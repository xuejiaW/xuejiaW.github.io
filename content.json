{"posts":[{"title":"《3D数学基础：图形和游戏开发》第一章笔记","text":"《3D数学基础：图形和游戏开发》第一章笔记 关于笛卡尔坐标系的介绍，如三维坐标种的左右手坐标系。 一些三角函数的介绍。 Chapter 1 在计算机三维数学和三维坐标的计算中，用的最频繁的框架就是笛卡尔坐标系（Cartesian coordinate system）。 1D Mathematics 有理数（Rational numbers）定义：可以表示为两个整数的比 实数定义：包括有理数和无理数（例如$\\pi$） 对于自然数和整数的研究称作为离散数学（Discrete Mathematics），对于实数的学习称为连续数学（Continuous Mathematics）。 图形学第一定理：如果看起来结果是对的，那么就是对的 If it looks right, it is right. 2D Cartesian Space 坐标轴的长度是无限的。 对于二维坐标而言，无论X轴和Y轴选取的方向如何，都能通过旋转（包括翻转）将其互相转换。如下图是二维坐标的一共8种可能（当X轴选定一个方向（X轴的选择有六种可能）时，Y轴因为必须与X轴垂直，所以只有两种可能，正向或反向）： 所以从某种角度而言，所有的二维坐标都是等效的。 3D Cartesian Space 所有的二维坐标是等效的，但所有的三维坐标并不是等效的。可以通过旋转或反转将三维坐标中的两个匹配，但在这种情况下第三个坐标的方向可能是反的。 三维坐标一共有48种可能（Z轴一共有6种可能，X和Y构成二维坐标，有8种可能，6*8 = 48）。 因此所有的三维坐标被分为两组，一组被称为左手坐标系（Left-handed coordinate spaces），另一组被称为右手坐标系（Right-handed coordinate spaces）。左右手坐标系只是不同的选择，两者其他方面的差异。 如下图所示，左边为左手坐标系，右边为右手坐标系。 在每个坐标系下，如图所示，食指，中指，大拇指相互垂直，大拇指指向X轴正方向，食指指向Y轴正方向，中指指向Z轴正方向。 左右手坐标系还会影响旋转的正方向。在每个坐标系下，如果要绕着某个轴旋转，用大拇指指向该轴的正方向，四指环绕方向即为旋转的正方向。 这本书下的例子都是以左手坐标系为准的。 Odds and Ends Summation and Product Notation 累加符号： $$ \\sum_{i=1}^{n}a_i $$ 累乘符号: $$ \\prod_{i=1}^{n}a_i $$ 间隔符号 $[a,b]$表示$a\\leq x\\leq b$ $(a,b)$表示$a&lt;x&lt;b$ $[a,b)$表示$a\\leq x &lt;b$ $(a,b]$表示$a&lt;x\\leq b$ Angles,Degrees, and Radians 角度（Angles）在日常生活中用的比较多，但是在数学上弧度（Radians）用的更多。 当提及弧度，实际上是计算某角度在半径为1的圆上所占的长度。因为半径为1的圆周长为$2\\pi$，所以$360^\\circ = 2\\pi 弧度$。 弧度与角度的转换关系如下： $$ 1\\text{ rad} = (180/\\pi)^\\circ \\approx 57.29578^\\circ \\\\ 1 ^ \\circ = (\\pi /180) \\text{ rad} \\approx 0.01745329 \\text{ rad} $$ Trig Functions 对于在半径为1的圆上的点$（x,y）$，$\\theta$为该点与原点形成的向量与X轴正方向的夹角，则 $$ x = \\cos(\\theta) \\\\ y = \\sin(\\theta) \\\\ $$ Trig Identities 基本转换 $$ \\sin(-\\theta)=-\\sin\\theta\\\\ \\cos(-\\theta)=\\cos\\theta\\\\ \\tan(-\\theta)=-\\tan\\theta \\\\ \\sin(\\frac{\\pi}{2}-\\theta) = \\cos\\theta\\\\ \\cos(\\frac{\\pi}{2}-\\theta) = \\sin\\theta\\\\ \\tan(\\frac{\\pi}{2}-\\theta) = \\cot\\theta\\\\ \\cos \\theta = -\\cos(180-\\theta)\\\\ \\sin \\theta = \\sin (180-\\theta) $$ 勾股定理 $$ \\sin^2\\theta+cos^2\\theta=1 \\\\ 1 + \\tan^2\\theta = \\sec^2\\theta \\\\ 1 + \\cot^2\\theta = csc^2 \\theta $$ $$ \\sin(a+b) = \\sin a \\cos b + \\cos a\\sin b \\\\ \\sin(a-b) = \\sin a \\cos b - \\ cos a \\sin b \\\\ \\cos(a+b) = \\cos a \\cos b -\\sin a \\sin b \\\\ \\cos(a-b) = \\cos a \\cos b + \\sin a \\sin b \\\\ \\tan(a+b) = \\frac{tan a+ tan b}{1- \\tan a\\tan b } \\\\ \\tan(a-b) = \\frac{tan a - tan b }{1+ \\tan a \\tan b} \\\\ $$ 两倍角定理 $$ \\sin 2\\theta = 2\\sin \\theta \\cos \\theta \\\\ \\cos 2\\theta = \\cos ^2 \\theta-\\sin^2\\theta=2cos^2\\theta-1=1-2sin^2\\theta \\\\ \\tan 2 \\theta=\\frac{2\\tan \\theta}{1- \\tan^2\\theta} $$ 正弦定理 对于如下的三角形，有： $$ \\frac{\\sin A}{a} = \\frac{\\sin B}{b}=\\frac{\\sin C}{c} $$ 余弦定理 对于上面的三角形，有 $$ a^2=b^2+c^2-2bc\\cos A, \\\\ b^2 = a^2 +c^2 - 2ac \\cos B, \\\\ c^2 = a^2 +b^2 -2ab \\cos C. $$ 引用： 3D Math Primer for Graphics and Game Development 2nd 2011","link":"/3DMathPrimerForGraphicsAGameDevelopment-Chapter1-Notes/"},{"title":"《3D数学基础：图形和游戏开发》第二章笔记","text":"《3D数学基础：图形和游戏开发》第二章笔记。 介绍了向量的数学计算以及对应的几何意义，在每一节的第一部分是数学计算，第二部分是几何意义。 Chapter 2 Mathematical Definition of Vector, and Other Boring Stuff 从数学角度看，向量（Vector）只是一个数字的数组。 数学上会区分向量和标量，带有方向的为向量，不带方向的为标量，如速度（有朝着某方向的含义在）是向量，位移是向量，而速率（仅仅是一个数字）是标量，距离是标量。 向量的维度表示一个向量中含有多少个数字。 向量通常通过方括号包裹，如果向量是水平方向的写，称其为行向量，否则为列向量，如： 行向量： $$ [1,2,3] $$ 列向量： $$ \\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\end{bmatrix} $$ 在这本书中： 标量用小写斜体表示：a,b,x,y 向量用小写粗体表示：a,b,u,v 矩阵用大写粗体表示：A,B,M,R 研究向量和矩阵的数学称为线性代数（linear algebra）。在线性代数中，$n$维度的向量和矩阵是用来求解有$n$个未知数的方程的。而在这本书中解释了向量和与矩阵的几何与几何意义。 Geometric Definition of Vector 从几何角度来说，向量是一条既有大小又有方向的线（有向线）。 向量并没有位置信息，大小和方向一致的向量出现在图中的什么位置并没有区别。 Specifying Vectors with Cartesian Coordinates Vector as a Sequence of Displacements 当向量出现在笛卡尔坐标系中，向量中的每个元素表示对应的坐标的位移。 如$[2,3]$表示X轴方向移动了2，y轴方向移动了3，位移的顺序并没有关系。 The Zero Vector 零向量是唯一一个没有方向的向量，在坐标系中，零向量不是一根线，而是一个点。 零向量是作为加法单位元（additive identity，加到别的元素上也不会造成区别的数字）。 Vectors versus Points 点（Points）表示位置，向量（Vectos）表示位移。 Relative Position 没什么关键信息。 The Relationship between Points and Vectors 所有关于位置的方法，都是相对的 向量$[x,y]$表示从原点到点$(x，y)$的位移。 点是位置，图像上表示为一个点。向量是位移，图像上表示为一个箭头。 It’s All Relative 非图形学相关内容，作者描述了世上其他的相对物体。 Negating a Vector 向量求反（Vector negating）：对于每个向量，都有一个相同维度的反向量，满足$v+(-v)=0$。 Offical Linear Algebra Rules 向量求反： $$ -\\begin{bmatrix} a_1 \\\\ a_2 \\\\ \\vdots \\\\ a_{n-1} \\\\ a_n \\\\ \\end{bmatrix}= \\begin{bmatrix} -a_1 \\\\ -a_2 \\\\ \\vdots \\\\ -a_{n-1} \\\\ -a_n \\\\ \\end{bmatrix} $$ Geometric Interpretation 向量求反几何意义：保持向量的大小，但是方向变反方向 Vector Multiplication by a Scalar 向量与标量相乘： $$ k\\begin{bmatrix} a_1 \\\\ a_2 \\\\ \\vdots \\\\ a_{n-1} \\\\ a_n \\\\ \\end{bmatrix}= \\begin{bmatrix} a_1 \\\\ a_2 \\\\ \\vdots \\\\ a_{n-1} \\\\ a_n \\\\ \\end{bmatrix}k= \\begin{bmatrix} ka_1 \\\\ ka_2 \\\\ \\vdots \\\\ ka_{n-1} \\\\ ka_n \\\\ \\end{bmatrix} $$ 向量与标量相乘，标量可以写在向量的左侧也可以写在右侧，但通常而言习惯性写在右侧 向量与标量相乘时不需要写乘号 标量不能被相乘除，向量不能除以另一个向量。 Geometric Interpretation 向量与标量相乘几何意义：大小乘以$|k|$，如果$k$是负数，则向量的方向取反，否则不变。 Vector Addition and Subtraction Official Linear Algebra Rules 向量相加： $$ \\begin{bmatrix} a_1 \\\\ a_2 \\\\ \\vdots \\\\ a_{n-1} \\\\ a_n \\\\ \\end{bmatrix}+ \\begin{bmatrix} b_1 \\\\ b_2 \\\\ \\vdots \\\\ b_{n-1} \\\\ b_n \\\\ \\end{bmatrix}= \\begin{bmatrix} a_1+b_1 \\\\ a_2+b_2 \\\\ \\vdots \\\\ a_{n-1}+b_{n-1} \\\\ a_n+b_n \\\\ \\end{bmatrix} $$ 向量相减： $$ \\begin{bmatrix} a_1 \\\\ a_2 \\\\ \\vdots \\\\ a_{n-1} \\\\ a_n \\\\ \\end{bmatrix}- \\begin{bmatrix} b_1 \\\\ b_2 \\\\ \\vdots \\\\ b_{n-1} \\\\ b_n \\\\ \\end{bmatrix}= \\begin{bmatrix} a_1-b_1 \\\\ a_2-b_2 \\\\ \\vdots \\\\ a_{n-1}-b_{n-1} \\\\ a_n-b_n \\\\ \\end{bmatrix} $$ 向量不能与标量相加或相减，也不能与维度不同的向量相加或相减 Geometric Interpretation 向量相加几何意义：如果是向量$a+b$，可以将a的头部与b的尾部向量，从a的尾部指向b的头部的向量即为加法结果，如下图所示： 向量相减几何意义：如果向量$d-c$，则将两个向量的尾部向量，从c头部指向d头部的向量即为减法结果，如下图所示： Displacement Vector from One Point to Another 当要计算从点a到点b的位移向量，可以通过$b-a$获得，如下图所示： Vector Magnitude(Length) 向量的大小也常称为向量的长度（Length）或向量的模（Norm）。 Official Linear Algebra Rules 求向量的大小： $$ \\Vert V \\Vert = \\sqrt{\\sum_{i=1}^{n}{v_i}^2} $$ 其中每个$v_i$表示向量$V$的一个维度，如x轴，y轴等 一些书用单条形符号表示，如$|v|$ 如果有向量a和b，则a,b满足： $$ \\Vert a \\Vert^2 + \\Vert b \\Vert^2 = \\Vert a+b \\Vert^2 \\\\ \\Vert a \\Vert + \\Vert b \\Vert\\geq \\Vert a+b \\Vert $$ Geometric Interpretation 求向量大小物理解释：求向量$V$的大小，类似于求直角三角形的第三条边长度，因此用类似于勾股定理的每条边平方相加，再开方。 对于任意正数值，有无数条向量的大小是该值。 Unit Vectors 单位向量（Unit vector）是长度为1的向量（并没有限定方向），单位向量也被称为归一化向量（normalized vectors）。 normalized vector表示是归一化向量即单位向量，长度为1的向量 normal vector表示法向量，是垂直于某个面的向量 Official Linear Algebra Rules 某个方向的单位向量可以通过这个方向的某向量除以它的大小得到，如 $$ \\hat = \\frac{v}{\\Vert v \\Vert} $$ 零向量不能被归一化 Geometric Interpretation 单位向量几何意义：在二维坐标系中，如果将无数的单位向量的尾部放在原点，则其顶点可以构成半径为1的圆。在三维坐标系中，如果将无数的单位向量的尾部放在原点，则其顶点可以构成半径为1的球。 The Distance Formula 求两向量的距离： $$ distance(u,v)=\\Vert v-u \\Vert=\\sqrt{\\sum_{i=1}^{n}{v_i-u_i}} $$ 其中$v_i$和$u_i$为向量$v$和$u$每个维度的值。 Vector Dot Product 向量点乘（dot product）又称为向量内积（inner product）。 Official Linear Algebra Rules 向量点乘时必须用一个使用点符号，如$a\\cdot b$。如果两个向量之间没有点符号，则会认为这两个向量要进行矩阵的乘法。 $$ \\begin{bmatrix} a_1 \\\\ a_2 \\\\ \\vdots \\\\ a_{n-1} \\\\ a_n \\\\ \\end{bmatrix}\\cdot \\begin{bmatrix} b_1 \\\\ b_2 \\\\ \\vdots \\\\ b_{n-1} \\\\ b_n \\\\ \\end{bmatrix}=\\sum_{i=1}^{n}{a_ib_i} $$ 向量的点乘是相互的，$a\\cdot b=a \\cdot b$ Geometric Interpretation Projection 点乘的第一个几何意义：投影 假设a是单位向量，则a与b的点乘,$\\hat{a}\\cdot b$表示为$b$在$a$上的投影的有向长度（因为点乘的结果是标量，所以这里的有向指的是正负，而不是方向）。如下图所示： 向量的点乘可以与标量的乘法相结合： $$ (ka)\\cdot b =k(a\\cdot b)=a\\cdot(kb) $$ 因此，上述关于单位向量的点乘可以推广到普通向量，即 向量a与向量b的点乘，结果为向量b在向量a上的有向投影长度(b的长度会影响该投影长度)乘以向量a的大小。 点乘满足加法与减法分配律即： $$ a\\cdot(b+c)=a\\cdot b+a\\cdot c $$ 点乘的第二个几何意义：计算分量 b在a上的投影实际上可以看作是b在a方向上的分量。因此还可以通过投影来将b拆分为两部分，平行于a的分量和垂直与a的分量，即 $$ b_\\Vert=(\\hat{a}\\cdot b)\\hat{a} \\\\ b_\\perp=b-(\\hat{a}\\cdot b)\\hat{a} $$ 点乘的第三个几何意义：计算角度 将投影的结果表示为三角形，如下所示： 单位向量$\\hat{a}$和单位向量$\\hat{b}$的点积为在a上的投影，即三角形的临边，所以角度$\\theta$可表示为： $$ cos\\theta=\\frac{\\hat{a}\\cdot\\hat{b}}{1}=\\hat{a}\\cdot\\hat{b} $$ 可以将其推广到普通的向量a和b，即 两个向量的点积等于这两个向量之间夹角的cos乘上两个向量的大小 $$ a\\cdot b= \\Vert a\\Vert \\Vert b\\Vert cos\\theta \\\\ \\theta=arccos(\\frac{a\\cdot b}{\\Vert a\\Vert \\Vert b\\Vert}) $$ 因此，如果点乘的两个向量夹角范围在$-90^\\circ \\sim 90^\\circ$,结果为正数。如果夹角为90°，结果为0。如果范围在$90^\\circ \\sim 270^\\circ$，结果为负数。如果是正数，则b和a是在指向同一个方向（比如都往前），而负数则表示指向不同方向（一个向前，一个向后）。 Vector Cross Product 向量与向量还有个计算称为叉乘（Cross product）。 Official Linear Algebra Rules 以三维向量的叉乘为例，表达式及计算如下： $$ \\begin{bmatrix} x_1 \\\\ y_1 \\\\ z_1 \\\\ \\end{bmatrix} \\times \\begin{bmatrix} x_2 \\\\ y_2 \\\\ z_2 \\\\ \\end{bmatrix}= \\begin{bmatrix} y_1z_2-z_1y_2 \\\\ z_1x_2-x_1z_2\\\\ x_1y_2-y_1x_2 \\end{bmatrix} $$ 当向量和点乘一起发生时，先计算叉乘，再计算点乘，即 $$ a\\cdot b \\times c = a\\cdot (b\\times c) $$ 形如$a\\cdot (b\\times c)$的表达式称为三重积。 叉乘是反交换的，即$a\\times b = -(b\\times a)$ 叉乘满足分配律，即$a\\times(b+c)=a\\times b + a\\times c$ 叉乘没有结合性，即$(a \\times b)\\times c \\neq a\\times(b\\times c)$ 标量与叉乘结合：即$k(a\\times b)=(ka)\\times b = a\\times(kb)$ Geometric Interpretation 叉乘返回的结果是垂直于两个叉乘向量的另一个向量，如下图所示： 其大小等于两个向量的大小乘上两个向量之间夹角的sin,该大小也等于由两个向量构成的平行四边形的面积。即 $$ \\Vert a\\times b \\Vert = \\Vert a\\Vert \\Vert b\\Vert \\sin \\theta $$ 叉乘结果的方向与左右手坐标系相关，如果表达式为$a \\times b$，将b的尾部与a的头部相连。在左手坐标系下，如果在形成的方向是顺时针的，则结果方向指向外侧，如果是逆时针，则指向内侧。在右手坐标系下，结果相反。如下图所示： 也可以用手来求叉乘结果方向，如果表达式为$a \\times b$，将大拇指指向a的方向，将食指指向b的方向，让中指与食指和大拇指垂直（像展示左右手坐标系那样），食指的方向即为叉乘结果方向。 Linear Algebra Identities 下表为向量计算定律，基本都在上面解释过了： 引用： 3D Math Primer for Graphics and Game Development 2nd 2011","link":"/3DMathPrimerForGraphicsAGameDevelopment-Chapter2-Notes/"},{"title":"《3D数学基础：图形和游戏开发》第三章笔记","text":"《3D数学基础：图形和游戏开发》第三章笔记 3.1节没什么关键信息。 3.2节介绍了世界坐标系，物体坐标系，摄像机坐标系，以及作者自己引入的直立坐标系。 3.3节介绍了坐标系转换时从移动物体出发和从移动坐标系出发的两种思考角度，还讨论了基本向量的选择问题。 3.4节讨论了嵌套坐标系存在的目的。 3.5节讨论了作者引入直立坐标系的初衷。 Chapter3 Multiple Coordinate Spaces Why Bother with Multiple Coordinate Spaces? 没什么关键信息 Some Useful Coordinate Spaces 之所以需要不同的坐标系，是因为一些信息仅在某些坐标系下是有意义的，或者只能在某坐标系下获得（或更容易得到）。 World Spaces 世界坐标系（World Spaces）是作为一个全局的存在，所有的其他坐标系都属于这个坐标系下。世界坐标系是需要关系的最大坐标系（类似于全集的概念）。 在不同的情况下，会有不同的世界坐标。 世界坐标系也被称为全局坐标系(Global coordinate space)或者统一坐标系（Universal coordinate space）。 Object Space 物体坐标系（Object Space）是属于每一个物体的，即每个物体都有自己的物体坐标系，当这个物体移动时，物体坐标系也相应移动。 “向右转”就是物体坐标系的概念，而“向东走”就是全局坐标系的概念。 在图形学中，物体坐标系也被称为模型坐标系（Model Space），模型的顶点信息就描述在该物体的模型坐标系下。 Camera Space 物体坐标系的一个重要特例就是摄像机坐标系（Camera Space），摄像机坐标系是关于用于渲染的视角的坐标系。 在摄像机坐标系下，$+X$轴指向右侧，$+Z$轴指向前方，$+Y$指向上方（注意本书采用的是左手坐标系，OpenGL采用的是右手坐标系）。 摄像机坐标系如下图所示： Upright Space 直立坐标系（Upright space）是这本书中提出的概念，是作为世界坐标和物体坐标转化过程中的中间变量存在，如下图所示： 直立坐标系的原点与物体坐标系相同，直立坐标系的方向与世界坐标系相同。下图为物体坐标系与世界坐标系经过直立坐标系转换的步骤： Basis Vectors and Coordinate Space Transformations 将一个坐标系下的坐标转换为另一个坐标系下的坐标称为坐标系转换（coordinate space transformation）。 Dual Perspectives 坐标系转换可以从两个角度来考虑： 主动转换（Active Transformation）：两个坐标系保持不动，物体的坐标进行转换 被动转换（Pasison Transformation）：物体保持不动，坐标系进行转换 只需要注意的是，在从两个角度思考时，位移的方向是不同的。如上图从世界坐标转换到直立坐标系的过程，如果思考角度是移动物体，那么物体是向左下移动，到了原点；如果是从移动坐标系角度考虑，坐标系是向右上移动，到了原点。 另一点是，在进行旋转操作时，要保证物体处于当前坐标系的原点，因为一个坐标系下的旋转操作都是基于该坐标系的原点的。 所以在上图中，当从世界坐标系转换到本地坐标系时，会先移动转换到直立坐标系，因为前者坐标系物体不在原点，而后者在。同理在从本地坐标系转换到世界坐标系时，会先进行旋转，因为此时物体已经在原点了。 Specifying Coordinate Spaces 坐标系是由原点和坐标轴两部分决定的，坐标轴是相对与自己原点而言的“上”，“右”，“前”。 一个坐标系的原点和坐标轴是相对于另一个坐标系的。 如在展示三个坐标系的上图中，如果说机器人的高度是5.5。那么直立坐标系的原点在世界坐标系中的位置大约在$(4.5,1.5)$，而物体坐标系中的$(1,0)$点，在直立坐标系下大约是$(0.87,0.5)$，物体坐标系中的$(0,1)$点，在直立坐标系下大约是$(-0.5,0.87)$。在直立坐标系中，向量$(0.87,0.5)$的角度大约是30°，因此两个坐标系的原点位置差距为$(4.5,1.5)$，角度差距在30°。 Basis Vectors 如果在物体坐标系下一个点的位置是$(-1,5)$，那么它在世界坐标系下的位置可以按以下公式进行计算： $$ w=o+b_xp+b_yq $$ 其中$b$为点在物体坐标系下的位置，即$(-1,5)$，$w$为点在世界坐标系下的位置，$o$为物体坐标系的原点在世界坐标系中的位置，在上例中为$(4.5,1.5)$，$p$为物体坐标系X轴在世界坐标系中的表示，在上例中为$(0.87,0.5)$，$q$为物体坐标系Y轴在世界坐标系中的表示，在上例中为$(-0.5,0.87)$。 将所有数据带入上式，可以算出该点在世界坐标系下的坐标为$(-1.13,5.35)$。计算如下： $$ w=(4.5,1.5)+(-1)(0.87,0.5)+5(-0.5,0.87)=(-1.13,5.35) $$ 可以将上述公式简化，即不再将“点”作为考虑的对象，而是描述向量。因为是向量所以也就不需要考虑位移。如果上述公式不考虑位移（可以假象为两个坐标系的原点是重叠的），且推广至三维空间，可表示为： $$ v=xp+yq+zr $$ 式中的$v$是目标坐标系下的坐标，$x,y,z$是当前坐标系下的选取的三条基本向量上的分量，$p,q,r$为三条基本向量在目标坐标系$v$上的表示。 如上例中，因为是二维空间，只有两条基本向量，选取的分别是X轴和Y轴，对应的P为$(0.87,0.5)$，对应的q为$(-0.5，0.87)$。 如有物体坐标系下的向量$b=[b_x,b_y,b_z]$，对应世界坐标系下的向量$u=[u_x,u_y,u_z]$，$p,q,r$为物体坐标系下选取的三条基本向量在世界坐标系下的表示。套用上述的公式，可表示为 $$ u=b_xp+b_yq+b_zr \\text{ 或者表达为 } \\begin{aligned} u_x=b_xp_x+b_yq_x+b_zr_x\\\\ u_y=b_xp_y+b_yq_y+b_zr_y\\\\ u_z=b_xp_z+b_yq_z+b_zr_z\\\\ \\end{aligned} $$ 注意$p,q,r$三个向量实际上都是在世界坐标系下的表示，即$u,p,q,r$是属于一个坐标系下。 如果知道了向量$b$，求向量$u$只需要套用公式即可。但如果知道了向量$u$想求向量$b$，则需要解一个三元方程（$b_x,b_y,b_z$都是未知量）。 如果一系列向量满足，向量互相垂直，即正交（orthogonal）和向量的长度都为1，则称这些向量为标准正交基（orthonormal），如果基本向量是标准正交基，则求$b$的过程可以从解三元方程简化为以下公式： $$ b_x=u\\cdot p \\\\ b_y=u\\cdot q \\\\ b_z = u\\cdot r $$ 之所以可以这样简化，是因为： 点乘的物理意义有求在某个分量上的长度，所以可以通过点乘来计算。 如果三条基本向量不是相互垂直的，那么在一条基本向量上值增加，会导致另一条基本向量上的值也增加。 如基本向量选取为$(1,0)$和$(1,1)$，如果点从$(1,1)$位移到$(2,2)$点上，虽然是在基本向量$(1,1)$上移动的，但同样会增加在$(1,0)$上的值。 这样的话在上述公式中，则会出现$b_x$的值不仅与$p$有关，还可能与$q$有关。 $a\\cdot b$的结果还与$b$的长度有关，为了避免这个影响，所以取$p,q,r$都为1 选取的基本向量通常都需要是线性无关的（Linearly Independent），即任意一个向量不能通过其他向量的线性组合表示出来。否则的话，n个向量无法描述n维空间中的所有向量，在线性代数中，将通过基本向量能表述的空间维度称为秩(rank) 对于基本向量不是标准正交基的情况，将在第六章中说明。 通常而言，对于三维空间而言，基本向量的选取都是X,Y,Z轴。 Nested Coordinate Spaces 因为通常而言，物体坐标系最后都要基于世界坐标系进行计算，如把不同的物体放在世界中的过程。 因此可以称世界坐标系是父空间，物体坐标系是子空间。 而物体坐标系可以进一步划分，如将一只羊作为物体坐标系，可以再进一步将其头作为物体坐标系的子坐标系，称为头坐标系。同理头坐标系下还可以耳朵坐标系等。 这种将不同部分层层划分的模型称为关节模型（articulated model）。 一些运动在各自的坐标系下计算是很简单的，但是放在世界坐标系下将会很复杂。如羊一边走，一边摇头，一边上下翻动耳朵。对于耳朵坐标系而言，这只是Y轴的变化，但是对于世界坐标系而言，就是耳朵的运动轨迹就非常复杂了。 当知道了物体在一个子坐标系下的位置，可以通过坐标系之间的相对位置来进行转换。这部分会在之后章节详细说明。 In Defense of Upright Space 当将点从物体坐标系转换到世界坐标系时，不仅需要进行旋转操作，还需要进行位移操作。 当将向量从物体坐标系转换到世界坐标系时，仅需要旋转操作。 但物体和点在代码中通常都是用同一个类型来表示的，如flaot3。因此需要一个方法来区分操作究竟是针对点还是向量，有的人将flaot3取别名，如变成point和vector，有的人则是通过计算过程，如将旋转操作和位移操作分开，在处理点的时候，使用位移操作。 作者在这里提出的直立坐标系（Upright Space）则是另一种表达，设想是，当使用世界坐标系时，则表示这个操作是需要进行位移的，而使用直立坐标系时，则是不需要位移。 引用： 3D Math Primer for Graphics and Game Development 2nd 2011","link":"/3DMathPrimerForGraphicsAGameDevelopment-Chapter3-Notes/"},{"title":"《3D数学基础：图形和游戏开发》第四章笔记","text":"《3D数学基础：图形和游戏开发》第四章笔记 这一节简单的介绍了矩阵的一些基础性质： 4.1 关于矩阵的一些数学特性 4.2 关于矩阵是用来表达线性变换的几何意义 4.3 介绍了矩阵在线性代数中还可以用于解方程组 Introduction to Matrices 矩阵是3D数学的重要部分，它主要被使用在不同的坐标系之间的转换。 Mathematical Definition of Matrix 在线性代数中，矩阵是由一系列数字按行和列排布组成。可以将向量看作是标量的集合，把矩阵看作是向量的集合。 Matrix Dimensions and Notation 将一个有$r$行，$c$列的矩阵称为是$r\\times c$矩阵，矩阵中的数字由方括号包围，如下为一个$3 \\times 3$的矩阵， $$ M=\\begin{bmatrix} m_{11}&amp;m_{12}&amp;m_{13}\\\\ m_{21}&amp;m_{22}&amp;m_{23}\\\\ m_{31}&amp;m_{32}&amp;m_{33}\\\\ \\end{bmatrix} $$ 在这本书中，所有的矩阵都用大写粗体表示，如$\\mathbf{M}$，用$m_{ij}$表示$\\mathbf{M}$中第i行，第j列的元素。 Square Matrices 将行数和列数相同的矩阵，称为方阵（Square Matrices）。 将下标的行数和列数相同的元素，称为对角元素（Diagonal elements），如上矩阵中的$m_{11}$,$m_{22}$,$m_{33}$为对角元素。 如果一个矩阵（并不一定是方阵）中，所有的非对角元素都是0，那么整个矩阵称为对角矩阵（diagonal matrix）。如下 $$ \\begin{bmatrix} 3&amp;0&amp;0&amp;0\\\\ 0&amp;1&amp;0&amp;0\\\\ 0&amp;0&amp;-5&amp;0\\\\ 0&amp;0&amp;0&amp;2\\\\ \\end{bmatrix} $$ 在对角矩阵中，如果所有的元素都为1，那么就变成了单位矩阵（Identity Matrix），单位矩阵通常用$\\mathbf{I}$表示，如下 $$ \\begin{bmatrix} 1&amp;0&amp;0&amp;0\\\\ 0&amp;1&amp;0&amp;0\\\\ 0&amp;0&amp;1&amp;0\\\\ 0&amp;0&amp;0&amp;1\\\\ \\end{bmatrix} $$ 如果一个矩阵与单位矩阵相乘，那么得到的还是该矩阵本身。 Vectors as Matrices 向量可以看作是一个$1\\times n$或者$n \\times 1$的矩阵，即$1\\times n$的矩阵可以称为行向量，$n\\times 1$可以称为列向量。 Matrix Transposition 给定一个$r\\times c$矩阵$\\mathbf{M}$，其转置写为$\\mathbf{M^T}$，转置矩阵是一个$c\\times r$的矩阵。其中$\\mathbf{M}$中的行变为$\\mathbf{M^T}$中的列，即$\\mathbf{M^T_{ij}}=\\mathbf{M_{ji}}$。如下： $$ {\\begin{bmatrix} a&amp;b&amp;c\\\\ d&amp;e&amp;f\\\\ g&amp;h&amp;i\\\\ \\end{bmatrix}}^T= \\begin{bmatrix} a&amp;d&amp;g\\\\ b&amp;e&amp;h\\\\ c&amp;f&amp;i\\\\ \\end{bmatrix} $$ $$ {\\begin{bmatrix} x &amp; y &amp;z \\end{bmatrix}}^T=\\begin{bmatrix} x\\\\ y\\\\ z\\\\ \\end{bmatrix} $$ 转置矩阵有如下性质： 矩阵转置的转置等于本身，$(\\mathbf{M^T})^T=\\mathbf{M}$ 如果一个矩阵的转置等于矩阵本身，那么$\\mathbf{D^T}=\\mathbf{D}$，那么这个矩阵就是是单位矩阵。 Multiplying a Matrix with a Scalar $$ kM=k\\begin{bmatrix} m_{11}&amp;m_{12}&amp;m_{13}\\\\ m_{21}&amp;m_{22}&amp;m_{23}\\\\ m_{31}&amp;m_{32}&amp;m_{33}\\\\ \\end{bmatrix}= \\begin{bmatrix} km_{11}&amp;km_{12}&amp;km_{13}\\\\ km_{21}&amp;km_{22}&amp;km_{23}\\\\ km_{31}&amp;km_{32}&amp;km_{33}\\\\ \\end{bmatrix} $$ Multiplying Two Matrices 对于$r\\times n$的矩阵$\\mathbf{A}$，如果与$n\\times c$的矩阵$\\mathbf{B}$相乘，结果为$r\\times c$的矩阵$\\mathbf{AB}$ 对于两个矩阵相乘，前者的列数必须与后者的行数匹配，如下： 假设将相乘结果中的每个元素称为$c_{ij}$，其值为前者的第$i$行中所有元素与后者的第$j$列中的元素一一相乘并累加，即 $$ c_{ij}=\\sum_{k=1}^{n}a_{ik}b_{kj} $$ 如下： 矩阵相乘有如下性质： $\\mathbf{MI=IM=M}$ 矩阵的相乘不是可交换的，$\\mathbf{AB\\neq BA}$ 矩阵的相乘满足结合律，$\\mathbf{(AB)C=A(BC)}$。矩阵与标量和向量同样满足结合性，即 $$ \\mathbf{(kA)B=k(AB)=A(kB)}，\\\\ \\mathbf{(vA)B=v(AB)} $$ 乘积的转置，等于乘数与被乘数的转置以相反的顺序相乘，$\\mathbf{(AB)^T=B^TA^T}$ Multiplying a Vector and a Matrix 如有向量和矩阵的乘法如下： $$ \\begin{bmatrix} x &amp; y &amp;z \\end{bmatrix}\\begin{bmatrix} m_{11}&amp;m_{12}&amp;m_{13}\\\\ m_{21}&amp;m_{22}&amp;m_{23}\\\\ m_{31}&amp;m_{32}&amp;m_{33}\\\\ \\end{bmatrix}= \\\\ \\begin{bmatrix} xm_{11}+ym_{21}+zm_{31} &amp; xm_{12}+ym_{22}+zm_{32} &amp;xm_{13}+ym_{23}+zm_{33} \\end{bmatrix} $$ $$ \\begin{bmatrix} m_{11}&amp;m_{12}&amp;m_{13}\\\\ m_{21}&amp;m_{22}&amp;m_{23}\\\\ m_{31}&amp;m_{32}&amp;m_{33}\\\\ \\end{bmatrix} \\begin{bmatrix} x\\\\ y\\\\ z\\\\ \\end{bmatrix}= \\begin{bmatrix} xm_{11}+ym_{12}+zm_{13}\\\\ xm_{21}+ym_{22}+zm_{23}\\\\ xm_{31}+ym_{22}+zm_{33}\\\\ \\end{bmatrix} $$ 向量和矩阵的乘法有以下特性： 结果的每个元素，相当于原向量与矩阵不同列的点积（如果是矩阵与列向量相乘，则是与矩阵不同行的点积） 矩阵中的每个元素相当于是控制输入向量的某个元素在输出某个元素上的占比。如$m_{12}$就是控制输入的$x$元素，在输出的$y$元素上的占比。所以对输入的向量而言，所有控制输入向量X分量的元素都在第一行，所有控制Y分量的元素都在第二行，所有控制Z分量的元素都在第三行，即矩阵的每一行都代表一个基础向量（类似于X轴，Y轴）。 元素和向量的成绩满足分配律，如$\\mathbf{(v+w)M=vM+wM}$ Row versus Column Vectors 行向量与列向量本质上并没有区别，但需要注意使用行列向量与矩阵相乘时的顺序是不同的。假设向量$\\mathbf{v}$需要与矩阵$\\mathbf{A,B,C}$依次相乘。如果$\\mathbf{v}$是列向量，那么向量应该出现在右侧，即写为$\\mathbf{vABC}$。如果$\\mathbf{v}$是行向量，那么向量应该出现在右侧，即写为$\\mathbf{CBAv}$。 且行向量与列向量与同一个矩阵相乘后，对应的元素是不同的（如行向量计算结果的第一个元素与列向量计算结果的第一个元素不同）。因此如果想要使用行向量进行计算和使用列向量进行计算的结果向量元素一一对应相等的话，则它们各自使用的矩阵必须是不同的，且为转置关系。 行向量的优点在于，阅读的顺序和相乘的顺序是一致的，即从左到右，而列向量乘积的相乘顺序则是从右到左，但行向量的主要缺点在于，当向量的维度增加时，会让表达式变得非常的长，造成书写的不便，而使用列向量就不会有这个问题。 对于数学家而言，因为需要用到推到，所以他们更喜欢用写起来较短的列向量表达式。而对于计算机而言，因为没有书写的问题，所以更喜欢阅读和相乘顺序相同的行向量，本书也是使用行向量作为与矩阵相乘的向量，之后章节计算出的各种变换矩阵都是基于行向量的，如果要使用在列向量的计算环境下，需要进行转置。 DirectX使用行向量，OpenGL使用列向量。当使用别人的表达式或者代码时，需要特别注意它使用的是行向量还是列向量。 Geometric Interpretation of Matrix 从几何意义角度来说，方阵可以描述任何的线性变化（Linear transformation）。 线性变化保证了图形中的线条不会被弯曲，且线条们的平行性质不会给改变，但其他的几何性质，如角度，面积，体积，长度都可能发现变化。线性变化包括： 旋转(Rotation) 缩放(Scale) 正交投影(Orthographic projection) 反射(Reflection) 切边（shearing） Multiplying a Vector and a Matrix 假设$\\mathbf{i}=[1,0,0],\\mathbf{j}=[0,1,0],\\mathbf{k}=[0,0,1]$，矩阵$\\mathbf{M}$为 $$ \\begin{bmatrix} m_{11}&amp;m_{12}&amp;m_{13}\\\\ m_{21}&amp;m_{22}&amp;m_{23}\\\\ m_{31}&amp;m_{32}&amp;m_{33}\\\\ \\end{bmatrix} $$ 则向量$\\mathbf{v}=v_x\\mathbf{i}+v_y\\mathbf{j}+v_z\\mathbf{k}$。且矩阵和向量的乘法可以看作为： $$ \\mathbf{vM}=(v_x\\mathbf{i}+v_y\\mathbf{j}+v_z\\mathbf{k})M \\\\ =(v_x\\mathbf{i})\\mathbf{M}+(v_y\\mathbf{j})\\mathbf{M}+(v_z\\mathbf{k})\\mathbf{M}\\\\ =v_x(\\mathbf{i}\\mathbf{M})+v_y(\\mathbf{j}\\mathbf{M})+v_z(\\mathbf{k}\\mathbf{M})\\\\ =v_x\\begin{bmatrix}m_{11} &amp; m_{12} &amp;m_{13} \\end{bmatrix}+v_y\\begin{bmatrix}m_{21} &amp; m_{22} &amp;m_{23} \\end{bmatrix}\\\\ +v_z\\begin{bmatrix}m_{31} &amp; m_{32} &amp;m_{33} \\end{bmatrix} $$ 可以将矩阵的每一行看作是一个基本向量，即$\\begin{bmatrix}m_{11} &amp; m_{12} &amp;m_{13} \\end{bmatrix}$，$\\begin{bmatrix}m_{21} &amp; m_{22} &amp;m_{23} \\end{bmatrix}$和$\\begin{bmatrix}m_{31} &amp; m_{32} &amp;m_{33} \\end{bmatrix}$都是基本向量，将其命名为$\\mathbf{p,q,r}$，则上式结果可以改写为 $$ \\mathbf{vM}=v_x\\mathbf{p}+v_y\\mathbf{q}+v_z\\mathbf{r} $$ 与原式$\\mathbf{v}=v_x\\mathbf{i}+v_y\\mathbf{j}+v_z\\mathbf{k}$比较，可以得出，原来的基本向量$\\mathbf{i,j,k}$经过了线性变化，变成了新的基本向量$\\mathbf{p,q,r}$，不同的的基本向量就构成了不同的坐标系。 可以通过上述的方法来直接判断一个方阵所代表的线性变化，方阵的每一行都是变换后的基本向量，如有方阵 $$ \\mathbf{M}= \\begin{bmatrix} 2 &amp; 1 \\\\ -1 &amp; 2 \\end{bmatrix} $$ 其中，$\\mathbf{p}=\\begin{bmatrix}2 &amp;1 \\end{bmatrix},\\mathbf{q}=\\begin{bmatrix}-1 &amp;2 \\end{bmatrix}$。即原坐标$(0,1)$变成了$(2,1)$，原坐标$(1,0)$变成了坐标$(-1,2)$，如下图所示： 如果对一个二维图片使用该矩阵进行变化，则如下图所示： 对于三维矩阵同样如此，如有三维矩阵 $$ \\begin{bmatrix} 0.707 &amp; -0.707 &amp; 0 \\\\ 1.25 &amp; 1.25 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 \\\\ \\end{bmatrix} $$ 将其用于三维模型的坐标变化，则结果如下图所示： 如同可以通过矩阵来直接判断出基本向量的变换，也可以直接通过基本向量的变换来构建出矩阵，只要将对应的基本向量填入每一行即可。 $n$维方阵在$n$维度下只能描述线性变化。因为$n$维的零向量与$n$维矩阵相乘的结果为零向量，即没有任何的位移变换发生。 The Bigger Picture of Linear Algebra 矩阵在线性代数中，主要用于解决方程组问题，如有方程 $$ -5x_1+x_2+x_3=-10, \\\\ 2x_1+x_2+4x_3=12, \\\\ x_1-3x_3=9, \\\\ $$ 可以用矩阵表达为： $$ \\begin{bmatrix} -5 &amp; 1 &amp;1 \\\\ 2&amp; 2&amp;4 \\\\ 1&amp; 0&amp;-3 \\\\ \\end{bmatrix} \\begin{bmatrix} x_1 \\\\ x_2 \\\\ x_3 \\end{bmatrix}= \\begin{bmatrix} -10 \\\\ 12\\\\ 9 \\end{bmatrix} $$ 即可以通过矩阵的变换求出方程组的解。 线性代数在解方程组方面的应用在这本书中不多，但在一些更深入的主题，如物理引擎和渲染方面则有很多应用。 引用： 3D Math Primer for Graphics and Game Development 2nd 2011","link":"/3DMathPrimerForGraphicsAGameDevelopment-Chapter4-Notes/"},{"title":"《3D数学基础：图形和游戏开发》第五章笔记","text":"《3D数学基础：图形和游戏开发》第五章笔记 5.1-5.5 介绍了五种线性变换，旋转，缩放，正交投影，反射，切变。 5.6 介绍了线性变化的结合。 5.7 介绍了变换的种类，包括线性变换和仿射变换。还有各种其他的分类方式，如可逆变换，保角变换等。 Chapter 5 Matrices and Linear Transformations 这一章将主要介绍使用$3\\times 3$矩阵进行三维孔径啊下的线性变化（Linear Transformations）。线性变化是不包含位移的，包含了位移的变换称为仿射变换（Affine Transformation）。对于一个$N$维的方阵，是不可能你表达出$N$维的仿射变换的。 这一章中推到出变换矩阵的方法还是通过先计算出基础向量经过变换后的向量，然后将变换后向量依次填入矩阵的每一行，形成变换矩阵。 Rotation Rotation in 2D 在二维空间中的旋转是基于一个点的。对于基于原点的二维旋转，只有一个变量即旋转角度$\\theta$，而且通常而言顺时针旋转为正方向，逆时针旋转为反方向。 旋转矩阵如下： $$ \\mathbf{R}(\\theta)=\\begin{bmatrix} \\cos\\theta &amp; \\sin\\theta \\\\ -\\sin\\theta &amp; \\cos\\theta \\\\ \\end{bmatrix} $$ 其中的每一行都是变换后的标准向量，即将$(1,0)$，变为了$(\\cos\\theta , \\sin\\theta)$，将$(0,1)$变成了$( -\\sin\\theta , \\cos\\theta )$，如下图所示： 3D Rotation about Cardinal Axes 这里讨论的三维旋转矩阵也同样是基于原点旋转的，但在三维空间中，可以围绕不同的轴进行旋转，这里首先给出基于三个向量轴的旋转： 绕着X轴的计算矩阵如下： $$ R_x(\\theta)=\\begin{bmatrix} 1&amp;0 &amp;0\\\\ 0&amp; \\cos\\theta&amp;\\sin\\theta\\\\ 0&amp; -sin\\theta&amp;\\cos\\theta\\\\ \\end{bmatrix} $$ 绕着Y轴的计算矩阵如下： $$ R_y(\\theta)=\\begin{bmatrix} \\cos\\theta&amp;0 &amp;-\\sin\\theta\\\\ 0&amp; 1&amp;0\\\\ \\sin\\theta&amp;0 &amp;\\cos\\theta\\\\ \\end{bmatrix} $$ 绕着Z轴的计算矩阵如下： $$ R_z(\\theta)=\\begin{bmatrix} \\cos\\theta&amp; \\sin\\theta&amp;0\\\\ -\\sin\\theta&amp; \\cos\\theta&amp;0\\\\ 0&amp;0 &amp;1\\\\ \\end{bmatrix} $$ 三个矩阵的推导同样是通过基本向量的变换。如果某个轴作为旋转轴，那么这个轴在旋转过程中是不会发生变化的，而剩下的两个轴就可以看作是一个二维空间的旋转，如下图是当旋转轴是Y轴的示意图： 3D Rotation about an Arbitrary Axis 向量绕着任意轴$n$(穿过原点的轴)旋转$\\theta$角度的计算表达式如下： $$ R({\\hat{n},\\theta})= \\begin{bmatrix} {n_x}^2(1-\\cos \\theta) + \\cos\\theta &amp; n_xn_y(1-\\cos \\theta)+n_z\\sin\\theta &amp; n_xn_z(1-\\cos \\theta) -n_y\\sin\\theta \\\\ n_xn_y(1-\\cos \\theta) -n_z\\sin\\theta &amp; {n_y}^2(1-\\cos \\theta)+\\cos\\theta &amp; n_yn_z(1-\\cos \\theta) +n_x\\sin\\theta \\\\ n_xn_z(1-\\cos \\theta) +n_y\\sin\\theta &amp; n_yn_z(1-\\cos \\theta)-n_x\\sin\\theta &amp; {n_z}^2(1-\\cos \\theta) +\\cos \\theta \\end{bmatrix} $$ 推导过程如下： 针对对于任意轴的旋转矩阵，思路同样是求基本向量在旋转后的结果。向量$\\mathbf{v}$在绕任意轴$n$旋转$\\theta$角度后变为$\\mathbf{v^{'}}$，表达式为： $$ \\mathbf{v^{'}}=\\mathbf{v}\\mathbf{R}(\\hat{\\mathbf{n}},\\theta) $$ 求解过程如下： 为了方便计算，将向量$v$拆成两部分$v_{\\parallel}$和$v_{\\perp}$，分别表示平行于和垂直于旋转轴$n$的分量。在旋转过程中，平行于旋转轴$n$的分量$v_{\\parallel}$是不会发生变化的，因此要求的只是旋转后的$v^{'}_{\\perp}$ 整个旋转的示意图如下： $v_{\\parallel}$可以通过点积求得，即$\\mathbf{ v_{\\parallel}=(v\\cdot\\hat{n})\\hat{n}}$ $v_{\\perp}$可以通过$v$减去$v_{\\parallel}$得到，即$\\mathbf{v_{\\perp}=v-v_{\\parallel}}$ 图中的$w$向量是为了与向量$v_{\\perp}$构成一个平面，$w$向量的长度与$v_{\\perp}$相同，且垂直于$\\hat{n}$和$v_{\\perp}$，所以可得$\\mathbf{w=\\hat{n}\\times v_{\\perp}}$ 此时,$w$和$v_{\\perp}$构成了一个二维平面，根据二维平面的旋转可得，$v_{\\perp}^{'}=\\cos \\theta v_{\\perp} + \\sin\\theta w$ 结合上面所有的式子，可推导出$v^{‘}$的公式，即 $$ \\mathbf{v^{’}=V_{\\perp}^{'}+v_{\\parallel}}\\\\ =\\mathbf{\\cos \\theta v_{\\perp} + \\sin\\theta w+(v\\cdot\\hat{n})\\hat{n}} \\\\ =\\cos\\theta(v-(v\\cdot\\hat{n})\\hat{n})+\\sin\\theta (\\hat{n}\\times v_{\\perp})+(v\\cdot\\hat{n})\\hat{n} \\\\ =\\cos\\theta(v-(v\\cdot\\hat{n})\\hat{n})+\\sin\\theta (\\hat{n}\\times(v-v_{\\parallel}))+(v\\cdot\\hat{n})\\hat{n} \\\\ =\\cos\\theta(v-(v\\cdot\\hat{n})\\hat{n})+\\sin\\theta (\\hat{n}\\times v-\\hat{n} \\times v_{\\parallel})+(v\\cdot\\hat{n})\\hat{n} \\\\ =\\cos\\theta(v-(v\\cdot\\hat{n})\\hat{n})+\\sin\\theta (\\hat{n}\\times v-0)+(v\\cdot\\hat{n})\\hat{n} \\\\ =\\cos\\theta(v-(v\\cdot\\hat{n})\\hat{n})+\\sin\\theta (\\hat{n}\\times v)+(v\\cdot\\hat{n})\\hat{n} $$ 即最终用$\\hat{n}，\\theta，v$表达$v^{'}$的式子为： $$ v^{'}=\\cos\\theta(v-(v\\cdot\\hat{n})\\hat{n})+\\sin\\theta (\\hat{n}\\times v)+(v\\cdot\\hat{n})\\hat{n} $$ 将$p=\\begin{bmatrix} 1 &amp; 0&amp; 0\\end{bmatrix}$作为$v$代数上式，得: $$ v^{‘}=p^{’}=\\cos\\theta({\\begin{bmatrix} 1\\\\0\\\\0 \\end{bmatrix}}^T-n^x{\\begin{bmatrix} n^x\\\\n^y\\\\n^z \\end{bmatrix}}^T)+ sin\\theta {\\begin{bmatrix} 0\\\\n_z\\\\-n_y \\end{bmatrix}}^T+n^x{\\begin{bmatrix} n^x\\\\n^y\\\\n^z \\end{bmatrix}}^T $$ 其中：$\\hat{n}={\\begin{bmatrix} n^x\\\\n^y\\\\n^z \\end{bmatrix}}^T$，且$\\hat{n}\\times v={\\begin{bmatrix} 0\\\\n^z\\\\-n^y \\end{bmatrix}}^T$ 原式可继续化简： $$ p^{‘}=v^{’}=\\cos\\theta({\\begin{bmatrix} 1\\\\0\\\\0 \\end{bmatrix}}^T-n^x{\\begin{bmatrix} n^x\\\\n^y\\\\n^z \\end{bmatrix}}^T)+ sin\\theta {\\begin{bmatrix} 0\\\\n_z\\\\-n_y \\end{bmatrix}}^T+n^x{\\begin{bmatrix} n^x\\\\n^y\\\\n^z \\end{bmatrix}}^T \\\\ ={\\begin{bmatrix} \\cos\\theta(1-{n_x}^2)+0+{n_x}^2\\\\ \\cos\\theta(0-n_xn_y)+\\sin\\theta n_z+n_xn_y\\\\ \\cos\\theta(0-n_xn_z)-\\sin\\theta n_y +n_xn_z \\end{bmatrix}}^T \\\\ ={\\begin{bmatrix} {n_x}^2(1-\\cos \\theta) + \\cos\\theta \\\\ n_xn_y(1-\\cos \\theta)+n_z\\sin\\theta \\\\ n_xn_z(1-\\cos \\theta) -n_y\\sin\\theta \\end{bmatrix}}^T $$ 使用相同的步骤，可以计算出当输入$v=q=\\begin{bmatrix} 0 &amp; 1&amp; 0\\end{bmatrix}$时，结果$q^{'}$值为： $$ q^{'}={\\begin{bmatrix} n_xn_y(1-\\cos \\theta) -n_z\\sin\\theta \\\\ {n_y}^2(1-\\cos \\theta)+\\cos\\theta \\\\ n_yn_z(1-\\cos \\theta) +n_x\\sin\\theta \\end{bmatrix}}^T $$ 当输入为$r=q=\\begin{bmatrix} 0 &amp; 0&amp; 1\\end{bmatrix}$，结果$r^{'}$值为： $$ r^{'}={\\begin{bmatrix} n_xn_z(1-\\cos \\theta) +n_y\\sin\\theta \\\\ n_yn_z(1-\\cos \\theta)-n_x\\sin\\theta \\\\ {n_z}^2(1-\\cos \\theta) +\\cos \\theta \\end{bmatrix}}^T $$ 将每个变换后的基本矩阵，即$p^{‘},q^{’},r^{'}$放入变换矩阵的每一行，即为所需要求的绕着任意轴旋转的变换矩阵，即： $$ R({\\hat{n},\\theta})= \\begin{bmatrix} {n_x}^2(1-\\cos \\theta) + \\cos\\theta &amp; n_xn_y(1-\\cos \\theta)+n_z\\sin\\theta &amp; n_xn_z(1-\\cos \\theta) -n_y\\sin\\theta \\\\ n_xn_y(1-\\cos \\theta) -n_z\\sin\\theta &amp; {n_y}^2(1-\\cos \\theta)+\\cos\\theta &amp; n_yn_z(1-\\cos \\theta) +n_x\\sin\\theta \\\\ n_xn_z(1-\\cos \\theta) +n_y\\sin\\theta &amp; n_yn_z(1-\\cos \\theta)-n_x\\sin\\theta &amp; {n_z}^2(1-\\cos \\theta) +\\cos \\theta \\end{bmatrix} $$ Scale Scaling along the Cardinal Axes 缩放效果如下图所示： 对于基本向量而言，在进行了缩放操作后，其变为： $$ p^{‘}=k_xp=kx\\begin{bmatrix}1&amp; 0 &amp;0\\end{bmatrix} =\\begin{bmatrix} k_x&amp;0&amp;0\\end{bmatrix}，\\\\ q^{’}=k_yq=ky\\begin{bmatrix}0&amp; 1&amp;0\\end{bmatrix} =\\begin{bmatrix} 0&amp;k_y&amp;0\\end{bmatrix}，\\\\ r^{'}=k_zr=kz\\begin{bmatrix}0&amp; 0&amp;1\\end{bmatrix} =\\begin{bmatrix} 0&amp;0&amp;k_z\\end{bmatrix}，\\\\ $$ 将其带入缩放矩阵的每一行，可得，如果缩放的方向是基本向量的话，那么缩放矩阵为： $$ S(k_x,k_y,k_z)=\\begin{bmatrix} k_x&amp;0 &amp;0 \\\\ 0&amp;k_y &amp;0 \\\\ 0&amp;0 &amp;k_z \\\\ \\end{bmatrix} $$ 如果使用一个向量与该矩阵相乘，得 $$ \\begin{bmatrix}x&amp;y&amp;z \\end{bmatrix} \\begin{bmatrix} k_x&amp;0 &amp;0 \\\\ 0&amp;k_y &amp;0 \\\\ 0&amp;0 &amp;k_z \\\\ \\end{bmatrix} = \\begin{bmatrix}k_xx&amp;k_yy&amp;k_zz \\end{bmatrix} $$ 如果沿着各个轴的缩放大小是一样的，则称这个缩放为均匀缩放（Uniform Scaling），否则为非均匀缩放（Nonuniform Scaling）。 Scaling in an Arbitary Direction 向量$v$沿着任意穿过原点的轴$n$缩放得到向量$v^{'}$，示意图如下： 计算过程如下： 如求沿着任意轴旋转一样，将$v$拆成两部分$v_{\\parallel}$和$v_{\\perp}$，其中$\\mathbf{ v_{\\parallel}=(v\\cdot\\hat{n})\\hat{n}}$，$\\mathbf{v_{\\perp}=v-v_{\\parallel}}$ 如果沿着轴$n$进行缩放，$v_{\\parallel}$将发生相应缩放，而$v_{\\perp}$不会产生任何变化，即: $$ v_{\\parallel}^{‘}=kv_{\\parallel}=k(v\\cdot\\hat{n})\\hat{n} \\\\ v_{\\perp}^{’}=v_{\\perp}=v-v_{\\parallel}=v-(v\\cdot\\hat{n})\\hat{n} $$ 因此可求得$v^{'}$： $$ v^{‘}=v_{\\perp}^{’}+v_{\\parallel}^{'} \\\\ =v-(v\\cdot\\hat{n})\\hat{n} + k(v\\cdot\\hat{n})\\hat{n} \\\\ =v+(k-1)(v\\cdot\\hat{n})\\hat{n} $$ 如同计算绕着任意轴旋转一样，如果输入的向量$v$是基本向量$p=\\begin{bmatrix}1,0,0 \\end{bmatrix}$，代数上式，可求得$p^{'}$： $$ p^{'}=p+(k-1)(p\\cdot\\hat{n})\\hat{n} \\\\ ={\\begin{bmatrix}1 \\\\ 0 \\\\ 0\\end{bmatrix}}^T + (k-1)n_x{\\begin{bmatrix} n_x \\\\ n_y \\\\ n_z\\end{bmatrix}}^T \\\\ ={\\begin{bmatrix}1 \\\\ 0 \\\\ 0\\end{bmatrix}}^T + {\\begin{bmatrix}(k-1) {n_x}^2 \\\\(k-1)n_xn_y \\\\ (k-1)n_xn_z\\end{bmatrix}}^T \\\\ ={\\begin{bmatrix}1+(k-1) {n_x}^2\\\\ (k-1)n_xn_y \\\\ (k-1)n_xn_z\\end{bmatrix}}^T $$ 使用相同的步骤，可以计算出当输入$v=q=\\begin{bmatrix} 0 &amp; 1&amp; 0\\end{bmatrix}$时，结果$q^{'}$值为： $$ q^{'}={\\begin{bmatrix}(k-1) {n_xn_y}\\\\ 1+(k-1){n_y}^2 \\\\ (k-1)n_yn_z\\end{bmatrix}}^T $$ 当输入为$r=q=\\begin{bmatrix} 0 &amp; 0&amp; 1\\end{bmatrix}$，结果$r^{'}$值为： $$ r^{'}={\\begin{bmatrix}(k-1) {n_xn_z}\\\\ (k-1){n_yn_z} \\\\ 1+(k-1){n_z}^2\\end{bmatrix}}^T $$ 将其放入缩放矩阵对应的行中，可得沿着任意穿过原点的轴进行缩放的矩阵为： $$ S(\\hat{n},k)=\\begin{bmatrix} 1+(k-1) {n_x}^2&amp;(k-1)n_xn_y &amp;(k-1)n_xn_z \\\\ (k-1) {n_xn_y}&amp; 1+(k-1){n_y}^2 &amp; (k-1)n_yn_z \\\\ (k-1) {n_xn_z} &amp; (k-1){n_yn_z} &amp; 1+(k-1){n_z}^2 \\\\ \\end{bmatrix} $$ Orthographic Projection 正射投影（Orthographic Projection）保证所有原始点和投影点的连线时平行的，如下图所示： Projecting onto a Cardinal Axis or Plane 如果投影到$xy$平面上，那么即沿着$z$轴缩放到0。即将$\\hat{n}=\\begin{bmatrix}0&amp;0&amp;1\\end{bmatrix}$，$k=0$，代入 $$ S(\\hat{n},k)=\\begin{bmatrix} 1+(k-1) {n_x}^2&amp;(k-1)n_xn_y &amp;(k-1)n_xn_z \\\\ (k-1) {n_xn_y}&amp; 1+(k-1){n_y}^2 &amp; (k-1)n_yn_z \\\\ (k-1) {n_xn_z} &amp; (k-1){n_yn_z} &amp; 1+(k-1){n_z}^2 \\\\ \\end{bmatrix} $$ 得 $$ P_{xy}=S(\\begin{bmatrix}0&amp;0&amp;1\\end{bmatrix},0)=\\begin{bmatrix} 1 &amp; 0 &amp;0 \\\\ 0 &amp; 1 &amp;0 \\\\ 0 &amp; 0 &amp;0 \\\\ \\end{bmatrix} $$ 同理，可得 $$ P_{xy}=S(\\begin{bmatrix}0&amp;1&amp;0\\end{bmatrix},0)=\\begin{bmatrix} 1 &amp; 0 &amp;0 \\\\ 0 &amp; 0 &amp;0 \\\\ 0 &amp; 0 &amp;1 \\\\ \\end{bmatrix} $$ $$ P_{yz}=S(\\begin{bmatrix}1&amp;0&amp;0\\end{bmatrix},0)=\\begin{bmatrix} 0 &amp; 0 &amp;0 \\\\ 0 &amp; 1 &amp;0 \\\\ 0 &amp; 0 &amp;1 \\\\ \\end{bmatrix} $$ Projecting onto an Arbitrary Line or Plane 如果投影到任意平面上，且向量$\\hat{n}$垂直于该平面。那么投影实际上是相当于沿着向量$\\hat{n}$进行缩放，且缩放系数$k=0$。将其代入沿着任意角度进行缩放的矩阵，即 $$ R(\\hat{n})=S(\\hat{n},0)=\\begin{bmatrix} 1+(0-1) {n_x}^2&amp;(0-1)n_xn_y &amp;(0-1)n_xn_z \\\\ (0-1) {n_xn_y}&amp; 1+(0-1){n_y}^2 &amp; (0-1)n_yn_z \\\\ (0-1) {n_xn_z} &amp; (0-1){n_yn_z} &amp; 1+(0-1){n_z}^2 \\\\ \\end{bmatrix} \\\\ =\\begin{bmatrix} 1-{n_x}^2&amp;-n_xn_y &amp;-n_xn_z \\\\ -{n_xn_y}&amp; 1-{n_y}^2 &amp; -n_yn_z \\\\ -{n_xn_z} &amp;-{n_yn_z} &amp; 1-{n_z}^2 \\\\ \\end{bmatrix} $$ Reflection 反射（Reflection）也称为镜像（Mirroring）是针对一个轴（2D空间）或者一个平面（3D空间）进行反转的操作。 反射操作如下图所示： 针对于一个平面或一个轴的反射变换，相当于沿着垂直该平面或轴的向量$\\hat{n}$进行$k$大小为$-1$的缩放操作。即： $$ R(\\hat{n})=S(\\hat{n},0)=\\begin{bmatrix} 1+(-1-1) {n_x}^2&amp;(-1-1)n_xn_y &amp;(-1-1)n_xn_z \\\\ (-1-1) {n_xn_y}&amp; 1+(-1-1){n_y}^2 &amp; (-1-1)n_yn_z \\\\ (-1-1) {n_xn_z} &amp; (-1-1){n_yn_z} &amp; 1+(-1-1){n_z}^2 \\\\ \\end{bmatrix} \\\\ =\\begin{bmatrix} 1-2{n_x}^2&amp;-2n_xn_y &amp;-2n_xn_z \\\\ -2{n_xn_y}&amp; 1-2{n_y}^2 &amp; -2n_yn_z \\\\ -2{n_xn_z} &amp;-2{n_yn_z} &amp; 1-2{n_z}^2 \\\\ \\end{bmatrix} $$ Shearing 切变（Shearing）是歪斜（skews）坐标轴的变化，因此有时也会被称为斜变变换（skew transform）。基本思想是把一个方向轴上的元素乘以系数后加到另一个方向轴上。 如$x^{'}=x+sy$，对应的矩阵为： $$ H_x(s)=\\begin{bmatrix} 1 &amp; 0 \\\\ s &amp; 1 \\end{bmatrix} $$ 矩阵中的$s$即对应计算过程$0+s*1$。从矩阵可以看出基本向量$\\begin{bmatrix}1 &amp;0 \\end{bmatrix}$并没有发生变化，基本向量$\\begin{bmatrix}0 &amp;1 \\end{bmatrix}$变为了$\\begin{bmatrix}s &amp;1 \\end{bmatrix}$。 $H_x(s)$表示$x$被$y$轴切变，即$x$轴的值受$y$轴的影响 如下图中所示，： 同理，如果在三维坐标中，$H_{xy}$表示$xy$平面被$z$轴坐标影响。所有的三维空间切变矩阵如下所示： $$ \\mathbf{H_{xy}}(s, t)=\\begin{bmatrix} 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 \\\\ s &amp; t &amp; 1 \\end{bmatrix} $$ $$ \\mathbf{H_{xz}}(s, t)=\\begin{bmatrix} 1 &amp; 0 &amp; 0 \\\\ s &amp; 1 &amp; t \\\\ 0 &amp; 0 &amp; 1 \\end{bmatrix} $$ $$ \\mathbf{H_{yz}}(s, t)=\\begin{bmatrix} 1 &amp; s &amp; t \\\\ 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 \\end{bmatrix} $$ 切边是一个比较少用到的变换，因为使用切变变换和缩放变换（无论是均匀还是非均匀）后的图形完全可以通过旋转和非均匀缩放来达成。 Combining Transformations 因为几个变换矩阵的大小是相同的，所以多个变换矩阵可以被结合在一起。如在物体坐标系中的物体，需要转换到世界坐标系中，此时需要用矩阵$\\mathbf{M_{obj\\rightarrow wld}}$，将物体从世界坐标系中转换到摄像机坐标系，需要用到矩阵$\\mathbf{M_{wld\\rightarrow cam}}$ 则将物体从物体坐标系转换到摄像机坐标系的表达式如下： $$ \\begin{aligned} \\mathbf{P_{\\mathrm{cam}}} &amp;=\\mathbf{p_{\\mathrm{wld}}} \\mathbf{M_{\\mathrm{wld} \\rightarrow \\mathrm{cam}}}\\\\ &amp;=\\left(\\mathbf{p_{\\mathrm{obj}}} \\mathbf{M_{\\mathrm{obj} \\rightarrow \\mathrm{wld}}}\\right) \\mathbf{M_{\\mathrm{wld} \\rightarrow \\mathrm{cam}}} \\end{aligned} $$ 注意矩阵的相乘是满足结合律的，即上式可以进一步简化为： $$ \\begin{aligned} \\mathbf{P_{\\mathrm{cam}}} &amp;=\\left(\\mathbf{p_{\\mathrm{obj}}} \\mathbf{M_{\\mathrm{obj} \\rightarrow \\mathrm{wld}}}\\right) \\mathbf{M_{\\mathrm{wld} \\rightarrow \\mathrm{cam}}} \\\\ &amp;=\\mathbf{p_{\\mathrm{obj}}}\\left(\\mathbf{M_{\\mathrm{obj} \\rightarrow \\mathrm{wld}}} \\mathbf{M_{\\mathrm{wld} \\rightarrow \\mathrm{cam}}}\\right)\\\\ &amp;=\\mathbf{p_{\\mathrm{cam}}}=\\mathbf{p_{\\mathrm{obj}} }\\mathbf{M_{\\mathrm{obj} \\rightarrow \\mathrm{cam}}} \\end{aligned} \\\\ $$ Classes of Transformations 首先需要说明映射和函数的关系。映射指的是输入按照一定的规则变成特定的输出，而函数是用来描述映射关系的。 如将$F$将$a$映射至$b$，可以表示为$F(a)=b$ Linear Transformations 如果$F(a)$是线性变化，那么$F(a)$满足以下特性： $$\\begin{aligned} F(\\mathbf{a}+\\mathbf{b}) &amp;=F(\\mathbf{a})+F(\\mathbf{b}) \\\\ F(k \\mathbf{a}) &amp;=k F(\\mathbf{a}) \\end{aligned}$$ 线性变换还有两个重要推论： 如果满足，$F(a)=\\mathbf{aM}$，其中$\\mathbf{M}$是一个方阵。那么$F(a)$是线性变换。 证明如下： $$ F(\\mathbf{a}+\\mathbf{b})=(\\mathbf{a}+\\mathbf{b}) \\mathbf{M}=\\mathbf{a} \\mathbf{M}+\\mathbf{b} \\mathbf{M}=F(\\mathbf{a})+F(\\mathbf{b})\\\\ \\text{且，}\\\\ F(k \\mathbf{a})=(k \\mathbf{a}) \\mathbf{M}=k(\\mathbf{a} \\mathbf{M})=k F(\\mathbf{a}) $$ 即满足线性变换的定义 对于一个线性变换而言，如果输入是零向量，那么输出必然是零向量。 证明如下： 如果$F(0)=a$, 那么$F(K0)=F(0)=a$，且$KF(0)=Ka$ 如果$a\\neq 0$，则$F(k0)\\neq KF(0)$，即不满足线性代数的性质二。 在本章的5.1-5.5节所有描述的变换都可以通过一个矩阵完成，所以它们都是线性变换。 Affine Transformations 仿射变换（Affine Transformation）是在线性变换后加上位移变换，因此仿射变换是线性变换的超集，任何的线性变换都是仿射变换（只不过后面的位移为零）。 任何形式为$\\mathbf{v’=vM+b}$的变换都是仿射变换。 Invertible Transformations 如果一个变换是可逆的，即存在一个相反的变换可以重置之前的变换，表达式如下： $$ F^{-1}(F(\\mathbf{a}))=F\\left(F^{-1}(\\mathbf{a})\\right)=\\mathbf{a} $$ 因为位移操作必然是可逆的，所以仿射变换是否可逆的关键在于线性变换是否可逆。主要的线性变换，除了投影外都是可逆的，因为投影变换将一个维度的数值变为了零，即一个维度的数据消失了。 找出一个变换的相反操作，相当于找出这个变换矩阵的逆矩阵。如果一个矩阵没有逆矩阵，称这个矩阵为奇异矩阵（或退化矩阵，singular matrix）。一个奇异矩阵的行列式为零。 在非奇异矩阵中（存在逆矩阵的矩阵），当且仅当输入为零向量时，输出才会是零向量。而在奇异矩阵中，有一系列的输入向量都会导致输出为零向量，这些输入向量称为矩阵的零空间（Null Space）。在投影矩阵中，垂直于投影平面的所有向量都在零空间中，因为这些向量在投影后会变成一个点。 对于一个方阵，如果它的基础向量（因为本书用的是行向量，所以相当于每一行，如果用的是列向量则相当于每一列）是线性相关的，则这个矩阵是歧义矩阵，即不存在逆矩阵。 Angle-Preserving Transformations 如果一个变换是保角变换（Angle-Preserving Transformation），那么在变换前后图形中的两个向量的夹角是不会发生变换的。 只有位移，旋转，和均匀缩放是保角变换。对于反射变换，虽然角度的绝对值不会发生改变，但是角度的方向发生了改变，因此也不能算是保角变换。 所有的保角变换都是仿射变换且都是可逆的。 Orthogonal Transformations 正交变换（Orthogonal Transformation）可以很容易的求出反变换，所以被使用的频率很高。 正交变换保证变换前后，图像的长度，角度的绝对值，面积和体积不会发生改变。 只有位移，旋转和反射是正交变换。 所有的正交变换都是可逆的，且是仿射变换。 Rigid Body Transformations 刚体变换（Rigidbody Transformation，proper transformations）只改变图像的位置和角度，但不会改变其形状。位移和旋转是唯二的刚体变换，反射变换因为改变了图形的角度方向所以不是刚体变换。 刚体变换几乎是最严格的变换。所有的刚体变换，都是正交的，保角的，可逆的和仿射的。 刚体变换的行列式大小为1。 Summary of Types of Transformations 所有变换的总截图如下，Y表示必然满足，空白处表示不一定满足。 引用： 3D Math Primer for Graphics and Game Development 2nd 2011","link":"/3DMathPrimerForGraphicsAGameDevelopment-Chapter5-Notes/"},{"title":"《3D数学基础：图形和游戏开发》第七章笔记","text":"《3D数学基础：图形和游戏开发》第七章笔记 7.1节 介绍2D极坐标 7.2节 介绍哪些问题下极坐标比笛卡尔坐标更有用 7.3节 介绍极坐标如何在3D中工作，并介绍圆柱坐标系和球坐标系 7.4节 介绍在极坐标系中点和线段的关系 Chapter 7 Polar Coordinate Systems 2D Polar Space Locating Points by Using 2D Polar Coordinates 在笛卡尔坐标系下，有两个轴分别表示$x,y$，但在极坐标系下只有一个轴，成为极轴（Polar axis），表示从原点发出的一条射线。在数学中，极轴是指向右侧的，即笛卡尔坐标系下$+x$轴的方向。如下图所示： 极坐标系通过一个标量$r$距离原点的距离，一个角度$\\theta$表示与初始极轴的夹角，其中角度的正方向是逆时针。通过$(r,\\theta)$来表示二维极坐标中的一个点，位置为极轴先逆时针转动$\\theta$角度，然后再在极轴上移动$r$，如下所示： 上图极坐标系图中的同心圆，表示$r$相同的点的集合，图中的直线则表示$\\theta$相同的点的集合。 极坐标系中的单位可以是弧度，也可以是角度，只要保证使用时统一一个单位即可。在本书中使用角度。 Aliasing 在笛卡尔坐标系下，一个点只有一个表示。但是在极坐标系下，一个点有无数个表示。如过两个表示实际上是指同一个点，那么称这两个表示互为对方的别名（Aliases）。 如果有点表示为$(r,\\theta)$，那么所有它的别名可以表示为$\\left((-1)^{k} r, \\theta+k 180^{\\circ}\\right)$，其中$k$为任何整数。 极坐标中还有歧义性（singularity），即当$r=0$时，无论$\\theta$取何值，结果都没有区别。 别名和歧义性本身并不会引发任何问题，只不过表达起来存在困难而已。但就如$13/26$通常表示为$1/2$一样，在极坐标系中也有一个通常的表示法，成为正则坐标（canonical coordinate）。一个正则表达是$r$为非负，且$\\theta$的范围在$\\left(-180^{\\circ}, 180^{\\circ}\\right]$中。如果表达$(r,\\theta)$满足以下的三个条件，那么这个表达就是正则坐标： $$ \\begin{cases} r \\geq 0 &amp; \\ -180^{\\circ} &lt; \\theta \\leq 180 ^{\\circ} &amp; 如果极轴指向左侧，则\\theta=180^{\\circ} \\ r=0 \\Rightarrow \\theta=0 &amp; \\end{cases} $$ 以下的方法可以将一个非正则坐标转换为正则坐标： 当$r=0$时，$\\theta =0$ 当$r&lt;0$时，$r=-r, \\theta=\\theta +180^{\\circ}$ 当$\\theta \\leq -180^{\\circ}$，$\\theta =\\theta +k360 ^{\\circ}$，$k$为第一个让$\\theta &gt; -180^{\\circ}$的值 当$\\theta &gt; -180^{\\circ}$，$\\theta =\\theta -k360 ^{\\circ}$，$k$为第一个让$\\theta \\leq -180^{\\circ}$的值 Converting between Cartesian and Polar Coordinates in 2D 二维极坐标系和笛卡尔坐标系的转换可以参考下图： 极坐标系转换为笛卡尔坐标系表达式如下： $$x=r \\cos \\theta \\quad y=r \\sin \\theta$$ 笛卡尔坐标系转换为极坐标系表达式如下： $$ r=\\sqrt{x^{2}+y^{2}} \\quad \\theta=\\arctan (y / x)$$ 其中，$\\theta=\\arctan (y / x)$是由$\\frac{y}{x}=\\frac{r\\sin \\theta}{r \\cos \\theta}$化简得来。 但$\\arctan (y / x)$的表达式存在两个问题，第一是当$x=0$时，表达式的除法是未定义的。第二是$\\arctan$的范围为$\\left[-90^{\\circ},+90^{\\circ}\\right]$。这个原因是$\\frac{y}{x}$隐藏了一部分信息：$x和y$分别存在正负，所以一共有4种组合，但是$\\frac{y}{x}$却只有两个结果。 在书中，作者定义了函数$atan2$，其定义为： $$\\operatorname{atan} 2(y, x)=\\left{\\begin{array}{ll} 0, &amp; x=0, y=0 \\ +90^{\\circ}, &amp; x=0, y&gt;0 \\ -90^{\\circ}, &amp; x=0, y&lt;0 \\ \\arctan (y / x), &amp; x&gt;0 \\ \\arctan (y / x)+180^{\\circ}, &amp; x&lt;0, y \\geq 0 \\ \\arctan (y / x)-180^{\\circ}, &amp; x&lt;0, y&lt;0 \\end{array}\\right.$$ 此时，笛卡尔转换为极坐标系可以表示为： $$r=\\sqrt{x^{2}+y^{2}} ; \\quad \\quad \\theta=\\operatorname{atan} 2(y, x)$$ Why Would Anybody Use Polar Coordinates 人们本能上会觉得笛卡尔坐标系更熟悉，但是日常生活中实际上使用更多的是极坐标系，如“往西走50米”，这个描述就是极坐标系（方位+距离）。但是在电脑的计算中，使用较多的是笛卡尔坐标系。 在游戏和物理中，如果一个变换只关注角度和距离，那么极坐标系是比较好的选择。 另外在球表面上的计算，也通常使用极坐标系，如经度、维度，实际上就是球坐标系下的表示。 3D Polar Space 在2D极坐标系下，两个变量分别是距离$r$和角度$\\theta$，当扩展为3D极坐标时，第三个变量可以是距离$z$，此时变为了圆柱坐标系，也可以是$\\phi$，此时变为了球坐标系。 Cylindrical Coordinates 圆柱坐标系以及点$(r,\\theta,\\phi)$的表示如下图所示： 可以看到，第三个变量$z$是垂直于2D极坐标平面的，当$z=0$时，即为2D极坐标平面。 Spherical Coordinates 球坐标系在使用中更为常见。球坐标系下第三个变量仍然表示角度且命名为$\\phi$。$phi$的初始方向为垂直向上，旋转正方向为绕着极轴顺时针向下，如下图所示： $\\theta$被称为方位角（Azimuth），$\\phi$被称为天顶角（Zenith）。在地球仪中经度（Longitude）对应的为$\\theta$，维度（Latitude）对应的为$90^{\\circ}-\\phi$，海拔（Altitude）对应$r$。 Some Polar Conventions Useful in 3D Virtual Worlds 之前章节描述的是数学层面上的极坐标系，但在3D游戏的使用中，数学层面的极坐标系存在以下问题： $\\theta =0$的位置，对应的是$+x$方向，但希望对应的方向是$+z$方向。 $\\phi =0$的位置，对应的是$+y$方向，但这样的话当$\\phi=0$时，并不等于二维的极坐标系。而在$(r,\\theta,90^{\\circ})$时才等同于二维坐标系。 $\\theta$和$\\phi$不方便记忆。 为此，3D游戏中的极坐标系做了如下改变 水平角$\\theta$命名为$h$(heading)，且当$h=0$时指向$+z$方向。旋转正方向从Y轴正方向看为顺时针 垂直角$\\phi$命名为$p$(pitch)，当$p=0$时，为水平角度，旋转正方向为向下。 3D游戏中的极坐标系如下图所示： Aliasing of Spherical Coordinates 三维坐标中同样存在别名和歧义性。 当r取反时，$h+k180^{\\circ}$，并且$p=-p$即能获得一样的值（别名） 当$r=0$时，$h$和$p$取任意值都没有区别。（歧义性） $(h,p)$可以表示为$\\left(h \\pm 180^{\\circ}, 180^{\\circ}-p\\right)$（别名） 如h向右转90°，p向下转45°，等同于h向左转90°，p向下转135°。 当$p=\\pm 90^{\\circ}$时，$h$取任意值没有区别（歧义性）（万向锁，gimbal lock）。 同样如在二维极坐标中一样，可以通过正则坐标来消除歧义和别名，三维极坐标系的正则坐标满足以下条件： $$ \\left{\\begin{array}{l} r \\geq 0 \\ -180^{\\circ}&lt;h \\leq 180^{\\circ} &amp; 指向后侧时，h=180^{circ} \\ -90^{\\circ} \\leq p \\leq 90^{\\circ} \\ r=0 \\Rightarrow h=p=0 \\ |p|=90^{\\circ} \\Rightarrow h=0 \\end{array}\\right. $$ 可以通过以下方法，将普通三维极坐标转换为正则坐标 当$r=0$,$h=p=0$ 当$r &lt;0$，$h=h+180^{\\circ},p=-p$ 当$p&lt;-90^{\\circ}$,$p=p+k360^{\\circ}$，直到$p\\geq -90^{\\circ}$ 当$p&gt;270^{\\circ}$,$p=p-k360^{\\circ}$，直到$p\\leq 270^{\\circ}$ 当$p&gt;90^{\\circ}$,$h=h+180^{\\circ}$,$p=180^{\\circ}-p$ 当$h \\leq -180^{\\circ}$,$h=h+k360^{\\circ}$，直到$h &gt; -180^{\\circ}$ 当$h &gt; 180^{\\circ}$,$h=h-k360^{\\circ}$，直到$h \\leq 180^{\\circ}$ Converting between Spherical and Cartesian Coordinates 球坐标系与笛卡尔坐标系的转换图如下所示（数学层面）： 其中 $$ x=r \\sin \\phi \\cos \\theta, \\quad y=r \\sin \\phi \\sin \\theta, \\quad z=r \\cos \\phi $$ 求解过程如下： $z=r \\cos \\phi$很容易从图中看出，关键是求得$x和y$的表达式。当$\\phi=90^{\\circ}$时，即为二维的球坐标系，有 $$x^{\\prime}=r \\cos \\theta, \\quad y^{\\prime}=r \\sin \\theta$$ 根据，相似三角形性质，可得 $$x / x^{\\prime}=y / y^{\\prime}=d / r$$ 又有$d / r=\\sin \\phi$ 所以可以求得 $$ x=r \\sin \\phi \\cos \\theta, \\quad y=r \\sin \\phi \\sin \\theta, \\quad $$ 如果是求3D游戏转换的球坐标系，可得 $$x=r \\cos p \\sin h, \\quad y=-r \\sin p, \\quad z=r \\cos p \\cos h$$ 笛卡尔坐标系转换为球坐标系如下： $$ r=\\sqrt{x^{2}+y^{2}+z^{2}} \\ h=\\operatorname{atan} 2(x, z) \\ p=\\arcsin (-y / r) $$ Using Polar Coordinates to Specify Vectors 实际上，极坐标系的描述就线段的描述（方向+距离）。 一切上述的极坐标的点的描述，都可以直接转换为对线段的描述。 引用： 3D Math Primer for Graphics and Game Development 2nd 2011","link":"/3DMathPrimerForGraphicsAGameDevelopment-Chapter7-Notes/"},{"title":"《3D数学基础：图形和游戏开发》第六章笔记","text":"《3D数学基础：图形和游戏开发》第六章笔记 6.1 介绍了矩阵的行列式 6.2 介绍了矩阵的逆 6.3 介绍了正交矩阵 6.4 介绍了齐次矩阵 6.5 介绍了齐次矩阵与透视投影的关系 Chapter 6 More on Matrices 在第四章中介绍了矩阵的基本数学性质和几何意义。 在第五章中着重介绍了矩阵的几何意义，列举了一系列矩阵能表示的各种图形变换。 在这一章中将扩展前两章的知识，介绍矩阵的另一些数学特性和深入讨论图形变换。 Determinant of a Matrix 对于方阵而言，有一个重要的标量成为矩阵的行列式（Determinant of the matrix）。 Determinants of $2\\times 2$ and $3\\times 3$ matrices 方阵$\\mathbf{M}$的行列式写为$|\\mathbf{M}|$或者写为&quot;$def \\mathbf{M}$&quot;，非方阵的矩阵并没有行列式。 二维行列式的计算过程如下： $$|\\mathbf{M}|=\\left|\\begin{array}{ll} m_{11} &amp; m_{12} \\\\ m_{21} &amp; m_{22} \\end{array}\\right|=m_{11} m_{22}-m_{12} m_{21}$$ 三维行列式的计算过程如下： $$ \\begin{aligned} \\left|\\begin{array}{lll} m_{11} &amp; m_{12} &amp; m_{13} \\ m_{21} &amp; m_{22} &amp; m_{23} \\ m_{31} &amp; m_{32} &amp; m_{33} \\end{array}\\right|\\ &amp;=\\begin{array}{l} &amp;m_{11} m_{22} m_{33}+m_{12} m_{23} m_{31}+m_{13} m_{21} m_{32} \\ &amp;-m_{13} m_{22} m_{31}-m_{12} m_{21} m_{33}-m_{11} m_{23} m_{32} \\end{array} \\\\ &amp;=\\begin{array}{l} &amp; m_{11}\\left(m_{22} m_{33}-m_{23} m_{32}\\right) \\ &amp;+m_{12}\\left(m_{23} m_{31}-m_{21} m_{33}\\right) \\ &amp;+m_{13}\\left(m_{21} m_{32}-m_{22} m_{31}\\right) \\end{array} \\end{aligned} $$ Minros and Cofactors 余子式（Minors）和代数余子式（Cofactors）之后求任意维度的行列式时会用到。 对于矩阵$\\mathbf{M}$来，$\\mathbf{M}^$表示删除了第$i$行和第$j$的子矩阵，而子矩阵的行列式称为余子式。如下所示： $$\\mathbf{M}=\\left[\\begin{array}{ccc} -4 &amp; -3 &amp; 3 \\\\ 0 &amp; 2 &amp; -2 \\\\ 1 &amp; 4 &amp; -1 \\end{array}\\right] \\quad \\Longrightarrow \\quad M^12=\\left|\\begin{array}{cc} 0 &amp; -2 \\\\ 1 &amp; -1 \\end{array}\\right|=2$$ 而代数余子式，是为余子式再加上一个系数，该系数由子矩阵所删除的行列决定，即 Determinants of Arbitary $n\\times n$ Matrices 任意$n\\times n$矩阵的行列式计算过程如下： 任意选取一行或一列 对这行或这列中的每一个元素，将它和它所在行列的代数余子式相乘。 将第二步中的所有结果累加 即： 如果一个三维矩阵通过上述方法计算： $$\\begin{aligned} \\left|\\begin{array}{lll} m_{11} &amp; m_{12} &amp; m_{13} \\ m_{21} &amp; m_{22} &amp; m_{23} \\end{array}\\right|=m_{11}\\left|\\begin{array}{cc} m_{22} &amp; m_{23} \\ m_{31} &amp; m_{32} &amp; m_{33} \\end{array}\\right| &amp;-m_{12}\\left|\\begin{array}{cc} m_{21} &amp; m_{23} \\ m_{31} &amp; m_{33} \\end{array}\\right| \\ &amp;+m_{13}\\left|\\begin{array}{cc} m_{21} &amp; m_{22} \\ m_{31} &amp; m_{32} \\end{array}\\right| \\end{aligned}$$ 以下为行列式的一些重要特性： 如果矩阵是单位矩阵，那么行列式为1 $$|\\mathbf{I}|=1$$ 矩阵乘积的行列式等于矩阵行列式的乘积 $$|\\mathbf{A B}|=|\\mathbf{A} | \\mathbf{B}|$$ 矩阵转置的行列式等于矩阵的行列式 $$\\left|\\mathbf{M}^{\\mathrm{T}}\\right|=|\\mathbf{M}|$$ 有任意行或列全为0，则该矩阵行列式为0 $$\\left|\\begin{array}{cccc} ? &amp; ? &amp; \\cdots &amp; ? \\ ? &amp; ? &amp; \\cdots &amp; ? \\ \\vdots &amp; \\vdots &amp; &amp; \\vdots \\ 0 &amp; 0 &amp; \\cdots &amp; 0 \\ \\vdots &amp; \\vdots &amp; &amp; \\vdots \\ \\vdots &amp; ? &amp; \\cdots &amp; ? \\end{array}\\right|=\\left|\\begin{array}{cccccc} ? &amp; ? &amp; \\cdots &amp; 0 &amp; \\cdots &amp; ? \\ ? &amp; ? &amp; \\cdots &amp; 0 &amp; \\cdots &amp; ? \\ \\vdots &amp; \\vdots &amp; &amp; \\vdots &amp; &amp; \\vdots \\ ? &amp; ? &amp; \\cdots &amp; 0 &amp; \\cdots &amp; ? \\end{array}\\right|=0$$ 交换矩阵的任意两行或两列，行列式取反 $$\\left|\\begin{array}{cccc} m_{11} &amp; m_{12} &amp; \\cdots &amp; m_{1 n} \\ m_{21} &amp; m_{22} &amp; \\cdots &amp; m_{2 n} \\ \\vdots &amp; \\vdots &amp; &amp; \\vdots \\ m_{i 1} &amp; m_{i 2} &amp; \\cdots &amp; m_{i n} \\ \\vdots &amp; \\vdots &amp; &amp; \\vdots \\ m_{j 1} &amp; m_{j 2} &amp; \\cdots &amp; m_{j n} \\ \\vdots &amp; \\vdots &amp; &amp; \\vdots \\ m_{n 1} &amp; m_{n 2} &amp; \\cdots &amp; m_{n n} \\end{array}\\right|=-\\left|\\begin{array}{cccc} m_{11} &amp; m_{12} &amp; \\cdots &amp; m_{1 n} \\ m_{21} &amp; m_{22} &amp; \\cdots &amp; m_{2 n} \\ \\vdots &amp; \\vdots &amp; &amp; \\vdots \\ m_{j 1} &amp; m_{j 2} &amp; \\cdots &amp; m_{j n} \\ \\vdots &amp; \\vdots &amp; &amp; \\vdots \\ m_{i 1} &amp; m_{i 2} &amp; \\cdots &amp; m_{i n} \\ \\vdots &amp; \\vdots &amp; &amp; \\vdots \\ m_{n 1} &amp; m_{n 2} &amp; \\cdots &amp; m_{n n} \\end{array}\\right|$$ 将矩阵的一行或一列乘以系数后加到零一行或列上不改变行列式的值（因此切变的行列式为1） $$\\left|\\begin{array}{cccc} m_{11} &amp; m_{12} &amp; \\cdots &amp; m_{1 n} \\ m_{21} &amp; m_{22} &amp; \\cdots &amp; m_{2 n} \\ \\vdots &amp; \\vdots &amp; &amp; \\vdots \\ m_{i 1} &amp; m_{i 2} &amp; \\cdots &amp; m_{i n} \\ \\vdots &amp; \\vdots &amp; &amp; \\vdots \\ m_{j 1} &amp; m_{j 2} &amp; \\cdots &amp; m_{j n} \\ \\vdots &amp; \\vdots &amp; &amp; \\vdots \\ m_{n 1} &amp; m_{n 2} &amp; \\cdots &amp; m_{n n} \\end{array}\\right|=\\left|\\begin{array}{cccc} m_{11} &amp; m_{12} &amp; \\cdots &amp; m_{1 n} \\ m_{21} &amp; m_{22} &amp; \\cdots &amp; m_{2 n} \\ \\vdots &amp; \\vdots &amp; &amp; \\vdots \\ m_{i 1}+k m_{j 1} &amp; m_{i 2}+k m_{j 2} &amp; \\cdots &amp; m_{i n}+k m_{j n} \\ \\vdots &amp; \\vdots &amp; &amp; \\vdots \\ m_{j 1} &amp; m_{j 2} &amp; \\cdots &amp; m_{j n} \\ \\vdots &amp; \\vdots &amp; &amp; \\vdots \\ m_{n 1} &amp; m_{n 2} &amp; \\cdots &amp; m_{n n} \\end{array}\\right|$$ Geometric Interpretation of Determinant 在2D中，行列式实际上是表达了两个向量（每一行表示一个向量）所构成的平行四边形的有向面积，如： 同理，在3D中即表示由三条向量构成的平行六面体体积。 行列式的大小表示了一个变换是否改变了多个向量所构成物体的面积或体积，行列式的正负表示了变换是否存在反转，如果行列式为0，那么说明这个变换存在投影。 Inverse of a Matrix 矩阵$\\mathbf{M}$的逆矩阵为$\\mathbf{M^{-1}}$，矩阵与逆矩阵的乘积为单位矩阵，即： $$\\mathbf{M}\\left(\\mathbf{M}^{-1}\\right)=\\mathbf{M}^{-1} \\mathbf{M}=\\mathbf{I}$$ 并不是所有的矩阵都有逆矩阵，如零矩阵无论与哪个矩阵相乘都不会成为单位矩阵。如果一个矩阵有逆矩阵，就称该矩阵为可逆矩阵或非奇异矩阵（Invertible or nonsingular）。 对于可逆矩阵有如下性质： 对于任何可逆矩阵，当前仅当$\\mathbf{v=0}$时有$\\mathbf{vM=0}$。 任何可逆矩阵的行和列都是线性不相关的。 可逆矩阵的行列式不为0。因此检查一个矩阵的行列式是否为零是最通用且最快的检查矩阵是否可逆的方法。 The Classical Adjoint 伴随矩阵（Classical Adjoint）是计算逆矩阵的方法，将矩阵$\\mathbf{M}$的伴随矩阵称为“adj $\\mathbf{M}$”。 伴随矩阵是原矩阵所有代数余子式构成的矩阵的转置。如下以一个$3\\times 3$矩阵作为例子： $$\\mathbf{M}=\\left[\\begin{array}{ccc} -4 &amp; -3 &amp; 3 \\ 0 &amp; 2 &amp; -2 \\ 1 &amp; 4 &amp; -1 \\end{array}\\right]$$ 要求伴随矩阵，首先要求出所有的代数余子式，即： $$\\begin{aligned} &amp;C^11=+\\left|\\begin{array}{cc} 2 &amp; -2 \\ 4 &amp; -1 \\end{array}\\right|=6, \\quad C^12=-\\left|\\begin{array}{cc} 0 &amp; -2 \\ 1 &amp; -1 \\end{array}\\right|=-2, \\quad C^13=+\\left|\\begin{array}{cc} 0 &amp; 2 \\ 1 &amp; 4 \\end{array}\\right|=-2\\ &amp;C^21=-\\left|\\begin{array}{cc} -3 &amp; 3 \\ 4 &amp; -1 \\end{array}\\right|=9, \\quad C^22=+\\left|\\begin{array}{cc} -4 &amp; 3 \\ 1 &amp; -1 \\end{array}\\right|=1, \\quad C^23=-\\left|\\begin{array}{cc} -4 &amp; -3 \\ 1 &amp; 4 \\end{array}\\right|=13\\ &amp;C^31=+\\left|\\begin{array}{cc} -3 &amp; 3 \\ 2 &amp; -2 \\end{array}\\right|=0, \\quad C^32=-\\left|\\begin{array}{cc} -4 &amp; 3 \\ 0 &amp; -2 \\end{array}\\right|=-8, \\quad C^33=+\\left|\\begin{array}{cc} -4 &amp; -3 \\ 0 &amp; 2 \\end{array}\\right|=-8 \\end{aligned}$$ 矩阵的伴随矩阵如下： $$\\begin{aligned} \\operatorname{adj} \\mathbf{M} &amp;=\\left[\\begin{array}{ccc} C^11 &amp; C^12 &amp; C^13 \\ C^21 &amp; C^22 &amp; C^23 \\ C^31 &amp; C^32 &amp; C^33 \\end{array}\\right]^{\\mathrm{T}} \\ &amp;=\\left[\\begin{array}{ccc} 6 &amp; -2 &amp; -2 \\ 9 &amp; 1 &amp; 13 \\ 0 &amp; -8 &amp; -8 \\end{array}\\right]^{\\mathrm{T}}=\\left[\\begin{array}{ccc} 6 &amp; 9 &amp; 0 \\ -2 &amp; 1 &amp; -8 \\ -2 &amp; 13 &amp; -8 \\end{array}\\right] \\end{aligned}$$ Matrix Inverse-Official Linear Algebra Rules 用矩阵的伴随矩阵除以矩阵的行列式，即为矩阵的逆矩阵。因为计算逆矩阵时要除以矩阵的行列式，所以行列式为0的矩阵是不存在逆矩阵的。公式如下： $$\\mathbf{M}^{-1}=\\frac{\\operatorname{adj} \\mathbf{M}}{|\\mathbf{M}|}$$ 除了用伴随矩阵的方法来计算逆矩阵，还有如高斯消除（Gaussian elimination）等其他方法。高斯消除法的运算量会更小，但针对图形学最常用的$3\\times 3$和$4 \\times 4$大小的矩阵，用伴随矩阵的方法就已经足够。 逆矩阵有如下性质： 逆矩阵的逆矩阵等于原矩阵 $$\\left(\\mathbf{M}^{-1}\\right)^{-1}=\\mathbf{M}$$ 单位矩阵的逆矩阵为本身。 $$\\mathbf{I^{-1}=I}$$ 单位矩阵并不是唯一的逆矩阵为本身的矩阵，反射矩阵和旋转180°的矩阵通用也满足。 转置的逆矩阵等于逆矩阵的转置 $$\\left(\\mathbf{M}^{\\mathrm{T}}\\right)^{-1}=\\left(\\mathbf{M}^{-1}\\right)^{\\mathrm{T}}$$ 乘积的逆矩阵等于相反顺序的逆矩阵的乘积 $$(\\mathbf{A B})^{-1}=\\mathbf{B}^{-1} \\mathbf{A}^{-1}$$ 逆矩阵的行列式等于原矩阵行列式的倒数 $$\\left|\\mathbf{M}^{-1}\\right|=1 /|\\mathbf{M}|$$ Matrix Inverse-Geometric Interpretation 逆矩阵的几何意义即是相反的变换，相当于一个变换的undo。 $$(\\mathbf{v M}) \\mathbf{M}^{-1}=\\mathbf{v}\\left(\\mathbf{M M}^{-1}\\right)=\\mathbf{v} \\mathbf{I}=\\mathbf{v}$$ Orthogonal Matrices Orthogonal Matrices-Official Linear Algebra Rules 一个方阵当且仅当它和它的转置乘积为单位矩阵时，这个矩阵为正交矩阵（Orthogonal Matrix）： $$\\mathbf{M} \\text { is orthogonal } \\Longleftrightarrow \\quad \\mathbf{M M}^{\\mathrm{T}}=\\mathbf{I}$$ 同时因为$\\mathbf{M}^{-1} \\mathbf{M}=\\mathbf{I}$，所以正交矩阵还满足： $$\\mathbf{M} \\text { is orthogonal } \\Longleftrightarrow \\mathbf{M}^{\\mathrm{T}}=\\mathbf{M}^{-1}$$ 如果知道一个矩阵是正交的（如旋转和反射变换），那么可以很快的通过求其转置矩阵来获得逆矩阵。 Orthogonal Matrices-Geometric Interpretation 正交矩阵的意义在于其逆矩阵非常容易求得（转置矩阵即为逆矩阵）。 如果一个变换仅包含位移，旋转和反射，那么它为正交矩阵。 如果一个矩阵的每一行（或每一列）构成的基本向量长度为1，且相互垂直，那么它也是正交矩阵。 证明如下： 首先根据正交矩阵的定义，矩阵与矩阵的转置乘积为单位矩阵： 假设 $$ \\mathbf{M}=\\left[\\begin{array}{lll} m_{11} &amp; m_{12} &amp; m_{13} \\ m_{21} &amp; m_{22} &amp; m_{23} \\ m_{31} &amp; m_{32} &amp; m_{33} \\end{array}\\right] $$ 且$\\mathbf{M}$为正交矩阵，则有 $$ \\left[\\begin{array}{lll} m_{11} &amp; m_{12} &amp; m_{13} \\ m_{21} &amp; m_{22} &amp; m_{23} \\ m_{31} &amp; m_{32} &amp; m_{33} \\end{array}\\right]\\left[\\begin{array}{lll} m_{11} &amp; m_{21} &amp; m_{31} \\ m_{12} &amp; m_{22} &amp; m_{32} \\ m_{13} &amp; m_{23} &amp; m_{33} \\end{array}\\right]=\\left[\\begin{array}{lll} 1 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 1 \\end{array}\\right] $$ 用$\\mathbf{r_1,r_2,r_3}$代表矩阵$\\mathbf{M}$的每个基本向量（每一行），即 $$\\begin{aligned} &amp;\\mathbf{r}{1}=\\left[\\begin{array}{lll} m{11} &amp; m_{12} &amp; m_{13} \\end{array}\\right]\\ &amp;\\mathbf{r}{2}=\\left[\\begin{array}{lll} m{21} &amp; m_{22} &amp; m_{23} \\end{array}\\right]\\ &amp;\\mathbf{r}{3}=\\left[\\begin{array}{lll} m{31} &amp; m_{32} &amp; m_{33} \\end{array}\\right] \\end{aligned}$$ $$\\mathbf{M}=\\left[\\begin{array}{l} -\\mathbf{r}{1}- \\ -\\mathbf{r}{2}- \\ -\\mathbf{r}_{3}- \\end{array}\\right]$$ 可得： $$\\begin{array}{lll} \\mathbf{r}{1} \\cdot \\mathbf{r}{1}=1, &amp; \\mathbf{r}{1} \\cdot \\mathbf{r}{2}=0, &amp; \\mathbf{r}{1} \\cdot \\mathbf{r}{3}=0 \\ \\mathbf{r}{2} \\cdot \\mathbf{r}{1}=0, &amp; \\mathbf{r}{2} \\cdot \\mathbf{r}{2}=1, &amp; \\mathbf{r}{2} \\cdot \\mathbf{r}{3}=0 \\ \\mathbf{r}{3} \\cdot \\mathbf{r}{1}=0, &amp; \\mathbf{r}{3} \\cdot \\mathbf{r}{2}=0, &amp; \\mathbf{r}{3} \\cdot \\mathbf{r}{3}=1 \\end{array}$$ 即每个基本向量与自己的点乘值为1，去别的基本向量点乘值为0。即表明每个基本向量的长度为1，且与其他的基本向量相互垂直。 如果一个矩阵是正交矩阵，它的转置也必然是正交矩阵。因此无论矩阵的每一行还是每一列满足上述条件，都能证明它是正交矩阵。 在英语中有些术语会造成困扰。orthogonal basis vectors是描述一系列相互垂直的向量，但并没有限定它们的长度。如果它们满足长度为1，则称为orthnormal basis verctors。但是orthogonal matrices需要基本向量不仅相互垂直，而且长度为1。即orthogonal basis vectores不能构成orthogonal matrices，必须是orthonormal basis vectores才行。 Orthogonalizing a Matrix 有时遇到一些矩阵因为数据的错误或者浮点误差（Floating point error）。 在这些情况下，需要通过一些变换将矩阵的基本向量变为互相垂直和长度为一。通常使用的方法为Gram-Schmidt 正交化。 首先将矩阵的标准向量（每一行）定义为$\\mathbf{r}{1}, \\mathbf{r}{2},$ 和 $\\mathbf{r}{3}$，并将转换后的满足相互垂直的基本向量定义为$\\mathbf{r}{1}^{\\prime}, \\mathbf{r}{2}^{\\prime},$ 和 $\\mathbf{r}{3}^{\\prime}$。 其转换方法如下： $$\\begin{aligned} &amp;\\mathbf{r}{1}^{\\prime} \\Leftarrow \\mathbf{r}{1}\\ &amp;\\begin{array}{l} \\mathbf{r}{2}^{\\prime} \\Leftarrow \\mathbf{r}{2}-\\frac{\\mathbf{r}{2} \\cdot \\mathbf{r}{1}^{\\prime}}{\\mathbf{r}{1}^{\\prime} \\cdot \\mathbf{r}{1}^{\\prime}} \\mathbf{r}{1}^{\\prime} \\ \\mathbf{r}{3}^{\\prime} \\Leftarrow \\mathbf{r}{3}-\\frac{\\mathbf{r}{3} \\cdot \\mathbf{r}{1}^{\\prime}}{\\mathbf{r}{1}^{\\prime} \\cdot \\mathbf{r}{1}^{\\prime}} \\mathbf{r}{1}^{\\prime}-\\frac{\\mathbf{r}{3} \\cdot \\mathbf{r}{2}^{\\prime}}{\\mathbf{r}{2}^{\\prime} \\cdot \\mathbf{r}{2}^{\\prime}} \\mathbf{r}_{2}^{\\prime} \\end{array} \\end{aligned}$$ 其中$\\mathbf{r}{2}^{\\prime}$只所以这么定义，是为了从$\\mathbf{r2}$中减去平行于$\\mathbf{r1}$的部分，这样剩余部分$\\mathbf{r}{2}^{\\prime}$即为垂直于$\\mathbf{r1}$的部分。 且根据利用点乘求向量分量的定义可得， $$\\begin{aligned} r_{2}^{\\prime} &amp;=r_{2}-\\left(r_{2} \\cdot \\hat{r}{1}\\right) \\cdot \\hat{r}{1} \\ &amp;=r_{2}-\\left(r_{2} \\cdot \\frac{r_{1}^{\\prime}}{\\left|r_{1}\\right|}\\right) \\cdot \\frac{r_{1}^{\\prime}}{\\left|r_{1}\\right|} \\ &amp;=r_{2}-\\frac{r_{2} \\cdot r_{1}^{\\prime}}{\\left|r_{1}\\right|^{2}} \\cdot r_{1}^{\\prime} \\ &amp;=r_{2}-\\frac{r_{2} \\cdot r_{1}^{\\prime}}{r_{1}^{\\prime} \\cdot r_{1}^{\\prime}} \\cdot r_{1}^{\\prime} \\end{aligned}$$ 求$\\mathbf{r}_{3}^{\\prime}$的过程同理。 对于$\\mathbf{r}{3}^{\\prime}$还可以直接通过求得的$\\mathbf{r}{1}^{\\prime}$和$\\mathbf{r}_{2}^{\\prime}$获得，即 $$\\mathbf{r}{3}^{\\prime} \\Leftarrow \\mathbf{r}{1}^{\\prime} \\times \\mathbf{r}_{2}^{\\prime}$$ 在求得相互垂直的向量$\\mathbf{r}{1}^{\\prime}, \\mathbf{r}{2}^{\\prime},$ 和 $\\mathbf{r}_{3}^{\\prime}$后，通过归一化基本求得长度为1的矩阵，如下： $$\\begin{aligned} &amp;r_{1}^{\\prime \\prime}=\\frac{r_{1}^{\\prime}}{\\left|r_{1}^{\\prime}\\right|}\\ &amp;r_{2}^{\\prime \\prime}=\\frac{r_{2}^{\\prime}}{\\left|r_{2}^{\\prime}\\right|}\\ &amp;r_{3}^{\\prime \\prime}=\\frac{r_{3}^{\\prime}}{\\left|r_{3}^{\\prime}\\right|} \\end{aligned}$$ 还有一种方法是利用迭代来求得相互垂直的向量，称为Nonbiased incremental 正交化。如下： $$\\begin{aligned} &amp;\\mathbf{r}{1}^{\\prime} \\Leftarrow \\mathbf{r}{1}-k \\frac{\\mathbf{r}{1} \\cdot \\mathbf{r}{2}}{\\mathbf{r}{2} \\cdot \\mathbf{r}{2}} \\mathbf{r}{2}-k \\frac{\\mathbf{r}{1} \\cdot \\mathbf{r}{3}}{\\mathbf{r}{3} \\cdot \\mathbf{r}{3}} \\mathbf{r}{3}\\ &amp;\\mathbf{r}{2}^{\\prime} \\Leftarrow \\mathbf{r}{2}-k \\frac{\\mathbf{r}{2} \\cdot \\mathbf{r}{1}}{\\mathbf{r}{1} \\cdot \\mathbf{r}{1}} \\mathbf{r}{1}-k \\frac{\\mathbf{r}{2} \\cdot \\mathbf{r}{3}}{\\mathbf{r}{3} \\cdot \\mathbf{r}{3}} \\mathbf{r}{3}\\ &amp;\\mathbf{r}{3}^{\\prime} \\Leftarrow \\mathbf{r}{3}-k \\frac{\\mathbf{r}{3} \\cdot \\mathbf{r}{1}}{\\mathbf{r}{1} \\cdot \\mathbf{r}{1}} \\mathbf{r}{1}-k \\frac{\\mathbf{r}{3} \\cdot \\mathbf{r}{2}}{\\mathbf{r}{2} \\cdot \\mathbf{r}{2}} \\mathbf{r}{2} \\end{aligned}$$ 该方法时通过选取一个适当的k，进行反复迭代获取一个很近似正交的类型。 $4\\times 4$ Homogeneous Matrices 这部分第一次提及了四维向量，称为齐次坐标（Homogeneous coordinate）。 4D Homogeneous Space 在四维向量中，第四个元素为$w$。 为了更好的理解物理的三维空间是如何扩展到四维空间的。先以二维空间为例，想象二维空间是存在于三维齐次空间中的一个平面，且第三个元素值为1，即$w=1$，所有在该平面上的点都可表示为$(x,y,1)$。所有不在$w=1$平面上的齐次坐标点$(x,y,w)$，都可以通过$(x/w,y/w,1)$转换到二维物理平面上。如下： 同样的，对于任何在二维平面上的点$(x,y)$都有无限多个相应的在齐次坐标中的点$(kx,ky,k)$。这些点构成一条穿越原点的直线。 当$w=0$时，除法是未定义的，所以没有相对应的在二维物理平面上的点。因此将$w=0$的坐标定义为是在无限远处的点，这些点是用来表示方向而不是位置，即$w=0$的坐标实际上是作为向量来进行处理，而$w\\neq 0$的点才是作为表示位置的点。 将二维空间的概念推广到三维空间中，三维空间中的点也同样可以看作是在四维齐次空间中，只不过第四个元素值$w=1$。同样的，任意在四维齐次空间中的点，都可以通过$(x/w,y/w,z/w,1)$转换到三维空间中。当$w=0$时，坐标同样是用来表示向量而不是点。 在三维空间中引入四维齐次坐标主要有两个原因： 为了计算上的便捷，因为位移需要用到四维矩阵，而将其他所有的变形都用四维矩阵表示可以方便计算。 第四个参数$w$可以用于表示透视投影（perspective projection）。 $4\\times 4$ Translation Matrices 因为$n$维零向量与任何的$n\\times n$矩阵相乘结果都是$n$维零向量，所以通过一个$3 \\times 3$的矩阵是永远无法将一个点从原点移动出去的，即$n$维的矩阵无法在$n$维空间中表示位移。 但是可以通过一个$4 \\times 4$的矩阵在三维空间中表示位移。如下所示： $$\\left[\\begin{array}{llll} x &amp; y &amp; z &amp; 1 \\end{array}\\right]\\left[\\begin{array}{cccc} 1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; 0 \\ \\Delta x &amp; \\Delta y &amp; \\Delta z &amp; 1 \\end{array}\\right]=\\left[\\begin{array}{lllll} x+\\Delta x &amp; y+\\Delta y &amp; z+\\Delta z &amp; 1 \\end{array}\\right]$$ 注意这个变换在四维空间中，仍然是一个线性变换（具体来说是切变），但从三维空间角度来看，就是一个仿射变换，对三维向量进行了位移。 另外三维矩阵可以扩展成四维矩阵来表示普通的三维向量的变换，如下所示： $$\\begin{aligned} &amp;\\left[\\begin{array}{llll} x &amp; y &amp; z &amp; 1 \\end{array}\\right]\\left[\\begin{array}{cccc} m_{11} &amp; m_{12} &amp; m_{13} &amp; 0 \\ m_{21} &amp; m_{22} &amp; m_{23} &amp; 0 \\ m_{31} &amp; m_{32} &amp; m_{33} &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{array}\\right]\\ &amp;=\\left[\\begin{array}{llll} x m_{11}+y m_{21}+z m_{31} &amp; x m_{12}+y m_{22}+z m_{32} &amp; x m_{13}+y m_{23}+z m_{33} &amp; 1 \\end{array}\\right] \\end{aligned}$$ 因此，如果一个三维向量需要先进行旋转变换（变换矩阵为$\\mathbf{R}$），再进行位移变换（变换矩阵为$\\mathbf{T}$），则矩阵及表达式如下： $$\\mathbf{R}=\\left[\\begin{array}{cccc} r_{11} &amp; r_{12} &amp; r_{13} &amp; 0 \\ r_{21} &amp; r_{22} &amp; r_{23} &amp; 0 \\ r_{31} &amp; r_{32} &amp; r_{33} &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{array}\\right], \\quad \\mathbf{T}=\\left[\\begin{array}{cccc} 1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; 0 \\ \\Delta x &amp; \\Delta y &amp; \\Delta z &amp; 1 \\end{array}\\right]$$ $$\\mathbf{v}^{\\prime}=\\mathbf{v R T}=\\mathbf{v}(\\mathbf{R T})=\\mathbf{v M}$$ 其中$\\mathbf{M}$为两个变换结合的变换矩阵，表示如下： $$\\begin{aligned} \\mathbf{M}=\\mathbf{R} \\mathbf{T} &amp;=\\left[\\begin{array}{cccc} r_{11} &amp; r_{12} &amp; r_{13} &amp; 0 \\ r_{21} &amp; r_{22} &amp; r_{23} &amp; 0 \\ r_{31} &amp; r_{32} &amp; r_{33} &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{array}\\right]\\left[\\begin{array}{cccc} 1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; 0 \\ \\Delta x &amp; \\Delta y &amp; \\Delta z &amp; 1 \\end{array}\\right] \\ &amp;=\\left[\\begin{array}{cccc} r_{11} &amp; r_{12} &amp; r_{13} &amp; 0 \\ r_{21} &amp; r_{22} &amp; r_{23} &amp; 0 \\ r_{31} &amp; r_{32} &amp; r_{33} &amp; 0 \\ \\Delta x &amp; \\Delta y &amp; \\Delta z &amp; 1 \\end{array}\\right] \\end{aligned}$$ 可以看出，矩阵$\\mathbf{M}$是将$\\mathbf{R}$和$\\mathbf{T}$中的变换部分和在了一起，即 $$\\mathbf{M}=\\left[\\begin{array}{ll} \\mathbf{R} &amp; \\mathbf{0} \\ \\mathbf{t} &amp; 1 \\end{array}\\right]$$ 另外如前所述，当一个齐次空间中的向量坐标的第四个元素$w=0$时，这个坐标表示的是位置而不是位移，如下所示，取向量的坐标为$\\left[\\begin{array}{llll}x &amp; y &amp; z &amp; 0\\end{array}\\right]$，与$\\mathbf{M}$相乘的结果将不包含位移信息，如： $$\\begin{array}{ll} \\left[\\begin{array}{llllllll} x &amp; y &amp; z &amp; 0 \\end{array}\\right]\\left[\\begin{array}{llll} r_{11} &amp; r_{12} &amp; r_{13} &amp; 0 \\ r_{21} &amp; r_{22} &amp; r_{23} &amp; 0 \\ r_{31} &amp; r_{32} &amp; r_{33} &amp; 0 \\ \\Delta x &amp; \\Delta y &amp; \\Delta z &amp; 1 \\end{array}\\right] \\ &amp; =\\left[\\begin{array}{llll} x r_{11}+y r_{21}+z r_{31} &amp; x r_{12}+y r_{22}+z r_{32} &amp; x r_{13}+y r_{23}+z r_{33} &amp; 0 \\end{array}\\right] \\end{array}$$ General Affine Transformations 在四维齐次空间中，就能实现仿射变换而不仅仅是线性变换，经常使用的仿射变换包括： 绕着不经过原点的任意轴旋转 沿着不经过原点的任意轴缩放 沿着不经过原点的任意平面反射 投影至任意不包括原点的平面 这些变换的基本思路都是，先将线性变换的中心（如旋转轴，缩放轴，投影平面等）移动到原点，再进行线性变换，最后位移回原点。将位移的矩阵命名为$\\mathbf{T}$，将线性变换的矩阵命名为$\\mathbf{R}$，即： $$\\mathbf{T}=\\left[\\begin{array}{cccc} 1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; 0 \\ -p_{x} &amp; -p_{y} &amp; -p_{z} &amp; 1 \\end{array}\\right]=\\left[\\begin{array}{cc} \\mathbf{I} &amp; \\mathbf{0} \\ -\\mathbf{p} &amp; 1 \\end{array}\\right]$$ $$\\mathbf{R}{4 \\times 4}=\\left[\\begin{array}{cccc} r{11} &amp; r_{12} &amp; r_{13} &amp; 0 \\ r_{21} &amp; r_{22} &amp; r_{23} &amp; 0 \\ r_{31} &amp; r_{32} &amp; r_{33} &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{array}\\right]=\\left[\\begin{array}{cc} \\mathbf{R}_{3 \\times 3} &amp; \\mathbf{0} \\ \\mathbf{0} &amp; 1 \\end{array}\\right]$$ $$\\mathbf{T}^{-1}=\\left[\\begin{array}{cccc} 1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; 0 \\ p_{x} &amp; p_{y} &amp; p_{z} &amp; 1 \\end{array}\\right]=\\left[\\begin{array}{ll} \\mathbf{I} &amp; 0 \\ \\mathbf{p} &amp; 1 \\end{array}\\right]$$ 按上述的，先位移再线性变换再位移回去的操作方法，实际变换过程为： $$\\begin{aligned} T R_{4 \\times 4} T^{-1} &amp;=\\left[\\begin{array}{ll} I &amp; 0 \\ -p &amp; 1 \\end{array}\\right]\\left[\\begin{array}{ll} R_{3\\times 3} &amp; 0 \\ 0 &amp; 1 \\end{array}\\right]\\left[\\begin{array}{ll} I &amp; 0 \\ p &amp; 1 \\end{array}\\right] \\ &amp;=\\left[\\begin{array}{ll} R_{3\\times 3} &amp; 0 \\ -p \\left(R_{3\\times 3}\\right) &amp; 1 \\end{array}\\right]\\left[\\begin{array}{ll} I &amp; 0 \\ p &amp; 1 \\end{array}\\right] \\ &amp;=\\left[\\begin{array}{ll} R_{3 \\times 3} &amp; 0 \\ -p\\left(R_{3 \\times 3}\\right)+p &amp; 1 \\end{array}\\right] \\end{aligned}$$ $4 \\times 4$ Matrices and Perspective Projection 在第五章中提到了正交投影，正交投影是一种平行投影，每条顶点和其投影点的连线是平行的，如下： 在3D中的透视投影（Perspective projection）投影同样也是投影到二维平面上，不同的是所有的顶点与投影点的连线会相会在投影中心（Center of projection）上，且在投影平面后这些连线的延伸会在投影平面上构成一个倒转的图形，如下所示： 对于一个透视投影来说，投影平面是固定的，投影中心距离投影平面的距离也是固定的，因此物体离投影中心越近，其在投影平面上的构成的图像大小就越大，这个现象称为透视收缩（perspective forshortening）。 A pinhole Camera 透视投影之所以在图形学中很重要，是因为它就是人类视觉系统工作的方式。人眼可以简化为是一个小孔成像系统，如下所示： 盒子上的小孔即是投影中心，盒子的后表面就是投影平面。 小口成像可以用坐标来表示，将投影看作是原点，将物体的顶点看作是$p$点，将物体在投影平面上的成像看作是$p^{\\prime}$，如下图所示： 根据三角形相似定理，可得： $$\\frac{-p_{y}^{\\prime}}{d}=\\frac{p_{y}}{z} \\quad \\Longrightarrow \\quad p_{y}^{\\prime}=\\frac{-d p_{y}}{z}$$ 同理可得： $$p_{x}^{\\prime}=\\frac{-d p_{x}}{z}$$ 因此，整个变换可以表达为： $$\\mathbf{p}=\\left[\\begin{array}{lll} x &amp; y &amp; z \\end{array}\\right] \\quad \\Longrightarrow \\quad \\mathbf{p}^{\\prime}=\\left[\\begin{array}{lll} x^{\\prime} &amp; y^{\\prime} &amp; z^{\\prime} \\end{array}\\right]=\\left[\\begin{array}{ccc} -d x / z &amp; -d y / z &amp; -d \\end{array}\\right]$$ 在计算机的实际运用中，上述结果中的负号是完全没意义的，因此可以等同于将投影平面移动到投影中心前面（这样的作法在真实物理世界中是不可行的），如下图： 则变换变为： $$\\mathbf{p}^{\\prime}=\\left[\\begin{array}{lll} x^{\\prime} &amp; y^{\\prime} &amp; z^{\\prime} \\end{array}\\right]=\\left[\\begin{array}{lll} d x / z &amp; d y / z &amp; d] \\end{array}\\right.$$ Perspective Projection Matrices 为了将上述的$p^{\\prime}$转换到四维齐次空间中，需要为$xyz$三个分量找出一个公因数作为$w$，即 $$\\mathbf{p}^{\\prime}=\\left[\\begin{array}{lll} d x / z &amp; d y / z &amp; d \\end{array}\\right]=\\left[\\begin{array}{lll} d x / z &amp; d y / z &amp; d z / z \\end{array}\\right]=\\frac{\\left[\\begin{array}{lll} x &amp; y &amp; z \\end{array}\\right]}{z / d}$$ 公因数为$z/d$，因此可以转换为齐次坐标： $$\\left[\\begin{array}{llll} x &amp; y &amp; z &amp; z / d \\end{array}\\right]$$ 对于齐次向量$[x,y,z,1]$如果想要转换到上述的齐次坐标，需要用下列矩阵，该矩阵称为投影矩阵： $$\\left[\\begin{array}{llll} x &amp; y &amp; z &amp; 1 \\end{array}\\right]\\left[\\begin{array}{llll} 1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; 1 / d \\ 0 &amp; 0 &amp; 0 &amp; 0 \\end{array}\\right]=\\left[\\begin{array}{llll} x &amp; y &amp; z &amp; z / d \\end{array}\\right]$$ 通过矩阵，求出$\\left[\\begin{array}{llll} x &amp; y &amp; z &amp; z / d \\end{array}\\right]$的过程并不是透视投影，将$\\left[\\begin{array}{llll} x &amp; y &amp; z &amp; z / d \\end{array}\\right]$转换为$\\left[\\begin{array}{llll} d x / z &amp; d y / z &amp; d &amp; 1 \\end{array}\\right]$的过程才是。 在真实运用中，投影矩阵会比这里更加复杂（同样也会称为裁剪矩阵），主要的区别在于： 在远剪切平面会保证$w=1$。这样做保证了深度检测的精确性（//TODO why？）。 还需要对$x，y$进行缩放来满足摄像机的视野（Field of view）要求。 引用： 3D Math Primer for Graphics and Game Development 2nd 2011","link":"/3DMathPrimerForGraphicsAGameDevelopment-Chapter6-Notes/"},{"title":"《MDA： A Formal Approach to Game Design and Game Research》 笔记","text":"《MDA： A Formal Approach to Game Design and Game Research》 笔记 这篇论文中，作者提出了一个名为MDA的形式上的框架，A指玩家游戏的感受，D指游戏运行时的行为，M指游戏的基本规则元素。 作者认为可以通过框架帮助设计师分析游戏，如从A推导出M，或从M预测会导致的A。 Introduction 在这篇论文中，作者提出了MDA框架（Mechanics，Dynamics,Aesthetics的缩写），这一种形式上的理解游戏的方法。该方法尝试将游戏设计与游戏开发联系在一起，将游戏评论和技术上的游戏研究联系在一起。 Towards a Comprehensive Framework 目前的游戏研究很多是针对一个游戏领域，这篇文章是从整个游戏的角度去思考：从游戏系统的基本方法，到游戏设计的总体目标，到最终玩家的体验。 一个系统性的连贯性是从解决和满足系统中各个部分的限制和要求中创造的。对于游戏而言，连贯性需要从游戏的各个层面中获得，可以通过自底向上的思考，即思考如何通过游戏代码实现游戏概念，概念又如何最终体现在玩家体验，也可以从自顶向下的思考，即从玩家体验开始分析，体验是如何从游戏概念中获得的，游戏概念又是怎么通过游戏代码实现的。 MDA框架就是帮助游戏从业者进行上述的思考，无论是自底向上还是自顶向下。 MDA 游戏设计师和玩家的关系是，游戏设计师创造了游戏，玩家消费游戏，如下图所示： 玩家消费设计师创造的游戏的过程，可以看作为是“设计师定义了游戏的规则，游戏的规则构成了游戏系统，游戏系统决定了玩家的游戏体验”，如下所示： 可以将整个过程抽象为如下： Mechancis：下简称为M，表示游戏的算法和数据结构 Dynamics：下简称为D，表示游戏运行时的行为，包括玩家的输入和游戏系统的输出 Aesthetics：下简称为A，描述了玩家在游戏时的情绪上的反应 这个框架的基本思想是，游戏是相对于媒体而言，更像是一个手工制品，它的内容很大一部分来自于玩家的行为。而不是像电影这样的媒介，所有的内容都是直接传递给观众的。 MDA in Detail MDAs as Lens 可以将MDA作为一个观察游戏的方法。设计师的角度使用MDA来看游戏，游戏的M在运行时形成了D，最后反应为玩家的A。从玩家角度来看，A是来自于观察D，而D是来自也运行的M。如下所示： 可以看出，无论是修改M还是A，都会最终都会反映在MDA的另一端。 Aesthetics A表示玩家游戏时的体验，设计师的目的是让玩家在游戏时感到有趣，有趣可以体现在如下方面： Sensation：来自于感官愉悦 Fantasy：来自于幻想 Narrative：来自于故事情节 Challenge：来自于克服困难 Fellowship：来自于社交 Discovery：来自于发现的过程 Expression：来自于自我情感的发现 Submission：来自于消磨时光 大部分的游戏的有趣都是上述多个点的结合，如最终幻想是Fantasy, Narrative, Expression, Discovery, Challenge, Submission，模拟人生是 Discovery, Fantasy, Expression, Narrative。但是每个游戏中这些不同的点不是平均的，都有各自的着重点。 Aesthetic Models A模型是作为一个指南针的存在，指导D和M该如何去设计实现。 如在竞技游戏中，玩家的情绪上的参与感（A）是来自于击败对手的渴望，所以在设计游戏时，D和M的关键就在于如何提供快速清晰的反馈和对抗性的游戏方式。 Dynamic Models D模型直接影戏了玩家对于游戏的体验（即D构成了A）。比如，A中的Challenge来自游戏时的时间限制或者对手的竞争，Fellowship来自于游戏时同一个队伍的信息交流，或者游戏时玩家发现组队合作比自己单打独斗更有利。 在设计时，应该先构建一个模型，用这个模型来预测游戏运行时会发生的事情（D）。如大富翁中每次玩家有两个六面筛子，那么投筛子出现的点数概率分布如下： 可以根据这个模型来预测游戏时，玩家走完一圈需要花费多少时间。 同样的，可以进一步通过游戏运行时发生的事（D），来预测玩家的情绪（A）。 如大富翁中，富有的玩家拥有更多的土地，拥有土地多的玩家有更高的概率收到租金，于是就会变得更加的富有，而贫穷的玩家会愈发贫穷，且富有的玩家始终是少数，毕竟资源是有限的。那么在游戏中，只有小部分的富有玩家会有参与感。 这个问题可以通过引入负反馈解决，如在游戏中更多的奖励贫困玩家，或给富有玩家增加限制，通过这些规则（M）来改变运行时的情况（D）进而改变玩家的情绪（A）。 Mechanics M包括玩家在游戏中可以进行的操作和行为，以及玩家可以看到的各种游戏元素等等。如对于射击游戏而言，武器，弹药和玩家的出生点就是M。 修改M可以最终影响到运行时的D，如在大富翁中为富有的玩家引入税，为贫困的玩家引入保证金。税和保证金就是M，但他们构成了负反馈，即会影响了运行时的D。而这些D的变换，会改变只有极少数的玩家有参与感的问题，即又进一步影响了玩家的A。 Tuning 在分析游戏时，需要反反复复的进行迭代，去修改M。该如何修改M的想法可以来自于对D和A的分析。 MDA at Work 这里作者以设计一款针对不同年龄段的游戏作为例子，展示如何从上层的A推导出M该如何创建。这里的例子是些非常笼统的概念，需要展示的仅仅是A到M的推导。 First Pass 如果一个游戏是针对3到7岁的孩子，那么游戏的A应该专注于Exploration和Discovery，这样要需要游戏时的行为（D）不是竞赛性的，所以游戏中的规则和元素（M）可以是轻松愉快的，如有趣的内置语音与玩家交流，与孩子大闹的小物件等等。 Second Pass 如果是针对7-12岁的孩子，那么游戏的A应该是有更多的Challenge，或许也应该包含一些narrative。在运行时（D）,玩家应该可以与别的玩家进行交流，共同发展关系，也可以增加一些时间限制（M）来实现Challenge。 Third Pass 如果针对14-35岁的玩家，游戏的A可以是关于Fantasy的，有更多的Challenge等。这时候运行时就可以有更多策略方面的玩法，比如选择适当的技能，进行适当的战斗，对应的M可以是技能树之类的元素。 Conclusion 综上，MDA是一个形式化的，帮助设计与开发的迭代框架。即游戏设计师通过从玩家的A出发，来推导出该如何设计M，或者从M出发，预测会导致怎么样的A。 引用： Hunicke, R., LeBlanc, M. and Zubek, R., 2004, July. MDA: A formal approach to game design and game research. In Proceedings of the AAAI Workshop on Challenges in Game AI (Vol. 4, No. 1, p. 1722).","link":"/AFormalApproachToGameDesignAndGameResearch-Notes/"},{"title":"《3D数学基础：图形和游戏开发》第九章笔记","text":"《3D数学基础：图形和游戏开发》第九章笔记 9.1节 关于图形的表示法分类 9.2节 介绍了射线 9.3节 介绍了球和圆 9.4节 介绍了边界盒 9.5节 介绍了平面 9.6节 介绍了三角形 9.7节 介绍了多边形 Chapter 9 Geometric Primitives Representation Techniques 这一节介绍不同的用来表达基本图形的方法： 第一种是隐式表达（Implicit form），即用一个等式或不等式来描述关系，如下式是描述球的，当为等号时，说明点在球面上，如果小于则说明点在球内，大于说明点在球外。 $$x^{2}+y^{2}+z^{2}=1$$ 第二种表达式为参数化表达（Parametric form），如下式为参数化表达圆，其中$t$为的参数，通常来说参数的数值为$[0,1]$ $$x(t)=\\cos 2 \\pi t, \\quad y(t)=\\sin 2 \\pi t$$ 参数化表达圆的示意图如下： 参数化表达可以进一步细分为一元表达（univariate）， 即只有一个参数，和二元表达（bivariate），即有两个参数。一元表达描述的是一个曲线，二元表达描述的是一个曲面。 第三种表达方式是直接表达，但这种表达没有统一的形式。如使用两个点来描述一条直线，用半径和圆心来描述一个圆。 Lines and Rays 从数学角度来说，关于线条有三个定义： 直线是用来描述一个朝正反方向都无限延伸的线 线段是用来描述由确切两个点构成的有限长度的线。这两个点并没有起点和终点之分，即不存在方向。 射线是用来描述有一个起点，和朝一个方向无限延伸的线。 从几何角度来说 直线描述与数学角度相同 线段描述与数学角度相同 射线是用来描述一个有方向的线段，即存在起点和终点的概念。 在电子游戏中，通常只使用射线，直线和线段的概念很少出现。 Rays 如果用直接方法定义射线，直接给定终点和起点即可，$\\mathbf{P}{org}$和$\\mathbf{P}{end}$ 用参数化表达射线，表达式如下 $$\\mathbf{p}(t)=\\mathbf{p}_{0}+t \\mathbf{d}$$ 其中，$\\mathbf{P}_0$为起点，$\\mathbf{d}$为射线的有向长度，参数$t$的取值范围是$[0,1]$ 射线的参数化表达也可以进一步拆分为两部分，即分别描述x分量和y分量 $$x(t)=x_{0}+t \\Delta x, \\quad y(t)=y_{0}+t \\Delta y$$ 可以看出这个表达存在四个自由度，分别是$x_0$和$y_0$表示起点和$\\Delta x$和$\\Delta y$表示一个分量上的有向长度。 Special 2D Representation of Lines 这一节介绍一些二维射线的特殊表达 截距形式（Slope-interpret form） $$y=m x+y_{0}$$ 其中$m$表示射线的斜率(rise/run)，$y_0$表示截距（y-intercept），如下图所示 截距形式的问题在于，它无法表达沿着Y轴向上的射线。 隐式表达（Implicit definition） 射线的隐式表达实际上相当于截距形式的变形 $$a x+b y=d$$ 而且隐式表达可以进一步使用向量的点乘表达， $$\\mathbf{p} \\cdot \\mathbf{n}=d$$ 其中$\\mathbf{n}=[a, b]$表示射线的法线方向，且是一个单位向量。 $\\mathbf{p}=[x,y]$表示射线上的点。 $d$表示射线沿着$\\mathbf{n}$方向上离原点的距离。 如下所示： 垂直线等分法： 该方法定义两个点$\\mathbf{q,r}$，射线用来描述距离这两个点距离相等的点的几何。如下图所示： Converting between Representations 直接表达法： $$\\mathbf{P}{end}和\\mathbf{P}{org}$$ 截距法： $$y=m x+y_{0}$$ 隐式表达法： $$a x+b y=d$$ 向量表达法： $$\\mathbf{p} \\cdot \\mathbf{n}=d$$ 垂直线等分法法： $$与点\\mathbf{q}和点\\mathbf{r}距离相同的点的合集$$ 上述相互之间的转换方法为： 直接表达法与隐式表达法的转换 直接表达即为通过两个点$\\mathbf{P}{end}$和$\\mathbf{P}{org}$来描述一条射线，为了将其转换为隐式表达法首先需要计算出两点之间的有向距离 $$\\mathbf{d}=\\mathbf{p}{\\text {end }}-\\mathbf{p}{\\text {org }}$$ $\\mathbf{d}$不仅表示两点间的距离还表示两点间的方向 因此如果表示为截距法，那么射线的斜率为$m=d_y/d_x$，将点$\\mathbf{P}org$代入式子中，可以求得$y_0=y{org}-\\frac{d_y}{d_x}x_{org}$ 转换为隐式表达法则有： $$a=d_{y}, \\quad b=-d_{x}, \\quad d=x_{\\text {org }} d_{y}-y_{\\text {org }} d_{x}$$ 隐式表达法和截距法的转换 使用隐式表达法中的$a,b,d$来描述截距法，则有 $y=-\\frac{a}{b}x+\\frac{d}{b}$ 隐式表达法求射线的法线和距离 隐式表达法可以直接转换为向量形式的表达，即 $$a x+b y=\\mathbf{p} \\cdot \\mathbf{n}=[x \\quad y]\\cdot[a \\quad b]=d$$ 即$\\mathbf{n}t[a \\quad b]$，如果将其转换为单位向量，即 $$\\hat{\\mathbf{n}}=[a \\quad b]/\\sqrt{a^2+b^2}$$ 如果用$\\hat{\\mathbf{n}}$作为表达式，则原表达式两边都要等除$\\sqrt{a^2+b^2}$，即 $$ [x \\quad y]\\cdot \\frac{[a \\quad b]}{\\sqrt{a^2+b^2}}=\\frac{d}{\\sqrt{a^2+b^2}} $$ $$ [x \\quad y]\\cdot \\hat{\\mathbf{n}}=distance $$ 其中$\\hat{\\mathbf{n}}$为射线的法线，$distance$为射线沿着法线方向与原点的距离。 垂直线等分法转换为隐式表达法 有两个点$\\mathbf{q}和点\\mathbf{r}$，其中$\\mathbf{r}$是x轴分量更大的点。 可以得到由这两个点构成的线段的斜率为$r_{y}-q_{r}/r_{x}-q_{x}$，因为所求的射线，即这两个点中间的垂直线斜率相反，所以可以得到所求射线的斜率$m=q_{r}-r_{y}/r_{x}-q_{x}$ 转换为隐形表达式，则可得： $$\\begin{aligned} &amp;a=q_{y}-r_{y}\\ &amp;b=r_{x}-q_{x} \\end{aligned}$$ 点$\\mathbf{q}和点\\mathbf{r}$的中点在所求射线上，且该中点为$\\mathbf{q}+\\frac{\\mathbf{r-q}}{2}=\\frac{\\mathbf{q+r}}{2}$，将该点带入隐形表达式，可得 $$d=\\frac{\\mathbf{q}+\\mathbf{r}}{2} \\cdot\\left[\\begin{array}{ll} a &amp; b \\end{array}\\right]$$ 进一步化简得： $$\\begin{aligned} d &amp;=\\frac{\\mathbf{q}+\\mathbf{r}}{2} \\cdot\\left[\\begin{array}{cc} a &amp; b \\end{array}\\right]=\\frac{\\mathbf{q} +\\mathbf{r}}{2} \\cdot\\left[\\begin{array} {cc} q_{y}-r_{y} &amp; r_{x}-q_{x} \\end{array}\\right] \\ &amp;=\\frac{\\left(q_{x}+r_{x}\\right)\\left(q_ {y}-r_{y}\\right)+\\left(q_{y}+r_{y}\\right) \\left(r_{x}-q_{x}\\right)}{2} \\ &amp;=\\frac{\\left(q_{x} q_{y}-q_{x} r_{y}+r_ {x} q_{y}-r_{x} r_{y}\\right)+\\left(q_{y} r_{x}-q_{y} q_{x}+r_{y} r_{x}-r_{y} q_{x} \\right)}{2} \\ &amp;=r_{x} q_{y}-q_{x} r_{y} \\end{aligned}$$ Sphere and Circles 球常用来作为物体的边框，一是用球作为边框比较简单，二是因为当用球来作为边框时，物体的旋转并不会造成任何的影响，因此物体旋转后的再次计算边框。 球的隐式定义如下： $$|\\mathbf{p}-\\mathbf{c}|=r$$ 其中$\\mathbf{p}$表示球上的点,$\\mathbf{c}$表示球心，两者都是向量。非向量形式的隐式表达如下： $$\\begin{aligned} \\left(x-c_{x}\\right)^{2}+\\left(y-c_{y}\\right)^{2} &amp;=r^{2} \\ \\left(x-c_{x}\\right)^{2}+\\left(y-c_{y}\\right)^{2}+\\left(z-c_{z}\\right)^{2} &amp;=r^{2} \\end{aligned}$$ 球的其他计算数学计算如下： 直径 $$D=2 r$$ 周长 $$C=2 \\pi r=\\pi D$$ 圆的面积 $$A=\\pi r^{2}$$ 球的表面积 $$S=4 \\pi r^{2} $$ 球的体积 $$V=\\frac{4}{3} \\pi r^{3}$$ Bounding Boxes AABB（Axially aligned bounding box）通常用来表示立方体形状的边框，而且立方体的边必须与当前坐标系下坐标轴相平行。 另一种不太常用的立方体边框为OBB（Oriented bounding box），这里立方体的边与坐标系的轴没有任何约束。相对来说，AABB更容易创建，而且OBB仅仅是AABB在一个坐标系下旋转，所以这一节只会讨论AABB。 OBB和AABB的区别并不在于边框本身，而是在于坐标系。如果一个边框用于在世界坐标中旋转了的物体，那么这个边框从物体坐标系角度看是AABB，但是从世界坐标系角度看是OBB Representing AABBs 一种表达方式是限定三个坐标系的范围，即 $$x_{\\min } \\leq x \\leq x_{\\max }, \\quad y_{\\min } \\leq y \\leq y_{\\max }, \\quad z_{\\min } \\leq z \\leq z_{\\max }$$ 也可以通过两个对角线的点来进行表达，即 $$\\mathbf{p}{\\min }=\\left[\\begin{array}{lll} x{\\min } &amp; y_{\\min } &amp; z_{\\min } \\end{array}\\right], \\quad \\mathbf{p}{\\max }=\\left[\\begin{array}{ccc} x{\\max } &amp; y_{\\max } &amp; z_{\\max } \\end{array}\\right]$$ 其中边框的中点可以表示为： $$\\mathbf{c}=\\left(\\mathbf{p}{\\min }+\\mathbf{p}{\\max }\\right) / 2$$ 边框的尺寸向量（Size vector）用$\\mathbf{s}$表示，值为对角线两个点间的有向距离： $$\\mathbf{s}=\\mathbf{p}{\\max }-\\mathbf{p}{\\min }$$ 同样也可以计算半径向量，如下所示： $$\\mathbf{r}=\\mathbf{p}_{\\max }-\\mathbf{c}=\\mathbf{s} / 2$$ 关于边框的值$P_{min}, P_{\\max }, \\mathbf{c}, \\mathbf{s}, \\text {和} \\mathbf{r}$，除了$\\mathbf{s}和\\mathbf{r}$这两个值的搭配，通过其他任意搭配都可以求出边框的其他值。 Computing AABBs //TODO // 书中给出了关于AABB的类 AABBs versus Bounding Spheres AABB对于球边框的优势： 计算由一系列的点构成的AABB面只需要线性时间（比较出最小的点和最大的点即可），而计算出由一系列的点构成的球相对复杂。 通常来说，对于同一个物体AABB边框会更小，最坏的情况下，AABB也只比球边框大不到两倍（当物体本身是一个球时），而最坏情况下球边框可能会比AABB大很多。 如下所示，蓝色为球边框，红色为AABB 球边框对于AABB边框的优势： 物体的变换不会造成球边框的变化，如下图所示： Transforming AABBs 如之前所述，AABB边框在物体变换后也会发生变化，这一节介绍如何计算变换后的AABB边框。 通常有两种思路，一种是对变换后的物体再次求解AABB边框，第二种是直接对AABB边框进行同样的变换。通常第二种方法比第一种计算更快，因为无论物体本身多复杂，计算AABB的变换只需要计算8个顶点，所以通常第二种方法用的较多。 第二种方法中直接将AABB变换后的结果作为新的AABB是不行的，因为可能旋转会导致原先的$\\mathbf{P}{max}$变得比$\\mathbf{P}{min}$更小。所以直接对AABB边框进行同样的变换后，根据变换后的8个顶点，得出新AABB框，如下图所示： 上图的右半部分是旋转后的物体和ABBB，图中蓝色的部分是直接对AABB进行了旋转，此时在世界坐标系下，它已经变成了OBB。 内部的红色边框为第一种方法，是根据旋转后的图形再次求解AABB。该方法准确但效率较低。 外部的红色边框为第二种方法，它是由旋转后的原AABB（蓝色部分）计算得到的，它比理想上的AABB框要更大。该方法迅速，只需要计算AABB的顶点，但通常会造成计算出的边框更大。 第二种方法的计算如下，假设$[x \\quad y \\quad z]$是原先AABB的顶点，变换后的顶点为$[x^{\\prime} \\quad y^{\\prime} \\quad z^{\\prime}]$，则转换果然如下： $$\\begin{aligned} \\left[\\begin{array}{ll} x^{\\prime} &amp; y^{\\prime} &amp; z^{\\prime} \\end{array}\\right] &amp;=\\left[\\begin{array}{lll} x &amp; y &amp; z \\end{array}\\right]\\left[\\begin{array}{lll} m_{11} &amp; m_{12} &amp; m_{13} \\ m_{21} &amp; m_{22} &amp; m_{23} \\ m_{31} &amp; m_{32} &amp; m_{33} \\end{array}\\right] \\ x^{\\prime} &amp;=m_{11} x+m_{21} y+m_{31} z \\ y^{\\prime} &amp;=m_{12} x+m_{22} y+m_{32} z \\ z^{\\prime} &amp;=m_{13} x+m_{23} y+m_{33} z \\end{aligned}$$ 其中矩阵表示进行的变换。 通常的的方式是将八个顶点分别通过上式进行计算，然后找出最小点和最大点。 但是观察后发现，可以直接通过矩阵中的元素正负号来直接求出最大点和最小点，下面以二维平面的变换作为例子，即变换为： $$\\begin{aligned} \\left[\\begin{array}{ll} x^{\\prime} &amp; y^{\\prime} \\end{array}\\right] &amp;=\\left[\\begin{array}{lll} x &amp; y \\end{array}\\right]\\left[\\begin{array}{lll} m_{11} &amp; m_{12} \\ m_{21} &amp; m_{22} \\end{array}\\right] \\ x^{\\prime} &amp;=m_{11} x+m_{21} y\\ y^{\\prime} &amp;=m_{12} x+m_{22} y \\ \\end{aligned}$$ 在二维平面下中，AABB有四个顶点，$[x_{min},y_{min}],[x_{min},y_{max}],[x_{max},y_{min}],[x_{max},y_{max}]$ 所以$x^{\\prime}$也相对有四种可能，即$m_{11} x_{min}+m_{21} y_{min}$，$m_{11} x_{min}+m_{21} y_{max}$，$m_{11} x_{max}+m_{21} y_{min}$，$m_{11} x_{max}+m_{21} y_{max}$， 如果将$x^{\\prime}$拆分成两部分来看，即$m_{11}x$和$m_{21}y$，如果$m_{11}$是正数，那么要求得更小的$x^{\\prime}$，x是$x_{min}$时更合适，反之$x_{max}$更合适。对于$m_{21}$也是同理，$y_{min}$适合$m_{21}$是正数的情况，$y_{max}$适合$m_{21}$是负数的情况 因此求$x_{min}^{\\prime}$，只需要判断$m_{11}$和$m_{21}$的大小，然后直接选取对应的x和y分量，进行累加就行，不需要求出所有的$x^{\\prime}$可能进行比较。 //TODO //书中有对应的求新AABB算法 Planes 3D中的平面对应2D中的射线，其定义也与在2D中的射线类似：与给定的两个点距离相同的所有的点的集合。 The Plane Equation：An Implicit Definnition of a plane 隐式表达法： 用标量 $$a x+b y+c z=d$$ 用向量 $$\\mathbf{p} \\cdot \\mathbf{n}=d$$ 其中$\\mathbf{p}$为在平面上的点，$\\mathbf{n}=[a \\quad b \\quad c]$为垂直平面的线。 证明如下，假设平面上还有一个点$\\mathbf{q}$： $$\\begin{aligned} \\mathbf{n} \\cdot \\mathbf{p} &amp;=d \\ \\mathbf{n} \\cdot \\mathbf{q} &amp;=d \\ \\mathbf{n} \\cdot \\mathbf{p} &amp;=\\mathbf{n} \\cdot \\mathbf{q} \\ \\mathbf{n} \\cdot \\mathbf{p}-\\mathbf{n} \\cdot \\mathbf{q} &amp;=0 \\ \\mathbf{n} \\cdot(\\mathbf{p}-\\mathbf{q}) &amp; =0 \\end{aligned}$$ 如果要求平面的法线，对$n$进行归一化即可 $$ \\hat{\\mathbf{n}}=\\frac{[a \\quad b \\quad c]}{\\sqrt{a^2+b^2+c^2}} $$ 用法线表示平面为： $$ \\mathbf{p}\\cdot \\hat{\\mathbf{n}}=\\frac{d}{\\sqrt{a^2+b^2+c^2}}=distance $$ 其中distance为平面距离原点的距离 平面分正反面，沿着法线方向看，看到的是背面，法线指向的方向是正面，如下图所示： Defining a Plane by Using Three Points 假设有三个在平面上的点$\\mathbf{p}{1}, \\mathbf{p}{2}$和$\\mathbf{p}_{3}$，且他们按顺时针方向排列，如下图所示： 可以按照下式，求出法线： $$\\mathbf{e}{3}=\\mathbf{p}{2}-\\mathbf{p}{1}, \\quad \\mathbf{e}{1}=\\mathbf{p}{3}-\\mathbf{p}{2}, \\quad \\hat{\\mathbf{n}}=\\frac{\\mathbf{e}{3} \\times \\mathbf{e}{1}}{\\left|\\mathbf{e}{3} \\times \\mathbf{e}{1}\\right|}$$ 将任意一个点带入法线表达式，既能求出distance ，如$distance=\\hat{\\mathbf{n}}\\cdot \\mathbf{p}_1$ 即最终表达式为 $$\\mathbf{P}\\cdot \\hat{\\mathbf{n}}=\\hat{\\mathbf{n}}\\cdot \\mathbf{p}_1$$ “Best Fit” Plane for More than Three Points 当给定了多个点，要根据多个点求平面时，不能简单的从多个点中任意选取出三个点，因为： 选取的三个点可能在一条线上 多个点构成的多边形可能是凹的，即虽然按顺时针在多边形上取了三个点，但实际上它们是逆时针的 由于精度或各种原因，三个点可能实际上并不在一个平面上。 所以解法是用所有的点来计算，如有以下点： $$\\begin{aligned} &amp;\\mathbf{p}{1}=\\left[\\begin{array}{lll} x{1} &amp; y_{1} &amp; z_{1} \\end{array}\\right]\\ &amp;\\mathbf{p}{2}=\\left[\\begin{array}{lll} x{2} &amp; y_{2} &amp; z_{2} \\end{array}\\right]\\ &amp;\\vdots\\ &amp;\\mathbf{p}{n-1}=\\left[\\begin{array}{lll} x{n-1} &amp; y_{n-1} &amp; z_{n-1} \\end{array}\\right] \\ &amp;\\mathbf{p}{n} =\\left[\\begin{array}{lll} x{n} &amp; y_{n} &amp; z_{n}\\end{array}\\right] \\end{aligned}$$ 则法线为： $$\\begin{aligned} n_{x}=&amp;\\left(z_{1}+z_{2}\\right)\\left(y_{1}-y_{2}\\right)+\\left(z_{2}+z_{3}\\right)\\left(y_{2}-y_{3}\\right)+\\cdots \\ &amp; \\cdots+\\left(z_{n-1}+z_{n}\\right)\\left(y_{n-1}-y_{n}\\right)+\\left(z_{n}+z_{1}\\right)\\left(y_{n}-y_{1}\\right) \\ n_{y}=&amp;\\left(x_{1}+x_{2}\\right)\\left(z_{1}-z_{2}\\right)+\\left(x_{2}+x_{3}\\right)\\left(z_{2}-z_{3}\\right)+\\cdots \\ &amp; \\cdots+\\left(x_{n-1}+x_{n}\\right)\\left(z_{n-1}-z_{n}\\right)+\\left(x_{n}+x_{1}\\right)\\left(z_{n}-z_{1}\\right) \\ n_{z}=&amp;\\left(y_{1}+y_{2}\\right)\\left(x_{1}-x_{2}\\right)+\\left(y_{2}+y_{3}\\right)\\left(x_{2}-x_{3}\\right)+\\cdots \\ &amp; \\cdots+\\left(y_{n-1}+y_{n}\\right)\\left(x_{n-1}-x_{n}\\right)+\\left(y_{n}+y_{1}\\right)\\left(x_{n}-x_{1}\\right) \\end{aligned}$$ 即 $$\\begin{aligned} &amp;n_{x}=\\sum_{i=1}^{n}\\left(z_{i}+z_{i+1}\\right)\\left(y_{i}-y_{i+1}\\right)\\ &amp;n_{y}=\\sum_{i=1}^{n}\\left(x_{i}+x_{i+1}\\right)\\left(z_{i}-z_{i+1}\\right)\\ &amp;n_{z}=\\sum_{i=1}^{n}\\left(y_{i}+y_{i+1}\\right)\\left(x_{i}-x_{i+1}\\right) \\end{aligned}$$ //TODO: 推导该公式 在求出了$n$后，将所有的点都带入公式，然后求出平均的$d$，如下： $$d=\\frac{1}{n} \\sum_{i=1}^{n}\\left(\\mathbf{p}{i} \\cdot \\mathbf{n}\\right)=\\frac{1}{n}\\left(\\sum{i=1}^{n} \\mathbf{p}_{i}\\right) \\cdot \\mathbf{n}$$ Distance from Point to Plane 要求平面外点$\\mathbf{q}$距离平面的距离，可找出平面上离该点最近的点$\\mathbf{p}$，有向距离$\\mathbf{pq}$即为距离，当$\\mathbf{q}$处于平面的正方向，则距离为正数，否则为负数，如下图所示： 如果$\\mathbf{n}$是单位向量法线，即$\\hat{\\mathbf{n}}$，那么$a$即是有向距离。 在实际求解的过程中，实际上并不需要算出$\\mathbf{p}$的位置，如下所示： $$\\begin{aligned} \\mathbf{p}+a \\hat{\\mathbf{n}} &amp;=\\mathbf{q} \\ (\\mathbf{p}+a \\hat{\\mathbf{n}}) \\cdot \\hat{\\mathbf{n}} &amp;=\\mathbf{q} \\cdot \\hat{\\mathbf{n}} \\ \\mathbf{p} \\cdot \\hat{\\mathbf{n}}+(a \\hat{\\mathbf{n}}) \\cdot \\hat{\\mathbf{n}} &amp;=\\mathbf{q} \\cdot \\hat{\\mathbf{n}} \\ d+a &amp;=\\mathbf{q} \\cdot \\hat{\\mathbf{n}} \\ a &amp;=\\mathbf{q} \\cdot \\hat{\\mathbf{n}}-d \\end{aligned}$$ Triangles Notation 三角形是通过三个顶点定义的。通常在左手坐标系下，三个顶点的顺序为顺时针。 三角形的边和顶点的定义如下图所示： $$\\begin{aligned} &amp;\\mathbf{e}{1}=\\mathbf{v}{3}-\\mathbf{v}{2}, \\quad \\mathbf{e}{2}=\\mathbf{v}{1}-\\mathbf{v}{3}, \\quad \\mathbf{e}{3}=\\mathbf{v}{2}-\\mathbf{v}{1}\\ &amp;l{1}=\\left|\\mathbf{e}{1}\\right|, \\quad l{2}=\\left|\\mathbf{e}{2}\\right|, \\quad l{3}=\\left|\\mathbf{e}_{3}\\right| \\end{aligned}$$ 根据顶点，边，角的关系，有正弦和余弦定理，如下所示： 正弦定理为： $$\\frac{\\sin \\theta_{1}}{l_{1}}=\\frac{\\sin \\theta_{2}}{l_{2}}=\\frac{\\sin \\theta_{3}}{l_{3}}$$ 余弦定理为： $$\\begin{array}{l} l_{1}^{2}=l_{2}^{2}+l_{3}^{2}-2 l_{2} l_{3} \\cos \\theta_{1} \\ l_{2}^{2}=l_{1}^{2}+l_{3}^{2}-2 l_{1} l_{3} \\cos \\theta_{2} \\ l_{3}^{2}=l_{1}^{2}+l_{2}^{2}-2 l_{1} l_{2} \\cos \\theta_{3} \\end{array}$$ Area of a Triangle 最普通的求三角形面积为通过底和高，即 $$A=b h / 2$$ 海拉公式，可以通过三角形的三边长度来求得三角形面积： $$\\begin{aligned} &amp;s=\\frac{l_{1}+l_{2}+l_{3}}{2}=\\frac{p}{2}\\ &amp;A=\\sqrt{s\\left(s-l_{1}\\right)\\left(s-l_{2}\\right)\\left(s-l_{3}\\right)} \\end{aligned}$$ 还可以通过三角形的顶点本身来求得三角形面积，首先需要对三个顶点相减，获得三条边的向量$e_1,e_2,e_3$，然后再任意取其中两条求面积如下所示： $$A=\\frac{\\left|\\mathbf{e}{1} \\times \\mathbf{e}{2}\\right|}{2}$$ 该公式推导如下： 首先三角形的三条边都与X轴形成了一个梯形，如下图所示： 对该梯形的面积定义正负，如果边的顶点是由左到右，则梯形面积为正，否则面积为负，三边构成的梯形面积如下： $$\\begin{aligned} &amp;A\\left(\\mathbf{e}{1}\\right)=\\frac{\\left(y{3}+y_{2}\\right)\\left(x_{3}-x_{2}\\right)}{2}\\ &amp;A\\left(\\mathbf{e}{2}\\right)=\\frac{\\left(y{1}+y_{3}\\right)\\left(x_{1}-x_{3}\\right)}{2}\\ &amp;A\\left(\\mathbf{e}{3}\\right)=\\frac{\\left(y{2}+y_{1}\\right)\\left(x_{2}-x_{1}\\right)}{2} \\end{aligned}$$ 三角形的面积为三个梯形的累加，如下所示： $$\\begin{aligned} A &amp;=A\\left(\\mathbf{e}{1}\\right)+A\\left(\\mathbf{e}{2}\\right)+A\\left(\\mathbf{e}{3}\\right) \\ &amp;=\\frac{\\left(y{3}+y_{2}\\right)\\left(x_{3}-x_{2}\\right)+\\left(y_{1}+y_{3}\\right)\\left(x_{1}-x_{3}\\right)+\\left(y_{2}+y_{1}\\right)\\left(x_{2}-x_{1}\\right)}{2} \\ &amp;=\\frac{\\left(\\begin{array}{c} \\left(y_{3} x_{3}-y_{3} x_{2}+y_{2} x_{3}-y_{2} x_{2}\\right) \\ +\\left(y_{1} x_{1}-y_{1} x_{3}+y_{3} x_{1}-y_{3} x_{3}\\right) \\ +\\left(y_{2} x_{2}-y_{2} x_{1}+y_{1} x_{2}-y_{1} x_{1}\\right) \\end{array}\\right)}{2} \\ &amp;=\\frac{-y_{3} x_{2}+y_{2} x_{3}-y_{1} x_{3}+y_{3} x_{1}-y_{2} x_{1}+y_{1} x_{2}}{2} \\ &amp;=\\frac{y_{1}\\left(x_{2}-x_{3}\\right)+y_{2}\\left(x_{3}-x_{1}\\right)+y_{3}\\left(x_{1}-x_{2}\\right)}{2} \\end{aligned}$$ 将上式中的$y_1,y_2,y_3$都减去$y_3$，相当于三角形向下平移了一部分，所以结果不会变，即如下所示： $$\\begin{aligned} &amp;\\begin{aligned} A &amp;=\\frac{y_{1}\\left(x_{2}-x_{3}\\right)+y_{2}\\left(x_{3}-x_{1}\\right)+y_{3}\\left(x_{1}-x_{2}\\right)}{2} \\ &amp;=\\frac{\\left(y_{1}-y_{3}\\right)\\left(x_{2}-x_{3}\\right)+\\left(y_{2}-y_{3}\\right)\\left(x_{3}-x_{1}\\right)+\\left(y_{3}-y_{3}\\right)\\left(x_{1}-x_{2}\\right)}{2} \\end{aligned}\\ &amp;=\\frac{\\left(y_{1}-y_{3}\\right)\\left(x_{2}-x_{3}\\right)+\\left(y_{2}-y_{3}\\right)\\left(x_{3}-x_{1}\\right)}{2} \\end{aligned}$$ 上述结果即为点乘，即 $$A=\\frac{\\left|\\mathbf{e}{1} \\times \\mathbf{e}{2}\\right|}{2}$$ Barycentric Space 重心系统（Barycentric Space）是用三角形的三个顶点来描述三角形的位置，表达式为： $$\\left(b_{1}, b_{2}, b_{3}\\right) \\equiv b_{1} \\mathbf{v}{1}+b{2} \\mathbf{v}{2}+b{3} \\mathbf{v}_{3}$$ 其中 $$b_{1}+b_{2}+b_{3}=1$$ 重心系统实例如下： 注意其中三个顶点的数值，即 $$(1,0,0) \\equiv \\mathbf{v}{1}, \\quad(0,1,0) \\equiv \\mathbf{v}{2}, \\quad(0,0,1) \\equiv \\mathbf{v}_{3}$$ 三角形内的点，数值会在$[0,1]$之间，三角形外的点最少会有一个负数。 下图是重心系统的镶嵌，可以看出重心系统中值的运算规律： 如第一个数值表示顶点$\\mathbf{V}_1$对面的边所平行的部分，即$\\mathbf{V}_2$和$\\mathbf{V}_3$构成的边。因此可以看到该边上的点，值都为$(0,x,x)$，而平行于该边且经过$\\mathbf{v}_1$的边上面的点都为$(1,x,x)$，$\\mathbf{v}_1$点为$(1,0,0)$。同理顶点$\\mathbf{v}_2$对面，由$\\mathbf{v}_1$和$\\mathbf{v}_3$构成的边，表示第二个参数，即$(x,0,x)$。第三个参数的数值也同理可得。 重心系统的维度不是由参考点的维度决定的，而是由参考点的数量决定的。如三角形的重心系统，无论三角形的点是二维还是三维的，只要是三角形就需要三个参考点，所以该重心系统是二维的。 在图形学中，重心系统常应用在在计算顶点插值时，如计算片段的颜色。还被应用在计算相交问题时，一根射线可以根据与各个三角形片元的重心值判断是与哪个片元相交。 Calculating Barycentric Coordinates 如果通过重心系统计算笛卡尔坐标系，可以通过上述公式： $$\\left(b_{1}, b_{2}, b_{3}\\right) \\equiv b_{1} \\mathbf{v}{1}+b{2} \\mathbf{v}{2}+b{3} \\mathbf{v}_{3}$$ 由笛卡尔坐标系计算重心表达如下： 已知三个点和所求点的笛卡尔坐标系，如下图所示： 对于二维空间中的三角形，根据三角形重心的定义，可得： $$\\begin{aligned} b_{1} x_{1}+b_{2} x_{2}+b_{3} x_{3} &amp;=p_{x} \\ b_{1} y_{1}+b_{2} y_{2}+b_{3} y_{3} &amp;=p_{y} \\ b_{1}+b_{2}+b_{3} &amp;=1 \\end{aligned}$$ 三个表达式对应三个未知数$b_1,b_2,b_3$，因此这是一个三元一次方程的求解，结果为： $$\\begin{array}{l} b_{1}=\\frac{\\left(p_{y}-y_{3}\\right)\\left(x_{2}-x_{3}\\right)+\\left(y_{2}-y_{3}\\right)\\left(x_{3}-p_{x}\\right)}{\\left(y_{1}-y_{3}\\right)\\left(x_{2}-x_{3}\\right)+\\left(y_{2}-y_{3}\\right)\\left(x_{3}-x_{1}\\right)} \\ b_{2}=\\frac{\\left(p_{y}-y_{1}\\right)\\left(x_{3}-x_{1}\\right)+\\left(y_{3}-y_{1}\\right)\\left(x_{1}-p_{x}\\right)}{\\left(y_{1}-y_{3}\\right)\\left(x_{2}-x_{3}\\right)+\\left(y_{2}-y_{3}\\right)\\left(x_{3}-x_{1}\\right)} \\ b_{3}=\\frac{\\left(p_{y}-y_{2}\\right)\\left(x_{1}-x_{2}\\right)+\\left(y_{1}-y_{2}\\right)\\left(x_{2}-p_{x}\\right)}{\\left(y_{1}-y_{3}\\right)\\left(x_{2}-x_{3}\\right)+\\left(y_{2}-y_{3}\\right)\\left(x_{3}-x_{1}\\right)} \\end{array}$$ 根据上节中，通过顶点求三角形面积的方法，可以看出上式的分子和分母都是面积公式的两倍，因此也可以化简为： $$b_{1}=A\\left(T_{1}\\right) / A(T), \\quad b_{2}=A\\left(T_{2}\\right) / A(T), \\quad b_{3}=A\\left(T_{3}\\right) / A(T)$$ 对于三维空间中的三角形，也可以通过类似的方法求得结果。但是因为是三维空间，所以可以列出四个表达式（x,y,z三个表达式+一个和为1的限制），但是未知数还是三个（$b_1,b_2,b_3$）。因此需要删除一个表达式。 但是不能随便删除一个表达式，因为删去一个表达式的操作相当于将三维空间中的三角形投影至一个平面上，而如果三角形是垂直或者接近垂直于该平面，那么就会有问题。因此要选择投影面积最大的平面。 可以根据法线判断出投影面积最大的平面，如果法线为$[0,1,0]$，那么法线垂直于$xz$平面，即$xz$平面最大，即删除$y$，也因此法线上哪个分量最大，删除哪个表达式。 上述已经求得重心可以通过三角形的面积得到： $$b_{1}=A\\left(T_{1}\\right) / A(T), \\quad b_{2}=A\\left(T_{2}\\right) / A(T), \\quad b_{3}=A\\left(T_{3}\\right) / A(T)$$ 同时由之前公式可知，面积可以通过叉乘求得，即： $$A=\\frac{\\left|\\mathbf{e}{1} \\times \\mathbf{e}{2}\\right|}{2}$$ 因此理论上可以通过用顶点获取三角形的各边，再通过边的叉乘的得到结果。但存在的问题是，上述公式中的求模永远返回的是正数，因此这样就无法计算三角形外的点。 解决方法是再通过一个点积，如下所示： $$\\begin{aligned} \\mathbf{c} \\cdot \\hat{\\mathbf{n}} &amp;=|\\mathbf{c}||\\hat{\\mathbf{n}}| \\cos \\theta \\ &amp;=|\\mathbf{c}|(1)(\\pm 1) \\ &amp;=\\pm|\\mathbf{c}| \\end{aligned}$$ 其中$\\mathbf{c}$为叉乘的结果，$\\hat{\\mathbf{n}}$为法线，因此$\\mathbf{c}$必然平行于$\\hat{\\mathbf{n}}$。如果两者同向则返回正数，否则返回负数。 整个计算如下图所示： 其中： $$\\begin{aligned} &amp;\\mathbf{e}{1}=\\mathbf{v}{3}-\\mathbf{v}{2}, \\quad \\mathbf{e}{2}=\\mathbf{v}{1}-\\mathbf{v}{3}, \\quad \\mathbf{e}{3}=\\mathbf{v}{2}-\\mathbf{v}{1}\\ &amp;\\mathbf{d}{1}=\\mathbf{p}-\\mathbf{v}{1}, \\quad \\mathbf{d}{2}=\\mathbf{p}-\\mathbf{v}{2}, \\quad \\mathbf{d}{3}=\\mathbf{p}-\\mathbf{v}_{3} \\end{aligned}$$ $$\\hat{\\mathbf{n}}=\\frac{\\mathbf{e}{1} \\times \\mathbf{e}{2}}{\\left|\\mathbf{e}{1} \\times \\mathbf{e}{2}\\right|}$$ $$\\begin{aligned} &amp;b_{1}=A\\left(T_{1}\\right) / A(T)=\\frac{\\left(\\mathbf{e}{1} \\times \\mathbf{d}{3}\\right) \\cdot \\hat{\\mathbf{n}}}{\\left(\\mathbf{e}{1} \\times \\mathbf{e}{2}\\right) \\cdot \\hat{\\mathbf{n}}}\\ &amp;b_{2}=A\\left(T_{2}\\right) / A(T)=\\frac{\\left(\\mathbf{e}{2} \\times \\mathbf{d}{1}\\right) \\cdot \\hat{\\mathbf{n}}}{\\left(\\mathbf{e}{1} \\times \\mathbf{e}{2}\\right) \\cdot \\hat{\\mathbf{n}}}\\ &amp;b_{3}=A\\left(T_{3}\\right) / A(T)=\\frac{\\left(\\mathbf{e}{3} \\times \\mathbf{d}{2}\\right) \\cdot \\hat{\\mathbf{n}}}{\\left(\\mathbf{e}{1} \\times \\mathbf{e}{2}\\right) \\cdot \\hat{\\mathbf{n}}} \\end{aligned}$$ Special Points 质心（center of gravity） 质心为三角形三个顶点位置的平均值，即： $$\\mathbf{c}{\\mathrm{Grav}}=\\frac{\\mathbf{v}{1}+\\mathbf{v}{2}+\\mathbf{v}{3}}{3}$$ 其重心坐标值为： $$\\left(\\frac{1}{3}, \\frac{1}{3}, \\frac{1}{3}\\right)$$ 内心（incenter） 内心距离三角形三条边的距离相等，也因此是三角形内切圆的圆心，如下图所示： 计算方法如下： $$\\mathbf{c}{\\mathrm{In}}=\\frac{l{1} \\mathbf{v}{1}+l{2} \\mathbf{v}{2}+l{3} \\mathbf{v}_{3}}{p}$$ 其重心坐标值为： $$\\left(\\frac{l_{1}}{p}, \\frac{l_{2}}{p}, \\frac{l_{3}}{p}\\right)$$ 内心与三角形边的距离为： $$r_{\\mathrm{In}}=\\frac{2 A}{p}$$ 外心（circumcenter） 外心是距离三角形三个顶点距离相同的点，如下图所示： 计算过程如下： 先根据上图中的标识算出如下的中间变量： $$\\begin{aligned} &amp;\\begin{array}{l} d_{1}=-\\mathbf{e}{2} \\cdot \\mathbf{e}{3} \\ d_{2}=-\\mathbf{e}{3} \\cdot \\mathbf{e}{1} \\ d_{3}=-\\mathbf{e}{1} \\cdot \\mathbf{e}{2} \\end{array}\\ &amp;c_{1}=d_{2} d_{3}\\ &amp;c_{2}=d_{3} d_{1}\\ &amp;c_{3}=d_{1} d_{2}\\ &amp;c=c_{1}+c_{2}+c_{3} \\end{aligned}$$ 其中外心的点为： $$\\mathbf{c}{\\mathrm{Circ}}=\\frac{\\left(c{2}+c_{3}\\right) \\mathbf{v}{1}+\\left(c{3}+c_{1}\\right) \\mathbf{v}{2}+\\left(c{1}+c_{2}\\right) \\mathbf{v}_{3}}{2 c}$$ 重心坐标值为： $$\\left(\\frac{c_{2}+c_{3}}{2 c}, \\frac{c_{3}+c_{1}}{2 c}, \\frac{c_{1}+c_{2}}{2 c}\\right)$$ 距离三角形三个顶点的值为： $$r_{\\mathrm{Circ}}=\\frac{\\sqrt{\\left(d_{1}+d_{2}\\right)\\left(d_{2}+d_{3}\\right)\\left(d_{3}+d_{1}\\right) / c}}{2}$$ Polygons 通常来说，多边形是一个由顶点和边组成的平面图形。 Simple versus Complex Polygons 简单多边形不存在洞，复杂多边形存在洞，如下所示： 可以通过加上一对缝合边将简单多边形转换为复杂多边形，如下所示： 还有一种自相交多边形（Self-intersecting polygon），如下所示： Convex versus Concava Polygons 关于凹多边形(Concave)和凸多边形(Convex)有多种区分方法： 凹多边形至少有一个凹点（concavity），如下所示： 凹多边形至少有一对顶点的连线是在多边形外的。 凹多边形沿着所有顶点走，顶点的旋转顺序会发生变化（顺逆时针）。 这个可以通过对每两边进行叉乘来判断，如果叉乘的结果与法线方向不一致，说明顺序为逆时针，否则为顺时针。如果按顺时针顺序来取两边进行叉乘，突然出现了结果与法线相反的情况，则该两边中间为凹点。 无论是凸多边形还是凹多边形，其内角和都是$(n-2)360^{\\circ}$。但是通过点积求得的是较小角的角度。如果对凸多边形的每两边都点积，则结果和为$(n-2)360^{\\circ}$，而凹多边形不是。 如下图所示： Triangulation and Fanning 每一个$n$条边的凸多边形都能分为$n-2$个三角形。如下图所示： 但这样切分的问题在于，可能会切出一条非常细的三角形。 解决方法为每次切分前，先找出能使内角最大的切割方法，然后切一刀，将图形分为两部分。再对每一个部分迭代使用上述方法，直到只剩下三角形。这样可以一定程度避免出现细长三角形，但效率不如直接切分高。 引用： 3D Math Primer for Graphics and Game Development 2nd 2011","link":"/3DMathPrimerForGraphicsAGameDevelopment-Chapter9-Notes/"},{"title":"《3D数学基础：图形和游戏开发》第八章笔记","text":"《3D数学基础：图形和游戏开发》第八章笔记 8.1节 介绍了朝向（Orientation）的概念。 8.2节 介绍了如何用矩阵表示朝向。 8.3节 介绍如何使用欧拉角表示朝向。 8.4节 介绍如何使用轴角法和指数映射表示朝向。 8.5节 介绍如何使用四元数表示朝向 8.6节 比较了各个表示方法的利弊 8.7节 介绍了各个表示方法如何相互转换。 Chapter 8 Rotation in Three Dimensions What Exactly is “Orientation” 方向（direction）只需要两个参数表示，而朝向（orientation）需要三个参数表示。如下图中确认飞机的朝向需要两个参数，而朝向还需要图中的绿圈方向来决定其旋转角度。 朝向（orientation），旋转（rotation）和角位移（angular displacement）三者的关系为，旋转将物体从一个朝向转换为另一个朝向，这个转换的数值为角位移。 角位移与朝向的关系与线段和点的关系有点类似，前者都是表示一个变换，后者都是表示一个状态。 Matrix Form 这一节是描述用$3 \\times 3$的矩阵来描述旋转。 Which Matrix？ 矩阵很常用的操作是坐标系的转换，其中两个用的比较多的是 从物体坐标系转换为直立坐标系——乘以变换矩阵 从直立坐标系转换为物体坐标系——乘以变换矩阵的逆矩阵 在这里，每个对象都含有一个$3 \\times 3$的矩阵表示朝向，进行变换的矩阵只包含旋转信息，即它是一个正交矩阵（虽然反转矩阵也是正交矩阵，但这里只包含旋转信息）。 Direction Consines Matrix 通过矩阵来进行旋转实际上是从方向余弦（Direction cosines）这个概念中得到的。一个方向预先矩阵就是一个旋转矩阵。 假设变换前的三个坐标轴分别为$\\hat{\\mathbf{x}}{1}, \\hat{\\mathbf{x}}{2}, \\hat{\\mathbf{x}}{3}$，变换后的三个坐标轴分别为$\\hat{\\mathbf{e}}{1}, \\hat{\\mathbf{e}}{2}, \\hat{\\mathbf{e}}{3}$。 那么$\\hat{\\mathbf{e}}{i}$和$\\hat{\\mathbf{x}}{j}$之间的方向余弦$a_{ij}$定义为： $$a_{i j} \\stackrel{\\text {def}}{=} \\cos \\left(\\theta_{i j}\\right)=\\frac{\\hat{\\mathbf{e}}{i} \\cdot \\hat{\\mathbf{x}}{j}}{|\\hat{\\mathbf{e}}{i}||\\hat{\\mathbf{x}}{j}|}= \\hat{\\mathbf{e}}{i} \\cdot \\hat{\\mathbf{x}}{j}$$ 而且坐标轴$\\hat{e_{i}}$可以通过其在$\\hat{x_{i}}$上的分量累加进行表示。又$\\hat{e_{i}}$在原坐标轴上的分量可以通过$cos$求得。于是可得： $$\\begin{aligned} &amp;\\hat{\\mathbf{e}}{1}=\\cos \\left(\\theta{11}\\right) \\hat{\\mathbf{x}}{1}+\\cos \\left(\\theta{12}\\right) \\hat{\\mathbf{x}}{2}+\\cos \\left(\\theta{13}\\right) \\hat{\\mathbf{x}}{3}=a{11} \\hat{\\mathbf{x}}{1}+a{12} \\hat{\\mathbf{x}}{2}+a{13} \\hat{\\mathbf{x}}{3}\\ &amp;\\hat{\\mathbf{e}}{2}=\\cos \\left(\\theta_{21}\\right) \\hat{\\mathbf{x}}{1}+\\cos \\left(\\theta{22}\\right) \\hat{\\mathbf{x}}{2}+\\cos \\left(\\theta{23}\\right) \\hat{\\mathbf{x}}{3}=a{21} \\hat{\\mathbf{x}}{1}+a{22} \\hat{\\mathbf{x}}{2}+a{23} \\hat{\\mathbf{x}}{3}\\ &amp;\\hat{\\mathbf{e}}{3}=\\cos \\left(\\theta_{31}\\right) \\hat{\\mathbf{x}}{1}+\\cos \\left(\\theta{32}\\right) \\hat{\\mathbf{x}}{2}+\\cos \\left(\\theta{33}\\right) \\hat{\\mathbf{x}}{3}=a{31} \\hat{\\mathbf{x}}{1}+a{32} \\hat{\\mathbf{x}}{2}+a{33} \\hat{\\mathbf{x}}_{3} \\end{aligned}$$ 如果将这个变换用矩阵表示，即为： $$ A=\\left[\\begin{array}{lll} \\cos \\left(\\theta_{11}\\right)&amp; \\cos \\left(\\theta_{12}\\right)&amp; \\cos \\left(\\theta_{13}\\right) \\ \\cos \\left(\\theta_{21}\\right)&amp; \\cos \\left(\\theta_{22}\\right)&amp; \\cos \\left(\\theta_{23}\\right) \\ \\cos \\left(\\theta_{31}\\right)&amp; \\cos \\left(\\theta_{32}\\right)&amp; \\cos \\left(\\theta_{33}\\right) \\end{array}\\right] \\ =\\left[\\begin{array}{lll} \\hat{\\mathbf{e}}{1} \\cdot \\hat{\\mathbf{x}}{1}&amp; \\hat{\\mathbf{e}}{1} \\cdot \\hat{\\mathbf{x}}{2}&amp; \\hat{\\mathbf{e}}{1} \\cdot \\hat{\\mathbf{x}}{3} \\ \\hat{\\mathbf{e}}{2} \\cdot \\hat{\\mathbf{x}}{1}&amp; \\hat{\\mathbf{e}}{2} \\cdot \\hat{\\mathbf{x}}{2}&amp; \\hat{\\mathbf{e}}{2} \\cdot \\hat{\\mathbf{x}}{3}\\ \\hat{\\mathbf{e}}{3} \\cdot \\hat{\\mathbf{x}}{1}&amp; \\hat{\\mathbf{e}}{3} \\cdot \\hat{\\mathbf{x}}{2}&amp; \\hat{\\mathbf{e}}{3} \\cdot \\hat{\\mathbf{x}}{3} \\end{array}\\right] $$ 书中用$\\mathbf{p}, \\mathbf{q}$ 和 $\\mathbf{r}$表示原先的坐标轴，用$\\mathbf{p}^{\\prime}, \\mathbf{q}^{\\prime}$ 和 $\\mathbf{r}^{\\prime}$表示变换后的坐标轴，将其带入上矩阵，可得 $$ A=\\left[\\begin{array}{lll} \\mathbf{p} \\cdot \\mathbf{p}^{\\prime} &amp; \\mathbf{q} \\cdot \\mathbf{p}^{\\prime} &amp; \\mathbf{r} \\cdot \\mathbf{p}^{\\prime} \\ \\mathbf{p} \\cdot \\mathbf{q}^{\\prime} &amp; \\mathbf{q} \\cdot \\mathbf{q}^{\\prime} &amp; \\mathbf{r} \\cdot \\mathbf{q}^{\\prime} \\ \\mathbf{p} \\cdot \\mathbf{r}^{\\prime} &amp; \\mathbf{q} \\cdot \\mathbf{r}^{\\prime} &amp; \\mathbf{r} \\cdot \\mathbf{r}^{\\prime} \\end{array}\\right] $$ 注意这个变换矩阵是用来将用$\\mathbf{p}, \\mathbf{q}, \\mathbf{r}$表达的向量转换为用$\\mathbf{p}^{\\prime}, \\mathbf{q}^{\\prime}, \\mathbf{r}^{\\prime}$表达的向量，即 $$ \\mathbf{v}A=\\mathbf{v^{\\prime}} $$ 如果用$[1,0,0], [0,1,0], [0,0,1]$来表示$\\mathbf{p}, \\mathbf{q}, \\mathbf{r}$并带入上矩阵，可得 $$\\left[\\begin{array}{lll} {[1,0,0] \\cdot \\mathbf{p}^{\\prime}} &amp; {[0,1,0] \\cdot \\mathbf{p}^{\\prime}} &amp; {[0,0,1] \\cdot \\mathbf{p}^{\\prime}} \\ {[1,0,0] \\cdot \\mathbf{q}^{\\prime}} &amp; {[0,1,0] \\cdot \\mathbf{q}^{\\prime}} &amp; {[0,0,1] \\cdot \\mathbf{q}^{\\prime}} \\ {[1,0,0] \\cdot \\mathbf{r}^{\\prime}} &amp; {[0,1,0] \\cdot \\mathbf{r}^{\\prime}} &amp; {[0,0,1] \\cdot \\mathbf{r}^{\\prime}} \\end{array}\\right]=\\left[\\begin{array}{lll} p_{x}^{\\prime} &amp; p_{y}^{\\prime} &amp; p_{z}^{\\prime} \\ q_{x}^{\\prime} &amp; q_{y}^{\\prime} &amp; q_{z}^{\\prime} \\ r_{x}^{\\prime} &amp; r_{y}^{\\prime} &amp; r_{z}^{\\prime} \\end{array}\\right]=\\left[\\begin{array}{l} -\\mathbf{p}^{\\prime}- \\ -\\mathbf{q}^{\\prime}- \\ -\\mathbf{r}^{\\prime}- \\end{array}\\right]$$ 即矩阵的每一行是用原坐标轴表示的变换后的坐标轴（这一点在前面的推导过程中也能看出$\\hat{\\mathbf{e}}{i}$，是由$\\hat{\\mathbf{x}}{i}$表示的）。 同理，如果用$[1,0,0], [0,1,0], [0,0,1]$表示$\\mathbf{p}^{\\prime}, \\mathbf{q}^{\\prime}, \\mathbf{r}^{\\prime}$带入上矩阵，可得： $$\\left[\\begin{array}{ccc} \\mathbf{p} \\cdot[1,0,0] &amp; \\mathbf{q} \\cdot[1,0,0] &amp; \\mathbf{r} \\cdot[1,0,0] \\ \\mathbf{p} \\cdot[0,1,0] &amp; \\mathbf{q} \\cdot[0,1,0] &amp; \\mathbf{r} \\cdot[0,1,0] \\ \\mathbf{p} \\cdot[0,0,1] &amp; \\mathbf{q} \\cdot[0,0,1] &amp; \\mathbf{r} \\cdot[0,0,1] \\end{array}\\right]=\\left[\\begin{array}{ccc} p_{x} &amp; q_{x} &amp; r_{x} \\ p_{y} &amp; q_{y} &amp; r_{y} \\ p_{z} &amp; q_{z} &amp; r_{z} \\end{array}\\right]=\\left[\\begin{array}{ccc} | &amp; | &amp; | \\ \\mathbf{p}^{\\mathrm{T}} &amp; \\mathbf{q}^{\\mathrm{T}} &amp; \\mathbf{r}^{\\mathrm{T}} \\ | &amp; | &amp; | \\end{array}\\right]$$ 即矩阵的每一列，是由变换后的坐标轴表示的原坐标轴。 Advantages of Matrix Form 用矩阵表示旋转的优点如下： 向量的旋转可以很快的实现，包括坐标系的变换等 绝大部分图形API都是通过矩阵来进行变换的。 多个变换矩阵可以级联，即矩阵相乘 当要进行逆操作时，矩阵取反即可 Disadvantages of Matrix Form 用矩阵表示旋转的缺点如下： 矩阵花费更多的内存。用来表示三维空间旋转的矩阵为$3\\times 3$的矩阵，要9个数字，而通过欧拉角只要三个数字。 人无法直观理解。虽然可以通过每一行进行判断，但是矩阵用来表示旋转仍不够直观。而且所有的数字都会被归一到$-1\\sim 1$的范围内（为了表示长度位为一的单位向量）。 矩阵可能存在格式错误。 a. 并不是随手写一个矩阵都能表示旋转的，旋转矩阵必须是正交矩阵，同时还不能是反转变换。所以矩阵中的数据必须要额外小心，必须满足旋转的表达格式。 b. 可能由进度不够造成数据错误。因为旋转矩阵中的元素数值通常范围为$-1\\sim 1$，当表示一些变换时，精度可能会不够。因此在变换过程中，当小数点后数据进行了舍弃，可能导致无法满足旋转矩阵的性质，这种现象称为矩阵蠕变（Matrix creep）。可以通过矩阵的正交化解决（在第六章有提到）。 Eular Angles 欧拉角表示旋转的基本思路是通过连续的绕着三个相互垂直的轴的角位移来表示旋转。 理论上来说，这三个相互垂直的轴可以是任意的，但通常来说，都选择一个坐标系的三个基轴（cardinal axes）。在这本书中，称为heading-pitch-bank，绕着这三个轴的旋转如下图所示： 第一张图显示的是原始状态，第二张图是绕着heading轴（直立坐标系下的y轴）旋转，第三张图是绕着pitch轴旋转（物体坐标系下的x轴），第四章图是绕着bank轴旋转（物体坐标系下的z轴）。 Other Euler Angle Conventions 还存在很多其他的欧拉角旋转表达方式，如很常见的yaw-pitch-roll。这种表达方式下，通常roll与bank的含义一模一样，但heading和yaw有细微差别，heading是直立坐标系的y轴，yaw是物体坐标系的y轴。 如果所有的旋转轴都是直立坐标系的轴，则称为固定轴（Fixed-Axis）旋转。而传统的欧拉角旋转都是绕着物体自己的坐标系的轴。两种方式实际上是等效的，只要用相反的顺序执行旋转即可（传统欧拉：yaw-pitch-roll,固定轴：roll-pitch-yaw）。因为传统欧拉角旋转顺序中，前一个轴的旋转会影响后面的轴的位置，而固定轴欧拉角的旋转顺序则不会。 在最原始的欧拉角定义，实际上第一个轴和第三个轴是相同的，这种定义又被命名为proper Euler angles。而现在常用的欧拉角，实际上称为Tait-Bryan angles。 这一节中提到个各种命名，并不是绝对的，即可能现在命名名字相同但是含义却不同的情况。 在这里提及各种命名，实际上是为了让读者在接触其他的系统时，首先确认下其中的欧拉角定义方式是否不同，如旋转正方向，绕什么轴旋转，绕不同轴旋转的顺序等。 不同定义的欧拉角进行转换过程，通常是先原始欧拉角转换为矩阵，再从矩阵 转换为目标欧拉角 Advantages of Euler Angles 欧拉角表达的优点在于： 人可以直观理解。当需要人来输入旋转角度时，通常欧拉角表达是唯一的选择。 欧拉角用了最少的数字来表达旋转。另外因为欧拉角中的数字是用来表达角度的，所以不会像在矩阵中的数字一样，局限在范围$-1\\sim 1$之中，也因此浮点数的精度误差也不会像在矩阵中严重。 任意三个数值的组合都是合法的。 Disadvantages of Euler Angles 对于一个旋转角度的表达不唯一，即存在别名。 在不同角度之间的线性差值变换可能存在问题。 万向锁 第一个别名问题，一是因为所有的角度都可以加上360°保持不变，第二个原因是因为绕着三个轴的旋转并非完全相互独立，如pitch向下135°，和先heading转180再pitch向下45°效果一样。 而这个问题可以通过标准坐标（canonical）解决。限制heading和bank的范围为$\\left(-180^{\\circ},+180^{\\circ}\\right]$，pitch的范围是$\\left[-90^{\\circ},+90^{\\circ}\\right]$。但这样还存在一个歧义性，当pitch角度是$\\pm 90^{\\circ}$时，heading和bank旋转是一样的效果，这个现象称为万向锁（Gimbal Lock）。在这种情况下，定义变换的轴是heading，bank轴始终为0。 因此欧拉角的标准坐标规则为： $$\\left{\\begin{aligned} -180^{\\circ}&lt;&amp; h \\leq 180^{\\circ} \\ -90^{\\circ} \\leq &amp; p \\leq 90^{\\circ} \\ -180^{\\circ}&lt;b &amp; \\leq 180^{\\circ} \\ p=\\pm 90^{\\circ} &amp; \\Rightarrow \\quad b=0 \\end{aligned}\\right.$$ 当通过代码实现欧拉角时，最好保证返回的数值时标准坐标。 第二个问题是关于角度变换插值的。 插值变换是指，有两个角度$\\mathbf{R}{0}$ 和 $\\mathbf{R}{1}$，希望通过参数$0 \\leq t \\leq 1$，实现$\\mathbf{R}(t)$在$\\mathbf{R}{0}$ 和 $\\mathbf{R}{1}$间线性变化。类似于： $$\\begin{aligned} \\Delta \\theta &amp;=\\theta_{1}-\\theta_{0} \\ \\theta_{t} &amp;=\\theta_{0}+t \\Delta \\theta \\end{aligned}$$ 欧拉角的插值变换问题第一种可能是由别名造成的，如下所示： 在其中两个角度实际上相差为$45^{\\circ}$，但因为用了别名表示，路径多走了将近两圈。这种可能可以通过使用标准坐标表示解决。 第二个问题如下： 其中$-170^{\\circ}和170^{\\circ}$都是在范围$(-180^{\\circ},+180^{\\circ}]$内，因此满足标准规范。但实际上两者相差20°，却要插值340°。 解决方法是通过wrapPi进行计算，计算式子如下： $$\\operatorname{wrap} \\operatorname{Pi}(x)=x-360^{\\circ}\\left\\lfloor\\left(x+180^{\\circ}\\right) / 360^{\\circ}\\right\\rfloor$$ 其中的x即为两个角度相减后的插值，在此例中为340。 因此线性插值表达式应该为： $$\\begin{aligned} \\Delta \\theta &amp;=\\operatorname{wrap} \\mathrm{Pi}\\left(\\theta_{1}-\\theta_{0}\\right) \\ \\theta_{t} &amp;=\\theta_{0}+t \\Delta \\theta \\end{aligned}$$ 第三个问题万向锁无法被解决。只要使用了三个数值来表达旋转，那么当第二个轴旋转至90°时，第一个轴与第三个轴的旋转效果都会变得相同。 Axis-Angle and Exponential Map Representations 欧拉还提出了欧拉旋转理论（Euler‘s rotation theorem）：任何的3D旋转，都可以通过绕着某一个轴的单一旋转实现。如给定了两个旋转$\\mathbf{R}_1和\\mathbf{R}_2$，存在一个轴$\\hat{\\mathbf{n}}$，使得$\\mathbf{R}_1和\\mathbf{R}_2$两个旋转的结合可以通过绕着$\\hat{\\mathbf{n}}$轴的一次旋转搞定。 这种通过轴$\\hat{\\mathbf{n}}$和一个旋转角度$\\theta$来表示的方法称为轴角法（Axis-Angle）。 而指数映射法(exponential map)是更进一步，通过$\\mathbf{e}=\\theta \\hat{\\mathbf{n}}$将轴和角结合在一起表示。如果想获取角度，可以通过$\\theta=|\\mathbf{e}|$。如果想获取旋转轴，可以对$\\mathbf{e}$进行归一化，即$\\hat{\\mathbf{n}}=\\bar{\\mathbf{e}}$。 当$\\theta=0$时，轴角法会出现歧义性，但是指数映射法不会（因为最终值已经变为了0）.同样，因为角度和轴的正负号造成的别名问题，指数映射法中也不会发生，因为正负号被相乘的操作抵消了。 但是因为加减$360^{\\circ}$造成的别名问题，无论是轴角法还是指数映射法中都会出现。 同时，在使用指数映射法的时候，多个角度的旋转不能通过加法来获得。因为加法操作是支持交换律的，而旋转操作不支持。 如有两个旋转$\\mathbf{e}{1}=\\left[90^{\\circ}, 0,0\\right]$ 和$\\mathbf{e}{2}=\\left[0,90^{\\circ}, 0\\right]$，先执行$\\mathbf{e}{1}$和先执行$\\mathbf{e}{2}$的结果是不同的。因为旋转轴都是针对于物体坐标的，后者的旋转轴位置会受前一个旋转的影响。 但是这个结果的差距会随着角度的缩小而缩小，如旋转的角度是2°的话，那么结果的差异相对来说没有那么明显。因此一定意义上如果旋转的角度足够小，那么可以通过指数映射法的加法来结合角度的旋转。 轴角法更多的是一个概念上的方法，在实际上中运用的比较少。四元数实际上是通过轴角法演变来的。 指数映射法运用的相对较多。在计算角速度的时候，通常使用指数映射法。一是因为指数映射法受加减360°别名的影响，因此可以保留速度的变换。二是因为虽然指数映射法的加法无法完美结合多个变换，但是可以结合多个变换的变换角度的大小。 Quaternions 从数学上可以证明为什么用欧拉角来表示三维空间旋转必然会引起万向锁，所用方法为“manifolds”，但这个论证超出了本书的范围。 Quaternion Notation 四元数通常包含一个标量部分（$\\mathbf{w}$），和一个三维向量部分（$\\mathbf{v}$），即四元数标记为： $$\\left[\\begin{array}{ll} w &amp; \\mathbf{v} \\end{array}\\right], \\quad\\left[\\begin{array}{llll} w &amp; (x &amp; y &amp; z) \\end{array}\\right]$$ 四元数也可以通过纵向表示，如： $$\\left[\\begin{array}{c} w \\ \\left(\\begin{array}{l} x \\ y \\ z \\end{array}\\right) \\end{array}\\right]$$ 但不像向量中的横向量与纵向量会影响计算，四元数的横向与纵向表示没有任何区别，仅仅是写法的不同。 What Do Those Four Numers Mean？ 之前提到了轴角法表示旋转，即通过$(\\theta, \\hat{\\mathbf{n}})$表达旋转。可以将其表示为四元数，将其中的旋转角度和旋转轴的信息进行编码放入四个数中，如下所示： $$\\begin{aligned} &amp;\\left[\\begin{array}{ll} w &amp; \\mathbf{v} \\end{array}\\right]=[\\cos (\\theta / 2) \\quad \\sin (\\theta / 2) \\hat{\\mathbf{n}}]\\ &amp;\\left.\\left[\\begin{array}{llll} w &amp; (x &amp; y &amp; z \\end{array}\\right)\\right]=\\left[\\cos (\\theta / 2) \\quad\\left(\\sin (\\theta / 2) n_{x} \\quad \\sin (\\theta / 2) n_{y} \\quad \\sin (\\theta / 2) n_{z}\\right)\\right] \\end{aligned}$$ 这样的四元数是关于角度旋转的，其中的$\\mathbf{v}$和旋转轴$\\hat{\\mathbf{n}}$相关，$\\omega$和旋转角度$\\theta$相关。 这样是几何意义上的四元数，但是从复数层面或者其他学科中，四元数还有其他用处，只不过超出了本书的范围。 Quaternion Negation 从第三节到第11节都是关于四元数的操作 四元数的取反操作如下： $$\\begin{aligned} -\\mathbf{q} &amp;\\left.=-\\left[w \\quad\\left(\\begin{array}{lll} w &amp; y &amp; z \\end{array}\\right)\\right]=\\left[\\begin{array}{llll} -w &amp; (-x &amp; -y &amp; -z \\end{array}\\right)\\right] \\ &amp;=-[w \\quad \\mathbf{v}]=\\left[\\begin{array}{ll} -w &amp; -\\mathbf{v} \\end{array}\\right] \\end{aligned}$$ 从几何意义上来说，$\\mathbf{q}$和$\\mathbf{-q}$没有任何区别。因为根据上一节中四元数数据的定义，因为每个操作符都是对于$\\theta/2$，给$\\theta$加上360°，其数值就会取反，但是旋转的角度仍然相同。 Identity Quaternion(s) 从几何意义角度上说，存在两个单位四元数，表示没有任何的旋转，它们为： $$\\left[\\begin{array}{ll} 1 &amp; 0 \\end{array}\\right] \\text { 和 }\\left[\\begin{array}{ll} -1 &amp; 0 \\end{array}\\right]$$ 当$\\theta$为偶数倍的360°时，$\\cos(\\theta /2) =1$，对应上式中第一个单位四元数。当$\\theta$为奇数倍的360°时，$\\cos(\\theta /2) =-1$，对应上式中第二个单位四元数。在两种情况下，$\\sin(\\theta/2)$都为0，所以$\\hat{\\mathbf{n}}的取值也是没关系的$。 但从代数角度上说，实际上只有$\\left[\\begin{array}{ll}1 &amp; 0\\end{array}\\right]$一个四元数。 Quaternion Magnitude 对于任意的四元数，求模的公式如下： $$\\begin{aligned} |\\mathbf{q}| &amp;=\\left|\\left[w \\quad\\left(\\begin{array}{ll} x &amp; y \\end{array} \\quad z\\right)\\right]\\right|=\\sqrt{w^{2}+x^{2}+y^{2}+z^{2}} \\ &amp;=|[w \\quad \\mathbf{v}]|=\\sqrt{w^{2}+|\\mathbf{v}|^{2}} \\end{aligned}$$ 对于表示旋转的几何意义上的四元数，其求模过程如下： $$\\begin{aligned} |\\mathbf{q}| &amp;=|[w \\quad \\mathbf{v}]|=\\sqrt{w^{2}+|\\mathbf{v}|^{2}} \\ &amp;=\\sqrt{\\cos ^{2}(\\theta / 2)+(\\sin (\\theta / 2)|\\hat{\\mathbf{n}}|)^{2}} \\ &amp;=\\sqrt{\\cos ^{2}(\\theta / 2)+\\sin ^{2}(\\theta / 2)|\\hat{\\mathbf{n}}|^{2}} \\ &amp;=\\sqrt{\\cos ^{2}(\\theta / 2)+\\sin ^{2}(\\theta / 2)(1)} \\ &amp;=\\sqrt{1} \\ &amp;=1 \\end{aligned}$$ 即用于表达旋转的四元数，其模为1。 在几何中，通常unit quaternions用来描述这些模为1的四元数，并且同样翻译为单位四元数。 Quaternion Conjugate and Inverse 四元数有共轭操作，表示为$\\mathbf{q}*$，计算过程如下： $$\\begin{aligned} \\mathbf{q}^{} &amp;=\\left[\\begin{array}{ll} w &amp; \\mathbf{v} \\end{array}\\right]^{}=\\left[\\begin{array}{ll} w &amp; -\\mathbf{v} \\end{array}\\right] \\ &amp;\\left.\\left.=\\left[\\begin{array}{lll} w &amp; (x &amp; y &amp; z \\end{array}\\right)\\right]^{*}=\\left[\\begin{array}{llll} w &amp; (-x &amp; -y &amp; -z \\end{array}\\right)\\right] \\end{aligned}$$ 四元数也有取反操作，表示为$\\mathbf{q}^{-1}$，计算过程如下： $$\\mathbf{q}^{-1}=\\frac{\\mathbf{q}^{*}}{|\\mathbf{q}|}$$ 且类似于矩阵，同样有性质： $$ \\mathbf{q}\\mathbf{q}^{-1}=\\left[\\begin{array}{ll} 1 &amp; \\mathbf{0} \\end{array}\\right] $$ 从几何意义上来说，用于旋转的四元数，因为模为1，所以$\\mathbf{q}^{*}=\\mathbf{q}^{-1}$。它们都表示为绕着相反的轴（因为$\\mathbf{v}$取反了）进行旋转。 Quaternion Multiplication 四元数的相乘和矩阵的叉乘类似，叉乘返回的是向量，四元数相乘返回的是四元数。如下所示： $$\\begin{aligned} \\mathbf{q}{1} \\mathbf{q}{2} &amp;\\left.=\\left[w_{1} \\quad\\left(\\begin{array}{ccc} x_{1} &amp; y_{1} &amp; z_{1} \\end{array}\\right)\\right]\\left[\\begin{array}{ccc} w_{2} &amp; \\left(x_{2}\\right. &amp; y_{2} &amp; z_{2} \\end{array}\\right)\\right] \\ &amp;=\\left[\\begin{array}{c} w_{1} w_{2}-x_{1} x_{2}-y_{1} y_{2}-z_{1} z_{2} \\ \\left(\\begin{array}{l} w_{1} x_{2}+x_{1} w_{2}+y_{1} z_{2}-z_{1} y_{2} \\ w_{1} y_{2}+y_{1} w_{2}+z_{1} x_{2}-x_{1} z_{2} \\ w_{1} z_{2}+z_{1} w_{2}+x_{1} y_{2}-y_{1} x_{2} \\end{array}\\right) \\end{array}\\right] \\ &amp;=\\left[\\begin{array}{lll} w_{1} &amp; \\mathbf{v}{1} \\end{array}\\right]\\left[\\begin{array}{ll} w{2} &amp; \\mathbf{v}{2} \\end{array}\\right] \\ &amp;=\\left[w{1} w_{2}-\\mathbf{v}{1} \\cdot \\mathbf{v}{2} \\quad w_{1} \\mathbf{v}{2}+w{2} \\mathbf{v}{1}+\\mathbf{v}{1} \\times \\mathbf{v}_{2}\\right] \\end{aligned}$$ 四元数的乘法，满足结合律，不满足交换律 $$\\begin{aligned} (\\mathbf{a b}) \\mathbf{c} &amp;=\\mathbf{a}(\\mathbf{b} \\mathbf{c}) \\ \\mathbf{a b} &amp; \\neq \\mathbf{b a} \\end{aligned}$$ 乘积的模等于模的乘积 $$\\left|\\mathbf{q}{1} \\mathbf{q}{2}\\right|=\\left|\\mathbf{q}{1}\\right|\\left|\\mathbf{q}{2}\\right|$$ 乘积的逆，等于逆按相反顺序的乘积 $$\\begin{aligned} (\\mathbf{a b})^{-1} &amp;=\\mathbf{b}^{-1} \\mathbf{a}^{-1} \\ \\left(\\mathbf{q}{1} \\mathbf{q}{2} \\cdots \\mathbf{q}{n-1} \\mathbf{q}{n}\\right)^{-1} &amp;=\\mathbf{q}{n}^{-1} \\mathbf{q}{n-1}^{-1} \\cdots \\mathbf{q}{2}^{-1} \\mathbf{q}{1}^{-1} \\end{aligned}$$ 如果$\\mathbf{q}$是一个表示旋转的四元数，那么下式可以表示旋转操作： $$\\mathbf{p}^{\\prime}=\\mathbf{q p q}^{-1}$$ 式子中的$\\mathbf{p}$是描述一个点的四元数，如果在三维空间中的点$(x,y,z)$，用四元数表示则为$[0 \\quad(x \\quad y \\quad z)]$。 使用该式子的例子如下： 如果存在点$\\mathbf{P}=(1,0,0)$，希望其绕着+z轴旋转90°，则旋转四元数为$\\left[\\frac{\\sqrt{2}}{2} \\quad ( 0 \\quad 0 \\quad \\frac{\\sqrt{2}}{2} ) \\right]$，需要求得旋转的点$\\mathbf{P^{'}}$，计算过程如下： $$ p^{\\prime}=q p q^{-1} $$ $$ \\begin{array}{l} q p =\\left[\\frac{\\sqrt{2}}{2} \\quad\\left(0 \\quad 0 \\quad\\frac{\\sqrt{2}}{2} \\right)\\right] \\quad \\left[0 \\quad\\left(1 \\quad 0 \\quad 0\\right)\\right] \\ =\\left[0-0 \\quad\\left(\\frac{\\sqrt{2}}{2} \\quad 0 \\quad 0\\right)+(0 \\quad 0 \\quad 0)+\\left(0 \\quad \\frac{\\sqrt{2}}{2} \\quad 0\\right)\\right] \\ =\\left[0 \\quad\\left(\\frac{\\sqrt{2}}{2} \\quad \\frac{\\sqrt{2}}{2} \\quad 0\\right)\\right] \\end{array} $$ $$ \\begin{array}{l} q p q^{-1} =\\left[0 \\quad\\left(\\frac{\\sqrt{2}}{2}\\quad \\frac{\\sqrt{2}}{2}\\quad 0\\right)\\right]\\left[\\frac{\\sqrt{2}}{2} \\quad \\left(0\\quad 0\\quad -\\frac{\\sqrt{2}}{2}\\right)\\right] \\ =\\left[0-0 \\quad \\left(0 \\quad 0 \\quad 0\\right)+\\left(\\frac{1}{2} \\quad \\frac{1}{2} \\quad 0\\right) +\\left(-\\frac{1}{2} \\quad \\frac{1}{2} \\quad 0\\right)\\right] \\ =\\left[0 \\quad\\left(0 \\quad 1 \\quad 0\\right)\\right] \\end{array} $$ 即求得变换后的四元数$\\mathbf{p^{'}}$为$\\left[0 \\quad\\left(0 \\quad 1 \\quad 0\\right)\\right]$，因此变换后的点为$(0,1,0)$。 但这个式子只是理论上使用，实际操作中并不会使用这个式子进行旋转操作。可以通过这个式子做理论上的分析，如下式: $$\\begin{aligned} \\mathbf{p}^{\\prime} &amp;=\\mathbf{b}\\left(\\mathbf{a p a}^{-1}\\right) \\mathbf{b}^{-1} \\ &amp;=(\\mathbf{b} \\mathbf{a}) \\mathbf{p}\\left(\\mathbf{a}^{-1} \\mathbf{b}^{-1}\\right) \\ &amp;=(\\mathbf{b} \\mathbf{a}) \\mathbf{p}(\\mathbf{b} \\mathbf{a})^{-1} \\end{aligned}$$ 该式子表示四元数的旋转可以级联，也表示了两个旋转操作（由$\\mathbf{a}$和$\\mathbf{b}$表示），可以结合为同一个旋转$\\mathbf{ba}$ 当多个四元数表示多次相连的旋转时，其计算顺序是由内向外的（上式中先计算$\\mathbf{a}$再计算$\\mathbf{b}$） Quaternion “Difference” 四元数的差值（Difference）是用来表示两个朝向的角度相互变换时差距。 注意这里的差值并不是几何意义上的两个角度大小之间的差，和上一节中用于变换的旋转四元数也不相同。这里的差值指的是从一个角度变换为另一个角度需要进行的操作，将这个操作用四元数表示出来。 如给定了两个朝向$\\mathbf{a}和\\mathbf{b}$，需要求得差值$\\mathbf{d}$满足： $$\\mathbf{d a}=\\mathbf{b}$$ 可以根据下式求得$\\mathbf{d}$, $$\\begin{aligned} (\\mathbf{d a}) \\mathbf{a}^{-1} &amp;=\\mathbf{b a}^{-1} \\ \\mathbf{d}\\left(\\mathbf{a a}^{-1}\\right) &amp;=\\mathbf{b a}^{-1} \\ \\mathbf{d}[1 \\quad \\mathbf{0}] &amp;=\\mathbf{b a}^{-1} \\ \\mathbf{d} &amp;=\\mathbf{b a}^{-1} \\end{aligned}$$ 例如有变换前的点$\\mathbf{p}=\\left[0 \\quad\\left(1 \\quad 0 \\quad 0\\right)\\right]$和变换后的点$\\mathbf{p}^{\\prime}=\\left[0 \\quad\\left(0 \\quad 1 \\quad 0\\right)\\right]$，需要求得差值$d$ $$d=p^{\\prime}p^{-1}$$ $$ \\begin{array}{l} d=\\left[\\begin{array}{cc} 0 &amp; (0\\quad 1\\quad 0) \\end{array}\\right]\\left[\\begin{array}{cc} 0 &amp; (-1\\quad 0\\quad 0) \\end{array}\\right] \\ =[0-0 \\quad(0\\quad 0\\quad 0)+(0\\quad 0\\quad 0)+(0\\quad 0\\quad 1)] \\ = {[0 \\quad(0\\quad 0\\quad 1)]} \\end{array}$$ 如之前所述，这里求得的$\\mathbf{d}$虽然形式上满足旋转四元数的定义，但是它并不是一个旋转四元数，而是表示两个点之间的差值。 这差值也同样不是几何意义上的两个点之间的角度差。如例子中的$\\mathbf{p}=[0 (\\quad 1 \\quad 0 \\quad 0)]$和$\\mathbf{p^{\\prime}}=[0 (\\quad 0 \\quad 1 \\quad 0)]$，两者实际上的角度差值是90°（绕着+z）轴。但是这里求出的$\\mathbf{d}=[0 \\quad(0\\quad 0\\quad 1)]$，如果按旋转四元数来解释$\\mathbf{d}$，那么$\\cos(\\theta/2)=0$，$\\theta=180^{\\circ}$，明显与实际情况不同。 Quaternion Dot Product 四元数的点乘与矩阵的点乘类似，如下所示： $$\\begin{aligned} \\mathbf{q}{1} \\cdot \\mathbf{q}{2} &amp;=\\left[\\begin{array}{ll} w_{1} &amp; \\mathbf{v}{1} \\end{array}\\right] \\cdot\\left[\\begin{array}{ll} w{2} &amp; \\mathbf{v}{2} \\end{array}\\right] \\ &amp;=w{1} w_{2}+\\mathbf{v}{1} \\cdot \\mathbf{v}{2} \\ &amp;\\left.=\\left[w_{1} \\quad\\left(\\begin{array}{lll} x_{1} &amp; y_{1} &amp; z_{1} \\end{array}\\right)\\right] \\cdot\\left[\\begin{array}{llll} w_{2} &amp; \\left(x_{2}\\right. &amp; y_{2} &amp; z_{2} \\end{array}\\right)\\right] \\ &amp;=w_{1} w_{2}+x_{1} x_{2}+y_{1} y_{2}+z_{1} z_{2} \\end{aligned}$$ 在上一节求四元数差值的部分中，如果设$\\mathbf{a}=[\\omega_{1} \\quad \\mathbf{v_1}]$和$\\mathbf{b}=[\\omega_{2} \\quad \\mathbf{v_2} ]$，那么$\\mathbf{d}$中的$\\omega$部分即为$w_{1} w_{2}+\\mathbf{v}{1} \\cdot \\mathbf{v}{2}$，即和$\\mathbf{a} \\cdot \\mathbf{b}$的结果相同。 而$\\mathbf{d}$的形式上满足旋转四元数的定义（虽然$\\theta$和$\\hat{\\mathbf{n}}$和真实的旋转四元数并不相等），所以其中的$\\omega$也能反应差值的角度大小，因此可以通过点乘来求得差值的角度大小。 Quaternion log，exp, and Multiplication by a Scaler 为了书写方便，四元数可表示为，$\\alpha=\\theta / 2，\\mathbf{q}=[\\cos \\alpha \\quad \\hat{\\mathbf{n}} \\sin \\alpha]$ 四元数的log（logarithm）定义为： $$\\log \\mathbf{q}=\\log ([\\cos \\alpha \\quad \\hat{\\mathbf{n}} \\sin \\alpha]) \\equiv\\left[\\begin{array}{ll} 0 &amp; \\alpha \\hat{\\mathbf{n}} \\end{array}\\right]$$ 四元数的自然指数函数（Exponential function）定义为： $$\\exp \\mathbf{p}=\\exp \\left(\\left[\\begin{array}{ll} 0 &amp; \\alpha \\hat{\\mathbf{n}} \\end{array}\\right]\\right) \\equiv[\\cos \\alpha \\quad \\hat{\\mathbf{n}} \\sin \\alpha]$$ 可以得出： $$\\exp (\\log \\mathbf{q})=\\mathbf{q}$$ 这与一般数学中的操作是对应的，即： $$e^{\\ln a}=a$$ 四元数与标量相乘的定义如下： $$k \\mathbf{q}=k[w \\quad \\mathbf{v}]=\\left[\\begin{array}{ll} k w &amp; k \\mathbf{v} \\end{array}\\right]$$ Quaternion Exponentiation 四元数的指数形式（Exponentiation），写为$\\mathbf{q}^{t}$ 在自然数中，$a^0=1,a^1=a$，即指数从$0\\sim1$变化的过程中，结果从$1\\sim a$逐渐变换。在四元数中类似，即指数从$0\\sim 1$的过程中，结果从$[1 \\quad \\mathbf{0}]$逐渐变换为$\\mathbf{q}$ 四元数指数操作的几何意义在于，它可以截取或倍化差值，因为： $$\\mathbf{q}^{t}=\\exp (t \\log \\mathbf{q})$$ 上式中，先进行了log操作，由上节可知，log操作的结果是将角度抽离出来（从$\\sin \\alpha \\hat{\\mathbf{n}}$变为了$\\alpha \\hat{\\mathbf{n}}$）。这时候乘以$t$就是直接对角度进行截取或倍化。然后进行的exp操作，则又是将角度变化回了四元数。 所以如果$\\mathbf{q}$表示绕着x轴旋转30°，那么$\\mathbf{q}^2$表示绕着x轴旋转60°，$\\mathbf{q}^{-1/3}$表示绕着反方向旋转了10°。 但是指数操作的旋转的结果是最短路径，即$\\mathbf{q}^8$的结果并不是旋转240°，而是120°。 另外四元数的几何操作不满足实数的指数操作的一些性质，如$\\left(a^{s}\\right)^{t}=a^{s t}$无法在四元数中实现。 //TODO: 书中给出了实现四元数指数操作的代码 Quaternion Interpolation, a.k.a Slerp 球面线性插值（Slerp，Spherical Linera interpolation，下简称插值）是用来在两个角度间逐渐变换的方法。Slerp方法需要三个参数，$\\mathbf{q}_0,\\mathbf{q}_1和t$，分别表示插值的起始点，终点和目前的进度。 插值的基本步骤为： 算出起始点和重点之间的差距 使用t得出一部分差距 将这一部分差距加到起始点上 这三个步骤可表示为： $$\\begin{aligned} \\Delta a &amp;=a_{1}-a_{0} \\ \\operatorname{lerp}\\left(a_{0}, a_{1}, t\\right) &amp;=a_{0}+t \\Delta a \\end{aligned}$$ 而对于四元数的插值来说，步骤基本类似，具体为： 算出两个朝向的差值 $$\\Delta \\mathbf{q}=\\mathbf{q}{1} \\mathbf{q}{0}^{-1}$$ 使用指数操作，求出一部分差值 $$(\\Delta \\mathbf{q})^{t}$$ 通过乘法，对起始位置加上差值 $$(\\Delta \\mathbf{q})^{t} \\mathbf{q}_{0}$$ 结合起来，四元数的插值运算为： $$\\text { slerp }\\left(\\mathbf{q}{0}, \\mathbf{q}{1}, t\\right)=\\left(\\mathbf{q}{1} \\mathbf{q}{0}^{-1}\\right)^{t} \\mathbf{q}_{0}$$ 但在实际运用中，通常使用另一个方法进行四元数的插值运算。 因为所有形式为旋转四元数的四元数，其模都为1，所以可以看作是在长度为1的四维球体表面。那么插值运算可以看作是在这个四维的球体表面的弧线上运动（所以插值运算全程是球面线性插值）。 如下图所示： 而可以进一步，将$v_t$看作是$v_0$和$v_1$的线性组合。 根据下图，可以求得$k_1$ $$\\begin{aligned} \\sin \\omega &amp;=\\frac{\\sin t \\omega}{k_{1}} \\ k_{1} &amp;=\\frac{\\sin t \\omega}{\\sin \\omega} \\end{aligned}$$ 注意因为$v_1$的模为1，所以在分母中省略了。 同理，根据下图，可以求出$k_0$ 因此可得： $$\\mathbf{v}{t}=k{0} \\mathbf{v}{0}+k{1} \\mathbf{v}{1}=\\frac{\\sin (1-t) \\omega}{\\sin \\omega} \\mathbf{v}{0}+\\frac{\\sin t \\omega}{\\sin \\omega} \\mathbf{v}_{1}$$ 即 $$\\operatorname{slerp}\\left(\\mathbf{q}{0}, \\mathbf{q}{1}, t\\right)=\\frac{\\sin (1-t) \\omega}{\\sin \\omega} \\mathbf{q}{0}+\\frac{\\sin t \\omega}{\\sin \\omega} \\mathbf{q}{1}$$ 现在还遗留的问题是如何求出插值的角度$\\omega$。根据之前对于四元数点乘的定义，可以使用点积求得四元数中得标量部分$\\omega$(这里的$\\omega$不是指角度)，即可通过$\\mathbf{q}_0 \\cdot \\mathbf{q}_1$得到$\\cos\\omega$ （这里的$\\omega$是指要求得角度差值，不是标量）。 //TODO 书中有给出关于差值的算法 Advantages and Disadvantage of Quaternions 优点： 可以实现平滑的插值运算 可以级联和使用四元数的逆进行逆转换 可以快速的转换至矩阵形式，和从矩阵形式转换回来 只需要四个数字 缺点： 需要的数字仍然比欧拉角多（欧拉角只需要3个数字） 并不是所有的四元数都能表示旋转 旋转四元数的模是1 人无法直观理解 Quaternions as Complex Number 这一节是用从复数的角度来描述四元数，从这个角度可以解释两个问题，一是为什么从旋转角度来看，四元数代表的是$\\theta/2$而不是$\\theta$，二是为什么用于旋转的表达式是$\\mathbf{qvq_{-1}}$ 首先实数可以通过矩阵形式进行表达，如实数$a$，可按如下方式表示： $$a \\equiv\\left[\\begin{array}{ll} a &amp; 0 \\ 0 &amp; a \\end{array}\\right]$$ 复数同样可以通过矩阵形式表达，如复数$a+bi$，可以表达为： $$a+b i \\equiv\\left[\\begin{array}{cc} a &amp; -b \\ b &amp; a \\end{array}\\right]$$ 而且这样表达复数，仍然可以满足$i^2=-1$的性质，如下 $$i^{2} \\equiv\\left[\\begin{array}{cc} 0 &amp; -1 \\ 1 &amp; 0 \\end{array}\\right]^{2}=\\left[\\begin{array}{cc} 0 &amp; -1 \\ 1 &amp; 0 \\end{array}\\right]\\left[\\begin{array}{cc} 0 &amp; -1 \\ 1 &amp; 0 \\end{array}\\right]=\\left[\\begin{array}{cc} -1 &amp; 0 \\ 0 &amp; -1 \\end{array}\\right] \\equiv-1$$ 因为四元数的乘法是从右向左的，相当于是矩阵中的右手坐标系，所以矩阵中的每一列代表坐标轴，从上式可以看到，在$i$乘以$i$后，列从$[0,1]$变为了$[-1,0]$，从$[-1,0]$变为了$[0,-1]$，即旋转了90°。 即可以将复数看作是一种旋转的表达，如果旋转$\\theta^{\\circ}$，即表达为： $$\\cos \\theta+i \\sin \\theta \\equiv\\left[\\begin{array}{cc} \\cos \\theta &amp; -\\sin \\theta \\ \\sin \\theta &amp; \\cos \\theta \\end{array}\\right]$$ 这个矩阵即为之前在二维旋转中推导出的，旋转$\\theta^{\\delta}$的矩阵，只不过之前推导的是左手坐标系中的，这里是右手坐标系中的（两个坐标系的结果互为转置）。 如果将复数$x+yi$用矩阵表示为矩阵$[x,y]$，可以看到实数的乘法与矩阵的乘法同样可以对应起来。进一步证明可以通过实数来进行旋转操作。 同时复数的共轭，也可以与矩阵的求逆对应起来，两者都是进行逆变换。 $$\\begin{aligned} (\\cos \\theta+i \\sin \\theta)(x+i y) &amp;=x \\cos \\theta+i y \\cos \\theta+i x \\sin \\theta+i^{2} y \\sin \\theta \\ &amp;=(x \\cos \\theta-y \\sin \\theta)+i(x \\sin \\theta+y \\cos \\theta) \\end{aligned}$$ $$\\left[\\begin{array}{cc} \\cos \\theta &amp; -\\sin \\theta \\ \\sin \\theta &amp; \\cos \\theta \\end{array}\\right]\\left[\\begin{array}{l} x \\ y \\end{array}\\right]=\\left[\\begin{array}{l} x \\cos \\theta-y \\sin \\theta \\ x \\sin \\theta+y \\cos \\theta \\end{array}\\right]$$ 当这个结论无法推导至三维空间中。在二维空间中，用实数和虚数$i$对应两个维度，但是在三维空间中无法用实数和两个虚数$i,j$来对应三个维度（无法用$3\\times3$的矩阵表示）。 如果可以对应，那么三维的单位矩阵$I_3$，应该对应数字1，三维的负单位矩阵$I_3$，应该对应-1。因为$i^2=-1$，所以表示虚数$i$的矩阵的平方应该等于$-I_3$。 但是$-I_3$的行列式值为-1，根据行列式性质“乘积的行列式等于行列式的乘积”，那么表示虚数$i$的矩阵的行列式的平方，应该等于-1，即该矩阵的行列式值为i，这显然无法满足。 因此无法通过$3\\times 3$的矩阵来表示三维三维的虚数。 数学家$William Hamilton$提出，可以通过四维的虚数来表示四维空间，即通过实数，和三个虚数$i,j,k$来表示。其中三个虚数满足： $$\\begin{aligned} &amp;i^{2}=j^{2}=k^{2}=-1\\ &amp;i j=k, \\quad j i=-k\\ &amp;j k=i, \\quad k j=-i\\ &amp;k i=j, \\quad i k=-j \\end{aligned}$$ 而四元数就是一种形式的四维矩阵，即$[w,(x, y, z)]$可用来对应$w+x i+y j+z k$。 将四维的虚数用$4\\times4$的矩阵表示有多个方法，以下为其中一种： $$a \\equiv\\left[\\begin{array}{llll} a &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; a &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; a &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; a \\end{array}\\right]$$ $$i \\equiv\\left[\\begin{array}{cccc} 0 &amp; 0 &amp; 0 &amp; 1 \\ 0 &amp; 0 &amp; -1 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 0 \\ -1 &amp; 0 &amp; 0 &amp; 0 \\end{array}\\right], \\quad j \\equiv\\left[\\begin{array}{cccc} 0 &amp; 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \\ -1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; -1 &amp; 0 &amp; 0 \\end{array}\\right], \\quad k \\equiv\\left[\\begin{array}{cccc} 0 &amp; -1 &amp; 0 &amp; 0 \\ 1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \\ 0 &amp; 0 &amp; -1 &amp; 0 \\end{array}\\right]$$ 结合可得： $$w+x i+y j+z k \\equiv\\left[\\begin{array}{cccc} w &amp; -z &amp; y &amp; x \\ z &amp; w &amp; -x &amp; y \\ -y &amp; x &amp; w &amp; z \\ -x &amp; -y &amp; -z &amp; w \\end{array}\\right]$$ 可以发现，$k$矩阵的左上部分与二维空间中$i$的表达一模一样，于是猜测$k$矩阵也可以用来表达旋转，且是绕着$z$的旋转。使用三维向量$[1,0,1]$来测试。该向量如果用四元数表达，则为$[0 \\quad (1,0,1)]$，即用实数表达为$i+k$。因为是绕着$z$轴旋转，所以$z$的变量不会变，$xy$变量的结果与二维空间旋转结果相同，即最后的正确结果应该是$(\\cos \\theta,\\sin\\theta,1)$，即$\\cos\\theta i +\\sin\\theta j+k$ 那么相乘过程可以表示为： $$\\begin{aligned} (\\cos \\theta+k \\sin \\theta)(i+k) &amp;=i \\cos \\theta+k \\cos \\theta+k i \\sin \\theta+k^{2} \\sin \\theta \\ &amp;=i \\cos \\theta+j \\sin \\theta+k \\cos \\theta-\\sin \\theta \\end{aligned}$$ 可以看到结果根本就不是一个三维空间中的向量，因为$w$参数并不为0。这个结果中，$x,y$平面的答案是我们想要的，而$z,w$平面则不是。 如果对实数取共轭，即表达为$\\cos\\theta - k\\sin \\theta$，并且进行右乘，那么结果为： $$(i+k)(\\cos \\theta-k \\sin \\theta)=i \\cos \\theta+j \\sin \\theta-k \\cos \\theta+\\sin \\theta$$ 结果仍然不是一个三维空间中你的向量，$x,y$平面的结果不变，$z,w$平面的结果虽然不同，但是与之前的结果正好相反，所以尝试将两个表达式结合在一起，即 $$\\begin{aligned} &amp;(\\cos \\theta+k \\sin \\theta)(i+k)(\\cos \\theta-k \\sin \\theta) \\ =&amp;(i \\cos \\theta+j \\sin \\theta+k \\cos \\theta-\\sin \\theta)(\\cos \\theta-k \\sin \\theta) \\ =&amp; i \\cos ^{2} \\theta-i k \\cos \\theta \\sin \\theta+j \\sin \\theta \\cos \\theta-j k \\sin ^{2} \\theta+k \\cos ^{2} \\theta-k^{2} \\cos \\theta \\sin \\theta-\\sin \\theta \\cos \\theta+k \\sin ^{2} \\theta \\ =&amp; i \\cos ^{2} \\theta+j \\cos \\theta \\sin \\theta+j \\sin \\theta \\cos \\theta-i \\sin ^{2} \\theta+k \\cos ^{2} \\theta+\\cos \\theta \\sin \\theta-\\sin \\theta \\cos \\theta+k \\sin ^{2} \\theta \\ =&amp; i \\cos ^{2} \\theta-i \\sin ^{2} \\theta+2 j \\sin \\theta \\cos \\theta+k \\ =&amp; i \\cos 2 \\theta+j \\sin 2 \\theta+k \\end{aligned}$$ 与正确结果$\\cos\\theta i +\\sin\\theta j+k$相比，$\\theta$变为了$2\\theta$。因此如果要用复数来表达旋转的话，式子应该改为$(\\cos \\theta /2+k \\sin \\theta /2)(i+k)(\\cos \\theta /2-k \\sin \\theta /2)$，即四元数应该表达为$\\mathbf{q}=[\\cos \\theta /2 \\quad \\mathbf{\\sin \\theta/2k}]$，且上述式子对应的乘法表达式为$\\mathbf{qpq^-1}$。 而这就是前几节中定义的用四元数来表示乘法的方法。 Summary of Quaternions 这一节是总结上述描述中比较重要的概念。 概念上来说，四元数可以用来表达绕着一个轴的旋转一定角度。 其中四元数中的标量部分$w=\\cos (\\theta / 2)$，向量部分$\\mathbf{v}=\\hat{\\mathbf{n}} \\sin (\\theta / 2)$。 这种四元数称为旋转四元数，其模为1 从几何角度来说，每个三维点的旋转，都有两种表达方式，且这两个表达方式互为对方的相反（不是逆），即$\\mathbf{q}=\\mathbf{-q}$ 单位四元数$[1 \\quad \\mathbf{0}]$和$[-1 \\quad \\mathbf{0}]$都表达没有旋转 旋转四元数可以级联表示多个旋转（从右向做级联），表达式为$\\mathbf{qpq^-1}$且可以通过求旋转四元数的逆来表示逆变换，且因为旋转四元数的模为1，所以旋转四元数的逆等于旋转四元数的共轭。 但实际运用中，很少通过$\\mathbf{qpq^-1}$计算旋转，更多的是使用矩阵。 四元数的指数运算可以用来截取或者倍化四元数表示的旋转，但只能表示最短路径。 旋转四元数常用来计算插值。 Comparision of Methods 欧拉角是最适合人直接理解的方法 当需要进行空间转换时，必须是使用矩阵 如果要大量的存储旋转信息，欧拉角，指数映射和四元数是比较理想的存储方式 要实现可靠的插值运算，只能通过四元数 只有四元数和矩阵运算可以实现旋转级联 矩阵，指数映射，四元数都可以快速的求出逆运算 如果要求角速度，或者其他要保留额外的旋转（有几次360°的旋转），只有轴角法或者指数映射表达可以实现。 Converting between Representations Converting Euler Angles to Matrix 从欧拉角表达转到矩阵表达，存在不同情况下的不同矩阵。如一个场景中有普通物体和摄像机，用于表达普通物体旋转的矩阵与摄像机是不同的，普通物体是用物体-直立坐标系的矩阵表达，而摄像机为直立到物体坐标系的矩阵。 两个矩阵互为逆矩阵，所以在这里重点说明物体-直立坐标系的矩阵表达，直立到物体坐标系的矩阵可以通过取反快速得到。 欧拉角转换成矩阵表达的基本思想就是，将绕着三个轴的旋转拆分，各自表达为一个旋转矩阵，然后再级联，即得到了结果。 这里还存在的问题是，级联的顺序该如何定。如之前所述，关于欧拉角的表达分为传统欧拉旋转顺序（heading-pitch-row）和固定轴旋转顺序（row-pitch-heading）。这里用固定轴的旋转顺序进行旋转，否则的话在之前的轴旋转后，后续的轴就发生了变换。 又因为在左手坐标系下，乘法顺序是从左至右的，所以欧拉角在物体-直立坐标系矩阵中的表达式为： $$\\mathbf{M}_{\\text {object} \\rightarrow \\text {upright}}=\\mathbf{B P H}$$ 根据第五章中的内容，可以很容易的得到绕着每个轴旋转的矩阵 $$\\begin{aligned} &amp;\\mathbf{B}=\\mathbf{R}{z}(b)=\\left[\\begin{array}{ccc} \\cos b &amp; \\sin b &amp; 0 \\ -\\sin b &amp; \\cos b &amp; 0 \\ 0 &amp; 0 &amp; 1 \\end{array}\\right]\\ &amp;\\begin{array}{l} \\mathbf{P}=\\mathbf{R}{x}(p)=\\left[\\begin{array}{ccc} 1 &amp; 0 &amp; 0 \\ 0 &amp; \\cos p &amp; \\sin p \\ 0 &amp; -\\sin p &amp; \\cos p \\end{array}\\right] \\ \\mathbf{H}=\\mathbf{R}_{y}(h)=\\left[\\begin{array}{ccc} \\cos h &amp; 0 &amp; -\\sin h \\ 0 &amp; 1 &amp; 0 \\ \\sin h &amp; 0 &amp; \\cos h \\end{array}\\right] \\end{array} \\end{aligned}$$ 结合得： $$\\begin{aligned} \\mathbf{M}_{o b j e c t \\rightarrow u p r i g h t} &amp;=\\mathbf{B P H} \\ &amp;=\\left[\\begin{array}{ccc} \\cos h \\cos b+\\sin h \\sin p \\sin b &amp; \\sin b \\cos p &amp; -\\sin h \\cos b+\\cos h \\sin p \\sin b \\ -\\cos h \\sin b+\\sin h \\sin p \\cos b &amp; \\cos b \\cos p &amp; \\sin b \\sin h+\\cos h \\sin p \\cos b \\ \\sin h \\cos p &amp; -\\sin p &amp; \\cos h \\cos p \\end{array}\\right] \\end{aligned}$$ 直立-物体坐标系的表达取逆即可： $$\\begin{aligned} \\mathbf{M}{u p r i g h t \\rightarrow o b j e c t} &amp;=\\mathbf{H}^{-1} \\mathbf{P}^{-1} \\mathbf{B}^{-1}=\\mathbf{R}{y}(-h) \\mathbf{R}{x}(-p) \\mathbf{R}{z}(-b) \\ &amp;=\\left[\\begin{array}{ccc} \\cos h \\cos b+\\sin h \\sin p \\sin b &amp; -\\cos h \\sin b+\\sin h \\sin p \\cos b &amp;\\sin h \\cos p \\ \\sin b \\cos p &amp; \\cos b \\cos p &amp;-\\sin p\\ -\\sin h \\cos b+\\cos h \\sin p \\sin b &amp; \\sin b \\sin h+\\cos h \\sin p \\cos b &amp;\\cos h \\cos p \\end{array}\\right] \\end{aligned}$$ Converting a Matrix to Euler angles 从矩阵转换到欧拉角，首先要确认矩阵表达的是什么形式的旋转，物体-直立坐标系，还是直立-物体坐标系。 矩阵转换到到欧拉角后返回的结果是标准坐标，即heading和bank的范围为$\\left(-180^{\\circ},+180^{\\circ}\\right]$，pitch的范围是$\\left[-90^{\\circ},+90^{\\circ}\\right]$ 这节中方法默认给的矩阵是合法的旋转矩阵。 首先是将物体-直立坐标系的矩阵转换为欧拉角，矩阵如下所示： $$\\left[\\begin{array}{ccc} \\cos h \\cos b+\\sin h \\sin p \\sin b &amp; \\sin b \\cos p &amp; -\\sin h \\cos b+\\cos h \\sin p \\sin b \\ -\\cos h \\sin b+\\sin h \\sin p \\cos b &amp; \\cos b \\cos p &amp; \\sin b \\sin h+\\cos h \\sin p \\cos b \\ \\sin h \\cos p &amp; -\\sin p &amp; \\cos h \\cos p \\end{array}\\right]$$ 从元素$m_{32}=-\\sin p$中可以直接求出pitch角度,$\\arcsin \\left(-m_{32}\\right)=p$。 C标准库中的$asin()$函数返回的数值范围为$[-\\pi / 2,+\\pi / 2]$，正好符合标准坐标对于pitch角度的范围要求。所以为： $$ p=\\operatorname{asin}(-m_{32}) $$ 求heading和roll角度时，要考虑万向锁的问题，即当pitch角度为正负90°的情况。 首先如果不是万向锁的情况，那么可以根据元素$m_{31}=\\sin h \\cos p$和元素$m_{33}=\\cos h \\cos p$求出， 即 $$h=\\operatorname{atan2} (\\sin h, \\cos h)=\\operatorname{atan2} \\left(m_{31} / \\cos p, m_{33} / \\cos p\\right)$$ 因为pitch角度不为$\\pm 90 ^{\\circ}$，所以$\\cos p$不为0，且可以约分，即 $$h=\\operatorname{atan2} \\left(m_{31}, m_{33}\\right)$$ C标准库中的$atan2()$函数表示进行$\\arctan$c操作（2为函数名的一部分，并不是乘2），范围是$$[-\\pi,+\\pi]$$，同样符合标准坐标的范围。 类似的在非万向锁情况下，可以通过元素$m_{12}=\\sin b \\cos p$和元素$m_{22}=\\cos b \\cos p$求出roll角度，即 $$\\begin{aligned} b &amp;=\\operatorname{atan2} (\\sin b, \\cos b)=\\operatorname{atan2} \\left(m_{12} / \\cos p, m_{22} / \\cos p\\right) \\ &amp;=\\operatorname{atan2} \\left(m_{12}, m_{22}\\right) \\end{aligned}$$ 而在万向锁的情况下，因为$p=\\pm 90^{\\circ}，即$$\\cos p=0$，所以无法将$\\cos p$作为分母。而且此时，heading角度和roll角度的旋转是相同效果的。 在万向锁情况下，限定roll角度为0，即$b=0, \\sin b =0 \\cos b=1$，此时通过元素$m_{11}=\\cos h \\cos b+\\sin h \\sin p \\sin b$和元素$m_{13}=-\\sin h \\cos b+\\cos h \\sin p \\sin b$来求得heading角度。 将$\\cos b=1, \\sin p=1, \\sin b=0$，带入得 $$ m_{11}=\\cos h \\quad m_{13}=-\\sin h $$ 即 $$h=\\operatorname{atan2} \\left(-m_{13}, m_{11}\\right)$$ 直立-物体坐标系的矩阵到欧拉角的转换雷同，矩阵为： $$ \\left[\\begin{array}{ccc} \\cos h \\cos b+\\sin h \\sin p \\sin b &amp; -\\cos h \\sin b+\\sin h \\sin p \\cos b &amp;\\sin h \\cos p \\ \\sin b \\cos p &amp; \\cos b \\cos p &amp;-\\sin p\\ -\\sin h \\cos b+\\cos h \\sin p \\sin b &amp; \\sin b \\sin h+\\cos h \\sin p \\cos b &amp;\\cos h \\cos p \\end{array}\\right] $$ 欧拉角计算方法为 $$ p=\\operatorname{asin}(-m_{23}) $$ 当非万向锁时，即$p\\neq \\pm 90^{\\circ}$时，有： $$ h=\\operatorname{atan2} \\left(m_{13}, m_{33}\\right) \\ b=\\operatorname{atan2} \\left(m_{21}, m_{22}\\right) $$ 当万向锁时，即$p= \\pm 90^{\\circ}$时，有： $$ b=0 \\ h=\\operatorname{atan2} \\left(m_{31}, m_{11}\\right) $$ //TODO 书中给出从欧拉角转换为物体-直立坐标系矩阵的代码 Converting a Quaternion to a Matrix 因为旋转四元数表达的是绕着任意轴$\\hat{n}$旋转$\\theta$，而这个同样可以通过矩阵表达，即第五章中得出的： $$\\left[\\begin{array}{ccc} n_{x}^{2}(1-\\cos \\theta)+\\cos \\theta &amp; n_{x} n_{y}(1-\\cos \\theta)+n_{z} \\sin \\theta &amp; n_{x} n_{z}(1-\\cos \\theta)-n_{y} \\sin \\theta \\ n_{x} n_{y}(1-\\cos \\theta)-n_{z} \\sin \\theta &amp; n_{y}^{2}(1-\\cos \\theta)+\\cos \\theta &amp; n_{y} n_{z}(1-\\cos \\theta)+n_{x} \\sin \\theta \\ n_{x} n_{z}(1-\\cos \\theta)+n_{y} \\sin \\theta &amp; n_{y} n_{z}(1-\\cos \\theta)-n_{x} \\sin \\theta &amp; n_{z}^{2}(1-\\cos \\theta)+\\cos \\theta \\end{array}\\right]$$ 而转换四元数到矩阵的思路，就是用四元数的四个元素来取代上面矩阵中的元素，四元数的四个元素分别表示为： $$\\begin{array}{l} w=\\cos (\\theta / 2) \\ x=n_{x} \\sin (\\theta / 2) \\ y=n_{y} \\sin (\\theta / 2) \\ z=n_{z} \\sin (\\theta / 2) \\end{array}$$ 通过观察绕任意轴旋转的矩阵可以发现，对角线元素的表达方式是一种类型，非对角线元素的表达方式是另一种类型。因此，只要分别求出一个对角线元素的转换和一个非对角线元素的转换，其他的元素都可以类比得到。 首先求对角线元素$m_{11}$，通过等式代换可以转换为四元数中的元素，如下： $$\\begin{aligned} m_{11} &amp;=n_{x}^{2}(1-\\cos \\theta)+\\cos \\theta \\ &amp;=n_{x}^{2}-n_{x}^{2} \\cos \\theta+\\cos \\theta \\ &amp;=1-1+n_{x}^{2}-n_{x}^{2} \\cos \\theta+\\cos \\theta \\ &amp;=1-\\left(1-n_{x}^{2}+n_{x}^{2} \\cos \\theta-\\cos \\theta\\right) \\ &amp;=1-\\left(1-\\cos \\theta-n_{x}^{2}+n_{x}^{2} \\cos \\theta\\right) \\ &amp;=1-\\left(1-n_{x}^{2}\\right)(1-\\cos \\theta) \\end{aligned}$$ 根据倍角公式，可以进一步拆分$\\cos \\theta$： $$\\begin{aligned} \\cos 2 \\alpha &amp;=1-2 \\sin ^{2} \\alpha \\ \\cos \\theta &amp;=1-2 \\sin ^{2}(\\theta / 2) \\end{aligned}$$ 带入上述得： $$\\begin{aligned} m_{11} &amp;=1-\\left(1-n_{x}^{2}\\right)(1-\\cos \\theta) \\ &amp;=1-\\left(1-n_{x}^{2}\\right)\\left(1-\\left(1-2 \\sin ^{2}(\\theta / 2)\\right)\\right) \\ &amp;=1-\\left(1-n_{x}^{2}\\right)\\left(2 \\sin ^{2}(\\theta / 2)\\right) \\end{aligned}$$ 因为$\\hat{\\mathbf{n}}$是一个单位向量，所以有$n_{x}^{2}+n_{y}^{2}+n_{z}^{2}=1$，带入上式可继续代换得： $$\\begin{aligned} m_{11} &amp;=1-\\left(1-n_{x}^{2}\\right)\\left(2 \\sin ^{2}(\\theta / 2)\\right) \\ &amp;=1-\\left(n_{y}^{2}+n_{z}^{2}\\right)\\left(2 \\sin ^{2}(\\theta / 2)\\right) \\ &amp;=1-2 n_{y}^{2} \\sin ^{2}(\\theta / 2)-2 n_{z}^{2} \\sin ^{2}(\\theta / 2) \\ &amp;=1-2 y^{2}-2 z^{2} \\end{aligned}$$ 可类比得到其他得对角线元素 $$ m_{22}=1-2x^2-2z^2 \\ m_{33}=1-2x^2-2y^2 $$ 在求非对角线元素$m_{12}$，同样是通过等式代换，首先根据倍角公式可得： $$\\begin{aligned} &amp;\\sin 2 \\alpha=2 \\sin \\alpha \\cos \\alpha\\ &amp;\\sin \\theta=2 \\sin (\\theta / 2) \\cos (\\theta / 2) \\end{aligned}$$ 与之前的$\\cos$的倍角公式结果一起带入$m_{12}$，得 $$\\begin{aligned} m_{12} &amp;=n_{x} n_{y}(1-\\cos \\theta)+n_{z} \\sin \\theta \\ &amp;=n_{x} n_{y}\\left(1-\\left(1-2 \\sin ^{2}(\\theta / 2)\\right)\\right)+n_{z}(2 \\sin (\\theta / 2) \\cos (\\theta / 2)) \\ &amp;=n_{x} n_{y}\\left(2 \\sin ^{2}(\\theta / 2)\\right)+2 n_{z} \\sin (\\theta / 2) \\cos (\\theta / 2) \\ &amp;=2\\left(n_{x} \\sin (\\theta / 2)\\right)\\left(n_{y} \\sin (\\theta / 2)\\right)+2 \\cos (\\theta / 2)\\left(n_{z} \\sin (\\theta / 2)\\right) \\ &amp;=2 x y+2 w z \\end{aligned}$$ 类比可得其他的非对角元素，如： $m_{13}=2xz-2wy$ 最终转换为的矩阵为: $$\\left[\\begin{array}{ccc} 1-2 y^{2}-2 z^{2} &amp; 2 x y+2 w z &amp; 2 x z-2 w y \\ 2 x y-2 w z &amp; 1-2 x^{2}-2 z^{2} &amp; 2 y z+2 w x \\ 2 x z+2 w y &amp; 2 y z-2 w x &amp; 1-2 x^{2}-2 y^{2} \\end{array}\\right]$$ Converting a Matrix to a Quaternion 矩阵转换为四元数的主要思路是通过组合矩阵中的元素来获得四元数四个元素的表达。而矩阵中的对角线元素，不包含两个不同四元数元素的乘积，所以通过矩阵的对角线元素来计算： 如累加三个对角元素，得： $$\\begin{aligned} m_{11}+m_{22}+m_{33} &amp;=\\left(1-2 y^{2}-2 z^{2}\\right)+\\left(1-2 x^{2}-2 z^{2}\\right)+\\left(1-2 x^{2}-2 y^{2}\\right) \\ &amp;=3-4\\left(x^{2}+y^{2}+z^{2}\\right) \\ &amp;=3-4\\left(1-w^{2}\\right) \\ &amp;=4 w^{2}-1 \\end{aligned}$$ 同样可得： $$\\begin{aligned} m_{11}-m_{22}-m_{33} &amp;=\\left(1-2 y^{2}-2 z^{2}\\right)-\\left(1-2 x^{2}-2 z^{2}\\right)-\\left(1-2 x^{2}-2 y^{2}\\right) \\ &amp;=4 x^{2}-1 \\ -m_{11}+m_{22}-m_{33} &amp;=-\\left(1-2 y^{2}-2 z^{2}\\right)+\\left(1-2 x^{2}-2 z^{2}\\right)-\\left(1-2 x^{2}-2 y^{2}\\right) \\ &amp;=4 y^{2}-1 \\ -m_{11}-m_{22}+m_{33} &amp;=-\\left(1-2 y^{2}-2 z^{2}\\right)-\\left(1-2 x^{2}-2 z^{2}\\right)+\\left(1-2 x^{2}-2 y^{2}\\right) \\ &amp;=4 z^{2}-1 \\end{aligned}$$ 因此： $$\\begin{aligned} &amp;w=\\frac{\\sqrt{m_{11}+m_{22}+m_{33}+1}}{2}\\ &amp;x=\\frac{\\sqrt{m_{11}-m_{22}-m_{33}+1}}{2}\\ &amp;y=\\frac{\\sqrt{-m_{11}+m_{22}-m_{33}+1}}{2}\\ &amp;z=\\frac{\\sqrt{-m_{11}-m_{22}+m_{33}+1}}{2} \\end{aligned}$$ 但这个计算方式的问题在于，因为是通过根号求得结果，所以四个元素的结果都是正数。在四元数中，$\\mathbf{q}$和$\\mathbf{-q}$表达的是相同的元素，所以单一的元素到底是正数还是负数没有关系，只要其他的元素相应变化就可以，但是所有的元素都一定是正数会造成问题。 根据非对角元素的组合可得： $$\\begin{aligned} &amp;m_{12}+m_{21}=(2 x y+2 w z)+(2 x y-2 w z)=4 x y\\ &amp;\\begin{array}{l} m_{12}-m_{21}=(2 x y+2 w z)-(2 x y-2 w z)=4 w z \\ m_{31}+m_{13}=(2 x z+2 w y)+(2 x z-2 w y)=4 x z \\ m_{31}-m_{13}=(2 x z+2 w y)-(2 x z-2 w y)=4 w y \\ m_{23}+m_{32}=(2 y z+2 w x)+(2 y z-2 w x)=4 y z \\ m_{23}-m_{32}=(2 y z+2 w x)-(2 y z-2 w x)=4 w x \\end{array} \\end{aligned}$$ 用之前的根号求解出一个元素数值，然后通过这些表达式，就可以求出正确的答案，即如下表达式的四选一： $$\\begin{aligned} &amp;w=\\frac{\\sqrt{m_{11}+m_{22}+m_{33}+1}}{2} \\Longrightarrow x=\\frac{m_{23}-m_{32}}{4 w} \\quad y=\\frac{m_{31}-m_{13}}{4 w} \\quad z=\\frac{m_{12}-m_{21}}{4 w}\\ &amp;x=\\frac{\\sqrt{m_{11}-m_{22}-m_{33}+1}}{2} \\Longrightarrow w=\\frac{m_{23}-m_{32}}{4 x} \\quad y=\\frac{m_{12}+m_{21}}{4 x} \\quad z=\\frac{m_{31}+m_{13}}{4 x}\\ &amp;y=\\frac{\\sqrt{-m_{11}+m_{22}-m_{33}+1}}{2} \\Longrightarrow w=\\frac{m_{31}-m_{13}}{4 y} \\quad x=\\frac{m_{12}+m_{21}}{4 y} \\quad z=\\frac{m_{23}+m_{32}}{4 y}\\ &amp;z=\\frac{\\sqrt{-m_{11}-m_{22}+m_{33}+1}}{2} \\Longrightarrow w=\\frac{m_{12}-m_{21}}{4 z} \\quad x=\\frac{m_{31}+m_{13}}{4 z} \\quad y=\\frac{m_{23}+m_{32}}{4 z} \\end{aligned}$$ 新问题是，如何决定取哪一个元素用根号求解？ 通常的做法是先计算出每个元素的平方值，然后用平方值最大的元素开根，再通过结果求解其他值。 //TODO 书中给出从矩阵转换到欧拉角的代码 Converting Euler Angles to a Quaternion 如同欧拉角转换为矩阵一样，欧拉角转换到四元数也一样要考虑两种情况，物体-直立四元数和直立-物体四元数。因为两者相互取共轭就能转换，所以这里主要讨论物体-直立四元数。 四元数的转换，如矩阵的转换类似，同样是通过求每个轴的四元数表达，然后级联得到。其中每个每个轴的旋转四元数为： $$\\mathbf{h}=\\left[\\begin{array}{c}\\cos (h / 2) \\ \\left(\\begin{array}{c} 0 \\ \\sin (h / 2) \\ 0 \\end{array}\\right) \\end{array}\\right], \\quad \\mathbf{p}= \\left[\\begin{array}{c} \\cos (p / 2) \\ \\left(\\begin{array}{c} \\sin (p / 2) \\ 0 \\ 0 \\end{array}\\right) \\end{array}\\right], \\quad \\mathbf{b}= \\left[\\begin{array}{c} \\cos (b / 2) \\ \\left(\\begin{array}{c} 0 \\ 0 \\ \\sin (p / 2) \\end{array}\\right) \\end{array}\\right]$$ 而且同样是通过固定轴，即计算顺序为$roll-pitch-heading$。但不同的是四元数的乘法结合顺序是从右到左的。因此结合的结果如下： $$\\begin{array}{l} \\mathbf{q}_{object \\rightarrow upright}(h, p, b)=\\mathbf{hpb} \\ =\\left[\\begin{array}{c} \\cos (h / 2) \\ \\left(\\begin{array}{c}0 \\ \\sin (h / 2) \\ 0 \\end{array}\\right) \\end{array}\\right] \\left[\\begin{array}{c} \\cos (p / 2) \\ \\left(\\begin{array}{c}\\sin (p / 2) \\0 \\ 0 \\end{array}\\right) \\end{array}\\right] \\left[\\begin{array}{c} \\cos (b / 2) \\ \\left(\\begin{array}{c}0 \\0 \\ \\sin (b / 2) \\end{array}\\right) \\end{array}\\right] \\ =\\left[\\begin{array}{c} \\cos (h / 2) \\cos (p / 2) \\ \\left(\\begin{array}{c} \\cos (h / 2) \\sin (p / 2) \\ \\sin (h / 2) \\cos (p / 2) \\ -\\sin (h / 2) \\sin (p / 2) \\end{array}\\right) \\end{array}\\right] \\left[\\begin{array}{c} \\cos (b / 2) \\ \\left(\\begin{array}{c} 0 \\ 0 \\ \\sin (b / 2) \\end{array}\\right) \\end{array}\\right] \\ =\\left[\\begin{array}{c} \\cos (h / 2) \\cos (p / 2) \\cos (b / 2)+\\sin (h / 2) \\sin (p / 2) \\sin (b / 2) \\ \\left(\\begin{array}{c} \\cos (h / 2) \\sin (p / 2) \\cos (b / 2)+\\sin (h / 2) \\cos (p / 2) \\sin (b / 2) \\ \\sin (h / 2) \\cos (p / 2) \\cos (b / 2)-\\cos (h / 2) \\sin (p / 2) \\sin (b / 2) \\ \\cos (h / 2) \\cos (p / 2) \\sin (b / 2)-\\sin (h / 2) \\sin (p / 2) \\cos (b / 2) \\end{array}\\right) \\end{array}\\right] \\end{array} $$ 直立坐标系到空间坐标系的四元数为： $$\\begin{array}{l} \\mathbf{q}{upright \\rightarrow object}(h, p, b) = \\mathbf{q}{object \\rightarrow upright }(h, p, b)^{*} \\ =\\left[\\begin{array}{c} \\cos (h / 2) \\cos (p / 2) \\cos (b / 2)+\\sin (h / 2) \\sin (p / 2) \\sin (b / 2) \\ \\left(\\begin{array}{c} -\\cos (h / 2) \\sin (p / 2) \\cos (b / 2)-\\sin (h / 2) \\cos (p / 2) \\sin (b / 2) \\ \\cos (h / 2) \\sin (p / 2) \\sin (b / 2)-\\sin (h / 2) \\cos (p / 2) \\cos (b / 2) \\ \\sin (h / 2) \\sin (p / 2) \\cos (b / 2)-\\cos (h / 2) \\cos (p / 2) \\sin (b / 2) \\end{array}\\right) \\end{array}\\right] \\end{array}$$ Converting a Quaternion to Euler Angles 首先讨论从物体-直立四元数转换为欧拉角的方法。 之前已经求出了如何从矩阵转换为欧拉角，如下所示： $$\\begin{array}{lll} p &amp; =\\arcsin \\left(-m_{32}\\right) \\ h &amp; =\\left{\\begin{array}{ll} \\operatorname{atan2}\\left(m_{31}, m_{33}\\right) &amp; \\text { if } \\cos p \\neq 0 \\ \\operatorname{atan2}\\left(-m_{13}, m_{11}\\right) &amp; \\text { otherwise } \\end{array}\\right. \\ b &amp; =\\left{\\begin{array}{ll} \\operatorname{atan2}\\left(m_{12}, m_{22}\\right) &amp; \\text { if } \\cos p \\neq 0 \\ 0 &amp; \\text { otherwise } \\end{array}\\right. \\end{array}$$ 同样求出了矩阵中的元素，如何用四元数中的元素表达，如下： $$\\begin{aligned} m_{11}=1-2 y^{2}-2 z^{2}, \\quad &amp; m_{12}=2 x y+2 w z, \\quad m_{13}=2 x z-2 w y, \\ &amp; m_{22}=1-2 x^{2}-2 z^{2} \\ m_{31}=2 x z+2 w y, \\quad &amp; m_{32}=2 y z-2 w x, \\quad m_{33}=1-2 x^{2}-2 y^{2} \\end{aligned}$$ 将两者结合就能得到四元数转换为欧拉角的方法： $$\\begin{aligned} p &amp;=\\arcsin \\left(-m_{32}\\right) \\ &amp;=\\arcsin (-2(y z-w x)) \\end{aligned}$$ $$h=\\left{\\begin{array}{ll} \\operatorname{atan2} \\left(m_{31}, m_{33}\\right) \\ =\\operatorname{atan2} \\left(2 x z+2 w y, 1-2 x^{2}-2 y^{2}\\right) &amp; \\text { if } \\cos p \\neq 0 \\ =\\operatorname{atan2} \\left(x z+w y, 1 / 2-x^{2}-y^{2}\\right) \\ \\operatorname{atan2}\\left(-m_{13}, m_{11}\\right) \\ =\\operatorname{atan2}\\left(-2 x z+2 w y, 1-2 y^{2}-2 z^{2}\\right) &amp; \\text { otherwise } \\ =\\operatorname{atan2}\\left(-x z+w y, 1 / 2-y^{2}-z^{2}\\right) \\end{array}\\right.$$ $$b=\\left{\\begin{array}{ll} \\operatorname{atan} 2\\left(m_{12}, m_{22}\\right) &amp; \\text { if } \\cos p \\neq 0 \\ =\\operatorname{atan} 2\\left(2 x y+2 w z, 1-2 x^{2}-2 z^{2}\\right) &amp; \\ =\\operatorname{atan} 2\\left(x y+w z, 1 / 2-x^{2}-z^{2}\\right) \\ 0 &amp; otherwise \\end{array}\\right.$$ 从直立-物体四元数转换为欧拉角，只需要将$x,y,z$三个元素取反即可，因为直立-物体四元数是物体-直立四元数的共轭，即 $$\\begin{aligned} p &amp;=\\arcsin \\left(-m_{32}\\right) \\ &amp;=\\arcsin (-2(y z+w x)) \\end{aligned}$$ $$h=\\left{\\begin{array}{ll} \\operatorname{atan2} \\left(m_{31}, m_{33}\\right) \\ =\\operatorname{atan2} \\left(2 x z-2 w y, 1-2 x^{2}-2 y^{2}\\right) &amp; \\text { if } \\cos p \\neq 0 \\ =\\operatorname{atan2} \\left(x z-w y, 1 / 2-x^{2}-y^{2}\\right) \\ \\operatorname{atan2}\\left(-m_{13}, m_{11}\\right) \\ =\\operatorname{atan2}\\left(-2 x z-2 w y, 1-2 y^{2}-2 z^{2}\\right) &amp; \\text { otherwise } \\ =\\operatorname{atan2}\\left(-x z-w y, 1 / 2-y^{2}-z^{2}\\right) \\end{array}\\right.$$ $$b=\\left{\\begin{array}{ll} \\operatorname{atan} 2\\left(m_{12}, m_{22}\\right) &amp; \\text { if } \\cos p \\neq 0 \\ =\\operatorname{atan} 2\\left(2 x y-2 w z, 1-2 x^{2}-2 z^{2}\\right) &amp; \\ =\\operatorname{atan} 2\\left(x y-w z, 1 / 2-x^{2}-z^{2}\\right) \\ 0 &amp; otherwise \\end{array}\\right.$$ //TODO 书中给出了四元数到欧拉角的转换的代码 引用： 3D Math Primer for Graphics and Game Development 2nd 2011","link":"/3DMathPrimerForGraphicsAGameDevelopment-Chapter8-Notes/"},{"title":"《计算机网络与因特网》 第十三章笔记","text":"《计算机网络与因特网》 第十三章笔记 主要讨论了分组交换，包的概念，局域网中的拓扑等。 Chapter 13 Local Area Networks: Packets,Frames,And Topologies Introduction 这一章主要会介绍分组交换，计算机网络技术，硬件地址，帧识别等概念。 Circuit Switching And Analog Communication 电路交换（Circuit Switching）概念是指使用时在发送端和接收端之间建立不受干扰的通路的通信方法。电路交换通常与模拟电话技术相关。下图是电路交换的示意图： 电路交换的主要特点是： 是点对点的通信 有单独的步骤建立电路连接，使用电路，终止电路连接 例如在电话通信中，实际上有三步。第一步在电话发起人和接受者之间建立电路，第二步双方使用电路进行通信，第三步在通话结束后，终止通路。 这也是称为交换（Switched）电路的原因 与固定的物理通路有相同的性能。 电路交换建立的电路最终使用频分复用或者时分复用使用同一个媒介进行传输。电路建立的过程包括在频分复用或时分复用中分配频率或时间段。 Packet Switching 分组交换（Packet Switching）使用一种统计意义上的复用，即多个信源之间竞争共享媒介的使用。电路交换通常在传统的电话通信中使用，而分组交换构成了因特网的基础。分组交换示意图如下： 注意，在11章中提到的复用技术，如频分复用和时分复用是对于物理存在的信道或者像电路交换这样生成的信道使用的，与分组交换并没有关系。分组交换本身就有统计复用（Statistic Multiplexing）的概念。多个信源在媒介空闲时竞争使用，当媒介为空，且只有一个信源需要传输数据时，该信源就会独占媒介。如果同时有多个信源要传输数据，则基本每个信源占据媒介的时间是平均的，轮流使用。 分组交换的核心是将原数据切分成一个个小块方便传输，这些小块称作包（Packets），包中需要包括传送的目的地信息（在之后节会更详细说明）。分组交换传输的单位不是bit或者byte,而是包。不同的分组交换技术对于包的尺寸有不同的定义。 分组交换的主要特点是： 任意大小的异步传输 在通信前没有建立通路的步骤 性能取决于各信源的包的统计复用 分组交换的主要优点在于成本的控制。对于电路交换来说，如果有$N$个电脑，则需要$N/2$个独立的路径（虽然在连接时才创建）。但对于分组交换只要一个共享的电路就行。 Local And Wide Area Packet Networks 分组交换技术通常根据传输距离的距离进行分类。通常分为三类： 局域网（Local Area Network,LAN）：最便宜，通常范围在房间级或者一个大楼。 城域网（Metropolitan Area Network,MAN）中等开销，范围涵盖城市或者大都会。 广域网（Wide Area Network,WAN）：最贵。范围通常包含城市与城市之间。 在实际使用中，虽然城域网的概念被提出，但在商业上并不成功。基本广泛使用的只有局域网和广域网，城域网的概念在逐步被纳入广域网中。 还有一些机构或者商家定义的类似的分类方式，如： 个人局域网络（Personal Area Network，PAN），通常范围在几米内，如蓝牙通信等。 芯片局域网络（Chip Area Network），芯片厂商提出的概念，通常是超大型电路（Very-Large-Scale-Integration,VLSI）中多个核之间的通信。 Standards For Packet Format And Identification 每个在网络中传输的包都必须包含其目标收信人的标识。需要有规范来制定标识的格式以及添加的位置，在LAN领域最常用的标准是由IEEE（Institute Electrical And Electronics Engineers）创建的。 IEEE是由一群关注于协议栈最下两层（物理层（Physical）和数据链接层（Data Link））的工程师构成的。协议栈的不同层由不同的机构负责，如IEFT关注传输层和因特网协议，WWW组织关注应用层。机构与其关注的协议如下图所示： 在1980年，IEEE组织了802项目局域网/城域网标准委员（Project 802 LAN/MAN Standards Commitee）会为网络设定标准。 IEEE 802 Model And Standards IEEE将数据链接层又在细分为了两层，逻辑链接控制层（Logical Link Control,LLC）(第15章中描述)和媒介访问控制层（Media Access Control,MAC）。 逻辑链接控制层设备的地址和在解复用中地址的使用。媒介访问控制层关注于多个计算机如何共享底层的媒介。 IEEE对于协议的命名是采用多部分标识符，如$XXX.YYY.ZZZ$，$XXX$表示协议的分类，$YYY$表示协议的子分类，$ZZZ$是当子分类也非常大是，额外添加的标识。 如局域网的规范在分类802中，这里的802并不是什么缩写或有实际的技术含义，仅仅是一个分类标识。IEEE不同的工作小组针对其细分的协议进行定义，如针对$802.1$或$802.2$。 IEEE中有许多不同的工作小组。当有新技术需要协议时，由工业代表和学术协会共同形成工作小组，他们会定期开会商定协议的细节等，当协议的所有细节都确定后，IEEE会发表协议的标准文件。 当协议最终发布后，工作小组可以选择解散或者如果协议非常重要或者仍需要后续工作，小组也可以继续活动。如果小组负责的部分协议不再有意义，如商业上不被接受，或者有更新更好的技术出现，小组也可以选择直接解散而不发表任何的规范。下图是802分类下的协议，有一些规范就已经被放弃（Disbanded）了。 LAN Topologies 因为有许多不同的LAN技术，通常使用拓扑型或者网络的基本形状来进行分类。LAN有四个基本的拓扑型，总线型结构（Bus），环状结构（Ring），星状结构（Star），网状结构（Mesh）。 Bus Topology 总线型结构（Bus Topology）是如同以太网一样，用一根电缆连接所有电脑，任何电脑都可以将数据传输到电缆上，然后所有的计算机都可以接受到数据。 Ring Topology 环状结构（Ring Topology）是多个电脑首尾相接的连接，直至成为环形。环形结构的优点是对于相连的两台设备来说连接是安全的，即使别的设备出现问题仍然可以连接。 Mesh Topology 网状结构（Mesh Topology）为任意两两配对的电脑都提供了连接线路，这意味着如果有$N$台电脑，就需要$\\frac{n^2-n}{2}$个连接。当增加电脑时，连接电缆的增加是平方级的，因此开销巨大，也因此网状结构在局域网中不常被使用 Star Topology 星状结构（Star Topology）是所有的电脑都连接在一个中心设备（Hub）上。注意星状结构并不严格要求中心设备真的在所有电脑的中心，与所有电脑的距离相同。 The Reason For Multiple Topologies 每个结构都有各自的优点，如环状结构很适合各电脑间协调访问，但当其中一个设备出现问题时，通路就会出现问题。星状结构下单一设备出现了问题，其他设备都可以正常访问。总线结构有最少的连接需求，但与环状结构与相同的缺点。网状结构因为连接数量过多，通常不在局域网中使用。 Packet Identification，Demultiplexing，Mac Addresses IEEE为寻址（Addressing）创建了标准。在分组交换中，解复用是依赖于一个称为地址（Address）的标识。每个电脑都分配了一个独特的地址，每个传输的包中都包含其目标收件人（Intended Recipent）的地址。 在IEEE的寻址规范中，每个地址是由48-bit二进制数据组成的，IEEE将其称为媒介访问控制地址（Media Access Control address,MAC address）。因为48位地址来源于以太网技术，所以也有人将其称为以太网地址（Ethernet Address）。 IEEE为每块网卡（Network Interface Card，NIC）都分配了地址，因此当消费者购买了一张网卡时，其中就包含一个独一无二的地址。 但IEEE并不是单独的为每个网卡分配地址，它是将前24位（3 Bytes）分配给设备供应商，然后设备供应商再决定后24位的数据。因此前24位称为组织唯一标识符（Organizationally Unique Identifier，OUI），后24位称为网络接口控制标识符（Network Interface Controller Specific）。 组织唯一标识符的最高有效字节（Most Significant Byte，即大端模式下即最左端）的倒数两位有特殊含义。其最低位表示是单播（0）还是双播（1）。倒数第二位决定该设备是全球唯一（0）（Globally Unique）还是是本地分配（1）（Locally Assigned），全球唯一表明地址是IEEE分配，即世界上的每块网卡都有不同的表示，而本地分配是实验性网卡或者某组织自己地址空间等，即这张卡是在一个小范围内内部使用。 Unicast，Broadcast，And Multicast Addresses IEEE定义了三种对应包传递的方法： 单播（Unicast）：目标地址是设定一个电脑，也仅这个电脑可收到包 广播（broadcast）：网络中的所有电脑都可收到包 多播（multicast）：目标地址是一系列的电脑，这些电脑都可以收到包。 对于广播来说，因为是所有电脑都收到包，所以目标地址实际是没有意义的。将地址的48位全部设为1，则表示是广播模式。广播模式也可看作是多播模式的一个特殊情况。 Broadcast,Multicast,And Efficient Multi-Point Delivery 广播和多播模式在局域网中特别有用，对于要传递给多台电脑的数据来说，用这两种方法进行传递特别的高效。 对于大多数的LAN技术，都是通过一个共享的媒介进行传输。当有数据在媒介中传输时，每台电脑都将从媒介中获取包的拷贝，然后再判断包中的地址情况是否与自己复合，来决定是处理包的内容还是丢弃包的内容。 因此局域网中的计算机在处理媒介中的包流程如下： 从包中抽取出地址信息 判断地址是否满足自己的单播地址，如果是则接受并处理包 如果2失败，判断地址是否是广播模式，如果是则接受并处理包 如果3失败，判断地址是否是多播模式，且电脑是多播模式指定的电脑组的一员，如果是则接受并处理包 如果4失败，则丢弃包 如在局域网情况下，如果多台电脑使用同一个媒介，且包需要传递给多态电脑，那么使用多播和广播模式，数据仅需要发送一次即可。 Frames And Framing 在同步通信系统中，帧的概念是让接收者知道数据的开始和结束。但在更宽泛的概念下，帧是表示一系列bit或byte的特定结构，让接收方和发送方都能一致同意的特定格式。 在分组交换中，帧的概念就对应包。在分组交换中，每个包都需要一个数据头，数据头（header）中包含目标地址。数据头后是有效负载（payload），即真正需要传输的原数据。在大部分的网络技术中，有效负载是不透明的即网络设备只能检查数据头。 在整个包的前后还能加入可选的前置数据（Prelude）或后置数据（Postlude）。因此整个包的结构如下所示： 举一个例子，如果一个包有6个byte的数据头，然后任意长度的有效负载，在包的前后各有1byte表示包的开始和结束。且开始和结束标识用ASCII码中的SOH（Start Of Header）和EOT（End Of Transmission）表示，则整个包如下所示： 上述例子有一点点数据的浪费，因为如果包是一个接一个发的，那么后一个包的SOH会紧跟着前一个包的EOT。在实际中，只需要一个来区分两个包即可。 虽然包的前置数据和后置数据是可选的，但在实际使用中，他们可以一定程度上提升异步传输数据的处理速度和对错误的检测。在异步传输中，如果接收方收到了EOT，它就知道数据包传输完成了，可以直接开始处理数据而不需要等到下一个包的到来再根据新包确定上个包是否完成。当发送端发送数据到一般崩溃时，因为接收端始终收不到EOT，也就能知道错误的发生。 Byte And Bit Stuffing 在ASCII码中，SOH用十六进制0x01表示，EOT用0x04表示。如果有效负载中也出现了0x01和0x04，接收端就无法判定到底是真实数据还是前置或后置标识。 一种称为字节填充（byte Stuffing）就是为了解决有效负载和特殊标记位有相同表示导致无法识别的问题。 该技术有时也称为数据填充（Data Stuffing）或字符填充（Character Stuffing）。该技术主要是 字节装填是用另一个字符来替代特殊标识的出现。 如我们选择用ASCII码中的ESC字符（Ox1B）来作为替换字符。在发送端当有效负载中出现SOH，那么就替换为&quot;ESC A&quot;，如果出现EOT,就替换为&quot;ESC B&quot;，如果出现了ESC就替换为&quot;ESC C&quot;。注意这个计算是针对有效负载的，当整个发送的有效负载中就不会与EOT和SOH相同的数据。对接收端而言，去找寻背后跟着&quot;A,B,C&quot;的ESC字符，然后将其替换回SOH和EOT的数据。发送端的替换过程如下所示： Computer Networks and Internets 6th Switching technology 【计算机网络】数据交换技术和多路复用技术的正（nao）确(can)打开方式","link":"/CNI-Chapter13-Notes/"},{"title":"《计算机网络与因特网》 第十一章笔记","text":"《计算机网络与因特网》 第十一章笔记 这一章主要是关于复用的概念。 Multiplexing And Demultiplexing（Channelization） Introduction 这一章介绍复用的概念，包括为什么要复用，复用的类型等。 The Comcept Of Multiplexing 复用(Multiplexing)是将多个信源的数据流合并在一起，并通过一个共享的媒介进行传输。复用器（Multiplexor）是用来进行复用的设备。解复用（Demultiplexing）是将合并后的数据流拆分还原成一个个信源的信息，解复用器（Demultiplexor）是用来进行解复用的设备。下图是复用与解复用的使用简图： 复用与解复用在日常的计算机网络使用中一直在进行，如多台电脑使用同一根网线等。 The Basic Types Of Multiplexing 在物理层，有四大类的复用方式： 频分复用（Frequency Division Multiplexing） 波分复用（Wavelength Division Multiplexing） 时分复用（Time Division Multiplexing） 码分复用（Code Division Multiplexing） 频分复用和波分复用使用比较广泛。波分复用可以看作是频分复用的一种特殊形式（波长与波的频率是相关的），波分复用用于光纤中。码分复用是没有使用物理特性，而是用数学原理，在一些电话系统中有运用。 Frequency Division Multiplexing（FDM） 频分复用（Frequency Division Multiplexing）是无线电广播的基础。在频分复用下，一个有大频率带宽的信道将拆分成许多小部分，每个信源都有一个自己单独的信道（占据一定频率的范围，相当于每个信源的载波频率都不同），每个信道间不会相互干扰，所有的信源都将使用一个共同的媒介进行传输。在频分复用下，每个信道都可以选择各自的方式进行调制。 频分复用最大的优点在于多个发送端和接收端都可以同时使用传输媒介。 为了避免在频分复用下，每个信源都有自己的信道，如果这些信道间的频率太过于接近则会产生干扰。为了避免干扰的的产生，信道之间需要由间隔（Gap），称为防护频带（Guard band）。 下图是频分复用的示意图，每个小块代表一个可供信源使用的单独信道，可以看到每个信道间都有一个小间隔作为防护频带。 Using A Range Of Frequency Per Channel 在上节的例子中，每个信道都有一个频率范围，但载波是固定频率的，信道之所欲选择一个频率范围而非单一的频率，主要是考虑便捷性，因为划分出的信道可能会以各种方式被使用。大多数频分复用系统都给发送端和接收端一个频率范围，系统可以选择最适用的频率作为载波，选择的评判标准通常是数据速率和对噪音的敏感性。 因为频分复用通常的频率较高，对噪声敏感，因此通常使用同轴电缆来作为传输媒介。 有的时候为了进一步增加数据速率，被分配给一个信源的信道会被再次的分割成更小的信道，如一个信源将分配给它的信道再分割成$K$个小信道，则每个小信道只要传输$1/k$的数据即可，这技术称为子信道（Subchannel）。 有的时候为了进一步增加对噪声的抵抗性，会使用称为展频(Spread Spectrum)的技术。这个方法同样将信源的信道再切割成$k$个小信道，但每个信道都传输一样的数据，接收端收到信息后，从这$k$个小信道中找寻错误最少的数据作为接收数据。 Hierarchical FDM 分层频分复用（Hierarchical FDM）是将频分复用后的总数据再作为一个频率更高的频分复用的输入进行再次复用。如下图所示： 虽然上图中每一级的单一信道带宽是上一级所有信道带宽的总和。但在实际运用中，下一级的单一信道带宽是要略大于上一级所有信道带宽的总和的，因为还需要携带额外的同步帧。 Wavelength Division Multiplexing（WDM） 波分复用（Wavelength Division Multiplexing，WDM）是在使用光纤作为媒介时的频分复用。当波分复用使用了许多不同频率的光时，可称为密集波分复用（Dense Wavelength Division Multiplexing）。 波分复用的原理可以参考物理上的三棱镜实验，即白光可以拆分为不同颜色的光，而光的颜色是由光的频率决定的。棱柱为波分复用与解复用提供了基础。波分复用的复用器是接受一系列不同波长的光，然后通过一个棱柱将它们合并成一束光，然后接收端的解复用器再次通过棱镜将它们还原成不同波长的光。示意图如下： Time Division Multiplexing（TDM） 时分复用（Time Division Multiplexing，TDM）的原理很简单，即每个信源使用共同的媒介一段时间，然后供下一个信源使用。示意图如下： Synchronous TDM 时分复用在计算机网络中是一个比较宽泛的概念。因此在实际运用中，上节中的概念图会在细节上有变化。例如有些时分复用系统并不是所有信源按顺序一个个发送。有些时分复用的系统中，每个信源发送间也并不像上图一样有时间间隔，一个信源发送后另一个信源会马上发送，这种系统称为同步时间复用系统（Synchronous TDM）。如下图所示： Framing Used In The Telephone System Version Of TDM 如之前所述，电话系统的两端是模拟信号，中间传输的是数字信号。对于中间使用同一个媒介传输的数字信号是通过同步时间复用系统来进行复用的。在电话系统中在时间复用系统中用了一个特殊技术来保证接收端和发送端的时间是对齐的，因为一旦接收端的时间出现了偏差，则可能将错误的信号传递给错误的目的地。为了解决这个问题，电话系统中的时间复用系统需要额外传输一个信道帧（Framing Channel）来表示一轮传输的开始，如下图所示： Hierarchical TDM 如同频分复用，时间复用也可以是分层的。不同的是，在频分复用系统中，每一级增加的是频率，在时分复用系统中每一级增加的是数据速率（减少时间切分间隔）。另外每一级的数据速率略大于前一级所有数据速率的总和，这是因为要传输额外帧数据。分层时间复用如下图： The Problem With Synchronous TDM: Unfilled Slots 同步时间复用对与每个信源都平均的提供时间，即将整个信道的容量（容量可看作一秒能传输的数据量）平分。但如果一个信源在某一段是空白数据，那么当轮到这个信源发送数据时，只能往信道内填空白数据（通常填0），且额外增加一位表示该数据是无效的，而不是正好全是0。这样会造成信道容量的浪费。如下图所示： Statistical TDM 为了解决同步TDM这个问题，有个称为统计时间复用（Statistical TDM），或称为异步时间复用（Asynchronous）的技术。这个技术仍然是所有信源轮询的传输数据，但是当信源没有数据时，并非像同步时间同步那样装填空白数据，而是直接跳过。如下图所示： 尽管这个方法解决了空白数据造成的信道容量浪费，但需要引入额外的数据来表明每个数据块是哪个信源的。 Inverse Multiplexing 逆复用（Inverse Multiplexing）技术是用类似于复用的思维方式，但解决是只有两个信源，但其中有多个传输媒介，且两信源有大量的数据需要传输，但中间媒介没有一个有足够的足够的比特率。逆复用技术就是将原数据拆分成多份，然后通过中间的低容量媒介进行传输，最后在接收端再将数据合并在一起。示意图如下图所示： 虽然逆复用看着很像复用的反向使用，即将复用的输出端变成输入，输入端变成输出，但在实际使用时，不能简单的将复用器反向设计得到逆复用器。逆复用器在发射端必须考虑如何将数据拆分后分配给多个低速率媒介。在接收端也必须考虑多个媒介的传输速率不同，可能造成某些媒介中的数据到达特别缓慢，这时候该如何处理。 Code Division Multiplexing 码分复用（Code Division Multiplexing）是在蜂窝电话（Cellular telephone）和卫星通信中使用的复用方法。与频分复用和时分复用不同的是，码分复用并不依赖与物理特性，而是利用数学特性：两个正交的线段可以被结合在一起而不会互相干扰。 每个信源都有一个不同的二进制码$C_i$，每个信源的二进制码都必须与其他信源的二进制码正交。即将这些二进制码看作是线段（1保持1，0看成-1），这些线段间必须两两垂直。每个信源都将原数据与二进制码叉乘，然后传输结果，复用的过程即是将所有的结果都累加在一起，在接收端每个信源的目的地再相应的将接受到的复用数据再次与对应信源的二进制码点乘，结果即为该信源应该收到的数据。 下面以一个例子方便理解。 假设有两个信源，两个信源的$C_i$分别是$(1,0)和(1,1)$，需要传输的数据分别是$(1,0,1,0)$和$(0,1,1,0)$。传输过程如下： 将原数据和二进制码改为向量，即1为1，0变-1。 信源1：$C_1=(1,-1)$，$V_1=(1,-1,1,-1)$ 信源2：$C_2=(1,1)$，$V_2=(-1,1,1,-1)$ 可以看到$C_1$和$C_2$是正交的。 复用过程即为: $$ (C_1 \\times V_1) + (C_2\\times V_2)= \\\\ ((1,-1),(-1,1),(1,-1),(-1,1))+((-1,-1),(1,1),(1,1),(-1,-1))\\\\ =((0,-2),(0,2),(2,0),(-2,0)) $$ ((0,-2),(0,2),(2,0),(-2,0))即为复用后的结果。 对于信源1的接收端而言，解复用过程为： $$(1,-1)\\cdot((0,-2),(0,2),(2,0),(-2,0))\\\\ =((0+2),(0-2),(2+0),(-2+0))\\\\ =(2,-2,2,-2) $$ 负数变为0，正数变为1，即接收端1收到数据为(1,-1,1,-1)，与信源1发送数据相同。 对于信源2的接收端来说，解复用过程如下： $$(1,1)\\cdot((0,-2),(0,2),(2,0),(-2,0))\\\\ =((0-2),(0+2),(2+0),(-2+0))\\\\ =(-2,2,2,-2) $$ 负数变为0，正数变为1，即接收端2收到数据为(-1,1,1,-1)，与信源2发送数据相同。 上述例子中，每个信源的二进制码$c_i$都比较小，但在实际运用中$c_i$可能会很大，这就导致了计算量的上升。如果数据本身并不多，但是花费了大量时间计算，效率比较低，因此在数据量不高的网络中CDM并不适用， 但是高数据量网络中，码分复用非常常见，因为相对于时间复用，码分复用的延迟较低。因为码分复用可以将多个信源的数据一次性同时发送给发送端，而时分复用则必须等待轮询到自己才能发送一部分。 Computer Networks and Internets 6th","link":"/CNI-Chapter11-Notes/"},{"title":"《计算机网络与因特网》 第五章笔记","text":"《计算机网络与因特网》 第五章笔记。 这一章简单定义了数据通信的概念，给出了数据通信的概念模型，并简单介绍了其中的一些关键领域的概念。 Chapter 5 Overview Of Data Communications Introduction 这一章主要是分析通过物理媒介进行信息传递的方法，例如线，光和无线电波等。这些方式在一些细节上不同，但所有方法的基本原理是相通的。 这一章同样会阐述一些在理论上可行，但在实际中因为现实世界的物理限制无法实现的方法。 The Essence Of Data Communications 数据通信是物理，数学和电气工程三个学科的混合领域。 物理：信息的传输依赖于物理媒介 数学：信息需要数字化 电气工程：数据传输需要构建现实中的通信系统 Motivation And Scope Of The Subject 在数据通信领域有三个重要的点，他们定义了数据通信的一些领域 传输的数据可以是任意类型的 传输的数据并不一定是存储在计算机中的bit数据，也可以是从现实世界中获取的信息，如音频和视频。 数据的传输依赖于物理系统 数据是基于物理现象来传输的，例如电，电磁波。了解为什么这些物理现象可以被用来传输数据是很重要的。另外也需要理解物理系统的限制，因为这些限制引发的问题和这些问题如何被检测并解决。 多个来源的信息可以共享基础媒介来传输 媒介共享在计算机网络中是一个重要角色。了解哪些基础设施是可以被共享的，共享他们的优缺点，以及基于共享而设计的通信模型是很重要的。 The Conceptual Pieces Of A Communications System 每一个来源都需要一些方法来获取信息，调整信息为用于传播的模式，使用共享的物理媒介来传输信息。同时也需要一些方法从物理媒介中抽取出每条信息的目的地地址，并将信息传送给目标地址。整个过程如下图所示： 上图是一个非常简化的模型，在实际操作中，在传输数据前，必须对数据进行数字化，也需要加入一些额外的信息防止错误发生。如果考虑到隐私，可能还需要进行加密。在使用共享媒介时，还要保证有方法可以分辨出每条信息且他们不会相互干扰。 为了解释数据通信的每个部分，工程师们制订了一个概念框架来说明通信系统中的每个小主题是如何联系在一起的，概念框架如下图所示： The Subtopics Of Data Communications 上一节中的概念框架图中的每一部分都代表了数据通信中的一个小主题。这一节中简单介绍了图中的一些术语，之后的几章中会在对每一部分进行详细说。 数据来源(Information Sources)可以是模拟数据或者数字电路。这一部分的关键内容包括信号的特征（振幅(Amplitude)，频率(Frequency)，相位(Phase)），周期性与非周期性，以及模拟信息和数字信息的转换。 信源编码与解码(Source Encoder and Decoder)。一旦信息被数字化后，信息就可以被转换，这一部分的关键内容包括数据压缩以及压缩后对于传输的影响 加密与解密(Encryptor and Decryptor)。为了保护信息和保证其可信度，在信息传送前需要进行加密，在接收后需要解密。这一部分的关键内容包括密码学技术与算法。 信道编码与解码(Channel Encoder and Decoder)。信道编码是用来检测也纠正传输错误。这一部分的关键内容包括检测和限制错误，以及实际应用的技术，如奇偶校验(parity checking)等。 复用与解复用(Multiplexor and Demultiplexor)。复用是指让多个来源的信息结合在一起并保证可以使用同一个媒介传输的方式。这一部分的关键内容包括介绍同时复用以及分时复用的技术。 调制与解调(Modulator and Demodulator)。调制是指让用电磁波传递信息的方式。这一部分的关键内容包括模拟信息与数字信息的调制方式，用来进行调制与解调的设备。 物理通道与传输(Physical Channel and Transmission)。 这一部分的关键内容包括传输媒介与传输方式（如并行，串行），带宽，噪声，干扰，信道容量， 引用： Computer Networks and Internets 6th","link":"/CNI-Chapter5-Notes/"},{"title":"《计算机网络与因特网》 第十四章笔记","text":"《计算机网络与因特网》 第十四章笔记。 Chapter 14 The IEEE MAC Sublayer 这一章原书中的Statiion一词，在笔记中翻译为终端。 Introduction 这一章将会深入讨论MAC层，包括多路访问协议（multi-access protocols）以及静态和动态信道分配。 A Taxonomy Of Manchanisms For Shared Access 实现多个计算机通过一个共享媒介来访问数据主要有三种方法： （1）复用技术（Multiplexing Technique） （2）分布算法来控制访问（Distributed Algorithms For Controlled Access） （3）随机访问策略（Random Access Strategy） 这里的复用技术与在11章中讨论的复用核心思想是相同的，但仍然有略微区别。11章中提到的是物理上的复用，通过复用器将信号合并在一起。这里的复用则是对于共享信道的逻辑划分，使不同的终端占用共享信道的部分资源，所以这里的复用技术也称为信道协议（Channelization Protocols）。 下图展示了按照共享媒介所使用的方法的分类： Static And Dynamic Channel Allocation 信道分配是与第11章中提到的复用技术相关联的。以频分复用为例子，在第11章中是每个终端都有它的载波频率，终端与载波频率是一对一的关系，这就是信道的静态分配（Static Channel Allocation）。 信道可以静态分配的前提是预先知道终端的存在，而且终端在传输过程中不会发生变化。而在许多的场景下，终端是会变化的，例如一个路由器负责房间内手机的信号，但是手机可以关闭或者离开房间，这就是终端的变化。 在这种情况下就需要信道的动态分配（Dynamic Channel Allocation），即当终端出现时才分配信道的资源给终端。 Channelization Protocols 与第11章中的复用技术相似，信道分配也存在频分多路复用（Frequency Division Multi-Access），时分多路复用（Time Division Multi—Access），码分多路复用（Code Division Multi-Access）三种类型。 FDMA 频分多路复用下每个终端都可以选择一个载波频率，这个频率并不会影响到其他的终端。在有些系统下存在一个中央控制器进而支持动态的频分多路复用：当一个新的终端出现，中央控制器用一个预留的信道与终端通信，然后分配一个未使用的载波频率给这个终端，之后终端都使用这个载波频率传输数据。 TDMA 时分多路复用下，所有终端按顺序编号，如$1,2,3,…N$，并且会按这个顺序占据信道进行传输。如同频分多路复用，在某些系统下支持动态分配，即终端出现时再分配给他信道的占用时间段。 CDMA 码分多路复用如同码分复用，通过数学方法将多个终端的数据合并在一起，再同时通过信道进行传输。 Controlled Access Protocols 访问控制协议（Controlled Access Protocols）为统计复用提供了方法，主要分为三个类型： 轮询（Polling）：控制中央持续的询问每一个终端是否要发送数据。 预留（Reservation）：终端需要发送信息时，发出一个在下一次循环时发送数据的申请。 令牌传递（Token Passing）：终端间循环传递一个令牌，当终端持有令牌时可以发送数据。 Polling 轮询（Polling）系统是存在一个中央控制器，这个控制器会询问其下的每个终端是否需要传递数据。轮询可以再细分为两种，轮询调度顺序（Round Robin Order）和优先顺序（Priority Order）。在轮询调度顺序下，每个终端都有相同的机会传递数据，而在优先顺序下，一些终端会有更多的机会去传递数据。 轮询的算法实现伪代码如下： 123456For Centralized Controller:while(true){ Select a station S, and send a polling message to S; Wait for S to respond by sending a packet or passing;} Reservation 预留（Reservation）系统多用在航天系统中，系统分为两个步骤，在第一步中需要传输数据的终端申请，所有申请的终端构成一张表，在第二步中表中的终端开始传输数据。通常第一步与第二步使用的是不同的信道，即有一个信道专门用来接受申请信息，另一个信道作为主信道传递每个终端的数据。 预留的算法实现伪代码如下： 123456For Centralized Controller:While(true){ Form a list of stations that have a packet to send; Allow stations on the list to tranmit;} Token Passing 令牌传递（Token Passing）被用在多个局域网（LAN）技术中，被用的最多的就是环形拓步结构中。在一个网络中，某一台计算机持有着一个特殊的控制命令，这个命令被称作为令牌，持有令牌的计算机可以发送数据，在发送完毕后将令牌传递给下一个计算机。 令牌传递的算法实现伪代码如下： 1234567For each computer:While(true){ Wait for the token to arrive; Transmit a packet if one is waiting to be send; Send the token to he next station;} 环形拓补结构中，存在物理的环形链接，所以令牌可以直接传递给相邻的下一个电脑。在其他的拓步结构中，所有的计算机都被赋予了一个逻辑顺序，因此可以获知下一个要收取令牌的电脑是哪个。 Random Access Protocols 许多网络，特别是局域网络中，并不使用访问控制协议，而使用随机访问协议（Random Access Protocols）。随机访问协议下只有当终端存在数据要发送时，才会被给予权限（在访问控制协议中，每个终端都要被持续检查）。这里的随机是在所有终端都有数据要发送时的处理方式。随机访问协议也可以被分为三类： ALOHA：早期夏威夷的无线电网络中被使用的协议。在教科书中比较流行，因为便于分析，但在实际网络中已不再使用。 CSMA/CD（Carrier Sense Multi-Access With Collision Detection）：原以太网的基础，现在也不再使用。 CSMA/CA（Carrier Sense Multi-Access With Collision Avoidance）：Wifi无线网络的基础。 ALOHA 在早期夏威夷的网络中使用，在这个系统下有一个强大的发送器被部署中在物理上的中心位置，其他的终端（通常对应一台计算机）在这个发送器周围部署，这些终端都没有足够的能量将数据直接传输给其他终端，因此需要通过中央的发送器。 中央发送器用两个载波频率与每个终端通信，一个被称为入站频率（In Frequency，407.305MHZ），一个被称为出站频率（Outbound Frequency，413.475MHZ）。终端通过入站频率将数据传递给中央发送器，中央发送器通过出站频率将数据发送给每个终端。 ALOHA的实现逻辑很直接：当终端有数据要发送时，使用入站频率将数据传递给中央数据站，中央数据站通过出站频率将数据传给所有的终端，终端检查数据是否是自己需要的。为了保证数据被正常发送，发送终端也需要监听出站频率，当发送的数据拷贝被传输回发送终端，发送终端确认数据被正常传递了，就会传输下一个数据。反之，则会在一段时间后尝试重新发送。 当两个终端同时使用各自的入站频率传输数据时，两个数据会发送混淆，进而导致信息错误，将这种情况称为信道冲突（Collision）。协议通过等待一段时间后重新发送数据来解决冲突，重新发送数据前的等待时间的设定尤为关键，如果两个终端等待的时间相同，那么再次发送数据时仍然是同时发送则会继续导致冲突。因此等待时间是随机的，但是网络繁忙时，冲突的概率仍然会增加，因为即使是随机时间仍然可能会与其他的终端发生冲突。 ALOHA示意图如下： CSMA/CD 1978年，数字设备联盟（Digital Equipment Corporation），英特尔（Intel）和施乐（Xerox）共同指定了个标准（DIX标准），也就是后来的以太网。最早的以太网技术使用一根长电缆连接每个电脑，这根长电缆就是共享媒介，与ALOHA使用中央发送器来实现数据传输不同，在以太网中每个终端都可以通过这个共享的线缆传输数据。以太网同样需要解决冲突问题，以太网主要引入了三个解决冲突的方法，统称为具有冲突检测功能的载波侦听多路访问（CSMA/CD，Carrier Sense Multi-Access With Collision Detection）： 载波侦听（Carrier Sense）： 在每个终端发送数据前，先监听线缆确定是否有其他的终端正在传输数据。 冲突检测（Collision Detection）： 虽然有载波侦听，但如果在线缆空闲时，两个需要发送数据的终端同时监听，此时他们都发现线缆空闲，因此都开始传输数据，这时候仍然会造成冲突。因此在传输过程中，发送终端也会持续的监听线缆，如果发现线缆中的数据与发送的数据不同，说明已经发生了冲突，数据被干扰了，于是停止数据的发送。 以太网的数据传输还有一些细节问题，如在检测到冲突时，发送端并不会立刻停止数据的发送，他仍然会传输数据一段时间，保证所有的其他终端都可以收到冲突信号。另外，当一个包被发送完后，发送终端需要等待一段时间，称为包间间隙（Interpacket gap）（在早期10Mbps的以太网中，包间间隙为9.6微秒），保证其他的终端可以检测到线缆的空闲并传递数据。 二进制指数补偿（Binary Exponential Backoff） 如ALOHA一样，在发现了冲突后，发送端需要等待一段时间重新发送数据，这个等待时间是随机的，通常会设置一个最大延迟时间$d$，然后在$0\\sim d$。如之前所述，在网络繁忙时，可能存在随机后终端仍然冲突的情况。二进制指数补偿是指在新一次冲突发生后，随机的范围变成$0\\sim 2d$，如果再有冲突则变成$0\\sim 4d$，依次类推。 CSMA/CD算法实现伪代码如下： 123456789101112131415For each Computer:Wait for a packet to be ready;Wait for the medium to be idle;Delay for the interpacket gap;Set x to be the standard backoff range d;Attempt to transmit the packet;While(Collision occured){ random a delay time q from 0 to x; delay for q microseconds; double x to be 2x attempt to retransmit the packet} CSMA/CA CSMA/CD并不能被运用在无线网络中，因为无线网络中的设备存在一个最远距离$\\delta$。即如果两个终端的距离大于$\\delta$，则CSMA/DA中的载波监听就无法被应用，因为一个终端并不能知道另一个是否在发送信息。这种情况如下图所示，如果Computer1在发送信息，Computer3是无法得知的，因此冲突只有Computer2可以知晓，这种情况称为隐藏终端问题(Hidden Station Problem)。 所以无线网络中使用具有冲突规避的载波侦听多路访问（CSMA/CA，Carrier Sense Multi-Access With Collision Avoidance）。以上图的例子，Computer3在发送数据前会先向所有它的$\\delta$范围内的设备发出一个短信息表明自己需要发送数据了，接受到Computer3发出的短信息的设备会检查自己是否正在接受其他的数据，如果不是则回复可以发送的信号。如下图所示： 如果发送端没有收到接收方的回执，则会在随机时间后再次尝试发送。 Computer Networks and Internets 6th","link":"/CNI-Chapter14-Notes/"},{"title":"《计算机网络与因特网》 第十六章笔记","text":"《计算机网络与因特网》 第十六章笔记 Chapter 16 Wireless Networking Technologies Introduction 这一章主要介绍计算机网络无线部分的技术。 $16.2$节对无线技术依据网络的覆盖范围做了分类。 $16.3$节介绍了个人局域网。 $16.4$节介绍了ISM频域。 $16.5\\sim16.11$都是介绍局域网相关技术，主要关注对象是Wifi技术。 $16.12$介绍了城域网中使用的WiMax技术。 $16.13$给出了个人局域网的标准分类列表。 $16.14$介绍了两个没有被包含在个人局域网中的短距离通信，红外线和射频识别通信。 $16.15\\sim16.18$介绍了广域网技术，主要关注蜂窝式网络。 $16.19和16.20$介绍了卫星通信。 $16.20$介绍了软件无线电系统。 A Taxonomy Of Wireless Networks 计算机网络无线技术的变种非常多的原因之一在于因为政府的管理，电磁信号的频谱被切分为了许多不同的部分以供不同的目的使用，而这些不同频域的技术通常都不同。 无线技术通常通过其使用的范围来分类，主要可分为：局域网（Local Area Networks,LANs），城域网（Metropolitan Area Networks,MANs），广域网（Wide Area Networks，WANs）以及个人局域网（ Personal Area Networks，PANs）。如下图所示： Personal Area Networks（PANs） 上节中对于无线网络的分类与在第十三章中对于网络的分类十分类似，不同的是这里还引入了个人局域网（Personal Area Networks，PANs）的概念。个人局域网是提供非常短距离下的通信，通常是只供一个用户使用，如蓝牙耳机就属于个人局域网的应用。 个人局域网络可以再细分为以下几种： 蓝牙（Bluetooth）：距离较短 红外线（Infrared）：视距通信（Line-Of-Sight Communication）即发射端和接收端之间需要无遮挡 紫峰（ZigBee）：距离可以支撑一个住宅的范围，在智能家居中被运用。 其他ISM无线技术：为工业，科学以及医药（Industrial，Scientific，Medical，ISM）预留的频率发展的技术。 ISM Wireless Bands Used By LANs And PANs 振幅为了工业，科学以及医药领域专门预留了一部分频域，被称为ISM无线。这部分的频域并没有再进一步细分，如科学只能用哪一段频域之类。这三个领域的产品都可以使用这部分频域，具体频域如下图所示： Wireless LAN Technologies And Wi-Fi IEEE将局域网下的无线网络协议分类在$802.11$下。1999年一些销售商建立了Wifi联盟，一个生产和验证使用802.11协议的无线设备的非盈利组织。因为这个联盟的产品在商业市场上反应很好，消费者将Wifi一词与无线局域网联系在了一起，Wifi原先是产品广告词中Wireless Fidelity的缩写。 下表为Wifi联盟所指定的协议： Spread Spectrum Technology 在第十一章中提到的展频技术（Spread Spectrum Technology）在wifi技术中也有应用。 展频技术的原理是发送端将原先的信道频域再细分为多个部分，将数据通过不同的频率发送出去，接收端接受多个频率的数据，再还原出原信号。使用展频技术主要目的有两个，一是增加传输速率，另外是增加对噪声的抗干扰能力。 Wifi技术主要用了以下扩频技术，其主要目的还是帮助Wifi在有噪声环境下能更好的工作： 直接扩频（Direct Sequence Spread Spectrum，DSSS）： 发送端使用一个序列码得到不同的频率，用这些频率来发送数据。 跳频扩频（Frequency Hopping Spread Spectrum，FHSS）： 载波的频率一直在设定的几个频率间切换。 正交频率复用（Orthogonal Frequency Division Multiplexing，OFDM）： 将原信道分为多个小信道，每个小信道传输一部分的数据。 书中并未对三个技术做详细的解释，上面的概括解释也可能存在错误。 三个技术都有各自的优点，OFDM有最高的适用性，DSSS性能好，FHSS对于噪声的抗干扰能力强。 Other Wireless LAN Standards 除了上述Wifi联盟所指定的协议，无线局域网还有其他许多的协议，都属于$802.11$协议分类下如下图所示： Wireless LAN Architecture 局域网无线网络结构主要有三个因素：（1）接入点（Access Point），有时也被称为基站（Base Station）。（2） 互联机制（Interconnection mechanism），例如路由器或者交换机，用来将接入点连接在一起。（3）一系列终端（Hosts），如个人手机就是一个终端。 存在两种无线局域网，一是自主网（Ad hoc），其中所有的终端都可以在没有接入点的情况下相互通信。另外一个是基础设施结构（Infrastructure）。 在实际运用中，自主网很少存在，基础设施结构如下图所示，图中的$AP$即为接入点（Access Point），一个接入点和连接它的一系列终端称为基本服务集（Basic Service Set，BSS）。 Overlap，Association，And 802.11 Frame Format 在实际运用中，基础设施结构中的接入点如果距离太远，会出现无服务区（Dead Zone），距离太仅的话，他们的覆盖的范围会出现重叠（Overlap），因此终端可能会同时存在于两个接入点的范围内。在这种情况下，终端需要指定他与哪个接入点进行通信，因此在$802.11$协议定义的网络帧格式下，帧数据必须包含其连接的接入点的MAC地址。 另外如果基础设施结构是要连接外网的，那么接入点的互联机制还需要另外一个有线连接至与外网连接的路由器，如下图所示，下图也同时展示了上述的接入点重叠情况 $802.11$的定义的数据帧，还需要指定连接外网的路由器的MAC地址，综上数据帧的结构如下： Coordination Among Access Points 如上节所述，在接入点重叠的情况下，终端需要决定与哪个接入点进行通信。 主要有两种方法来实现接入点的切换，第一个是靠接入点本身，接入点能相互通信，当接入点发现有终端同时收到多个接入点信号时，接入点会判断信号强度然后帮助终端无缝切换，这种方法实现较为复杂且成本较高。第二种方法下，所有接入点都是独立的，切换是靠终端本身实现，这种方法的成本较低。 Contention And Contention-Free Access $802.11$定义了两种信道访问的方式：无竞争（Contention-Free）的点协调方式（Point Coordinated Function，PCF）和存在竞争的分布协调方式（Distributed Coordinated Function，DCF）。 PCF方式保证在一个基本服务集中的接入点保证下面的终端不会发生任何干扰，例如通过给每一个终端一个特定的频率来实现。但在实际中PCF从来都没有被使用过。 DCF则是让一个基本服务集中的终端都使用随机访问协议（Random Access Protocols）。并如同在十四章中的介绍，因为$802.11$是无线网络，所以通常使用的是CSMA/CA，终端需要发送准备完毕（Ready to Send，RTS）和信道空闲（Clear To Send，CTS）两种控制命令。 $802.11$中使用的CSMA/CA还包含一些在十四章未提及的细节，如定义了以下三个时间参数： 短帧时间间隔（Short Inter-Frame Space,SIFS）为10微秒。 接收端在发送确认信息（Acknowledge，ACK）或其他控制命令前的等待时间。 帧间间隔（Distributed Inter-Frame Space）为50微秒。 在发送端发送数据前必须等待的时间，以保证其他的终端可以监听到信道的空闲。 时隙（Slot Time）为20微秒 Wifi网络中所使用的CSMA/CA如下图所示： 因为各终端间的物理间隔以及环境噪声，微弱信号的检测是很困难的，因此Wifi网络并没有引入CSMA/CA中的冲突检测（Collision Detection）部分，即发送端并不会在数据发送过程中监听信道来判断是否有冲突。在Wifi网络中，发送端会等待ACK信号，如果没有收到ACK信号，发送端则认为数据发送失败。 Wireless MAN Technology And WiMax 城域网技术的协议被反类在$802.16$中。如同在局域网中主要使用的是Wifi，在城域网中主要使用的事WiMax（World-wide Interoperability For Microwave Access）技术。 WiMax可以再被细分为固定WiMax和移动WiMax，前者是指服务提供方与连接者的位置是固定的，如大楼间的通信，后者则指接收方是可以移动的，如用户的手机和电脑等。 WiMax在城域网中的使用，如果是用在回传网络（服务提供方之间的连接，通常需要较高的数据速率）中则需要无阻碍（Line-Of-Sight，LOS）的连接，如果是在服务提供方与接入点直接的连接则也可以使用有阻碍的连接（Non-Line-Of-Sight，NLOS），如下图所示： PAN Technologies And Standards PAN技术被分类在$802.15$分类下，如下图所示： Other Short-Distantce Communication Technologies 还有两种技术短距离的通信方式并没有被分类在PANs下，红外通信（Infrared Data Association，IrDA）以及射频识别（Radio Frequency Identification，RFID）通信。 红外通信是方向性的，大约有30°的范围，而且信号可以在障碍物表面反射，但是并不能传统障碍物。电视遥控器即是使用了红外通信。 射频识别通信，是一个芯片中包含有验证信息的Tag，接收方可以将信息从芯片中读取出来。酒店的门禁卡，大学食堂的饭卡等都是使用了这个技术。 Wireless WAN Technologies 广域网通信有两大类，蜂窝式通信系统（Cellular communication systems）和卫星通信系统（Satellite communication system）。 蜂窝式通信系统最早是为了满足手机的电话服务设计的。在这个系统下，地区被风格为一个个小块称为巣室（Cell），每个巣室都包含一个基站塔，一系列基站塔由一个移动交换中心控制。这个中心会追踪用户，并在用户从一个巣室进入另一个巣室时，提供巣室的切换服务。蜂窝式系统的结构如下图： 理论上每个巣室都是六边形的，那么就能无缝的分割区域，但在实际运用中，每个基站塔的覆盖范围大致是圆形的，因此就会出现重叠或者无服务区。且基站塔的覆盖范围由所处区域的用户数量决定，如果用户数量很多，则每个基站塔的覆盖范围会较小，且有更多的基站塔，反之每个基站塔覆盖很大一块区域。理论和实际的巣室图如下，（a）图为理想情况，（b）图为实际情况： Micro Cells 如上节所述，用户密度越大，则设计时每个巣室的面积越小。在城市中，有时会出现一个巣室仅覆盖大楼的一层这种情况，这是称其为微巣室（Micro Cells）。因为巣室很小且很小块区域内有多个巣室，为了避免干扰，微巣室的功率都比较小。 Cell Clusters And Frequency Reuse 蜂窝式通信有一个重要原则：相邻的巣室在不使用相同频率的载波情况下，干扰最小。 蜂窝式系统使用称为巣室簇的结构构成，每个巣室簇都由特定数目的巣室构成，其中的每个巣室频率都不同。通常而言，巣室簇由3，4，7或12个巣室构成，如下图所示： 巣室簇中的每个巣室频率不同，将巣室簇拼接后就不会有相邻巣室频率相同的情况出现，如下图为7巣室簇拼接： Generations Of Cellular Technologies 目前通信技术的发展有四代，称为1G,2G,3G和4G： 1G：出现在1970年代后期，通过模拟信号传递语音信息。 2G和2.5G：从1990年代早期开始发展，至今仍然在使用。与1G的主要区别在于，2G使用了数字信号传递语音信息。2.5G是2G的扩展，实现了部分3G的特性。 3G和2.5G：从2000年开始发展，主要关注高速数据服务。3G系统提供400Kbps到2Mbps的数据速度。 4G：从大约2008年开始使用，主要关注实时媒体的使用，如电视直播，高速视频下载等。4G手机通常包含多种数据连接方式，如Wifi和卫星通信。 在2G技术发展过程中，许多组织都尝试定义标准，欧洲主要使用TDMA技术并制订了GSM标准（Global System For Mobile Communication），该标准逐渐称为了全球标准。在美国，摩托罗拉使用TDMA技术定义了iDEM标准。同时大部分其他的美国运营商和亚洲运营商都使用了CDMA技术来指定标准。 在3G时代，EVDO（Evolution Data Optimized/Evolution Data Only）和EVDV标准几乎同时出现，两者都是CDMA和FDM技术的混合。EVDO技术被运用的较为广泛。 在设计4G标准时，国际通信协会（ITU）指定了4G蜂窝式系统的标准，称为IMT-Advanced（International Mobile Telecommunication Advaced）。其指定终端在高速移动时（如在火车上）应该有100Mbps的数据速率，而在静止时应该有100Mbps的速率。 在早期，运营商指定的4G标准，如HSPA+，HTC Evo 4G，WiMax和LTE（Long Term Evolution）都未满足要求。但是ITU还是允许了他们使用4G作为自己的广告语，在后期，LTE-Advanced和WiMax Advanced满足了ITU的标准，被称为真4G。 3G和4G的主要区别在于，3G系统设计时仍然是基于语音通话系统考虑的，还是继承自原先的模拟电话系统，其他的数据是作为额外的要求。而在4G标准设计时主要考虑因特网协议，因此4G系统使用了帧交换而语音只是作为一个特殊应用。在实际应用中，许多蜂窝系统仍然通过3G来传输通话信息，而在其他数据时使用4G。 VSAT Satellite Technology 卫星通信的关键是用一个曲面天线（Parabolic antenna/Dish）保证电磁信号被反射到一个单一点上，如下图所示： 为了最大化收集到的信号，早期的卫星通信系统使用直径大于3米的曲面天线，但这种尺寸的天线并不适用于个人或小商家。于是称为甚小口径天线终端（Very Small Aperture Terminal，VSAT）的技术出现，它指代直径小于3米的曲面天线，通常直径在1米以下。 VSAT卫星通信选择的频率不同会影响信号强度，天气环境变化的敏感程度，和信号的覆盖范围（Satellite’s footprint）。如下表所示： GPS Satellites GPS（Global Positioning System）卫星提供实时的准确位置信息。GPS通信并非是计算机通信的一部分，但是越来越多的移动网络使用了位置信息。 GPS系统通过三颗卫星计算出终端的位置。首先要计算终端距离三颗卫星的距离，距离可以通过卫星与终端的传输时间乘上光速来确定。如果一个终端与卫星的距离为$d$，则终端出现在以卫星为球星，半径为$d$的球上任意位置。通过三个卫星，可以计算出三个球，三个球的交点为两个点（两个球的交点为一个圆形）。这两个交点，一个在太空中，一个在地球上，地球上的点即为终端的位置。 Software Defined Radio And The Future Of Wireless 通常一个蜂窝网络手机需要指定天线，发射器和接收器的规格，这些数据都是需要预先指定的。如果同时支持GSM，Wifi和CDMA，则需要三套独立的无线电系统，使用时在其中切换。 现在传统的无线电系统被软件无线电取代，可以通过软件来指定的特性如下表所示： 软件无线电的一大特性是可以同时使用多个天线，称实现了多天线同时传输和接受的系统为MIMO（Multiple-Input Multiple-Output）系统。 通过软件来设定通信特性也有一定的危险性，如用户可以选择被政府限制的频率来发送数据或者占据为紧急服务预留的频道。因此这个技术也需要严格规范。 Computer Networks and Internets 6th","link":"/CNI-Chapter16-Notes/"},{"title":"《计算机网络与因特网》 第一章笔记","text":"《计算机网络与因特网》 第一章笔记 笼统的介绍了网络的五个关键领域，一些网络基本概念，TCP/IP分组模型，OSI模型等。 Chapter1 Introduction And Overview Growth Of Computer Networking 计算机网络正在持续的爆炸性成长。在1970年代它只是一个非常小范围的研究课题，在1980年也只有几个网站，但到现在计算机网络已经成为了生活中的一部分。 Why Networking Seems Complex 计算机网络是一个高速发展的领域。 对于初学者而言，他可能让人觉得很困惑，因为并没有一个最基础的理论来将计算机网络的所有部分联系在一起。有许多组织都定义了计算机网络的标准，而有时这些标准相互之间并不兼容。 计算机网络用语也并没有一个统一的标准，许多组织都定义过自己一套用语规范，这又很容易让初学者们感到困惑。 The Five Key ASpects of Networking 计算机网络包括五个关键领域： 网络应用与网络编程 数据通信 分组交换与网络技术 TCP/IP的网络互联 附加的网络概念和技术 Network Applications and network programming 用户使用网络服务和设施是基于一个安装在电脑上的应用程序，这个程序可以与其他电脑上的程序通过网络进行交流。网络程序有很多种类，包括邮件，下载器，游览器等。 所有这些程序都是构建在一个单一的、共享的网络上，因此开发者可以使用同一套接口来进行开发。 计算机网络的只是可以帮助开发者更好的开发网络应用。 Data Communications 数据通信是电子工程的主要领域，它基于一些物理现象来传输数据，是一个较底层的方法。 因为数据通信是基于物理概念，所以乍看起来它与计算机网络的学习并没有太深的关系，但数据通信中的一些关键概念影响了通信规范的制定。例如调制中带宽的概念直接影响了网络的吞吐量。 数据通信也引入了复用的概念，即多个来源的数据可以被组合在一起通过一个共享的媒介进行传输，然后再分开传递给不同的目的地。 数据通信包含了许多底层的细节，他为计算机网络构建了基础。 Packet Switching And Networking Technologies 通信网络已经从早期的依赖于物理点线进行的点对点电报或电话系统转换为一个通信电路。早期的通过线连接已经转换为通过电交换。 分组交换（Packet switching）从最底层的方式改变了网络，是现代网络的基础。多个信息发送者不再需要依赖于专用网络，通过分组交换他们可以通过一个共享的网络来传输数据。 分组交换将数据分为许多小块，称为包Packets，包中都包含一个目的地的信息。网络中的设备都包含了如何抵达其他地址的信息，当设备接收到一个包后他会解析包中的数据，并选择一个通路将其送给正确的目的地。 因为计算机网络在设计时有许多不同的需求，例如速度，距离，经济成本等，有许多分组交换技术被发明出来，他们针对不同的需求在细节上存在着一些差异。 Internetworking with TCP/IP 在一段时间内，许多研究者都致力于找到一个可以满足所有需求的分组交换技术。在1973年，Vinton Cerf 和 Pobert Kahn认为不存在一种分组交换技术可以满足所有的需求，因此他们致力于将不同的技术融合在一起。他们发展了一系列的标准，并最终成为了TCP/IP协议族(TCP/IP Internet Protocol)(简称为TCP/IP)。这最终成为了全球网络的基础，并称为计算机网络的一个重要组成部分。 TCP/IP标准成功的一个重要原因是它宽容的异质性。TCP/IP使用了一个虚拟的方法来定义网络不相关的包好网络不相关的检测方法。因此即使分组技术在持续的发展，因为TCP/IP始终可以与新的分组技术共存。 Additional Networking Concepts And Technologies 除了构造网络的硬件和协议，还有大量的其他技术为网络提供了不同偶给你能。 例如软件定义网络(Software Defined Networking(SDN))允许管理者定义和控制网络，物联网(Internet to Thing)让嵌入式系统可以通过网络进行交流。 Public and Private Parts Of The Internet 计算机网络是由公共网络(Public network)和私人网络(Private network)构成的。 Public Network 公共网络是服务提供商(Service Provider)所拥有的服务，服务商会将服务提供给任何订阅了的个人或组织。这里的公共指的是大众都可以订阅这个服务，并不意味着公共网络传输的数据是被暴露在外，所有人都可以获取的。 Private Network 私人网络是指网络的使用权被限制在一个组间。如果服务商将服务租赁给了个人或公司，个人或公司仅在自己的范围内使用这个网络，那么它就是私人网络。 私人网络按其大小可以被分类为以下四种： 消费者(Consumer) 小型办公室/家庭办公室(Small Office/Home Office,SOHO) 中小型商用(small-medium Business，SMB) 大型企业(Large enterprise) Networks,Interoperability,And Standards 通信至少包含两个实体，信息发送者和信息接受者。为了保证网络中的所有实体都能正确的交流，需要有一个共同的标准。 使用互操作性(Interoperability)来表示两个实体是否可以无误的彼此通信。 为了保证实体可以正确的彼此交流，他们需要遵守一系列共同的规则，这些规则被称为通信协议(Communication protocol/Network protocol/Protocol)。 在通信发生错误的时候需要采取的行动也是由通信协议来指定。 通信协议可以是底层的，例如电压或信号的制定，也可以高层的，如软件传输的数据类型。 Protocol Suites And Layering Models 为了避免重复工作，每个协议应该只负责其他协议未包含的部分，因此协议的制定并非是相互独立的。将一系列合作的协议称为族(Suites/Families)。族中的每个协议都只关注通信中的一部分，族中的所有协议组合起来就覆盖了整个通信的所有方面。 一个用来将协议分组的基本抽象是分组模型(Layering model)，分组模型将所有通信问题分为几个部分，每个部分称为一层(Layer)。将所有协议按层分组帮助协议的设计者和实现者有效的控制了问题的复杂度，因为他们只需要关注与网络的一个方面即可。 下图展示了因特网的分组模型，也成为TCP/IP分组模型： Layer 1:Physical 物理层的协议指定了传输媒介和相关硬件的细节。电子相关的属性，频率，信号等都属于物理层。 Layer 2: Network Interface(MAC) 网络接口层的协议指定了对网络通信的细节以及网络硬件与Layer3（Internet层）的通信细节。硬件地址，网络地址，网络可支持的最大包数据以及传输媒介的协议等信息都属于网络接口层。 TCP/IP的设计者将这一层命名为网络接口层（Network Interface），但一些协会更喜欢称为数据链路层（Data Link），工业界又喜欢称为媒介访问控制层（Media Access Control,MAC） Layer 3：Internet 因特网层是因特网的基础。因特网地址结构，因特网包的结构，大包拆分成小包的方式，报告错误的方式都属于因特网层。 Layer 4：Transport 传输层协议提供了计算机上的一个应用与另一台机器上的应用交流的方法。如接收端接收数据的最大速率，避免网络堵塞的方法，和保证接收端按顺序接收数据的技术都属于传输层。 Layer 5: Application 应用层的协议指定了通过网络交流的应用传输的数据信息的格式和意义，以及需要执行的步骤。如邮件，文件传输，语音电话等的实现都属于应用层。 How Data passes Through Layers 分组模型并不只是为了帮助理解协议，协议的实现满足某一层协议的输出需要匹配相邻层协议的输入。 如下图展示了两台电脑通过网络传输数据的过程： 一号电脑是数据的发送方，二号电脑是数据的接收方。数据从一号电脑的应用层逐渐向下传递，通过接口层进入网络，在进入网络并传输后，通过二号电脑的接口层传入，再向上逐渐传递到应用层。 Headers And Layers 每一层的协议为了保证数据被正确的传递都进行了一些计算。在发送端的每一层中都将一些额外的信息加到了数据包中，对应的，在接受段的每一层中都将解析并移除这些额外的信息。 这些被协议额外加入的数据称为数据头(header)。以发送端为例，数据头是在数据逐层向下的过程中一步步被加入的，即传输层增加一些数据头，网络层增加一些数据头，接口层增加一些数据头。因此最终的数据会如下图所示，最靠近原始数据的数据头是最早被添加的： 虽然图中每个被添加的数据头大小看起来相同，但实际上都不是一个固定的大小。 ISO And The OSI Seven Layer Reference Model 在因特网模型发展的过程中，有两个组织定义了一个替代的参考模型，称为开放式系统互联参考七层模型(Open Systems Interconnection Seven-Layer Reference Model)，简称为OSI模型。 这两个组织分别是国际标准化组织（International Organization for Standardization），简称为ISO和国际电信联盟（International Telecommunications Union）(ITU)中的电信标准部门。 OSI协议图如下： TCP/IP协议比OSI协议更为高效合理，发展和部署OSI协议的工作已经被停滞。许多工作者目前在扩展OSI协议的定义来让其符合TCP/IP，基本是让Network层匹配Internet层，然后再在Session层和Presentation层增加一些支持协议。 虽然许多工程师和商业部门知道OSI协议不如TCP/IP协议高效，但他们依然处于某些原因在坚持使用。 Remainder Of The Text 书的剩下部分将分为五个部分，基本对应与1.3节中提到的五个重要领域。 第一部分介绍网络应用和网络编程 第二部分介绍数据通信和信息传输 第三部分介绍分组交换以及包数据，另外也会介绍一些网络的基本分类，如局域网和广域网 第四部分将介绍TCP/IP协议族 第五部分介绍剩下的一些网络相关的技术 引用： Computer Networks and Internets 6th","link":"/CNI-Chapter1-Notes/"},{"title":"《计算机网络与因特网》 第十七章笔记","text":"《计算机网络与因特网》 第十七章笔记 Chapter 17 Introduction 这一章会介绍关于扩展LAN的方法，如中继器（Repeaters）和网桥（Bridges），也会介绍在网桥存在循环时解决死循环的生成树算法(Spannning tree algorithms)。最后会讨论交换机和网桥之间的关系。 Distance Limitation And LAN Design 距离限制是LAN计算的核心，工程师们需要从最大延迟，信道容量和传输距离间做权衡。因为LAN中的硬件设备的发送功率是固定的，所以如果两个设备之间的电缆长度增加，其中的信号强度就会减弱，导致错误的发生。 Fiber Modem Extensions 解决LAN距离的方法通常不是增加信号的强度也不是增加电缆，而是增加额外的硬件设备来转播信号。 最简单的LAN扩展方法是通过一根光纤和一堆光纤调制解调器，如下图所示： 一个光纤调制解调器与计算机设备连接，另一个光纤调制解调器与通向以太网的交换机或集线器连接，两个光纤调制解调器用光纤连接。这样计算机设备就能与以太网进行连接。 Repeaters 中继器（Repeaters）是一个用来传播LAN信号的模拟设备，中继器并不理解包和Bit数据，它只是将接受到的信号放大再传播出去。 一个中继器的典型应用就是使用遥控器控制其他房间的设备，将中继器放置在另一个房间，在遥控器所在房间，将Sensor通过线缆与中继器相连。当本房间的Sensor搜到信号后，信号后传输给中继器，中继器放大后传播出去，另一个房间的设备就会收到，如下图所示： Bridges And Bridging 网桥（Bridges）是连接两组LAN设备（如两个集线器）并且在它们之间传输包的方法。网桥是以混杂模式监听每组LAN设备，即数据发送给其下的任意一个设备，该数据都会被网桥检测到。因此，被网桥连接的两组设备表现如同是一组设备，即一组中的设备可以发送数据给另一组设备，且当一个设备广播时，两组设备中的所有设备都能接受到。而在网桥下的设备是无法区分自己是在一个单一的一组设备下（如只是在集线器下）还是在网桥下。 这里将书中描述的Segment翻译为一组设备，如一个集线器下的设备。 网桥连接的示意图如下： Learning Bridges And Frame Filtering 虽然网桥是以混杂模式监听，且可以让两组设备表现的如同在同一组，但是网桥并不会盲目的将数据从一组设备传递给另一组。网桥监听到数据后会针对包的目标MAC地址过滤数据，仅将数据发送给需要的一组设备。当让，在广播或者多播模式下，网桥直接将数据发送给两个设备的，以保证广播或者多播的正常运行。 大多数网桥被称为自适应网桥（Adaptive/Learning Bridges），因为他们可以自动识别出每个设备是处于哪个分组下。当一个数据包经过网桥时，网桥会读取源地址，然后判断两组设备列表中是否有该发送设备，如果没有，则将发送设备放在符合的设备列表下。同时也会读取目标地址，决定数据需要发送给哪部分设备，如果目标地址在两组设备列表中都不存在，则两组设备都会收到网桥的转发的数据。 下表是发送网桥发送数据的例子。在第一行即网桥启动时，两组数据的列表都是空的。第二行即数据从A设备发送给B设备，此时先检测出将发送端A是在Segment1中，但此时B不在任何列表中，所以数据会发送给两个部分。第三行即数据从B设备发送给A设备，先检测出发送端B设备是再Segment1中，而A也在Segment1种，所以数据只要在Segment1中传输即可。同理可以分析其他的发送数据。 Why Bridging Works Well 当网桥知道其下的所有设备处于哪个部分后，数据在网桥之间的传输效率要大于数据在真正的单一分组中的传输。 以上节中的示意图为例，当网桥知道所有的设备处于哪个部分后，如果数据从A发送给B，那么数据只要在Segment1中传输，同理如果数据从X发送给Y，数据只要在Segment2中传输。因此，这两个传输行为是可以同时进行的，因为它们都只是发生在各自的部分中。而如果所有设备都是在一个真正的单一分组下，即A，B，X，Y是共享一个媒介传输，两个传输行为也就不可能同时发生。 因此可以将设备分组后，用网桥连接来增加数据传输的效率。 Distributed Spanning Tree 如果一系列设备如下图所示连接（每个HUb下有多个设备，图中未展现）： 可以看到图中的设备形成了一个循环，在这种情况下广播的数据会发生死循环。因为网桥收到广播数据后会直接向前传递，而在网桥形成循环后，每个网桥的直接向前传递就会导致信息始终在循环中传输。 为了解决这个问题，电子设备协会（Digital Equipment Corporation）在1985年为以太网设计了一个称为生成树协议（Spannning Tree Protocol,STP）的方法。STP方法是通过算法从一系列网桥STP计算出一个分布生成树（Distributed Spanning Tree）。协议规定如果将包的广播地址设为01:80:C2:00:00:00即表示使用STP方法。STP方法的步骤如下： 先找到一个网桥作为根。 每个网桥都有一个ID地址，算法将ID最小的网桥作为根。 每个网桥的ID地址都由两部分组成，第一部分是16bit长的可配置优先级数字，第二部分是48bits长的MAC地址。当比较ID地址时，会首先判断第一部分，在第一部分相同的情况下判断第二部分。因为第一部分是可配置的，所以管理员是可以指定某一个网桥作为根的。 最短路径计算 每个网桥都计算自己与根网桥的最短路径。 传递数据 网桥之间的数据传递，只能由最短路径传输。 在上图展示的循环中，如果Hub1广播数据，那么Hub4收到数据的通路就是$Hub1-&gt;Hub4$，而更长的路径，如$Hub1-&gt;Hub2-&gt;Hub3-&gt;Hub4$就会被禁止，因此更长的循环路径也同样会被禁止。 Switching And Layer 2 switchers 桥接（bridging）的概念可以帮助理解现代以太网的基础：交换（switching）。一个以太网交换机（Ethernet switch）有时也被称为二层交换机（Layer-2 switch）。交换机如同集线器一样，有多个接口，每个接口都与一个计算机相连。交换机和集线器的不同在于，集线器如模拟设备一样，是将电脑传输的信号传递出去，而交换机是数字设备，传递的是电脑的数据包。可以将集线器想象成一个共享媒介，而把交换器想象成一个由网桥连接的网络，其中每个部分都只有一台电脑。 交换机可以想象成如下图的结构，可以看到交换机的左侧是三个网桥，每个网桥连接两个设备： 但上图只是一个概念图，实际中的交换机中并没有网桥，而是每个端口都于一个智能接口（Intelligent Interface）相连，然后有个中央光纤将所有的接口连接在一起，而且这光纤支持两两配对的接口间的同时传输（如之前提到的网桥连接的两部分间的设备可同时传输一样）。 每个智能接口都有处理器和内存，因此可以判断需要传递的路线以及在目标端口繁忙时缓存数据，如电脑1和电脑2同时要向电脑3传输数据，则电脑1或电脑2中的一台会先将要传输的数据缓存起来。实际的交换机结构如下： 交换机相对于集线器最大的优点在于并行。集线器在同一时间只能支持一个传输，而交换机可以同时进行多个独立的传输（这里的独立指不会有多个来自于不同地址的数据要发送给同一端口）。因此如果一个交换机有$N$个端口，最多可以有$N/2$个传输同时进行。 VLAN Switchers 当一个交换机被扩展了虚拟功能，即称为虚拟局域网交换机（Virtual Local Area Network Switch,VLAN Switcher）。虚拟局域网交换机的功能就是让单一的交换机模拟成是多个独立的交换机，即管理者可以将一台交换机的其中某几个端口定义是在一个模拟局域网中，而另几个端口是在另外一个模拟局域网中，这样的话其中一个模拟局域网中的设备发送广播数据，另一个模拟局域网中的端口并不会接受到信息。 这种通过VLAN切分广播域的做法在公司环境下很关键，如一层楼只有一个交换机，但广播数据的发送并不希望整层楼都能收到。 Multiple Switchers And Shared VLANs 交换机通常被部署在离计算机较近的地方，如每层楼都有一个交换机。在公司环境下有种情况是同一个部门可能处于不同的楼层，那么同一个部门的网络在不同的交换机下。在有多个交换机的情况下，上节中提到的VLAN会遇到问题。当只有一个交换机时，根据端口号分好VLAN后，数据的传输指定端口号就能判断出数据应该处于哪个VLAN中。但如果有两台交换机，两台交换机的同一端口，如端口1，可能是在不同的VLAN下，因此光指定端口号是无法知道其到底在哪个VLAN。 为了在多个交换机中使用VLAN技术，IEEE扩展了以太网协议，记录在$802.1Q$中。该协议下，在以太网的数据包的头字段中，增加16bit长的数据表示VLAN Tag，表示需要传递给VLAN。在802.1Q协议下的以太网数据包如下图所示： 即使是使用了多交换机的VLAN，$802.1Q$协议下的以太网数据包仅在交换机之间传输，而在交换机与电脑间传输的包仍然是普通以太网数据包，因为只有交换机才能解析$802.1Q$数据。使用$802.1Q$实现VLAN的交换机如下图所示 以上图为例，如果图中的A，B，D，E共处于VLAN 17中，当A广播数据后，B会直接收到数据，然后交换机1会将$17$作为VLAN Tag插入到数据包头中，然后传递给交换机2，交换机2在收到数据后，取出其中的VLAN tag，并将包传递给D和E。 The importance Of Bridging 虽然现在很少会有厂商生产单独的网桥，但是桥接的概念已经被整合入网络设备中。如无线网络的路由器就整合了提供桥接功能的以太网的交换器，通常将其中交换机的端口称为本地端口（Local Port），将连接网络调制解调器的端口称为因特网端口（Internet Port）。当两个本地的电脑传输数据时，无线路由器并不会将数据发送给网络服务商，而是直接将数据在本地进行传输（类似于桥接的分组功能）。 引用： Computer Networks and Internets 6th","link":"/CNI-Chapter17-Notes/"},{"title":"《计算机网络与因特网》 第六章笔记","text":"《计算机网络与因特网》 第六章笔记。关于信源和信号的知识，包括信源的特征，模拟信号和数字信号的转换等 Chapter 6 Information Sources And Signals Introduction 这一章讲解释信源（Information Sources）和携带信息的信号的特征。 Information Sources 数据通信理论更关注于较低层次的通信系统，因此信源可以是任意来源，不仅仅是包括计算机上层的键盘，鼠标，摄像机，传感器等等也是信源。 Analog And Digital Signals 数据通信由两种信息组成，模拟信息或数字信息。模拟信号是由一个连续变化的函数构成，而数字信号则是跳跃变换的，在某个时间点会从一个强度突然跳跃至另一个强度。下图为模拟信号和数字信号的图解，左为模拟信号，右为数字信号： Periodic And APeriodic Signals 信号也可分类为周期信号与非周期信号。周期信号顾名思义表示信号会重复出现，反之为非周期信号。下图为周期信号： Sine Waves And Signal Characteristics 数据通信通常使用Sin函数来表示信号。之所以选择Sin函数，是因为许多自然界产生的信号强度与时间的函数都是Sin，如麦克风获取声音后的输出信号，电磁波的信号等。 Sin函数波的信号特性由四个部分组成： 频率（Frequency）：单位时间（通常是秒）内震动出现的个数。单位为赫兹（Hertz,Hz） 波幅（Amplitude）：信号最强和最弱两处的差 相位（Phase）：Sin拨开始的地方与参考时间（一般是时间0）的偏移 波长（Wavelength）：一个周期的波在传播媒介中要传播的距离。 其中波长是一个媒介相关的特性，与波在媒介中传播的速度相关。剩下的三个特性都可以用数学公式表示，如波$A\\sin (\\omega t+\\phi)$，其中$A$表示波幅，$\\phi$表示相位，$\\omega$表示频率，当$\\omega=2\\pi$时表示频率为1。 数据通信用的波一般都是高频的，一秒内出现百万个循环，对于这种频率的波，通常用兆赫兹（Megahertz,MHz）来表示。高频率波的单位如下表显示： Composite Signals 之前图中的波称为简单信号(Simple Signal)，因为只是以单一的Sin波组成。但在实际中，多数信号都是以组合信号（Composite Signal）的形式出现。如下图所示，就是两个不同频率及振幅的波组合成一个新的波。 The Importance of Composite Signals And Sine Functions 调制（Modulation）出来的信号通常是组合信号。数学家傅里叶(Fourier)发现可以从组合信号中解析出他的组成部分，即简单信号。大部分的通信系统都是用组合信号来携带信息，在接收端再将信息拆分成简单信号。 Time And Frequency Domain Representations 之前的所有信号波的图片的$X轴$都是时间，称为信号在时域(Time Domain)内表示。 还有一种表现方式是信号在频域(Frequency Domain)内的表示，如之前$\\sin (2\\pi t)$和$0.5\\times \\sin(2\\pi 2 t)$组成的复合信号，也用下图在频域中表示： 图中的$x轴$为频率，$y$轴仍为波幅。可以看到在频率为$1$和$2$的地方有波形出现，正好对应函数$\\sin (2\\pi t)$和$0.5\\times \\sin(2\\pi 2 t)$的频率，波形的振幅也与函数所表现的振幅相同。 因为每个简单波在频域图的$x$轴上只占据一点，所以频域图用来表示复合波形是简单易读的。 Bandwidth Of An Analog Signal 在计算机网络中经常听到网络带宽(Network Bandwidth)一词，关于网络带宽会在之后的章节中解释，这里先介绍一个相关概念，模拟带宽(Analog Bandwidth)。一个模拟信号的带宽是这个信号最高频率与最低频率之间的差，单位为$Hz$。如一个信号的频域图如下图所示，那么这个信号的贷款为$4KHz$，因为这个信号的最高频率为$5KHz$，最低频率为$1KHz$。 如果一个信号是用频域图来表示的，那么可以很快的看出这个信号的带宽。 Digital Signals And Signal Levels 数字信号是由一系列的固定的有效电平（Valid Level）组成且在任意的时间点信号都处于这些有效电平之一。 一些系统用电压来表示数字信号，如电压为$5V$表示信号1，电压为$0V$表示信号0，如下图所示： 如果将电压划分更细，如电压$5V$表示信号$11$，电压$2V$表示$10$，电压$-2V$表示$01$，电压$-5V$表示$00$，如下图所示： 可以看到传输相同数据(8 bit)的情况下，第二种方法花费的时间少了一半，称第二种方法的数据速率（Data Rate）翻倍。因为第一种方法一次只能表示1bit的数据（1或0），而第二种方法表示了2bit的数据。如果电压细分为$2^n$种，则一次性能表达$n$ bit的数据。 理论上可以将电压切分到非常小（如分割成一百万个电平等级）达到每次都能传递许多信息的目的，但是实际中因为电力系统并不能区分过小的电压间隔，所以只将电压分割为几个电平等级。 Baud And Bits Per Second 数据速率有两方面决定，一方面是上一节中提到的信号有效电平数量（决定每次可以携带多少数据），另一方面是每个有效电平持续的时间。 如上一节中的例子，假设将1秒切分为8部分（即一秒电平可以变换8次）传递数据，一共有2个电平等级。那么一秒传递8 bit的数据。如果改为有4个电平等级，则每次能传递2个bit,一秒传递16 bit的数据。如果仍然保持两个电平等级，但将一秒切分为16个部分，则同样一秒传递16 bit的数据。 将一秒电平可以变换的次数用波特表示(Baud)，波特数越高则一个电平持续的时间越短，如给每个电平0.001的持续时间，那么这个系统工作在1000 Baud。理论上来说波特可以非常高，让每秒传递的数据增多，但是实际上当一个信号持续时间过短系统是无法检测到该信号的。每秒传递的数据量可用以下公式表示: $$ \\text{bits per second} = baud \\times \\lfloor \\log_2{(levels)} \\rfloor $$ Converting A Digital Signal To Analog 根据傅里叶定理，任意的波形都可以由一系列Sin波组成，其中每个Sin波都有各自的振幅，相位与频率。 数字信号也可以看作是一个跃变的波形，但是这样的跃变波形需要由无数个Sin波才能构成，所以从工程角度来说不可能实现，毕竟不可能找出无数个信源。 所以在实际运用中只能妥协，运用越多的Sin波形，最终的复合波形就越接近跃变波形。下图展示了用模拟信号来表示数字信号的过程，图（a）是数字信号，显示为跃变波形，图（b）是用一个Sin波来表示，图（C）是两个Sin波，图（d）是用三个Sin波。可以看到Sin波的数量越多，波形越接近跃变信号，而且新增的波的频率越来越高。 一般而言，用三个Sin波模拟即可。 The Bandwidth Of A Digital Signal 如之前所述，求一个信号的带宽是求其最大频率和最小频率的差值。对于数字信号来说可以先将他转换为模拟信号（多个Sin信号），然后找出最高频率的Sin以及最低频率的Sin。但是如上节所述，数字信号的跃变波形是由无数的Sin组成，且Sin的频率越来越高，即数字信号的最高频率是无限，因此数字信号的带宽为无限。 Synchronization And Agreement About Signals 在实际运用中，发送端和接收端必须保证信号的每次变换间隔是一样的（可看作采样频率），这个问题称为同步问题（Synchronization），下图展示了发送端和接收端以不同的频率采样会引发的问题，接收端的采样频率（10次每秒）高于发送端（8次每秒）。 在实际运用中，这种频率的差异可能非常小，如误差为$10_{-8}$秒，那可能出现了几百万个Bit后才发生一次错误。但在传输速率在亿个Bit每秒时，这种细微的差距也会引发大量的错误数据。 Line Coding 如上节所述，在数据传递的过程中可能会因为同步问题导致一些错误的发生，有一些方法来帮助避免这些错误的发生。一种是真正发送信号前，先发送一系列的特定模式的字节，如重复的0或者重复的1，通过这些字节来帮助接收端校准，另一种方法称为信道编码（Line Coding），在这种方式下会添加一些额外的字符来保证接收端能确切的解析出真实的数据。 如一个电路能产生5V，0，-5V的电压，可以将-5V定义为一个数据的开始。因此0信号表示为$-5V,0V$，1信号表示为$-5V,5V$。接收端知道在-5V信号后才是真正的数据。这种方式的图解如下： 因为信道编码引入了额外的数据来保证真实数据的准确性，所以信道编码降低了真实数据的传输速率。 Manchester Encoding Used In Computer Networks 曼彻斯特编码(Manchester Encoding)是一种信道编码，在计算机网络中曼彻斯特编码主要用于以太网中，所以十分重要。 对电路来说，检测信号的变化比检测信号的强度要简单。因此曼彻斯特编码将1信号定义为从零电压跳转为正电压，将0信号定义为从正电压跳转为零电压。而且曼彻斯特采样的时间为时间周期的中间，因此可以对于连续0或者连续1的情况，信号有时间可以回到之前的电压水平，保证下一次的检测正常。曼彻斯特编码的图示如下： 曼彻斯特编码还有一个变化，叫做差分曼彻斯特编码（Differential Manchester Encoding），这种方法用相对变化来表示信号，0信号表示信号发生了变化，1信号表示信号没有变化。采样时间为时间周期点。差分曼彻斯特编码如下图所示： 差分曼彻斯特编码的好处在于，即使信号的大小意外的翻转了也不会发生错误（如5V变为-5V之类）。 Converting An Analog Signal To Digital 模拟信号为了进一步的被处理，必须转换为数字信号。一般转换为数字信号有两种方式,一是脉冲编码调制(Pulse Code Modulation，PCM)，另一种是差分调制(Delta modulation) 脉冲编码调制是以相同时间间隔去测量模拟信号，并根据模拟信号的强度，将其转换为数字信号，整个流程分为三步，如下图框出的部分所示： 以相同时间间隔去测量模拟信号，即为采样，所以上图中的第一部分称为采样。有的时候为了避免采样时间点的信号突变导致的采样失真，会在相关时间点附近多采样几次，然后取平均值作为最后采样值。第二部分称为量化（Quantization），量化是根据模拟信号的强度，将其转换为一个Int值，如下图所示，第一个采样的数值，会被量化为2，第二个采样的数值会被量化为3，第三个采样的数值会被量化为6。 量化后的数据会被进一步编码为之后需要的数据格式（根据需求而定）。 差分调制的主题思想与脉冲编码调制类似，不同的是在量化阶段他不是对每个采样值进行量化，而是对当前采样值与上一个采样值的差距进行量化。这样节省了许多用来表示数据的Bit数，但是缺点在于一旦之前的数据出现了误差，后面的所有数据都会收到影响。 The Nyquist Theorem And Sampling Rate 应该以怎样的采样频率进行采样是数据通信中需要考虑的问题，如果采样频率过低，那么采样出来的信号与原信号可能有较大差异，如果采样频率过高，则会产生大量的数据。 奈奎斯特（Nyquist Theorem）定理提出：为了避免采样失真，采样的最低频率应该是原信号最高频率的两倍。 Nyquist Theorem And Telephone System Transmission 经过实验，0到4000HZ的频率基本就能提供人所能接受的音频质量。因此根据奈奎斯特频率，语音信号的采样频率应该是8000HZ，既一秒有8000个采样点。通话系统所用的PCM标准规定，每个采样信号用8-bit数据表示，所以每秒通话产生的数据量为： $$ 8000 \\frac{samples}{second} \\times 8 \\frac{bits}{sample} = 64000 \\frac{bits}{second} $$ 因此电话系统每秒传递64000-bits数据（64Kbps），也可见采样频率越高，可携带的数据也就越多。 Nonlinear Encoding 当每个采样点只能用8个比特来表示时，线性的PCM编码无法很好的体现声音，因为8个Bit只能表现256个值，且线性表示的话，无论是非常低频或高频的部分还是人身大部分集中的部分都用了一样的采样间隔，这造成了浪费。而非线性编码，解决了这个问题，他更关注与人耳最敏感的频率。数字电话标准中有两种非线性编码： $\\alpha-law$，主要是欧洲及中国采用的编码方式 $\\mu-law$，主要是北美和日韩采用的编码方式 $\\mu-law$算法的主要优势在于它覆盖了更广的频率范围（例如可以更好的还原特别高的声音），缺点在于对于一些弱信号有更多的失真。$\\alpha-law$在弱信号的失真上有优势，但动态范围更小。 对于国际电话，需要有$\\alpha-law$和$\\mu-law$之间的转化。 Encoding And Data Compression 数据压缩(Data Compression)是用来减少用来表达数据的bit数的方法。对于数据通信来说，通常在传输前对数据进行压缩。压缩分为两种类型：有损压缩(Lossy)和无损压缩(Lossless)。 有损压缩则通常用来压缩一些人相关的文件，如图片，视频，音频，这种压缩方式会忽视掉一些人无法精确识别的数据，JPEG和MPEG-3(MP3)都是典型的有损压缩。 无损压缩保证压缩后的数据在解压后与原数据相同，一般用于压缩文档之类的文件。大部分的无损压缩都用了字典技术，即如果一个字符串在文件中重复的出现，将这个字符串存放在字典中，之后的出现只要取字典中的索引值即可。 引用： Computer Networks and Internets 6th","link":"/CNI-Chapter6-Notes/"},{"title":"《计算机网络与因特网》 第七章笔记","text":"《计算机网络与因特网》 第七章笔记。 这一章是关于传播媒介的，首先给出了传播媒介的分类。 然后依次介绍各种媒介，包括线，光纤，红外线等。 最后介绍了信道容量的概念。 Chapter 7 Transmission Media Introduction 这一章将会给出传播媒介的分类，介绍电磁传播的基本概念以及展示干扰和噪音是如何被屏蔽的，最后会解释容量的概念。 Guided And Unguided Transmission 有两种重要的将传输媒介分类的方法： 按传播路径：使用有向（Guided）和无向（Unguided）来描述传播路径。像铜线和光纤这种提供特定路径的方式称为有向。而像无线电这样的传输称为无向。工程师会通俗的将这两种称为有线(wired)和无线(wireless)，因此光纤也算在有线的范畴。 按能的形式：分为三种类型，在线缆上的电信号（Electrical Energy），无线上使用的无线电（Radio）和光纤中使用的光（Light）。 Taxonomy By Forms Of Energy 下图展示了按能的形式分类的图，这个分类图也不是完美的，例如在无线电部分分为陆地无线电（Terrestrial Radio）和卫星无线电（Satellite），但实际上太空空间站的无线电部分两者都不符合。 Background Radiation And Electrical Noise 所有用电信号传输的电路都需要两根线，一根用来将信号传递给接收方，一根用来将反馈还给发送方。最简单的电传输方式就是使用两根铜线，每根线都用塑料包裹住，来防止相互之间的电干扰，在两根线外还有一层整个包裹起来，为了人方便使用。 但在线缆形式下有许多改进，这主要是因为电信号有以下特征： 环境中有随机的电磁辐射，称为噪音（Noise），如霓虹灯和电机就会发出随机的辐射。一般来说通信系统在正常运行状态下就会产生少量的噪音。 当电磁辐射遇到金属会被吸收进而产生细微的信号，这些信号会对正常的信号造成干扰。 正因为金属能吸收电磁辐射，所以可以用足够的金属放在噪声源和通信系统间，将其作为防护（Shield）。 Twisted Pair Coppter Wiring 有三种形式的电缆可以减少电磁噪音的干扰： 非屏蔽双绞线（Unshielded Twisted Pair,UTP） 同轴电缆（Coaxial cable） 屏蔽双绞线（Shielded Twisted Pair,STP） 第一个形式，非屏蔽双绞线在通信中被广泛应用。如名字一样，双绞线是将两根铜线缠绕在一起的形式，这种相互缠绕的形式比两根线平行排布有更好的抗干扰性。如下图所示，（a）为平行排列，蓝线更接近辐射源，于是它相对于灰线吸收了更多的能量，而在（b）图的缠绕形式中，两根线都各有一部分更靠近辐射源，所以整体来说，两者收到的能量是相同的。 Shielding：Coaxial Cable And Shielded Twisted Pair 因为非屏蔽双绞线只是让两根线吸收了相同的能量，但噪音还是被吸收了，所以在一些情况下，非屏蔽双绞线仍然会产生问题，如有特别强的电噪音环境，或者特别接近噪声源，或者通信系统中的信号频率很高（频率越高对噪音越敏感）。为了解决这些问题，只能尽量的屏蔽噪声。 一种方法就是同轴电缆（Coaxial Cable），它在线材的外层增加了一层编织金属屏蔽(Braided metal shield)（如网状）。使用编织样的金属层而非一整块金属层主要是处于便携性的考虑（后者的屏蔽性更好），但相对于非屏蔽双绞线，同轴电缆的便携性还是差的。如电视的信号线，一般都是同轴电缆，同轴电缆如下图所示： 屏蔽双绞线则是非屏蔽双绞线和同轴电缆的混合，是两者形式的折中，他在一对或多对双绞线的外层使用了更薄的金属屏蔽层，很多情况下用铝来作为金属屏蔽层（铝更软）。 如之前节所述，为了避免铜线间的电干扰，铜线外层会包裹一层塑料。双绞线是将两个两个包裹着塑料的铜线绞在一起，同轴电缆则是在一根包裹住塑料的导线外包裹金属屏蔽层，屏蔽双绞线是在两根包裹着塑料的铜线绞在一起后再包裹金属层。 Categories Of Twisted Pair Cable 一些标准机构为用于计算机网络的双绞线定义了标准，这些机构包括美国国家标准组织（American National Standards Institute，ANSI），通信产业联合（Telecommunications Industry Association，TIA），电子产业联合（Electronic Industries Alliance，EIA），下图为主要分类： Media Using Light Energy And Optical Fibers 有三种形式的媒介是用光能携带数据的：光纤（Optical Fibers），红外线传输（Infrared transmission），点对点激光（Point to Point lasers）。 其中最重要的类型是光纤： 每根光纤都是一根包裹在塑料外层中的细玻璃线或者透明塑料。 光纤是用于单项传播的。在光纤的一段是一个激光或者LED，用来发射光，另一端是连接一个感光设备用来检测光。如果数据需要双向传播，则需要用到两根光纤。多根光纤用塑料封壳包裹在一起生成光纤电缆。 光纤无法被弯折成直角，但光纤仍然可以弯曲，甚至可以弯曲成一个直径小于2英寸的圆，让光纤在弯折状态下仍然可以正常工作，主要是因为光的传播特性。 光从一个低密度物质照射入另一个高密度物质，随着入射的角度不同，光的反应也会不同。存在一个特定的角度，当光以这个角度入射时，光会随着两个物质的交界处传播。当光的入射角大于这个角度时，光会被反射。当光的入射角小于这个角度时，光会发生折射。如下图所示： 光纤运用的是光的反射，有一个特殊的镀层（Cladding）与光纤共同形成一个边界，在传输过程中，光会在上下两个边界内反射前进。 但反射的过程中是存在能量损耗的，而且因为光的反射，光传播的路径是比光的直线传播要长的，因此光在光纤一段发射后，抵达另一端时能量会更低，而且会更分散（Dispersed），如下图所示： 上图中，因为接受时的能量更低，所以Y轴值更低，且因为能量更分散，所以接受的时间也会拖长，因此在X轴上如同被拉伸。 Types Of Fiber And Light Transmission 因为光在传输中的反射导致的分散在长距离使用光纤时会成为严重问题，因此有三个种类的光纤，不同的在性能与价格上权衡， 跃变型多模光纤（Multimode，step index fiber）：这种类型的光纤，光纤与镀层中的边界很陡峭，因此光会在边界内频繁的反射，造成大量的能量分散，但是这种光纤价格最便宜。 渐变型多模光纤（Multimode，graded index fiber）：这种类型比跃变型多模稍贵，但是能减少反射进而有更少的能量分散。 单模光纤（Single mode fiber）：这种类型的光纤最贵，但也有最低能量分散。通常用于长距离传输和高比特率的传输。 如之前节所述光纤的一端会用来发射光，另一端会用来接收光。在发射端，可以通过发光二极管（Light Emitting Diode，LED），或者激光二极管（Injection Laser Diode，ILD）。在 接收端可以用感光细胞（Phote-sensitive）或者光敏二极管（Photodiode）。 Optical Fiber Compared To Copper Wiring 光纤的优势： 对电噪音免疫 更少的衰减（相对于铜线而言） 更高的带宽 铜线的优势： 更低的价格 更少的设备要求（光纤的接收端必须被有效的抛光） 更不易被损坏 Infrared Communication Technologies 红外线通信（Infrared Communication）也是光能通信的一种，也是点对点技术的一种,电视遥控机就是红外线通信的应用。红外线的频率在人眼可见光的范围外，但是红外线仍然表现的如同可见光，它会很快的消散，可以在坚硬光滑表面反射，会被不透明物体阻挡，薄如纸片的物体会阻挡信号，甚至大气中的水气都会阻碍信号。 因此红外线通信适用于室内使用，适用于距离短且无阻挡的通信。 下图是三种红外线通信的常见技术： Point-To-Point Laser Communication 激光通信（Laser Communication）是另一种点对点通信，如红外线通信一样，激光通信也需要一个无阻挡的路径。 但与红外线通信不同的是，激光通信只能覆盖很小的一片区域，激光的宽度通常只有几厘米（这里是宽度，并不是指长度），也正是因为激光的宽度很窄，所以激光传输的接收条件是比较苛刻的，通常是被永久的固定安装。 激光通信的典型应用是楼与楼之间的信号传输，通常在相邻大楼的外墙或者顶楼安装部署用于激光通信的发射和接收装置。 Electronmagnetic(Radio) Communication 常用无向性（unguided）来描述不需要任何介质来传播能量的通信方式。在计算机网络中最常用的依赖于电磁能的无向性技术是无线电传播（Radio Frequency Transmission）。无线电传播相较于光传播有个显著的优势，即可以长距离传播且可穿透阻碍物。 电磁能的使用依赖于他的频率属性，常用波谱（Spectrum）来描述可能的频率范围。全球的各政府分配不同频率的使用权，例如在美国是联邦通信委员会（Federal Communications Commission）。下图是主要的能量频率波谱，其中无线电的范围基本是$3KHZ$到$300GHZ$。 Signal Progagation 电磁波的频率也决定它传播时的特性，下表是波传播的三大类型： 分类 频率范围 传播类型 低频 &lt; 2 MHZ 沿地球表面传输，可能会被地形阻挡 中频 2 到 30 MHZ 在大气层中反射传播，尤其是在电离层 高频 &gt;30 MHZ 直线传播，会被障碍物阻挡 无线技术也可被分为以下两类： 地表（Terrestrial）：依赖相对贴近地表的设备通信，例如无线电发射器和微博发射器。这些设备一般安装在山顶，人造塔或建筑上。 非地表（Nonterrestrial）：依赖于大气层外的设备，例如轨道卫星 Types Of Satellites 通信卫星可以根据距离地表的距离分为三类： 近地轨道卫星（Low Earth Orbit,LEO）： 有低延迟的优点，但是与地球的相对位置变化的较快，接收端需要追踪卫星。 中地球轨道卫星（Medium Earth Orbit,MEO）： 为地球南北极提供信号的椭圆轨道卫星。 对地静止轨道卫星（Geostationary Earth Orbit,GEO）： 与地面可以保持固定角度，缺点是离地球较远，延迟大。 Geostationary Earth Orbit(GEO) Satellites 从上节对于通信卫星的描述可以看出，通信卫星的权衡主要是在延迟和与轨道周期的权衡（轨道周期与地球自转相差越远，追踪卫星越难）。 这里以对地静止轨道卫星（Geostationary Earth Orbit,GEO）为例，对地静止轨道卫星的距离地表距离约为35805千米，计算过程如下： 因为卫星保持在轨道上，所以离心力与万有引力相等，即 $$ {\\omega}^2mr=\\frac{GMm}{r^2} \\\\ 化简为：\\\\ r^3=\\frac{GM}{w^2}\\\\ 其中，G是万有引力常数为6.67\\times 10^-20 {km}^3/kg\\cdot {s^2}，M是地球质量为5.976\\times 10^{24} kg\\\\ \\omega 为角速度，如果要求对地静止，即角速度与地球自转相同，即\\\\ \\omega = \\frac{2\\pi}{3600*24}=7.29\\times10^{-5} rad/s\\\\ 都代入上式，求得r=42172 km，减去地球半径6376km，得对地静止轨道卫星的距离地表距离约为35805千米。 $$ 卫星距离如果不足这个数值，其旋转速度就会比地球快，在这个距离下，卫星与地表以相同的速度转动，所以地表上的卫星追踪装置在追踪到卫星后就不需要再次运动，因为两者的角度不会发生变化。但对地静止轨道卫星的最大缺陷是信号的延迟，信号的速度以光速计算，信号的一次来回需要： $$ 2\\times \\frac{35.8\\times 10^6 \\text{ meters}}{3\\times 10^8 \\text{meters/sec}}=0.238 sec $$ 0.2秒的延迟在许多领域上是无法被接受的。 GEO Coverage Of The Earth 在对地静止轨道上的卫星数量是由限制的。为了避免星号键的相互干扰，卫星与卫星间必须有间隔，间隔的大小与信号的强度相关，但通常而言是4-8度，因为整个轨道是360度，所以对地静止轨道上最多有45-90颗卫星。 最少则需要三颗卫星来覆盖整个地球，如下图所示： 证明如下，首先根据透视原理，距离一个球体越近，能看到球体的部分越少。在距离球体无限远的距离，最多也只能看到球体的50%，如下图所示： 将能看到球体的百分比设为X，离球体的距离设为d，求的半径设为R，表达式为： $$ X=\\frac{50%}{1+\\frac{R}{d}} $$ 式子是由等比三角形得出的，如下图： 将地球半径6376KM及对地静止轨道距离35805KM代入，得能看到的范围是约为42.45%，所以最少需要三颗卫星才能覆盖地球。 Low Earch Orbit(LEO) Satellites And Clusters 近地轨道卫星的高度最多为2000千米，其主要的缺点在于无法与地面保持相同速度，因此地面上的天线必须旋转来追踪卫星。最低的近地轨道卫星在大约90分钟就可以环绕一遍地球，移动速度还是将对较快的，因此对于地面天线来说追踪有一定难度。 通常的解决方式是用卫星群（Clustering）或者阵列部署（Array Deployment）的卫星来解决追踪问题。一系列卫星一同工作来覆盖较大的区域。 如一条信息需要从欧洲传到北美，欧洲的地面基站向此时他上方的卫星发送数据，上方的卫星将信息在卫星群之间传播，一直传送到北美上方的卫星，北美上方的卫星再将信息传送给北美的地面基站。 Tradeoffs Among Media Types 通信媒介的选择是复杂的，通常需要从以下几个方面权衡： 花费（Cost）：材料，安装，操作，维护等的开销 数据速率（Data rate）：每秒可以传送多少数据 延迟（Delay）：数据传播和处理的延迟 信号影响（Affect on signal）：信号是否会衰减和失真 环境（Environment）：对干扰的敏感性和电子噪音 安全性（Security）：是否容易被窃听 Measuring Transmission Media 可以从两个方面来评判传输媒介：传播延迟（Progagation Delay）和信道容量（Channel Capacity）。 奈奎斯特第一准则（Nyquist Theorem）表明在理想低通信道下的最高码元速率速率是带宽的2倍。假设有K个电平，则一个码元能传输的bit数为$log_2K$，B表示信道的带宽，因此数据速率可以表达为： $$ D=2Blog_2K \\text{ bits /s} $$ 下面证明奈奎斯特准则： 一个有限带宽的低通滤波器，如果其截至频率为$\\omega_g$其频域图如下： 该滤波器的时域相应图为： 时域的相应波形时一个拖尾的连续信号，这个拖尾会干扰后续信号。但是从波形上可以看出，在$t=\\frac{\\pi}{\\omega_s},\\frac{2pi}{\\omega_s}…$处是0，所以如果在这些间隔点发送码元，则不会被干扰。这些点的间隔时间为$T_s=\\frac{\\pi}{\\omega_s}=\\frac{1}{2f_m}$，所以码元速率为$R=\\frac{1}{T_s}=2f_m$ The Effect of Noise On Communication 奈奎斯特定理提供了了理论上的最高码元速率，因为他并没有将噪音纳入考虑， 而实际中噪音不可避免。香农在此基础上给出了考虑噪音的数据速率，称为香农定理（Shannon’s Theorem）： $$ C=B\\log_2(1+S/N) bits/s $$ 其中$S/N$称为信噪比，式子中并没有给出电平数量K，这是因为实际上在考虑噪声时，电平数量是受噪声影响的，噪声越大，为了避免干扰，电平的间隔就只能越大，因此电平数量就越少。 The Significance Of Channel Capacity 奈奎斯特定律鼓励工程师探索更高效的编码方式，因为在最高码元速率受信道带宽限制时，编码方式越高效，一个码元携带的数据就越多，单位时间内就能传输更多的比特。 香农定理给出了真实环境下，数据速率的上限，即无论编码多么高效，在非理想环境（有噪声）下，每秒最大的比特传输量 Xianping, W.M.L.R.T., 2002. Simple Certification of Nyquist Rule. Journal of Beijing Institufe of Petrochemical Technology, (2), p.12. https://zh.wikipedia.org/wiki/地球靜止軌道 Computer Networks and Internets 6th","link":"/CNI-Chapter7-Notes/"},{"title":"《计算机网络与因特网》 第八章笔记","text":"《计算机网络与因特网》 第八章笔记。 给出了可能出现的错误，以及控制错误的信道编码方法，包括检测错误和修复错误。 Chapter 8 Reliability And Channel Coding Introduction 这一章介绍在通信过程中会出现的错误，以及控制错误的技术。 其中的一部分也被纳入了因特网的协议中，这也会在本章中介绍。 The Three Main Sources Of Transmission Errors 传输中发生的错误可以分为三大类： 干扰（Interference）：如第七章所述，环境中存在许多电磁干扰，这些电磁干扰会阻碍无线电传输和线缆中的信号传输。 失真（Distortion）：所有的物理系统都会造成信号的失真。光纤中的光因为移动距离的增加，时域会发生扩张（频域也因此变化）。信道容量会导致一些频率的信号被过滤掉。放在线缆旁边的金属可能会改变线缆内信号的频率，金属也能干扰无线电信号。 衰弱（Attenuation）：信号在媒介中传输的过程中，信号会逐渐衰弱。 香农定理给出了介绍错误的思路：提高信噪比。 但无论如何噪声不可能被完全的消除，所以许多方法致力于检测错误，在某些情况下自动修复错误。 但是错误的监测机制无疑是会为系统增加开销的，因此系统设计时要考虑在错误影响与错误检测开销间做权衡，如金融系统，1bit的错误可能会造成很严重的错误，但是在图片中1bit的错误可能根本无法被识别到。 Effect Of Transmission Errors On Data 这里要区分传输错误与数据错误，数据是由传输信号在经过例如解码，解调后得到的。传输错误最后都会导致最后的数据出错。主要有三类传输造成的数据错误： 单元位错误（Single Bit Error）：即一系列数据中，只有一位数据被改变了。这通常是因为传输信号的短时间（称为脉冲，Spike）干扰造成的。 突发性错误：一系列数据中有多位数据被改变，通常是由长时间的干扰造成的。错误长度是由错误开始位到错误结束位直接的位数决定。如下表，错误的数据由加粗表示，错误长度是7： 发送 1 0 1 1 0 0 0 1 0 1 1 接收 1 0 0 1 1 0 1 0 1 1 1 Two Strategies For Handling Channel Errors 有一系列的方法解决数据错误并增加数据的可靠性，这些方法统称为信道编码(Channel Coding)，这些方法可以被分为两类：前向错误纠正技术（Forward Error Correction，FEC），自动重传请求技术（Automatic Repeat reQuest，ARQ）。 前向错误纠正技术的主题思想是在发送的数据中增加额外的信息，接收端可以根据这些额外信息来判断是否有错误发生，有些方法可以检测出究竟是哪一位数据发生了错误，并在可能的情况下纠正错误。 自动重传请求技术是让接收端和发送端互换数据来保证数据被正确的传递。 Block And Convolutional Error Codes 前向错误纠正技术可以再细分为两类： 分组错误码（Block Error Codes）：分组错误码是将数据分成一块块的，然后对每一块都增加额外信息。每一块的额外信息只针对于该块数据本身。 卷积错误码（Convolutional Error Codes）：卷积错误码是将数据看作一系列bits，增加的额外信息是由当前的bit和之前的bit共同决定的。 卷积错误码相对于分组错误码需要更多的计算，但是也更能检测出错误。 An Example Block Error Code：Single Parity Checking 单一奇偶校验检查（Single Parity Checking）是分组错误码检测的一个例子，可以再分为偶校验检查和奇校验检查。如果将数据分为$n$ bit一组，那么每一组增加一位数据，当是偶校验时，$n$位数据+1位额外数据应该一共有偶数个1，当是奇校验时，$n$位数据+1位额外数据应该一共有奇数个1。下表为8位数据时的例子： 原始数据 偶校验 奇校验 00000000 0 1 01011011 1 0 01010101 0 1 单一奇偶校验是一个比较弱的信道编码，他只能检测错误，但无法检测出错误具体出现在哪一位，也无法纠正错误。而且当有偶数个位发生错误时，错误就无法被检测出来。 The Methematics of Block Error Codes And (n,k) Notation 如有$k$位bit的数据，我们将所有$2^k$种可能出现的数据称为数据字(Datawords)，在这些数据中增加$r$位额外数据，一共有$n=k+r$个数据，所有$2^n$种可能称为编码字(codeworks)，其中编码字中合法的部分，即额外添加的数据与原数据时符合规则的部分，称为码书(Codebook)，并将这种方法标记为$(n,k)$ 如单一奇偶校验中,$k=8,r=1$，因此一共有256个数据字，也对应了有256个合法的编码字，一共有512个编码字。 在理想状态下，合法编码字中的任一一位被改变了，改变后的编码字就不是合法编码字。但是在单一奇偶校验的例子中，如果同时改变了合法编码字中的两位，那么结果仍然是一个合法编码字。 没有一个信道编码可以达到理想状态，所以要考虑的就是，合法编码字最少多少位数据要被同时改变，才能产生另一个合法编码字。在单一数字编码中，这个位数为2。 Hamming Distance：A Measure Of A Code’s Strength 汉明距离（Hamming Distance）是用来测量一个合法编码字要转换为另一个合法编码字最少要改变的数据位数的方法中需要用到的概念。如果给定两个$n$长度的字符，两个字符的汉明距离就是两个字符间不同的数据数量。 如$d(000,001)=1,d(000,101)=2,d(000,111)=3,d(101,001)=1$。 可以先对两个字符求异或，然后计算异或出来的字符1的总数，即为汉明距离。 The Hamming Distance Among String In A Codebook 为了计算出一个合法编码字要转换为另一个合法编码字最少要改变的数据位数，先要计算出码书中所有编码字组合的汉明距离。如对2位bit数据进行单一奇校验检测： 数据字 编码字 00 001 01 010 10 100 11 111 一共有4个编码字，4个编码字一一配对一共有6种可能，$d(001,010)=2,d(010,100)=2,d(001,100)=2,d(010,111)=2,d(001,111)=2,d(100,111)=2$。6种可能中最小的汉明距离是2，所以最少需要更改2位数据才能从一个合法编码字变为另一个合法编码字。 因此计算从一个合法编码字转换为另一个合法编码字最少要改变的数据位数过程是，计算出所有码书中的编码字（即合法编码字）两两配对后的所有汉明距离$d_{min}$，其中的最小值即为所求值。 The Tradeoff Between Error Detection And Overhead 对于一个编码，最多的能被检测出来的错误位数为$e=d_{min}-1$，如单一奇偶校验，因为$d_{min}=2$，所以最多能正确检测出来的错误位数为1。 虽然$d_{min}$越大能检测出来的错误位数越多，但这也意味着要增加更多的额外数据，对于$(n,k)$的编码，工程师用编码率（Code Rate）$R=\\frac{k}{n}$来表示为了检测出错误信息的编码开销。 Error Correction With Row And Column(RAC) Parity 奇偶校验本身是不能进行错误纠正的，但是通过行列奇偶校验（Row And Column Parity）就可以做到。如一共有12个bit的原始数据，即$k=12$，排成三行四列每一列每一行都进行奇偶校验，增加一个额外位，则一共8个额外位，即$r=8，n=k+r=20$，因此这是一个$(20,12)$的编码，如下图所示： 因此如果一位数据出错，会同时在对应的行和列校验位感知到，因此就可以定位到错误的数据，取反后就能纠正数据。 奇偶校验数据的$d_{min}$还是2，因此如果错误的位数大于1，当是偶数时无法被检测到，当是奇数时虽然能检测出错误，但无法纠正。 The 16-Bit Checksum Used In The Internet 有个称为因特网校验和（Internet checksum）的信道编码方法在网络中扮演了重要角色。这个算法的输入可以是任意长度，将输入拆分为一段段16字节的的部分，如果不能长度不能被16整除，则最后补0。如下图所示： 算法的流程如下： 将输入拆分为以16-bit为一组 定义一个32-bit的变量（这里称为$C$）作为结果。 将每一组16-bit的数据累加给$C$ 将$C$的前16位累加给后16位 将$C$的后16位取反，如果取反后全是0，则将其改为全是1 此时$C$的16位即为校验和。 可以看出最后的校验和也是16位的数据，将校验和作为新的一组16-bit放在原数据后（经过了补0的原数据）发送出去。接收端接受信息后重复算法流程，如果数据没有发生错误，最后接收端计算出的校验和应该是FFFF。 下面以两个例子进行说明： 例子1 如果发送端输入数据为0100 1000 0110 0101，0110 1100 0110 1100，0110 1111 0010 0001，计算过程如下： 12345 0100 1000 0110 0101 0110 1100 0110 1100+ 0110 1111 0010 0001----------------------------1 0010 0011 1111 0010 将高16位移到后16位 1234 0010 0011 1111 0010+ 1------------------------- 0010 0011 1111 0011 取反后得到： 11101 1100 0000 1100 这即为校验和 对于接收端，因为将校验和也一并发送了过去，所以接收端的计算过程如下： 123456 0100 1000 0110 0101 0110 1100 0110 1100 0110 1111 0010 0001+ 1101 1100 0000 1100----------------------------1 1111 1111 1111 1110 将高16位移到后16位 1234 1111 1111 1111 1110+ 1------------------------- 1111 1111 1111 1111 取反后得到： 10000 0000 0000 0000 因为全为0，所以改为全为1 11111 1111 1111 1111 例子2 如果发送端输入数据为1111 1111 1111 1111，1111 1111 1111 1111，0000 0000 0000 0001，计算过程如下： 12345 1111 1111 1111 1111 1111 1111 1111 1111+ 0000 0000 0000 0001----------------------------1 1111 1111 1111 1111 将高16位移到后16位 1234 1111 1111 1111 1111+ 1-------------------------1 0000 0000 0000 0000 此时虽然高16仍然有数值，但不需要再次累加，后16位取反后得到： 11111 1111 1111 11111 这即为校验和 对于接收端，因为将校验和也一并发送了过去，所以接收端的计算过程如下： 123456 1111 1111 1111 1111 1111 1111 1111 1111 0000 0000 0000 0001+ 1111 1111 1111 1111----------------------------10 1111 1111 1111 1110 将高16位移到后16位 1234 1111 1111 1111 1110+ 10-------------------------1 0000 0000 0000 0000 取反后得到： 11111 1111 1111 1111 Cyclic Redundancy Codes(CRCs) 在高速网络中，有一个称为循环冗余码(Cyclic Redundancy Codes,CRCs)的信道编码方法。循环冗余码有三个主要优点： 可以对任意长度的数据进行计算 可以充分的检测出错误 可以通过硬件实现，所以非常的高效 求$CRC$的计算过程可以看作是两个二进制数的相除，一个代表原数据，一个代表一个特定的除数（可根据不同的情况设置，除数的设置决定错误检测的能力），如果需要求得$N$长度的$CRC$，则需要$N+1$长度的被除数。二进制数相除的过程可以看作是多项式相除，如果原数据是$1010$，除数设置为$1011$，则计算过程如下图： An Efficient Hardware Implementation Of CRC CRC算法的实现硬件是由移位寄存器(Shift Register)和异或门(Exclusive or gates)构成的。在计算CRC前，硬件会初始化将移位寄存器中的所有位改为0，上例中的除数$1011$，对应的硬件图如下： TODO：为什么这么设计的原因。 Automatic Repeat Request(ARQ) Mechanisms 自动重传请求技术（Automatic Repeat Request,ARQ）需要发送端和接收端传递信息来检测错误。当一方发送数据给另一方时，接收方需要传递一个回执给发送方。如果在一段时间后发送方仍然没有收到回执，则认为数据丢失，重新发送数据。 自动重传请求技术适合只能检测错误，但不能修复错误的系统。当接收方检测出数据有错误后，将数据丢弃并不传递回执，那么发送方就会再次发送数据。 Computer Networks and Internets 6th 多项式除法 1’s Complement Arithmetic","link":"/CNI-Chapter8-Notes/"},{"title":"《计算机网络与因特网》 第十章笔记","text":"《计算机网络与因特网》 第十章笔记 调制与调制器相关内容。 Chapter 10 Modulation And Modems Introduction 这一章讨论数据通信中的调制与调制器相关的内容。 调制是利用高频的信息来携带原始数据，将分别讨论当原始数据是模拟信号和数字信号的情况。 Carriers,Frequency,And Propagation 许多通信系统会利用一个持续震荡的电磁波来作为信息的载波（Carrier），通常这个信号都是一个高频信号。在第七章有提到，信号的频率会影响信号的传播特性，如穿透性，对噪声的敏感性等。 Analog Modulation Schemes 调制（Modulation）意为根据原始信号来改变载波的特性。调制有两个输入，一个是载波，一个是原信号，然后产生一个调制后的载波作为输出。调制的原理图如下： 输入的原信号必须改变载波的一个特性，根据特性的不同可以分为振幅调制（Amplitude modulation），频移调制（Frequency modulation），移相调制（Phase shift modulation）。其中前两种最为普遍。 Amplitude Modulation 振幅调制（Amplitude modulation）是根据原信号改变载波的振幅。从时域图上看，调制后的波形的轮廓与原信号基本相同，如下图所示，（a）是高频载波，（b）是原信号，（c）是调制后的信号。 Frequency Modulation 频移调制（Frequency modulation）是根据原信号改变载波的频率，当信号强是，载波的频率增加，反之减少。如下图即为频移调制后的样子： Phase Shift Modulation 移相调制（Phase shift modulation）是根据原信号改变载波的相位。经过理论上可行，但对于模拟信号来说，很少用移相调制，因为模拟信号采样点的数据可能比较接近，导致移相的大小不明显，很容易被误认为是频率的改变。但对于数字信号来说移相调制因为可以一个码元传递多个Bit的字节，所以经常被使用。 Amplitude Modulation And Shannon’s Theorem 在之前解释振幅调制的示意图中，调制后信号变化幅度较大，最低处的强度接近于0。但实际运用时，基本上振幅调制的幅度变化很小。因为考虑到有噪声的存在，如果信号的变化幅度较大，在信号最弱时的信噪比会很低，则几乎无法传递有效信息。 Modulation,Digital Input,And Shift Keying 为了区分模拟信号和数字信号的调制，使用属于移位键控（Shift Keying）来表示数字信号的调制。数字信号的调制与模拟信号调制基本原理类似，只不过作为原信号的模拟信号是连续的数值变化，而数字信号是离散的几个特定的数值。振幅与频率移位键控如下图，(a)是载波，(b)是原信号，©是振幅移位键控，(d)是频率移位键控 Phase Shift Keying 相位移位键控(Phase Shift Keying)是根据原信号突然的改变载波的相位，如下图所示，即为相位移位键控的示意图。 Phase Shift And A Constellation Diagram 如之前所示，相位移位键控最大的优势在于可以用一个码元传递多个bit。可通过$2^n$个相位来使一个码元可携带$n$ bit数据。使用星座图来表示相位变化大小与该大小与对应数据的关系。星座图如下图所示，图（1）是只有两个相位变化，即表示0和1，图（2）是有四个相位变化，可代表两个bit,即00,01,10,11。 Quadrature Amplitude Modulation 如上节所述，可以在使用相位移位键控时采用多个相位间隔使一个码元传递多个bit。但某些情况下，硬件无法检测过于精细的相位变化。这时候可以通过降相位移位键控和振幅移位键控结合在一起使一个码元可携带更多的数据，这方法称为正交振幅调制（Quadrature Amplitude Modulation）。如下图所示： 如上图，一共有四个相位区分，每个点距离原点的距离代表振幅，一共有四个电压，因此一共有16种组合，一个码元可以携带4个bit。 Modem Hardware For Modulation And Demodulation 将一系列的数据bit作为输入，然后根据这些原数据对载波进行调制的设备称为调制器（Modulator），反之根据调制后的载波重新解析出原信号的机器称为解调器（Demodulator）。在实际中，大部分的通信设备同时包含调制器和解调器，这种设备被称为调制解调器（Modem）。下图是两个计算机的通信简图，在两者将数据传给中间的电缆媒介前，都经过了调制解调器 Optical And Radio Frequency Modems 调制解调器不仅可用于电缆的传输，对于无线电波和光纤也同样适用，原理也一样，在发送端调制解调器对载波进行调制，在接收端，数据从被调制后的载波中会提取。 Dialup Modems 在语音电话系统中，使用的调制解调器称为拨号调制解调器（Dialup Modems），其与普通的调制解调器最大的区别在于，前者用的是语音信号，后者用的是电信号，而且拨号调制解调器占用的带宽更小。 因为电话系统接受的是模拟信号，所以拨号调制解调器也是一个对模拟信号进行调制的设备。但讽刺的是现代电话系统的中间传输部分是数字信号，于是发送端在调制后，需要将模拟信号转换为数字信号。而在接收端，在进行解调前也需要先将中间传输来的数字信号转换为模拟信号。 QAM Applied To Dialup 正交振幅调制也同样可用于拨号调制解调器中。因为大部分语音频率本身是从$300HZ\\sim 3300HZ$，但拨号调制解调器只能提供$600HZ\\sim 3000HZ$，所以同样需要正交振幅调制来使一个码元能携带更多的数据。 V.32 And V.32bis Dialup Modems V.32和V.32bis是两个拨号调制解调器用正交振幅调制的标准。 V.32使用32个振幅和相位的组合来表示数据，可以达到单向每秒9600个bit的数据速率。 V.32bis使用128个振幅和相位的组合来表数据，可以达到单向每秒14400个bit的数据速率。 Computer Networks and Internets 6th","link":"/CNI-Chapter10-Notes/"},{"title":"《C++ Primer》 第四章笔记","text":"《C++ Primer》 第四章笔记 主要关于对内建类型的操作。 Chapter 4 Expressions Fundamentals Basic Concepts Grouping Operators and Operands 多个操作符的顺序是由优先级（Precedence）和结合性（associatively）有时还有求值顺序（order of evaluation）决定的。 Overloaded Operators 操作符可以被重载，但是操作符接受的参数数量，优先级还有结合性是没法被改变的。 Lvalues and Rvalues 左参数（Lvalues）是出现在赋值左侧的参数，右参数(Rvalues)是出现在赋值右侧的参数。当使用右参数时，使用的是右参数的值，当使用左参数时，使用的是参数的地址。 除了在13.6节会提到一个例外，可以在右参数的地方使用左参数代替，但是在左参数的地方无法使用右参数代替。 赋值操作会返回左参数，取地址操作返回的指针是右参数，前置的++和--返回左参数。 左右参数在使用decltype时也会体现出区别，当传入decltype的是表达式时，且表达式的结果是左参数，那么decltype的结果是引用。 假设p的类型是int *，那么*p返回的是左参数，因此decltype(*p)结果是int&amp;，而因为取地址符返回的是右参数，即(&amp;p)结果为为右参数，所以decltype(&amp;p)结果是int* *，而不是引用int** &amp; Precedence and Associativity 优先级（Precedence）决定是操作符执行的先后顺序，结合性（Associativity）决定的是同优先级的操作符之间执行的顺序。 算数操作符是左结合，即计算顺序是从左到右的，如3*4/2，会先计算除法，而赋值操作是右结合。 可以使用括号来重新决定优先级和结合性。 Order of Evaluation 求值顺序决定了操作符的多个参数，哪个还会先进行求值。 如下代码： 1int i = f1() * f2(); C++标准只能保证在执行乘法操作前，函数f1和f2都会被执行完毕，但是f1和f2的执行顺序是未定义的。 同理，如下代码的结果也是未定义的，即使在测试中得到了期待答案，也无法保证在其他硬件或编译器下能正常工作： 1cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; ++i &lt;&lt; endl; 所有出现在同一个表达式中的未限定求值顺序的操作符的执行顺序都是未定义的。所以尽量不要在同一个表达式中引用或修改同一个对象，这很可能会引发Bug。 只有四个操作符的执行顺序是指定了的，逻辑与&amp;&amp;，逻辑或||，条件判断?:和逗号,。 只有一种情况下，在同一个式子中使用未限定求值顺序的操作符对同一个变量多次操作能得到确定的答案，即修改了变量的子表达式本身就是另一个表达式的对象。 如int*++iter，按优先级会计算++iter，而改变后的iter本身就是int*表达式的对象。但是在之前的式子的f1() * f2()中，乘法操作符的对象是函数运行后的值，而不是函数本身。同理，对于cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; ++i，前面的i和i++实际上是不相关的，即&lt;&lt;操作符并不是将它俩链接在一起，所以谁先执行也是不能保证的。 Order of Evaluation,Precedence and Associativity 如有式子f()+g()* h()+j(),可以得出以下结论： 优先级保证了，g()的结果和h()的结果会先相乘 结合性保证了f()的结果会先和g()和h()相乘的结果相加，然后得到的结果再与j()相加。 四个函数的执行顺序无法保证。 如果这四个函数是相关的，如都会在内部对同一个全局变量进行修改或访问，那么结果将是未定义的。 Arithmetic Operators 算数操作符的优先级排序如下，所有的算数操作符的结合性都是从左至右： 优先级 操作符 含义 使用 1 + 正号 + expr 1 - 负号 - expr 2 * 相乘 expr * expr 2 / 相除 expr / expr 2 % 求余 expr % expr 3 + 相加 expr + expr 3 - 相减 expr - expr 算数操作符的结果都是右参数。 Arithmetic Operation on Boolean 在对布尔值进行算数操作时需要额外的注意，如下代码： 1234567bool b = true;bool b2 = -b;cout &lt;&lt; &quot;b2 is &quot; &lt;&lt; b2;/*b2 is 1*/ 因为对b使用了负号操作符，所以b会转换为int，因为b值为true，所以被转换为1，即b2的值为-1,因为非0，所以b2值为true。最后使用cout打印时，又转换为了int，为1。 Overflow 如果对整数类型使用了算数操作符且结果超过了类型所能表达的最大值，那么结果是未定义的，如使用short表示一个数，且在某设备上short是16-bits的类型，那么它的表达范围是$-32768\\sim 32767$，如有以下代码： 1234567short short_value = 32767;short_value++;cout &lt;&lt; &quot;short value is &quot; &lt;&lt; short_value &lt;&lt; endl;/*b2 is 1short value is -32768*/ 结果为-32768，是因为编译器对其进行了wrap around，但因为结果实际上是未定义的，并不能保证所有设备上都是这个结果。 remainder(%) operation 取余符号的操作对象必须是整数类型，对于m % n，结果的正负与m一样。即m%(-n)的值与m%n相同，(-m)%n的值与-(m%n)相同。 Logical and Relational Operators 所有的算数值（整数和浮点数）和指针转换为布尔值的规则相同，值为0为false，值非0为true。 所有的逻辑和关系运算符优先级如下标： 优先级 结合性 操作符 含义 1 Right ! 取非 2 Left &lt; 小于 2 Left &lt;= 小于等于 2 Left &gt; 大于 2 Left &gt;= 大于等于 3 Left == 相等 3 Left != 不等 4 Left &amp;&amp; 与 4 Left || 或 &amp;&amp;操作和||操作都是最短路径求值 The Relational Operators 因为关系运算符的返回结果是bool值，级联关系运算符的结果通常如期望的不同，如下代码： 1234567int i = 3, j = 2, k = 3;if (i &lt; j &lt; k) cout &lt;&lt; &quot;enter case 1&quot;; /*enter case 1*/ 运算的实际过程是，先判断i&lt;j，结果为false，返回0，然后判断o&lt;k，结果为true。如果要判断i,j,k是否是递增的，应该写为 12if(i &lt; j &amp;&amp; j &lt; k) cout &lt;&lt; &quot;enter case 1&quot;; Equality Tests and the bool Literals 可以在condition中直接使用算数值或者指针来判断该参数是否是0，如下 1if(val) {/* ... */}//true if val is nonzero value 但上式不能改写为 1if(val == true) {/* ... */} 在这个式子中，true会被转换为val的类型，即变为1，因此式子判断的是val的值是否为1。 Assignment Operators Assignment Is Right Associative 赋值操作的结合性是从右至左的，且赋值的右参数必须与左参数类型相同或者可以转换到左参数的类型，如下代码所示： 1234567891011int i;double d;i = d = 3.5;cout &lt;&lt; &quot;i is &quot; &lt;&lt; i &lt;&lt; &quot;, d is &quot; &lt;&lt; d &lt;&lt; endl;d = i = 3.5;cout &lt;&lt; &quot;i is &quot; &lt;&lt; i &lt;&lt; &quot;, d is &quot; &lt;&lt; d &lt;&lt; endl;/*i is 3, d is 3.5i is 3, d is 3*/ Assignment Has Low Precedence 在C++中，可以在condition中使用赋值操作，如下两部分代码是等效的，但第二个更简洁： 123456int i = getValue();while ( i != 42 ){ // do sth i = getValue();} 123int i;while( (i = getValue()) != 42) // do sth 注意赋值操作的优先级很低，所以需要使用括号来限定优先操作，如果不使用括号，则i的值会变成getValue返回值与42的比较结果，即只会是0或1。 Compound Assignment Operators 以下都是复合赋值操作符： +=,-=,*=,/=,%=,&lt;&lt;=,&gt;&gt;=,&amp;=,^=,|=。 以+=为例，下两个式子是等效的： 12a += 1;a = a+1; 但是从性能角度考虑，使用复合赋值操作只需要读取一次左参数，而普通的赋值方法则需要读取两次，因此复合赋值操作有更好的性能，虽然之中的差距不是很明显。 Increment and Decrement Operators ++和--操作都有两个形式，前置(Prefix)和后置（Postfix），前置返回的是原值加1后的原对象本身，结果是左参数。后置返回的是原对象的原值，结果是右参数。如下代码所示： 123456789101112int i = 0, j;cout &lt;&lt; &quot;i is &quot; &lt;&lt; i &lt;&lt; &quot;, j is &quot; &lt;&lt; j &lt;&lt; endl;j = ++i;cout &lt;&lt; &quot;i is &quot; &lt;&lt; i &lt;&lt; &quot;, j is &quot; &lt;&lt; j &lt;&lt; endl;j = i++;cout &lt;&lt; &quot;i is &quot; &lt;&lt; i &lt;&lt; &quot;, j is &quot; &lt;&lt; j &lt;&lt; endl;/*i is 0, j is 0i is 1, j is 1i is 2, j is 1*/ 尽量使用前置操作，这样代码更简洁，且因为避免了拷贝也有更好的性能 Combining Dereference and Increment in a Single Expression 因为累加符号的优先级低于解引用符，所以*p++等同于*(p++) Remember That Operands Can Be Evaluated in Any Order 如之前所述，在同一个表达式内，子表达式的计算顺序是无法保证的（操作符的优先级决定的是子表达式的计算结果在总表达式中计算的顺序）。 在同一个表达式中，有子表达式使用对象，另一个子表达式修改对象时，结果是未定义的，如下式： 123456789string s = &quot;abcdefg&quot;;auto beg = s.begin();while (beg != s.end() &amp;&amp; !isspace(*beg)){ *beg = toupper(*beg++);}/*aAAAAAA */ 结果并不是期望的遍历整个字符串并将所有字符换为大写，这是因为语句*beg = toupper(*beg++)是未定义的，它可能被解释为以下任何情况： 123*beg = toupper(*beg)*(beg + 1) = toupper(*beg)//Others 右侧的*beg++中的两个操作符的顺序是固定的，即先进行累加，在进行解引用。 但是左侧的*beg和右侧的*beg++哪个先进行运算结果是不一定的，如果先运行了左侧，则结果对应上述第一种可能，否则对应上述第二种可能。 The Member Access Operators ptr-&gt;mem相当于(*ptr).mem 箭头操作需要对指针对象进行操作，且返回的是左参数，点操作返回的参数是左参数还是右参数由对象本身决定。 The Conditional Operator 条件操作符的形式为cond ? expr1 : expr2，和逻辑与和逻辑或一样，条件操作符同样也是最短求值，所以expr1和expr2中只会有一个参数被计算。 Nesting Conditional Operations 当有多个条件操作符嵌套时，结合性是从右至左的，如下： 123456789void TestConditionalOperations(){ int grade; cin &gt;&gt; grade; string final = (grade &gt; 90) ? &quot;High Pass&quot; : (grade &lt; 60) ? &quot;fail&quot; : &quot;pass&quot;; //Equals to: //(grade &gt; 90) ? &quot;High Pass&quot; : ((grade &lt; 60) ? &quot;fail&quot; : &quot;pass&quot;) cout &lt;&lt; &quot;Final is &quot; &lt;&lt; final &lt;&lt; endl;} 结合性是从右至左的，但是计算顺序仍然是从左至右，即会先计算grade &gt; 90的情况，再计算grade &lt;60。 Using a Conditional Operator in an Output Expression 因为条件操作符（Conditional Operator）的优先级很低，所以在输出表达式中使用条件操作符时往往都需要加上括号，如下： 12345678910cout &lt;&lt; ((grade &lt; 60) ? &quot;fail&quot; : &quot;pass&quot;);cout &lt;&lt; endl;cout &lt;&lt; (grade &lt; 60) ? &quot;fail&quot; : &quot;pass&quot;;cout &lt;&lt; endl;// cout &lt;&lt; grade &lt; 60 ? &quot;fail&quot; : &quot;pass&quot;; //Error/*fail1*/ 第三个表达式无法正常编译，第二个表达式输出了1，因为都是因为&lt;&lt;操作比条件操作符有更高的优先级。 第二个表达式和第三个表达式等效为以下代码： 1234567// cout &lt;&lt; (grade &lt; 60) ? &quot;fail&quot; : &quot;pass&quot;;cout &lt;&lt; (grade &lt;60) ;cout ? &quot;fail&quot; : &quot;pass&quot;// cout &lt;&lt; grade &lt; 60 ? &quot;fail&quot; : &quot;pass&quot;; //Errorcout &lt;&lt; grade;// cout &lt; 60 ? &quot;fail&quot; : &quot;pass&quot;; //Error, can not use &lt; on cout The Bitwise Operators 位操作符（Bitwise Operators）使用整数类型来表示一系列的bits。如果操作的对象类型小于操作的结果类型，则会首先将操作的对象转换为结果类型，然后再进行操作。 位操作符的优先级及描述如下表所示： 优先级 操作 含义 代码实例 1 ~ 位取反 ~expr 2 &lt;&lt; 左移 expr1 &lt;&lt; expr2 2 &gt;&gt; 右移 expr1 &gt;&gt; expr2 3 &amp; 与 expr1 &amp; expr2 3 ^ 异或 expr1 ^ expr2 3 | 或 expr1 \\ expr2 Bitwise Shift Operators &lt;&lt;和&gt;&gt;都是位移操作，右侧的参数必须是正整数，而且必须小于左侧操作对象的bit数，否则将是未定义的。 位移运算结合性时从左至右的。 返回的结果是拷贝的左侧操作对象位移右侧参数后的结果，即位移运算不会影响原变量。 位移出边界的bit将被舍弃。 对于左移操作，如果操作对象是signed的，那么操作结果是未定义的，如果操作对象是unsigned的，数据左移后，在右侧装填0。 对于右移操作，如果操作对象是signed的，操作结果是基于实现的，可以实现为操作后左侧插入1，也可以实现为操作后左侧拷贝sign位（即数据的第一位）。如果操作对象是unsigned的，则在操作后在左侧插入0。 在操作对象为signed时，左移和右移操作要么是未定义的，要么是基于实现的，都不可控。所以建议只对unsigned对象进行位移操作。 例子1： 如有一台设备，其中char为8-bits，int为16-bits，一个名为bits的char对象的值为0233（八进制表示），则其二进制表示为 10011011 首先将其，转换为int，拓展的位都为0，如下 00000000 10011011 如果执行的函数是bits&lt;&lt;8，即将bits左移8位，结果为 10011011 00000000，最左侧的8位移除了范围，所以被丢弃了。 如果执行的函数是bits &gt;&gt; 3，即将bits右移动3位，结果为 000000000 00010011，最右侧的三位移出了范围，所以被丢弃了。 Bitwise Not Operator 同样在操作前，如果操作对象的整数类型较小，需要将其提升为结果的整数类型，如结果为int（16-bits）,对象为char，且值为10010111，则对其进行取反操作的结果为： 11111111 01101000 Bitwise And,Or 同样在操作前，如果操作对象的整数类型较小，需要将其提升为结果的整数类型。 对于异或操作，如果两个操作对象中，有且只有一个1，则结果为0，否则结果都为0。 例子2： 在一台int为21-bits，char为8-bits的设备上运行~'q' &lt;&lt; 6，该设备用Latin-1字符集，q二进制表示为01110001。 首先将其转换为int，结果为 00000000 00000000 00000000 01110001 然后进行取反操作，结果为 11111111 11111111 11111111 10001110， 再左移6位，结果为 11111111 11111111 11100011 10000000 如果要将该结果转换为10进制，首先第一位数据是1，说明为负数，负数的二进制是补码，因此需要将该二进制转换为原码，首先减一，得到 11111111 11111111 11100011 01111111 再取反，得到 00000000 00000000 00011100 10000000 表达为10进制为7296,所以结果为-7296。 Using Bitwise Operators 如果有一个int值quiz1，需要将其第27位变为1，则可使用以下代码 1quiz1 |= 1UL &lt;&lt; 27; 如果要将其27位变为0，则可使用如下代码： 1quize1 &amp;= ~(1UL &lt;&lt; 27); 如想要的到第27位的值，可以使用如下代码： 1bool status= quiz1 &amp; (1UL &lt;&lt; 27) Shift Operators Are Left Associateive 位移操作符的结合性是从左至右的，而IO的操作符是继承自位移操作符的，因此IO的操作符的结合性也同样是从左至右的，因此如下代码将会无法通过编译： 1cout &lt;&lt; 10 &lt;24; 因为&lt;&lt;的优先级高于关系操作符，因此上式实际上等于： 12cout &lt;&lt; 10;cout &lt; 24 因此会造成编译错误。 The sizeof Operator sizeof操作符返回类型的大小，单位为byte，该操作符结合性是从右至左的，结果为type_t类型。有以下两种表达方式： 12sizeof (type)sizeof expr sizeof操作符并不会对操作对象求值，因此如果表达式的结果是未定义的也没关系。 对于sizeof有以下规则： 对于char或者返回结果为char类型的表达式，sizeof的结果为1 对引用对象使用sizeof，结果为绑定的对象类型大小 对指针使用sizeof，结果为该设备上容纳地址需要的字节数（硬件相关）。 对数组使用sizeof，返回的是整个数组的大小，因为实际上数组的大小是数组类型的一部分 对string和vector使用sizeof，返回是这两个类的固定部分，即大小是固定的，并不随元素数量而变化。 sizeof实例代码如下： 12345678910111213string s = &quot;ABCD&quot;, ss = &quot;&quot;, *sp = &amp;s;cout &lt;&lt; sizeof(string) &lt;&lt; endl;//32cout &lt;&lt; sizeof ss &lt;&lt; endl;//32cout &lt;&lt; sizeof s &lt;&lt; endl;//32cout &lt;&lt; sizeof sp &lt;&lt; endl;//8cout &lt;&lt; sizeof *sp &lt;&lt; endl;//32cout &lt;&lt; sizeof s.size() &lt;&lt; endl;//8cout &lt;&lt; sizeof(size_t) &lt;&lt; endl;// 8int arr[3]{1, 2, 3};cout &lt;&lt; sizeof(arr) &lt;&lt; endl;//12int arrr[4]{};cout &lt;&lt; sizeof(arrr) &lt;&lt; endl;//16 Comma Operator 逗号操作符（Comma Operator）使用两个操作对象，求值顺序是从左至右的，即逗号操作符可以保证操作对象求值的顺序。 逗号操作符会先对左手边的操作对象求值，然后丢弃结果，再对右手边的操作对象求值，然后返回结果，如果右手边的对象操作对象是左参数，则返回左参数，否则返回右参数。 如下代码： 1234567891011121314int x = 1, y = 3, i;cin &gt;&gt; i;(i &gt; 0) ? ++x, ++y : --x, --y;cout &lt;&lt; &quot;x is &quot; &lt;&lt; x &lt;&lt; &quot;, y is &quot; &lt;&lt; y &lt;&lt; endl;/*2x is 2, y is 3*//*-1 x is 0, y is 2*/ 因为逗号操作符的优先级是最低的，所以上式实际上为 1( (i &gt; 0) ? ++x, ++y : --x ), --y; 无论如何，逗号操作符的右手边参数，--y都会被运行。 当i&gt;0时，执行的是(++x,++y)，然后再执行--y，因此结果为x=2,y=3。 当i&lt;0时，执行的是--x，再执行--y，所以结果为x=0,y=2 也因为逗号操作符的优先级是最低的，因此下式无法正常编译 12345int a = --x , ++y;//Equals to//int a = --x;//,++y Type Conversions C++会自动进行隐式转换，如表达式 1int ival = 3.541 + 3; 表达式中的3会先转换为double类型，然后相加的结果再转换为int类型。 隐式转换会在以下情况下发生： 在多数表达式中，小于int的整数类型会被先转换为int类型 在条件中，非布尔值的表达式会转换为布尔值 在初始化中，初始化值会被转换为目标类型；在赋值中，等号右手边的参数类型会转换为左手边的参数类型 在算数和关系表达式中，如果操作数的类型不同，那么会转换为一个通用的类型（在下一节解释） The Arithmetic Conversions 这节阐述的是算数类型的隐式转换，算数表达式中的隐式转换遵循以下规则： 算术类型的转换会尽量保持精度，如3.541+3中是3转换为了double类型，因为这样可以保留结果的精度。 小的整数类型会被转换为大的整数类型，如bool, short, unsigned short, char, unsigned char都会默认尝试转换为int，如果int无法容纳参数值，则转换为unsigned int。 a. 如果与较小的整数类型进行计算的是比int更大的整数类型，则直接转换为该类型，如'a'+12L，会直接将’a’转换为long类型。 b. 注意这里必须是与较小的整数类型直接连接的，如12+b+12L中，b还是会先转换为int。 c. 如果更大的类型非整数类型，仍然会先转换为int再转换为目标类型，如3.14L+'a'，'a’会先转换为int。 signed和unsigned类型转换 a. 如果两个类型都是signed或都是unsigned，则较小的类型转换为较大的类型 b. 如果unsigned的类型大于等于signed的类型（这里比较的是类型，不是参数值），则signed类型转换至unsigned的目标类型。 c. 如果signed类型大于unsigned类型，则首先尝试将unsigned类型转换至signed的目标类型，如果signed目标类型无法容纳unsigned类型的参数值，则将signed类型转换至unsigned 目标类型。 Other Implicit Conversions 除了算数类型的隐式转换，C++还有其他类型的隐式转换，如 数组到指针的隐式转换： 如之前所述，在使用数组名称时，会自动转换为指向数组第一个元素的指针。 这个转换在以下情况不适用： a. 使用decltype b. 使用取地址符&amp; c. 使用sizeof d. typeid，在19.2.2节会说明 指针转换 指针转换包含以下几种： a. 固定字面值0和字面值nullptr可以被转换至任意类型的指针（空指针） b. 指向任何非const类型的指针可以转换至void* c. 指向任何类型的指针都可以转换至const void* 布尔值转换 任何在表达式中的算数类型和指针都会被转换至布尔值，如果参数值为0为false，否则为true const转换 a. 在初始化时，非const的对象可以初始化const对象。 b. 指向普通类型的指针也可以转换为指向const类型的指针。 c. 相反的操作，即将const类型转换至非const的隐式转换不存在。 类型自定义隐式转换 a. string s = &quot;abc&quot;就是string类型自定义的隐式转换，将C类型的字符串字面值转换为string类型 b. while ( cin &gt;&gt; s)也是cin类型自定义的隐式转换，将cin类型转换为布尔值 Explicit Conversions 可以使用cast来进行显示转换，显示转换的格式为： cast-name&lt;type&gt;(express) 其中cast-name为显示转换的方法，一共有四种，其中dynamic_cast在19.2节会进行详细说明，剩下三种如下： static_cast 任何定义了的转换（除了low-level const）都可以通过静态转换（static_cast）来执行，这里的定义指的是可能存在的转换。如double和int之间存在转换，但vector和int之间不存在转换，因此前者可以使用静态转换，后者不行。 如： 12345678910int i = 10, j = 3;double slope = i / j;cout &lt;&lt; &quot;slope is &quot; &lt;&lt; slope &lt;&lt; endl;slope = static_cast&lt;double&gt;(i) / j;cout &lt;&lt; &quot;slope is &quot; &lt;&lt; slope &lt;&lt; endl;/*slope is 3slope is 3.33333*/ 直接进行i/j的话，因为两者都是int，所以结果也是int，因此输出的值为3。而通过static_cast将i的类型转换为double，此时j也会被隐式转换为double，因此结果为3.33。 通常也会用静态转换将void*转换到目标指针，如下 1234567void *p = &amp;slope;double *dp = static_cast&lt;double *&gt;(p);cout &lt;&lt; &quot;slope is &quot; &lt;&lt; (*dp) &lt;&lt; endl;/*slope is 3.33333*/ void*转换为的目标指针必须是原先的值匹配，否则结果是未定义的。 const_cast low-level的const只能通过const_cast显示转换，const_cast唯一能做的是也只是转换low-level的const。 如: 12345678910111213const int *value1 = &amp;i;// int *valueP = value;int *value2 = const_cast&lt;int *&gt;(value1);cout &lt;&lt; &quot;value1 is &quot; &lt;&lt; (*value1) &lt;&lt; endl;*value2 = 3;cout &lt;&lt; &quot;value1 is &quot; &lt;&lt; (*value1) &lt;&lt; endl;cout &lt;&lt; &quot;value2 is &quot; &lt;&lt; (*value2) &lt;&lt; endl;/*value1 is 10value1 is 3value2 is 3*/ 通过了const_cast，上式将const int *赋值给了普通的int*。甚至通过int*修改了参数，但是C++标准中，修改通过const_cast得到的指针结果是未定义的。 虽然在测试中得到了期望的结果，但是极度不推荐用这样的方法。 reinterpret_cast reinterpret_cast可以在更低的层次转换类型，因此提供了更多的转换可能。 但在转换后的类型很可能是无法正常操作的，如： 123int *ip;char* cstr = reinterpret_cast&lt;char*&gt;(ip);string str = cstr; 代码中，将int*转换为了char*，并用它来初始化string，在编译过程中代码不会出现任何问题，但在运行时的结果是未定义的，因为实际上char*和int*在bit层面的解释方法是不一样的。 尽量避免使用reinterpret_cast,该操作太危险了 Old-Style Casts 在C语言中，可以通过以下两种方式进行显示转换： 12345678type (expr)(type) expr//Like,char *pc;int i = int(*pc);i = (int)(*pc); old-stype转换与上述的三个显示转换实际上是等效的，它会首先尝试进行static_cast和const_cast，如果是合法的，则进行相应操作，如果这两个都不合法，则进行reinterpret_cast操作。 如以下两个操作是等效的： 1234const string *ps;void *pv;pv = static_cast&lt;void *&gt;(const_cast&lt;string *&gt;(ps));pv = (void *)ps; Operator Precedence Table 下图为C++所有操作符的含义，实例代码，结合性，优先级以双横线区分： 引用： Cpp Primer 5th Aug.2012","link":"/CPPPrimer-Chapter4-Notes/"},{"title":"《C++ Primer》 第五章笔记","text":"《C++ Primer》 第五章笔记 讨论了基础语句，循环语句和条件判断语句，以及讨论了C++的异常处理。 Chapter 5 Statements Simple Statements Null Statements 一个单一的分号即构成了一条空语句（Null Statements），当语言语法需要一条语句，但是代码逻辑并不需要的时候，空语句是很有用的。如： 12while(cin&gt;&gt; s &amp;&amp; s != sought) ; //null Statements 建议在每个空语句后都加上注释，表明是故意使用空语句而不是不小心遗漏。 Compound Statements(Blocks) 多条语句可以放在一个代码块中，代码块以两个大括号构成。如果代码块中没有任何的语句，则相当于一个空语句，如 1234while(cin&gt;&gt; s &amp;&amp; s != sought){} Statement Scope 可以在if, switch,while和for的控制语句中定义变量，在控制语句中定义的变量，只在其对应的作用域下有用，如 12345while (int i = getNum()){ cout &lt;&lt; &quot;i is &quot; &lt;&lt; i &lt;&lt; endl;}// i = 0; //error, out of scope Conditional Statements The if Statement If与C语言的If语句类似。 Dangling else 当if和else的数量不匹配时，else该与哪个if结合称为dangling else问题，C++的解决方法是，else与上方最近的未匹配其他else的if语句结合。 The switch Statement switch语句的构造如下： 123456789101112131415switch (expression){ case caseLabel1: //some code break; case caseLabel2: //some code break; case caseLabel3: //some code break; default: //some code break;} expression可以是一个变量的定义语句，或普通的一个变量，但expression必须是可以转换到整数类型的，expression的值会与每一个caseLabel进行比较，决定进入哪个case。 当进入一个case后，case内的代码会被执行，然后会进入顺应的下一个case，直到遇见break语句为止，所以在大多数情况下，每一个case中都会有一个break语句。 如果在某个case下故意的不加入break，要继续执行下一个case中的代码时，建议加上注释表明不是意外遗漏了break。 caseLabel必须是一固定的整数表达式参数（Integral constant），如case 3.14:，case ival（ival不是const int）等语句都无法通过编译。 当所有的case都不满足时，会进入default中，虽然default case不是强制的，但还是建议添加default。 Variable Definitions inside the Body of a switch 因为switch下所有case都是在一个作用域中（并没有大括号进行分割），所以在一个case中定义的变量是可以在另一个case中使用的，但是定义变量时不能进行初始化，因为初始化的case并不一定会被选中，如： 12345678910111213switch (val){case 1: // string file_name; //error, default initialization, and the initialization may bebypassed // int ival = 0;//error, the initialization may be bypassed int jval; //int is build-in type and this is in function so it isn't initialiazed break;case 0: jval = 2; break;default: break;} 代码中的file_name和ival都会造成编译失败，两者都有初始化的过程，file_name虽然没有指定初始化变量，但是因为它不是内建类型，所以会被默认初始化。 如果确实需要在某个case下定义变量且要初始化，那么只能将这个case的作用域与其他case分开，如下： 123456789101112131415switch (val){case 1:{ // string file_name; //error, default initialization, and the initialization may bebypassed // int ival = 0;//error, the initialization may be bypassed int jval; //int is build-in type and this is in function so it isn't initialiazed break;}case 0: // jval = 2;//error, jval is in another code scope break;default: break;} Iterative Statements while和for在执行body的代码前会先进行条件判断，而do while会先执行一次body代码，再进行条件判断 The while Statement 12while (condition) statement 在condition或statement中定义的变量会在每一次的迭代中被创建和摧毁。 Traditional for Statement for语句的标准形式为： 12for (initializer; condition; expression) statement; for语句的执行顺序是：先执行initializer，再执行condition判断条件，如果不满足则退出for循环，否则执行statement再执行expression。然后再次回到condtion进行循环。 如while循环一样，在initialzier中定义的变量的作用域只在控制语句和statement内部。 Multiple Definitions in the for Header 在initializer中可以定义多个变量，但只能使用一条定义语句，因此所有初始化的变量都是一个类型的，如 123456789101112131415161718vector&lt;int&gt; v{1, 2, 3};for (decltype(v.size()) i = 0, sz = v.size(); i != sz; ++i){ v.push_back(v[i]);}for (auto &amp;val : v){ cout &lt;&lt; val &lt;&lt; &quot; &quot; &lt;&lt; endl;}cout &lt;&lt; endl;/*123123*/ 在第一个for循环中，定义了i和sz两个变量。 Omitting Parts of the for Header for控制语句中的initializer, condition, expression都是可以被省略的。 如果condition被省略，相当于将true作为condition，因此为了避免死循环，必须在循环body中使用break。 Range for Statement range for循环的结构如下： 12for(declaration: expression) statement expression必须是用大括号括起的一系列元素，或者数组，或者带有begin, end迭代器的类型（如vector和string）。 declaration的类型必须是expression中元素的类型匹配，可以使用auto来简化操作。 如果要修改元素，必须将declaration的类型设置为引用，且使用引用也可以避免元素的拷贝来提升性能。 declaration中的变量会在每次statment执行后运行，并且用下一个元素来进行初始化。 1234for (auto &amp;val : {1,2,3}){ cout &lt;&lt; val &lt;&lt; &quot; &quot; &lt;&lt; endl;} 在range for中添加或删除元素可能会造成错误，这是因为range for循环的范围，即最终结束的end是被缓存下来的，在其中修改了元素的数量，range for的范围也不会改变。 The do while Statement do while与while很类似，只是在statement执行后再检查condition，如： 123do statementwhile(condition) 因为do while的condition会后执行，所以condition中不允许定义变量，否则将会出现statement中使用未定义变量的情况。 Jump Statements C++中一共有四种跳转语句，break,continue,goto,return，return会在6.3节介绍。 The break Statement break语句可以出现在while，do while，for和switch语句中，break语句只影响最近的loop或者switch语句，使用了break后会终止整个循环。 The continue Statement continue语句会终止当前的循环语句，并进入下一次循环。continue只出现在for,while和do while中（break还能出现在switch中），continue只有在switch是嵌套在循环中的时候才能写在switch内部，而且终止的也是嵌套switch的循环。 在while和do while中，continue后执行的是循环的condition，在传统for循环中，continue后执行的是for循环控制语句的expression，在range for中，continue后执行的是用下一个元素初始化declaration中的变量。 The goto Statement goto语句提供了无条件的跳转，goto语句可以跳转到同一函数中的另一个语句中，如 123456789101112 int val; int print1; cin &gt;&gt; val; if (val == 0) goto print0; else goto print1;print0: cout &lt;&lt; &quot;This is 0&quot; &lt;&lt; endl;print1: cout &lt;&lt; &quot;This is 1&quot; &lt;&lt; endl; 其中goto语句后跟着的print0和print1称为label，label指定了程序的跳转点。且label的命名和变量的命名是独立的，如代码中，定义了变量print1和label print1。 goto的作用域是同一个函数，即只能跳转到同一个函数中定义的label中。 goto语句还可以向上跳转，向上跳转的过程中，如果遇到了定义变量的语句，被定义的变量会被销毁，并重新构造，如下： 1234begin: int sz = getNum(); if (sz &lt;= 0) goto begin; 上述代码中，如果执行了goto begin，则变量sz会被销毁并被重新定义。 Try Blocks and Exception Handling 异常（Exceptions）是runtime时的不正常情况，如数据库连接错误，错误输入等。 异常处理是在程序的一部分检测到问题时，抛出异常信息，由另一部分程序来处理异常信息且问题之后的代码将不再运行。 C++的异常处理由三部分构成： throw expressions：当检测到错误时，使用throw来抛出异常信息。 try blocks，用来标记需要检测的代码部分，try block由语句try开始，由一个或多个catch语句作为终止。catch语句后的代码块是处理异常的代码。 一系列异常类，用来提供关于异常的信息。 示例代码如下： 12345678910111213141516171819202122232425262728293031323334int salesNum1, salesNum2;while (cin &gt;&gt; salesNum1 &gt;&gt; salesNum2){ try { if (salesNum1 &lt; 0 || salesNum2 &lt; 0) { throw runtime_error(&quot;num can't be less than 0&quot;); } int total = salesNum1 + salesNum2; cout &lt;&lt; &quot;Total num is &quot; &lt;&lt; total &lt;&lt; endl; } catch (runtime_error err) { cout &lt;&lt; err.what() &lt;&lt; &quot;, try again?&quot; &lt;&lt; endl; char c; cin &gt;&gt; c; if (c == 'n') break; }}/*20 11Total num is 31-1 25num can't be less than 0, try again?y22 20Total num is 42-2 1num can't be less than 0, try again?n*/ 当运行了throw语句后，之后的代码将不再运行，在示例代码中，抛出的是runtime_error异常，该异常定义在头文件stdexcept中，且必须通过string或C风格的字符串来初始化。关于不同类型的异常，将在之后章节中说明。 try语句块就是被检测的代码部分，注意其中定义的变量作用域仅在try代码块中，即使在后面的catch代码块中也无法访问。 try代码块后跟着一个或多个catch语句，每个catch负责一个错误类型，如果try代码块中抛出的错误语句与catch的错误类型匹配，则会进入相应的catch代码块，代码块中就是错误处理。 注意其中使用了err.what()，这里的err就是监听到的异常信息，由try中通过throw抛出。每个异常类都定义了what函数，该函数返回用于初始化异常对象的语句，在本例中即是num can't be less than 0，返回的类型是C风格的字符串。 Functions Are Exited during the Search for a Handler 如果出现了try代码块的中嵌套了多个其他的try，则当某个try代码块中抛出了异常信息，则会先在这个try对应的catch语句中搜索对应的异常处理。如果没有则再更外层的try代码块中找对应的异常处理。 如果最终没有搜索到对应的异常处理，将会执行标准库中的函数terminate，该函数的实现是系统相关的，但无论什么实现都保证程序之后的部分不会被继续执行。 如果一段程序再非try块中发生了异常，则会是直接调用terminate函数。 Writing Exception Safe code is hard 当一个异常发生时，代码中的一部分被执行了，另一部分没有被执行。这就可能造成物体只初始化了一部分或者一些物体没有被释放等等，这些都需要在代码的异常处理中完成。 如果一个程序的异常处理部分可以完全解决异常遗留下的各种问题，那么就说这个异常处理是安全的（Exception safe）。但要实现一份安全的异常处理是很困难的，需要额外的细心和考虑到各种可能的情况。 Standard Exceptions C++库中所有的异常类型定义在四个头文件中： exception头文件，定义了最通用的异常类型exception，这个类型只能告知有异常发生，但无法提供任何额外的信息。 new头文件，定义了bad_alloc异常类型，会在12.1.2节进行说明 type_info头文件，定义了bad_cast异常类型，会在19.2节说明 stdexcept头文件，该头文件定义了一系列常用的异常类。如下表所示： 异常类 说明 exception 最普通的异常 runtime_error 只能在runtime检测到的异常 range_error 运行时的错误，结果超出了有效范围 overflow_error 运行时的错误，计算上溢 underflow_error 运行时错误，计算下溢 logic_error 逻辑错误 domain_error 逻辑错误，没有结果的参数 invalid_error 逻辑错误，不合适的参数 length_error 逻辑错误，尝试创建大于物体最大值的参数 out_of_error 逻辑错误，使用了超出合理范围的参数 exception，bad_accloc和bad_cast类都使用默认初始化，无法提供其他的初始值。stdexcept中定义的一系列异常处理类，都必须用string或者C风格的字符串进行初始化，没有默认的构造函数。 所有的异常都有且只有一个函数what，该函数返回值类型为const char*，用来说明异常的信息。对于stdexcept中的异常类，返回的信息即是在初始化异常对象时传入的信息，对于其他的异常类，返回的内容由编译器决定。 引用： Cpp Primer 5th Aug.2012","link":"/CPPPrimer-Chapter5-Notes/"},{"title":"《C++ Primer》 第二章笔记","text":"《C++ Primer》 第二章笔记，关于变量与基本类型。 Chapter 2 Variables And Basic Types Primitive Built-in-Types C++的内置类型（Primitive Type）包括算数类型和空（Void）。算数类型可以用来表示字符，整数，布尔值，浮点数。 Arithmetic Types 算数类型（Arithmetic Types）可以再细分为整数类型（Integral types）和浮点数类型（Floating-point types）。 算数类型的大小，即占用多少个bit，在不同的设备上是不同的 C++标准保证了每个类型的最小尺寸，编译器可以给类型分配大于最小尺寸的位数。因为位数的变换，每一个类型所能表示的最大值和最小值也会相应的变换。 C++有的算数类型如下： 类型 含义 最小尺寸 bool 布尔值 Not Available char 字符 8 bits wchar_t 宽字符 16 bits char16_t Unicode 字符 16 bits char32_t Unicode 字符 32 bits short 短整数 16 bits int 整数 16 bits long 长整数 32 bits long long 长整数 32 bits float 单精度浮点数 精度为6位有效数字 double 双精度浮点数 精度为10位有效数字 long double 额外精度浮点数 精度为10位有效数字 long long 是C++ 11 后才支持的特性 一个char的大小应该保证可以容纳一个设备的基础字符集，通常尺寸为8 bits。wchar_t,char16_t和char32_t都是为了扩展字符集。 布尔值，字符和各种整数，都是整数类型。 内存可以分配的最小单元是byte，存储的基本单元为word。在c++中，byte的大小是可以容纳机器基本字符集的大小，通常为8 bits。word的大小通常为32 bits或者64 bits，即4到8 bytes。 通常编译器会提供给浮点数比最低要求更高的精度，float一般表示7位有效数字，double表示16位有效数字。通常float用1个word表示，double用两个words表示，long double用3或4个words表示。但要注意的是这些精度与尺寸都不是固定的，可能因设备的不同而不同。 大多数的计算机都会给每个byte分配一个地址。如在一台8-bit byte和 32-bit words的电脑上，一个word的内存如下，可以说是地址在736424的word或地址在736427的byte。 数据的类型决定了编译器会如何处理这些内存，即多少bit的数据会被认为是一个数据以及该如何翻译这些内存。 Signed and Unsigned Types 除了布尔值和扩展字符集的字符（如wchar_t等），所有的整数类型都可以被分类为有符号（signed）与无符号（unsigned）。 默认的类型，如int，short，long和long long都是有字符的，可以通过加上相应的unsigned关键字得到无字符版本，如unsigned long。unsigned int被缩写为unsigned。 但是对于char类型，有三个类型char，signed char，unsigned char三个版本。char是signed char或unsigned char中的一种，具体是哪一种由编译器决定。 标准并没有定义有符号类型如何表示数据，但是定义了正数部分和负数部分应该是均匀的分割，如8-bit的 signed char，应该保证能覆盖$-127 \\sim 127$的范围。大多数现代设备的实现下，char表示的范围是$-128\\sim127$。 数据定义建议： 如果确保数值不会是负数，使用unsigned类型 通常情况下使用int，short的可定义范围太小，如果数值大于了int可表示范围，使用long long。之所以不使用long，是因为在许多设备的实现下，long和int的大小是相同的。 在算数表达式中，不要使用char和布尔值。char类型在不同的设备下，可能是signed char可能是unsigned char，这个会导致bug的发生。布尔值则会被解释为0或1，可能与设想的结果不同，建议直接用0或1来表达。 使用double进行浮点数计算。一是因为float通常没有足够的精度，二是因为单精度和双精度的开销差距几乎可以忽略不计，三是因为对于一些设备而言，双精度反而会有更高的效率。 Type Conversions 类型转换会在使用一个类型的对象，但希望得到另一个类型的对象时自动进行。 如下列代码 1234567891011121314bool b = 42;cout &lt;&lt; &quot;value is &quot; &lt;&lt; b &lt;&lt; endl;int i = b;cout &lt;&lt; &quot;value is &quot; &lt;&lt; i &lt;&lt; endl;i = 3.14;cout &lt;&lt; &quot;value is &quot; &lt;&lt; i &lt;&lt; endl;if (i) cout &lt;&lt; &quot;result is true&quot; &lt;&lt; endl;double pi = i;cout &lt;&lt; &quot;value is &quot; &lt;&lt; pi &lt;&lt; endl;unsigned char c = -1;cout &lt;&lt; &quot;value is &quot; &lt;&lt; (int)c &lt;&lt; endl;signed char c2 = 256;cout &lt;&lt; &quot;value is &quot; &lt;&lt; (int)c2 &lt;&lt; endl; 结果为 规则如下： 如果将一个非布尔值的算数类型赋值给布尔值，如果该数据值为0，则布尔值为false，否则为true。 如果将布尔值赋值给算数类型，如果布尔值是true，则值为1，否则值为0。 如果将浮点数类型赋值给整数类型，整数类型将保留浮点数的整数部分。 如果将整数类型赋值给浮点数类型，则浮点数的小数部分为0。 如果给unsigned类型赋值了超过其能表达的范围的数，结果为值与unsigned类型范围的取模。如上例中，unsigned char c = -1，值为最大能表达的数$256-1$（测试电脑char为8-bit）。 如果给signed类型赋值了超过其能表达的范围的数，结果是未定义的，虽然在这里的测试中，结果为0。 但结果在不同电脑，不同编译器，甚至不同的运行时间都会不同，结果是不可预知的。 Expression Involving Unsigned Types 当signed与unsigned数一起计算时，signed会被转换为unsigned，如下面代码所示： 123456unsigned u1 = 10, u2 = 42;int i = -42;cout &lt;&lt; i + i &lt;&lt; endl;cout &lt;&lt; i + u1 &lt;&lt; endl;cout &lt;&lt; u2 - u1 &lt;&lt; endl;cout &lt;&lt; u1 - u2 &lt;&lt; endl; 结果为： 第二个表达式值为4294967264，因为在计算时$i$被转换为了unsigned,值为$2^{32}-42$（32次方是因为int用32-bit表示），因此整个式子的结果为$2^{32}-42+10=4294967264$。 同理第四个式子直觉上结果应该为-32，但因为是unsigned的，所以结果为$2^{32}-32=4294967264$。 在使用unsigned作为循环条件时尤其要注意，如下式： 1234for (unsigned i = 10; i &gt;= 0; i--){ cout &lt;&lt; &quot;i is &quot; &lt;&lt; i &lt;&lt; endl;} 结果会变成死循环： 因为在i变为0后，执行i--，i将变成$2^{32}-1$，而不是-1。 因此不要将signed和unsigned混用，即使是知道隐式转换的规则。因为在不同的设备下，用以表达unsigned类型的字节数是可能是不同的，这将会导致隐式转换后的结果不同。本例子中，int为32-bit表达，但并不保证所有的设备都是用32-bit表达int。 Literals Integar and Floating-Point Literals 可以使用十进制，八进制或者十六进制来写整数字面量。以0开始的字面量会被认为是八进制，以0x或者0X开始的字面量会被认为是十六进制。 以下的三个表达是等效的，结果都是十进制的20。 1234int i_decimal = 20, i_octal = 024, i_hexadecimal = 0x14;cout &lt;&lt; &quot;i decimal is &quot; &lt;&lt; i_decimal &lt;&lt; endl;cout &lt;&lt; &quot;i octal is &quot; &lt;&lt; i_octal &lt;&lt; endl;cout &lt;&lt; &quot;i hexadecimal is &quot; &lt;&lt; i_hexadecimal &lt;&lt; endl; 三个表达是等效的，结果都是十进制的20。 1int month = 09;//error, 09 is treated as octal 上式无法通过编译，因为0开头的字面值会被认为是八进制数，而数字9不会出现在八进制数中。 十进制的字面值会被默认是有符号的，八进制和十六进制则可以是无符号也可以是有符号的。即十进制的字面值类型会被认为是int,long,long long之中最小的满足值的类型。八进制或十六进制则会在int,unsigned int,long,unsigned long,long long, unsigned long long中选择最小的满足的类型。 如果字面值的大小超过long long 或unsigned long long所能匹配的值，则无法匹配任意一种类型，编译器将会报错，如以下语句无法通过编译： 12//cout &lt;&lt; 9223372036854775808 &lt;&lt; endl;//cout &lt;&lt; -9223372036854775808 &lt;&lt; endl; 因为这是10进制的字面值，其最大类型为long long，而signed long long的范围是$-9223372036854775808 \\sim 9223372036854775807$。$-9223372036854775808$虽然在范围内，但仍然无法被编译，因为十进制的字面值并不会被认为有负号，即$-9223372036854775808$会被认为是一个$0减去9223372036854775808$，即仍然计算的是$9223372036854775808$。 这里谈论的限制都是C++标准的限制，但是有些编译器的实现会与标准不同，如上述代码在visual studio 2019中可通过编译，这是因为编译器将其自动转换为了unsigned long long 类型 浮点数的字面值用十进制的小数点或者用科学计数法（符号E表示），如下: 1234567cout &lt;&lt; 3.14159 &lt;&lt; endl; //3.14159cout &lt;&lt; 3.14159E0 &lt;&lt; endl; //3.14159cout &lt;&lt; 3.14159E1 &lt;&lt; endl; //31.14159cout &lt;&lt; 0. &lt;&lt; endl;//0cout &lt;&lt; 0e0 &lt;&lt; endl;//0cout &lt;&lt; .001 &lt;&lt; endl;//0.001cout &lt;&lt; 1E-3 &lt;&lt; endl;//0.001 默认的所有浮点数字面值的类型为double。 Character and Character String Literals 单引号之间的字符会被认为是char字面值，双引号之间的字符会被认为string字面值。如 12cout &lt;&lt; 'a' &lt;&lt; endl; //acout &lt;&lt; &quot;Hello&quot; &lt;&lt; endl; //Hello string字面值是const char的数组，编译器会自动在数组的最后加上一个空白字符，即\\0，所以string的真实长度比看上去的字符数大1。如’a’长度为1，&quot;a&quot;长度为2。 两个string字面值如果中间只有空格，或tab或者换行符，会被认为是一个string字面值，如 12cout&lt;&lt;&quot;This is first string literal&quot; &quot;This is second string literal&quot;&lt;&lt;endl; Escape Sequences 一些无法显示出来的字符（如回车）和一些有特殊含义的字符可以使用转义序列（Escape sequence）表示。 一些常用转义序列 转义符 作用 转义符 作用 \\n 换行 \\t 水平 tab \\v 纵向tab &lt;*&gt; 打印出特殊符号*，如&quot; ’ \\ 也可以使用数字和转义符来生成转义序列，假设编译器使用的是Latin-1字符集。可在\\x后跟1或多位十六进制数组，或在\\后跟着1至3位八进制数字，如以下代码都将显示一样的结果： 123cout &lt;&lt; &quot;M\\n&quot;; //Mcout &lt;&lt; &quot;\\115\\12&quot;; //Mcout &lt;&lt; &quot;\\x4d\\xA&quot;; //M 这里的\\115后跟着的是八进制数，转换为十进制为77，可在Latin-1表中得知，77表示为M。同理\\12表示十进制10，表示为LF，即换行。 跟在\\后的数字最多只会被计算前三位，如\\1234将会被认为是转义序列\\123和一个普通的4。而\\x之后跟着的所有数字都会被计算,如\\x1234会被认为后面跟着16-bits的十六进制数（一个16进制数是4-bits），但是大多数的硬件都是使用8-bits char的，所以通常来说，两位十六进制数就足以表示字符表了。 Specifying the Type of a Literal 可以通过前缀或后缀来指定整数、浮点数以及字符字面值的类型。字符字面值用前缀，整数及浮点数字面值用后缀。 字符字面值类型指定如下表所示： 前缀 类型 u char16_t U char32_t L wchar_t u8（只能用于string类型） char 整数字面值指定如下表所示: 后缀 最小类型 u 或 U unsigned l 或 L long ll 或 LL long long 整数字面值设定的是最小类型，即最终的类型还是会根据字面值的大小来调整 指定有无符号的类型后缀可以和指定长度的类型的混合使用 浮点数字面值指定如下表所示： 后缀 类型 f 或 F float l 或 L long double 指定字面值类型示例代码如下所示： 123456cout &lt;&lt; 9223372036854775808ULL &lt;&lt; endl;cout &lt;&lt; L'a' &lt;&lt; endl;cout &lt;&lt; u8&quot;hi&quot; &lt;&lt; endl;cout &lt;&lt; 1E-3F &lt;&lt; endl;cout &lt;&lt; 0.001F &lt;&lt; endl;cout &lt;&lt; 3.14159L &lt;&lt; endl; Variables C++中的每个变量（Variables）都有类型。 Variable Definitions 简单的变量定义由一个类型指示器（Type Specifier）跟着一个或多个由逗号分割的变量名称组成，以分号结束。如： 1int sum = 0, value, units_sold = 0; Initializers 当变量定义在同个语句中定义多个变量时，每个变量在声明后马上可见，即后续的变量可以用前面的变量来初始化，如： 1double price = 109.99, discount = price * 0.16; 在C++中初始化（Initialization）和赋值（assignment）是两个不同的操作，在许多语言中这两者的区别几乎可以忽略。但是在C++中两者的区别却很重要，初始化是一个变量在创建时给予参数的过程，赋值是变量已经生成后由新的参数替代原先参数的过程。 在后续的章节中会进一步讨论两者的差异。 List initialization C++有多种方法来初始化变量，如下所示： 1234int units_sold = 0;// int units_sold(0);// int units_sold = {0};// int units_sold{0}; 这四者都是初始化的方法，其中后两种带有大括号的是C++11的新特性，称为列表初始化（list initialization）。 如果使用列表初始化，那么在初始化变量的过程中不允许出现精度的丢失，如下所示： 123long double id = 3.1415926536;float ifloat{id};int a{id}, b = {id}; 书中描述编译器会禁止丢失精度的赋值，但在gcc 8.1.0的版本测试下，编译器只是给出了warning Default Initialization 当定义一个变量但没有给初始化数值时，参数会被赋予默认值。在任何函数外的未赋值变量会被初始化为0，在函数内部的未赋值内置变量则不会被初始化。未初始化的变量值是未定义的（Undefined），访问或拷贝任何未初始化的值都会产生错误。 这里的描述仍然是C++的标准定义，但是不同的编译器会有不同的实现，如在gcc 8.1.0版本中，函数内部的未赋值变量仍然会被初始化为0。但要知道未定义的操作在不同的版本或设备下很可能有不同的结果，所以应该尽可能避免。 Variable Declarations and Definitions C++支持单独编译（Separate Compilation），即可以把整个程序放在多个文件中，每个文件可以独立的被编译。 为支持单独编译，C++需要区分声明（Declaration）和定义（Definition）。 声明是为了让程序知道变量的名称。如果一个文件需要使用在其他地方定义的变量，那么在这个文件中需要对该变量进行声明。声明一个变量需要指定它的类型和名称。 定义是创建相关的变量。定义一个变量首先会先声明该变量，然后再为该变量开辟存储空间，并赋予初始值。 每个变量都只可以被定义一次，但可以被声明多次。 可以使用关键字extern来指定操作是声明而不是定义，不允许在函数内部使用extern关键字。 如上所属，声明是不包括函数的初始值的，所以如果一个声明包含了对变量的初始化，那么该声明实际上是定义（在后续章节中可以看到，对于const变量会需要同时使用extern和初始化）。如下所示： 1234//Declarations and Definitionsextern int i; // Declares but does not define iint j; //declare and defines jextern double pi = 3.1416; // declare and defines pi, same with expression without extern 为了在多个文件中使用同一个变量，必须在一个文件中定义该变量，在其他文件中声明（不包括定义）该变量。 Identifiers C++中的标识符（变量名称）由字符，数字和下划线构成，C++并没有限制名称的长度。 Scope of a Name 作用域（Scope）是指一个变量在程序中存在意义的部分，在C++中绝大部分的作用域都是通过大括号（{ }）进行分割的。 Nested scopes 作用域有的时候会形成嵌套，如果产生嵌套的话，外部作用域（Outer scope）中定义的参数可以被内部作用域（Inner scope）使用，如果内部作用域定义了一个与外部作用域中某变量名字相同的新变量，外部作用域中的变量将会被隐藏，但可以使用操作符::来访问被隐藏了的变量。 如下所示，其中定义在所有函数外的变量有全局作用域(Global scope)，否则的话有代码块作用域(block scope)。 12345678910int reused = 42; //global scopeint main(){ int unique = 0; //block scope cout &lt;&lt; reused &lt;&lt; &quot; &quot; &lt;&lt; unique &lt;&lt; endl; //42 0 int reused = 0; //local named reused hides global reused cout &lt;&lt; reused &lt;&lt; &quot; &quot; &lt;&lt; unique &lt;&lt; endl; // 0 0 cout &lt;&lt; ::reused &lt;&lt; &quot; &quot; &lt;&lt; unique &lt;&lt; endl; // 42 0} 其中第二个输出中的reused变量是在内部作用域中新定义的变量，因此值为0。第三个输出中的reused使用了::操作符访问了全局变量中的reused,所以值为42。 Compound Types 复合类型（Compound Type）是根据其他类型定义的一种类型，C++有多种混合类型，在这里会先介绍两种，引用（Reference）和指针（Points）。 References 在C++11中引入了右引用(rvalue reference)和左引用(lvalue reference)的概念。但通常来说，当提及引用时都是指左引用。 引用（Reference）是一个物体的别名，引用类型指代另一个类型。 一个引用创建时会绑定至另一个变量，成为它的别名。当引用创建后无法重新绑定至其他变量，因此引用创建的时候必须被初始化。 12345int ival = 1024;int &amp;refVal = ival;// int &amp;refVal2; //error,must be initialized// &amp;refVal = reused; //error,can not be rebindedrefVal = reused;//Not rebingding, is to change ival's value A Reference Is an Alias 如之前所述，引用不是物体，而是另一个物体的别名，所以对引用的任何操作实际上都是对被绑定的物体的操作。如下： 12int ii = refVal; //Bound to ivalint &amp;refVal3 = refVal; //the same value as ival Reference Definitions 引用符号&amp;是针对变量名称而言的，所以每个引用在定义的时候前面都需要加上引用符号。 另外除了在2.4节（const reference可以绑定至任意可转换的对象）和15.2节(基类的引用可以绑定派生类对象)提到的两个特殊情况，引用类型必须和被捆绑的值类型一致，且引用类型不能捆绑至字面值。 12345int i = 1024, i2 = 2048;int &amp;r = i, r2 = i2; //r is int refernece, r2 is int// int &amp;refVal4 = 10; //error, can't be bound to literaldouble dval = 3.14;// int &amp;refVal5 = dval; //error, types not match Pointers 指针（Pointers）是一个“指向”别的类型的复合类型。 与引用不同的是，指针是一个物体，因此它可以被拷贝和赋值，在指针的生命周期内，它可以被指向多个不同的物体。而且指针在定义时并不一定要被初始化，但与其他的内建类型一样，在代码块作用域中的指针如果未被初始化赋值，则它的值是未定义的。 与引用相似的是，在定义每个指针变量的时候，都需要在前面加上指针符号*。 Taking the Address of an Object 一个指针包含另一个物体的地址，可通过取地址符(&amp;)来获得一个对象的地址。 与引用类似，除了在2.4节（pointer to const可以绑定至nonconst对象）和15.2节阐述的特殊情况外，指针所指向的对象类型必须与指针类型相同。如下列代码所示： 12345678910//Pointsint *ip1, *ip2; //define int pointer without initializerdouble dp, dp2; //dp is double, dp2 is double pointerint ival = 42;int *p = &amp;ival; //p hold the address of ivaldouble dval;double *pd = &amp;dval; //Initializer is the address of a doubledouble *pd2 = pd; //Initializer is a pointer to double// int *pi = pd; //error,pointer types not match// int *pi2 = &amp;dval; // error,pointer types and object typenot match Pointer Value 一个指针的值，可以是以下四种情况： 指向一个对象的地址 指向一个对象地址后的第一个byte 空指针，不指向任何对象 非法指针，除了上述三个情况的指针都是非法指针。 使用非法指针的结果是未定义的，具体的结果由不同的编译器决定。虽然情况2和3是合法的，但是访问这两种情况的指针结果也是未定义的。如 1234int *ip = &amp;ival; //Pointer to ivalint *ipEnd = ip + 1; //Pointer to end of ivalint *ipNull = NULL;cout &lt;&lt; (*ip) &lt;&lt; &quot; &quot; &lt;&lt; (*ipEnd) &lt;&lt; endl; // 42 0 虽然在这里的测试中(*ipEnd)返回的值为0，但实际上这是未定义操作，在不同的编译器会返回不同的结果。 Using a Pointer to Access an Object 当使用指针访问变量时，需要使用解引用符号*。如上节代码中的(*ip)。 尽可能避免解引用那些非法或者没有指向具体对象的指针。 &amp;和*符号现在都有多个含义，&amp;既可以表示为引用，又可以表示取地址符号，*既可以表示指针，又可以表示解引用符号。它们在代码中的具体含义由上下文决定： 1234567int i = 42;int &amp;r = i; //referenceint *pp; //pointerpp = &amp;r; //address-of operator*pp = i; //dereferenceint &amp;r2 = *pp; // reference and dereferencecout &lt;&lt; (r2) &lt;&lt; &quot;&quot; &lt;&lt; (*pp) &lt;&lt; endl; //4242 Null Pointers 空指针（Null Pointers）并不指向任何对象，代码可以在使用指针前检查其是否为空。 有三种方法定义空指针，如下所示： 123int *p1 = nullptr; // c++ 11int *p2 = 0;int *p3 = NULL; nullptr是C++11标准中引入的特性，它是一个特殊的字面值，可以转换为任何指针类型。NULL定义在头文件cstdlib中，它使用预处理器(#define)转换为0，所以使用NULL和使用0来定义空指针实际上是等效的。 尽量使用nullptr 虽然可以用0来表示空指针，但并不能将int变量直接赋值给指针，即使该变量值为0也不行，如下： 12int zero = 0;// p3 = zero; //error, can't assign an int to pointer Assignment and Pointers 指针和引用都是对对象的间接访问，但引用是对象的别名，且引用本身并不是一个对象，但指针是一个对象，它存储另一个对象的地址。 引用在初始化后无法修改其本身绑定的对象，指针可以在生命周期内修改它所指向的对象。 Other Pointer Operations 指针可以用来作为判断条件，如果指针为0（空指针）则为false，任何非空指针都为true。 可以比较两个指针是否相同（== 或 !=），如果两个指针包含的地址是一样的，则两者相同。 如果用了非法的指针来作为判断条件或判断是否相同，结果是未定义的。 void* Pointers void*类型是一个可以包含任何类型的对象的地址的特殊类型。如下所示： 123double obj = 3.14, *pdd = &amp;obj;void *pv = &amp;obj;//pv can hold a pointer to any typepv = pdd; 但无法通过void*对其指向的对象进行操作，因为void*无法得知对象的具体类型，也就无法解释对象，如下： 1// cout &lt;&lt; (*pv) &lt;&lt; endl;//error,can't operate in the object void* addresses void*更多的是用来处理内存方面的工作。 Understanding Compound Type Declarations Defining Multiple Variables 如之前所述，引用和指针的定义是跟着变量名字的，因此可以在一个定义中同时定义普通变量，引用和指针。如: 1int i = 1024, *p = &amp;i, &amp;r = i &amp;和*符号可以写在类型后面，也可以写在变量前面，如下面两个式子是等效的： 12int* p;int *p; 但为了避免误解，即认为引用和指针的定义是跟着变量类型的，推荐使用第二种方式。 Pointers to Pointers 指针是内存中的一个对象，所以可以创建指针指向另一个指针对象，如下所示： 123456int ival = 1024;int *pi = &amp;ival;int **ppi = &amp;pi;cout &lt;&lt; &quot;Direct value is &quot; &lt;&lt; ival &lt;&lt; endl;//Direct value is1024cout &lt;&lt; &quot;Indirect value is &quot; &lt;&lt; *pi &lt;&lt; endl;//Indirect valueis 1024cout &lt;&lt; &quot;Double indirect value is &quot; &lt;&lt; **ppi &lt;&lt; endl;//Doubleindirect value is 1024 C++并没有限定指针的个数，因此可以进一步定义***pppi等。 Reference to Pointers 因为引用并不是一个对象，所以不可能存在引用的指针，但可能存在指针的引用，如下： 12345int i = 42;int *p;int *&amp;r = p;r = &amp;i; //make p point to i*r = 0; //make i's value to 0 重点是语句int *&amp;r = p，该语句的操作符比较多，为了很好理解，可以从变量名逐渐向外层读。变量名是r，离变量名最近的操作符是&amp;，因此r是一个引用，外层的操作符是*，因此r是指针的引用，再外层是int，所以r是int指针的引用。 const Qualifier 可以使用const限定词来限制一个变量在初始化后不会被改变。 Initialization and const const限定的变量必须被初始化，初始化的语句可以是任何复杂的表达式，且用于初始化的变量并不一定要是const的。 const变量的初始化如下所示： 12345const int kk = getSize();// const int k; //error, const value must be initializedint i = 42;const int ci = i;int j = ci; 其中修饰变量$ci$的const限定符，只是表明变量$ci$不能会修改，用于初始化的$i$仍然能被修改，使用$ci$初始化的j也仍然能被修改。 By Default, const Objects Are Local to a File 对于const限定的变量，大多数编译器在编译的过程中会将相关的代码直接修改为限定的值，如下代码： 1const int bufSize = 512; 在代码中使用bufSize的地方在编译后都会被修改为512。 也因此，在不同的文件中，可以定义多个同名的const变量，因为const的作用域是仅局限在本文件中的。普通的非const的变量则不行，它们只能在某一个文件中被定义一次，其他文件中只能声明。 而需要在多个文件中公用一个const变量时则需要用到extern关键字，如下所示： 1234567//In file Chapter2Const.hint getSize() { return 42; }extern const int bufSize = getSize();//In file Chapter2_VariablesAndBasicType.cppextern const int bufSize;cout &lt;&lt; &quot;value is: &quot; &lt;&lt; bufSize; //value is: 42 Reference to const 将有限定词const的引用成为const reference，但这个称呼有的时候会造成干扰，实际上应该的表达时reference to const。因为严格意义上，所有的引用本身在初始化后都是无法修改的（无法绑定至别人的变量），所以所有的引用都是const的。 一个const变量的引用必须是const reference，否则就可以通过普通的引用来修改const变量。示例如下： 1234const int ci = 1024;const int &amp;r1 = ci;// r1 = 42; //error,ri is reference to a const variable// int &amp;r2 = ci; //error, reference to a const variable mustbe const Initialization and Reference to const 在之前的引用章节中，提到引用类型必须与被引用的对象类型一致。 这里将阐述第一个意外，一个const reference可以绑定至任意其他可以被转换的变量和表达式（如非const的变量，字面值，类型不同但可转换的变量等），如下所示： 1234567int i = 42;double dval = 3.14;const int &amp;r1 = i;const int &amp;r2 = 42;const int &amp;r3 = r1 * 2;const int &amp;r4 = dval;// int &amp;r5 = i * 2;//error, plain,nonconst reference must match type 如语句const int &amp;r4 = dval，编译器实际上将初始化过程转换为了类似于如下的语句： 12const int temp = dval;const int &amp;r4 = temp; 因为r4是const reference，所以它不会修改绑定的对象，因此绑定的对象是临时变量也没有问题。而对于普通引用来说，如果执行了同样的操作，那后续对普通引用的操作就变成了操作一个临时变量了。 A Reference to const May Refer to an Object That is not const const Refernece只是限定了不能通过该引用来修改绑定的参数，但参数本身是否能修改并不限定，如下代码 1234567int i = 42;int &amp;r1 = i;const int &amp;r2 = i;cout &lt;&lt; &quot;value is &quot; &lt;&lt; r2 &lt;&lt; endl; //value is 42r1 = 0;// r2=0;//error,can't change const referencecout &lt;&lt; &quot;value is &quot; &lt;&lt; r2 &lt;&lt; endl; //value is 0 Points and const 指向const变量的指针也必须是const类型的指针。对于指向const变量的指针而言，也可以指向非const的变量，但仍然不能绑定至类型不同的变量和字面值。如下所示： 1234567const double pi = 3.14;// double *ptr = &amp;pi;//error,pointer must be pointer to constconst double *cptr = &amp;pi;// *cptr = 42; //error,can't modify const valuedouble dval = 3.14;cptr = &amp;dval; //can pointer to different variable// const int *iptr = &amp;dval;//error,can't point to differnet type pointer to const只是限制了不能通过该指针对变量进行修改（这一点如同const refernece）。但是对指针本身的值可以修改（reference不行，无论是不是const的）。 const Pointers 如果要限定指针本身的值不被修改，可以使用const Pointers。const Pointer是在指针符号*后加上const。 const pointers必须初始化。 $$ \\begin{cases} \\text{pointer to const} &amp; \\text{不能通过该指针修改绑定的内容} \\\\ \\text{const pointer} &amp; \\text{不能修改指针本身} \\end{cases} $$ 如下代码所示： 123456789101112int errorNum = 0, warningNum = 0;// int *const curErr;//error, must be initialized.int *const curErr = &amp;errorNum;// curErr = &amp;warningNum; // can not change pointer value*curErr = 1;const double pi = 3.14;double p = 3.1415;const double *const pip = &amp;pi;// pip = &amp;p; //error,can not change pointer value// *pip = 2.0; //error,can not const variable value} Top-Level const 使用术语top-level const来表示本身是const,使用术语low-level const表示指向的值是const类型。 更宽泛的说，任何类型都可以是top-level const的，复合类型如引用和指针可以是low-level const的。而指针与其他类型不同，可以同时是top-level和low-level的const。 当拷贝top-level const类型的变量时，top-level const属性会被无视。而low-level const则必须满足，即被拷贝的对象和接纳拷贝数据的对象都必须有相同的low-level const属性或者它们的类型可以转换，通常non-const可以转换至const，但是const不能转换至non-const。 top-level const和low-level const的测试代码如下： 123456789101112int i = 0;int *const pi = &amp;i; //pi is top level constconst int ci = 42; //top level constconst int *p2 = &amp;ci; //low level const// int *p3 = p2; //error,differnt low level const,and const can't convert to nonconstconst int *const p4 = p2; //both top and low level constconst int &amp;r1 = ci; //low level const// int &amp;r2 = ci; //error,differnt low level const,and const can't convert to nonconsti = ci; //high level const of ci is ignoredp2 = p4; //high level of p4 is ignoredp2 = &amp;i; //although different low level const,but nonconst can convert to constconst int &amp;r3 = i; //although different low level const,but nonconst can convert to const constexpr and Constant Expressions //TODO Dealing with Types Type Aliases 类型别名（Type Aliases）是用来给另一个类型定义一个新名字。可以用typedef关键字和using关键字（C++11特性）。 12345typedef double wages; //wages is a synonym for doubleusing base = wages; //base is a synonym for wages(double)base b = 3.14;wages w = b;cout &lt;&lt; b &lt;&lt; &quot; &quot; &lt;&lt; w &lt;&lt; endl;//3.14 3.14 Pointers, const, and Type Aliases 也可以对类型的指针使用别名，如下所示： 12345678int value1 = 15, value2 = 20;typedef int *pInt;typedef const int *cpInt;const pInt p = &amp;value1;//equals to int *const p=&amp;value1;cpInt cp = &amp;value1;//equals to const int *cp=&amp;value1;// *cp = 20; //error, cp is pointer to const int*p = 20; // p is int* const// p = &amp;value2; //error,p is int * const 需要注意分辨指针别名的类型，如在上例中，定义了pInt类型为pointer to int，那么const pInt还是修饰指针的，即其类型应该是int * const,为const pointer to int The auto Type Specifier auto关键字是C++11的特性，可以使用auto来让编译器自动识别变量的类型。变量的类型是由初始化数值决定的。即使用了auto的话，必须对变量进行初始化。 C++是静态语言，所以auto只是让编译器识别出变量类型，但变量类型在运行时仍然是不可改变的。 在同一个声明语句中，auto必须指代同一个类型，如下： 12auto i = 0, *p = &amp;i; //i is int, p is int*// auto sz = 0, pi = 3.14; //error, sz is int but pi is double Compound Types,const,and auto 在复合类型下，编译器并不能保证auto关键字解析出的数据类型与初始值的类型一致。 如使用引用来初始化auto类型，会得到引用类型绑定的值的类型。而且auto类型会无视top level const,如果要保留的话需要显示的使用const，但当对top level const使用引用时，top level const不会被无视。 1234567891011int i = 0, &amp;r = i;auto a = r; //a is int not int reference because r is alias for iconst int ci = i, &amp;cr = i; //ci is const int,cr is const int referenceauto b = ci; //b is intauto d = &amp;i; //d is int*auto e = &amp;ci; //e is const int *auto &amp;g = ci; // g is const int reference// auto &amp;h=42;//errorconst auto &amp;h = 42; //can bind const reference to literalauto &amp;m = i, k = ci; //although i is int while ci is const int,but the top-level constis ignored// auto &amp;n = i, *p2 = &amp;ci; //error,while using reference, top-level const is not ignored 有几个语句需要特别注意，首先是auto e = &amp;ci，这里对const int的ci使用了引用，所以const保留，即e类型为const int，同理还有auto &amp;g = ci,g也同样是const int reference。 还有语句auto &amp;m = i, k = ci，虽然i和ci的类型不同，但是因为top level const被无视，所以这里仍然可以放在一起被定义。而auto &amp;n = i, *p2 = &amp;ci中因为对ci使用了引用符号，所以top level const被保留，i和ci类型不同，因此无法在一起定义。 The decltype Type Specifier 有时希望编译器可以根据一个表达式的返回值来自动判定一个变量的类型，但却不希望用表达式的返回值来初始化变量。这时候可以使用decltype关键字，该关键字是C++11的特性，使用如下 1decltype(getSize_Literal()) size; 但需要特别说明的，当decltype传入的是变量时，decltype对top level const和引用的处理与auto不一样，auto默认会无视这些，但是decltype则全部保留，如 12345const int ci = 0, &amp;cj = ci;decltype(ci) x = 0; // x is const intauto xx = ci;//xx is intdecltype(cj) y = x; //y is int reference// decltype(cj) yy; //yy is int reference, must be initialized 上例中的y会被认为是int的引用所以必须要初始化，这也是C++语言中唯一的引用类型不表现为另一个变量的别名，而真的将其视为引用类型的情况。 decltype and Reference 当decltype传入的是表达式时，如果表达式返回的值可以作为赋值操作的左参数，那么decltype的判断类型将是返回类型的引用，如： 12345int i = 42, *p = &amp;i, &amp;r = i;decltype(r) b = i; //b is int referencedecltype(r + 0) bb; //bb is int,because r + 0 is a expression and result is literaldecltype(p) c; // c is int pointer// decltype(*p) cc;//error,*p is a expression and *p can be the left hand side of assignment,cc is int&amp; 如上式，如果想通过一个引用类型返回普通类型，将其写成返回字面值的表达式即可。且如上式中，p是参数，所以判断的类型是参数本身的类型即int指针，而*p是表达式，且返回的结果是int，因此最终结果是int &amp; 注意普通函数返回是字面值，如下函数看起来返回的是一个变量，但实际上是该变量值的字面值： 12345int getSize_Int(){ int i = 0; return i;} 因此形如decltype(getSize_Int()) size;,size的类型为Int,因为返回的字面值无法作为左参数。 另外在decltype中，如果普通参数外有额外的括号，则也会被认为是表达式，如： 12decltype(i) d; // d is uninitialized int// decltype((i)) dd;//error,(i) is expression and i can be left hand side, so dd is int&amp; Defining Our Own Data Structures Defining the Sales_Data Type 在类与结构体的定义主体后可直接声明对象，虽然通常不这样做。如下所示： 123456struct Sales_data{ std::string bookNo; unsigned units_sold = 0; double revenue = 0.0;} accum, trans, *salesptr; 但通常将类与结构体的定义和相关对象的声明分开，如下所示： 12345678struct Sales_data{ std::string bookNo; unsigned units_sold = 0; double revenue = 0.0;};Sales_data accum, trans, *salesptr; Class Data Menbers 结构体中的变量如果没有初始值，将会默认初始化。 而如同double revenue = 0.0这样在类的内部定义变量时直接赋予初值，称为类内初始化（in-class initializer）。这也是C++11的特性。 Using the Sales_data Class 无重要内容 Writing Our Own Header Files 通常类是在函数外定义的（在19.7节可以看到在函数内定义类的方法）。 为了保证类的定义在每个文件中是相同的，在头文件中定义类。通常来说头文件的名字与其中定义的类名字相同。 因为头文件在多次引用（include），所以必须有一个方式可以保证即使头文件多次被引用，类的定义也不会重复。 A Brief Introduction to the Preprocessor 通常保证头文件可以被安全多次引用的方法是预处理器（preprocessor）。C++的预处理器继承自C语言，是一个在编译器前运行的程序，它可以修改部分源码内容。 当预处理器看到#include xxx时，它会将#include xxx替换为指定头文件中的内容。 C++使用预处理器来定义文件保护符（Header guards），预处理器变量有两个可能的状态，定义（define）和未定义（undefined）。 #define关键字加上一个名字可直接将这个名字定义为预处理变量。同样，预处理器还有两个关键字来判断变量是否被定义，#ifndef和#ifdef，前者在变量未定义时为true，后者在变量定义时为true。 注意#define的作用域是文件，所以使用该方法只能保证在同一个文件内，不会多次include同一个文件。但无法保证整个程序只include一次。如程序有多个CPP文件，每个文件都include某h文件，且该文件内有定义（非声明）参数，那么同样会造成重复定义。 因此，尽量不要在头文件中进行任何函数或变量的定义。除非是内联函数的定义。 当#ifndef和#ifdef为true的情况下，它们后面的代码会一直执行，直到遇到#endif关键字。 如一个带有文件保护符的头文件如下： 123456789101112131415#ifndef SALES_DATA_H#define SALES_DATA_H#include &lt;string&gt;using namespace std;struct Sales_data{ std::string bookNo; unsigned units_sold; double revenue;};#endif 在第一次引入该头文件时，还没有定义过SALES_DATA_H，所以ifndef为true。但第二次引入时因为#define语句的执行，ifndef为false，即之后的语句不会再被执行，也就不会有类的重复定义。 预处理器变量的作用域与C++变量的作用域不同，预处理器变量的名称必须在整个程序中都是独一无二的。通常来说为了避免重复，都根据头文件的名字对预处理器变量取名，且一般都是全大写。 虽然不是强制规定，但建议每个头文件都带有文件保护符。 引用： Cpp Primer 5th Aug.2012 Latin-1字符集","link":"/CPPPrimer-Chapter2-Notes/"},{"title":"《C++ Primer》 第三章笔记","text":"《C++ Primer》 第三章笔记。 第二章介绍的是C++中的内建类型，这一章则是会介绍C++标准库中的一些重要类型。 Chapter 3 String, Vectors, And Arrays Namespace using Declarations 可以使用using &lt;namespace&gt;::&lt;name&gt;的方式定义在命名空间中的一个函数或变量，注意一个using命令符只能对应一个名字，如下式 123456789101112131415161718using std::cin;using std::cout;using std::endl;void voidTestNamespace();int main(){ voidTestNamespace();}void voidTestNamespace(){ cout &lt;&lt; &quot;Enter two number&quot; &lt;&lt; endl; int v1, v2; cin &gt;&gt; v1 &gt;&gt; v2; cout &lt;&lt; &quot;The sum is &quot; &lt;&lt; v1 &lt;&lt; &quot; and &quot; &lt;&lt; v2 &lt;&lt; &quot; is &quot; &lt;&lt; v1 + v2 &lt;&lt; endl;} Header Should not include using Declarations 如之前所述，预处理器实际上是把#incldue语句替换为头文件中的内容，所以如果在头文件中使用了using声明，那么所有引用了该头文件的文件都会使用该using声明。 这可能会造成意想不到的情况发生，所以应该尽量避免在头文件中使用using声明。 Library string Type 使用C++标准库的string前，应该首先引入string，如下 12#include &lt;string&gt;using std::string; Defining and Initializing strings 初始化String的方法如下表所示： 实例代码 描述 string s1 默认的初始化，s1是空字符串 string s2 s2是s1的拷贝 string s2 = s1 与上式相同 string s3(“value”) s3是字符串字面值的拷贝，不包括最后的空字符 string s3 = “value” 与上式相同 string s4(n,‘c’) 用n个’c’来初始化s4 如果用string字面值来初始化string类型，字面值最后的空字符是不会被拷贝进string的，如上表中，&quot;value&quot;是字面值，其长度为6，而通过&quot;value&quot;初始化的s3，长度为5，如下代码验证： 123456string s3(&quot;value&quot;);string s4 = &quot;value&quot;;char str[] = &quot;value&quot;;cout &lt;&lt; sizeof(str) / sizeof(*str) &lt;&lt; endl; //6cout &lt;&lt; s3.length() &lt;&lt; endl; //5cout &lt;&lt; s4.length() &lt;&lt; endl; //5 Direct and Copy Forms of Initialization 当使用=进行初始化的时候，实际上编译器执行的是拷贝初始化(Copy Initialize)，当不使用=时，是直接初始化（Direct Initialization）。 上表中，string s2 = s1和string s3 = &quot;value&quot;是拷贝初始化，其他的都是直接初始化 Operations on strings Reading and Writing strings 下表为可以对string进行的操作： 操作代码 解释 os &lt;&lt; s 输出结果到os,返回os is &gt;&gt; s is的结果到s，返回is。is的数值以whitespace分隔 getline(is,s) 读取is中的一行，返回is s.empty() s是否为空 s.size() s中的字符数 s.length() s中的字符数，与size是同义api，返回的结果相同 s[n] 去s中index为n的字符 s1 + s2 返回一个新string,值为s1和s2的结合 s1 = s2 将s1中的值替换为s2的值 s1 == s2 s1和s2是否相同 s1 != s2 s1和s2是否不同 &lt;,&lt;=,&gt;,&gt;= s1和s2的大小，根据字典规则排序 其中is &gt;&gt; s是以whitespace分隔的（空格，换行，tab），当读到whitespace时一个读取便结束（不包括whitespace），如下所示 1234string s1, s2;cin &gt;&gt; s1 &gt;&gt; s2; //input is &quot; Hello World! &quot;cout &lt;&lt; &quot;s1 is &quot; &lt;&lt; s1 &lt;&lt; endl; //Hellocout &lt;&lt; &quot;s2 is &quot; &lt;&lt; s2 &lt;&lt; endl; //World! 可以看到用cin的话，是无法读取输入中的空格的，如果需要读取空格，建议使用getline，如下所示： 123456789101112string line;while (getline(cin, line)){ cout &lt;&lt; &quot;result is &quot; &lt;&lt; line &lt;&lt; endl;}/*$ ./a.exe123 456 789result is 123 456 789 Hello World result is Hello World */ getline以换行符进行分割，在Windows中输入回车即可，当getline读取到换行符后即会停止，读取的结果不包含换行符，即如果一行的开头便是换行符，则这次读取的结果为空字串。 又因为getline返回的也是stream类型，所以同样可以作为判断条件。 The string::size_type Type string.size()方法返回字符串中的字符数，但是返回的结果并不是int或者unsigned，而是string::size_type。 string类和其他大部分的库类都定义了伴侣类型(companion type)，string::size_type就是其中一个。int之类的内建类型是硬件相关的，即不同的硬件会有不同的结果，而伴侣类型则是机器不相干的实现。 string::size_type内部的细节书中未提及，但是它是大到足够容纳任何长度字符串的unsigned类型。也因为是unsigned，所以要注意表达式中signed int到unsigned int的隐式转换，如 123456789int n = -3;if (n &lt; s3.length()) cout &lt;&lt; &quot;n is smaller&quot; &lt;&lt; endl;else cout &lt;&lt; &quot;s3 length is smaller&quot; &lt;&lt; endl;/*s3 length is smaller&quot;*/ 直觉上，n是负数，而s3的长度必然是正数，所以n一定小于s3的长度，但实际上因为n被转换为了unsigned int，所以是一个非常大的数（$2^32-3$）。因此最终的结果是s3的长度更小。 在C++11中，可以通过auto关键字来避免每次都手动的输入伴侣类型（通常比内建类型长，所以相对不太容易输入），如 1auto len = line.size() Adding Literals and strings string标准库允许将字符字面值和字符串字面值转换为string字面值。 但如果需要用+操作符将字面值和string类型合并的时候，必须保证操作符的至少一端是string类型，如下 12345string s1 = &quot;hello&quot;, s2 = &quot;world&quot;;string s3 = s1 + ',' + s2 + &quot;\\n&quot;;cout &lt;&lt; s3;// string s4 = &quot;Hello&quot; + &quot;world&quot;; //error,both sides of + are literalsstring s4 = s1 + &quot;,&quot; + s2; //ok, s1 + &quot;,&quot; return string Dealing with the Characters in a string 在标准库的cctype头文件中定义了许多关于字符的函数。 cctype实际上是从C标准库中继承来的，在c中命名为ctype.h。通常而言，在C中的标准库会被命名为c&lt;Name&gt;.h，如果这个库被移植到到C++，则会被命名为cc&lt;Name&gt;。 C和C++在很大程度上是通用的，在C++的移植版本中主要变换是将所有的函数和变量会被移到std命名空间下。如果直接使用C版本的标准库也是可以运行的，但是推荐还是使用C++版本，这样可以保证标准库命名空间的统一。 cctype中常用的函数如下： 代码实例 解释 isalnum © c是否是字母或者数字 isalpha © c是否是字母 iscntrl © c是否是控制字符 isdigit © c是否是数字 isgraph © c是否是可显示的（不包括空格） islower © c是否是小写的 isprint © c是否是可显示的（包括空格） isupper © c是否是大写的 ispunct © c是否是标点符号 isspace © c是否是空白字符（空格，tab，vertical tab,返回，换行符等） isxdigit © c是否是十六进制字符 tolower© 将c从大写切换为小写 toupper© 将c从小写切换为大写 Processing Every Character? Use Range-Based for 可以使用Range for来改变字符串中的每个字符，Range for结构如下 12for (declaration : expression) statement 如需要判断字符串中的每个字符是否是标点符号，可以通过如下代码： 1234567891011string s(&quot;Hello World!!!&quot;);decltype(s.size()) punct_cnt = 0; //type is size_tfor (auto c : s){ if (ispunct(c)) ++punct_cnt;}cout &lt;&lt; &quot;There are &quot; &lt;&lt; punct_cnt &lt;&lt; &quot; punctuation characters in &quot; &lt;&lt; s &lt;&lt;endl;/*There are 3 punctuation characters in Hello World!!!*/ 在使用range for的时候，为了避免数值的拷贝，可以使用引用，并且在只访问数据的情况下，为了避免对值进行修改，可以使用const reference，如下： 12345for (const auto &amp;c : s){ if (ispunct(c)) ++punct_cnt;} Using a Range for to Change the Characters in a string Range for实际上是返回值的拷贝，如上节的例子中在每次迭代的情况下，是将str中下个字符拷贝至c中。因此如果需要通过Range for修改string中的数值，就需要使用引用，如下是将字符串中的每个字符转换为大写的代码： 12345678910for (auto &amp;c : s){ c = toupper(c);}cout &lt;&lt; &quot;result is &quot; &lt;&lt; s &lt;&lt; endl;/*HELLO WORLD!!!*/ Using a Subsctipt for Iteration 可以使用下标（[&lt;index&gt;]）取string中的每个字符。使用下标返回的并不是拷贝，而直接是string中的数值，所以可以直接进行修改，并不需要引用，如下是使用下标来将每个字符改为大写： 123456789string s(&quot;Hello World!!!&quot;);for (decltype(s.size()) i = 0; i != s.size(); i++){ s[i] = toupper(s[i]);}cout &lt;&lt; &quot;result is &quot; &lt;&lt; s &lt;&lt; endl;/*HELLO WORLD!!!*/ Library vector Type Vector是对象的集合，所有的对象都必须有相同的类型。Vector并不是一个具体的类，而是一个类模板。 模板可以被视为是编译器生成函数或者类的指导，编译器使用模板生成函数和类的过程称为实例化（Instantiation）。当使用模板时，必须提供想要编译器创建的函数或类类型。在模板后跟上一对尖括号，在尖括号内部加上想要创建的类型，如vector&lt;int&gt;。 Vector中可以容纳绝大部分的类型，无论是内建类型还是自定义的类型，但是不能包含引用，严格严格来说引用并非是对象。Vector中的对象也可以是另一个Vector，在老版本中嵌套Vector的尖括号中必须带有空格，如vector&lt;vector&lt;int&gt; &gt;，但在C++11中不需要如此，直接写成vector&lt;vector&lt;int&gt;&gt;即可。 Defining and Initializing vectors Value Initialization and Default Initialization 首先要说明值初始化（Value Initialization）和默认初始化（Default Initialization）的概念。 在默认初始化情况下，如果变量声明在函数外，一个变量将获得其初始值。而在函数内，内建类型的值是未定义的。 在值初始化情况下，无论变量声明在函数内外，它都会获得其初始值。 定义和初始化vector的方法如下所示： 示例代码 解释 vector v1 vector中的元素类型为T，v1为空 vector v2(v1) v2中包含有v1中每个元素的拷贝 vector v2 = v1 与上式一样 vector v3(n,val) v3中有n个元素，每个元素的值都是val vector v4(n) v4中有n个元素，每个元素都是T的默认值 vector v5{a, b, c} 如果a,b,c与T类型匹配，则v5包含a,b,c三个元素（不匹配的情况在下面有详细说明）。 vector v5 = {a, b, c} 与上式相同 vector的创建同样分类为拷贝初始化和直接初始化，定义和string中的初始化一样，如vector&lt;T&gt; v2 = v1和vector&lt;T&gt; v5 = {a, b, c}为拷贝初始化，其他的都为直接初始化。 在初始化中，如果使用的是括号(())，则括号中的值为vector中元素的数量，所以括号内的值必须是自然数。如果使用的是大括号（{}），则会尝试将其中的值作为vector的元素，如下所示： 123456789101112131415vector&lt;int&gt; intList_1(10);// vector&lt;string&gt; intList_1(&quot;abc&quot;);//errorvector&lt;int&gt; intList_2{10};vector&lt;int&gt; intList_3(10, 1);vector&lt;int&gt; intList_4{10, 1};cout &lt;&lt; &quot;vector_1 size is &quot; &lt;&lt; intList_1.size() &lt;&lt; endl;cout &lt;&lt; &quot;vector_2 size is &quot; &lt;&lt; intList_2.size() &lt;&lt; endl;cout &lt;&lt; &quot;vector_3 size is &quot; &lt;&lt; intList_3.size() &lt;&lt; endl;cout &lt;&lt; &quot;vector_4 size is &quot; &lt;&lt; intList_4.size() &lt;&lt; endl;/*vector_1 size is 10vector_2 size is 1vector_3 size is 10vector_4 size is 2*/ 式子vector&lt;T&gt; v4(n)中，进行的是值初始化。类型T必须含有默认初始化值，否则vector的初始化会失败。 但如果使用的是大括号，而且大括号内的值与vector中的元素类型不匹配，那么就无法将其作为vector中的元素，编译器会尝试将大括号替换为括号再次解析，如果仍然解析失败则会编译错误。如： 12345678910111213vector&lt;string&gt; v5{&quot;hi&quot;};// vector&lt;string&gt; v6(&quot;hi&quot;);//Error, value in parentheses must be digitvector&lt;string&gt; v7{10};vector&lt;string&gt; v8{10, &quot;hi&quot;}; //try to analyse as parentheses// vector&lt;string&gt; v9{10, 20};//Error, analyse as parenthese still not workcout &lt;&lt; &quot;v5 size is &quot; &lt;&lt; v5.size() &lt;&lt; endl;cout &lt;&lt; &quot;v7 size is &quot; &lt;&lt; v7.size() &lt;&lt; endl;cout &lt;&lt; &quot;v8 size is &quot; &lt;&lt; v8.size() &lt;&lt; endl;/*v5 size is 1v7 size is 10v8 size is 10*/ Adding Elements to a vector 使用push_back方法来增加vector中的元素。 在标准库中vector的实现下，vector的扩张是很高效的，所以通常来说不需要用括号的初始化方法来定义vector的大小，有的时候定义vector的大小反而会造成性能方面的影响。除了所有的元素都是相同值的情况，否则尽量避免使用括号的初始化方法。 Programming Implications of Adding Elements to a vector 在vector的循环中要注意使vector大小发生变化的操作。 如果操作时关于改vector的大小的，则无法使用在string节提到的range for来遍历vector。 Other vector Operations 对vector的操作如下表，绝大部分的含义与之前介绍的string的操作一样。 代码示例 含义 v.empty() 返回vector是否为空 v.size() 返回vector中元素的个数 v.push_back(t) 将一个元素加到vector最后，元素的值与t相同 v[n] 访问下标为n的元素 v1 = v2 将v1中的元素都替换为v2中元素的拷贝 v1 = {a,b,c} 将v1中的元素都替换为大括号内的元素 v1 == v2 v1与v2是否完全相同（元素个数，顺序，数值都相同） v1 != v2 v1和v2是否不同 &lt;, &lt;=, &gt;, &gt;= 顺序排列，按字典顺序 与string类似，size()操作返回的也是size_type，注意这里的size_type是属于实例化后的vector，如下： 12// vector::size_type size = 1; //errorvector&lt;int&gt;::size_type size = 1; 与string类似，下标操作[]也必须注意元素的存在，如果通过下标访问了不存在的元素，称为缓存区溢出错误（Buffer overflow）。通常可以通过使用range for来避免下标操作，也进而避免了缓存区溢出错误。 Introducing Iterators 除了Vector，标准库还定义了其他的容器（Container），所有的容器都包含迭代器操作（Iterator），但仅有部分的容器支持下标操作（[]）。 严格意义上，string并不是容器，但是string提供了非常多的容器操作。 迭代器有的像指针，同样提供了对象的非直接访问，而且同样也有合法和非法迭代器。一个合法的迭代器应该指向容器中一个元素或者指向容器最后的元素尾部的位置（position on past the last element）。 Using Iterators 通常来说，支持迭代器的类型都有两个成员迭代器，begin和end，begin指向容器中的第一个元素，end指向最后的元素尾部的位置，所以end指向的位置实际上并不是任何元素，end是一个用来标记容器尾部的指示器，通常将end迭代器值称为off-the-end迭代器。 如果一个容器是空的，则其begin和end指向的是同一个位置，都是off-the-end迭代器。 Iterator Operations 迭代器只支持部分操作，如下表所示： 代码实例 说明 *iter 返回迭代器指向的元素的引用 iter-&gt;mem 访问迭代器指向元素中的成员mem，等同于(*item).mem ++iter 迭代器指向下一个元素的位置 –iter 迭代器指向上一个元素的位置 iter1 == iter2 判断两个迭代器是否相同，两个迭代器都指向同一元素或都指向off-the-end时相同 iter1 != iter2 判断两个迭代器是否不同 因为end返回的并不是元素，所以不能被解引用或再使用++操作符。 因为并非所有的容器类都支持下标运算，且不一定支持关系比较，如&lt;和&gt;，所以C++程序会推荐使用迭代器并使用!=来进行循环操作，因为这样的实现可以适应任何的容器。 如下是两个等效的代码，一个对string使用下标，一个对string使用迭代器： 123456789101112131415161718string s(&quot;Hello World!!!&quot;);for (decltype(s.size()) i = 0; i != s.size(); i++){ s[i] = toupper(s[i]);}cout &lt;&lt; &quot;result is &quot; &lt;&lt; s &lt;&lt; endl;s = &quot;Hello World!!!&quot;;for (auto i = s.begin(); i != s.end(); i++){ (*i) = toupper(*i);}cout &lt;&lt; &quot;result is &quot; &lt;&lt; s &lt;&lt; endl;/*result is HELLO WORLD!!!result is HELLO WORLD!!!*/ Iterator Types 像size_type一样，含有迭代器的类型也定义了相应的同伴类型，iterator和const_iterator，且类型是属于实例化后的类，如vector&lt;int&gt;。iterator和const_iterator的关系如同pointer和pointer to const，后者只能读取指向的元素，但不能修改，而且对于const对象来说，必须使用const_iterator，如下： 12345678910111213vector&lt;int&gt; v1{1, 2, 3};const vector&lt;string&gt; v2{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;};vector&lt;int&gt;::iterator v1Iter = v1.begin();vector&lt;int&gt;::const_iterator v1Iter2 = v1.begin();const vector&lt;int&gt;::iterator v1Iter3 = v1.begin();// (*v1Iter2) = 2;//error,can't modify value through const_iterator++v1Iter2;// ++v1Iter3; //can't modify const iterator// vector&lt;string&gt;::iterator v2Iter = v2.begin(); //error, must beconst_iteratorvector&lt;string&gt;::const_iterator v2Iter2 = v2.begin();// const vector&lt;string&gt;::iterator v2Iter3 = v2.begin(); //error,still mustbe const_iterator 注意区分const iterator和const_iterator，前者类似于const pointer,指的是迭代器本身不能改变，即在初始化后无法指向其他元素，后者类似于pointer to const，指的是不能通过该迭代器修改指向的元素。 可以通过cbegin和cend来自动获取const_iterator，如 1auto cIter = v1.cbegin(); Combining Dereference and Member Access 可以使用-&gt;来取代(*).操作，如it-&gt;empty()等同于(*it).empty()。注意在使用后者时，必须加上括号。 如果去掉括号，*it.empty()指的是在it这个迭代器中寻找成员empty，无疑会造成编译错误。 Some vector Operations Invalidata Iterators 使用迭代器来执行循环操作时，也要注意循环操作造成容器大小变化时，很可能会造成循环的错误结果。 Iterator Arithmetic vector和string支持一些额外的迭代器操作，如下表所示： 代码实例 含义 iter + n 返回该迭代器后n个元素的位置 iter - n 返回该迭代器前n个元素的位置 iter += n 让迭代器指向后n个元素的位置 iter -= n 让迭代器指向前n个元素的位置 iter1 - iter2 获得两个迭代器之间的距离，即相距多少个元素 &lt;, &lt;=, &gt;, &gt;= 关系比较，比较迭代器指向元素的前后，越靠前越小 Arithmetic Operations on Iterators iter1 - iter2操作返回的是一个名为difference_type的signed int类型,该类型同样属于实例化后的容器类型。 Using Iterator Arithmetic 使用迭代器进行二分查找例子: 1234567891011121314string text = &quot;abcdefghijk&quot;;char toSearch;cin &gt;&gt; toSearch;auto beg = text.cbegin(), end = text.cend();auto mid = beg + (end - beg) / 2;while (mid != end &amp;&amp; (*mid) != toSearch){ if (toSearch &lt; (*mid)) end = mid; else beg = mid + 1; mid = beg + (end - beg) / 2;}cout &lt;&lt; (end != mid ? &quot;Found&quot; : &quot;Not Found&quot;) &lt;&lt; endl; Arrays Defining and Initializaing Build-in Arrays 数组同样也是复合类型（compound type）。 数组的大小是数组类型的一部分，所以必须在编译阶段就确定，也因此设定数组大小的值必须是const的，且数组的定义不能使用auto，如下： 12345678unsigned num = 42;const unsigned cnum = 42;int arr[10];// int arr2[]; //error,must indicate array size// auto aarr[] = {1, 2, 3}; //error,can not use auto// auto aarr[10]; //error,can not use auto// int arr2[num]; //error,num is not constint arr3[cnum]; 形如arr3[cnum]的式子，执行的是默认初始化，如果该式子出现在函数内，且其元素类型是内建类型，则值是未定义的。 因为引用并不是对象，所以也没有引用的数组。 Explicitly Initializing Array Elements 对数组可以使用列表初始化，在使用列表初始化的时候可以不指定数组的大小，此时数组的大小由列表内的元素数量决定。如果指定了数组大小，那么这个大小必须大于列表中元素的数量，在比列表元素数量大的情况下，数组中剩余的部分将进行值初始化。在不适用列表初始化的情况下，必须指定数组大小，如下： 123456const unsigned sz = 3;int ia1[sz] = {1, 2, 3};int a2[] = {0, 1, 2}; //array size is 3int a3[5] = {0, 1, 2}; //array size is 5, value is 01,2,0,0string sa[sz] = {&quot;hi&quot;, &quot;byt&quot;}; //size is 3,value is &quot;hi&quot;&quot;bye&quot; &quot;&quot;// int a4[sz] = {0, 1, 2, 3}; //error, list elements count is greater than array size Character Arrays Are Special 使用string字面值初始化char数组时要注意，string字面值最后是带有一个空白字符的，所以数组的大小应该是string字面值的大小+1。如： 1234char ca1[] = {'c', 'b', 'a'}; //size is 3char ca2[] = {'c', 'b', 'a', '\\0'}; //size is 4char ca3[] = &quot;abc&quot;; //size is 4// const char a4[6] = &quot;Daniel&quot;; //error,no space for \\0 No Copy or Assignment 数组是没有拷贝初始化和赋值的，如下所示： 12345int a[] = {0, 1, 2};// int aa[] = a; //error// int aa[] = a[]; //still errorint aa[3];// aa = a; //error,can't use assignment 某些编译器会允许数组的赋值，但仍然建议不要这样做，因为这不是C++标准的实现，在其他编译器中可能会引发问题。 Understanding Complicated Array Declarations 指针的数组和数组的指针的声明会看起来有点复杂，如下所示： 123456int array[10];int *ptrs[10]; // ptrs is an array of size 10 where elementstype is int*// int &amp;refs[10];//error,refs seems to be an array whereelemtns type is int&amp;, however reference is not objectint(*parray)[10] = &amp;array; //parray is a pointer point toan int array of size 10int(&amp;rarray)[10] = array; //rarray is a reference bind toan int array of size 10int *(*pparray)[10] = &amp;ptrs; //pparray is a pointer point toan int* array of size 10 当没有括号将*与变量名称合在一起时，*表示元素的类型，如int *ptrs[10]表示int*的数组，当有括号时，表示变量本身的类型，如int(*parray)[10] = &amp;array，表示parray是一个指针，指向int[10]。 引用符号同理。 Accessing the Elements of an Array 当使用一个参数来作为数组的下标值时，这个参数的类型应该时size_t。size_t是一个机器相关的unsigned type。size_t定义在头文件cstddef中，该头文件是从C语言的头文件stddef.h改写而来。 同样可以使用下标和range for对数组进行操作，如下使用下标访问元素，使用range for遍历所有的元素，代码的功能是将输入的数组分类，判断有多少是在0-9范围中，有多少在10-19范围中等： 1234567891011121314// unsigned scores[11];//warning,not defined valueunsigned scores[11] = {};unsigned grade;while (cin &gt;&gt; grade){ if (grade &lt;= 100) { ++scores[grade / 10]; }}for (auto c : scores){ cout &lt;&lt; &quot; &quot; &lt;&lt; c &lt;&lt; &quot; &quot;;} 注意必须对scores进行初始化。被初始化的第一条语句，执行的是默认初始化，而第二条语句unsigned scores[11] = {}使用的是值初始化。因此在函数内，后者可以保证所有的元素有确定的初始值（unsigned为0），而前者的值是未定义的。 如输入为33 1 44 112 100 22 77 76 75 ^Z，输出可能为1 0 268501010 1 16713577 0 898214646 32766 8 0 1，在这种情况下输出的结果是无法保证的。 而进行初始化的话，使用相同的输入，结果为1 0 1 1 1 0 1 2 0 0 1与预期结果相同。 在代码的最后通过range for遍历输出了scores中的元素，因为数组的大小是数组的一部分即必须在编译时确认，所以系统可以了解究竟有多少元素在数组中。 Pointers and Arrays 在C++中，数组和指针是紧密关联的。在绝大部分表达式中，当使用数组时，编译器会将其转换为对第一个元素的指针，如下所示： 12345678910111213string nums[] = {&quot;one&quot;, &quot;two&quot;, &quot;three&quot;};cout &lt;&lt; (*nums) &lt;&lt; endl;string *p = nums;string *pp = &amp;nums[0];if (p == pp) cout &lt;&lt; &quot;two pointers are the same&quot; &lt;&lt; endl;else cout &lt;&lt; &quot;they are different&quot; &lt;&lt; endl; /*onetwo pointers are the same*/ 在上例中，当使用nums实际上使用的是&amp;nums[0]，即对第一个元素的指针。 如使用auto也可以发现，编译器自动对数组进行了转换，如下代码： 12345678auto pnums = nums; // same as auto pnums = &amp;nums[0]// pnums = &quot;zero&quot;;(*pnums) = &quot;zero&quot;;cout &lt;&lt; &quot;first element is &quot; &lt;&lt; nums[0] &lt;&lt; endl;/*first element is zero*/ pnums的类型为string*，对pnums指向对象的操作即是对数组第一个元素的操作。 需要注意的是，当使用关键字decltype时，返回的仍然是数组类型，而不是对第一个元素的指针，如下： 12345678910decltype(nums) another = {&quot;abc&quot;, &quot;def&quot;};for (auto n : another){ cout &lt;&lt; &quot;value is &quot; &lt;&lt; n &lt;&lt; endl;}/*value is abcvalue is defvalue is*/ 如之前所述，数组的大小是数组类型的一部分，所以这里的another类型为string[3]，而列表初始化只给了两个元素，所以最有一个元素将默认为空string。 Pointers are Iterators 对于数组中元素的指针，其支持的操作与之前提到的迭代器支持的操作一样，包括++,--，通过*解引用，==,!=，关系判断，+= n等。 如可以通过数组来进行循环遍历，如下： 12345678910111213int arr[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};int *endPtr = &amp;arr[10]; //point to one past last elemmentcout &lt;&lt; &quot;value is: &quot; &lt;&lt; endl;for (int *i = arr; i != endPtr; i++){ cout &lt;&lt; (*i) &lt;&lt; &quot; &quot;;}cout &lt;&lt; endl;/*value is: 0 1 2 3 4 5 6 7 8 9*/ 在代码中使用了&amp;arr[10]来获取相当于off-the-end迭代器的指针，因为其指向了最后一个元素后面的位置。在C++11标准中，可以使用函数begin和end来获取对应的迭代器的指针，如下所示，判断两种方法取得的值是否相同： 12345678910int *oBeg = arr;int *oEnd = &amp;arr[10];int *beg = std::begin(arr);int *end = std::end(arr);cout &lt;&lt; &quot;Begin is &quot; &lt;&lt; (oBeg == beg ? &quot;the same&quot; : &quot;not thesame&quot;) &lt;&lt; endl;cout &lt;&lt; &quot;End is &quot; &lt;&lt; (oEnd == end ? &quot;the same&quot; : &quot;not thesame&quot;) &lt;&lt; endl;/*Begin is the sameEnd is the same*/ 下例是使用使用指针来判断两个数组是否相同的例子: 1234567891011121314151617181920212223242526272829bool CompareTwoArray(int *const pb1, int *const pe1, int *const pb2, int *const pe2){ if ((pe1 - pb1) != (pe2 - pb2)) return false; //Different length for (auto i = pb1, j = pb2; i &lt; pe1 &amp;&amp; j &lt; pe2; i++, j++) { if ((*i) != (*j)) return false; } return true;}void Exercise3_36(){ int arr1[]{1, 2, 3, 4}; int arr2[]{1, 2, 3, 4}; int arr3[]{1, 2, 3, 4, 5}; int arr4[]{1, 2, 3, 5}; cout &lt;&lt; CompareTwoArray(begin(arr1), end(arr1), begin(arr2), end(arr2)) &lt;&lt; endl; cout &lt;&lt; CompareTwoArray(begin(arr1), end(arr1), begin(arr3), end(arr3)) &lt;&lt; endl; cout &lt;&lt; CompareTwoArray(begin(arr1), end(arr1), begin(arr4), end(arr4)) &lt;&lt; endl; /* 1 0 0 */} Pointer Arithmetic 两个指针也是可以相减的，结果类型为ptrdiff_t，是一个硬件相关的类型，定义在cstddef头文件中。在不同的硬件上，它可能会被转换为不同的类型，如转换为long long等。 对不指向任何数组元素的指针进行访问，或比较两个不相关的指针是可以编译的，但其运行的结果是未定义的，如下所示： 123456cout &lt;&lt; &quot;value of end is &quot; &lt;&lt; *end &lt;&lt; endl;cout &lt;&lt; &quot;value of end next is &quot; &lt;&lt; *(++end) &lt;&lt; endl;int i = 0, sz = 42;int *p = &amp;i, *e = &amp;sz;cout &lt;&lt; (p &lt; e ? &quot;p is smaller than e&quot; : &quot;p is larger thane&quot;) &lt;&lt; endl; 这些操作的结果都是未定义的，不同的硬件，不同的编译器甚至不同的运行时间都会造成不同的结果。 Interaction between Dereference and Pointer Arithmetic 在对指针进行解引用时，括号的使用会影响结果,如下： 1234567int ia[] = {0, 2, 4, 6, 8, 10};cout &lt;&lt; *(ia + 4) &lt;&lt; endl;//Access the fifth elementcout &lt;&lt; *ia + 4 &lt;&lt; endl;//Access the first element and add 4to the result/*84*/ Subscripts and Pointers 可以对任何指针使用下标，但是大多数情况下，只有对指向数组中元素的指针使用下标才有意义，剩下的都是未定义的结果，如下： 1234567891011int ia[] = {0, 2, 4, 6, 8, 10};int *iaP = &amp;ia[2];cout &lt;&lt; *iaP &lt;&lt; endl; //Third elementcout &lt;&lt; iaP[-2] &lt;&lt; endl; //First elementcout &lt;&lt; *(iaP - 2) &lt;&lt; endl; //First element,same with lastexpressioncout &lt;&lt; iaP[-3] &lt;&lt; endl; //undefined resultint a = 2;int *ap = &amp;a;cout &lt;&lt; ap[0] &lt;&lt; endl; // acout &lt;&lt; ap[-1] &lt;&lt; endl; //undefined result 如上所示，通过解引用符号*对指针的访问，相当于使用[0]操作,因此如iaP[-2]和*(iaP - 2)是等效的。 C-Style Character Strings C++中的string字面值实际上是继承自C语言的。通过C++的string存储string字面值会将其转换为string类型，但如果要完全体现String字面值（C风格的String）本身的特性，可以使用char数组或者指针，如char str[] = &quot;ABC&quot;;，该数组的大小为4，因为还有在最后包含一个空字符。 在cstring头文件中，定义了对C-style的string操作的方法，如下表所示 代码实例 说明 strlen(p) 返回p的长度，不包含最后的空字符 strcmp(p1,p2) 判断两个字符串的大小，p1大于p2返回正数，小于p2返回负数，等于p2返回0 strcat(p1,p2) 将p2的内容添加到p1后，返回p1 strcpy(p1,p2) 将p2的内容拷贝到p1中，返回p1 对C-Style字符串（使用char数组或指针）进行判断，必须使用strcmp，如下所示： 123456789101112131415string s1 = &quot;A string example&quot;;string s2 = &quot;A different string&quot;;cout &lt;&lt; (s1 &gt; s2) &lt;&lt; endl;char cs1[] = &quot;A string example&quot;;char cs2[] = &quot;A different string&quot;;cout &lt;&lt; (cs1 &gt; cs2) &lt;&lt; endl; //wrong way,no meaning, iscomparing address of first elementcout &lt;&lt; strcmp(cs1, cs2) &lt;&lt; endl; //correct way/*111Although cs1&gt;cs1 also yield correct result,but it's nomeaning.*/ Caller is Responsible for Size of a Destination String 使用C-Stype字符串相关操作时需要额外的小心，如strcat和strcpy操作，并不会检查第一个参数，即装填最终结果的数组的大小，如果数组大小不满足，则会产生错误结果。 另外strlen的长度通常是通过找寻C-Style字符串最后的空字符来实现的，如果参数是一个没有空字符的C-Style字符串，那么结果是未定义的，如下： 123456char ca[]{'a', 'b', 'c'};cout &lt;&lt; strlen(ca) &lt;&lt; endl;/*21*/ 这里的21即是一个未定义的结果，在不同情况下结果会不同。在通常的编译器实现下，strlen会一直向后遍历内存，直到找到一块内存其中值未空白字符。 也正因为使用C-Style字符串需要额外的小心，一般现代C++程序推荐使用标准库中的string类型。 Interfacing to Older Code 在之前已经说明了，可以使用字符串字面值来直接初始化标准库中的string类型，更通常来说，可以使用任何最后是空白字符结尾的C-Style字符串直接转换为标准库中的string类型。如果C-Style字符串结尾不是空白字符，同样结果是未定义的。如下所示： 1234567891011121314string s = &quot;ABCD&quot;;cout &lt;&lt; &quot;value is &quot; &lt;&lt; s &lt;&lt; &quot;, size is &quot; &lt;&lt; s.size() &lt;&lt; endl;char cs[]{'A', 'B', 'C', 'D', '\\0'};string sc = cs;cout &lt;&lt; &quot;value is &quot; &lt;&lt; sc &lt;&lt; &quot;, size is &quot; &lt;&lt; sc.size() &lt;&lt;endl;char cs2[]{'A', 'B', 'C', 'D'};string sc2 = cs2;cout &lt;&lt; &quot;value is &quot; &lt;&lt; sc2 &lt;&lt; &quot;, size is &quot; &lt;&lt; sc2.size() &lt;&lt;endl;/*value is ABCD, size is 4value is ABCD, size is 4value is ABCD慅a, size is 7*/ 相反，无法直接将string转换为C-Style字符串，但可以通过string的成员函数c_str将结果转换为const char *。 需要注意的是，c_str返回的是字符串第一个元素的指针，且最后是由空字符结尾，并且标准库的string值改变的话，对应返回的数据也会自动改变，如下 1234567891011121314string s = &quot;ABCD&quot;;// char *cs3 = s; //error,can't direct convertconst char *cs3 = s.c_str();cout &lt;&lt; &quot;value is &quot; &lt;&lt; cs3 &lt;&lt; endl;s = &quot;DEFC&quot;;cout &lt;&lt; &quot;value is &quot; &lt;&lt; cs3 &lt;&lt; endl;string css = cs3;cout &lt;&lt; &quot;value is &quot; &lt;&lt; css &lt;&lt; &quot;, size is &quot; &lt;&lt; css.size() &lt;&lt;endl;/*value is ABCDvalue is DEFCvalue is DEFC, size is 4*/ Using an Array to Initialize a vector 如前所述，无法直接通过一个数组初始化另一个数组。同样的，无法通过一个vector直接初始化一个数组，但却可以通过指向数组元素的指针来初始化vector，如下所示 12345678910111213141516171819int intArr[]{0, 1, 2, 3, 4, 5};vector&lt;int&gt; intVec(begin(intArr), end(intArr));for (auto i : intVec){ cout &lt;&lt; i &lt;&lt; &quot; &quot;;}cout &lt;&lt; endl;intVec = vector&lt;int&gt;(intArr, intArr + 3);for (auto i : intVec){ cout &lt;&lt; i &lt;&lt; &quot; &quot;;}cout &lt;&lt; endl;/*0 1 2 3 4 5 0 1 2*/ 代码的前半段是使用begin和end函数来获取第一个元素指针和off-the-end指针，这样就是完整拷贝了数组的元素到新vector中。 后半段是直接使用指针操作，需要注意的是传入的第二个参数是指向vector最后一个元素的内存尾部的地址。因此代码中第二个参数为intArr+3，但实际上Vectr中最后一个参数值是*(intArr+2)。 创建的vector和原数组是不同的内存，因此创建完后，修改原数组并不会对vector中的元素造成影响。 Multidimensional Arrays C++并没有多维数组的概念，实际上多维数组的实现是通过数组的数组。如ia[3][4]可以看作是一个三行四列的数组。对于多维数组必须指定维度，不能初始值来推断。 Initializing the Elements of a Multidimensional Array 以下是初始化多维数组的几种方式： 123456int ia[3][4]; //without initialization;int ib[3][4]{}; //All elements will be 0int ic[3][4] = {{0, 1, 2, 3}, {4, 5, 6, 7}, {8, 9, 10, 11}};int id[3][4] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};int ie[3][4] = {{0}, {4}, {8}};int ix[3][4] = {0, 4, 8}; 其中ic和id的初始化结果是相同的，ie是初始化了每一行的第一个元素的值，ix的初始化了第一行的前三个元素，之后的元素都会被装填为0（进行了值初始化）。 Subscripting a Multidimentional Array 12int ia[3][4]= = {{0, 1, 2, 3}, {4, 5, 6, 7}, {8, 9, 10, 11}};int (&amp;row)[4] = ia[0]; 其中ia[0]表示第一行，是一个长度为4的int数组。row是一个绑定至长度为4的int数组的引用。 可以使用下标来遍历数组，如下所示： 123456789101112int ic[3][4] = {{0, 1, 2, 3}, {4, 5, 6, 7}, {8, 9, 10, 11}};for (int i = 0; i &lt; 3; i++){ for (int j = 0; j &lt; 4; j++) { cout &lt;&lt; ic[i][j] &lt;&lt; &quot; &quot;; }}cout &lt;&lt; endl;/*0 1 2 3 4 5 6 7 8 9 10 11*/ Using a Range for with Multidimentsional Arrays 当使用C++ 11标准的range for遍历多维数组时，需要注意除了最内侧的数组外，外层的遍历都需要用引用，如下： 123456789101112131415161718192021222324252627282930313233int ic[3][4] = {{0, 1, 2, 3}, {4, 5, 6, 7}, {8, 9, 10, 11}};for (auto &amp;row : ic){ for (auto &amp;col : row) { cout &lt;&lt; col &lt;&lt; &quot; &quot;; }}cout &lt;&lt; endl;for (auto &amp;row : ic){ for (auto col : row) { cout &lt;&lt; col &lt;&lt; &quot; &quot;; }}cout &lt;&lt; endl;// for (auto row : ic)// {// for (auto col : row)// {// cout &lt;&lt; col &lt;&lt; &quot; &quot;;// }// }// cout &lt;&lt; endl;/*0 1 2 3 4 5 6 7 8 9 10 11 0 1 2 3 4 5 6 7 8 9 10 11*/ 上面代码中，第一部分是两层循环都使用了引用，第二部分是之后外层循环使用了引用，第三部分是两层循环都没有使用引用。第一部分和第二部分都得到了理想的结果，而第三部分是无法通过编译的。 当外层循环的row不是引用时，编译器会自动将其转换为指针，即row的类型会变为int *，指向每一行数组的第一个元素，而对于指针没法使用range for，所以会出现编译错误。 Pointers and Multidimensional Arrays 首先要注意数组与指针的关系，式子int *ip[4]表示ip是一个长度为4的数组，其中元素类型为int*。式子int (*ip)[4]表示ip是一个指针，指向长度为4的数组。 可以使用指针来遍历数组，如下： 12345678910111213int ic[3][4] = {{0, 1, 2, 3}, {4, 5, 6, 7}, {8, 9, 10, 11}};for (int(*p)[4] = ic; p != ic + 3; ++p){ for (int *q = (*p); q != (*p) + 4; q++) { cout &lt;&lt; (*q) &lt;&lt; &quot; &quot;; }}cout &lt;&lt; endl;/*0 1 2 3 4 5 6 7 8 9 10 11 */ 注意外部循环中遍历p的类型是int (*)[4]，即指向大小为4的数组的指针，将ic赋值给p，是因为编译器会自动的将数组转换为指向第一个元素的指针，在外部循环中，第一个元素是数组。在内部循环中，初始值是(*p)，即是一个大小为4的数组，同样编译器会将其转换为第一个元素的指针，即int*。 如之前节所示，可以用begin和end简化代码，如下 123456789101112for (int(*p)[4] = begin(ic); p != end(ic); ++p){ for (int *q = begin(*p); q != end(*p); q++) { cout &lt;&lt; (*q) &lt;&lt; &quot; &quot;; }}cout &lt;&lt; endl;/*0 1 2 3 4 5 6 7 8 9 10 11 */ Type Aliases Simplify Pointers to Multidimensional Arrays 可以通过为int数组取一个别名来简化代码，如下 12345678910111213141516// using int_array = int[4];typedef int int_array[4];int ic[3][4] = {{0, 1, 2, 3}, {4, 5, 6, 7}, {8, 9, 10, 11}};for (int_array *p = ic; p != ic + 3; ++p){ for (int *q = (*p); q != (*p) + 4; q++) { cout &lt;&lt; (*q) &lt;&lt; &quot; &quot;; }}cout &lt;&lt; endl;/*0 1 2 3 4 5 6 7 8 9 10 11*/ 示例中，将长度为4的int数组称为int_array。示例中使用using和typedef是等效的。 引用： Cpp Primer 5th Aug.2012","link":"/CPPPrimer-Chapter3-Notes/"},{"title":"《C++ Primer》 第八章笔记","text":"《C++ Primer》 第八章笔记。 Chapter 8 The IO Library IO库定义了一系列读取和写入内建类型的操作。 The IO Classes 为了处理不同的IO操作，IO库定义了一系列的IO类型，他们集中在三个头文件中：iostream中定义列读取和写入流（Steam）的基本类型，fstream定义了读取和写入文件的类型，sstream定义列读取和写入字符串的类型。如下所示： 头文件 类型 iostream istream,wistream 从流中读取 ostream,wostream 向流中写入 iostream,wiostream 对流读取和写入 fstream ifstream,wifstream 从文件中读取 ofstream,wofstream 向文件中写入 fstream,wfstream 对文件读取和写入 sstream istringstream,wistringstream 从string中读取 ostringstream,wostringstream 向string中写入 stringstream,wstringstream 对string读取和写入 从表中可以看出，每个类型都有一个w版本，这个版本是针对宽字符处理的。如cin,cout,cerr都有对应的wcin,wcout,wcerr。 Relationships among the IO Types IO库用继承来实现对于不同类型的操作，如ifstream和istringstream都是继承自istream，因此所有对于istream的操作都可以使用在ifstream和istringstream上。 No Copy or Assign for IO Objects IO类型不支持赋值和拷贝操作，如 12ofstream out1, out2;// out1 = out2; //error, cannot assign stream objects 因此无法将IO类型作为函数的形参和返回值，通常是使用IO类型的引用来表示。读写IO类型都会改变其状态，所以通常也不会将传递的IO类型变为const reference。 Condition States 一旦一个问题发生，之后对于IO类型的操作就会失败，只有当IO类型处于无错误状态下才能进行流的读取和写入。因此，通常在代码中需要首先判断IO类型的状态，最简单的方法就是直接将io作为判断条件，如 1234while (cin &gt;&gt; word){ ///} Interrogating the State of a Stream 将IO作为判断条件，只能得到IO是否是正确的，但无法确定其究竟是因为什么原因导致失败。 IO类型定义了一系列机器相关的iostate类型来表示IO流的状态，每个IO类型都有自己的iostate类型，如istream::iostate，fstream::iostate。这个类型本质上是一系列的bits，所以可以通过位运算来进行操作。iostate类型和内置的函数操作如下所示： 类型与函数 说明 strm::iostate stm表示IO类型，strm::iostate表示该类型对应的状态 strm::badbit 一个不可自动恢复的错误发生了，通常是系统层面的错误 strm::failbit 一个可自动恢复的错误发生了，如读取string，赋值给int strm:: eofbit 遇到了文件结尾（end-of-file） strm:: goodbit 表示流没有错误，该值保证为0 s.eof() s是stm类型的实例，当eofbit位被置上时，该值为true s.fail() 当failbit位或badbit位被置上时，该值为true s.bad() 当badbit位被置上时，该值为true s.good() 当badbit,failbit和eofbit都没有置上时，该值为true， s.clear() 清空流的所有位，使其恢复正确状态，返回空 s.clear(flags) 清空flags位，flags为iostate类型，返回空 s.setstate(flags) 设置flags位，flags为iostate类型，返回空 s.sdstate 返回当前状态 通常来说，使用good()和fail()两个函数来判断流的状态。当将流作为判断条件时，实际上等同于调用了!fail()。要注意调用fail()并没有检查eofbit位，所以直接将流作为判断条件时，读取到文件末尾并不会停止，还会继续读取一次。 如下使用ifstream测试所示，文件内已有内容为123\\n456： 12345678910111213141516171819202122232425ifstream in(&quot;./Test.txt&quot;);while (in.good()){ in &gt;&gt; content; cout &lt;&lt; &quot;Read Content with good is &quot; &lt;&lt; content &lt;&lt; endl;}in.close();in.open(&quot;./Test.txt&quot;);cout &lt;&lt; endl;while (in){ in &gt;&gt; content; cout &lt;&lt; &quot;Read Content with condition is &quot; &lt;&lt; content &lt;&lt; endl;}/*Read Content with good is 123Read Content with good is 456Read Content with condition is 123Read Content with condition is 456Read Content with condition is 456*/ Managing the Condition State 如之前所述，可以对iostate类型进行位操作，如需要将failbit和badbit还原，但保留eofbit，可以使用以下语句： 1cin.clear(cin.rdstate() &amp; ~cin.failbit &amp; ~cin.badbit); Managing the Output Buffer 对于操作系统而言，将数据写入设备，可能是一个耗时的操作，所以通常操作系统会将数据先缓存起来，之后将多个数据合并再一起写入设备。 但这种缓存机制可能会导致Debug时的困扰，如程序意外终止时，缓存的数据并没有被输出，于是明明某个Debug语句已经运行，但因为数据没有刷新，导致被误以为并没有运行。 以下几种情况会让存储的数据被刷新，输出给设备： 当整个程序正常结束时。在main return的过程中，所有的输出缓存被刷新。 当缓存满时，会进行刷新。 当使用刷新操作符时，如endl，flush,ends。 可以使用操作符unitbuf设置IO对象，让输出IO对象的每一次操作都刷新缓存。默认情况下，cerr是已经被设置了unitbuf的。 如果输出IO对象被绑定至另一个IO对象，那么另一个IO对象无论进行了读还是写操作，都会刷新输出IO对象。默认情况下，cin和cerr都绑定了cout，所以无论是读和写这两个对象，都会刷新cout的缓存。 Flushing the Output Buffer 操作符endl会刷新缓存，并在增加一个换行符。 操作符ends会刷新缓存，并在增加一个空白字符。 操作符flush单纯刷新缓存。 123cout &lt;&lt; &quot;hi!&quot; &lt;&lt; endl;cout &lt;&lt; &quot;hi!&quot; &lt;&lt; flush;cout &lt;&lt; &quot;hi!&quot; &lt;&lt; ends; The unitbuf Manipulator unitbuf可以理解为一个开关，当设上时，每一次的输出操作都会立刻的刷新缓存。 1cout &lt;&lt; unitbuf; 可以通过nounitbuf关闭 1cout &lt;&lt; nounitbuf; Tying Input and Output Streams Together 当一个输入IO对象绑定输出IO对象时，任何对于输入IO对象的读取，都会刷新输出IO对象的缓存。 默认情况下，cin绑定给了cout，所以执行任何的cin &gt;&gt; xxx操作都会先刷新cout对象 关于绑定有两个操作函数，tie()和tie(&amp; o)，前者返回当前绑定的IO输出对象的指针，后者也返回当前绑定的IO输出对象的指针，然后将o作为新的绑定IO输出对象。如下所示： 123456789cin.tie(&amp;cout); //System already doostream *old_tie = cin.tie(nullptr);//old_tie is pointer to cout//Now cin is tied to nothingcin.tie(&amp;cerr);cin.tie(old_tie);//cin is tied to cout 注意，每个IO对象只能绑定给一个输出对象，所以上示代码中，cin最终绑定给了old_tie。但是一个输出对象可以同时被多个IO对象绑定，如cout同时被cin和cerr绑定。 File Input and Output 对于文件的流操作包含有三个类型： ifstream：读取给定文件 ofstream：写入给定文件 fstream：读取或写入给定文件 如之前所述，对于iostream的所有操作都可以用于fstream，而fstream还有一些特定的操作，如下所示： 操作 说明 fstream fstrm; fstream是fstream头文件中定义的类型，fstrm是实例，且没有打开任何的文件 fstream fstrm(s, mode); fstrm打开地址为s的文件，s可以是string，也可以是C风格的字符串，默认的mode与fstream的类型相关 fstream fstrm(s, mode); 指定打开文件的模式为mode fstrm.open(s) 打开地址为s的文件，mode与类型相关，返回空 fstrm.open(s,mode) 打开地址为s的文件，指定mode，返回空 fstrm.close() 关闭当前绑定的文件 fstrm.is_open() 检查绑定的文件是否被正确打开 Using File Stream Objects 无论是要写入还是读取一个文件，都需要定义一个文件流，然后使用该文件流打开文件。 当使用带有文件地址的文件流构造函数时，文件会被自动打开。如ifstream in(file)。 file为C风格的字符串，在C++11下，file还可以是string。 Using an fstream in Place of an iostream&amp; fstream作为iostream的派生类，如果一个函数的形参为iostream&amp;，则也可以传递fstream。 注意，因为IO操作不支持拷贝和赋值，所以函数的形参必然为引用。 The open and close Members open操作并不一定成功，当失败时其中的failbit位会被置上，所以通常来说，最好使用代码检查文件流的状态，如 1234ofstream out;out.open(file);if (out) ... 当文件流已经打开了一个文件，则该文件流无法直接打开其他的文件，必须先关闭前一个文件才行，如 1234ofstream out;out.open(file);out.close();out.open(file2); 一个文件，也无法被多个文件流打开，当需要另一个文件流操作时，需要先让使用该文件的文件流关闭文件，如： 123out1.open(&quot;./Test.txt&quot;);out1.close();in.open(&quot;./Test.txt&quot;); Automatic Construction and Destruction 当一个文件流对象离开了作用域时，它会被销毁，在销毁时会自动的给关闭当前绑定的文件。 File Modes 文件流的打开模式有以下几种： 模式 说明 in 作为程序的输入打开（读取文件） out 作为程序输出打开（写入文件） app 每一次写入前，定位到文件的最后 ate 在文件打开时，直接定位到文件的最后 trunc 删除文件的内容 binary 以位模式进行IO操作 ifstream默认以in模式打开。ofstream默认以out模式打开，且trunc位被置上，即输出时默认将文件内已有的内容删除的。fstream默认同时以in和out模式打开文件 主动设定模式，要以下限制： out只能在ofsteram和fstream类型时被置上 in只能在ifsteram和fstream类型时被置上 trunc只有在out模式下才能置上 app只能在trunc没有被置上时才能置上 ate和binary可以在任何文件流类型置上，且可以与其他的类型任意搭配。 Opening a File in out Mode Discards Existing Data ofstream模式默认是以out模式打开，且置上trunc位，所以如下的几种定义方式没有区别： 123ofstream out(&quot;file1&quot;);ofstream out2(&quot;file1&quot;, ofstream::out); // outand truncare implicitofstream out3(&quot;file1&quot;, ofstream::out | ofstream::trunc); 如果要保护文件的内容不被删除，有两种方法，一是置上app位，二是同时置上in和out位。如下： 123// to preserve the file’s contents, we must explicitly specify appmode ofstream app(&quot;file2&quot;, ofstream::app); // out is implicitofstream app2(&quot;file2&quot;, ofstream::out | ofstream::app); 注意in模式只能赋给ifstream和fstream，所以上示代码中是通过置上app位。 File Mode is Determined Each Time open Is Called 文件流的mode可以看作是与文件结合的，文件流的mode会在每次打开文件时重新指定。如果没有在重新打开文件时，没有显示的设置mode，则该文件会重新以默认的mode打开（不会保留打开前一个文件时指定的mode）。 如下测试，文件已有内容为123\\456： 123456789101112131415161718192021222324252627282930ofstream out1(&quot;./Test.txt&quot;, ostream::app);out1 &lt;&lt; &quot;\\n789&quot;;out1.close();in.open(&quot;./Test.txt&quot;);while (in.good()){ in &gt;&gt; content; cout &lt;&lt; &quot;Read Content with good is &quot; &lt;&lt; content &lt;&lt; endl;}in.close();cout &lt;&lt; endl;out1.open(&quot;./Test.txt&quot;);out1 &lt;&lt; &quot;\\n666&quot;;out1.close();in.open(&quot;./Test.txt&quot;);while (in.good()){ in &gt;&gt; content; cout &lt;&lt; &quot;Read Content with good is &quot; &lt;&lt; content &lt;&lt; endl;}/*Read Content with good is 123Read Content with good is 456Read Content with good is 789Read Content with good is 666*/ 可以看到out1，在创建时设置上了app位，所以没有擦除文件已有内容。但当其重新打开文件时，app位被清空，仍然是trunc被置上，文件已有内容被删除。 string Streams String流是把String看作一个IO流进行操作，定义在sstream头文件中，其中包括istringstream读取string，ostringstream写入string，stringstream可同时读取和写string。string流有以下特有的操作： 操作 说明 sstream strm 创建一个未绑定的string流 sstream stream(s) 创建一个绑定s拷贝的string流，s是string类型，该构造函数是explicit的 strm.str() 返回strm绑定的string的拷贝 strm.str(s) 将s的拷贝绑定至strm，返回空 Using an istringstream 因为sstringstream继承自iostream可以使用操作符，所以istringstream可以使用&gt;&gt;操作符，且如同cin中的&gt;&gt;一样，一次读取是以空白字符为结束的。如以下代码就是通过stringstream来从输入中读取数据： 1234567891011121314//morgan 2015 86255while (getline(cin, line)){ PersonInfo info; istringstream record(line); //Bind line to record record &gt;&gt; info.name; //Read one word,in this case, it's name // Read one word,in this case, it's phone, //If condition is false, means that there is no content while (record &gt;&gt; word) { info.phones.push_back(word); } people.push_back(info);} Using ostringstreams 同样的，ostringstream可以使用&lt;&lt;操作符，对ostringstream使用&lt;&lt;操作符类似于对string使用+=。如： 12345678ostringstream ssf;ssf &lt;&lt; &quot;123&quot; &lt;&lt; &quot; 456&quot;;cout &lt;&lt; ssf.str() &lt;&lt; endl;/*123 456*/ 引用： Cpp Primer 5th Aug.2012","link":"/CPPPrimer-Chapter8-Notes/"},{"title":"《C++ Primer》 序言与第一章笔记","text":"《C++ Primer》 序言与第一章笔记 因为之前已经对C++语言有一些了解，所以在笔记中不会事无巨细的罗列所有细节。 Preface Why Read This Book? 现代C++可以看作是由三个部分组成的： 低Level的语言，大部分都是继承自C 更高级的一些语言特性，让程序员可以定义自己的数据类型 使用高级语言特性实现的提供一些算法和数据结构的标准库 许多C++书籍的教学方式是从低Level的C语言特性开始，纯粹用C的特性来实现一些功能。在后期再用高级特性来重新实现这些功能，或直接使用标准库中的方法来代替实现。 这样教学的方法问题在于，首先低Level的C特性较为复杂繁琐，很多初学者在第一阶段就放弃。第二，在后期学会了高级特性后，之前所学的使用低Level实现的方法就要被替代，这一定程度上是浪费时间。 所以本书直接在介绍每一部分时都会尽量直接使用高级特性，不需要拘泥于C特性的一些细节。 Structure of This Book 本书的第一部分与第二部分是关于语言的基础。 第三部分与第四部分是关于如何让用户实现自己的数据类型，即C++语言的特性。第三部分较为基础，第四部分会深入一些特性。 Chapter 1 Getting Started Writing a Simple C++ Program 每个C++程序都必须有一个main函数，操作系统通过调用main函数来执行C++程序。 对于大部分操作系统来说，main函数返回的是状态指示器。返回0表示操作成功，非0的含义由操作系统决定，通常而言非0表示某个错误的发生。 Compiling And Executing Our Program 可使用Visual studio调试程序，或者使用命令行的g++来编译程序。g++编译下可使用 -o来指定编译后的文件名。 123g++ [-o &lt;BuildFileName&gt;] &lt;sourceFileName&gt;g++ -o test test.cpp A First Look at Input/Output C++中有提供IO功能的标准库，本书中大部分使用的是iostream库，其中istream类型表示输入，ostream类型表示输出。stream一词暗示了这些IO操作是可以连续的产生或消耗数据。 Standard Input and Output Objects istream类型对应的实例是cin，ostream对应的实例是cout，它们分别是标准输入和输出。iostream库也定义了一些cerr和clog输出实例，分别表示标准错误信息的输出和调试信息的输出 默认的，系统会将这些实例与正在执行程序的窗口联系在一起，即如果是输入，则从这个窗口中读取，如果是输出，则输出到这个窗口中。 如果需要避免每次调试时都手动在窗口中输出信息，可以使用文件重定向（File Redirection） 如通过g++编译出的程序名为a.exe，可以在命令行中通过下列命令实现文件重定向 1/a.exe &lt; input.txt &gt; output.txt 该命令的意思是将Input.txt中的文本都作为cin的输入数据，cout的输出数据都写入到output.txt中，这里的&lt;和&gt;即为文件重定向符。如其他Unix命令一样，输出时的&gt;表示会覆盖原文件的内容，如果想要追加内容，则通过&gt;&gt;操作符即可。 A Program that Uses the IO Library #include与头文件必须在同一行中，#include必须在函数外定义，通常而言都是将它放在文件开头的地方。 标准库的头文件，在调用时文件名放在&lt; &gt;中，不是库的头文件调用时文件名放在&quot; &quot;中 Writing to a Stream &lt;&lt;是输出操作符，操作符的返回的结果是左参数，即语句cout &lt;&lt; &quot;Hellow world&quot;返回的是cout对象。因此可以 使用&lt;&lt;操作符，如cout &lt;&lt; &quot;Hellow world&quot;&lt;&lt;&quot;!&quot; endl是在iostream中定义的一个特殊的参数，它不仅可以表示一行的结束，也会刷新当前设备的缓冲（Buffer），即保证当前程序所有产生的数据都会被写入到输出流中，而不是仍然在内存中等待写入。 当程序员使用输出流进行调试时，建议每句后都加上endl。因为程序意外崩溃的话，如果没有刷新缓冲的操作将会导致调试器对于程序在何处崩溃产生错误的判断。 Using Names from the Standard Library 所有标准库中的内容都在std命名空间下。 Reading from a Stream &gt;&gt;是输入操作符，如输出操作符一样，输出操作符的返回也是左参数，因此也可以连续使用&gt;&gt;操作符，如cin &gt;&gt; v1 &gt;&gt; v2。输入的数据会被依次读进输入操作符的右参数中。 数据可由空格或者换行来区分，如输入数据是12 13，则在上述代码中，V1的值为12，V2的值为13。 A Word about Comments 编译器会无视注释。 错误的注释不如没有注释，所以在修改代码后要及时的修改注释。 Kinds of Comments in C++ C++支持两种注释方式，单行注释（Single-line）和多行注释（Paired）。 单行注释以//开始，以换行结束 多行注释以/*开始，以/*结束。当使用多行注释时，建议每一行前都加上一个*号，这样可以快速的知道内容是在注释中，如下 1234/* * This is a comment * This is also a comment/* Comment Paris Do Not Nest 多行注释不支持嵌套，如下面这样写，最后一行的*/不会被认为是注释，因为在上一行的嵌套注释中，已经出现了*/,所以编辑器会认为注释在上一行已经结束。 12345/* * This is a comment * This is also a comment * /* Want to nest *//* 对于代码块，即使是需要注释多行，也建议通过多次使用单行注释来实现。因为很可能出现想要注释一大段代码时，其中的一部分已经被注释过了，那么如果都使用多行注释的话，就会出现嵌套。 Flow of Control The while Statement 与C类似 The for Statement 与C类似 Reading an Unknown Number of Inputs 如有代码 12while(std::cin &gt;&gt; value) sum += value; 当使用istream作为循环的判断条件时，如果stream是合法的，则循环将继续，否则循环结束。在istream中，如果遇到了end-of-file（不同操作系统定义不同）或者非法输入（将字符串赋值给int变量）则认为stream是非法的。 在Windows系统下，通过ctrl+z键入end-of-file，在Unix系统中，通常是通过control+d。 在C++程序中通常会遇到以下的语法错误： Syntax errors: 由操作符方面的错误造成，如少了操作符，没有写;符号等。 Type errors: 赋值过程不符合值的类型定义 Declaration errors: 使用变量前未定义该变量 最好是按报错误的顺序来修复错误，因为一个错误的发生可能会导致一系列错误的发生，在很多情况下修复了一个错误，后续的一系列错误将自动消失。 The if Statement 与C类似。 在c++中，=和==操作符都可以作为判断条件，所以编程时需要注意，不要误输入错误的操作符。 c++基本上是free-format语言，即语言编译过程并不会在意大括号，缩进，注释，换行这些信息的位置。 Introducing Classes 一个类定义一系列与这个类型相关的操作。 通常类的定义放在.h文件中，文件的名字与其中的类名字相同。也有程序员会使用.H，.hpp，.hxx来表示头文件，编译器通常不会在意文件后缀名，但是IDE有时会。 引用： Cpp Primer 5th Aug.2012","link":"/CPPPrimer-Preface-Chapter1-Notes/"},{"title":"《C++ Primer》 第六章笔记","text":"《C++ Primer》 第六章笔记。 关于函数的定义，函数参数的传递方式，函数重载，函数指针。 Chapter 6 Functions Function Basics Parameters and Arguments 函数的形参（Parameters）和实参（Arguments）是一一对应关系，但是编译器不能保证形参被初始化的顺序。 Function Parameter List 为了与C语言兼容，C++同样允许用void来作为形参的参数，如下 123void f2(void){} 参数的名字是可选的。但是如果没有设置参数名字，但因为参数没有名字所以无法在函数内部引用。但是未命名的参数还是需要指定实参的，如下： 123456void pareNoName(int, float fval){}// pareNoName(0.1f);//Although int doesn't have name, we still must assign itpareNoName(3, 0.1f); Function Return Type 函数返回的类型不能是数组类型，也不能是函数类型，但可以返回函数和数组的指针，以及函数的调用（相当于返回调用的函数的结果）。 Local Objects 对于一个变量而言，需要关注它的作用域以及生命周期。 在函数内部定义的变量称为局部变量，如果局部变量与全局变量有相同的名称，局部变量会隐藏全局变量的定义，如果想要调用全局变量，需要用到作用域符号::。 1234567891011121314int val = 2;void TestLocalObject(){ int val = 3; cout &lt;&lt; &quot;local val is &quot; &lt;&lt; val &lt;&lt; endl; cout &lt;&lt; &quot;global val is &quot; &lt;&lt; ::val &lt;&lt; endl; /* local val is 3 global val is 2 */} 全局变量的生命周期是从定义到程序终止，局部变量的生命周期是当退出了作用域。 Automatic Objects 函数的形参就是自动物体（Automatic Objects），它们在函数开始时被分配创建， 在函数终结时被释放。 Local static Objects 局部静态物体是在第一次被调用时创建，在程序终止时被摧毁，作用域在函数内部。如： 1234567891011121314151617181920212223242526int count_calls(){ static int ctr = 0; return ++ctr;}void TestStaticObjects(){ for (int i = 0; i != 10; ++i) { cout &lt;&lt; count_calls() &lt;&lt; endl; } /* 1 2 3 4 5 6 7 8 9 10 */} 静态的局部变量执行的是值初始化，因此即使是内建类型，它也会默认值，不会像普通的内建局部变量一样变成未定义的。 Function Declarations 如同变量一样，函数也只能被定义一次，但可以多次声明。 如果是函数声明，则使用分号取代函数主体，也因为声明并没有函数主体，所以所有的形参有没有名字都没有区别。 如 12void pareName(int val, float fval);void pareName(int, float); 一个函数的类型由函数名字，返回类型以及形参类型决定，函数的类型也成为函数原型(function prototype)。 Function Declarations Go in Header Files 函数的声明应该在头文件中，函数的定义在源文件中，这样如果后续要修改函数的声明，只需要改动一处即可。 在定义函数的源文件中，需要引入声明的头文件。 Separate Compilation Compiling and Linking Multiple Source Files 如我们将函数GetNum声明在头文件GetNum.h中，将函数的定义写在源文件GetNum.cpp中，将调用GetNum的语句写在源文件Chapter6_Functions.cpp中，则所有的文件内容如下： 12345678910111213141516171819202122//GetNum.hint GetNum();//GetNum.cpp#include &quot;GetNum.h&quot;int GetNum(){ return 10;}//Chapter6_Functions.cpp#include &lt;iostream&gt;#include &quot;GetNum.h&quot;using std::cout;int main(){ cout &lt;&lt; GetNum() &lt;&lt; endl;}/*10*/ 对于有多个源文件（CPP）文件的情况下，编译时要把所有的源文件都带上，源文件的顺序并不造成影响，如： 1g++ Chapter6_Functions.cpp GetNum.cpp 也可以单独编译（带上-c flag）某个源文件（必须是与其他源文件不依赖的），将其编译为.o文件，之后再编译其他依赖该源文件的文件时，只要带上.o文件，而不需要重新编译该文件，如下： 12g++ -c GetNum.cppg++ Chapter6_Functions.cpp GetNum.o Argument Passing 当调用函数时，实际上是用实参初始化了形参，初始化的过程与一般的参数初始化一样。而如果形参的类型是引用的话，那么会直接绑定至实参，否则的话初始化时会拷贝实参的值。 如果形参的参数是引用，称实参是引用传递（Paseed by reference或called by reference）。 如果形参的类型不是引用，那么实参会进行拷贝，称实参是值传递（Passed by value或called by value）。 Passing Arguments by Value 当形参是值传递时，修改函数中的局部变量并不会影响实参。 Pointer Parameters 指针与其他非引用的变量一样，形参会通过拷贝实参的值进行初始化。但是指针的值即是指向的对象，因此拷贝生成的形参与实参指向的是同一个变量，也因此通过形参修改对象也同样会影响实参指向的对象。 如： 1234567891011121314void Swap(int *val1, int *val2){ int temp = (*val1); *val1 = *val2; *val2 = temp;}void Exercise6_10(){ int val1 = 10, val2 = 5; cout &lt;&lt; &quot;Val 1 is &quot; &lt;&lt; val1 &lt;&lt; &quot;, Val2 is &quot; &lt;&lt; val2 &lt;&lt; endl; Swap(&amp;val1, &amp;val2); cout &lt;&lt; &quot;Val 1 is &quot; &lt;&lt; val1 &lt;&lt; &quot;, Val2 is &quot; &lt;&lt; val2 &lt;&lt; endl;} Passing Argument by Reference 使用引用传递就可以在函数内部修改实参的值，如 1234567891011121314void TestCallByReference(){ int val1 = 10, val2 = 5; cout &lt;&lt; &quot;Val 1 is &quot; &lt;&lt; val1 &lt;&lt; &quot;, Val2 is &quot; &lt;&lt; val2 &lt;&lt; endl; Swap(val1, val2); cout &lt;&lt; &quot;Val 1 is &quot; &lt;&lt; val1 &lt;&lt; &quot;, Val2 is &quot; &lt;&lt; val2 &lt;&lt; endl;}void Swap(int &amp;val1, int &amp;val2){ int temp = val1; val1 = val2; val2 = temp;} Using Reference to Avoid Copies 函数可以通过将形参设置为引用类型来避免拷贝的过程，进而可以提升性能。 且尽量使用const reference，本章的后小节会进行说明。 Using Reference Parameters to Return Additional Information 一个函数只可以返回一个值，在需要返回多个参数的时候，也可以通过引用，将要返回的参数作为形参的一部分传递进函数，并在函数内部修改成结果的值。 const Parameters and Arguments 如普通的参数初始化一样，当使用实参来初始化形参时，top-level的const会被无视，如： 123456789101112131415161718void TestConstParametersAndArguments(){ const int ci = 3; int i = 2; func(ci); func(i); /* value is 3 value is 2 */}void func(const int i){ cout &lt;&lt; &quot;value is &quot; &lt;&lt; i &lt;&lt; endl;}// void func(int i) {}//Error,redefines 函数func的形参类型为const int，但是可以用int的来进行初始化，因为这里是top-level的const。也因此函数func(int)和函数func(const int)是无法同时定义的，不然当使用int调用参数时，两个函数都可匹配。 Use Reference to const When Possible 当可能的时候尽量使用const referencce，因为 const reference可以避免函数中意外的修改实参值 普通reference形参，不能通过字面值进行初始化 普通reference形参，不能通过非const实参进行初始化 如： 12345678const string ss = &quot;&quot;;// funs(&quot;&quot;);//error,can not use literal to initialize string reference// funs(ss);//error,can not use const string to initialize stringreferencefunss(&quot;&quot;);funss(ss);void funs(string &amp;s) {}void funss(const string &amp;s) {} Array Parameters 虽然可以使用数组作为形参，但当数组作为形参的时候，是无法进行有效的值拷贝的。因为数组无法进行拷贝初始化，且当调用数组时，调用的实际上是指向数组第一个元素的指针。 以下三个函数定义，实际上是完全等效的： 123void print(const int *);void print(const int[]);void print(const int[10]); 即可以使用其中任意一个作为声明，再用另一个作来进行定义，而想声明其中两个则是不行的，因为会形成重复定义，后两个在编译的过程中会变换为第一种的写法。也因此，即使定义的是最后一种写法，看起来是要求一个大小为10的const int数组，但仍然可以传递普通的int指针进去，如 1234567int i = 0, j[2] = {0, 1};print(&amp;i);print(j);void print(const int[10]){} 因为即使形参使用数组，也会在编译时转换为指针，所以函数是不知道传进来的数组大小的，因此需要额外的信息来指定数组大小，以下为三种普遍的方式： Using a Marker to Specify the Extent of an Array 如之前所示，C风格的字符串实际上是const char[]，而C风格的字符串用来判断是否是数组结尾就是用一个空白的字符作为数组结束的标记位（Marker），如下： 123456789101112131415print(&quot;abcd&quot;);void print(const char cp[]){ if (cp) { while (*cp) cout &lt;&lt; *cp++; } cout &lt;&lt; endl;}/*abcd*/ 但是这种方法需要找到一个几乎不会作为正常数据的值，否则就会与正常数据产生干扰。 Using the Standard Liberary Conventions 第二种方法是通过标准库中的begin和end方法来传递数组的开始与结束指针，如下： 12345678910111213int j[2] = {0, 1};print(begin(j), end(j));void print(const int *beg, const int *end){ while (beg != end) cout &lt;&lt; *beg++ &lt;&lt; endl;}/*01*/ Explicitly Passing a Size Parameter 函数中使用一个形参来指定数组的大小，如： 1234567891011121314print(j, end(j) - begin(j));void print(const int *beg, size_t size){ for (size_t i = 0; i != size; ++i) { cout &lt;&lt; *beg++ &lt;&lt; endl; }}/*01*/ Array Parameters and const 可以使用在形参使用数组的引用，这个方法可以限定传递的数组的大小，如下： 1234567891011int valList[] = {0, 1, 2, 3, 4};print(valList);//print(j); // j is int array with size 2,so can't passvoid print(int (&amp;arr)[5]){ for (auto val : arr) { cout &lt;&lt; val &lt;&lt; endl; }} 注意数组的大小也是数组类型的一部分，所以对数组进行引用限定了数组大小，例子中只有数组大小是5的数组可以传递。 Passing a Multidimensional Array 对于多维数组，可以通过使用一个数组的指针进行传递，如 12345678910111213141516171819202122int mat[3][2] = {{1, 2}, {3, 4}, {5, 6}};print(mat, 3);void print(int (*matrix)[2], int rowSize){ for (int i = 0; i != rowSize; ++i) { for (int j = 0; j != 2; ++j) { cout &lt;&lt; matrix[i][j] &lt;&lt; endl; } }}/*123456*/ 其中因为传入的是长度为2的数组的指针，所以在循环中，可以确认内部循环的最大值为2。matrix[i]实际上获取的是长度为2的数组，但是会自动转为int*，所以matrix[i][i]实际上对一个int*使用[j]。也可以通过解引用符进行访问，即写成*((*(matrix + i)) + j) 需要注意的是，无法直接通过指针的指针，如int**来进行传递的。因为数组的大小是类型的一部分，在上例中，mat的会自动转换为int*[2]而不是int*。因此如果函数的形参为int**，将无法匹配。如果要使用指针的指针来传递，那么就必须用指针来表示多维数组，如： 1234567891011121314151617181920212223242526272829303132333435//Initial arrayint **matrix = new int *[3];for (int i = 0; i != 3; ++i){ matrix[i] = new int[2]; matrix[i][0] = 2 * i; matrix[i][1] = 2 * i + 1;}print(matrix, 3, 2);//release datafor (int i = 0; i != 3; ++i){ delete[] matrix[i];}delete[] matrix;void print(int **matrix, int rowSize, int columnSize){ for (int i = 0; i != rowSize; ++i) { for (int j = 0; j != columnSize; ++j) { cout &lt;&lt; matrix[i][j] &lt;&lt; endl; } }}/*012345*/ main: Handling Command-Line Options c++的main函数入口，可以是无参的，也可以是以下的格式 12345int main(int argc, char** argv){}//或者int main(int argc,char* argv[]){} 第一个int参数表示传入的参数数量，第二个是C风格的字符串的类型表示传入的参数。通常最少有一个参数，该参数是运行的exe文件的路径，如定义main函数如下： 12345678int main(int argc, char **argv){ cout &lt;&lt; &quot;argc count is &quot; &lt;&lt; argc &lt;&lt; endl; for (int i = 0; i != argc; ++i) { cout &lt;&lt; &quot;arg is &quot; &lt;&lt; argv[i] &lt;&lt; endl; }} 当直接启动编译完的exe文件，./a.exe，输出结果为 12argc count is 1arg is D:\\Study-Notes\\C++Primer\\Chapter6_Functions\\a.exe 当启动exe并传入参数时，./a.exe 1 2 3，输出结果为： 12345argc count is 4arg is D:\\Study-Notes\\C++Primer\\Chapter6_Functions\\a.exearg is 1arg is 2arg is 3 Functions with Varying Parameters 有的时候并不了解一个函数究竟需要多少个形参，如一个函数需要来处理错误信息，但错误信息的数量是不固定的。 为了处理这样的情况，在C++11的特性中，有两个方法，第一种是通过initializer_list，第二种是通过variadic模板。第二种方法将在16.4中进行说明。 C++还有一种名为elipsis的参数类型，可以实现传递不同数量的实参，但是该方法应该仅在与C接口进行通信时使用。 initializer_list Parameters initializer_list是一种表示数组的标准库中的类型，支持的操作如下表： 代码 含义 initializer_list lst; 默认初始化 initializer_list lst{a,b,c} 参数初始化，元素是初始值的拷贝，且list中的元素都是const的 lst2(lst) initializer_list的拷贝或赋值 lst2 = lst 同上 lst.size() 返回initializer_list中的元素数量 lst.begin() 返回第一个元素的指针 lst.end() 返回最后一个元素后面的指针 initializer_list的拷贝操作实际上并没有拷贝，而是共享被拷贝对象的元素 如同vector，initializer_list也是模板类，需要指定元素的类型。 如表格中所述，initializer_list中的元素都是const的，无法进行修改。 当调用initializer_list作为参数的函数时，如果想传递一系列的值来直接初始化initializer_list，则这些值必须放在大括号内。 使用例子如下： 1234567891011121314151617void TestVaryingParameters(){ error_msg({&quot;functionX&quot;, &quot;abc&quot;, &quot;def&quot;});}void error_msg(initializer_list&lt;string&gt; il){ for (auto beg = il.begin(); beg != il.end(); ++beg) { cout &lt;&lt; *beg &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl;}/*functionX abc def */ Ellipsis Parameters Elipsis是C++用来访问C中的库的，书中也未进行详细说明。但日后使用到时再进行查询。 Return Types and the return Statement Functions with No Return Value 在无返回值的函数中，编译器会在函数尾部隐式的加入一个return语句。 Functions That Return a value 如果函数的返回值不为空，则必须写明有return语句返回该类型的值，或者是返回一个可以隐式转换为该类型的值。 如果函数中有判断语句，且在某些case下没有返回值，那么编译器有可能可以检测出该错误，也有可能检测不出来，当检测不出来时，函数的结果是未定义的。 How Values Are returned 函数中返回的值，会用来初始化一个临时的变量，该临时的变量会作为函数的返回结果。如： 1234string ReturnThePluralVersionOfWord(size_t ctr, const string &amp;word, const string &amp;ending){ return (ctr &lt;= 1) ? word : word + ending;} 当ctr &lt;= 1时，返回的是word的拷贝，当ctr &gt; 1时，返回的是一个未命名的临时string，其中的值为word + ending。 Nerver Return a Reference or Pointer to a Local Object 如果要避免函数返回参数的时的拷贝，可以将返回类型设置为引用。但要注意千万不要返回本地局部变量的引用或指针。如： 12345678const string &amp;manip(){ string ret; if (!ret.empty()) return ret; //error,return reference of local variable else return &quot;empty&quot;;//error, return reference of a temporary string} 在例子中，如果返回的是ret，那么返回的是一个局部变量的引用，当退出函数时，该变量会被释放，于是引用的就是一个空参数。如果返回的是&quot;empty&quot;，实际上返回的是值为empty的临时变量的引用。 这两种返回方式的结果都是未定义的。 Reference Returns Are Lvalues 如果一个函数返回的是类型，那么该函数返回的是右参数。如果一个函数返回的是类型的引用，那么该函数返回的是左参数。因此可以将返回结果为引用的函数放在等式的左边，如： 1234567char &amp;Get_Val(string &amp;str, string::size_type ix){ return str[ix];}string s(&quot;abc&quot;);Get_Val(s,0) = 'A'; List Initializing the Return Value 在C++11特性下，函数可以通过大括号括其一系列返回的函数，如下： 1234vector&lt;string&gt; process(){ return {&quot;A&quot;, &quot;Bb&quot;, &quot;c&quot;};} 该例子中，会返回一个临时的vector变量，变量中有三个元素，由返回值来充填。 Return from main main函数虽然指定了返回类型为int，但却可以不写返回语句，这是因为当没有返回语句时，编译器会补上return 0。 main函数返回0表示执行成功，返回其他数值通常表示执行不成功，具体的定义是系统相关的，要返回系统不相关的值，可以使用头文件cstdlib。如 123456789#include &lt;cstdlib&gt;int main(){ if(someFailure) return EXIST_FAILURE; else return EXIST_SUCCESS;} 这两者都是预处理器的变量，所以不需要定义作用域或using语句。 Recursion 在函数中可以再调用自己，这种称为递归。 main函数中不能再调用自己。 Returning a Pointer to an Array 同样因为数组无法被拷贝，一个函数无法返回数组类型，但是返回数组的指针。关于定义返回数组指针的函数，有以下几种方法 Typedef / Using Functions That Return Class Types and the Call Operator 1234typedef int arrt[10];// using arrt = int[10];// equallyarrt *funcArray(); Declaring a Function That Returns a Pointer to an Array 像声明指向数组的变量那样直接定义，如 1int (*funcArray())[10]; funcArray()表明形参为空，(*funcArray())表明返回的是一个指针类型。 Using a Trailing Return Type 该方法是C++11的特性，Trailing Return可以针对任何的类型的函数，但针对返回值为数组的指针的函数时尤为有效。如 1auto funcArray() -&gt; int (*)[]; 该方法下，用auto替代原先定义返回类型的地方。 Using decltype 因为对数组使用decltype，返回的是数组类型，而不是指针类型，如 123456int odd[] = {1, 2, 3, 4, 5};int even[] = {0, 2, 4, 6, 8};decltype(odd) *funcArray(){ return &amp;odd;} Overloaded Functions main函数无法被重载 Defining Overloaded Functions 重载函数必须在形参的类型或者形参的数量上有区分。无法仅仅通过函数的返回类型来进行重载。 Overloading and const Parameters 无法仅通过形参的top-level的const属性进行函数重载，如下两个函数虽然不同，但却会造成重复定义。因为当调用函数时，top-level的const属性会被无视，因此对于调用者而说，两个函数是没有区别的，它们实际差异是体现在函数body中对形参的处理。 12Record lookup(Phone);Record lookup[(const Phone); 但如果const的区别是low-level的，那么是可以进行重载的，如 12Record loopup(Account&amp;);Record loopup(const Account&amp;); 对于调用者而言，上面的两个函数是不同的。如果使用的实参是const的，那么将无法直接调用第一个函数。当使用的形参是非const的，那么会优先调用第一个函数，关于重载函数的调用选择规则会在之后的小节中进行说明。 const_cast and Overloading 如有以下函数： 1234const string &amp;shorterString(const string &amp;s1, const string &amp;s2){ return s1.size() &lt; s2.size() ? s1 : s2;} 函数的形参是low level的const引用，返回的类型也为low level的const引用。如果调用的实参为非const的引用，会进行隐式的类型转换，此时返回结果将仍然是const的引用。 而如果想要实现，传入的实参是const的，返回为const类型；传入的实参是non-const类型，返回也会non-const类型，就需要进行函数重载。如下所示： 12345string &amp;shorterString(string &amp;s1, string &amp;s2){ const string &amp;r = shorterString(const_cast&lt;const string &amp;&gt;(s1), const_cast&lt;const string &amp;&gt;(s2)); return const_cast&lt;string &amp;&gt;(r);} 这里通过调用形参为const引用的版本来获取结果，注意在调用函数时，需要将形参转换为const类型，否则调用的将还是这个函数本身，即形成了无止境的递归。在返回结果时将const引用的版本返回的const string&amp;转换为string&amp;。 Calling an Overloaded Function 从一系列重载函数中找到正确的函数，这个过程叫做函数匹配（Function matching）。 对于调用重载函数，一共有三种可能的结果： 编译器找到了最佳的匹配函数（Best match），最终将调用该函数。 编译器没有找到任何可以匹配的函数（No match），最终编译器将报错。 编译器找到了多个匹配的函数，且无法从中判断出谁匹配度更高，为歧义调用（Ambiguous call），最终编译器将报错。 Overloading and Scope 如果在内层的代码范围内声明或者定义一个名字，则在外层代码块范围中同样名字的对象将被隐藏。这个规则同时适用于变量和函数。 如下代码，在内层作用域中定义的变量和函数将隐藏外层作用域中的同名变量与函数，如果要调用外层作用域的话需要::。 12345678910111213141516string read() { return &quot;readed&quot;; }void print(const string &amp;s) { cout &lt;&lt; s &lt;&lt; endl; }void print(double d) { cout &lt;&lt; d &lt;&lt; endl; }void fooBar(int ival){ bool read = false; // string s = read();//error, read() is hidden, in this scope read is a bool variable string s = ::read(); //ok,use :: to indicate search name is global scope // Decalare a function in the inner scope.This action is rare in practice. //Here we only use this to illustrate scope hidding void print(int); // print(&quot;value :&quot;);//error, print(const string &amp;s) is hidden. print(ival); print(3.14);//ok, but it will call print(int)} 在C++中，如果调用了一个名字的对象，编译器会在当前作用域首先找该名字的对象（可能不存在，可能一个，可能多个）。如果对象不存在的话，才会去外部作用域查找。 因此在上述代码中，调用print函数，编译器在当前的作用域找到了print(int)，就不会在外层的作用域查找了，于是print(double)与print(const string&amp;)都不会被作为重载的候选人，更不会进行函数匹配。 Features for Specialized Uses Default Arguments 可以为形参设定默认参数。但如果为一个形参设定了默认参数，该形参后面的所有形参都必须指明默认参数。 如 1string screen(int ht = 24, int wid = 80,char background = ' '); 如果仅想要修改最后一个变量，其他的变量仍然按默认参数，也仍然必须写明前面的参数。 如调用screen('?')，看起来实参类型为char，与最后一个参数相匹配，但在调用过程中，形参与实参是一一对应的，该表达式等同于screen('?', 80, ' '，即'?'会被转换为int作为第一个参数。 Default Argument Declarations C++中，只可以定义一个变量，但可以多次声明变量。但是对于默认参数而言，每个形参的默认参数都最多被声明一次，如 123string screen(int,int,char = ' ');// string screen(int,int,char = '*');string screen(int=24,int=80,char); 在第一条语句执行后，第二条语句无法通过编译，因为它重新声明了char类型的形参的默认值，造成了重复定义。而第三条语句仍然可以执行，且第三条语句执行后，函数screen的三个形参都有了默认值。 1234567891011121314string screen(int, int, char = '*');// string screen(int, int, char = ' ');string screen(int = 24, int = 80, char);string screen(int width, int height, char c){ cout &lt;&lt; &quot;width is &quot; &lt;&lt; width &lt;&lt; &quot;, height is &quot; &lt;&lt; height &lt;&lt; &quot;, c is &quot; &lt;&lt; c &lt;&lt; endl; return &quot;&quot;;}screen();/*width is 24, height is 80, c is **/ Default Argument Initializers 函数的默认参数可以是任何可以转换为形参类型的表达式，如 1234567891011121314151617181920int vall = 20;char cc = 'a';void printDefaultArgument(int ran = rand(), int w = vall, char c = cc){ cout &lt;&lt; &quot;random is &quot; &lt;&lt; ran &lt;&lt; &quot;, w is &quot; &lt;&lt; w &lt;&lt; &quot;, c is &quot; &lt;&lt; c &lt;&lt; endl;}void TestDefaultArgument(){ printDefaultArgument(); vall = 30; char cc = 'b'; printDefaultArgument();}/*random is 41, w is 20, c is arandom is 18467, w is 30, c is a*/ 上述代码中，printDefaultArgument函数第一个形参ran的默认值是一个函数，函数会随机取一个int值，第二个和第三个形参都是全局变量。 在函数TestDefaultArgument中调用printDefaultArgument函数，第二次调用前先改变了全局变量vall的值，然后定义了一个同名新局部变量cc。但是因为printDefaultArgument函数的第三个形参实际上是全局变量中的cc，所以在第二次调用printDefaultArgument时，第三个形参的数值并没有发生改变。 Inline and constexpr Functions 在大多数的设备下，函数调用是一个花费较大的操作，需要拷贝实参，记录和回复调用时的状态等。inline关键字可以减少函数的调用。 inline Functions Avoid Function Call Overhead 如果定义一个函数为inline的，那么编译器会在编译阶段，将函数调用的地方换成函数主体，这样就避免了函数的调用。这样的函数称为内联函数（inline Function）。 如 1234inline const string &amp;shorterString(const string &amp;s1, const string &amp;s2){ return s1.size() &lt; s2.size() ? s1 : s2;} 注意并不是函数加上了inline关键字就一定会变成内联函数，inline关键字如同一个申请，至于函数最终是否会变成内联由编译器决定。通常而言，递归函数和行数大于75行的函数是不会变成内联函数的。 constexpr Functions //TODO Put inline and constexpr Functions in Header Files 和其他的函数不同，内联函数在一个程序中是可以被多次定义的，如: 12345678910111213141516171819202122232425262728293031// GetNum.hint GetNum();inline double GetDoubleNum();// GetNum.cppint GetNum(){ return 10;}inline double GetDoubleNum(){ return 3.14;}//Chapter6_Functions.cpp// int GetNum()// {// return 10;// }inline double GetDoubleNum(){ return 4.15;}cout &lt;&lt; GetDoubleNum();/*4.15*/ 可以看到在Chapter6_Functions.cpp和GetNum.cpp两个源文件中都对GetDoubleNum函数进行了定义，且仍然可以正常运行。而如果尝试在Chapter6_Functions.cpp中再次定义GetNum函数，则会发生编译错误。 这是因为对于内联函数而言，是在本源文件中搜索内联函数的定义然后进行替代。 最合理的方式是将内联函数的定义放在头文件中，这样在使用include时，实际上就将内联函数的定义拷贝到了源文件中。 Aids for Debugging 可以使用预处理器来帮助C++进行调试工作，即实现在开发过程中，可以打出调试log，而在实际程序中log则不予显示的方法。 The assert Preprocessor Macro 预处理宏（Preprocessor Macro）是一种预处理器变量，运行起来有点像内联函数。 assert预处理器宏可以接纳一个表示condition的表达式，定义在头文件cassert中，且因为是预处理器变量，因此不需要设定命名空间。当表达式的结果为false时，将打出信息并且终止程序的运行。如： 1234567891011int a = 3, b = 2;assert(a &lt; b);/*Assertion failed!Program: D:\\Study-Notes\\C++Primer\\Chapter6_Functions\\a.exeFile: Chapter6_Functions.cpp, Line 50Expression: a &lt; b*/ assert通常是用来判断那些不可能发生的情况，如当某个数值超过了阈值等。 The NDEBUG Preprocessor Variable assert的运行状态预处理变量NDEBUG决定，如果该变量被定义了，则assert不会被执行。 因此可以通过在代码中加入#define NDEBUG来关闭assert的调试。也可以直接在编译时通过flag -D来加入这句话，如 123456789101112131415g++ Chapter6_Functions.cpp $ ./a.exe Assertion failed!Program: D:\\Study-Notes\\C++Primer\\Chapter6_Functions\\a.exeFile: Chapter6_Functions.cpp, Line 50Expression: a &lt; bg++ Chapter6_Functions.cpp -D NDEBUG$ ./a.exe 4.15 也可以进一步利用NDEBUG来定义自己的调试函数，如 123456void Debug(const string &amp;msg){#ifndef NDEBUG cout &lt;&lt; msg &lt;&lt; endl;#endif} C++还提供了一些帮助调试的预处理器变量： 变量 含义 func 当前的函数名 FILE 当前文件名 LINE 当前行号 TIME 该文件被编译的时间 DATE 该文件被编译的日期 1234567891011121314151617void TestPreprocessorVariable(){ cout &lt;&lt; &quot;Function is &quot; &lt;&lt; __func__ &lt;&lt; endl; cout &lt;&lt; &quot;File is &quot; &lt;&lt; __FILE__ &lt;&lt; endl; cout &lt;&lt; &quot;Line is &quot; &lt;&lt; __LINE__ &lt;&lt; endl; cout &lt;&lt; &quot;Time is &quot; &lt;&lt; __TIME__ &lt;&lt; endl; cout &lt;&lt; &quot;Dateis &quot; &lt;&lt; __DATE__ &lt;&lt; endl;}/*Function is TestPreprocessorVariableFile is Chapter6_Functions.cppLine is 78Time is 16:49:12Dateis Feb 22 2020*/ Function Matching 函数匹配过程可以分为三步： 找出候选函数（candidate functions），通过函数的名字，找到所有可能的重载函数（注意作用域隐藏）。 找出可选函数（viable functions），在候选函数中通过形参数量和类型找出可以被调用的函数 找出最佳匹配，在所有的可选函数中根据规则找出最佳匹配函数。 以下是找最佳匹配函数的规则，排名越靠前的函数，会越优先被选取 实参类型与形参类型完全匹配，包括 a. 实参类型与形参类型相同，不需要任何转换 b. 实参是数组或函数，形参是对应的指针类型 c. 实参和形参的差距是可以无视的top-level const 需要进行const转换 low level的const转换，如实参是nonconst的引用，形参是const的引用。 需要进行数值提升（promotion） 较小的整数类型会自动转换成int或更高类型的整数类型。如 123void ff(int);void ff(short);ff('a');//Call ff(int) 因为十进制的字面值会自动转换为最小为int的变量，所以a的最终类型为int。所以可以与ff(int)完全匹配，但是与ff(short)需要进行一次转换。 需要进行算数转换或者指针转换 算数类型的转换，如int转float,int转double。注意只要都是算数转换，则它们的排名就是一样的，无论正在进行的类型转换是什么。 指针转换指的是，0转换为空指针，non const的指针可以转换为void*，任何指针都可以转换为const void*。 需要进行类转换（14.9节中进行说明） 如果出现了多个可选函数由相同的排名，则会出现歧义调用（Ambiguous call）。如 1234f(int,int);f(double,double);// f(42,2.56); // ambiguous call 对于调用f(42,2.56)无论是访问f(int,int)和f(double,double)都是进行了一次算数转换，所以这两个函数的优先级一样的，为歧义调用。 还有类似于 123void manip(long);void manip(float);// manip(3.14); // ambiguous call 无论调用哪个函数都会进行算数转换，即使转换的目标类型不同，但是函数的优先级仍然是一样的，所以为歧义调用。 Pointers to Functions 函数指针就是指向函数的指针，指针的类型需要匹配要指向的函数的形参数量，形参类型和返回值类型。如： 1bool (*pf)(const string &amp;, const string &amp;); // uninitialized pf为指向两个形参都是const string&amp;，返回值为bool的函数的指针。如可以指向 1bool lengthCompare(const string &amp;, const string &amp;); 但是并不能指向类内成员函数，即使形参和返回值类型一样，因为类内函数实际上有一个this指针的传递 注意，定义pf时，外面的括号不能缺少，不然变成 1bool *pf(const string &amp;, const string &amp;); 上述代码意思为一个名为pf的返回值为bool*的函数的声明。 Using Function Pointers 在赋值和使用函数指针的时候，取地址符(&amp;)以及解引用符(*)都可以被省略。 123456789101112131415161718192021222324bool (*fp)(const string &amp;, const string &amp;) = lengthCompare;// bool (*fp)(const string &amp;, const string &amp;) = &amp;lengthCompare;//equal to abovebool b1 = fp(&quot;hello&quot;, &quot;goodbyte&quot;);bool b2 = (*fp)(&quot;hello&quot;, &quot;goodbyte&quot;);// equal to abovebool b3 = lengthCompare(&quot;hello&quot;, &quot;goodby&quot;);//equal ro abovecout &lt;&lt; &quot;b1: &quot; &lt;&lt; b1 &lt;&lt; endl;cout &lt;&lt; &quot;b2: &quot; &lt;&lt; b2 &lt;&lt; endl;cout &lt;&lt; &quot;b3: &quot; &lt;&lt; b3 &lt;&lt; endl;/*b1: 0b2: 0b3: 0*/当使用函数指针时，赋值给函数指针的函数的类型必须与函数指针的类型完全一致。```cppvoid ff(int val);void (*p1)(unsigned int) = ff;// void (*p2)(int) = ff; //error, can't convert unsigned int to int Function Pointer Parameters 无法将函数类型作为函数的形参类型，但是可以将函数指针作为形参的函数类型。如同数组一样，如果将函数的形参类型设置为某个函数类型，那么会形参类型会自动转换为该函数类型的指针，如 12345void print(const int *);void print(const int[]);void useBigger(const string &amp;s1,const string &amp;s2,bool pf(const string&amp;,const string&amp;));void useBigger(const string &amp;s1,const string &amp;s2,bool (*pf)(const string&amp;,const string&amp;)); 上述代码，每一组是完全相同的。 调用形参为函数指针的函数时，也可以省略取地址符，如以下两个语句是完全相同的。 12useBigger(s1, s2, lengthCompare);useBigger(s1, s2, &amp;lengthCompare); 但当使用decltype时，使用函数类型以及函数类型的指针返回的结果是不同的，如 1234567//Func and Func2 are function typetypedef bool Func (const string &amp;,const string &amp;);typedef decltype(lengthCompare) Func2;//FuncP and FuncP2 are pointer to function typetypedef bool (*FuncP) (const string &amp;,const string &amp;);typedef decltype(lengthCompare) *FuncP2; 上述代码，每组等效，但是第一组定义的是函数类型的别名，第二组定义的是函数指针的别名。 但使用函数类型和函数指针的别名来定义函数时，又可以直接进行转换，如下两句，完全等效 12void useBigger(s1, s2, Func);void useBigger(s1, s2, FuncP); Returning a Pointer to Function 如同数组一样，无法将函数类型作为函数的返回值，但可以返回函数类型的指针。如需要定义函数f1，形参为int，返回值类型为指向形参为(int*,int)，返回值为int的函数的指针。 以下是四种定义返回类型为函数指针的函数的方法，分别是使用别名，直接定义，使用trailing方法，使用decltype 12345678910111213141516171819//Method1: use aliasusing F = int(int *, int); //F is Function type,retun type is intusing FF = int *(int *, int); //F is Function type,retun type is pointe to intusing PF = int (*)(int *, int); //FP is pointer to Function typePF f1(int);// F f1(int); //error, function type can not be return typeF *f1(int);//Method 2: directly//like directly define return is pointer to array, which looks like//int (*f1(int)) [10];int (*f1(int))(int*,int);//Method 3: use trailing returnauto f1(int) -&gt; int (*)(int *, int);//Method4: use decltypeint func1(int*,int);decltype(func1)* f1(int); 引用： Cpp Primer 5th Aug.2012","link":"/CPPPrimer-Chapter6-Notes/"},{"title":"《Experts at Play：Understanding Skilled Expertise》 笔记","text":"《Experts at Play：Understanding Skilled Expertise》论文笔记 这篇文章，作者主要是分析CS中是哪些因素让一个玩家可以称为专家。 这些因素包括，对于地形的理解，与队友的合作，对方位的感知等等。 Introduction 目前大部分的对于游戏设计研究的论文是针对那些有宏大背景的游戏，如魔兽世界，星球大战系列等，而对于FPS的研究不多。其次对于游戏是如何被玩的研究不多，即玩家的游戏技能。 作者在这里探讨的主要是是什么让玩家能与别人玩家一起去玩好一个游戏。 分析会通过以下几个关键概念： 玩家如何实现游戏中的移动 玩家是如何学习和参与进游戏的场景中的 网络游戏的合作和冲突是如何支持并提升玩家的技能的。 Studing experts 作者首先给出了技能的定义：技能是用来描述可认知的操作，记忆理论，信息处理和心理结构的。 现在大量的关于游戏操作的测试，都是基于操作的速度，年纪与反应速度的关系，准确性等等，但很少有去分析再特定情况下的技能运用， 这篇文章的目的就是以游戏*反恐精英（CS）*作为例子，研究在真实情况下的对技能的应用和队友合作等。 Counter-Strike 这一部分是描述介绍反恐精英游戏戏。 Examining skill：a drop into the action 这一部分作者去观察一个“专业”的玩家，每周有数十小时的游戏经验，他通过观察玩家两个游戏片段总结出专业玩家的技能。 在文中作者详细描写了这两个游戏片段，但这里就不再赘述这两个片段的细节，直接总结作者从片段中得出的结论。 Moving competently 在地图中的移动是鼠标和键盘的混合操作，用鼠标控制角度，用键盘控制移动。虽然熟悉游戏的人会觉得这操作很简单，但对于刚接触游戏的人来说这是个需要一段时间学习的技能。 玩家在移动的同时，还需要做大量其他的工作，如快速的扫视别的方向，蹲下、跳跃等，这也说明了玩家在移动的还需要保有对地形的理解。 即使是对于熟悉游戏的人而言，更专业的玩家可以更快，更流畅的完成上述的一系列操作。如何比别的玩家更快，更精准的完成这些也是一个挑战。 另外对于通过这一系列的流畅的操作来获得胜利，或者在其他玩家前展示这些操作，对玩家而言也是一种愉悦的体验。 Collaboration 队友间会相互合作，如组成一个攻击队列，前方的队友危险但有更好的视野，后面的人相对安全，但也视野受限。 在游戏合作中，对于获取队友的位置，不仅仅是通过视线，也会通过脚步，射击的火光或者预制的语音信息等。 对手也可以反利用玩家对于队友位置的预判来进行攻击，如故意绕路，从通常是队友才会出现的地方进行攻击（如玩家的背后）。 Terrain 为了理解游戏中的地形，首先要理解游戏中的地图概念。对于CS而言，地图的数量是有限的，一个熟练的游戏玩家通过大量的游戏时间会对这些地图非常的熟悉。玩家过去的游戏经验会提供给他们判断的依据，如根据子弹的方向判断敌人的方位。 正是因为单一的游戏地图是不变的，才给玩家通过大量的游戏体验来熟悉地图的可能。作者在总结阶段，也将地形称为临时交互环境（Interactive temporal environment），即其中的可能性会在事件的运行过程中不断的变化。 而且地形的关键不仅仅子在于知道地图的某一个地方有什么，还要知道在不同的情况下，同一个位置有没有不同的意义（进攻时的掩护处，防守时的阻挡点等等）。 Presence and awareness 玩家在行动的时候都要注意自己的方位是否会被别人注意到，无论是敌人还是队友。 队友对于自己而言可以作为一个侦察兵的存在，可以根据队友的状态判断出敌人的位置，甚至队友死亡时的身体朝向也能用来判断敌人信息。 同时要尽量减少自己出现在敌人视野内的时间，并猜测敌人出现的位置，如狙击时的卡地形的同时不停移动（减少出现在视野内的时间）和始终标准固定高度（猜测敌人的头出现的位置） The right tool for the job 在游戏中选择不同的武器针对不同的情况。 如狙击枪的设计距离远，攻击力高，但换子弹时间慢，以及使用狙击枪时移动速度慢。 优秀的玩家会根据当前的情况，去做出武器之间的权衡，并找到适合这个武器的地形。 Round strategies and flashpoints 因为CS一定程度上是回合制游戏（警察和警匪有多轮对决），玩家可以在每一轮中根据之前轮的情况来调整战术，如在某局中使用某战术非常成功，下一轮就可以继续使用该战术等等。 同时玩家也可以通过大量的游戏经验，来贯彻一个战术，并使其越来越完善。 并且玩家的战术也会受同伴的影响，如在开局时看到队友的走向，判断队友想使用的战术，并以此来调整自己的战术。 闪电（flashpoint）就是这种在实时的情况下，根据情况和玩家的变换做出策略转换的时刻。 Conclusion Understanding expertise 对于游戏的分析不仅仅应该将游戏的动作分割开来，如去研究玩家按下跳跃键的速度，玩家的反应速度，而应该将玩家的一系列动作联系起来看，如同研究其他的人类行为意义，去研究玩家在游戏中的行为意义。 FPS与其他游戏不同的是，在FPS中玩家的行为反馈会非常的快，如果做了一个错误的行为，可能下一秒就会因此输掉游戏。 引用： Reeves, S., Brown, B., &amp; Laurier, E. (2009). Experts at Play: Understanding Skilled Expertise. Games and Culture, 4(3), 205–227. https://doi.org/10.1177/1555412009339730","link":"/ExpertsAtPlay-Understanding-Skilled-Expertise-Notes/"},{"title":"《C++ Primer》 第七章笔记","text":"《C++ Primer》 第七章笔记 Chapter 7 Classes Defining Abstract Data Types 如果一个类让用户可以任意访问其中的数据，且必须自己定义针对相关数据的操作，则该类不是抽象类型。 Designing the Sales_data class 在本章中，会逐步完善一个称为Sales_data的类，在完善的过程中解释类的特性。 Defining the Revised Sales_data Class 成员函数必须在类内声明，可以在类内或类外进行定义。且在类内定义的函数默认是内联（inline）的。 如目前Sales_data类为： 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;string&gt;using std::istream;using std::ostream;using std::string;struct Sales_data{ //Member function string isbn() const { return bookNo; } Sales_data &amp;combine(const Sales_data &amp;); double avg_Price() const; //Member variable string bookNo; unsigned units_sold = 0; double revenue = 0;};//nonmember but related functionSales_data add(const Sales_data &amp;, const Sales_data &amp;);ostream &amp;print(ostream &amp;, const Sales_data &amp;);istream &amp;read(istream &amp;, Sales_data &amp;); Introducing this 首先注意成员函数: 1string isbn() const { return bookNo; } 当类的实例化调用函数时，实际上会隐式的传递一个this指针，指针指向该实例的地址，如下代码： 12Sales_data total;total.isbn(); 编译器会将total.isbn()调用，改写为类似于如下代码： 1Sales_data::isbn(&amp;total); 当在函数内部访问成员变量时都相当于用了this-&gt;。如函数体内访问了bookNo，实际上等同于this-&gt;bookNo，而这个调用下，this指向total，所以访问的是实例化total中的bookNo变量。 另外this是一个const指针，即无法让this指向别的变量。 Intruducing const Member Functions 同样还是成员函数： 1string isbn() const { return bookNo; } 还需要注意到在这个函数的声明中有关键字const，当const跟在参数列表后时，其目的是改变this指针的类型，让this指针是一个指向const变量的指针。整个函数的定义会被编译器翻译为类似如下的代码： 1234string Sales_data::isbn(const Sales_data* const this){ return this-&gt;bookNo;} 称这样的函数为const函数。 如果该函数不是定义为const的，则const的Sales_data实例将无法调用isbn函数。如同变量的隐式转换规律，一个const变量无法赋值给一个指向非const变量的指针。实例代码如下： 12345678//In SalesData_Struct.h, modify the declaration of isbn functionstring isbn() { return bookNo; }//Call isbn functionSales_data total;total.isbn();const Sales_data cTotal;// cTotal.isbn();//error 在编译器的隐式转换后，cTotal.isbn()会变成用一个const Sales_data* const类型的指针区初始化一个Sales_data* const类型的指针，如之前章节所述，该操作是非法的。 Class Scope and Member Functions 类的编译分为两步，首先会先编译所有的声明，然后再编译函数的定义（实现），因此在函数的实现中，可以任意调用其他的成员变量，无论它定义在更前面还是后面。 Defining a Member Function outside the Class 如果在类外定义const函数，同样需要在参数列表后加上const关键字 1234567double Sales_data::avg_Price() const{ if (units_sold) return revenue / units_sold; else return 0;} Defining a Function to Return “This” Object 如果成员函数返回类型是该类型本身或者该类型的引用，可以返回*this，如： 123456Sales_data &amp;Sales_data::combine(const Sales_data &amp;rhs){ units_sold += rhs.units_sold; revenue += rhs.revenue; return *this;} Defining Nonmember Class-Related Functions 一些函数从概念上是某种类型的一部分，但却不是定义在函数的内部。这样的函数声明应该写在该类型的头文件（函数定义可以放在头文件对应的cpp文件中）。 如： 123456789101112131415161718192021222324252627//In SalesData_struct.h//nonmember but related functionSales_data add(const Sales_data &amp;, const Sales_data &amp;);ostream &amp;print(ostream &amp;, const Sales_data &amp;);istream &amp;read(istream &amp;, Sales_data &amp;);//In SalesData_struct.cppSales_data add(const Sales_data &amp;lhs, const Sales_data &amp;rhs){ Sales_data sum = lhs; sum.combine(rhs); return sum;}ostream &amp;print(ostream &amp;os, const Sales_data &amp;item){ os &lt;&lt; item.isbn() &lt;&lt; &quot; &quot; &lt;&lt; item.units_sold &lt;&lt; &quot; &quot; &lt;&lt; item.revenue &lt;&lt; &quot; &quot; &lt;&lt; item.avg_Price(); return os;}istream &amp;read(istream &amp;is, Sales_data &amp;item){ double price = 0; is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price; item.revenue = price * item.units_sold; return is;} 注意在函数print和read中返回的是ostream和istream的引用，这是因为这两个类型不支持拷贝。 在add函数中，首先是一个拷贝初始化Sales_data sum = lhs。C++的默认实现中，拷贝一个类类型会拷贝其中所有的成员变量，因此sum和lhs中的所有成员变量将有相同的值（但在不同的内存中）。 Constructors 构造函数特点： 构造函数在实例化创建时被执行。 构造函数与函数类型同名 构造函数没有返回值 构造函数不允许被定义成const函数。因为一个对象的const与否是在创建后才决定的，所以构造函数会在决定constness前先执行。 The Synthesized Default Constructor 默认构造函数（default constructor）是不需要任何形参的构造函数。 当类没有定义任何构造函数时，编译器会创建合成默认构造函数（synthesized default constructor）。合成默认构造函数的操作为，当参数有类内初始化（变量定义时有初始化值），如int a = 3;，则使用类内初始化值进行值初始化，否则使用变量的默认初始化。 Some Classes Cannot Rely on the synthesized Default Constructor 一些类无法依赖合成默认构造函数，因为 只有类没有定义任何构造函数时，才会有合成默认构造函数 当没有类内初始化值时，合成默认构造函数会使用变量默认初始化，但内建类型（int等）和复合类型（array，pointer）出现在函数内部时默认值是未定义的。所以当且仅当这些参数有类内初始化值时才可以依赖合成默认构造函数，否则构造的结果是未定义的。 有的情况下，编译器无法生成合成默认构造函数。如类中的一个成员变量并没有默认构造函数，合成默认构造函数也就无法去初始化这个变量。因此在这种情况下，需要自己定义默认构造函数。 Defining the Sales_data Constructors Sales_data构造函数定义如下： 1234567891011//Inside class bodySales_data() = default;Sales_data(const string &amp;s) : bookNo(s) {}Sales_data(const string &amp;s, unsigned n, double p) : bookNo(s), units_sold(n), revenue(p * n) {}Sales_data(istream &amp;);//Outside class bodySales_data::Sales_data(istream &amp;is){ read(is, *this);} 上述一共定义了四个构造函数，其中三个是在类内定义的，一个是在类外定义的。 在定义默认构造函数时，使用了default关键字，该关键字是C++11的特性，表示希望构造函数表现的如同合成默认构造函数一模一样。 Constructor Initializer List 在构造函数中的定义中，出现在参数列表后，函数主体前，以:开头的部分称为初始化列表（Initializer List）。初始化列表必须出现在函数定义中，即必须与函数主体一起出现。 当一个成员变量没有出现在初始化列表中时，该函数的初始化逻辑与合成构造函数相同，即有类内初始化值使用类内初始化，否则使用默认初始化。 建议为每个成员参数都设置类内初始化值 Defining a Constructor outside the Class Body 如形参为istream版本的构造函数： 123456Sales_data(istream &amp;);Sales_data::Sales_data(istream &amp;is){ read(is, *this);} 该构造函数没有初始化列表，或者严格意义上说，初始化列表为空。则该构造函数会在执行函数主体前，先按照合成默认构造函数的逻辑初始化所有成员变量，然后再执行函数主体。 尽量在初始化列表中初始化变量。如果将成员变量的赋值写在构造函数主体内，则实际上是经过了一个默认初始化，再进行了一个赋值。 Copy, Assignment, and Destruction 类还要控制对象是如何被拷贝，赋值和摧毁的。 拷贝：当使用对象初始化另一个变量，或作为值类型（没有引用）传递进函数或从函数返回时，对象都会经历拷贝。 赋值：当使用赋值操作符（=）时会经历赋值 摧毁：当对象退出作用域时会被摧毁。在数组和vector中的元素，会在容器摧毁时被摧毁。 如果用户没有指定拷贝，赋值和摧毁的实现，编译器都会提供合成版本。以下代码展示了编译器提供的合成赋值操作： 123456total = trans; // synthesized assignment//Equals tototal.bookNo = trans.bookNototal.units_sold = trans.units_soldtotal.revenue = trans.revenue Some Classes Canot Rely on the Synthesized Versins 通常来说，有动态内存分配的类不适合合成版本的拷贝，赋值和摧毁（第12章和13.1.4节会解释）。 但是合成版本可以正确处理string和vector，如下： 123456789101112131415161718192021Test firstOne;firstOne.value = {1, 2, 3};Test secondOne;secondOne = firstOne;firstOne.value[0] = 4;cout &lt;&lt; &quot;First one value is: &quot; &lt;&lt; endl;for (int i : firstOne.value) cout &lt;&lt; i &lt;&lt; &quot; &quot;;cout &lt;&lt; endl;cout &lt;&lt; &quot;Second one value is: &quot; &lt;&lt; endl;for (int i : secondOne.value) cout &lt;&lt; i &lt;&lt; &quot;&quot;;// First one value is: // 4 2 3// Second one value is:// 123 Test类中仅包含一个vector，如下： 1234struct Test{ vector&lt;int&gt; value;}; 可以看到合成默认赋值正确的拷贝了vector中的每个元素。 Access Control and Encapsulation public关键字后的变量可以被程序的其他部分访问，private关键字后变量仅能被类中的成员函数访问。 public和private关键字可以出现在类中出现任意多次。 Using the class or struct keyboard struct和class的唯一区别在于，class中没有写在public和private后的成员默认是private的，而struct中则默认是public的（struct中同样可以定义public和private）。 Friends 一个类可以允许其他的类或者函数访问其中的非public变量，此时其他的函数或者类被称为友类（函数）（Friends）。 要声明函数是友函数，只需要在类中加上函数的声明，并且最前方加入friend关键字即可。如下： 1234567891011121314151617181920212223242526class Sales_data{ friend Sales_data add(const Sales_data &amp;, const Sales_data &amp;); friend ostream &amp;print(ostream &amp;, const Sales_data &amp;); friend istream &amp;read(istream &amp;, Sales_data &amp;);public: Sales_data() = default; Sales_data(const string &amp;s); Sales_data(const string &amp;s, unsigned n, double p) : bookNo(s), units_sold(n), revenue(p * n) {} Sales_data(istream &amp;);public: //Member function string isbn() const { return bookNo; } // string isbn() { return bookNo; } // should be const Sales_data &amp;combine(const Sales_data &amp;);private: double avg_Price() const; //Member variable string bookNo; unsigned units_sold = 0; double revenue = 0;}; friend关键字只可以出现在类的定义中，而且因为严格意义上它并不是类的一部分，所以可以出现在类中的任意地方，不受public和private影响。 Declarations for Friends 在类内部关于friends的声明并不是函数声明，因此应该在类外部再次声明函数。如： 12345678910111213141516171819class Sales_data{ friend Sales_data add(const Sales_data &amp;, const Sales_data &amp;); friend ostream &amp;print(ostream &amp;, const Sales_data &amp;); friend istream &amp;read(istream &amp;, Sales_data &amp;); . . .}// Sales_data returnAddResult(const Sales_data &amp;lhs, const Sales_data &amp;rhs)// {// return add(lhs, rhs);// } //ErrorSales_data add(const Sales_data &amp;, const Sales_data &amp;);ostream &amp;print(ostream &amp;, const Sales_data &amp;);istream &amp;read(istream &amp;, Sales_data &amp;); 示例代码中的returnAddResult尝试返回add函数的结果，但因为add函数仅被声明为了友函数，并没有真正的进行声明，所以无法访问。 虽然即使不在类外部再次声明函数，大部分的编译器也都能正确编译。但是C++标准是要求在类外再次声明的，即使程序在没有再次声明的情况下正常运行了，也不能保证该代码换一个编译器仍然能正常工作。 Additional Class Features 7.1-7.2以Sales_data这个类作为例子说明了类的一些特性。在这一节中会继续深入探讨这些特性。 Class Members Revisited Defining a Type Member 在类内部，也可以定义Type成员。该成员与其他的成员类型一样，是受public和private关键字影响的。但与其他成员不同的是，在使用该类型前，必须已经出现了该类型的定义（对其他成员，会先编译声明，再编译定义，因此成员的位置不造成任何影响），如下： 1234567891011class Screen{public: // pos i = 0; //error, the pos hasn't been typedef string::size_type pos; // using pos = string::size_type; // same with aboveprivate: pos cursor = 0, height = 0, width = 0; string content;}; 当在类外访问该别名时，也需要像访问普通变量一样，如Screen::pos Making Members inline 如之前所述，定义在类内部的函数会隐式的认为为inline的。也可以通过显示的在函数类内声明或类外定义前加上inline来将函数变为内联函数，如： 1234567891011121314151617class Screen{ ... char get() const { return content[cursor]; } inline char get(pos ht, pos wd) const; ...}inline char Screen::get(pos ht, pos wd) const{ } 在上述代码中，get()是隐式的被定义为内联，get(pos ht, pos wd)是显示的被定义为内联，代码中get(pos ht, pos wd)的声明和定义处都加上了关键字inline，实际上只需要在任意一处定义即可。 注意如在第六章中所述，内联函数的定义建议与声明放在同一个头文件中 mutable Data Members mutable数据成员永远不会是const的，即使在const函数中（this指针是指向const的指针）仍然能被修改。如 123456789101112131415161718class Screen{public: ... void ChangeAccessCtr() const; ...private: ... mutable size_t accessCtr = 0; ...}void Screen::ChangeAccessCtr() const{ ++accessCtr;} 上述代码中,ChangeAccessCtr是const函数，但因为accessCtr变量是mutable的，所以仍然能够修改accessCtr。 Functions That Return *this 如果某成员函数返回的类型为类的引用，则该函数可以被正确的级联起来，否则虽然可以通过编译，但之后的操作是基于临时变量，如下： 12345678910111213141516171819202122232425262728293031323334//Define class function outside classScreen &amp;Screen::move(pos ht, pos wd){ pos row = ht * width; cursor = row + wd; return *this;}Screen &amp;Screen::set(char c){ content[cursor] = c; return *this;}Screen Screen::move_copy(pos ht, pos wd){ pos row = ht * width; cursor = row + wd; return *this;}//Test codeScreen sc(20, 20, ' ');sc.move(4, 0).set('a');cout &lt;&lt; &quot;content is &quot; &lt;&lt; sc.get() &lt;&lt; endl;sc.move_copy(4,0).set('b');cout &lt;&lt; &quot;content is &quot; &lt;&lt; sc.get() &lt;&lt; endl;/*content is acontent is a*/ 如上述代码所示，move函数返回的是类型的引用，move_copy函数返回的是类型本身，因此实际上返回的是一个经过拷贝初始化临时变量。当对move函数的返回值调用set时，原先的值被修改了，而对move_copy函数的返回值调用set时，被修改的实际上是返回的临时变量。 Returning *this from a const Member Function 如果成员函数是const函数，且返回类型是该类型的指针或引用，那么该指针或引用是指向const变量的。也因此无法级联调用其他非const的函数，如下所示： 12345678910111213141516171819//In Screen.hclass Screen{public: ... inline const Screen &amp;Display() const; ...}const Screen &amp;Screen::Display() const{ cout &lt;&lt; content; return *this;}//In Chapter7_Classes.cpp// sc.Display().set('a'); //error when there is no nonconst overload 在上述代码中，因为Display函数是const的，因此传入的this指针是const Screen * const类型，也因此如果返回的是*this，返回类型为const Screen&amp;。 调用语句sc.Display().set('a')失败，是因为set不是const函数，所以其this指针类型为Screen * const，而传入的是Display返回的变量指针，类型为const Screen * const，所以无法进行隐式转换。 Overloading Based on const 解决上述问题的方法是，定义一个非const的函数进行重载，因为函数的const与否实际是决定传入的this指针的类型，而且是low level的const区别，所以可以进行重载。如下所示： 123456789101112131415161718192021222324252627282930313233//In Screen.hclass Screen{public: ... inline const Screen &amp;Display(ostream &amp;) const; inline Screen &amp;Display(ostream &amp;); ...private: void do_display(ostream &amp;os) const;}const Screen &amp;Screen::Display(ostream &amp;os) const{ do_display(os); return *this;}//In Screen.cppScreen &amp;Screen::Display(ostream &amp;os){ do_display(os); return *this;}void Screen::do_display(ostream &amp;os) const{ os &lt;&lt; content;}//In Chapter7_Classes.cppsc.Display(cout).set('a'); // correct,when there is nonconst overwrite 在上述代码中，sc.Display(cout).set('a')可以成功运行，因为类中定义了const和非const两个版本的Display函数。该语句实际调用的是非const版本的Display，其中会调用const函数do_display，调用中存在将指向非const对象的指针（this指针）隐式转换为指向const对象的指针的过程。 Class Type 每个类都定义了一个独特的类型。两个不同的类即使其中的所有成员都一模一样，也无法相互赋值，但可以通过指针进行转换。如下： 123456789101112131415161718192021222324252627//In Test.hstruct First{ int memi = 0; int getMem = 0;};struct Second{ int memi = 0; int getMem = 0;};//In Chapter7_Classes.cppFirst first;Second sec;first.memi = 2;// sec = first; //ErrorSecond *sp = reinterpret_cast&lt;Second *&gt;(&amp;first);cout &lt;&lt; &quot;sp value is &quot; &lt;&lt; sp-&gt;memi &lt;&lt; endl;/*sp value is 2*/ Class Declarations 可以在没有定义类的情况下声明类，如 1struct NotDefined; 这种声明称为前向声明(forward declaration)。在执行完声明，但还没有执行完定义前，类NotDefined是不完整类型（incomplete type）。编译器知道了该类型是类，但还不知道其中包含有什么成员。 当创建一个类型的实例化时，该类型必须经过了定义。否则编译器不知道需要为他分配多少的内存。 不完整类型只能用于三个地方： 定义该类型的指针或引用 作为函数声明中的参数或者返回类型。注意是声明，不是定义 作为静态类型成为类的成员 在类的定义过程中，类还是不完整的。因为不完整类型可以用于以上三个地方，所以一个类型可以将本类型的指针或引用作为成员参数，或作为静态成员。也可以用本类型作为成员函数的形参和返回值。如： 123456struct TestNotDefined{ NotDefined *np; static NotDefined ns; NotDefined functionAboutNotDefine(NotDefined);}; Friendship Revisited 一个类可以将另一个类或者某个类中特定的成员函数作为友类或友函数。 Friendship between Classes 在类中定义另一个类为友类，同样需要使用关键字friend，另外还需要指定类型为class，如 123456//In Screen.hclass Screen{ friend class Window_mgr; ....} 与定义普通的友函数一样，定义友类的语句可以出现在类定义内部的任何地方。此时，虽然出现了Window_mgr类名，但并不需要Window_mgr类被定义，甚至不需要其被声明。 定义Window_mgr类的代码如下： 123456789101112131415161718192021222324//In Window_mgr.h#include &lt;vector&gt;#include &quot;Screen.h&quot;using std::vector;class Window_mgr{public: using ScreenIndex = vector&lt;Screen&gt;::size_type; void Clear(ScreenIndex index);private: vector&lt;Screen&gt; screens{Screen(5, 5, 'a')};};//In Window_mgr.cpp#include &quot;Window_mgr.h&quot;void Window_mgr::Clear(ScreenIndex index){ Screen &amp;s = screens[index]; s.content = string(s.height * s.width, ' ');} 这里因为需要真切的用到Screen类型，所以需要引入Screen.h文件。注意在函数Clear的实现中，访问了Screen中的private成员，如height和width。 友类或友函数性质不能传递，即A将B定义为朋友，B将C定义为朋友。但C并不是A的朋友，因此不能访问A中变量。 Making A member Function a Friend 上例中是将完整的Window_mgr定义为友类，所以类中的所有函数都可以访问Screen的私有成员，存在一定的风险性。Screen可以仅将Window_mgr中的Clear函数定义为友函数，如下： 12345678910111213141516171819202122232425262728293031323334//In Screen.h#include &quot;Window_mgr.h&quot;class Screen{ friend void Window_mgr::Clear(ScreenIndex); ....}//In Window_mgr.h#include &lt;vector&gt;class Screen;using std::vector;class Window_mgr{public: using ScreenIndex = vector&lt;Screen&gt;::size_type; void Clear(ScreenIndex index);private: vector&lt;Screen&gt; screens;};//In Window_mgr.cpp#include &quot;Window_mgr.h&quot;#include &quot;Screen.h&quot;void Window_mgr::Clear(Window_mgr::ScreenIndex index){ Screen &amp;s = screens[index]; s.content = string(s.height * s.width, ' ');} 注意当设置某类中的成员函数作为另一个类的友函数时，要额外注意引用依赖问题。 在本例中，因为在Screen类里要访问Window_mgr中的clear函数，所以这时就必须引入（include）Window_mgr.h。但这就会造成Screen.h中include &quot;Window_mgr.h&quot;，Window_mgr.h中include &quot;Screen.h&quot;的相互依赖。 实际上在Window_mgr.h中根本不需要访问Screen类中的成员，而仅仅是将Screen类作为形参类型和Vector中元素类型，因此完全可以使用不完整类型，即仅仅声明Screen类，代码中写为class Screen;。而在Window_mgr.cpp中因为需要访问了Screen类中的成员，所以必须引入Screen.h。 总结定义和声明顺序应该为： 定义Window_mgr类，其中只能声明Clear函数，不能定义Clear函数，否则就需要访问到Screen中的成员，则必须引用Screen.h，这里要避免引用。当需要用到Screen类型本身时，声明Screen类。 定义Screen类，其中声明Window::mgr为友函数。此步骤需要引入Window_mgr的定义。 定义clear函数，此步骤需要引入Screen类定义 Overloaded Functions and Friendship 在声明一个函数为友函数时，需要带上函数的返回类型和参数。因此当友函数有重载类型时，仅会将满足友函数定义的那个版本作为友函数。 Friend Declarations and Scope 如之前所述，友类和友函数的声明，并非是该函数的真正声明。该函数未进行外部声明时，仍然是无法被其他的函数使用的，如下代码所示： 12345678910111213struct X{ friend void f(); // X() { f(); } //error void g(); void h();};// void X::g() { return f(); } //errorvoid f() {}void X::h() { return f(); } 虽然代码中声明了f()为友函数，但构造函数和函数g()都是在外部声明前想访问函数f()，所以都会造成编译错误，而h()在外部声明后再进行定义，因此就能正常访问。 Class Scope Scope and Members Defined outside the Class 类的定义本身就是一个作用域，因此在类外定义成员函数时需要加上::操作符。 当成员函数的名字出现后，它的参数列表和定义主体就是在作用域里面的了。因此在参数列表和定义主体中访问类中成员时不需要加上::操作符。但是返回类型是在作用域外的，所以返回类型是类中的成员类型，则需要加上::操作符。如下： 1234567891011121314151617181920212223//In Window_mgr.hclass Window_mgr{public: .... void Clear(ScreenIndex index); ScreenIndex addScreen(const Screen &amp;s); ...}//In Window_mgr.cppvoid Window_mgr::Clear(ScreenIndex index){ Screen &amp;s = screens[index]; s.content = string(s.height * s.width, ' ');}Window_mgr::ScreenIndex Window_mgr::addScreen(const Screen &amp;s){ screens.push_back(s); return screens.size() - 1;} 在例子中，当ScreenIndex出现在了参数列表中时不需要加上Window_mgr::修饰作用域，但是当ScreenIndex作为返回类型时则必须加上。 Name Lookup and Class Scope C++找寻一个名字的含义时步骤是： 现在使用该名字的作用域里搜索该名字的声明，声明必须出现在使用之前 如果名字在当前作用域没有找到，在其嵌套的作用域中寻找（同样需要出现在使用之前） 如果找不到声明，则报错 类编译的顺序为： 先编译所有的声明 所有声明编译完，整个类的成员都是可见后，再编译函数主体等定义部分。 Name Lookup for Class Member Declarations C++找寻名字的策略和类编译顺序共同决定了以下结果： 当名字出现在返回类型或者参数列表中时，该名字必须在使用前已经声明过 当名字出现在成员函数主体中时，如果在使用该名字前无法在函数内部找到该名字的声明，则在类内部搜索该名字，所有的类成员变量都会被搜索，无论它的出现顺序。 如： 123456789typedef double Money;string bal;class Account{public: Money balnce() { return bal; }private: Money bal;}; 在上述代码中，函数balance返回的bal是成员变量Money bal，而不是全局变量string，即使成员变量的声明在全局变量bal使用后面。 Type Names Are Special 通常而言，Type声明可以在嵌套的作用域中重新修改，如下： 12345678typedef double Money;void testTypedef(){ Money i; typedef int Money;//correct Money j;} i的类型为double，j的类型为int。 但是在类中不允许重新定义，即使是一样的类型，如下： 12345678910typedef double Money;class Account{public: Money balnce() { return bal; }private: // typedef double Money; //error, class not allow redefine Money bal;}; 很多的编译器仍然会允许类内进行type重定义，但这样的行为是不符合标准的，无法保证在更换了编译器后仍然能正常工作。 Normal Block-Scope Name Lookup inside Member Definitions After Class Scope, Look in the Surrounding Scope 12345678910111213141516171819//In Screen.cppint height = 5;void Screen::dummyFcn(pos height){ cout &lt;&lt; &quot;height is &quot; &lt;&lt; height &lt;&lt; endl; cout &lt;&lt; &quot;Screen height is &quot; &lt;&lt; this-&gt;height &lt;&lt; endl; cout &lt;&lt; &quot;Global height is &quot; &lt;&lt; ::height &lt;&lt; endl;}//In Chapter7_Classes.cppScreen s(10, 2, ' ');s.dummyFcn(3);/*height is 3Screen height is 10Global height is 5*/ Constructors Revisited Constructor Initializer List Constructor Initializers Are Sometimes Required const成员变量必须通过初始化列表进行初始化，因为在构造函数体内部的操作实际上是赋值不是初始化，如下： 1234567891011121314151617181920class ConstRef{private: ConstRef(int ii) : ci(ii), ri(ii) { i = ii; } // ConstRef(int ii) //error // { // ri = i; // ci = i; // i = ii; // }public: int i; const int ci; int &amp;ri;}; 上述代码中，ci和ri必须通过初始化列表进行初始化，而i可以出现在初始化列表中（初始化），或者在出现在构造函数体内（先被默认初始化，因为是内置类型，所以结果为未定义，再将ii赋值给它） Order of Member Initialization 成员参数的初始化顺序是由其在声明中出现的顺序决定的，和在初始化列表中的顺序无关。如： 1234567891011121314151617181920212223class Num{public: Num(int val) : j(val), i(j) {} void Print() { cout &lt;&lt; &quot;i value is: &quot; &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; &quot;j value is: &quot; &lt;&lt; j &lt;&lt; endl; }private: int i; int j;};Num n(2);n.Print();/*i value is: 0j value is: 2*/ 在上例中，初始化列表中是先出现用val值初始化j，再通过j初始化i。但因为类的声明顺序中，是先声明了i再声明j。所以实际上的运行逻辑为，用未定义的j初始化了i，再通过val值初始化了j。 因此输出结果为i为0，j为2，i的值实际上是未定义的。 Delegating Constructors 代理构造函数时可以通过该类中的另一个构造函数来完成初始化，如 1234567891011121314151617inline Sales_data::Sales_data(const string &amp;s, unsigned n, double p) : bookNo(s), units_sold(n), revenue(p * n){ cout &lt;&lt; &quot;Constructor with 3 parameters&quot; &lt;&lt; endl;}inline Sales_data::Sales_data() : Sales_data(&quot;&quot;, 0, 0){ cout &lt;&lt; &quot;Constructor with no Parameters&quot; &lt;&lt; endl;}inline Sales_data::Sales_data(const string &amp;s) : Sales_data(s, 0, 0){}// inline Sales_data::Sales_data(istream &amp;is) : Sales_data(),revenue(0) { read(is, *this); }inline Sales_data::Sales_data(istream &amp;is) : Sales_data(){ read(is, *this);} 注意，当使用了代理构造函数时，初始化列表中就不能出现其他的变量初始化了，如上述代码尝试同时使用代理构造函数和初始化revenue就失败了。 当一个构造函数使用另一个代理构造函数时，代理构造函数的列表初始化会先运行，然后它的函数体会执行，最后执行本构造函数的函数体，如使用语句Sales_data s调用无参构造函数，它会调用三个参数的代理构造函数，输入结果如下： 1234/*Constructor with 3 parametersConstructor with no Parameters*/ 可以看出，三个参数的代理构造函数先运行了，然后运行的是无参构造函数。 The Role of the Default Constructor 无论一个对象是被默认初始化还是值初始化（相关概念在3.3.1节中），默认构造函数都会被执行。 默认初始化在以下情况会发生： 当在代码作用域中定义了非static的变量或者数组，且数组没有初始化列表（{}） 当一个类有使用合成默认构造函数的类成员。 当类中的成员在构造函数中并没有通过初始化列表进行初始化，这些成员会被默认初始化。 值初始化在以下情况发生： 定义数组时，提供了初始化列表，但是列表大小小于数组大小，剩余元素被值初始化。 当定义局部static变量 对于类类型，使用T()形式进行声明，所以Vector(n)，里面的元素都进行的是值初始化。 Using the Default Constructor 1234567891011121314151617181920class NoDefault{public: NoDefault(const string);};struct A{ NoDefault my_mem;};// A a;// A a = A();struct B{ // B(){}; //error B() : b_member(&quot;&quot;){}; NoDefault b_member;}; 上述代码中，NoDefault没有默认构造函数。当A包含有NoDefault类型的成员，A的合成默认构造函数就无法使用，因为其无法调用NonDefault变量的默认构造函数。 语句A a;使用的是默认初始化，A a=A()使用的是值初始化，但两者都无法通过编译。 同理，在B中必须手动的在初始化列表中为NonDefault类型变量初始化，否则在尝试调用其默认构造函数时会发生错误。 Implicit Class-Type Conversions 可以通过一个参数被调用的类构造器提供了隐式类型转换，从调用参数转换为该类型。 如Sales_data类提供了只需要一个const string引用的构造函数： 123inline Sales_data::Sales_data(const string &amp;s) : Sales_data(s, 0, 0){} 因此可以从const string类型隐式转换为Sales_data，如下： 1234567891011Sales_data &amp;Sales_data::combine(const Sales_data &amp;rhs){ units_sold += rhs.units_sold; revenue += rhs.revenue; return *this;}string null_book = &quot;9999&quot;;Sales_data item;item.combine(null_book); 上述代码中null_book会隐式转化成Sales_data对象，然后传递给combine函数。 注意这一步中，null_book隐式转换成的对象是一个临时变量，当combine函数执行完后就会被抛弃。 Only One Class-Type Conversions Is Allowed 需要注意，语句item.combine(&quot;9999&quot;)无法通过编译。 因为&quot;9999&quot;类型是C类型的字符串，它要先隐式转换为string，string再隐式转换为Sales_data，该过程包含了两次隐式转换，而C++的隐式转换仅支持一次，所以编译器无法执行。 Suppressing Implicit Conversions Defined by Constructors 可以通过explicit关键字禁止构造函数的隐式转换，explicit关键字仅能出现在类内的成员函数声明中。如 12345678910111213class Sales_data{public: explicit Sales_data(const string &amp;s); ....}string null_book = &quot;9999&quot;;Sales_data item;// item.combine(null_book);// error, when constructor isexplicititem.combine(Sales_data(null_book));//Direct Initializationitem.combine(static_cast&lt;Sales_data&gt;(null_book));//static_cast 在上述代码中可以看到，Sales_data构造函数被定义为了explicit，隐式转换不再能执行，但仍然可以通过直接初始化和static_cast进行转换。 标准库中： string类型有通过const char*的构造函数，如string(&quot;abc&quot;)，该构造函数不是explicit的 vector类型中有通过int的构造函数，如vector(2)，该构造函数是explicit的 Aggregate Classes 如果一个类满足以下条件，则它是一个聚合类（Aggregate Classes）： 所有的成员变量都是public的 没有定义任何的构造函数 没有任何的类内初始值（如int a = 1） 没有基类，没有虚函数。 如下就是一个聚合类： 12345struct Data{ int ival; string s;}; 对于聚合类，可以通过大括号进行初始化，大括号中的参数按顺序与聚合类中定义的变量一一初始化。如果大括号中的参数数量小于聚合类中的数据数量，后面的参数进行值初始化。如下： 12Data val1{0, &quot;Anna&quot;};Data val2{0}; Literal Classes //TODO,after read 2.4.4 static Class Members 当给成员变量加上static关键字后，该变量就变成了静态成员变量，静态成员变量也受到public，private等关键字的影响。 静态成员可以是const的，但静态函数不允许是const的。如下所示： 1234567891011121314151617181920212223class Account_S{public: void calculate() { amount += amount * interestRate; } static double rate() { return interestRate; } static void rate(double);private: string owner; double amount; static double interestRate; static const double cRate; static double InitRate(); // static double CInitRate() const; //error static member function can't be const}; 一个类的对象实际上并不包含其中的静态成员，因此静态函数也没有this指针，所以定义为函数定义为const与否并没有意义。 Using a Class static Member 可以通过作用域操作符，对象本身，对象引用，对象指针等来访问静态成员，如下： 12345double r = Account_S::rate();Account_S ac1;Account_S *ac2 = &amp;ac1;r = ac1.rate();r = ac2-&gt;rate(); 对于普通成员函数而言，可以直接通过访问静态成员，如Account_S中的方法calculate，其中直接访问了静态成员interestRata。 Defining static Members 当在类外定义静态成员函数时，不需要再次写明static关键字，如： 1234void Account_S::rate(double rate){ interestRate = rate;} 因为静态成员变量不是类对象的一部分，因此不能使用类内初始值，也不会被构造函数初始化（但可以在构造函数函数体内赋值），如 12345678910111213141516class Account_S{ // Account_S() : interestRate(0) //error // { // } Account_S() { interestRate = 0; } ... // static double interestRate = 2;//error static double interestRate; ···} 当尝试使用类内初始值时就会发生编译错误，静态成员变量的初始化过程与静态成员函数定义过程相同，如下 12345678910111213141516//inside classclass Account_S{public: typedef double RateD;private: static RateD interestRate; static double interest; static double InitRate() { return 0; }...}//outside classAccount_S::RateD Account_S::interestRate = InitRate();double Account_S::interest = 2.0; 如同在定义成员函数时一样，当成员函数的名字出现后，参数列表和函数主体就已经在作用域内部了。同理在上述定义中，当成员变量interestRate名字出现后，其余的部分就已经在作用域里了（变量的参数类型在名字出现前，所以不在作用域里），因此InitRate不需要使用作用域操作符来访问。 In-Class Initialization of static Data Members //TODO，关于 costexpr static Members Can be Used in Ways Ordinary Members Can’t 当一个类型是不完整类型时，无法使用该类型作为类中普通成员变量的类型，但可以作为类中静态成员变量的类型，如 123456class Bar{ ... static Bar mem1; ...} 可以在类中使用静态成员变量作为成员函数的初始值，而普通成员变量不行，如 1234567891011121314class Account_S{public: // void TestDefaultValue(double a = amount) // { // }//can not use member variable as default parameters void TestDefaultValue(double a = interest) { }//can use member variable as default parametersprivate: double amount; static double interest;} 引用： Cpp Primer 5th Aug.2012","link":"/CPPPrimer-Chapter7-Notes/"},{"title":"《Formal ABstract Design Tools》 笔记","text":"该文是作者Doug Church在1999年发布在GAMASUTRA上的文章。 作者认为当前阻碍游戏设计发展的是没有足够的词汇去描述游戏中的设计。 因此他提出了Formal Abstract Design Tool框架，作为一个词汇工具集。 在文章中作者着重讨论了目的，可预测结果和故事三个工具。 Formal Abstract Design Tools 游戏在科技方面的发展很迅速，但是在设计方面的发展却不尽如人意。 游戏设计是关于玩家的目标和节奏，是游戏设计让游戏成为了游戏。否则游戏光盘中装的只是数据而没有关于游戏的体验。 How Do We Talk About Games 游戏设计最大的障碍在于，缺少一个通用的设计词汇。 对于技术而言，又非常多的专业词汇来描述技术问题，但是对于游戏设计，往往讨论就只停留在有趣和不有趣。 A Language Without Boarders 目前游戏设计中的设计词汇大多限定在特定的游戏分类中，如可以去谈论RTS游戏中，每个单位该如何平衡。但是很少有去谈论如何汲取RTS游戏的优点，然后运用在RPGs游戏中的。 因此作者提出了&quot;Formal Abstract Design Tools&quot;（后简称FADT）这一概念，他实际上是一个针对于游戏专业词汇的框架。 Formal表示它是一个精确的，形式化（即可以运用到别的种类游戏上）的描述。如“有趣的东西”就不是一个Formal的描述，它不够精确，这一个并不精确的描述也无法运用在其他游戏上，而“玩家奖励”就是一个Formal的描述。 Abstract表示它是一个抽象的描述。如“+2攻击力的巨人之剑”就不是一个抽象描述，对应的是抽象描述是“玩家能力提升曲线”。 Let’s Create a Design Vocabulary——What Could Possibly Go Wrong？ 要注意FADT本质上还是只是工具，作为设计师，还是需要判断出什么是有趣的，游戏是关于什么的，你想展现给玩家的是什么，这才是构建出游戏的关键。这就如同房子不是由工具建成的，房子是由砖瓦构建而成的，工具之hi是帮助作用。 FADT只是一个工具，一个关于词汇的工具。设计师们只是用他来挑选出游戏中值得注意且能运用到自己游戏中的部分，并用合理的词汇将其描述出来。如上述的“玩家能力提升曲线”就是工具箱中的一个工具，一个FADT，设计师可以考虑将其运用到自己的游戏中，或不运用。 Tools Would Be Useful——Where Do We Find Them? 使用FADT最好的例子就是找一个优秀的游戏，从中抽离出一些概念并将其抽象化和形式化，让他可以运用到别的种类的游戏上。 Mario 64 Game Play 这一节是作者对于《超级马里奥64》的描述 在《超级马里奥64》中，玩家始终有很多事去做，但他们同时被给予了大量的选择（要去探索世界的哪一块，要去拿哪个额外的星星）。因此在游戏中，玩家花了大量的时间去决定“接下来要去做什么”，而不是去“找”要做什么。 这个游戏还有个重要特征是，在每个世界中，玩家会同时有多个目标。通常在进入每个世界后的第一个星星，是会鼓励玩家探索世界中的绝大部分区域。 马里奥的游戏世界是统一且可预测的。玩家能做的基本操作很少，很简单（移动，跳跃和一些简单交互）。但是这些简单的操作可以做出非常多的交互（跳跃踩怪兽等）。更重要的是所有的结果是恒定的，如三段跳的高度是固定的，跳到怪兽头顶上，怪兽就会死。一些额外能力的引入也是缓慢但同时恒定的，如钢铁马里奥一定能在水下走。 这些简单，恒定操作构建出了一个可预测的的物理世界，玩家在尝试些新鲜事物前通常可以准确的猜出会发生什么。怪物和游戏环境会增加游戏的复杂度，但他们也是缓慢的被引入，而且是在已有的交互原则上。这些都会让游戏内发生的情况是可预测的，当玩家遇到高强，新的怪物，新的地形，他们都能开始如何用已有的技能去解决，并且基本能猜出结果。 这些也会让玩家在游戏过程中有一个复杂的游戏计划过程（sophisticated planning process）。他们被潜移默化的告知了游戏中的规律，而且也直到他们的目标是什么。因此他们通常在潜意识中就已经构建了接下来要去做什么的计划。在游戏中，玩家在没有意识到情况下就已经做出了几千个要去做什么的计划。 更重要的是，玩家在做出计划并得到结果后，他能理解为什么成功或失败。如果必要的话，他们可以基于前一次尝试得到的经验去做进一步的计划。 玩家在游戏中很少有被欺骗感（觉得游戏是假的），他们很少有想要尝试某些东西，但是游戏不支持的情况。虽然马里奥的世界中支持的行为不多，但是它们都被实现的非常完整。这个世界是简单的，但却是统一的，如果它提供给了你一些东西，那么它们就是能被使用的。因此不会有玩家做出“为什么没法在游戏中生火做饭”之类的抱怨（游戏中根本就没有火这个素材，玩家在游戏体验中不会意识到）。 Great! But I’m not Writing Mario 64. I Mean, It’s Already Been Written 作者在上一节中描述了《超级马里奥64》游戏，在这一节中他会对其进行分析。即抽取出FADT 首先，可以看到玩家在游戏中是被鼓励构建出自己的目标并且对它们做出行为的。关键点在于玩家知道在游戏世界中可以发生什么，因此他们对于发生的情况是有掌控感的。目标和控制是可以从不同的层面去实现的，从“小而快速”的目标“穿过面前的桥”到“复杂而长期的”目标“获得额外的红色星星”。 这个“收集目标，理解世界，做出决策，行动”的过程，是很能帮助玩家融入游戏世界的。作者在这里将这个过程形式化并抽象称为目的（Intention），如之前所述，目的可以是不同层面的，从小而快速到复杂而长期。这是作者给出的第一个FDAT，定义如下： 目的：玩家根据当前游戏世界的情况和已知的可选行为，做出一个可行的计划 马里奥世界的简单而统一，让玩家觉得他们对于自己的行为是负责的，即当一个错误情况发生时，他们也能知道其发生的原因。作者将其称为可预料结果（Perceivable Consequence），这是第二个FDAT，定义如下： 可预料结果：游戏世界可以对玩家的行为做出清晰的反馈。 Same Tools，Different Games 这一节作者讨论上述两个FDAT如何用在别的游戏中，如RPGs 在RPGs中，当一个事件发生时，背后的逻辑就是“因为X，所以Y发生了”，这无疑是可预料结果的一种应用。 但是RPGs游戏中对于结果的展示并不如马里奥那样直接。如玩家选择在一个旅店住宿，设计师们为了避免玩家一直待在旅店中，会让某些早上玩家出旅店后遇到盗贼。对于设计师而言，玩家遇见盗贼是一个可预料的结果，但是对于玩家而言，却是一个随机事件。 同样的，还有些结果是玩家“认为”可预料的，但是却有不同的结果。如玩家在交叉路口选择走的方向，然后走上了一条路，但意外的遇到了盗贼。这确实是对玩家行为的结果，但并不是玩家所预想的结果，玩家选择某条路通常是认为这条路会有好处，但结果却是坏的。这种情况类似于“做X其实会导致Z，但是你并不知道”。 在RPG中最好的方法就是让可预料结果和目的结合在一起。如上述交叉路口选方向的例子，结果的确不是如玩家所想的一样，但是这是玩家玩家自己做出的选择，即玩家在他的目的中采取的行为，这同样给玩家提供了可控感。相反，如果这个结果是设计师提供的，即“你必须走这条路，然后收到盗贼的攻击”，对于玩家而言可能就是一个恼怒的事了，而且对于游戏的参与感也会明显降低。 Same Game，Different Tool 在RPGs中可能有时候会强迫玩家进入某种情况，即是这样做会让玩家失去对游戏的控制感。通常会发生这种情况，是因为设计师需要控制游戏剧情的走向。故事（Story）表示在游戏过程中的叙事线索。 这个线索可能是设计师驱动的，即设计师有一个预先存在剧本。 同样线索也可能是玩家驱动的，如马里奥中，玩家在游戏中的行为构成了故事，故事从游玩开始，到游玩结束。像NBA live这种偏竞技的游戏中，更为如此。其中还有如赛季模式等东西，一定程度上加深了玩家对于故事的把控能力。 故事是第三个FADT，定义如下： 故事：一个将游戏中的事件结合在一起，并推动游戏进程的叙事线索，该线索可以是设计师驱动的，也可以是玩家驱动的。 Using Multiple Tools:Cooperation,Conflict,Confusion 这一节作者谈论了多个工具之间可能造成的冲突和取舍。 冒险游戏通常有比较少的可预测结果和目的。玩家做的是去各个地方，捡取各种东西，和人交流来找寻“设计师的目的”。在较低的层面上，玩家会有“我去拿这个东西，我认为这个东西对我有用”和足够的关于“果然有用”然后让剧情推进的反馈。但这其中不是玩家设立目标和表达欲望的过程，这行为本质上是测试设计师提供的几个选项，玩家必须找出其中工作的一个选项，否则剧情无法推进。 相交而言，马里奥世界中的一些行为则是纯粹的玩家目的，如“收集额外的星星”，玩家不去进行也完全不影响游戏进度。 而冒险游戏之所以做出较少的可预测结果和目的，是为了获得更多的故事。在这些游戏中，会有设计师所设计的那些激动人心的关键时刻，一些重要剧情，设计师们想要用这些来吸引玩家。 所以这就是目的和故事之间的冲突，当设计师越想要创建特定的故事，让玩家自定义目的的可能性就越小。 Concrete Cases of Multiple Tool Use 这一节作者给出了故事和目的冲突的具体例子 例如游戏最终幻想中，故事的主线是由设计师决定的，在这一部分玩家并不能进行太多的计划和实现自己的目的。但是游戏中的角色和战斗策略却是完全自由的，玩家完全可以通过自己的策略，用的东西，combo来实现完全的控制。另外这探索故事的时候，探索的节奏也是玩家自我掌控的。 概括来说，虽然故事情节是固定的，但是其中的其他细节是玩家可控的。例如情节会强迫你与过去的盟友发生战斗，但是战斗的方式策略则是完全自定义的。 即在最终幻想的战斗系统中，设计师使用了目的和结果两个工具，而在情节框架中使用了故事和结果，设计师并没有盲目的尝试一下子将所有的工具都放在一起。 而所有的战斗和体育游戏，不太严谨地说，都是将三个元素合在了一起，但是稍微有些区别。 战斗和体育游戏的故事是完全交由玩家控制的。玩家的选择会导致游戏走向一个玩家自己决定的结局（大比分胜利，小比分胜利等等）。 两个游戏也都能看到自己行为的固定结果。当玩家学会操作后，他就会因为游戏给他的反馈（可预测的结果）做出自己的计划（目的）。 但两者略微不同的在于，在战斗游戏中，所有的结果都是直接的。因此当看到一个玩家比自己打的好的时候，你能明显的感受到他更优秀的原因。而在体育游戏中，还有一个数值层面（Statistical Layer），即概率或角色的能力，玩家相同的操作并不一定导致相同的结果。因此在体育游戏中，虽然玩家同样有计划，但是结果并不像战斗游戏那样的直接和可预测。 Tool-Based Analysis 上述的战斗游戏，他提供了一个简单的故事，故事是由玩家完全掌握的。对于体育游戏而言，他同样有目的和结果，但不像战斗游戏那样直接和可预测。因此，战斗游戏对玩家而言产生了一个更真实的故事，但是体育游戏却提供了一个更有传奇性的故事，毕竟故事中是需要不确定因素的。很难说这两者谁更好。 Ahhh，So What？ FADT是一个帮助分析的词汇工具，他帮助游戏设计师们专注于要提供玩家怎么样的体验（更精确，抽象的表达）。 游戏与书，电影或其他媒体不同的是，那些媒体是通过技术让观众们感受到作者想要他们感受的情感，让观众做出作者们想要他们做出的反应。而游戏一定程度上是要玩家沉浸在游戏中，做出 自己的决定，这一定程度上是让玩家探索自己，这也就是游戏媒体的独特性。 因此作者用FADT作为自己理解游戏设计每一个部分的工具，用它来最大化玩家对于游戏和自己的沉浸感。 作者在这篇文章中提到了目的,可预测结果,故事三个工具，而整个工具集应该有许许多多的其他工具，如资源经济，玩家学习、玩家能力曲线、奖惩关系等等。每一个主题都能专门写一篇文章来从特定角度对游戏进行分析。 引用： Formal Abstract Design Tool 怎样去设计一款优秀的现代电子游戏？","link":"/FormalAbstractDesignTools-Notes/"},{"title":"《Game Design Workshop》 第三章笔记","text":"《Game Design Workshop》 第三章笔记，这一章关于游戏中的常规元素。 包括，玩家、目标、流程、规则、资源、冲突、边界、结果。 Chapter 3 Working with Formal Elements 常规元素（Formal Elements）是那些组成游戏的元素，包含玩家，目标，流程，规则，自愿，冲突，边界和结果，这些构成了游戏的本质。 当充分了解这些元素后，就可以对他们进行结合来创造自己的新类型游戏。 Players 游戏是为玩家的游戏体验而设计的，玩家必须遵守游戏的规则和限定才能玩游戏。 以下是一些游戏中针对玩家设计可以考虑的方面。 Invitation to Play 游戏中最重要的时刻之一就是游戏的邀请阶段。对于桌游而说，游戏的邀请是社交部分。对于电子游戏而言，邀请阶段通常只是简单的开始按钮，但是有一些游戏它们有独特的邀请方式，如吉他英雄（Guitar Hero）通过拨弄吉他开始游戏。设计一个游戏的邀请阶段能让一款游戏更加的引人注目。 Number of Players 对于玩家人数是固定的游戏和对于玩家人数是变换的游戏，两者设计的思路是不同的。许多电子游戏仅支持一个游戏玩家，这种游戏的结构是让玩家与游戏系统竞争。也有许多游戏设计为多位玩家，如大富翁（Monopoly），EVE，WOW，但是这些游戏在一定程度上也是能支持一个玩家游玩的。如魔兽世界，即使一个人玩，游戏中的许多元素也让游戏体验足够有趣。 Roles of Players 一些游戏其中的所有玩家都有相同的角色（这里角色指的是玩家的任务），如大富翁，围棋。 还有一些游戏，不同的玩家扮演着不同的角色，如珠玑妙算（Mastermind，一个密码破解游戏），一个玩家扮演密码编写者，其他的玩家扮演密码破解者。 游戏的角色定义了玩家的基本能力，大部分的网络游戏都提供了多种不同的角色。对于多角色的游戏，定义核心不同的橘色和平衡各角色之间的能力是关键问题。 Player Interaction Patterns E.M.Avedon在文章The Structural Elements of Games中将玩家的交互分为&quot;玩家对抗游戏&quot;和“多个玩家之间的对抗”。这里作者将Avedon的概念进行进一步的细分，分为如下七种： Single player versus game 这种游戏结构是玩家与游戏系统进行对抗。因为这种架构中没有其他的玩家，所以游戏的冲突通常是通过解密或者其他的方式来表现。 Multiple individual players versus game 这种游戏结构是多个玩家一起与游戏系统进行对抗，但是玩家之间并不一定需要交互，甚至可以不再一个时间点。这种游戏结构在Facebook这种社交网站出现后变得流行。这种游戏本质上还是单人游戏，只不过多个玩家会一起与同一个系统进行对抗，它在不希望竞争的，但又希望有社交元素的玩家中很流行，如赌场游戏（多个人会使用一台老虎机）。 Player versus Player 这种游戏结构是两个玩家直接进行对抗。这在策略游戏和竞争游戏中是一个经典的结构。 Unilateral competition 这种结构是多个玩家一起对抗一个玩家，称为单边竞争。如桌游苏格兰场（Scotland Yard），其中一个玩家是罪犯，他了解游戏的所有信息，而其他玩家扮演侦探，他们必须一起合作找出罪犯的线索。单边竞争是一个将游戏的合作性和竞争性结合在一起的结构。 Multilateral competition 这种结构是三个或更多的玩家直接对抗，1v1v1，称为多边对抗。如大富翁就属于这种类型，通常提及多人游戏时就是指这种结构。许多桌游设计成玩家人数需要是三到六人，这种人数是直接对抗的理想人数。 Cooperative play 这种结构也是对各玩家一起与游戏系统对抗，但与第二种结构不一样的是，在这个结构中玩家需要相互合作。 Team competition 这种结构中，两个或更多的小组相互对抗。传统的运动如足球，篮球就是这种模式。这种模式不仅对于参与者有重大的吸引力，对于旁观者也同样如此，所以传统的运动会诞生粉丝文化。 Objectives 目标是玩家需要追求的东西，它定义了玩家在游戏规则下需要完成的东西。在理想状态下，目标对于玩家而言，应该是有挑战性的同样也是可完成的。 目标的存在不仅为游戏提供了挑战，同样也为游戏定下了基调。目标不仅仅是游戏的基本元素，它也提供了游戏的戏剧部分，理想状态下游戏的目标应该与游戏中的故事能完美融合。 许多学者尝试为游戏的目标进行分类，主要分为如下几种： Capture 捕捉游戏的本质是摧毁或得到对手的某些东西，同时避免被对手捉到或杀死。从古时起，这种设计思路就深深的嵌套在游戏中，比如常玩的木头人，就是这一类的游戏。 Chase 追逐游戏的目标是抓住对手或者从对手手上逃离。 追逐游戏可以是玩家与游戏系统的对抗，玩家与玩家的对抗，或者单边对抗。 追逐游戏可以由速度和灵活度决定。 苏格兰场也算是一种追逐游戏，只不过使用的是逻辑和推导来逃离玩家的追逐。 Race 比赛游戏的目标是在其他玩家前达到某种目标。比赛游戏可以是基于物理的灵活性（速度等），或者是基于概率。 Alignment 对齐游戏的目标是将游戏中的元素按一定的空间规则排列在一起或分类游戏中的元素。俄罗斯方块就是属于这种类型。 Rescue or scape 逃离游戏的目标是达到一个游戏设计的安全区域。通常这个游戏目标是与其他的游戏目标结合在一起的。 Forbidden Act 禁止行为游戏的目标是通过错误的移动，谈话或者任何玩家不应该做的行为来破坏游戏规则。 如游戏Don’t break the ice就属于这种类型： 这种游戏类型在电子游戏中很少见，可能是因为没法直接的进行物理竞赛，也很难游戏的公平性。 但是任天堂的switch中有许多关于这种类型的游戏 Construction 建造游戏的目标是建造，保持和管理物体，这种游戏可能包含直接或间接的竞争。如模拟人生就是这种类型的游戏。 这种类型的游戏通常是将资源管理和交易来作为游戏中的重要元素，游戏也是通过策略选择而非灵活性或概率进行比赛。 Exploration 探索游戏的目标是探索游戏场景。这种游戏通常是与其他更复杂的目标捆绑在一起的。例如塞尔达传说，游戏的目标不仅仅是探索世界，还要解密神庙，救出公主等。 Solution 解密游戏的目标是在解决一个困难或谜题。许多的游戏会被归纳与其他的游戏类型，但其中包含解密部分，如上述的塞尔达传说 Outwit 智慧游戏的目标是通过收集和使用知识来击败别的玩家。 有的智慧游戏是通过游戏外的知识来进行比赛，还有一些是利用游戏内知识，如 游戏的目标并不是单独存在的，一个游戏的目标很可能是上述多个种类的目标混合在一起。游戏设计者应该尝试将不同的目标结合在一起，看是否会创造出一个更加有趣的可能。 Procedures 流程（Procedures）是游戏的玩法，也是“玩家”为了达到目标能采取的行为。 对于桌游来说，游戏的流程通常是写在纸上让玩家阅读的。对于电子游戏来说，游戏的流程通过蕴含在了游戏的操作手册中（因为流程就是玩家采取的行为，操作一定程度上代表了流程）。 通常来说，游戏有以下几种流程： 开始的行为（Starting action）：如何让游戏开始 逐步进行的行为（Progression of action）：在游戏开始后，持续不断的行为。通常就是游戏进行中主体（Core loop）。 特殊行为（Special actions）：游戏进行中的特殊事件，因为游戏中的其他元素或状态的改变而变得可执行的行为。 解决的行为（Resolving actions）：让游戏走向结束的行为 如对于马里奥游戏，按下游戏开始键就是开始行为。在游戏进行中，玩家的前进，跳跃等就是逐步进行的行为，而诸如马里奥在水中按下前进就会游泳，吃下花朵就可以发射火球等就是特殊行为，马里奥并没有一个解决的行为，因为游戏是否正常结束是由游戏本身决定，而非玩家本身。 System Procedures 电子游戏相对于传统游戏而言复杂了许多，电子游戏有在后台运行的系统流程（System Procedures），这个流程会对玩家的行为和游戏的情景做出相应反应。 传统的桌游实际上也有相同的工作，如大富翁中，需要玩家判断踩到了别人的土地后要付多少的租金，需要通过筛子来引入随机因素。只不过因为在电子游戏的这些事件可以交由系统来进行，所以这些计算可以变得更快。 但这不意味着电子游戏就一定比传统的游戏更加复杂，一些简单的行为可以导致异常复杂的结果。如围棋中的行为，只是双方下棋，但是其背后的逻辑可以异常复杂。 Defining Procedures 当设计游戏的流程时，要注意游戏环境的限制。例如设计桌游时，游戏的流程就不应该过于复杂。还要考虑游戏的交互方式，是使用手柄还是键盘鼠标等。 要特别注意游戏的主体（core loop）。对于电子游戏，游戏的主体包括检查游戏的状态，玩家是否碰到了某些东西，同时系统也要对玩家的输入做出相应反应，而对于非电子游戏而言，玩家需要自己去检查游戏的状态。无论是电子游戏还是非电子游戏，游戏的主体都需要设计的足够流畅，玩家可以轻松的执行流程中的每一步，让游戏正确的进行下去。 游戏的流程本质上是被游戏的规则还有游戏本身所限制的。设计师需要意识到这些限制，然后在限制中找到一个有创造性且优雅的方式来让游戏流程顺畅且容易被记住。 Rules 游戏规则定义了游戏中的物体和玩家可以执行的行为。 在桌游来说，游戏规则同样是写在纸上的，对于电子游戏来说，规则可以同样写在手册中，也可以通过游戏本身来透露。 当设计规则时，需要考虑到规则与玩家之间的关系。如果规则太多，玩家或许很难去理解游戏，如果规则太少，玩家则可能感到困惑。即使规则制定的很好，且被游戏系统完美的运行，玩家也同样需要通过某种方法了解规则，否则当某种情况发生时，玩家将觉得被系统所欺骗了（虽然系统行为是正确的）。 Rules Defining Objects and Concepts 游戏中的物体是由规则决定的，且游戏中的物体含义是与真实世界中的含义不同的，无论这些物体是完全虚构的，还是基于真实世界创建的。 例如象棋中的马和车，虽然是基于真实世界创建的的物体，但他们的运行规律是由游戏决定的。即使是基于真实世界创建 的，其含义也会与真实世界中的模板有或多或少的差异。 对于桌游来说，其设定的物体作为规则中的一部分，需要显式的告知玩家，通常还是通过纸质的说明书。玩家必须理解这些规则和物体，也正因为这个原因，桌游中的物体会被限定为比较简单的元素，通常只有一到两个变量或状态，而且是由物理特性来表示。如围棋中的棋子，只有两个变量，颜色和位置。 但是对于电子游戏而言，物体的变量可以非常复杂，因为它是由系统进行计算，玩家甚至不会意识到这么多的变量的存在。如怪物的属性，攻击位置，攻击力，魔法值等等等等。玩家也不会&quot;精确&quot;的知道这些变量，即使是最专业的策略游戏玩家，也不会将游戏完全的变成一场数学运算，玩家通常是通过直觉来去获知这些变量。 当设计游戏中的物体时，需要特变注意玩家是如何去理解这些物体的特质的。例如如果变量过于复杂，玩家是否会造成困惑，如果变量过于简单，玩家是否有能力区分物体等。 Rules Restricting Actions 规则限定了玩家的行为，这个可以从三方面考虑： 规则弥补了游戏的漏洞。 如大富翁中，“进监狱时并不会因为通过起点获得200元”，避免了这个惩罚行为实际造成了奖赏。 规则可制定游戏的基本形式。 如“足球是两个由11人组成的队伍在360*160英尺的场地上的竞赛”，这个规则限定了每队的玩家人数是11人，游戏的边界是360*160。 实际上游戏的规则和流程制定了所有其他的元素 规则提供了平衡性。 如魔兽争霸中，“必须要三本建筑才能造某些兵种”，避免了玩家一开始就憋钱造高级兵种带来的不平衡。 Rules Determining Effects 规则同时在特定情况下触发某些效果，即&quot;如果XXX发生了，那么XXX&quot;。 通过规则触发效果有以下好处： 它为游戏创造了变量。条件并不是在游戏中一直存在的，所以它可以给玩家带来特殊的体验和惊喜。 它可以让游戏重回正轨。如塞尔达中的体力值，游戏并不希望体力值作为一个非常重要的存在，如用完了体力值林克就会死，但是也不希望体力值变成一个随意挥霍的东西，游戏需要提供一个方法让玩家知道需要节省体力值。于是游戏设置了“如果体力值用完了，那么体力值的回复会变慢”这样的设定。 Defining Rules 和指定流程时一样，指定规则时也要注意游戏本身的限制。对于玩家而言，规则需要是清晰的，玩家要直接通过本能就了解游戏的规则，这样游戏才能看起来是公平的，反应良好的。 通常来说，指定的规则越复杂，就需要花越多的努力让玩家理解规则。玩家对于规则理解的越少，他们就越不可能做出有意义的选择，也就越不觉得对于游戏有足够的掌控。 Resources 在现实生活中，资源是用来达成目标的资产，在游戏世界中也基本是这样。 管理资源和决定玩家什么时候和怎样去接触资源是游戏设计工作中的重要部分。设计师需要决定哪些资源是玩家可以掌控的，玩家又该通过怎么样的方式去用这些资源，同时保证玩家在使用资源的过程中不会破坏游戏的挑战性。 游戏设计师要设计玩家如何获得足够达成目标的资源，玩家或许不会像他们预期的那样获得非常多的资源，但是他们最终获得的资源一定是够他们推动游戏的，否则这个设计就是不平衡的。 从定义上来说，资源必须满足“实用性”和“稀缺性”。例如在暗黑破坏神中不会出现寿司这个资源，虽然寿司在这游戏中会是一个有趣的存在，但这个存在是无意义的。同时资源也不会非常非常多，否则资源也就失去了其存在的意义（不构成任何挑战）。 以下是游戏中通常会出现的资源： Lives 生命是动作游戏中最经典的稀缺资源，如马里奥中的生命。 生命这个资源采纳了最简单的模式：越多越好，更多的生命不会造成任何的副作用。 Units 在一些游戏中，玩家需要管理“单位”作为资源。如西洋棋中的棋子，炉石传说中的卡牌等。 有些单位是有限，有些是可再生的。 在游戏设计中，决定每个单位的花费，和平衡它与游戏中的其他元素是一个非常复杂的过程。最好的平衡方法，就是反复的测试。 Health 生命值可以作为一个单独的元素，或者其他元素的属性，如生命和单位就可以有生命值作为属性，来提示还有多久会失去这个元素。 通常来说，生命值这样的元素是有方法补充的。如在动作游戏中，玩家会通过药品来补充生命值，在角色扮演游戏中，玩家通过睡觉或者吃饭来补充生命值。不同的游戏种类适用不同的生命值补充方法，动作游戏中需要快速反应，所以补充生命值的方法更快但不真实，而角色扮演游戏则是相反。 Currency 金钱也是许多游戏中的重要资源，通常游戏也会因此设计一个交易系统。如真实世界一样，金钱的存在加快了交易的进行，让玩家可以更方便的获取自己想要的资源，而不是繁琐的以物换物。 Actions 一些游戏中，行为也是一种资源。如一些动作游戏中，会限制一些过于强大的行为，“大招”就是最好的例子，玩家需要有效的管理这种稀缺资源。 Power-ups 游戏中的一种经典资源就是能量提升，如马里奥中的蘑菇和花朵。 能力提升资源通常会设计的非常稀少而且是临时性的。 Inventory 一些游戏中，玩家可以选择收集和管理一些资源（通常能量提升和和单位不允许被管理），将这种资源称为“库存（Inventory）”。因为玩家可以收集的资源容量是有限的，所以这种收集本身就也存在稀缺性，玩家需要做出选择决定收集哪些资源，丢弃哪些资源。 Special Terrain 一些游戏中的某些地形也是一种资源，如魔兽争霸Ⅲ中的黄金是从金矿中采集的，金矿作为一个地形也成为了重要的i资源。 Time 时间在一些游戏中也会称为限制和资源。如许多的动作游戏，还有快棋，每个玩家都只有固定的时常做出下棋的选择。 Conflict 冲突通过规则，流程还有游戏情况（如多个玩家）来阻止玩家直接达成目标，冲突通常是一个游戏的核心。 流程通常提供了一种低效的达成目标的方法，即强迫玩家必须使用某些方法或技能才能达成目标。 流程本身也提供了竞赛和玩耍的感觉，玩家在这个低效的过程中会逐渐获得成就感或其他的快乐的感觉。 冲突通常有以下三个表现形式： Obstacles 障碍在一种常用的冲突方式。无论在单机游戏还是多人游戏中，都能使用障碍作为冲突，但在多人游戏中更多一些。 障碍不仅仅是物理形式，如水池，山坡，也可以是智力方面的，如动作游戏中的谜题等。 Opponents 在多人游戏中，对手是一个最主要的冲突来源。 Dilemmas 困境作为冲突通常是用来表示那些进退两难的选择，如大富翁中选择是否要购买一块土地。 Boundaries 边界是用来将游戏和其他非游戏的部分区分开来的。 Huizinga将玩家同意游戏的规则，开始游戏的行为称为，进入“Magic circle”。其中一个重要的部分，就是玩家需要有安全感，他可以在任意时间选择退出这个“Magic circle”。 游戏设计者必须定义游戏的边界，即玩家如何进入和退出游戏。这个边界可以是物理的，如足球场的边界，也可以是概念上的，如只是简单的放弃玩一个游戏。 边界的设置也决定了一款游戏的风格，因此修改边界也可以作为游戏设计的一部分。例如大富翁中能用真的金钱会怎么样？ 边界不仅仅作为游戏中的一个元素，它也提供了情绪上的区分。边界的存在让玩家在游戏中的情绪与在现实生活中的情绪所分开，如在游戏中对朋友开一些相对过分的玩笑并不会产生在现实中说同意的话造成的影响。 对于大多数的游戏而言，游戏系统是一个封闭的系统，即游戏内的元素是不会与游戏外的元素进行交互的。但现在也有许多的游戏设计师尝试去打破这个边界，如Pokémon GO。 Outcome 游戏的结果必须是一个不确定的因素，这样才能获取玩家的注意力。通常来说游戏的结果必须是一个可测量的结果，但也有例外，如模拟游戏，和一些在线的多人游戏，并不存在分数和输赢的概念。 对于绝大部分的游戏而言，游戏的结果是输或赢。在特定的时间或情况下，系统回去检测是否有达成赢或输的标准，如果达到了，那么游戏就结束了。 一些游戏是零和的，即一个人赢就代表另一个人输，如下棋。还有一些游戏是非零和的，如魔兽世界，一个玩家获取了某些东西并不代表另一个玩家会失去某些东西。非零和游戏在本质上不是竞争游戏，所以需要有另一个系统来体现游戏中的得失，如排名系统，玩家统计，或者其他不同的目标，甚至是玩家自定义的目标，如“我需要在模拟人生中达成…”。 Conclustion 这一章中介绍了游戏的常规元素，设计师可以通过结合这些元素来创造不同的游戏体验。 也可以通过分析游戏中的这些元素来学习游戏设计。 引用： 1.Game Design Workshop 4th 2019 by Tracy Fullerton","link":"/GameDesignWorkshop-Chapter3-Notes/"},{"title":"《Game Design Workshop》 第四章笔记","text":"《Game Design Workshop》 第四章笔记 这一章主要关于游戏的戏剧元素的设计。 作者首先介绍的常规的与游戏概念结合比较深的两个元素，挑战和玩耍。 之后介绍了三个在戏剧上更为复杂的元素，前提，角色，故事。 之后是两个更为复杂和高级的概念，世界创建和戏剧化曲线。 Chapter 4 Working with Dramatic Elements 第三章中提到的常规元素构创造了玩家体验，正是常规元素构成了游戏。戏剧元素（Dramatic Elements）定义了游戏的上下文，它将常规元素融合在系统中并产生了一个更有意义的体验，让玩家有了情感上的体验。 常规的戏剧元素有挑战（Challenge）和玩耍（Play），更复杂的戏剧化元素包括前提（Premise）、角色（Character）、故事（Story）。 Challenge 许多人都会同意游戏吸引他们的部分就是挑战。 当玩家谈及挑战时，他们谈及的是那些他们乐于完成的任务，这些任务需要一定的工作，而且能给他们带来满足感和愉悦感。 因此挑战是一个很个人化的因素，年轻人觉得是挑战的事情，老年人并一定觉得。 同样挑战也是一个动态的因素，一个事情在刚开始可能很有挑战性，但随着熟练度提升就逐渐失去了难度。所以游戏设计者必须要保持游戏的挑战性，用此来吸引玩家的注意。 当设计游戏时，设计师考虑的是如何让玩家更愉悦，这个问题是与挑战性相关的。虽然挑战性是个人化的因素，但是愉悦感却有相同点。根据心理学家Mihaly Crikszentmihalyi的研究，无论年纪，性别，社会阶层等等区别，让人们预约的活动都有以下特点 当解决人们有能力解决的问题时 人们必须集中于正在做的事情上 因为任务有清晰的目标和及时的反馈，所以人们可以集中在这件事上。 事物有一个深入但轻松的参与感，让人们忘记日常生活中的担忧和困扰 让人们对正在发生的事物有可控感 在事物进行时有无我的感觉，但是当事物结束后又能更加充分的感觉到自己的存在 感到时间的速度发生了变化，数小时可能变得像几分钟一样，几分钟又可能变得像数小时一样。 Crikszentmihalyi根据发现，发明了一个理论叫做心流（Flow），如下图所示： 如果一个活动的挑战远低于人的能力，那么就会觉得无聊，而如果挑战远高于人的能力，则会感到困扰。在心流中，一个活动是在挑战和能力之间平衡地带，给人带来愉悦感和满足感。 在游戏设计中期望达到的就是心流的区域。以下是一些能帮助达到心流的元素 A Challenging Activity That Requires Skill 根据Crikszentmihalyi的描述，心流发生的情况通常是一个活动是目标导向的，而且被规则所约束同时完成它需要有合适的技能。 如果一个人没有任务所要求的任何能力，那么这个任务对于他来说是没有意义的，只有这个人拥有部分能力，但又不足以完成这个人任务时，这个任务才能称为是有挑战性的。 The Merging of Action and Awareness Crikszentmihalyi说，当心流发生时，人们是非常沉浸入他们正在做的事情中，因此变得非常主动，他们也不会意识到自己是作为一个个体正在“做这件事”，即行为和感知结合在了一起，变成了无我的状态。 Clear Goals and Feedback 在心流的体验中，需要知道要达成什么，且要及时的得到该如何达成目标的反馈。 当一个游戏有明确的目标时，玩家知道他们要做些什么才能赢，才能前往下一关等等，而且他们也收到了明确的关于他们行动让他们离目标更近还是更远的反馈。 Concentration on the Task at Hand 另一个心流的元素是，人们只意识到此时此刻发生的事。他们不会再意识到其他的问题，出现了另一个世界，在这个世界中只有当下的事情，只有参与者在其中。 The Paradox of Control 人们享受在困难情况时候的掌控感，但是只有一个事情的结果是未知的时候，才会有掌控感。这有一定矛盾的感觉：人们只有在完全控制情况的下才会有掌控感。 Crikszentmihalyi说：当一个情况结果是未知时，只有这个人有能力去掌控结果，他才会有掌控感。 The Loss of Self-Consciousness 在心流中，人们会过度的关注于正在做的事情，忘记了自己的存在。但是在心流结束时，人们又会有更强的自我意识，如音乐家感受到了自己音乐的和谐，游戏玩家对自己策略或技能的满足。 这一点同样乍一看同样有点矛盾，自我感觉的强化来自于自我感觉的丢失。 The Transformation of Time 在心流中，一个常发生的现象就是感觉时间流动的速度发生了变化。如人们真正沉浸在某个时期时，会觉得时间过得很快，同样有的时候又会觉得时间很慢，如芭蕾舞者在做一些高难度动作时，会觉得几秒钟的事情仿佛发生了几分钟。 Experience Becomes an End in Itself 在心流中，做这件事变得是内在的，主动的。 生活中的大部分事情都是外在的，做那些事的原因是因为能满足某些目标。 但是像音乐，体育和游戏都是内在的，他们本身就是存在的意义。 总之在设计游戏时，需要考虑以下几个问题： 希望玩家要掌握什么技能。 希望玩家要掌握这个技能到什么程度。 如果给玩家清晰的，重要的目标，有意义的选择和清晰的反馈？ 如何将玩家需要做的事情，和他们需要思考的事情结合在一起？ 如何消除玩家的不专心，对失败的恐惧。即如何给玩家一个足够安全的环境，让他们可能达到无我的境界。 如何让游戏有趣到其本身就是意义 Play 玩是在一个限定的框架内做自由的活动，对于游戏而言这个框架就是规则和流程所限定的。 The Nature of Play 需要知道玩耍有很多面： 它帮助人们学习技能和获取知识，让人更社交化，帮助人们解决问题，让人们放松，让人从不同的角度去思考问题。玩可以是不严肃的，让人开怀大小，玩也可能是严肃的，让其作为一个实验的存在，去尝试新鲜事物，去探索一个事物的边界。玩被认为是引导改革和创造力的方法。 但最重要的一点，玩是一种精神层面的东西。即使对于最严肃和最难的事情，也能用一种玩笑的方法去面对。 这里同样作者同样提到了关于玩的分类，即在Roger Caillois的Man,Play,and Games中提到的$Ag\\hat{o}n$,$Alea$,$Mimicry$,$Ilinx$。 这部分在Rules Of Play的第22章有详细描述，这里就不再赘述。 对于游戏设计者而言，知道对于玩的分类是为了帮助他们了解对于某一种的玩耍方式什么才是核心的愉悦感，这样可以帮助他们决定在特定的系统中对玩家的体验该设定怎样的目标。 Types of Players 如同能区分玩耍的不同类型，也能从人的角度对玩家的类型进行区分： The Competitor： 竞争者是无论游戏类型是什么，他们的目标都是做最出色的玩家 The Explorer: 探索者是对游戏世界感到好奇，喜欢冒险，回去探索游戏世界的边界（无论是精神层面还是物理层面的边界）。 The Collector: 收集者会喜欢收集游戏世界内的元素，或者知识，如设定，历史等。 The Achiever: 成就者关心游戏中的成就和天梯等成就系统。 The Joker: 玩笑者对游戏不会太严肃，玩游戏只是为了单纯的快乐。硬核玩家可能会被玩笑者惹怒，但是玩笑者可以让游戏更加的有社会性，会推动游戏的流行。 The Artist: 艺术家是被游戏的设计和创意所吸引。 The Director: 引领者喜欢在游戏中带领游戏故事的推动，或称为别的玩家的领袖。 The Storyteller: 故事者会被游戏的故事所吸引。 The Performer: 表现者喜欢在别人玩家前表演，例如各种游戏主播。 The Craftsman: 工匠喜欢在游戏中建造，制作东西，或者解决游戏内的难题。 对于游戏玩家的分类可以帮助游戏设计师从不同的角度去思考该如何从情感上吸引玩家。 Levels of Engagement 除了从玩耍本身和玩家角度考虑，不同玩家对于游戏的参与度也是不一样的。 例如一些玩家相比于自己玩游戏，更喜欢看别人玩游戏。通常来说，游戏设计师并不会从游戏的观看者角度出发去设计游戏。但是不可否认的是有非常的多人都喜欢称为游戏的观众，而且这个对于游戏的流行会产生很大的影响，所有游戏设计者或许也应该将观察者纳入考量的范围。 真正的游戏参与者无疑是设计师们最应该考虑的目标。某些情况下，游戏参与者会体验转型游玩（Transformational play），即玩游戏的过程一定程度上影响了玩家的人生。一些游戏的设计师也会从希望玩家体验转型游玩的角度去设计游戏，让游戏有更深层的意义，如通过让玩家体验到现实世界中战争的残酷来反战等。 Premise 除了挑战和玩耍，游戏也有一些传统戏剧中包含的元素。如果没有这些戏剧元素，游戏对玩家而言会变得过于抽象，让玩家无法从情感上融入游戏。 如竞赛游戏，从常规元素角度上来说就是数值的比较，谁数值更大谁就获胜。为了让玩家在情感上能融入游戏，通常需要使用情感元素来包装常规元素。 在传统的戏剧中，前提是用来解释一个故事的，包括故事的时间，地点，人物，关系，现状等，还有两个格外重要的元素，问题（Problem）和攻击点（Point of attack）。问题是让现状不再稳定的事件，并且问题创造了矛盾。攻击点是问题被引出的时刻，也是一场戏剧真正开始的时刻。 在游戏中，问题和攻击点对应常规元素中的目标（objective）和流程中的开始时刻（starting action）。 在游戏中，前提可以是像传统戏剧中那样复杂，如魔兽世界，也可以非常简单，只是作为一个简单的比喻来包装抽象的常规系统，例如雷电，仅仅是战机攻击外星飞船。 前提的首要任务就是让游戏的常规系统对于玩家而言是可玩的，而不是完全对抽象概念的操作（玩家不是发出一个无意义的射线，而是对外星飞船的开火）。 前提更复杂的任务就是让游戏能从情感上吸引玩家。通过用前提来将游戏的常规系统和戏剧系统结合在一起，是游戏设计师提升玩家体验的一个机会。 Character 角色是戏剧中采取行动的人。通过定义角色和他的目标，观众可以内化故事的事件，对故事的发展感同身受。 角色可以从很多角度去解释。最常见的是角色是心理的表现，如为了体现观众的恐惧或渴望。更深一层，角色可以是有象征意义的，代表一个远大的想法，例如美国梦，民主等。角色也可以是有历史含义的，或者描述真实世界的现象。一个角色该如何使用是由故事本身决定的，例如没必要在一个低俗戏剧中，让一个角色代表严肃深刻的含义。 角色是由他所说的话，他做的事，他的外貌和别人眼中的他来决定的。如果一个角色有明显的特征，有真实的人格，而且在故事的发展中人格会发生变换，那么这就是个丰满的人物（round character）。相反，如果一个人只有很少的特征和人格，那么就会认为这个人物是扁平的（Flat）。一个扁平化的人物通常不会在故事中有人格上的变化，他们只是用来作为一个象征含义，如懒惰的人，邪恶的人。 无论一个角色复杂与否，在设计一个角色时都需要考虑以下几个问题： 角色想要什么？ 角色需要什么？ 观众希望看到什么? 观众害怕看到什么？ 在游戏中特殊的一点是，游戏角色的设计要考虑在代理（Agency）和同情（Empathy）间的平衡。代理指的是游戏角色完全是玩家的体现，游戏角色只是作为一个命令的执行者。而同情指的是玩家将自己的情感投射入角色中，让角色的目标成为了自己的目标。 对于早期的游戏角色而言，他们都是扁平的，主要区别在于角色的外观。他们的存在同样是为了包装常规系统，让一个戏剧化的目标代替游戏的常规元素，如在马里奥中，用拯救公主这个具体的目标代替抽象的“营救目标”这一常规游戏目标。但是这些角色完全是受玩家控制的，他们不会有人格上的变化。 而现在许多的游戏角色有了更深的背景故事和更丰富的人格特征，这些都会影响玩家的游戏体验。如战胜中的奎托斯，在游戏进度推进的过程中，可以看到角色的情感发生了变化，有自己的人格变化和发展，而不是单纯的作为玩家控制的体现。 还有一种角色是化身（Avatar），如魔兽世界中玩家创建的角色。玩家对于这种角色也同样有非常深得共鸣。 在游戏中还需要设计师考虑的一点是，自由意志和玩家控制之间的平衡（Free will vs. Player control）。 游戏角色是代理玩家的体现，这限定了游戏角色展示自己的个性和思考。但是在游戏过程中，并非每分每秒玩家都对角色有着控制。在这种情况下AI控制的角色在玩家的意志和游戏角色自己的意志中创建了一个灰色地带。 例如在早期游戏中，世嘉的游戏角色索尼克，在玩家不控制他时，他会不耐心的用脚点地。这种自由行为与索尼克抓紧每分每秒，高速移动的角色的设定是符合的。 同时AI的控制也能运用到非玩家控制的角色中，如NPC和敌人，这些都可以让游戏变得更加的有趣和可信。 现在的发展趋势是游戏角色变得越来越丰满，如何合理有效的运用传统戏剧元素和AI让游戏角色变得更加真实，是游戏设计师需要考虑的工作。 Story 如在第三章中所述，游戏的结果必须是不确定的。一个故事的结局同样是不确定的，最起码在第一遍阅读时时这样的。在电影和戏剧中，故事的不确定性是由作者或者演员来逐渐消除的，在游戏中则需要通过玩家逐渐消除。 在许多游戏中，故事是由背景故事限制的。背景故事给了游戏的上下文了冲突，它创造了游戏角色的动机。但是故事的推进并不是由玩家来决定的，玩家的行为只是触发要进入故事下一个片段的因素，实际上故事的走向已经是确定了的。 但也有一些游戏设计师希望玩家的行为能改变故事的走向。最简单的实现就是故事树，玩家的选择就让故事的走向走进预先设定的某一种可能中。故事树如下图所示： 但这种方法下，故事仍然是被预先决定的，同样它也限定了玩家可做的选择。还有一种实现就是像模拟人生一样，玩家可以用常规系统提供的元素，来自己创造出无限可能的故事。 故事在游戏中，最常见的用法就是用来在单机游戏中推动玩家的冒险，如最后的生还者和行尸走肉。两者都是用故事来推动玩家的游戏，故事中的人物也同样都是饱满的，会随着故事的发展和发生情感的变化，同样能在情感上吸引玩家。但是不同的是，最后的生还者中故事的发展是完全限定了的，而行尸走肉中玩家的对话和行为会改变故事的结局。 对于游戏设计师，要考虑的就是在不牺牲玩家体验的情况下，让游戏中的故事更好的与游戏结合，让故事更有深度。 World Building 世界构建（World building）是一个复杂且深入的虚拟世界创造过程，通常是由创建地图和历史开始，但也可以变得更加复杂，如包含语言，文化，宗教，政治，经济等。 目前最成功的世界构建可能是J.R.R Tolkien创造的中世纪这一概念。魔兽世界一定程度上就是基于这个概念创建的。 媒体理论学家Henry Jenkins提到，“限制越来越多的故事变成世界构建，艺术家们创建了一个复杂的世界，复杂到无法用单一的媒体来完全的展现出来。” 而对于游戏设计来说，最重要的是让游戏的规则与虚拟世界的规则是匹配的，无论是从交互层面还是从故事层面。 The Dramatic Arc 对于所有的戏剧元素中，最重要的就是冲突，这一概念在常规元素中同样有出现。 冲突是一个优秀的剧情的核心，同样也是一个游戏系统的核心。 一个有意义的冲突不仅仅是防止玩家太容易的达成目标，还要让玩家对游戏的结果产生紧张感，让玩家能被游戏所吸引。 当从变换的角度来思考冲突时，冲突通常是通过逐渐扩大来创造紧张感。在大部分的戏剧中，紧张感会先逐渐加剧然后逐渐放缓，这就是经典的戏剧性弧线，如下图所示： 如之前章节中所述，在解释（Exposition）部分会介绍故事的角色，背景以及冲突等各种重要概念。而主角尝试去解决冲突的过程，构成了故事铺陈（Rising Action）。在铺陈的重点是故事的高潮（Climax），在这个时刻会有某些决定性的因素或事件发生，故事的高潮决定了故事的最终结局。高潮过后即是收尾阶段（Falling Action），在这个阶段冲突逐渐被解决。直到结尾（Resolution），冲突最终被解决。 在游戏中，故事铺陈的阶段会与常规系统和戏剧系统联系在一起。游戏通常会被设计成挑战逐渐增加（常规系统），这时候可以与故事的冲突（戏剧系统）逐渐加剧结合在一起。 一个反面例子是马里奥，在马里奥的常规系统中，每一关的难度逐渐增加，但是从戏剧角度来看，马里奥的目标从未动摇过，他也没有对救出公主有任何的内心冲突。即戏剧系统和常规系统发生了发生了割裂。 游戏相对于戏剧还有一个重要区别在于，推动冲突解决的是玩家自己。如马里奥中，玩家直到需要救出公主，于是玩家的常规目标——过关会为了这个戏剧社的目标结合在一起。当冲突解决后，不仅有冲突解决后情绪上紧张感的释放，还有个人成就感的提升。 在现代游戏中，游戏设计师会从更深刻的角度去思考玩家在游戏过程中的情绪变化。如风之旅人，是参考了Joseph Campbell的英雄之旅（Hero‘s Journey），其作者陈星汉根据英雄之旅的灵魂创造了一种情绪上的变换弧线，如下图所示： //TODO 玩风之旅人 Conclusion 所有的戏剧元素都是为了引出玩家情绪上的反应。 目前游戏在情绪上的影响还不够深刻，因此无法被认为是另一种戏剧艺术形式。 对于游戏设计师而言，要更好的设计戏剧系统，同时需要对传统戏剧的理解和对游戏本身的理解。 引用： 1.Game Design Workshop 4th 2019 by Tracy Fullerton","link":"/GameDesignWorkshop-Chapter4-Notes/"},{"title":"《Head First 设计模式》 笔记（三）","text":"这一篇将会介绍状态模式，代理模式和复合模式并整理了书中提到了9个设计原则。 状态模式 状态模式(State Pattern)允许一个对象根据其内部状态的变化来选择需要执行的操作。这个对象会看起来像是改变了它的类。 状态模式定义听起来有些奇怪，实际上就是将不同状态的行为定义在不同的状态类中，然后根据状态的不同切换这些状态类，进而达到不同的行为。 例如我们需要做一个口香糖贩卖机需要处理，投钱、退钱、旋转出货按钮这三个操作，然后机器有未投钱、投钱、货物卖出、货物卖完四个状态。我们可以将不同状态下对三个操作的处理定义在各自的状态类中。 代码示例 状态类接口 状态类接口1234567public interface State{ void InsertQuarter(); void EjectQuarter(); void TurnCrank(); void Dispense();} 状态类实现 未投钱状态123456789101112131415161718192021public class NoQuarterState : State{ private GumballMachine gumballMachine = null; public NoQuarterState(GumballMachine gumballMachine) { this.gumballMachine = gumballMachine; } public void Dispense() { Console.WriteLine(&quot;You need to pay first&quot;); } public void EjectQuarter() { Console.WriteLine(&quot;You haven't inserted a quarter&quot;); } public void InsertQuarter() { gumballMachine.SetState(gumballMachine.HasQuarterState); Console.WriteLine(&quot;You inserted a quarter&quot;); } public void TurnCrank() { Console.WriteLine(&quot;You turned,but there's no quarter&quot;); }} 投钱状态123456789101112131415161718192021222324252627282930public class HasQuarterState : State{ private GumballMachine gumballMachine = null; public HasQuarterState(GumballMachine gumballMachine) { this.gumballMachine = gumballMachine; } public void Dispense() { Console.WriteLine(&quot;No gumball dispensed&quot;); } public void EjectQuarter() { Console.WriteLine(&quot;Quarter returned&quot;); gumballMachine.SetState(gumballMachine.NoQuarterState); } public void InsertQuarter() { Console.WriteLine(&quot;You can't insert another quater&quot;); } public void TurnCrank() { Console.WriteLine(&quot;You turned&quot;); gumballMachine.SetState(gumballMachine.SoldState); }} 货物卖出状态123456789101112131415161718192021222324252627282930313233343536public class SoldState : State{ private GumballMachine gumballMachine = null; public SoldState(GumballMachine gumballMachine) { this.gumballMachine = gumballMachine; } public void Dispense() { gumballMachine.ReleaseBall(); if (gumballMachine.remainGumballsNum &gt; 0) gumballMachine.SetState(gumballMachine.NoQuarterState); else { Console.WriteLine(&quot;Opps,out of gumballs&quot;); gumballMachine.SetState(gumballMachine.SoldOutState); } } public void EjectQuarter() { Console.WriteLine(&quot;Sorry,you already turned the crank&quot;); } public void InsertQuarter() { Console.WriteLine(&quot;Please wait,we are already giving you a gumball&quot;); } public void TurnCrank() { Console.WriteLine(&quot;Turning twice dones't get you another gumball&quot;); }} 货物售完状态123456789101112131415161718192021222324252627public class SoldOutState : State{ private GumballMachine gumballMachine = null; public SoldOutState(GumballMachine gumballMachine) { this.gumballMachine = gumballMachine; } public void Dispense() { Console.WriteLine(&quot;No gumball dispensed&quot;); } public void EjectQuarter() { Console.WriteLine(&quot;You can't eject,you haven't inserted a quarter yet&quot;); } public void InsertQuarter() { Console.WriteLine(&quot;You can't insert a quarter,the machine is sold out&quot;); } public void TurnCrank() { Console.WriteLine(&quot;You turned,but there are no gumballs&quot;); }} 测试代码及结果 测试代码123456789GumballMachine gumballMachine = new GumballMachine(5);gumballMachine.TurnCrank();gumballMachine.InsertQuarter();gumballMachine.EjectQuarter();gumballMachine.TurnCrank();gumballMachine.InsertQuarter();gumballMachine.TurnCrank();gumballMachine.TurnCrank();gumballMachine.EjectQuarter(); 运行结果： 代理模式 代理模式（Proxy Pattern）为对象提供一个代理进而控制对其的访问。 例如我们需要加载一张图片，但加载图片是个访问网络或IO的操作，我们不希望这个这个操作阻塞UI线程，于是我们可以定义一个代理来进行多线程的加载，并在加载完成后显示图片。 代码示例 抽象接口 图片接口1234public interface Icon{ void PrintIconWidthAndHeight();} 抽象接口实现 真实图片类1234567891011121314public class ImageIcon : Icon{ private int width, height; public ImageIcon() { Thread.Sleep(5000);//Pretend there is some hard work to load the image width = 800; height = 1000; } public void PrintIconWidthAndHeight() { Console.WriteLine(DateTime.Now.ToLongTimeString() + &quot;: Width is &quot; + width + &quot;,height is &quot; + height); }} 代理图片类1234567891011121314151617181920212223public class ImageProxyIcon : Icon{ private ImageIcon icon = null; private bool isLoading = false; public ImageProxyIcon() { } public void PrintIconWidthAndHeight() { if (icon != null) icon.PrintIconWidthAndHeight(); else if (!isLoading) { Console.WriteLine(DateTime.Now.ToLongTimeString() + &quot;: Is Loading Image...&quot;); isLoading = true; new Thread(() =&gt; { icon = new ImageIcon(); icon.PrintIconWidthAndHeight(); }).Start(); } }} 测试代码及结果 测试代码12ImageProxyIcon proxyIcon = new ImageProxyIcon();proxyIcon.PrintIconWidthAndHeight(); 运行结果： 代理模式与装饰模式很像，不同的是装饰模式的目的是在原先的类外扩展某些功能，而代理模式只是控制原先类中某些接口的访问。例如上例子中，ImageProxyIcon并没有为ImageIcon拓展什么功能，只是用了多线程来访问访问其中的函数。 复合模式 复合模式（Compound Pattern）是通过两个或以上的设计模式形成一个可以解决一般性问题的通用框架。 MVC框架就是一种组合模式，Controller和View之间使用了策略模式， View中只存Controller的接口，进而达到可以随时切换不同Controller的目的。Model和View之间使用了观察者模式，View作为观察者，Model作为被观察者，当Model的数据发生变化时，View相应改变。而View本身使用了组合模式，比如按钮中可能存在子按钮，窗口中存在子窗口等等。 我们以音量调节作为一个最简的MVC框架示例。 代码示例 框架接口 观察者接口1234public interface IVolumeObserver{ void VolumeUpdated();} Model接口123456public interface IVolumeModel{ int Volume { get; set; } void RegisterObserver(IVolumeObserver observer); void UnRegisterObserver(IVolumeObserver observer);} Controller接口123456public interface IViewController{ void VolumeUp(); void VolumeDown(); void SetVolume(int volume);} 接口实现 Model1234567891011121314151617181920212223242526272829public class VolumeModel : IVolumeModel{ private int volume = 0; public int Volume { get { return volume; } set { volume = value; observersList.ForEach(observer =&gt; observer.VolumeUpdated()); } } private List&lt;IVolumeObserver&gt; observersList = null; public VolumeModel() { observersList = new List&lt;IVolumeObserver&gt;(); } public void RegisterObserver(IVolumeObserver observer) { observersList.Add(observer); } public void UnRegisterObserver(IVolumeObserver observer) { observersList.Remove(observer); }} View123456789101112131415161718192021222324252627282930313233public class VolumeView : IVolumeObserver{ private IViewController controller = null; private IVolumeModel model = null; public VolumeView(IViewController controller, IVolumeModel model) { this.controller = controller; this.model = model; this.model.RegisterObserver(this); Console.WriteLine(&quot;View: volume init is &quot; + model.Volume); } public void OnVolumeUpButtonClick() { controller.VolumeUp(); } public void OnVolumeDownButtonClick() { controller.VolumeDown(); } public void VolumeUpdated() { Console.WriteLine(&quot;View: volume updated &quot; + model.Volume); } ~VolumeView() { model.UnRegisterObserver(this); }} Controller1234567891011121314151617181920212223public class VolumeController : IViewController { private VolumeModel model = null; public VolumeController(VolumeModel model) { this.model = model; } public void SetVolume(int volume) { model.Volume = volume; } public void VolumeDown() { --model.Volume; } public void VolumeUp() { ++model.Volume; } } 测试代码及结果 测试代码12345VolumeModel model = new VolumeModel();VolumeView view = new VolumeView(new VolumeController(model), model);view.OnVolumeUpButtonClick();view.OnVolumeUpButtonClick();view.OnVolumeDownButtonClick(); 运行结果： 设计原则 将变化的部分封装起来（Encapsulate what varies) 组合优于继承（Favor composition over inheritance） 面向接口编程而非实现（Program to interfaces, not implementations.） 减少需要交互的类之间的耦合（Strive for loosely coupled designs between objects that interact） 对拓展开放，对修改关闭（Classes should be open for extension but closed for modification.） 依赖于抽象而非具体的类（ Depend on abstraction.Do not depend on concrete classes） 暴露最少的信息给其他类（最少知识原则）（Talk only to your immediate friends） 高层有对底层的管理，而底层不需要关心高层何时会调用自己（好莱坞原则）（Don’t call us ,we’ll call you） 一个类应该有且只有一个被改变的理由（A class should have only one reason to change） 引用： https://design-patterns.readthedocs.io/zh_CN/latest/behavioral_patterns/behavioral.html","link":"/HeadFirstDesignPatternNotes-3/"},{"title":"Hexo教程（一）","text":"从大学开始就有通过Onenote整理笔记的习惯，也多次想过将自己的笔记分享出去。曾尝试过微信的公众号，但公众号的编辑器没法完全保存Onenote笔记的格式，发现每次发布都需要大量的时间去调整格式后便做了罢。之后想要建立个人博客，但苦于完全没有网站前端的开发经验便一拖再拖。最近也是才发现有Hexo这么一个搭建网站的框架便开始了再次尝试。这篇及之后的关于Hexo的文章与其说是教程更像是笔记，只是在学习Hexo时的一些记录罢了。 这一篇将包括Hexo环境安装，本地博客的创建，上传至Github域名三部分的介绍 Hexo环境安装 安装Node.js 安装Git 安装Hexo cmd运行 npm install -g hexo-cli 这里不做关于Git的介绍。 建站 新建Hexo网站文件夹 在需要保存Hexo网站文件夹的地方，运行git bash,输入hexo init &lt;folderName&gt;。Hexo会通过git自动拉去需要的文件，如果在安装过程中有错误显示，cd进创建出来的文件夹目录下，然后运行npm install补安装缺少的文件。 新建出来的文件夹目录如下 1234567├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 生成网站页面 运行hexo generate，运行后在目录下会新生成public文件夹,该文件夹即为网页的数据文件夹 测试网站 运行Hexo server,将生成一个本地的Hexo Host，将http://localhost:4000复制到游览器即可预览 也可以通过Hexo server -p &lt;port&gt;来指定生成本地Host的端口 创建草稿 在正式的发布文章前，我们可以先创建草稿 运行hexo new draft 'draftName'在_draft文件夹下创建名字为’draftName’的草稿文本。 测试草稿 hexo server创建的测试网站，默认是不渲染草稿的，如果需要渲染草稿需要加上后缀hexo server --draft 发布草稿 hexo publish post 'draftName'将名为’draftName’的草稿发布为文章，所有的文章存储与_posts文件夹下。 创建文章 如果需要直接创建文章，可使用命令hexo new post 'PostsName' 文件夹及目录介绍 scaffolds 文件夹 模版文件夹，当用Hexo新建一个md文件时，Hexo会根据这个文件夹下的模版决定新生成的md文件默认有哪些内容。 source 文件夹 资源文件夹，在网站上显示的内容都在这个文件夹下，在刚生成的目录下，只有一个_posts，其中存放提交的文章 themes 文件夹 主题文件夹 _config.yml 配置文件 Github上传博客 新建工程以生成外网路径 注意工程的名字必须为&lt;Owner&gt;.github.io 新工程会自动生成一个外部访问的网址，点开Setting即可看到 下图红框地址即为最终博客的地址 配置Hexo至Github工程 在_config.xml文件下添加 1234deploy: type: git repository: git@github.com:xuejiaW/xuejiaW.github.io.git branch: master 注意page页面只能是master，hexo源码可以保存在自己新建的任意分支 运行npm install hexo-deployer-git --save安装部署插件 运行hexo deploy将数据部署到网站 注意：有时候部署后，发现本地发生了变化，但是网站上没有变化，此时运行先运行 hexo clean再hexo deploy 访问地址 将上面看到的路径复制到游览器中即可看到自己的博客效果。","link":"/HexoTutorial-1/"},{"title":"《Head First 设计模式》 笔记（二）","text":"这一篇将会介绍单例模式，命令模式，适配器模式，外观模式，迭代器模式及组合模式。 单例模式 单例模式(Singleton Pattern)可能是最简单，也是被应用最为广泛的设计模式。单例模式保证一个类只会存在一个实例，并且提供了一个公共的接口来访问该实例。 代码示例 单例模式123456789101112131415161718192021222324public class Singleton{ private static object lockObj = new object(); private static Singleton instance = null; public static Singleton Instance { get { if (instance == null) { lock (lockObj) if (instance == null) instance = new Singleton(); } return instance; } } private Singleton() { Console.WriteLine(&quot;Constructor the Singleton&quot;); }} 这里使用一个lockObj是为了保证多线程安全，如果有多个线程在同一时间第一次调用Instance，则可能存在两个线程都进入了instance == null的分支，这就会造成两次实例化，所以我们需要通过加锁来保证线程安全。但如果我们将锁直接加在第一个If外，则每次调用Instance都有一个加锁的过程，所以这里选择在第一个If内加锁，锁内再次检查保证只会有一次实例化。 命令模式 命令模式(Command Pattern)将一个请求封装为一个对象，进而将拥有不同的请求的物体参数化，并且还可以请求排队，打印请求日志，支持可逆操作。 命令模式由抽象命令类、具体命令类、接受者、调用者、客户类，五部分组成。其中接受者为被命令封装的类，调用者存放需要执行的类。 我们以一个远程控制装置作为例子，远程控制装置有两个按钮和一个撤回按钮。我们通过命令模式来将远程控制类与具体需要做的操作（如开灯）解耦。在例子中程序入口即为客户端，远程装置为调用者，灯为接受者，有开灯与关灯两个命令 代码示例 抽象命令类及实现 抽象命令类12345public interface Command{ void Execute(); void Undo();} 命令类实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class LightOffCommand : Command{ private Light light; public LightOffCommand(Light light) { this.light = light; } public void Execute() { light.Off(); } public void Undo() { light.On(); }}public class LightOnCommand : Command{ private Light light; public LightOnCommand(Light light) { this.light = light; } public void Execute() { light.On(); } public void Undo() { light.Off(); }}public class NoCommand : Command{ public void Execute() { Console.WriteLine(&quot;No command execute&quot;); } public void Undo() { Console.WriteLine(&quot;No command undo&quot;); }} 接受者 灯123456789101112public class Light{ public void On() { Console.WriteLine(&quot;The light is on&quot;); } public void Off() { Console.WriteLine(&quot;The light is off&quot;); }} 调用者 远程控制12345678910111213141516171819202122232425262728class RemoteControl{ Command[] commands; Command lastCommond; public RemoteControl() { commands = new Command[2] { new NoCommand(), new NoCommand() }; lastCommond = new NoCommand(); } public void SetCommand(int index, Command command) { commands[index] = command; } public void OnButtonClick(int index) { commands[index].Execute(); lastCommond = commands[index]; } public void OnClickUndo() { lastCommond.Undo(); lastCommond = new NoCommand(); }} 客户类 函数入口12345678910static void Main(string[] args){ Light light = new Light(); RemoteControl remoteControl = new RemoteControl(); remoteControl.SetCommand(0, new LightOnCommand(light)); remoteControl.SetCommand(1, new LightOffCommand(light)); remoteControl.OnButtonClick(0); remoteControl.OnButtonClick(1); remoteControl.OnClickUndo();} 测试及结果 运行结果： 适配器模式 适配器模式（Adapter Pattern）将一个类的接口转换为用户想要的另一个接口。适配器模式将原先因为接口不兼容的一些类可以一起工作。 例如我们有已经实现的火鸡类和鸭子类，其中鸭子的鸣叫我们使用Quack，火鸡的鸣叫我们用Goggle，两个接口不相同，但在某些情况下，我们不希望具体区分是火鸡还是鸭子，只希望他们都能叫，这时候就需要用适配器模式，将火鸡或鸭子伪装成同一个类。 代码示例 鸭子及火鸡抽象接口及实现 鸭子接口12345public interface Duck{ void Quack(); void Fly();} 鸭子实现123456789101112public class MallardDuck : Duck{ public void Fly() { Console.WriteLine(&quot;MallardDuck Fly&quot;); } public void Quack() { Console.WriteLine(&quot;MallardDuck Quack&quot;); }} 火鸡接口12345public interface Turkey{ void Gobble(); void Fly();} 火鸡实现123456789101112public class WildTurkey : Turkey{ public void Fly() { Console.WriteLine(&quot;WildTurkey Fly&quot;); } public void Gobble() { Console.WriteLine(&quot;WildTurkey Gobble&quot;); }} 适配器类 火鸡适配器123456789101112131415161718public class TurkeyAdapter : Duck{ Turkey turkey; public TurkeyAdapter(Turkey turkey) { this.turkey = turkey; } public void Fly() { for (int i = 0; i != 5; ++i) turkey.Fly(); } public void Quack() { turkey.Gobble(); }} 测试代码及结果 测试代码12345678910111213static void Main(string[] args){ MallardDuck duck = new MallardDuck(); WildTurkey turkey = new WildTurkey(); TestDuck(duck); TestDuck(new TurkeyAdapter(turkey));}static void TestDuck(Duck duck){ duck.Fly(); duck.Quack();} 运行结果： 外观模式 外观模式(Facade Pattern)为子系统的一系列接口提供了一个统一的，更高级别的接口以简化外部的调用。 外观模式实际上是遵从于最小知识原则，对一些上层的类来说，它不需要了解下面子系统的具体构成，那么我们就用一个中间层（Facade）来将封装这些子系统，形成一个软解耦。 例如我们有一个家庭影院，在播放电影时我们需要打开DVD机，打开投影仪，打开放大器，打开音频协调器等，我们可以用一个Facade来将这些操作都封装起来，对于外部调用者来说仅有开始播放电影及关闭播放电影两步。 代码示例 子系统 DVD机器123456789101112public class DvdPlayer{ public void On() { Console.WriteLine(this.GetType().ToString() + &quot; On&quot;); } public void Off() { Console.WriteLine(this.GetType().ToString() + &quot; Off&quot;); }} 投影仪123456789101112public class Projector{ public void On() { Console.WriteLine(this.GetType().ToString() + &quot; On&quot;); } public void Off() { Console.WriteLine(this.GetType().ToString() + &quot; Off&quot;); }} 放大器123456789101112public class Amplifier{ public void On() { Console.WriteLine(this.GetType().ToString() + &quot; On&quot;); } public void Off() { Console.WriteLine(this.GetType().ToString() + &quot; Off&quot;); }} 音频协调器123456789101112public class Tuner{ public void On() { Console.WriteLine(this.GetType().ToString() + &quot; On&quot;); } public void Off() { Console.WriteLine(this.GetType().ToString() + &quot; Off&quot;); }} Facade 家庭影院外观者12345678910111213141516171819202122232425262728293031class HomeTheaderFacade{ private Amplifier amplifier = null; private Tuner tuner = null; private DvdPlayer dvdPlayer = null; private Projector projector = null; public HomeTheaderFacade(Amplifier amplifier, Tuner tuner, DvdPlayer dvdPlayer, Projector projector) { this.amplifier = amplifier; this.tuner = tuner; this.dvdPlayer = dvdPlayer; this.projector = projector; } public void WatchMovie() { amplifier.On(); tuner.On(); dvdPlayer.On(); projector.On(); } public void endMovie() { amplifier.Off(); tuner.Off(); dvdPlayer.Off(); projector.Off(); }} 测试代码及结果 测试代码1234HomeTheaderFacade facade = new HomeTheaderFacade(new Amplifier(), new Tuner(), new DvdPlayer(), new Projector());facade.WatchMovie();Console.WriteLine();facade.endMovie(); 运行结果： 模版方法模式 模版方法模式（Template Method Pattern）定义了一个算法的操作步骤，但其中的某些步骤需要派生来对应实现。 工厂方法&gt;模式就是模版方法模式的一种运用。 策略模式和模版方法模式都是将算法的实现抽象出来，不同的是策略模式的实现依靠组成，而模版方法模式依靠继承。 例如我们需要准备咖啡和茶，准备咖啡基本步骤为烧开水，加入咖啡粉，将咖啡倒入杯子，增加牛奶或糖（可选），准备茶的基本步骤为烧开水，加入茶粉，将茶倒入杯子，增加柠檬（可选）。我们发现在制作两个饮料的过程中，烧开水和倒入杯子这两个步骤是一样的，剩下的两个步骤，向烧开的水中增加相应的粉和增加配料，这两部分也是类似的，于是我们可以用模版方法模式，将这两步骤作为抽象方法。 代码示例 算法模版基类 咖啡因饮料模版123456789101112131415161718192021222324252627282930public abstract class CaffeineBeverage{ public void PrepareRecipe() { boilWater(); brew(); pourInCup(); if (NeedCondiments()) addCondiments(); } protected abstract void brew(); protected abstract void addCondiments(); private void boilWater() { Console.WriteLine(&quot;Boiling Water&quot;); } private void pourInCup() { Console.WriteLine(&quot;Pouring Water&quot;); } public virtual bool NeedCondiments() { return true; }} 例子中brew和addCondiments即为模版函数，而NeedCondiments这种提供了基本实现，但派生类中仍然可以重写的函数被称为钩子（Hook）。 咖啡因饮料实现 咖啡1234567891011121314151617public class Coffee : CaffeineBeverage{ protected override void addCondiments() { Console.WriteLine(&quot;Add sugar and Milk&quot;); } protected override void brew() { Console.WriteLine(&quot;Dripping coffee through filter&quot;); } public override bool NeedCondiments() { return false; }} 茶123456789101112class Tea : CaffeineBeverage{ protected override void addCondiments() { Console.WriteLine(&quot;Adding lemon&quot;); } protected override void brew() { Console.WriteLine(&quot;Steeping the tea&quot;); }} 测试代码及结果 测试代码12345Coffee coffee = new Coffee();Tea tea = new Tea();coffee.PrepareRecipe();Console.WriteLine();tea.PrepareRecipe(); 运行结果: 迭代器模式 迭代器模式(Iterator Pattern)提供了一种访问聚合对象但不需要关心其内部实现方法的方式。 例如我们存在两个菜单，第一个菜单表示早餐，第二个表示晚餐，第一个菜单其中的菜品用List来存储，第二个菜单其中的菜品用Array来存储。在这种情况下就需要使用迭代器模式，为两个菜单提供一个供外部调用的访问菜品的接口。 代码示例 我们在两个菜单类中添加createIterator函数来返回迭代器，对于外部调用者，如测试代码中的PrintMenu,它只需要调用hasNext及next即可而不需要关心菜单中的具体实现。 菜单 Pancake菜单1234567891011121314151617181920212223public class PancakeHouseMenu{ private List&lt;MenuItem&gt; menuItemsList = null; public PancakeHouseMenu() { menuItemsList = new List&lt;MenuItem&gt;(); addItem(&quot;K&amp;B's Pancake Breakfast&quot;, &quot;Pancake with eggs and toast&quot;, true, 2.99f); addItem(&quot;Regular's Pancake Breakfast&quot;, &quot;Pancake with eggs and sausags&quot;, true, 2.99f); addItem(&quot;Blueberry's Pancake Breakfast&quot;, &quot;Pancake with eggs and fresh blueberries&quot;, true, 2.99f); } public Iterator createIterator() { return new PancakeIterator(menuItemsList); } public void addItem(string name, string description, bool vegetarian, float price) { MenuItem menuItem = new MenuItem(name, description, vegetarian, price); menuItemsList.Add(menuItem); }} Diner菜单123456789101112131415161718192021222324252627public class DinerMenu{ private readonly int MaxItemsCount = 6; private MenuItem[] menuItemsArray = null; private int numberOfItems = 0; public DinerMenu() { menuItemsArray = new MenuItem[MaxItemsCount]; addItem(&quot;Vegetarian BLT&quot;, &quot;Fakin Bacon with tomato&quot;, true, 2.99f); addItem(&quot;BLT&quot;, &quot;Bacon with tomato&quot;, true, 3.99f); addItem(&quot;Soup of the day&quot;, &quot;Soup of the day and salad&quot;, false, 3.29f); } public void addItem(string name, string description, bool vegetarian, float price) { if (numberOfItems &gt;= MaxItemsCount) return; MenuItem menuItem = new MenuItem(name, description, vegetarian, price); menuItemsArray[numberOfItems++] = menuItem; } public Iterator createIterator() { return new DinerMenuIterator(menuItemsArray); }} 迭代器接口及实现 迭代器接口12345public interface Iterator{ bool hasNext(); object next();} 迭代器实现123456789101112131415161718192021222324252627282930313233343536373839public class PancakeIterator : Iterator{ private List&lt;MenuItem&gt; itemsList = null; private int currentPosition = 0; public PancakeIterator(List&lt;MenuItem&gt; itemsList) { this.itemsList = itemsList; } public bool hasNext() { return currentPosition &lt; itemsList.Count &amp;&amp; itemsList[currentPosition] != null; } public object next() { return itemsList[currentPosition++]; }}public class DinerMenuIterator : Iterator{ private MenuItem[] itemsArray = null; private int currentPosition = 0; public DinerMenuIterator(MenuItem[] items) { this.itemsArray = items; } public bool hasNext() { return currentPosition &lt; itemsArray.Length &amp;&amp; itemsArray[currentPosition] != null; } public object next() { return itemsArray[currentPosition++]; }} 测试代码及结果 测试代码1234567891011121314151617static void Main(string[] args){ DinerMenu dinerMenu = new DinerMenu(); PancakeHouseMenu pancakeHouseMenu = new PancakeHouseMenu(); PrintMenu(dinerMenu.createIterator()); Console.WriteLine(); PrintMenu(pancakeHouseMenu.createIterator());}private static void PrintMenu(Iterator iterator){ while (iterator.hasNext()) { ((MenuItem)iterator.next()).Debug(); }} 运行结果： 组合模式 组合模式（Composite Pattern）是用树形结构来组合对象进而体现一种局部-整体的层次结构。组合模式可以让调用者以统一的方式对待单个物体和多个物体的组合。 例如我们需要打印一个菜单上的所有菜品，但菜单中可能还包含子菜单，子菜单中又可能包含子菜单等等，但对于外部调用者而言则不希望关注这些细节。我们可以通过定义一个基类，无论是菜品还是菜单都继承自这个基类，这样对于菜单而言，无论是子菜单还是菜品都是同一个基类，可一起管理。对于外部调者而言只x需要关心这个基类即可。 代码示例 共同抽象类基类 菜单元素1234567891011121314public abstract class MenuComponent{ public virtual void Add(MenuComponent menuComponent) { throw new NotImplementedException(); } public virtual void Remove(MenuComponent menuComponent) { throw new NotImplementedException(); } public virtual MenuComponent GetChild(int i) { throw new NotImplementedException(); } public virtual string Name { get; protected set; } public virtual string Description { get; protected set; } public virtual float Price { get; protected set; } public virtual bool Vegetarian { get; protected set; } public virtual void Debug() { Console.WriteLine(Name + &quot; , &quot; + Description + &quot; , &quot; + Vegetarian + &quot; , &quot; + Price); }} 菜单及菜品实现 菜单1234567891011121314151617181920212223242526272829303132public class Menu : MenuComponent{ private List&lt;MenuComponent&gt; menuComponetsList = null; public Menu(string name, string description) { menuComponetsList = new List&lt;MenuComponent&gt;(); Name = name; Description = description; } public override void Add(MenuComponent menuComponent) { menuComponetsList.Add(menuComponent); } public override void Remove(MenuComponent menuComponent) { menuComponent.Remove(menuComponent); } public override MenuComponent GetChild(int i) { return menuComponetsList[i]; } public override void Debug() { Console.WriteLine(Name + &quot; , &quot; + Description); menuComponetsList.ForEach(menuComponent =&gt; menuComponent.Debug()); }} 菜品12345678910public class MenuItem : MenuComponent{ public MenuItem(string name, string description, bool vegetarian, float price) { Name = name; Description = description; Vegetarian = vegetarian; Price = price; }} 测试代码及结果 测试代码12345678910111213141516Menu menu = new Menu(&quot;General Menu&quot;, &quot;Holds all menus and menu items&quot;);Menu dinnerMenu = new Menu(&quot;Dinner Menu&quot;, &quot;Holds dinner menu items&quot;);Menu breakfastMenu = new Menu(&quot;Breakfast Menu&quot;, &quot;Holds Breakfast menu items&quot;);menu.Add(dinnerMenu);menu.Add(breakfastMenu);breakfastMenu.Add(new MenuItem(&quot;K&amp;B's Pancake Breakfast&quot;, &quot;Pancake with eggs and toast&quot;, true, 2.99f));breakfastMenu.Add(new MenuItem(&quot;Regular's Pancake Breakfast&quot;, &quot;Pancake with eggs and sausags&quot;, true, 2.99f));breakfastMenu.Add(new MenuItem(&quot;Blueberry's Pancake Breakfast&quot;, &quot;Pancake with eggs and fresh blueberries&quot;, true, 2.99f));dinnerMenu.Add(new MenuItem(&quot;Vegetarian BLT&quot;, &quot;Fakin Bacon with tomato&quot;, true, 2.99f));dinnerMenu.Add(new MenuItem(&quot;BLT&quot;, &quot;Bacon with tomato&quot;, true, 3.99f));dinnerMenu.Add(new MenuItem(&quot;Soup of the day&quot;, &quot;Soup of the day and salad&quot;, false, 3.29f));menu.Debug(); 运行结果： 引用： https://design-patterns.readthedocs.io/zh_CN/latest/behavioral_patterns/behavioral.html","link":"/HeadFirstDesignPatternNotes-2/"},{"title":"Hexo教程（二）","text":"这一篇我们将学习使用主题，themes文件夹即为主题文件存在的路径。Hexo安装后自带了landscape主题，在Hexo官网上也有多个主题供选择，这里我选择了较为经典的模版nexT，nexT的官网文档可能因为较长时间未更新，文档的中的一些配置已经无法在最新（本文创建时为V6.7.0）的nexT中生效，所以本文的一些内容会与官网文档不同。 Hexo工程中一般存在多个_config.yml文件在Hexo目录下会存在一个，在每一个主题的文件夹下还有一个。我们将存在于Hexo目录下的配置文件叫做 站点配置文件,存在于主题文件夹下的叫做 主题配置文件 。 安装nexT主题 在Hexo目录下，运行git clone https://github.com/iissnan/hexo-theme-next themes/next命令即可下载nexT工程，在下载完成后，打开站点配置文件，并找到theme字段，将其属性改为next即表示开始使用nexT主题 1theme: next 选择主题模版 nexT自带有四个模版Muse,Mist,Pisces,Gemini,可以在主题配置文件中找到字段scheme，并进行相应的修改 1scheme: Pisces 配置站点语言 我们可以修改博客的语言版本，在站点配置文件中找到language字段，并修改为自己想要的语言版本。 1language: zh-CN 支持的语言版本由主题文件来决定，在主题文件夹下存在languages文件夹，下面存放了该主题所支持的语言。如nexT所支持的语言为： Menu菜单 默认的Menu菜单只有归档和首页两个页面，如果要增加更多的页面，在主题配置文件的menu字段中加入即可，字段的格式如下。其中Icon为Font Awesome图标，名字与Font Awesome对应即可 123menu:# &lt;KEY&gt; : &lt;Link&gt; || &lt;Icon&gt; home: / || home 侧边栏 在主题配置文件中修改sidebar字段开控制侧边栏行为，比如position表示显示的位置，display表示显示的时机 12345sidebar: # 侧边栏显示在左侧 position: left #只在文章存在目录的情况下显示侧边栏 display: post 侧边栏中的头像可在主题配置文件中的avatar字段中修改 1234avatar: # 使用本地图片时，将图片放在source目录下的uploads或images目录下（必须是这两个目录名字） #网络图片，直接将图片的url赋值即可 url: /uploads/blackCat.jpg 侧边栏的作者昵称和站点描述可分别在站点配置文件中的author和description中修改 123description: To see the world as it is, and to love it.keywords:author: 三叔","link":"/HexoTutorial-2/"},{"title":"《Head First 设计模式》 笔记（一）","text":"这一系列为读《Head First 设计模式》时的笔记。 这一篇将会介绍策略模式，观察者模式，装饰模式，工厂模式。 在介绍每一个设计模式时，都会用一个简单的例子来说明，完整的测试代码可以在这里查看 原书中的示例代码都是Java，而我在工作中C#用的较多，所以这里的测试代码使用的都是C#。 策略模式 策略模式（Strategy Pattern）是使用一些独立的类来各自封装一些通用的算法，这些封装类都继承自同一个接口，该接口定义了算法。对于调用类来说，它只保存一个算法接口的对象，而这个对象所指代的特定算法则可以在运行时动态更改。 例如有我们有一个项目需要描述鸭子，可能有50种不同的鸭子都派生自基类Duck，鸭子一共有三种飞行方式。这时候我们如果将某一种特定的飞行方式写在基类中，则不是使用这个飞行方式的所有派生鸭子都需要对该方法重写。如果我们不在基类中定义，而在各个派生类中实现，则可能多个有相同飞行方式的鸭子派生类都有相同的代码定义飞行方式，这造成了代码冗余。 所以我们可以使用策略模式，将三种飞行方式都派生自接口FlyBehavior，并在鸭子基类中定义变量FlyBehavior，然后在派生类中选择各自需要的飞行方式即可。 代码示例 算法接口及实现类 飞行方法接口1234public interface IFlyBehavior{ void Fly();} 飞行方法实现1234567891011121314151617181920212223public class FlyNoWay : IFlyBehavior{ public void Fly() { Console.WriteLine(&quot;Can not fly&quot;); }}public class FlyWithRocket : IFlyBehavior{ public void Fly() { Console.WriteLine(&quot;Fly with rocket&quot;); }}public class FlyWithWings : IFlyBehavior{ public void Fly() { Console.WriteLine(&quot;Fly with wings&quot;); }} 环境类 鸭子基类123456789101112131415161718public abstract class Duck{ private IFlyBehavior flyBehavior; public Duck() { } public abstract void disPlay(); public void PerformFly() { flyBehavior.Fly(); } public void setFlyBehavior(IFlyBehavior fb) { flyBehavior = fb; }} 鸭子派生类123456789101112131415161718192021222324public class BlackDuck : Duck{ public BlackDuck() : base() { setFlyBehavior(new FlyWithWings()); } public override void disPlay() { Console.WriteLine(&quot;I am a black duck&quot;); }}public class RubberDuck : Duck{ public RubberDuck() : base() { setFlyBehavior(new FlyNoWay()); } public override void disPlay() { Console.WriteLine(&quot;I am a rubber duck&quot;); }} 测试及结果 测试代码123456789RubberDuck rubberDuck = new RubberDuck();rubberDuck.disPlay();rubberDuck.PerformFly();BlackDuck blackDuck = new BlackDuck();blackDuck.disPlay();blackDuck.PerformFly();blackDuck.setFlyBehavior(new FlyWithRocket());blackDuck.PerformFly(); 运行结果 观察者模式 观察者模式（Observer Pattern）定义了一种一对多的依赖关系，当被观察者（Subject）的状态发生变化时，它将会通知观察者们（Observers）进行某种操作。 例如我们希望定义温度计和压力计，在天气信息发生变化时自动更新，而非自己反复的查询是否天气信息有发生变化。这里天气信息就是被观察者，而温度计和压力计就是观察者。 代码示例 观察者及被观察者接口 被观察者123456public interface ISubject{ void RegisterObserver(IObserver observer); void UnregisterObserver(IObserver observer); void NotifyObservers();} 观察者1234public interface IObserver{ void Update(ISubject subject);} 观察者实现 温度计123456789101112131415161718public class TemperatureObserver : IObserver{ private ISubject subject; public TemperatureObserver(ISubject subject) { this.subject = subject; this.subject.RegisterObserver(this); } public void Update(ISubject subject) { WeatherData weatherData = subject as WeatherData; //注意这里我们是从主动从被观察者那里去获取数据 if (weatherData != null) Console.WriteLine(&quot;Temperature is &quot; + weatherData.Temperature); }} 压力计12345678910111213141516public class PressureObserver : IObserver{ private ISubject subject; public PressureObserver(ISubject subject) { this.subject = subject; this.subject.RegisterObserver(this); } public void Update(ISubject subject) { WeatherData weatherData = subject as WeatherData; if (weatherData != null) Console.WriteLine(&quot;Pressure is &quot; + weatherData.Pressure); }} 被观察者实现 天气数据1234567891011121314151617181920212223242526272829303132333435363738394041public class WeatherData : ISubject{ private List&lt;IObserver&gt; observersList; public float Temperature { get; private set; } public float Humidity { get; private set; } public float Pressure { get; private set; } public WeatherData() { observersList = new List&lt;IObserver&gt;(); } public void NotifyObservers() { observersList.ForEach(o =&gt; o.Update(this)); } public void RegisterObserver(IObserver o) { observersList.Add(o); } public void UnregisterObserver(IObserver o) { observersList.Remove(o); } private void measurementsChanged() { NotifyObservers(); } public void SetMeasurements(float temperature, float humidity, float pressure) { this.Temperature = temperature; this.Humidity = humidity; this.Pressure = pressure; measurementsChanged(); }} 测试及结果 测试代码12345678WeatherData weatherData = new WeatherData();TemperatureObserver temperatureObserver = new TemperatureObserver(weatherData);PressureObserver pressureObserver = new PressureObserver(weatherData);weatherData.SetMeasurements(30, 20, 10);weatherData.SetMeasurements(20, 40, 5);weatherData.UnregisterObserver(temperatureObserver);weatherData.SetMeasurements(10, 50, 15); 运行结果： 装饰模式 装饰模式(Decorator Pattern))提供了一个动态增加一个类功能的方法，主要实现思想是通过一个作为装饰者的类（Decorators）包裹被装饰类（Component）（装饰类以及被装饰类都有共同的基类）,Decorators会在Component类的某一个函数执行前或后进行一些操作，进而达到增加功能的作用。 装饰模式主要实现了“代码应该对扩展功能开放而对于修改关闭”的面向对象原则，它在增加新功能的前提下，不需要改动既有的代码，只需要增加新的Decorators并且包含既有的Component即可。 例如我们要计算一杯咖啡的价格，而这杯咖啡的价格还会受到额外的配料的影响，比如要加抹茶需要额外支付0.2元，加奶泡需要额外支付0.3元等。如果对各种配料都各自使用一个类来表示，则会存在较多的类需要维护，而且一旦配料发生变化等，还需要进行代码修改。而使用装饰模式则可以将原始的咖啡作为被装饰类，而所有的配料都是装饰类，则配料的更改仅需要增加或删除外部的装饰类即可。 代码示例 装饰类及被装饰类基类 被装饰类基类1234567891011public abstract class Beverage{ protected string description = &quot;UnKnown Beverage&quot;; public virtual string getDescription() { return description; } public abstract double Cost();} 装饰类基类123456789public abstract class CondimentDecorator : Beverage{ protected Beverage beverage; public CondimentDecorator(Beverage beverage) { this.beverage = beverage; }} 注意装饰类基类继承自被装饰类，并存有一个被装饰类的变量，因为装饰类需要在被装饰类操作的基础上进行一定额外的操作，所以它需要存有对被装饰类的引用，同时对外部而言调用者而言，它与被装饰类相同。 被装饰类实现 浓咖啡123456789101112public class Espresso : Beverage{ public Espresso() { description = &quot;Espresson&quot;; } public override double Cost() { return 1.99; }} 装饰类实现 酱油1234567891011121314public class Soy : CondimentDecorator{ public Soy(Beverage beverage) : base(beverage) { } public override string getDescription() { return beverage.getDescription() + &quot;, Soy&quot;; } public override double Cost() { return 0.30 + beverage.Cost(); }} 奶泡1234567891011121314public class Whip : CondimentDecorator{ public Whip(Beverage beverage) : base(beverage) { } public override string getDescription() { return beverage.getDescription() + &quot;, Whip&quot;; } public override double Cost() { return 0.30 + beverage.Cost(); }} 抹茶1234567891011121314public class Mocha : CondimentDecorator{ public Mocha(Beverage beverage) : base(beverage) { } public override string getDescription() { return beverage.getDescription() + &quot;, Mocha&quot;; } public override double Cost() { return 0.20 + beverage.Cost(); }} 测试及结果 测试代码12345Espresso espresso = new Espresso();Console.WriteLine(espresso.getDescription() + &quot; Cost: &quot; + espresso.Cost());Beverage doubleMochaWhipEspresso = new Mocha(new Mocha(new Whip(espresso)));Console.WriteLine(doubleMochaWhipEspresso.getDescription() + &quot; Cost: &quot; + doubleMochaWhipEspresso.Cost()); 运行结果： 工厂模式 工厂模式是为了将对象的实例化与对对象的操作解耦。因为有时我们会根据情况的不同，实例化出对象的不同版本，而我们不希望这种对于情况的判断与逻辑代码耦合在一起。 工厂模式有三个较为常见的变种，简单工厂模式，工厂方法模式，抽象工厂模式，下面会以创建披萨为例子来具体说明。 简单工厂模式 简单工厂模式严格意义上并不是一个设计模式，只是它被太多人的使用，所以需要单独进行说明。 简单工厂模式会定义一个工厂类来进行对象的实例化。 我们定义一个披萨商店，他将会管理披萨产出的整个流程。我们为了将披萨的生产与之后的操作（如切披萨）拆分开，需要定义一个简单披萨工厂。 披萨类及其实例化 披萨基类1234567891011121314151617181920212223242526272829303132333435public abstract class Pizza{ protected Cheese cheese = null; protected Sauce sauce = null; protected Onion onion = null; public string name { get; set; } public abstract void prepare(); public void bake() { Console.WriteLine(&quot;Bake for 25 minutes at 350&quot;); } public void cut() { Console.WriteLine(&quot;Cutting the pizza into diagonal slices&quot;); } public void box() { Console.WriteLine(&quot;Place pizza in official PizzaStore box&quot;); } public void Debug() { Console.WriteLine(&quot;--------------&quot;); Console.WriteLine(name); Console.WriteLine(&quot;Cheese is &quot; + (cheese != null ? cheese.ToString() : &quot;Null&quot;)); Console.WriteLine(&quot;Sauce is &quot; + (sauce != null ? sauce.ToString() : &quot;Null&quot;)); Console.WriteLine(&quot;Onion is &quot; + (onion != null ? onion.ToString() : &quot;Null&quot;)); Console.WriteLine(&quot;--------------&quot;); }} 披萨实现123456789101112131415public class CheesePizza : Pizza{ public override void prepare() { cheese = new Cheese(); }}public class SaucePizza : Pizza{ public override void prepare() { sauce = new Sauce(); }} 披萨商店与简单披萨工厂 披萨商店123456789101112131415161718public class PizzaStore{ SimplePizzaFactory simpleFactory; public PizzaStore(SimplePizzaFactory factory) { this.simpleFactory = factory; } public Pizza orderPizza(string type) { Pizza pizza = simpleFactory.createPizza(type); pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); return pizza; }} 简单披萨工厂123456789101112public class SimplePizzaFactory{ public Pizza createPizza(string type) { Pizza pizza = null; if (type.Equals(&quot;cheese&quot;)) pizza = new CheesePizza(); else if (type.Equals(&quot;sauce&quot;)) pizza = new SaucePizza(); return pizza; }} 测试及结果 测试代码123PizzaStore store = new PizzaStore(new SimplePizzaFactory());Pizza pizza = store.orderPizza(&quot;cheese&quot;);pizza.Debug(); 运行结果: 工厂方法模式 简单工厂提供了一个类来作为对象实例化的工厂，它解决了对象实例化与逻辑代码耦合的问题，但没有提供扩写这个工厂的方法。例如上例中，我们需要在工厂中增加新的产品只能扩写原先的工厂类，但这可能会造成单个工厂类的逻辑过于复杂。 而工厂方法模式则是通过一个抽象函数来作为工厂，在各派生类中重写该函数，达到工厂的扩写。 我们定义一个抽象的披萨商店，并在其中定义一个抽象函数createPizza，并在披萨商店的继承类中重写这个方法来演示工厂方法模式。 注意这个例子完全可以通过建立多个简单工厂来实现，这里只是为了说明工厂方法模式的结构。 抽象披萨商店及实例化 抽象披萨商店1234567891011121314public abstract class PizzaStore{ public Pizza orderPizza(string type) { Pizza pizza = createPizza(type); pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); return pizza; } protected abstract Pizza createPizza(string type);} 纽约披萨商店123456789101112public class NYPizzaStore : PizzaStore{ protected override Pizza createPizza(string type) { Pizza pizza = null; if (type.Equals(&quot;cheese&quot;)) pizza = new NYStyleCheesePizza(); else if (type.Equals(&quot;sauce&quot;)) pizza = new NYStyleSausePizza(); return pizza; }} 芝加哥披萨商店123456789101112public class ChicagoPizzaStore : PizzaStore{ protected override Pizza createPizza(string type) { Pizza pizza = null; if (type.Equals(&quot;cheese&quot;)) pizza = new ChicagoStyleCheesePizza(); else if (type.Equals(&quot;sauce&quot;)) pizza = new ChicagoStyleSaucePizza(); return pizza; }} 不同风格的披萨实现 纽约风格的披萨123456789101112131415public class NYStyleCheesePizza : Pizza{ public override void prepare() { cheese = new NYCheese(); }}public class NYStyleSausePizza : Pizza{ public override void prepare() { sauce = new NYSauce(); }} 芝加哥风格的披萨123456789101112131415public class ChicagoStyleCheesePizza : Pizza{ public override void prepare() { cheese = new ChicagoCheese(); }}public class ChicagoStyleSaucePizza : Pizza{ public override void prepare() { sauce = new ChicagoSauce(); }} 测试及结果 测试代码123456PizzaStore store = new ChicagoPizzaStore();Pizza pizza = store.orderPizza(&quot;cheese&quot;);pizza.Debug();store = new NYPizzaStore();pizza=store.orderPizza(&quot;cheese&quot;);pizza.Debug(); 运行结果： 抽象工厂模式 工厂方法模式中的工厂的多态性依赖于继承，比如我们定义的PizzaStore中有个抽象函数createPizza，这个抽象函数即为一个工厂，在各个派生类中我们去重写这个抽象函数，通过继承来实现不同的工厂。而在抽象工厂模式中，我们将定义一个工厂接口，在需要工厂的接口中类中存储这个接口，并在不同的情况下用这个接口不同的实现，来达到工厂的多态性。 另外在工厂方法模式中，因为是通过重写函数的方法来实现，所以一个工厂只能产出一个产品。而在抽象工厂模式中，在一个抽象工厂中却能定义多个制造产品的函数，进而一个抽象工厂可以提供多个产品。 生产出一个产品还是多个产品并不是抽象工厂模式和工厂方法模式的主要区别，他们的主要区别在于工厂方法模式是通过继承来实现工厂的多态，而抽象工厂模式是通过组合。 我们定义一个披萨原料工厂，来体现抽象工厂模式。 披萨原料工厂接口及实现 披萨原料工厂接口123456public interface PizzaIngredientFactory{ Onion createOnion(); Sauce createSauce(); Cheese createCheese();} 纽约披萨原料商店1234567891011121314151617public class NYPizzaIngredientFactory : PizzaIngredientFactory{ public Cheese createCheese() { return new NYCheese(); } public Onion createOnion() { return new NYOnion(); } public Sauce createSauce() { return new NYSauce(); }} 芝加哥披萨原料商店1234567891011121314151617public class ChicagoPizzaIngredientFactory : PizzaIngredientFactory{ public Cheese createCheese() { return new ChicagoCheese(); } public Onion createOnion() { return new ChicagoOnion(); } public Sauce createSauce() { return new ChicagoSauce(); }} 可以看到在抽象工厂的实现时，用到了工厂方法模式。抽象工厂模式与工厂方法模式并非互斥的两种模式，工厂方法模式实际上内嵌与抽象工厂模式中 抽象披萨商店及实例化 抽象披萨商店1234567891011121314public abstract class PizzaStore{ public Pizza orderPizza(string type) { Pizza pizza = createPizza(type); pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); return pizza; } protected abstract Pizza createPizza(string type);} 纽约披萨商店12345678910protected override Pizza createPizza(string item){ Pizza pizza = null; PizzaIngredientFactory ingredientFactory = new NYPizzaIngredientFactory(); if (item == &quot;cheese&quot;) pizza = new CheesePizza(ingredientFactory); else if (item == &quot;sauce&quot;) pizza = new SaucePizza(ingredientFactory); return pizza;} 芝加哥披萨商店12345678910111213public class ChicagoPizzaStore : PizzaStore{ protected override Pizza createPizza(string item) { Pizza pizza = null; PizzaIngredientFactory ingredientFactory = new ChicagoPizzaIngredientFactory(); if (item == &quot;cheese&quot;) pizza = new CheesePizza(ingredientFactory); else if (item == &quot;sauce&quot;) pizza = new SaucePizza(ingredientFactory); return pizza; }} 注意，这里披萨商店的实现，仍然是通过工厂方法模式。只是在createPizza函数中会实例化一个抽象工厂，并将其传递给对应的Pizza对象 披萨类及其实例化 在披萨类的实例化中，我们使用了抽象工厂模式，披萨的实例化会包含一个披萨原料的抽象工厂，通过不同的披萨原料工厂来取得不同风味的披萨 披萨基类1234567891011121314151617181920212223242526272829303132333435public abstract class Pizza{ protected Cheese cheese = null; protected Sauce sauce = null; protected Onion onion = null; public string name { get; set; } public abstract void prepare(); public void bake() { Console.WriteLine(&quot;Bake for 25 minutes at 350&quot;); } public void cut() { Console.WriteLine(&quot;Cutting the pizza into diagonal slices&quot;); } public void box() { Console.WriteLine(&quot;Place pizza in official PizzaStore box&quot;); } public void Debug() { Console.WriteLine(&quot;--------------&quot;); Console.WriteLine(name); Console.WriteLine(&quot;Cheese is &quot; + (cheese != null ? cheese.ToString() : &quot;Null&quot;)); Console.WriteLine(&quot;Sauce is &quot; + (sauce != null ? sauce.ToString() : &quot;Null&quot;)); Console.WriteLine(&quot;Onion is &quot; + (onion != null ? onion.ToString() : &quot;Null&quot;)); Console.WriteLine(&quot;--------------&quot;); }} 披萨实现12345678910111213141516171819202122232425262728293031public class CheesePizza : Pizza{ private PizzaIngredientFactory ingredientFactory = null; public CheesePizza(PizzaIngredientFactory ingredientFactory) { this.ingredientFactory = ingredientFactory; } public override void prepare() { cheese = ingredientFactory.createCheese(); onion = ingredientFactory.createOnion(); }}public class SaucePizza : Pizza{ private PizzaIngredientFactory ingredientFactory = null; public SaucePizza(PizzaIngredientFactory ingredientFactory) { this.ingredientFactory = ingredientFactory; } public override void prepare() { sauce = ingredientFactory.createSauce(); onion = ingredientFactory.createOnion(); }} 测试及结果 测试代码1234567PizzaStore pizzaStore = new NYPizzaStore();Pizza pizza = pizzaStore.OrderPizza(&quot;cheese&quot;);pizza.Debug();Console.WriteLine(&quot;--------&quot;);pizzaStore = new ChicagoPizzaStore();pizza = pizzaStore.OrderPizza(&quot;cheese&quot;);pizza.Debug(); 运行结果： 引用： https://design-patterns.readthedocs.io/zh_CN/latest/ https://dzone.com/articles/factory-method-vs-abstract https://stackoverflow.com/questions/5739611/differences-between-abstract-factory-pattern-and-factory-method","link":"/HeadFirstDesignPatternNotes-1/"},{"title":"Hexo教程（三）","text":"这一篇主要是说明标签页面和分类页面如何创建以及一些针对主题的细枝末节的修改。本篇文章也将持续更新，在每次网站主题修改后，都将在本篇中记录修改方法。 创建标签页面 先运行hexo new post tags创建tag页面资源，再在主题配置文件中找到menu字段，并启用tags 12menu: tags: /tags/ || tags 之后在刚新生成在source文件夹的tags文件夹中找到index.md，在其中增加type: &quot;tags&quot;，并修改Title为自己想要的文字 12345---title: 标签date: 2019-01-06 00:21:31type: &quot;tags&quot;--- 在下图的红框及黄框处都会自动链接到Tags页面，Tags页面也将自动统计目前所使用的标签数 创建分类页面 运行hexo new page categories创建分类页面，之后的操作与创建标签页面类似，这里不做赘述。 设置代码风格 在主题配置文件中修改highlight_theme字段，目前共有normal,night,night eighties,night blue,night bright，五种选项 1highlight_theme: night 社交链接 在主题配置文件中修改social字段，其格式与menu字段相同，|| 前为链接，后为Font Awesome图标 12social: GitHub: https://github.com/xuejiaW || github 打赏功能/订阅微信公众号 分别在主题配置文件中修改reward及wechat_subscriber字段 123456789reward: enable: true comment: Donate comment here wechatpay: /images/wechatpay.jpgwechat_subscriber: enabled: true qcode: /path/to/your/wechatqcode e.g. /uploads/wechat-qcode.jpg description: e.g. subscribe to my blog by scanning my public wechat account 动画效果修改 在配置文件中修改motion字段下的相应设置即可。 12motion: enable: true 修改文末#符号 每一篇文章如果打上了Tag，则会在文末显示#&lt;tag&gt;这样的标记，但#显得不太美观，而且无法直接的表现出其标签的含义，所以这里想将其替换为图标 找到themes/next/layout/_macro/post.swig文件，并在其中搜索rel=&quot;tag&quot;字段，并将其后的#修改为&lt;i class=&quot;fa fa-&lt;FontAwesome icon&gt;&quot;&gt; &lt;/i&gt;即可 1&lt;a href=&quot;{{ url_for(tag.path) }}&quot; rel=&quot;tag&quot;&gt;&lt;i class=&quot;fa fa-tags&quot;&gt; &lt;/i&gt; {{ tag.name }}&lt;/a&gt; 上例中的tags即为FontAwesome图标 首页增加阅读全文功能 在文章想要出现在首页的内容之后加入&lt;!--more--&gt;即可 123这一篇主要是说明标签页面和分类页面如何创建以及一些针对主题的细枝末节的修改。本篇文章也将持续更新，在每次网站主题修改后，都将在本篇中记录修改方法。&lt;!--more--&gt; 在点击了阅读全文按钮进入文章后会发现，文章自动跳转到了首页显示内容之后的地方，如果要关闭这个功能，在主题配置文件中修改scroll_to_more字段 1scroll_to_more: false 关闭归档页面Cheers 进入归档页面后会发现默认有以下效果 如果需要关闭的话，在主题配置文件中找到cheers_enabled字段 1cheers_enabled: false 文章及站点字数统计 Github支持地址：https://github.com/theme-next/hexo-symbols-count-time 首先在Hexo目录下运行npm install hexo-symbols-count-time --save安装需要的插件，后在站点配置文件中添加 12345symbols_count_time: symbols: true time: true total_symbols: true total_time: false 再在主题配置文件中修改symbols_count_time字段 123456symbols_count_time: separated_meta: true item_text_post: true item_text_total: true awl: 2 # 统计的语言 中文为2，英语为5，俄语为6 wpm: 275 # 每分钟估计的阅读字符数 增加本地搜索功能 Github支持地址 https://github.com/theme-next/hexo-generator-searchdb 首先在Hexo目录下运行npm install hexo-generator-searchdb --save安装需要的插件，后在站点配置文件中添加 12345search: path: search.xml field: post format: html limit: 10000 #最大搜索的文章数，10000即为在最新的10000篇文章中搜索 再在主题文件中配置修改local_search字段 12345local_search: enable: true trigger: auto top_n_per_article: 1 unescape: false 修改背景 在\\themes\\next\\source\\css\\_custom\\custom.styl文件下增加 1234567body { background:url(&quot;background url&quot;); background-repeat: no-repeat; background-attachment:fixed; background-size: cover; width: 100%;} 修改页面其他元素 实际上next自定义的修改都可放在\\themes\\next\\source\\css\\_custom\\custom.styl下，想要修改某一部分时，可以先打开博客网页（以Chrome游览器为例），然后按F12，唤出调试界面。 当在Element情况下选择部分代码，左侧页面相关部分会高亮，这部分类也会相应的显示出来，如上图中为.sidebar-inner，只要把最右侧的相关代码 123456.sidebar-inner { position: relative; padding: 20px 10px; color: #999; text-align: center;} 改动后复制到custom.styl即可。 由于我不懂CSS，所以这部分的修改也是摸石头过河，就不多说了。 增加Valine评论系统 Valine是一个轻量级，无后端的评论系统，它完全依赖于Leancloud运行，配置起来也十分便捷。 在Leancloud上完成账号的注册登录，并创建完应用后。如下图进入应用界面，并进入设置找到AppID与AppKey。 在主题配置文件中开启Valine并填入相应参数即可 1234567891011valine: enable: true appid: APPID appkey: APPKEY notify: false verify: false placeholder: 匿名的！不需要注册！想说啥直接说吧！ avatar: mm guest_info: nick,mail,link pageSize: 10 visitor: true #这里开启后注意该文件中还有一个leancloud_visitors字段，这两个功能相同，选一个开启就好，否则会有冲突 完成配置后刷新页面，每篇文章下便会出现评论，之前的分类及标签页面也会出现，如果不想在这两个页面显示评论，可以修改对应的index.md文件，如 123456---title: 标签date: 2019-01-06 00:21:31type: &quot;tags&quot;comments: false--- 增加角标功能 运行命令安装角标插件 1npm install hexo-footnotes --save 在主题配置文件中启用插件 12plugins: - hexo-footnotes 角标语法如下 12345678910basic footnote[^1]here is an inline footnote[^2](inline footnote)and another one[^3]and another one[^4][^1]: basic footnote content[^3]: paragraphfootnotecontent[^4]: footnote content with some [markdown](https://en.wikipedia.org/wiki/Markdown 待续 …","link":"/HexoTutorial-3/"},{"title":"《算法导论》 第一、二章笔记","text":"《算法导论》中第一章与第二章阅读笔记。 介绍了插入排序即归并排序的算法及复杂度。 Chapter 1. The Role of Algorithms in Computing Algorithms 算法是一系列将输入转换为输出的操作步骤。 数据结构是存储和管理数据的一种方式，这种方式要考虑到方便设备访问和修改数据。 这本书也介绍了一些设计和分析算法的技术。如设计算法时需要的分治法，动态规划和如何分析算法是否准确是否高效等。 算法在大多数情况下是找寻高效的方法，但在某些问题无法找到高效的解决方法，如NP问题。目前无人知道对于NP究竟是否存在一个高效的方法，而且NP问题有个特性，一旦找到了一个NP问题的高效解决方案，剩下的也就同样找到了。 现代芯片的设计已经从提高时钟频率到了提高并行效率，因为芯片的功率提升与时钟频率的提升是一个超线性关系，如果一味的增高频率，很可能芯片就会过热。为了提升计算效率，现在考虑的就是使用多核芯片进行并行运算，书中也会引入一些多线程的算法。 Algorithms as a technology 不同的算法一般有不同的效率，如插入排序和合并排序，插入排序的效率为$C_1 n^2$,而合并排序的效率为$C_2 n \\log n$，虽然$C_1&lt;C_2$，但是在n较大的情况下，$\\log ⁡n$ 远小于$n^2$，所以对于大数据来说合并排序更为高效。 Chapter 2. Getting Started Insertion Sort 插入排序，在对数量较小的元素排序时是一个很高效的算法。 插入排序类似于打牌整理手牌的过程，下为图解 首先将数组的某一项作为Key值，然后Key值从右至左的与每一项比较，如果该项的数值比Key值大，则将该值像右侧拷贝 A[i+1]=A[i] ，这相当于牌向右移的过程。 如果某一项比Key值小，则将Key值插入在他后方，A[i+1]=key 从数组的第二项开始从左至右的作为Key值，重复a,b的操作 伪代码实现 1234567for j=2 to A.length key=A[j] i=j-1 while i&gt;0 &amp;&amp; A[i]&gt;key A[i+1]=A[i] i--; A[i+1]=key C++实现 1234567891011121314void InsertationSort(int* array, int arraySize){ for (int i = 1; i &lt; arraySize; i++) { int key = array[i]; int startIndex = i - 1; while (startIndex &gt;= 0 &amp;&amp; array[startIndex] &gt; key) { array[startIndex + 1] = array[startIndex]; startIndex--; } array[++startIndex] = key; }} 一些书中伪代码需要注意的点 for循环的变量，在退出循环后，保持最后一个超越循环边界的值 如 for j=2 to A.length，在退出循环后，j = A.length +1 A[ 1……j] 表示A[1]、A[2]…A[j] 函数的形参是值传递的 Analyzing algorithms 分析算法主要是预测算法需要花费的资源，资源通常包括内存、带宽、但我们最关心的还是时间。 书中的分析都是基于单核的随机访问机器(random-access machine)。在这个模型中，所有的操作都看作花费一个固定时长，而且我们不考虑内存操作（如分配内存）所占用的时间。 Analysis of insertion sort 通常描述一个算法的运行时间都是一个关于输入数据大小的函数。 关于输入数据大小的定义根据问题的不同会发生改变。 a. 对于排序问题，数据的大小通常就是需要排列的数的大小 b. 对于两个整数相乘问题，数据大小就是这两个整数需要占据的bit数 c. 有些时候还需要两个数字来描述问题，如关于图的问题就需要顶点数和边数。 关于算法的运行时间通常是关于算法究竟有多少步骤需要执行。在RAM模型中，我们简化每一步所花费的时间都是同样长且都为一个固定值。 循环语句本身比循环体要多一次执行，因为循环语句本身在越界的时候仍然会进行一次判断。 插入算法时间复杂度分析 插入排序步骤 时间花费 运行次数 说明 for j=2 to A.length $c_1$ $n$ 将A.Length看作n，因为循环语句本身多执行一次，所以总运行次数为$n$ key=A[j] $c_2$ $n-1$ 2-&gt;n，运行$n-1$次 i=j-1 $c_3$ $n-1$ 2-&gt;n，运行$n-1$次 while i&gt;0 &amp;&amp; A[i]&gt;key $c_4$ $\\sum_{j=2}^nt_j$ 因为运行次数收到while判断影响，所以不定为$t_j$最好情况下直接满足，只需要判断一次，$t_j=1$最坏情况运行到i=0，运行j次，$t_j=j$ A[i+1]=A[i] $c_5$ $\\sum_{j=2}^n(t_j-1)$ 比循环判断少运行一次，运行次数为$t_j-1$ i–; $c_6$ $\\sum_{j=2}^n(t_j-1)$ 比循环判断少运行一次,运行次数为$t_j-1$ A[i+1]=key $c_7$ $n-1$ 2-&gt;n，运行$n-1$次 如表中所示，在最好情况下，$t_j=1$，最坏情况下运行$j$次。通常计算算法的复杂度，我们只考虑算法的最坏情况，因为往往在实际运算中，最坏情况就是最多的情况（如搜索算法，常常搜索的内容不在列表中，那就要搜索整个列表，即最坏情况）。而且纵使我们取平均值，在本例中，我们取运行次数为$j/2$，最终代入式子中计算，结果的最高次幂并不会改变。 我们以最坏情况计算整个表达式的时间 $$ T(n)=c_1n+c_2(n-1)+c_3(n-1)+c_4\\sum_{j=2}^nj+c_5\\sum_{j=2}^n(j-1)\\\\+c_6\\sum_{j=2}^n(j-1)+c_7(n-1) $$ 又有 $$ \\sum_{j=2}^nj=\\frac{(2+n)(n-1)}{2}=\\frac{n(n+1)}{2}-1 \\\\ \\sum_{j=2}^nj-1=\\frac{(1+n-1)(n-1)}{2}=\\frac{n(n-1)}{2} $$ 代入上式得 $$ T(n)=c_1n+c_2(n-1)+c_3(n-1)+c_4\\frac{n(n+1)}{2}-c_4+\\\\ c_5\\frac{n(n-1)}{2}+c_6\\frac{n(n-1)}{2}+c_7(n-1) \\\\ =\\frac{c_4+c_5+c_6}{2}n^2+(c_1+c_2+c_3+\\frac{c_4}{2} -\\frac{c_5}{2}-\\frac{c_6}{2}+c_7)n-(c_2+c_3+c_4+c_7)\\\\ =an^2+bn+c $$ 所以最坏的运行时间可以表达为$an^2+bn+c$，这是个二次幂方程. Order of growth 一个函数的增长极受最高次幂的影响最大，所以我我们也只关注运算时间的最高次幂，在上例中即为$n_2$。我们将最坏情况运行时间成为$\\Theta(n_2)$ Designing algorithms 这节中简略介绍了分治法（divide-and-conquer），分治法的一大好处是运算时间比较好估计。 The divide-and-conquer approach 许多算法都使用了递归，递归算法就是典型的分治法。将一个大问题分解为几个类似的小问题，然后递归的解决各个小问题，然后把结果合并在一起就得到了最终的答案。 分治法的解决分为三个步骤： 分解：将大问题分解为几个小问题 解决：迭代解决小问题 合并：将小问题的答案结合成为原始问题的答案。 归并排序（Merge sort algorithms）就是一个典型的分治法算法。排序算法的思想是将需要排序的数组二分，先对左半部分进行排序，再对右半部分进行排序，最有把左右半部分合并在一起获得完整的排序好的数组。 归并排序算法的伪代码 123456789101112131415Merge-sort(A,p,r)//A-&gt;需要排序的数组，p-&gt;需要排序部分的左起点，r-&gt;需要排序部分的右终点如果出现了p=r，说明被拆分出的子数组只有一个元素，则不需要计算。只计算p &lt; r的情况if p &lt; r q = [(p+r)/2] //除不尽的话向下取整 //将需要排序的部分等分为两部分，各自进行排序 Merge-sort(A,p,q) Merge-sort(A,q+1,r) Merge(A,p,q,r) 下图为归并排序图解，先将序列逐渐二分直到最后成为单个元素（单个元素不需要合并），然后再进行合并操作。 归并排序中，最重要的就是最终合并的部分。在之前合并函数前，我们假定两个需要被合并的数组已经排序完毕。合并部分的伪代码如下 123456789101112131415161718192021222324252627282930Merge(A,p,q,r)// A-&gt; 需要排序的数组//p,q,r-&gt;数组中的Index，p&lt;q&lt;r，A[p,q]表示一个子数组（下称为左半部分），A[q+1,r]表示另一个子数组（下称为右半部分），左右部分都已经排序完毕。n1=q-p+1 //左半部分长度n2=r-q //右半部分长度Make L[1...n1+1],R[1...n2+1] //创建两个新的数组，长度与左右部分长度+1，防止之后遍历时越界。for i=1 to n1 L[i]=A[p+i-1] //将左半部分内容对应拷贝到新建立的左数组中for j-1 to n2 R[i]=A[q+j] //将右半部分内容对应拷贝到新建立的右数组中//将左右数组的最后一个数值都设为无限大，如果遍历时达到了最后一个数值，说明这个数组已经完全装填回了原数组。因为最后的数值为无限大，所以另一个数组的数值始终小于等于这个数值，因此会一直装填另一个数组。L[n1+1]=Max R[n2+1]=Maxi,j=1for k=p to r if(L[i]&lt;= R[j]&gt;) A[k]=L[i] i++ else A[k]=R[j] j++ 合并部分算法的图解 C++实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344void MergeSort(int* array, int leftStartIndex, int rightEndIndex){ if (leftStartIndex == rightEndIndex) return; int centerIndex = (leftStartIndex + rightEndIndex) / 2; MergeSort(array, leftStartIndex, centerIndex); MergeSort(array, centerIndex + 1, rightEndIndex); Merge(array, leftStartIndex, centerIndex, rightEndIndex);}void Merge(int* array, int leftStartIndex, int middleIndex, int rightEndIndex){ int leftPartLength = middleIndex - leftStartIndex + 1; int rightPartLength = rightEndIndex - middleIndex; int* leftArray = new int[leftPartLength + 1]; int* rightArray = new int[rightPartLength + 1]; for (int i = 0; i &lt; leftPartLength; i++) leftArray[i] = array[leftStartIndex + i]; for (int i = 0; i &lt; rightPartLength; i++) rightArray[i] = array[middleIndex + 1 + i]; //Make the last index to be max leftArray[leftPartLength] = INT_MAX; rightArray[rightPartLength] = INT_MAX; int leftArrayIndex = 0, rightArrayIndex = 0; for (int i = leftStartIndex; i &lt;= rightEndIndex; i++) { if (leftArray[leftArrayIndex] &lt; rightArray[rightArrayIndex]) array[i] = leftArray[leftArrayIndex++]; else array[i] = rightArray[rightArrayIndex++]; } delete[] leftArray; delete[] rightArray;} Analyzing divide-and-conquer algorithms 当计算一个迭代问题的时间复杂度时，我们也常用迭代表达式来表示。 我们假定将原问题拆分为$a$个子问题，每个子问题有$\\frac{1}{b}$个数据，那么所有这些子问题的花费时间为$aT(\\frac{1}{b})$。并且拆分子问题需要$D(n)$的时间，合并子问题需要$C(n)$时间。另外我们需要考虑到如果子问题的输入数据足够小，可能在固定时间内子问题就能解决，例如排序的子问题，如果子数组只有一个变量，那么直接返回即可（固定时间）。所以整体的时间花费为： $$ T(n)=\\begin{cases} \\Theta(1) &amp; \\text{if } n \\leq c\\\\ aT(\\frac{1}{b})+D(n)+C(n) &amp; 其他情况条件 \\end{cases} $$ Analysis of merge sort 这里着重讨论归并排序的时间复杂度。 分解时间：归并排序将数组分为两部分，这一操作只是单纯的二分，所以花费时间为固定值，即$D(n)=\\Theta(1)$ 解决时间：将数组平分为两个部分，所以每一份的数据为$n/2$且有两部分，所以子问题解决时间为$2T(\\frac{n}{2})$ 合并时间： 由合并算法的伪代码可知，整个计算过程只有单层循环，所以时间复杂度$C(n)=\\Theta(n)$ 综上，归并排序的时间复杂度为 $$ T(n)=\\begin{cases} \\Theta(1) &amp; \\text{if } n=1\\\\ 2T(\\frac{n}{2})+\\Theta(n) &amp; \\text{if } n\\geq 1 \\end{cases} $$ 目前$T(n)$的表达式是一个递归表达，我们需要根据这个解出$n\\geq 1$情况下的$T(n)$单纯对于$n$的表达式。 我们将$T(n)$用树形结构表示，每个节点都代表一部分时间，所有节点的时间累计即为$T(n)$ 例如式子$T(n)=2T(\\frac{n}{2})+\\Theta(n)$，使用树形结构表达即为从下图的(a)树转换为(b)树，(b)树中的每个节点即代表等式右边的每小部分。而$T(\\frac{n}{2})$又可进一步表达为$2T(\\frac{n}{4})+\\Theta(\\frac{n}{2})$，即为下图中(b)图的叶子进一步转换，变成©图的样子。 我们可以重复递归这样的操作，直到属性结构变成下图所示： 整棵树所有叶子所代表的时间总和即为$T(n)$，可以看到每一层叶子的总和都为$cn$。最下一层一共有$n$个节点，每个节点时间花费为$c$，即代表归并排序中分解子数组到数组的元素只有一个的情况，这时候直接返回（花费时间固定）。 现在问题的解决到了求树一共有多少层，我们知道最下面一层有$n$个元素，每层的数量都是2的次幂，且第一层为一个元素，所以我们设层数为$x$，计算表达式应该为： $$ 2^(x-1)=n \\\\ x=\\lg n+1 $$ 那么整棵树所有叶子的时间花费总和即为，每层的时间（$cn$）乘以层数($\\lg n+1$)，即$T(n)=cn\\lg n+cn$。 所以归并排序最差情况时间复杂度标识为$\\Theta(n\\lg n)$ 书中的$\\lg n$表示$\\log_2n$，而非一般数学书中的$\\log_{10}n$，因为计算机讨论的是二进制而非现实生活中常用的十进制。 引用： Introduction to Algorithms 3rd Sep.2009","link":"/IA-Chapter1-Chapter2-Notes/"},{"title":"《算法导论》 第十章笔记","text":"《算法导论》第十章笔记，包括栈，队列，链表的实现。 Chapter 10. Elementary Data Structures 集合Set作为计算机科学的基础，重要性与数学中的集合相同。但数学中的集合是不可变的，计算机中的集合可在任意时刻扩张，收缩和更改，称之为动态集合（dynamic set）。一般动态集合需要实现如下操作中的一部分： Search，Insert，DELETE，MINIMUM，MAXIMUM，SUCCESSOR，PREDECESSOR 这些操作可以分为两种，查询操作(Queries)和修改操作(Modifying operations)，如Search，MINIMUM，MAXIMUM，SUCCESSOR，PREDECESSOR都属于前者，Insert，DELETE属于后者 Stacks and queues 堆栈(Stacks)是后进先出，队列(Queues)是先进先出。 Stacks 在堆栈上的插入操作一般成为Push，删除操作一般称为Pop。堆栈有一个top指针指向队列中的第一个元素，在Pop时返回该元素，在Push时top指针向前移动一格，并在新的地方插入新值，当top为0则说明队列为空。 堆栈的图解如下图，(a)为原始样子，(b)为执行了Push(17)和Push(3)后的样子，©为执行了Pop后的样子。图中的S.top表示当前指针的索引值。 堆栈操作微数据实现，每个步骤的复杂度都为O(1) 12345678910111213141516171819STACK_EMPTY(S):if s.top==0; return true;else return false;Push(S,x):S.top=S.top+1;S[S.top]=x;Pop(S):if STACK_EMPTY(S) error&quot;underflow&quot;else S.top=S.top-1; return S[S.top+1] c++的数组实现，不支持运行时扩大队列大小。 1234567891011121314151617181920212223242526272829303132333435363738394041class Stack{public: int data[MAX]; ~Stack() {} Stack() { top = -1; } bool push(int value) { if (top &gt; (MAX - 1)) { cout &lt;&lt; &quot;Stack Overflow&quot;&lt;&lt;endl; return false; } data[++top] = value; return true; } int pop() { if (isEmpty()) { cout &lt;&lt; &quot;Stack is empty&quot;&lt;&lt;endl; return -1; } else { return data[top--]; } } bool isEmpty() { return top &lt; 0; }private: int top;}; Queues 队列的插入操作称为ENQUEUE，删除操作称为DEQUEUE。队列的图解如下图，队列存在一个head指针和一个tail指针，两指针间的数据为队列保存的数据。当进行插入操作时，tail指针前移并在新地方插入数据，当进行删除操作时，head指针返回指着的值，并前移。 图解如下图，使用一个大小为12的数组表示队列 (a) 为初始状态，索引7-11为原始数据 (b) 为执行了Enqueue(17),Enqueue(3),Enqueue(5)后的样子，每一步执行时tail指针先向前，再插入新值。当抵达数组边界时，返回数组的开头处继续执行插入操作 © 为执行了Dequeue（）操作的样子 队列伪代码如下 12345678910111213141516ENQUEUE(Q,X):Q[Q..tail] = xif [Q.tail == Q.length] Q.tail = 1;else Q.tail = Q.tail + 1DEQUEUE(Q):x=Q[Q.head]if [Q.head == Q.length] Q.head = 1;else Q.head = Q.head + 1return x c++的循环数组实现 当top == head时认为队列为空，当(top+1) % size == head时，认为队列已满。所以在队列插满的情况下永远会有一个空的值（因为top不等于head） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Queue{public: Queue() { head = tail = 0; } ~Queue() { head = tail = 0; } bool Enqueue(int value) { if ((tail + 1) % QUEUESIZE == 0) { cout &lt;&lt; &quot;Queue is full&quot; &lt;&lt; endl; return false; } data[tail] = value; tail = (tail == QUEUESIZE - 1) ? 0 : tail + 1; return true; } int Dequeue() { if (Empty()) { cout &lt;&lt; &quot;Queue is empty&quot; &lt;&lt; endl; return -1; } int value = data[head]; head = (head == QUEUESIZE - 1) ? 0 : head + 1; return value; } bool Empty() { return head == tail; }private: int data[QUEUESIZE]; int head; int tail;}; Linked lists 链表(linked list)是一种对象线性排列的数据结构。 对于双向链表(Doubly linked list)来说，每个结点都保留有三个对象，表示属性的key，以及两个指针next和prev。如果对于结点x来说,x.prev==Null，则说明x是头结点，如果x.next==Null，则说明x是尾结点。另外还有存有一个变量head来指向头结点，如果head为空，则说明列表为空。 对于单链表（Singly linked list），删除双向链表中的prev对象即可。 对于循环链表（Circular list），尾结点的next指向头结点，头结点的prev指向尾结点。 下图是非循环双向链表的图解 (a) 为存有数据{1,4,9,16}的列表 (b) 为插入了数据25之后的列表 © 为删除了数据4之后的列表 链表通常需要支持Search，Insert和Delete操作，三者的伪代码分别为 123456789101112131415161718192021222324SEARCH(L,k):x=L.headwhile x!=null and x.key!=k x=x.nextreturn xINSERT(L,k):x.next=L.headif L.head!=null L.head.prev=x;x.prev=null;L.head=x;DELETE(L,x)if(x.prev!=Null) x.prev.next=x.nextelse L.head=x.nextif x.next!=null x.next.prev=x.prev Search的复杂度为$\\Theta(n)$，Insert的复杂度为$O(1)$，Delete的复杂度本身为$O(1)$，但是通常删除操作前需要先找到该元素，所以整体复杂度为$\\Theta(n)$ 列表的C++实现如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283struct Node{ int value; Node* next; Node* prev;};class List{public: List() { head = nullptr; } ~List() { } void Insert(int value) { Node* node = (Node*)malloc(sizeof(Node)); node-&gt;value = value; node-&gt;next = head; node-&gt;prev = nullptr; if (head != nullptr) head-&gt;prev = node; head = node; } void Delete(int value) { Node* toDelete = Search(value); if (toDelete == nullptr) return; if (toDelete-&gt;prev != nullptr) toDelete-&gt;prev-&gt;next = toDelete-&gt;next; else head = toDelete-&gt;next; if (toDelete-&gt;next != nullptr) toDelete-&gt;next-&gt;prev = toDelete-&gt;prev; free(toDelete); } Node* Search(int value) { Node* begin = head; while (begin != nullptr &amp;&amp; begin-&gt;next != nullptr &amp;&amp; begin-&gt;value != value) { begin = begin-&gt;next; } if (begin-&gt;value == value) { cout &lt;&lt; &quot;Find the value &quot; &lt;&lt; value &lt;&lt; endl; return begin; } else { return nullptr; } } void Print() { Node* begin = head; while (begin != nullptr) { cout &lt;&lt; &quot;List element value is &quot; &lt;&lt; begin-&gt;value &lt;&lt; endl; begin = begin-&gt;next; } cout &lt;&lt; &quot;Print is over&quot; &lt;&lt; endl; }private: Node* head;}; Sentinels 可以使用一个哨兵结点来将列表变为循环列表，将哨兵结点命名为nil，nil.next=head且nil.prev=tail，这时候列表中就不需要存储head结点了，因为通过nil即可找到head。 使用了哨兵结点后，搜索，插入以及删除伪代码变为 123456789101112131415161718SEARCH(L,k):x=L.nil.nextwhile x!=L.nil and x.key!=k x=x.nextreturn xINSERT(L,k):x.next=L.nil.nextx.prev=L.nilL.nil.next.prev=x;L.nil.next=xDELETE(L,x)x.next.prev=x.prev;x.prev.next=x.next 哨兵循环双链表的C++实现为 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172struct Node{ int value; Node* next; Node* prev;};class List_Sentinels{public: List_Sentinels() { sentials = (Node*)malloc(sizeof(Node)); sentials-&gt;next = sentials; sentials-&gt;prev = sentials; } ~List_Sentinels() { free(sentials); } void Insert(int value) { Node* node = (Node*)malloc(sizeof(Node)); node-&gt;value = value; node-&gt;next = sentials-&gt;next; node-&gt;prev = sentials; sentials-&gt;next-&gt;prev = node; sentials-&gt;next = node; } void Delete(int value) { Node* toDelete = Search(value); if (toDelete == nullptr) { cout &lt;&lt; &quot;return for value == null&quot; &lt;&lt; endl; return; } toDelete-&gt;prev-&gt;next = toDelete-&gt;next; toDelete-&gt;next-&gt;prev = toDelete-&gt;prev; free(toDelete); } Node* Search(int value) { Node* node = sentials-&gt;next; while (node-&gt;value != value &amp;&amp; node-&gt;next != sentials) { node = node-&gt;next; } return node-&gt;value == value ? node : nullptr; } void Print() { Node* node = sentials-&gt;next; while (node != sentials) { cout &lt;&lt; &quot;value is &quot; &lt;&lt; node-&gt;value &lt;&lt; endl; node = node-&gt;next; } }private: Node* sentials;}; Implementing pointers and objects 在上一节的实现线性列表的过程中，需要用到指针来表示上一个结点或下一个结点。但在某些语言中，并没有提供指针的概念，如C#和Java，这一节介绍了在这些语言中如何来实现列表。 A multiple-array representation of objects 第一种方法是使用三个大小相同的数组来分别表示next，key和prev，如下两图实际上是实现了同一种结构。 图二是将三个数组并排显示的效果，另外有一个变量L来保存列表的第一个结点的索引值，在这里第一个结点的Key值为9，索引值为7，所以L中保存的值为7。 以索引值为7为例，key值为9,next值为5,prev值为/。表示这个结点没有前一个结点，即为头结点，且后一个结点的索引值为5，数组索引值为5的地方，key值为16,next为2，prev为7。以此类推,可得到所有的结点。 A single-array representation of objects 第二种方法是只用一个数组来表示next，key和prev。每一个结点占数组中的三个位置，如一个结点的Key值在数组中的位置A[i]，则next位置为A[i+1],prev位置为A[i+2] 同理，这里仍然需要一个变量L来保存头结点的索引，这里的头结点索引为19，所有头结点的Key值为9，next结点为13，表示下一个结点的从索引值13开始，prev结点为/，表示没有前结点，该结点为头结点。 Allocating and freeing objects 这里以多数组表示法进行说明。为了可以释放和分配结点，我们需要另一个变量free来记录数组的哪个索引值为空结点。我们可以将多个空结点们看作也是一个链表，但是只是一个单链表，只需要知道下一个空结点在哪即可，所以在多数组方法中也仅只需要用到next数组即可。 分配和释放对象的过程如下图所示： 下图中的图(a)即为用多数组方式表示上图的数据，唯一与之前说明不同的是，这里需要一个变量free来表示第一个空结点在哪，这里显示第一个空结点的索引值为4，而在next数组的索引4处，值为8，说明下一个空结点在索引8的地方。 图(b)是插入了一个key值为25的结点。因为之前第一个空结点的位置在索引值为4的地方，所以这个结点现在插入在索引为4的地方。此时行结点成为了头结点，所以变量L值变为4,也因为索引4的地方有了值，所以第一个空结点变成之前的第一个空结点中保存的索引值的地方，即索引值为8的地方，因此free变量变为8. 图©是删除了key值为16的结点，该结点在索引值为5的地方。删除后，将他作为空结点插入空结点链表，即第一个空结点为索引值为5的地方，所以变量free值为5。且第一个空结点的next需要指向下一个空姐点，即索引值为8的地方。 多数组方法中，分配和删除的伪代码如下 1234567891011121314ALLOCATE-OBJECT()if free == NULL error &quot;out of free&quot;else x=free; free=x.next return xFREE-OBJECT()x.next=free;free=x; 这两步操作的复杂度都为O(1) 另外多个链表可以共用同三个数组，且共用一个free链表，如下图所示。存在两个链表，分别以$L_2$和$L_1$作为头结点。 Representing rooted trees 可以用表示链表的方法可以用在其他的类似的数据结构中，这一节将用列表的方法来表示有根树形结构。树的每一个结点都作为对象，如链表一样，结点中也有一个类似与Key值的存在，不同的是根据树的类型不同，结点中的指针会有不同的表示。 Binary Tree 在二叉树中，每个结点都有三个变量$p$，$left$和$right$，分别表示结点的父结点，左子结点和右子结点。如没有左子结点，则left=null，右子结点同理。 二叉树实例图如下： Rooted trees with unbounded branching 对于分支没有限制的有根树，可以使用变量$child_1$，$child_2$，$child_3$…来替代$left$和$right$。 但是这种方法存在一个弊端，首先如果子结点的个数没有限制，那我们无法预先直到该为每个结点分配多少的子结点。其次如果我们用一个非常大的数值来作为子结点的个数，在多数结点的子结点个数都小于这个设定数值时，就会造成很严重的内存浪费。 但是可以通过左孩子和右兄弟表示法(left-child,right-sibling representation)来解决这种情况，x.left-child表示所有子结点中，最靠左的那一个，x.right-sibling表示同级的结点中，最靠近x结点右边的那一个。 分支无限制有根树实例图如下 引用： Introduction to Algorithms 3rd Sep.2009","link":"/IA-Chapter10-Notes/"},{"title":"《算法导论》 第十二章笔记","text":"《算法导论》 第十二章笔记，线性二叉树的实现。 12.4节尚未整理 Chapter 12. Binary Search Trees 搜索树(Search tree)结构支持许多动态数组的操作，包括SEARCH，MINIMUM，MAXIMUM，PREDESCESSOR，SUCESSOR，INSERT和DELETE。 对于一个有$n$个结点的完全二叉树，这些操作在最坏情况下的时间复杂度应该为$\\Theta(n)$，而如果是一个随机建立的二叉树，复杂度应该为$\\Theta(\\lg n)$ What is a binary search tree? 二叉搜索树的每一个结点（下使用x来表示）都包含一个$key$值以及三个指针$p$、$left$和$right$分别表示结点的父结点，左子结点和右子结点。 对于一个二叉搜索树而言，一个结点的所有左子结点一定小于等于该结点值，结点的所有右子结点一定大于等于该结点值。 大部分搜索树的操作都与树的高度有关，下图是两个搜索二叉树的情况： 可以看到两个树都有8个结点，但(a)中的树较为平衡，树的深度较低，(b)树则很不平衡都集中在了右树上，树的深度较深。 二叉搜索树可以通过简单的递归按顺序打印出所有结点的数值，称为中序树遍历(inorder tree walk)，这个方法是先打印左树的值，再打印中间结点的值，最后打印右树的值。同理，还有前序树遍历(preorder tree walk)和后序树遍历(postorder tree walk)。 中序树遍历的伪代码如下 123456INORDER-TREE-WALK(x)if x!=NULL INORDER-TREE-WALK(x.left) print x.key INORDER-TREE-WALK(x.right) 中序树遍历的时间复杂度为$\\Theta(n)$。 证明如下：首先因为中序遍历需要访问所有n个结点，所以时间复杂度最少为$\\Omega(n)$，所以只要证明时间复杂度为$T(n)=O(n)$即能满足情况。 在空树的情况下，因为需要判断x!=null，所以也是存在一些时间花费的，以$T(0)=c$来表示。设左树有$k$个结点，则右树有$n-k-1$个结点，那么遍历时间可表达为$T(n)\\leq T(k) + T(n-k+1) +d$。这个$d$表示是一个常数，用来控制右式为遍历时间的上限。 后面我们可以通过4.3节中的替代法来证明，为了证明$T(n)=O(n)$，假设$T(n)\\leq (c+d)n+c$。对于$n=0$,$(c+d)0+c=c=T(n)$，满足情况，对于$n&gt;0$来说 $$ T(n)\\leq T(k) + T(n-k+1) +d \\\\ =( (c+d)k + c ) + ( (c+d)(n-k-1) +c ) +d \\\\ =c + (c+d)n -(c+d) +c +d\\\\ =(c+d)n +c $$ 满足猜测，所以证明得$T(n)=O(n)$。因此结合$T(n)=\\Omega(n)$可得$T(n)=\\Theta(n)$ Querying a binary search tree 二叉树的一系列操作，如MINIMUM，MAXIMUM,SUCCESSOR,PREDECESSOR的时间复杂度都与树的高度有关，对一个高度为$h$的数，这些操作的复杂度为$O(h)$ Searching 根据二叉搜索树的特性，我们只要判断目标值是否与当前值相同，如果相同则返回当前节点，如果小于则在当前节点的左树搜索，否则在右树搜索 搜索递归伪代码 123456789TREE-SEARCH(x,k)if x==NULL or k==x.key return xif k &lt; x.key return TREE-SEARCH(x.left,k)return TREE-SEARCH(x.right,k) 这个递归代码也可以通过循环方式来写，通常来说通过循环迭代方法实现的效率更高，因为少了函数的压栈与出栈操作。 12345678910111213TREE-SEARCH(x,k)while(x != NULl and k != x.key){ if k &lt; x.key x = x.left else x= x.right}return x 两种方法的C++实现如下 1234567891011121314151617181920TreeNode* BinarySearchTree::Search(TreeNode* rootNode, int value){ if (rootNode == nullptr || rootNode-&gt;value == value) return rootNode; return value &lt; rootNode-&gt;value ? Search(rootNode-&gt;leftChild, value) : Search(rootNode-&gt;rightChild, value);}TreeNode* BinarySearchTree::Search(TreeNode* rootNode, int value){ while (rootNode != nullptr &amp;&amp; rootNode-&gt;value != value) { if (value &lt; rootNode-&gt;value) rootNode = rootNode-&gt;leftChild; else rootNode = rootNode-&gt;rightChild; } return rootNode;} Minimum and Maximum 最大最小值的获取很简单，找到最左的节点即为最小值，找到最右的节点即为最大值，伪代码如下 12345678910111213TREE-MINIMUM(x)while x.left != NULL x = x.leftreturn xTREE-MAXIMUM(x)while x.right !=NULL x = x.rightreturn x c++ 实现如下 1234567891011121314151617181920212223242526272829TreeNode* BinarySearchTree::Maximum(TreeNode* node){ if (node == nullptr) { cout &lt;&lt; &quot;Tree is empty&quot;; return nullptr; } while (node-&gt;rightChild != nullptr) { node = node-&gt;rightChild; } return node;}TreeNode* BinarySearchTree::Minimum(TreeNode* node){ if (node == nullptr) { cout &lt;&lt; &quot;Tree is empty&quot;; return nullptr; } while (node-&gt;leftChild != nullptr) { node = node-&gt;leftChild; } return node;} Successor and predecessor Successor函数是找比当前结点值大的所有结点中，最小的一个 Predecessor函数值找比当前结点值小的所有结点中，最大的一个 Successor算法的思路是： （1） 如果一个节点的右子树不为空，那么右子树中的最小值即为比当前结点值刚好大的节点。 （2） 如果右子树为空，则需要从父节点中找寻比自己刚好大的节点，使用x.p遍历逐渐向上寻找祖先节点，直到遇到第一个祖先结点让当前结点或当前节点的祖先是它的左子树，这个父结点就是刚好大的节点。如下图中，我们以结点13为例子，7是13的父节点，但13是是它的右子树，所以不满足。继续向上找到6结点，但结点7是结点6的右子树，所以仍然不满足。再向上找到结点15，结点6是他的左子树，所以满足条件。即15为节点13的Successoor。 Predecessor算法的思路可以看出是Successor的镜像，即 （1） 如果一个节点的左子树不为空，那么左子树中的最大值即为比当前结点值刚好小的节点。 （2） 如果左子树为空，则需要从父节点中找寻比自己刚好小的节点，使用x.p遍历逐渐向上寻找祖先节点，直到遇到第一个祖先结点让当前结点或当前节点的祖先是它的右子树，这个父结点就是刚好小的节点。 Successor和Predecessor伪代码 123456789101112131415161718192021222324252627TREE-SUCCESSOR(x)if x.right != NULL return TREE-MINIMUM(x.right)y = x.pwhile( y != NULL &amp;&amp; x == y.right ) x = y; y = y.p;return y;TREE-PREDECESSOR(x)if x.left != NULL return TREE-MAXIMUM(x.left)y = x.pwhile( y != NULL &amp;&amp; x == y.left ) x = y; y = y.p;return y; c++实现如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445BSTreeNode* BinarySearchTree::Successor(int value){ BSTreeNode* node = Search(root, value); if (node == nullptr) { cout &lt;&lt; &quot;Can't find node with &quot; &lt;&lt; value &lt;&lt; endl; return nullptr; } if (node-&gt;rightChild != nullptr) return Minimum(node-&gt;rightChild); BSTreeNode* nodeParent = node-&gt;parent; while (nodeParent != nullptr &amp;&amp; node == nodeParent-&gt;rightChild) { node = nodeParent; nodeParent = node-&gt;parent; } return nodeParent;}BSTreeNode* BinarySearchTree::Predecessor(int value){ BSTreeNode* node = Search(root, value); if (node == nullptr) { cout &lt;&lt; &quot;Can't find node with &quot; &lt;&lt; value &lt;&lt; endl; return nullptr; } if (node-&gt;leftChild != nullptr) return Maximum(node-&gt;leftChild); BSTreeNode* nodeParent = node-&gt;parent; while (nodeParent != nullptr &amp;&amp; node == nodeParent-&gt;leftChild) { node = nodeParent; nodeParent = node-&gt;parent; } return nodeParent;} 可以看到，无论是Search,Minimum,Maximum,Successor,Predecessor，在最坏的情况下，都是遍历树的每一层，所以时间复杂度为$O(h)$ Insertion and deletion 二叉搜索树的插入和删除操作都需要保证改变的结点不会影响二叉搜索树的特性。 Insertion 插入算法的思想是用一个变量（伪代码中是变量$x$）来找寻插入结点(伪代码中被插入结点为$z$)的位置，用另一个变量（伪代码中为$y$）来记录第一个变量的父节点。 123456789101112131415161718192021TREE-INSERT(T,z)//T-&gt;被插入树，z-&gt;需要插入的结点y = NULLx = T.root//出循环时，X为空，即为z将要插入的位置，y是x的父节点while x != NULL y = x if z.key &lt; x.key x = x.left else x = x.rightz.p = y;if (y == NULL) T.root = z;else if ( z.key &lt; y.key) y.left = zelse y.right = z c++实现为： 1234567891011121314151617181920212223242526272829void BinarySearchTree::Insert(int value){ BSTreeNode* node = (BSTreeNode*)malloc(sizeof(BSTreeNode)); node-&gt;value = value; node-&gt;leftChild = nullptr; node-&gt;rightChild = nullptr; BSTreeNode* target = root; BSTreeNode* targetParent = nullptr; while (target != nullptr) { targetParent = target; target = value &lt; target-&gt;value ? target-&gt;leftChild : target-&gt;rightChild; } if (targetParent == nullptr) { root = node; return; } if (value &lt; targetParent-&gt;value) targetParent-&gt;leftChild = node; else targetParent-&gt;rightChild = node; node-&gt;parent = targetParent;} 插入算法需要从上到下遍历整棵树，所以时间复杂度为$O(h)$ Delete 删除操作相比插入操作更复杂一些，需要考虑三种情况。将需要删除的结点称为$z$ $z$没有子结点 可直接删除 $z$只有一个子结点 用存在的节点替换$z$ $z$有两个子结点 找到$z$的Successor，这里称为$y$，然后需要再细分为两种情况讨论。 注意这两种情况下$y$的左树不需要管，因为左树必然为空，否则Successor将出现在$y$的左树中。 (1) $y$是$z$的右子节点 用$y$替换$z$ (2) $y$不是$z$的右子节点 用$y$的右树替换$y$的位置。将$z$的右树作为$y$的右树，再用$y$替换$z$ 因为$z$有两个子节点，所以Successor必然是$z$右子树中的最小值 删除的示意图如下，其中图(a)(b)表示$z$只有一个子结点的情况，©(d)表示存在两个子结点的情况，其中©表示$y$即为$z$的右子树，(d)表示$y$不是$z$的右子树。 $z$没有子结点的情况，也可以用(a)(b)表示，即将存在的结点看作为空。 在实现DELETE算法前，需要先实现被反复用到的替换算法，伪代码如下 123456789101112//u为被替换节点，v为替换节点TRANSPLANT(T,u,v)if u.p == NULL //将v设为u的parnet的新子节点 T.root = v;else if u == u.p.left u.p.left = velse u.p.right = vif v != NULL //将v的parent设为u的parent v.p = u.p c++实现如下 123456789101112void BinarySearchTree::transplant(BSTreeNode* originNode, BSTreeNode* newNode){ if (originNode-&gt;parent == nullptr) root = newNode; else if (originNode == originNode-&gt;parent-&gt;leftChild) originNode-&gt;parent-&gt;leftChild = newNode; else originNode-&gt;parent-&gt;rightChild = newNode; if (newNode != nullptr) newNode-&gt;parent = originNode-&gt;parent;} 注意TRANSPART算法并没有处理u的子结点。替换后u的子节点处于没有追踪的状态 Delete算法的伪代码如下 123456789101112131415TREE-DELETE(T,z)if z.left == NULL //只有一种节点的情况，用另一个节点替换z TRANSPLANT(T , z , z.right)else if z.right == NULL //只有一种节点的情况，用另一个节点替换z TRANSPLANT(T , z , z.left)else y = MINIMUM(y.right) //求得Successor if y.p != z // y不是z的右子树的情况， TRANSPLANT(T, y, y.right) //y的右子树替换y的位置 y.right = z.right //z的右子树作为y的右子树 y.right.p = y TRANSPLANT(T,z,y) //用y替换z y.left = z.left //TRANSPLANT算法并没有处理z的子树情况，所以这里需要处理 y.left.p = y c++代码实现如下 1234567891011121314151617181920212223242526272829303132333435void BinarySearchTree::Delete(int value){ BSTreeNode* toDeleteNode = Search(root, value); if (toDeleteNode == nullptr) { //cout &lt;&lt; &quot;There is no node with value &quot; &lt;&lt; value &lt;&lt; endl; return; } if (toDeleteNode-&gt;leftChild == nullptr) transplant(toDeleteNode, toDeleteNode-&gt;rightChild); else if (toDeleteNode-&gt;rightChild == nullptr) transplant(toDeleteNode, toDeleteNode-&gt;leftChild); else { BSTreeNode* successorNode = Minimum(toDeleteNode-&gt;rightChild); if (successorNode-&gt;parent != toDeleteNode) { transplant(successorNode, successorNode-&gt;rightChild); //Handle toDeleteNode's right child //因为successorNode不是toDelete的子节点，所以toDeleteNode的右节点一定比他大，所以作为它的右子树。 successorNode-&gt;rightChild = toDeleteNode-&gt;rightChild; toDeleteNode-&gt;rightChild-&gt;parent = successorNode; } transplant(toDeleteNode, successorNode); //Handle toDeleteNode's left child successorNode-&gt;leftChild = toDeleteNode-&gt;leftChild; toDeleteNode-&gt;leftChild-&gt;parent = successorNode; free(toDeleteNode); }} 删除操作算法并不存在循环，所以大部分操作都是固定时间，除了用来找Successor的MINIMUM算法，因为MINIMUM算法的复杂度为$O(h)$，所以删除算法的复杂度也为$O(h)$ Randomly built binary search trees //TODO 引用： Introduction to Algorithms 3rd Sep.2009","link":"/IA-Chapter12-Notes/"},{"title":"《算法导论》 第三章笔记","text":"《算法导论》 第三章笔记，包括时间复杂度符号即一些基本的数学公式 Chapter 3. Growth of Functions Asymptotic notation Asymptotic notation,functions,and running time 书中所有的渐进符号都是用来用来表达算法的运算时间的，虽然渐进符号也能用来表示算法的其他资源，如内存，硬盘空间等。 $\\Theta$-notation 在第二章中，描述插入算法的最坏情况下$T(n)=\\Theta(n^2)$，但没有详细解释$\\Theta$含义， 这一节给出了定义。 对函数$f(n)$，如果存在常数$c_1$，$c_2$和$n_0$使得对于任意$n\\geq n_0$，满足 $$ 0\\leq c_1g(n)\\leq f(n) \\leq c_2g(n) $$ 则称$f(n)=\\Theta(g(n))$，$g(n)$称为$f(b)$的渐进紧确界，函数下图表示 注意$\\Theta(g(n))$实际上是一系列函数的集合，所以严格意义上来说应该表达为$f(n)\\in \\Theta(g(n))$，但在书中为了表达方便，都写为$f(n)=\\Theta(g(n))$ 这里的所有函数都约定为非负的 数学证明如下： 如我们要证明函数$\\frac{1}{2}n^2-3n=\\Theta(n^2)$，那么按定义，应该证明 $$ 0\\leq c_1n^2\\leq \\frac{1}{2}n^2-3n \\leq c_2n^2 $$ 不等式各边都除去$n^2$，得到 $$ c_1 \\leq \\frac{1}{2}-\\frac{3}{n} \\leq c_2 $$ 那么当$n$足够大时（大于$n_0$）,则逼近于$c_1 \\leq \\frac{1}{2}\\leq c_2$，明显可以可以找到$c_1$和$c_2$满足该不等式是。这里的$c_1$和$c_2$取值可以有无数种组合。 $O$-notation $O$标记表示渐进上边界，定义为对函数$f(n)$，如果存在常数$c$和$n_0$使得对于任意$n\\geq n_0$，满足 $$ 0\\leq f(n) \\leq cg(n) $$ 函数图如下： 因为$O$标记定义的表达式实际上是$\\Theta$标记表达式的一部分，所以可以用同样的方法证明$O$标记的合理性。 要注意的是，按照定义，$O$标记仅仅是定义了上边界，而没有具体的确认这个边界与原函数需要多么的紧密。如$n=O(n^2)$仍然也是成立的，即使对于函数$f(n)=n$来说，紧密的上边界应该为$O(n)$。 也正是因为如此，对于算法来说，无论输入情况是什么样的，都可以用$O$标记来描述。以插入函数举例：我们针对插入函数的最差输入情况（每次插入的数都需要插入到已有列表的第一个），紧密上边界表达式为$O(n^2)$；对于最佳输入情况（每次插入的数都可直接插入已有列表的最后），紧密的上边界应该表达为$O(n)$，但是表达式$O(n^2)$按定义仍然是可以用来描述最好情况的。 而渐进紧确界$\\Theta$则不满足上述情况，在插入算法中，最坏和最好情况下，表达式分别为$\\Theta(n^2)$和$\\Theta(n)$。这里不同的是$\\Theta(n^2)$不能用于描述最好情况，因为你无法找到一个常量$c$，在$n$足够大的情况下，仍然满足$n^2&lt;cn$。 $\\Omega$-notation $\\Omega$标记提供了符号渐进下边界，定义为存在常数$c$和$n_0$使得对于任意$n\\geq n_0$，满足 $$ 0\\leq cg(n)\\leq f(n) $$ 函数图像如下： $\\Omega$标记的证明与$\\Theta$类似，且与$O$一样都能描述算法的任何输入。只不过$\\Omega$关注的是算法的最好情况，$O$关注的是算法的最差情况，所以通常我们对于$O$的使用较多。 定理3.1： 对任意两个函数$f(n)$和$g(n)$，当且仅当$f(n)=O(g(n)$和$f(n)=\\Omega(g(n))$时，存在$f(n)=\\Theta(g(n))$ Asymoptotic notation in equations and inequalities 在书中，有时会在表达式和不等式中用渐进表达式来省去一些不关注的细节，如表达式$2n^2+3n+1=2n^2+\\Theta(n)$表示$2n^2+3n+1=2n^2+f(n)$，其中$f(n)\\in \\Theta(n)$ $o$-notation 如之前在$O$标记一节中描述的，$O$标记可以表示紧密上边界和非紧密上边界，如对于函数$2n^2$,$O(n^2)$即为紧密上边界，而$O(n^3)$则不是。 这里我们定义$o$标记来单独表示非紧密上边界：对于任意正常量$c$，都存在一个对应的常量$n_0$使得在$n\\geq n_0$时满足 $$ 0\\leq f(n) &lt; cg(n) $$ 则称$f(n)=o(g(n))$ $o$标记和$O$标记在定义上的区别在于，$O$是存在常量$c$和$n_0$使表达式成立即可，而$o$定义是对于任意常量$c$，都要存在$n_0$使得表达式成立(且表达式为&lt;而非$\\leq$)，例如$2n=o(n^2)$但$2n\\neq o(n)$。如果后者成立，那么当$c$取2时，无论$n_0$取值为多少，都无法满足$f(n)&lt;2n$。 关于$o$标记还有一个等效的定义表达式：因为是$o$标记非紧密的上边界，所以当$n$足够大，$g(n)$会远大于$f(n)$ $$ \\lim_{n\\rightarrow \\infty}\\frac{f(n)}{g(n)}=0 $$ $\\omega$ -notation $\\omega$标记对于$\\Omega$标记就如同$o$标记对于$O$标记。$\\omega$标记的定义为，对于任意正常量$c$，都存在一个对应的常量$n_0$使得在$n\\geq n_0$时满足 $$ 0\\leq cg(n) &lt; f(n) $$ 则称$f(n)=\\omega(g(n))$。例如，$n^2/2=\\omega(n)$但$n^2/2 \\neq \\omega(n^2)$。且同样存在另一个定义。 $$ \\lim_{n\\rightarrow \\infty}\\frac{f(n)}{g(n)}=\\infty $$ $o$标记和$\\omega$标记的关系可以表达为：当且仅当$g(n)\\in o(f(n))$时，$f(n)\\in \\omega(g(n))$ Comparing functions 渐进标记与数学中的不等式有点类似，同样都满足传递法，如a&lt;b，b&lt;c，则a&lt;c。 $f(n)=O(g(n))$ 类似于 $a\\leq b$ $f(n)=\\Omega(g(n))$ 类似于 $a\\geq b$ $f(n)=\\Theta(g(n))$ 类似于 $a= b$ $f(n)=o(g(n))$ 类似于 $a &lt; b$ $f(n)=\\omega(g(n))$ 类似于 $a &gt; b$ 但与不等式不同的是，对于两个数字，关系要么满足大于等于，要么满足小于等于。但对于渐进标记，存在两个函数$f(n)$和$g(n)$，可能即不满足$f(n)=O(g(n))$，也不满足$f(n)=\\Omega(g(n))$，如函数$n$与$n^{1+\\sin n}$，因为$n^{1+\\sin n}$的次幂始终在变化，在0-2之间摇摆。 Standard notations and common functions 这一节主要是介绍一些数学内容，这里只列出关键的结论，定理和公式，并没有完整证明。 Floors and ceilings（向上取整与向下取整） 一些定理及公式 $$\\lceil n/2 \\rceil + \\lfloor n/2 \\rfloor = n$$ $$ \\lceil \\frac{\\lceil x/a \\rceil}{b} \\rceil = \\lceil \\frac{x}{ab} \\rceil$$ $$ \\lfloor \\frac{\\lfloor x/a \\rfloor}{b} \\rfloor = \\lfloor \\frac{x}{ab} \\rfloor$$ $$ \\lceil \\frac{a}{b} \\rceil \\leq \\frac{a+(b-1)}{b} $$ $$ \\lfloor \\frac{a}{b} \\rfloor \\geq \\frac{a-(b-1)}{b} $$ Modular arithmetic（求余） $$ a mod n =a -n\\lfloor a/n \\rfloor$$ 如果存在$(a mod n ) = (b mod n)$，可写作$a\\equiv b \\text { (mod n)}$ Polunomials(多项式) 对于某个常量$k$，如果有$f(n)=O(n^k)$则称函数$f(n)$是多项式有界的 Exponentials（指数） $$(a^m)^n=a^{mn}$$ $$(a^m)+a^n=a^{m+n}$$ 对所有实数有， $$ e^x=\\sum_{i=0}^{\\infty}\\frac{x^i}{i!} $$ $$ e^x\\geq1+x$$ $$ e^x=\\lim_{n\\rightarrow \\infty}(1+\\frac{x}{n})^n$$ 指数增长速度比多项式快得多，可表达为 $$ \\lim_{n\\rightarrow \\infty}\\frac{n^b}{a^n}=0$$ 用渐进标记，则表达为 $$n^b=o(a^n)$$ Logarithms（对数） $$ \\lg ^kn=(\\lg n)^k$$ $$ a=b^{\\log_ba} $$ $$ \\log_c(ab)=\\log_ca+\\log_cb$$ $$ \\log_ba^n=n\\log_ba$$ $$ \\log_ba= \\frac{\\log_ca}{\\log_cb} $$ $$ \\log_b(1/a)=-\\log_ba$$ $$ \\log_ba=\\frac{1}{\\log_ab}$$ $$ a^{\\log_bc}=c^{\\log_ba}$$ 如果满足$f(n)=O(\\lg^kn)$，则称$f(n)$是多对数有界的。 多项式的增长速度比对数快得多，可以表达为 $$ \\lim_{n\\rightarrow \\infty}\\frac{\\lg^bn}{n^a}=0$$ 用渐进标记，则表达为 $$\\lg^bn=o(n^a)$$ Factorials(阶乘) $$n!\\leq n^n \\text{ 即 }n!=o(n^n)$$ $$ n!=\\omega 2^n$$ $$ \\lg(n^!)=\\Theta(n\\lg n)$$ Functional iteration (多重函数) 可看作是函数的递归嵌套，递归次数用括号包裹的次幂表示，如$f^{(i)}(n)$，表示递归$i$次 $$ f^{(i)}(n)= \\begin{cases} n &amp; \\text{if }i=0 \\\\ f(f^{(i-1)}(n)) &amp; \\text{if } i &gt;0 \\end{cases} $$ 如函数$f(n)=2n$，$f^{(i)}(n)=2^in$ 注意区分$\\lg^in$与$\\lg^{(i)}n$，前者是$\\lg n$的$i$次幂，后者是对$n$连续使用$i$次对数函数。 The iterated logarithm function (多重对数函数) 使用$lg*n$表示多重对数函数，定义为 $$ \\lg^*n=min{i\\geq 0:lg^{(i)}n\\leq 1} $$ 意思是求得最小的可以满足$lg^{(i)}n\\leq 1$的$i$是多少 如$lg^*16=3$、$lg^*65536=4$，因为 $$\\log_216=4 \\rightarrow \\log_24=2 \\rightarrow \\log_22=1$$ $$\\log_265536=16 \\rightarrow \\log_216=4 \\rightarrow \\log_24=2 \\rightarrow \\log_22=1$$ 即分别需要三次和四次运算才能满足条件。 斐波那契数列 斐波那契数列定义为： $$F_0=0$$ $$F_1=1$$ $$F_i=F_{i-1}+F_{i-2} $$ 还有一个定义 $$ F_i=\\frac{\\phi ^ i - \\hat{\\phi}^i}{\\sqrt{5}} $$ 其中$\\phi$和$\\hat{\\phi}$为方程$x^2=x+1$的两个解。 斐波那契数列以指数速率增长。 引用： Introduction to Algorithms 3rd Sep.2009","link":"/IA-Chapter3-Notes/"},{"title":"《算法导论》 第十七章笔记","text":"《算法导论》 第十七章笔记，关于平摊分析。 第17.4节尚未整理 Chapter 17 Amortized Analysis 平摊算法是计算一系列对数据结构的操作的平均时间，平摊算法分析保证了最坏情况下每个操作的平均性能。 这一节中会首先介绍三个平摊分析的方法： 17.1节介绍聚集分析，这个分析可以知道N个操作的累计花费时间的上限。 17.2节介绍记账方法，这个分析可以知道N个操作中，不同类型的操作的平均花费。 17.3节介绍势能方法，这个分许也可以知道N个操作中，不同类型的操作的平均花费。 势能方法与记账方法不同的是，记账操作是对每一个操作进行分析，如有的操作计算的时间比实际要花的时间更长，这些称之为预付，而有些操作计算的时间比实际时间更短，这些操作就是在使用之前的预付。而势能方法本质上也是预付和使用预付，但他的统计是针对于整个一系列操作，而不是针对每个操作，所以在势能方法中的预付是整体的。 Aggregrate analysis 在聚集分析（Aggregrate analysis）中，对一系列（n个）操作在最坏情况下总共花费的时间称为$T(n)$，因此对每个操作的平摊花费（amortized cost）为$T(n)/n$。 Stack operation 以栈操作为例，对于一个栈而言，Push和Pop的操作时间复杂度都是$O(1)$。定义一个新函数$Multipop(S,k)$，该操作会弹出栈上头K个元素，S为需要操作的堆栈，$K$为需要弹出的元素个数。如果栈上的元素数小于$k$，则该操作弹出所有的元素。 如下图所示： MultiPop函数的伪代码如下： 1234MULTIPOP(S,k)while not STACK_EMPTY(S) and k &gt; 0 POP(S) k = k-1 MultiPop函数的时间复杂度与它真正执行的Pop函数数量成线性关系。 如果对栈有n个操作。那么最差情况下，MultiPop的时间复杂度为$O(n)$，即前面所有的操作都是Push，最后调用Multipop时它需要弹出所有的操作。最差情况下n个操作的时间复杂度为$nO(n)=O(n^2)$。尽管$O(n^2)$的确是n个操作的时间上限，但这个上限并不是紧密的。 使用聚合分析可以得到一个更紧密的上限。实际上对于一个栈而言，如果有n个操作，那么pop的数量最多和push一样，即n个操作的时间复杂度总和为$O(n)$，因此每个操作的平摊花费为$O(n)/n$。在聚合分析分析中，不关心不同类型的操作，因此将每个操作的平摊花费定义为$O(n)/n$即$O(1)$。 Incrementing a binary counter 这里举另外一个例子来讨论聚合分析。如使用一个二进制数的数组来做计数器，将数组命名为A，设数组中一共有k个元素，将A[0]定义为最低位，将A[k-1]定义为最高位。整个数组表示一个十进制数，则这个数的值为$x=\\sum^{k-1}_{i=0}A[i]\\dot{2^i}$。 Increment(A)的伪代码如下： 123456i = 0;while i &lt; A.length and A[i] == 1 A[i] = 0; i++if i &lt; A.length A[i] = 1 While循环中处理的是进位问题，从最低位开始，如果是1则将其变为0（进位），直到发现某一位是0（出循环）后加1。所以Increment函数的时间复杂度与翻转（1变0或0变1）的位数有关。 在最坏的情况下，加1前，数组中的每个元素都是1，因此所有的元素值都需要反转（1变0，这种情况下是超过了数组所能累加的上线）。这种情况下时间复杂度为$O(k)$。一系列有n个操作，所以总体时间复杂度为$O(nk)$。但这样分析出来的时间复杂度同样也是不紧密的。 下图，展示了累加时数组每一位的变化情况。 可以看到，A[0]每次操作都发生变化，A[1]每两次操作发生变化，A[2]每四次操作发生变化…A[i]每$2^i$次操作发生变化。所以对于n次操作而言，A[i]发生了$n/2^i$次变化。因此，从第0位到第k-1位，反转的总计为： $$ \\sum_{i=0}^{k-1}\\lfloor \\frac{n}{2^i} \\rfloor \\\\ &lt; n \\sum_{i=0}^{\\infty}\\frac{1}{2^i} \\\\ =2n $$ 因此，整个操作的时间复杂度为$O(n)$，每个操作的平摊花费为$O(n)/n=O(1)$ The accounting method 记账方法（Accounting method），对不同的操作计算不同的时间，这个时间称为平摊花费(amortized cost)。如果某一个操作，计算的时间大于其真实的运行时间，对于操作的对象，存放一个特殊的数据称为credit。 对于一系列n个操作，操作平摊花费的累加是要大于等于操作真实花费的累加，这样平摊花费的总和才能表示一系列操作的时间上限。 $$ \\sum_{i=1}^{n}\\hat{c_i}\\geq\\sum_{i=1}^{n} c_i $$ 所有操作的credit总和即为$\\sum_{i=1}^{n} \\hat{c_i} - \\sum_{i=1}^{n} c_i$。为了保证平摊花费的总和代表上限，这个值必须是非负的。 Stack Operations 操作 真实花费 平摊花费 Push 1 2 Pop 1 0 MultiPop min(k,s) 0 其中$min(k,s)$中，$k$表示Multipop传入的$k$值，$s$表示目标数组的大小。 可以看到对于Push操作，平摊花费比真实花费要多1，这个1即使credit。即栈中的每个元素都有一个值为1的credit，之后的Pop操作和Multipop操作平摊花费都为0，相当于是使用一个credit。因为在Pop前都必须调用了相应数量的Push，所以总和的credit永远不会小于0 因此对于一系列n个操作而言，其总共的平摊花费也是$O(n)$。 Incrementing a binary counter 如之前所述，Increment函数的时间复杂度与翻转（1变0或0变1）的位数有关。实际上无论是从0变成1，还是从1变成0，其真实花费都是1。但是在这里认为对从0变成1，平摊花费为2，对与从1变成0，平摊花费为0。因为如果进行从1变为0的操作，这一位在之前一定经历过从0变为1，所以总和的credit也永远不会小于0。 因此对于n个Increment操作，其总平摊花费为$O(n)$。 The potential method 势能方法（potential method）中势能是对整个一系列操作而言的，即一些操作会增加整体势能，而一些操作会减少整体的势能。 我们假设数据$D_{i-1}$在进行了第$i$个操作后，变为了数据$D_{i}$，其中第$i$个操作的真实花费为$c_i$，数据$D_{i}$的势能为$\\Phi(D_{i})$，数据$D_{i-1}$的势能为$\\Phi(D_{i-1})$。定义第$i$个操作的平摊花费为 $$ \\hat{c_i} = c_i + \\Phi(D_{i})-\\Phi(D_{i-1}) $$ 即真实的操作花费加上势能的变化，这个变化可能是正数，也可能是负数。 那么对于一系列操作而言，其总体的平均花费为 $$ \\sum_{i=0}^{n} \\hat{c_i} \\\\ =\\sum_{i=0}^{n}(c_i+\\Phi(D_{i})-\\Phi(D_{i-1})) \\\\ =\\sum_{i=0}^{n}c_i + \\Phi(D_{n}) - \\Phi(D_{0}) $$ 为了平均花费的总和是真实花费总和的上界限，必须保证$\\Phi(D_{n})\\geq \\Phi(D_{0})$。在实际中，并不能知道$n$的值是多少，所以我们要保证$\\Phi(D_{i})\\geq \\Phi(D_{0})$。 为了满足这个式子，经常在定义势能函数时保证，$\\Phi(D_{0})=0$而且$\\Phi(D_{i})\\geq0$。 势能分析的关键在于定义势能的计算函数。 Stack Operation 在栈操作中，定义势能函数为栈中元素的个数，则对于Push操作，操作后势能的变化为 $$ \\Phi(D_{i})- \\Phi(D_{i-1})\\\\ (s+1) -s \\\\ =1 $$ 因此Push操作的平摊花费为 $$ \\hat{c_i} = c_i + \\Phi(D_{i})-\\Phi(D_{i-1})\\\\ = 1 +1 \\\\ =2 $$ 而对于Multipop函数而言，操作后的势能变化为 $$ \\Phi(D_{i})- \\Phi(D_{i-1})\\\\ =(s-k^{‘}) -s \\\\ =-k^{’} $$ 其中$k^{'}$为$min(k,s)$。因此Multipop的平摊花费为 $$ \\hat{c_i} = c_i + \\Phi(D_{i})-\\Phi(D_{i-1})\\\\ = k^{‘} -k^{’} \\\\ =0 $$ 同理可证明$\\hat{c_i}=0$，因此三个操作的均摊时间复杂度都是$O(1)$，总体的均摊时间复杂度为$O(n)$。 Incrementing a binary counter 这里，定义势能为操作后数组中值为1的元素数，表达为$b_i$。假设第$i$个操作，把$t_i$位从1变为0，其真实花费最多为$t_i+1$，即再加上一个退出循环后的从0到1的操作（也可能在退出循环后，已经大于了数组的边界，也就不会有从0到1的操作了）。 如果操作后$b_i$=0，说明上一个累加操作时超越了边界的，即操作前整个数组都是1，进行了$k$个从1到0，k为数组长度，即$b_{i-1}=t_i=k$。如果操作后$b_i&gt;0$，则$b_i=b_{i-1}-t_i+1$，总之$b_i\\leq b_{i-1}-t_i+1$。 因此势能的变化为: $$ \\Phi(D_{i})- \\Phi(D_{i-1})\\\\ \\leq (b_{i-1}-t_i+1) - b_{i-1}\\\\ =1-t_i $$ 平摊花费为 $$ \\hat{c_i} = c_i + \\Phi(D_{i})-\\Phi(D_{i-1})\\\\ \\leq t_i +1 +1 - t_i \\\\ =2 $$ 如果计数器从0开始，即$\\Phi(D_{0})=0$，且有$\\Phi(D_{i})\\geq 0$，因此一系列n个操作的总共平摊时间复杂度为$O(n)$。 如果计数器不是从0开始，一开始有$b_0$个1，最后有$b_n$个1，这两个数满足$0\\leq b_0$和$b_n \\leq k$。势能方法的表达式可变形为： $$ \\sum_{i=0}^{n}c_i \\\\ =\\sum_{i=0}^{n}\\hat{c_i}-\\Phi(D_{n})+\\Phi(D_{0}) $$ 因为已经证明了$\\hat{c_i} \\leq 2$，所以可得 $$ \\sum_{i=0}^{n}c_i \\leq 2n-b_n+b_o $$ 所以实际操作的总体花费复杂度为$O(n)$。 引用： Introduction to Algorithms 3rd Sep.2009","link":"/IA-Chapter17-Notes/"},{"title":"《算法导论》 第十三章笔记","text":"《算法导论》 第十三章笔记 红黑树实现 Chapter 13. Red-Black Trees 红黑树是众多让二叉搜索树达到平衡的树形结构之一。树达到平衡可以保证动态操作，如删除，插入，搜索等，复杂度都为$O(lgn)$。 Properties of red-black trees 红黑树是一种特殊的二叉搜索树，每个结点需要花费额外一个bit来存储结点的颜色信息，颜色为红或者黑。红黑树保证了整棵树，不会有一个路径是另一个路径的两倍长。 红黑树满足以下五个特性： 所有结点要么是黑要么是红 根节点是黑色的 每个叶子（这里指NULL结点）是黑色的 如果一个结点是红色的，那么他的两个子结点是黑色的（即不会有连续的两层是红） 所有结点到任意叶子的简单路径上（不存在绕行）有相同的黑色结点数 将任意结点到叶子的路径上黑色结点的数目成为黑高(black-height)，表达为$bh(x)$。将一棵树的黑高定义为：根节点到叶子的黑高。 黑高的计算并不包含结点自己。例如，根节点必然是黑色的，但如果一棵树，只有根节点，那么他的黑高是0，因为根节点并不纳入黑高的计算。 用一个哨兵（用T.nil表示）来指代叶子结点（NULL），这样所有的叶子和根节点的父节点都为T.nil。 将除了叶子结点外的所有结点成为内部结点(internal nodes)，否则为外部结点external nodes 定理：一个有$n$个内部结点的红黑树，其高度最多为$2\\lg (n+1)$ 定理证明如下： 首先需要证明定理：对于任意一个结点$x$，至少有$2^{bh(x)}-1$个内部子结点 用推导法证明该定理： (1)如果结点x的高度是0，则x一定是叶子结点。其黑高为0，那么内部子节点为$2^0-1=0$，即0个内部子节点，满足 (2) 如果结点x的高度不为0，且有两个子结点。根据特性5，可以推得如果这个子结点是红色，则这个子结点的黑高为$bh(x)$，如果子结点是黑色，则子结点的黑高为$bh(x)-1$。 因为$x$的黑高为$bh(x)$，如果子结点是黑色的，则这个子结点本身提供了一个黑色结点，所以它的黑高只能为父结点黑高减1，即$bh(x)-1$，反之子结点是红色的，那么这个结点不提供黑色结点，他的黑高和父结点一样，为$bh(x)$ 所以结点$x$至少有 $2*(2^{bh(x)-1}-1) +1$个结点，这里两个子结点的各自内部子结点数计算都取更小的黑高数$bh(x)-1$，式子最后实际上应该是+2的，即$x$的两个子结点，但这里取更小的1，式子计算得$2^{bh(x)}-1$，即满足定理。 根据红黑树的特性4，红色结点的子结点必为黑色。所以红色结点出现最多的情况也只能是红黑相间，红色结点不可能连续出现而黑色结点可以。因此一个节点的黑高数最起码是其高度的一半，即$bh(x)&gt;\\frac{h}{2}$。 结合1和2中得出的结论。1中得出了 $$ n \\geq 2^{bh(x)}-1 $$ 2中得出了 $$ bh(x)&gt;\\frac{h}{2} $$ 所以 $$ n \\geq 2^{bh(x)}-1 \\geq 2^{\\frac{h}{2}} -1 $$ 即 $$ 2^{\\frac{h}{2}} \\leq n+1 $$ 即 $$ h \\leq 2 \\lg (n+1) $$ 得证。 因为一个有$n$个结点的红黑树，其高度$h$最多为$2\\lg (n+1)$，且二叉搜索树的操作时间复杂度都为$O(h)$，所以红黑树操作的时间复杂度为$O(\\lg n)$ Rotations 红黑树的插入和删除操作都可能破坏红黑树特性。为了保证红黑树的特性，可以在两个操作后通过修改结点的颜色，和改变树的部分结构保证其仍然满足红黑树的特性。 通过Rotate操作来修改树的部分结构，这个操作要保证修改树结构的同时不会影响二叉搜索树的特性。Rotate分为leftRotate和rightRotate，因为两个操作基本是镜像的，所以这里只对leftRotate作具体分析。 在对于一个结点$x$进行左旋时，$x$必须含有右子树，将$x$的右子树称为$y$。左旋操作的支点可以看作是$x$和$y$的交界点，左旋操作为：用y替换x的位置，将$y$原先的左子树变为$x$的右子树,将$x$变为$y$的左子树，。 左旋和右旋的示意图如下：从左到右是对于y的右旋，从右到左是对x的左旋 无论是左旋还是右旋，被旋转的节点深度都+1，（变得更靠下） 左旋操作的伪代码如下 123456789101112131415161718192021TREE-ROTATE(T,x)y = x.right;//用y替换x的位置y.p = x.pif( x.p == NULL) T.root = yelse if ( x == x.p.left ) x.p.left = yelse x.p.right = y//将y的左结点变为x的右结点x.right = y.leftif y.left != NULLy.left.p = x//将x作为y的左子树y.left = xx.p = y c++代码的实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041bool RBTree::LeftRotate(RBTreeNode* node){ if (node == nullNode || node-&gt;right == nullNode) { cout &lt;&lt; &quot;Invalid operation: LeftRotate&quot;; return false; } RBTreeNode* lowerRight = node-&gt;right; //lowerRight replace node's place lowerRight-&gt;parent = node-&gt;parent; if (node-&gt;parent == nullNode) { rootNode = lowerRight; nullNode-&gt;right = rootNode; nullNode-&gt;left = rootNode; nullNode-&gt;parent = rootNode; } else if (node == node-&gt;parent-&gt;left) { node-&gt;parent-&gt;left = lowerRight; } else { node-&gt;parent-&gt;right = lowerRight; } //lowerRight's left subtree become node's right subtree node-&gt;right = lowerRight-&gt;left; if (lowerRight-&gt;left != nullNode) { lowerRight-&gt;left-&gt;parent = node; } //node as lowerRight's left subtree node-&gt;parent = lowerRight; lowerRight-&gt;left = node; return true;} 右旋操作与左旋操作对称，只要将左旋操作中的left都换为right,right都换为left即可。 这里直接给出右旋操作的c++代码 1234567891011121314151617181920212223242526272829303132333435363738bool RBTree::RightRotate(RBTreeNode* node){ //As the symmetry of LeftRotate if (node == nullNode || node-&gt;left == nullNode) { return false; } RBTreeNode* lowerLeft = node-&gt;left; lowerLeft-&gt;parent = node-&gt;parent; if (node-&gt;parent == nullNode) { rootNode = lowerLeft; nullNode-&gt;left = rootNode; nullNode-&gt;right = rootNode; nullNode-&gt;parent = rootNode; } else if (node == node-&gt;parent-&gt;right) { node-&gt;parent-&gt;right = lowerLeft; } else { node-&gt;parent-&gt;left = lowerLeft; } node-&gt;left = lowerLeft-&gt;right; if (lowerLeft-&gt;right != nullNode) { lowerLeft-&gt;right-&gt;parent = node; } node-&gt;parent = lowerLeft; lowerLeft-&gt;right = node; return true;} 左旋及右旋操作的时间复杂度都为$O(1)$ Insertion 红黑树插入算法的思想为，先像普通的二叉搜索树一样插入结点，然后调用RB-INSERT-FIXUP函数调整树使其满足红黑树特性。 红黑树插入算法与普通的二叉搜索树插入算法主要有四个区别： 用T.nil替代NULL 将T.nil设为新插入结点的子结点 新插入结点的颜色为红色 这是为了保证性质5。如果新插入的结点设为黑色，那么新结点所在路径黑高则会增加，而另一条路径不变，则违背了性质5）。 插入后，调用RB-INSERT-FIXUP函数 Insert伪代码如下 1234567891011121314151617181920212223RB-INSERT(T,z)z.left = T.nilz.right = T.nilz. color = REDy = T.nilx = T.rootwhile x != T.nil y = x if z.key &lt; x.key x = x.left else x= x.rightz.p = yif y == T.nil T.root = zelse if z.key &lt; y.key y.left = zelse y.right = zRB-INSERT-FIXUP(T,z) c++ 实现如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152bool RBTree::Insert(int value){ RBTreeNode* toInsert = new RBTreeNode(); toInsert-&gt;value = value; toInsert-&gt;color = RED; toInsert-&gt;right = nullNode; toInsert-&gt;left = nullNode; RBTreeNode* targetNode = rootNode; RBTreeNode* targetNodeParent = nullNode; while (targetNode != nullNode) { targetNodeParent = targetNode; if (value &lt; targetNode-&gt;value) { targetNode = targetNode-&gt;left; } else if (value &gt; targetNode-&gt;value) { targetNode = targetNode-&gt;right; } else { return false; } } if (targetNodeParent == nullNode)//Tree is empty { rootNode = toInsert; rootNode-&gt;parent = nullNode; nullNode-&gt;left = rootNode; nullNode-&gt;right = rootNode; nullNode-&gt;parent = rootNode; } else { if (value &lt; targetNodeParent-&gt;value) { targetNodeParent-&gt;left = toInsert; } else { targetNodeParent-&gt;right = toInsert; } toInsert-&gt;parent = targetNodeParent; } InsertFixUp(toInsert); return true;} 后面要解决的问题就是函数RB-INSERT-FIXUP(T,z)的实现，在进入讨论前，需要先明确几点 性质1不可能违背，因为新插入的结点是红色 性质3不可能违背，因为新插入的结点两个叶子设为了黑色 性质5不可能违背，因为新插入的结点为红色，且替换的是原来NULL的地方 可能违背的只有性质2和性质4。 当新插入的结点$z$是根节点时，违背性质2 当新插入的结点父节点是红色时，违背性质4 在每次插入新结点前，树的状态一定是满足红黑树的，这意味着同时性质2和性质4最多被违背一个。 如果违背了性质2，那么说明新插入的$z$是树中唯一的结点，那么不可能违背性质4 如果违背了性质4，那么说明$z$和$z.p$都为红色。$z.p$不可能是根节点，不然在插入$z$前就已经为违背了红黑树特性2，$z.p.p$必然为黑色，否则也是在插入前就违背了性质4。因此违背性质4的情况下，不可能违背性质2。 这里算法更多的是关注违背性质4时的处理方式，因为性质2比较好修复，只要将根节点的颜色改变即可。 RB-INSERT-FIXUP(T,z)算法一共对插入新结点后，可能出现的违背红黑树原则的6种情况进行修复。前三种情况出现在$z.p$是$z.p.p$的左结点，后三种情况是$z.p$是$z.p.p$的右结点。前三种与后三种情况的修复是对称的，将前三种修复时的左旋操作改成右旋操作即为后三种情况的修复。因此这里只关注于前三种情况的讲解。 前三种(z.p = z.p.p.left )情况的区分在于$z$的$uncle$的颜色，即$z.p.p.right$的颜色。 如果$z.p.p.right$为红色，无论$z$是$z.p$的哪科子树，都为情况1。 如果$z.p.p.right$为黑色，且$z$是$z.p$是右子树，则为情况2。 如果$z.p.p.right$为黑色，且$z$是$z.p$是左子树，则为情况3。 对于情况1的修复： 如图示，$z$为红色，$z.p$和$z.uncle$都是红色。情况1的修复步骤为： 将$z.p$和$z.uncle$都变为黑色 这样违背性质4的连续红色结点就消失了。 将$z.p.p$变为红色 因为$z.p$和$z.uncle$都变成了黑色，所有包含他们的通路，黑高都+1。考虑到包含了$z.p$和$z.uncle$的通路必然都包含$z.p.p$，所以为了保证通路上的黑高不变，将$z.p.p$变为红，这样增加的黑高就弥补了。 将$z$指针指向$z.p.p$ 因为将$z.p.p$变为了红色，所以可能$z.p.p$和$z.p.p.p$会出现违背性质4的情况。将$z$指针指向$z.p.p$即可重新通过RB-INSERT-FIXUP(T,z)算法进行判断。 情况1修复的图解如下： 对于情况2、3的修复： 在情况2和3下，$z.uncle$是黑色，因此$z.uncle$和$z.p$的颜色不同，也就不能像情况1的修复一样统一改成黑色，不然会影响他们子树的黑高。因此这两种情况需要用到旋转来修复。 情况2下$z$作为$z.p$的右子树，因此可以对$z.p$进行左旋。于$z.p$进行左旋后，将原先$z.p$定义为$z$即转换为了情况3，如下图所示 对于情况3，我们对$z.p.p$，即上图中的$C$进行右旋。旋转后如下图所示。 可以看到路径存在$A$结点的树的黑高都减一（原先父结点是黑色的$C$,现在变成了红色的$B$），而包含$C$结点的路径黑高是不变的。而且此时$A$和$B$还是不满足性质4。这里再将原先的$B$调整为黑色，原先的$C$调整为红色。对于包含$A$的路径而言，黑高+1，对于包含$C$的路径而言，黑高不变，因为路径上一个结点变成了红，一个结点变成了黑。因此情况三的最终变化如下： 情况3调整后性质4和5都满足了，而不像情况1调整后仍然可能存在违背性质4的可能。 另外对于情况2和3的处理，不能是情况3通过右旋$z.p$来转换为情况2再进行修复。因为如果在情况2下对$C$进行右旋，会出现如下情况。 此时满足了性质4，但是包含$\\alpha$结点路径的黑高少了1，如果为了满足性质5将$A$结点和$C$结点调整颜色，那么$C$结点和$B$结点又会违背性质4。 情况4，5，6的调整与情况1，2，3是镜像这里就不复述了。 整个给出RB-INSERT-FIXUP(T,z)的伪代码实现 123456789101112131415161718192021RB-INSERT-FIXUP(T,z)while z.p.color == RED if z.p == z.p.p.left // Case 1,2,3 y= z.p.p.right if (y.color == RED) //Case 1 z.p.color = BLACK y.color = BLACK z.p.p.color = RED z = z.p.p else if z == z.p.right //Case 2 z = z.p LEFT-ROTATE(T,z) z.p.color = BLACK // Case 3,下一次循环将直接退出 z.p.p.color = RED RIGHT-ROTATE(T,z.p.p) else //Case 4,5,6 ... //和情况1,2,3类似，将right和left对调即可T.root.color = BLACK //保证性质2 c++代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657void RBTree::InsertFixUp(RBTreeNode* node){ while (node-&gt;parent-&gt;color == RED) { if (node-&gt;parent == node-&gt;parent-&gt;parent-&gt;left)//The first three cases { RBTreeNode* uncle = node-&gt;parent-&gt;parent-&gt;right; if (uncle-&gt;color == RED) //Case 1 { node-&gt;parent-&gt;color = BLACK; uncle-&gt;color = BLACK; node-&gt;parent-&gt;parent-&gt;color = RED; node = node-&gt;parent-&gt;parent; } else { if (node == node-&gt;parent-&gt;right) //Case 2 { node = node-&gt;parent; LeftRotate(node); } //Case3 node-&gt;parent-&gt;color = BLACK; node-&gt;parent-&gt;parent-&gt;color = RED; RightRotate(node-&gt;parent-&gt;parent); } } else { //The remainging three cases, as the symmetry of the first three RBTreeNode* uncle = node-&gt;parent-&gt;parent-&gt;left; if (uncle-&gt;color == RED) { node-&gt;parent-&gt;color = BLACK; uncle-&gt;color = BLACK; node-&gt;parent-&gt;parent-&gt;color = RED; node = node-&gt;parent-&gt;parent; } else { if (node == node-&gt;parent-&gt;left) { node = node-&gt;parent; RightRotate(node); } node-&gt;parent-&gt;color = BLACK; node-&gt;parent-&gt;parent-&gt;color = RED; LeftRotate(node-&gt;parent-&gt;parent); } } } rootNode-&gt;color = BLACK;} 因为RB-INSERT操作是一层层的向下搜索可以插入的点，所以复杂度与树的高度有关，即为$O(\\lg n)$，RB-INSERT-FIXUP操作只有在情况1的情况下会继续循环，且每次循环前都将$z$向上移两位，因此执行次数是层数的一半，时间复杂度也为$O(\\lg n)$。综上，红黑树插入操作总体的时间复杂度为$O(\\lg n)$。 Deletion 如二叉搜索树一样，红黑树的删除操作同样需要Transplant操作来用一个结点替换另一个，这里与二叉搜索树不同的只是将Null变为了T.nil，以及在设置$v.p$时不需要额外的判断，因为即使$v$是哨兵，访问$v.p$也不会出错 伪代码如下 12345678RB-TRANSPLANT(T,u,v)if u.p == T.nil T.root = velse if u == u.p.left u.p.left = velse u.p.right = vv.p=u.p c++代码实现如下 1234567891011121314151617void RBTree::TransPlant(RBTreeNode* originNode, RBTreeNode* newNode){ if (originNode-&gt;parent == nullNode) { rootNode = newNode; } else if (originNode == originNode-&gt;parent-&gt;left) { originNode-&gt;parent-&gt;left = newNode; } else { originNode-&gt;parent-&gt;right = newNode; } newNode-&gt;parent = originNode-&gt;parent;} 在二叉搜索树的删除操作中，最复杂的情况，即被删除节点$z$有两个子树，且他的successor不是$z$的右子树。 这时候需要执行的操作是，将$successor.right$替换$successnor$的位置，再用$successor$替换$z$的位置。因为整个操作牵扯到三个节点$succcessor.right,successor,z$的变化，所以在红黑树的操作下，这三个结点都需要被确认是否会造成红黑树性质的破坏。 在删除算法中，将需要移进或者移出原先$z$位置的结点命名为$y$，需要记录$y$结点的位置，因为如果他是黑色的，那么他的移动会破坏红黑树的性质5。需要替代$y$位置的点用$x$表示。 删除操作的伪代码如下 1234567891011121314151617181920212223y = z //这里y表示要移除z位置的结点，即z自己y-original-code = y.colorif z.left == T.nil x = z.right RB-TRANSPLANT(T,y,x) //用z的右树替代z，即用x替代z，即用x替代yelse if z.right = T.nil x = z.left RB-TRANSPLANT(T,y,x) //用z的左树替代z，即用x替代z，即用x替代yelse y = TREE-MINIMUM(z.right) //y表示z.successor，这里y表示需要移进z位置的结点 x = y.right //如普通的搜索二叉树一样，用y的右子树替代y的位置 if y.p == z x.p = z //在普通二叉搜索树中，y.p == z的情况不需要任何操作，这里因为设置了x，所以需要为x指定父节点 else RB-TRANSPLANT(T,y,x) //TRANSPLANT操作同时也为x设置了父结点，即x.p = y.p y.right = z.right y.right.p = y RB-TRANSPLANT(T,z,y) y.left = z.left y.left.p = y y.colour = z.clour //在y移动到了z的位置后，用z的颜色表示y的颜色，这样就保证了y有原先z.p不会违背性质4if(y-original-color == Black)//在原先的y结点是黑色的情况下，会引发问题（后面会解释），所以需要修复 RB-DELETE-FIXUP(T,x) 在伪代码的最后，仅在原$y$结点颜色为黑色的时候调用修复函数RB_DELETE_FIXUP,因为$y$结点如果原先为红色，则不会违反任何的红黑树性质 因为$y$是红的，所以移动$y$不会造成树的黑高的变化，性质5也就不会被破坏 因为在代码的20行将$z$的颜色赋给了$y$，所以不会发生$y$与$z.p$=破坏性质4的情况。 $x$作为替代$y$的结点，如果$y$是红的,$x$就是黑色的，移动$x$也不会造成破坏性质4的情况 $y$是红色的，$y$不可能是树的根，所以根也不会发生变化，性质2也不会被破坏 性质1，3在操作中根本没有相关改动的地方，肯定不会被破坏 而$y$结点如果是黑色的，则可能会存在以下情况 如果$y$根节点，而且$y$的子结点是红色，那么破坏性质2。 这种情况只有$y$表示的是移出$z$位置的结点时($y=z$)才可能发生。否则$y$移入$z$的位置，且$y$是黑色的，不可能破坏性质2。如果$y$表示是移出$z$位置，说明$z$最多只有一个子树，这种情况下$y$的子结点即为$x$。 如果$x$和$x.p$都为红色，那么破坏性质4。 首先分析$x$和$x.p$的可能取值。 （1） $x$可能是$y.left$（在$z$只有左结点）或者$y.right$（在$z$有两种结点的情况或$z$只有右结点）。 （2） $x.p$在大部分情况下都为$y.p$，除了$x$在$z$有两个结点，且$y$是$z.right$的情况下，$x.p$=$y$。 因为$x$和$x.p$都是红色，且$y$是黑的，所以$x.p$不能等于$y$。因此发生的情况一定是$z$有两个结点，且$y$不等于$z.right$或$y$只有右结点。即如下图所示的两种情况： 任意包含了$y$的路径都会出现黑高减一的情况，违背性质5 (1) 在$y$表示移出$z$位置的结点的情况下(即 $y$ = $z$ )，因为$z$和$y$都是黑色，所以删除$z$结点必然会出现黑高减一 (2) 在$y$表示移入$z$位置的结点的情况下(即 $y$ = $z.successor$ )，仍然会出现黑高减一。如果$z$是黑色的，那么同样是$y$和$z$都是黑色，删除$z$结点出现黑高减一。如果$z$是红色的，删除$z$不会造成黑高减一，但是因为在算法的最后为了保证新移入的$y$不会与树的上层发生冲突，所以将$y$设为了原先$z$的颜色，即将$y$变为了黑色，因此同样黑高减一。 在这里为了解决包含$y$的路径出现的黑高减一现象，将额外的一个黑色给予$x$结点，因为包含有$y$的路径一定包含$x$（因为$x$=$y$或者$y.right$）。因为修复了黑高减一的问题，性质5满足了，但因为$x$现在是拥有两个黑色，或者是一黑一红，因此违背了性质1，即所有结点要么是红色，要么是黑色。 这里给$x$一个额外黑的操作并没有在代码中体现，只是一个思路。因此$x$的颜色在代码中判断，依然按$x$之前的颜色判断。 因此RB-DELETE-FIXUP一共需要解决三个性质的问题即，性质1，2，4。且性质1是针对$x$结点，所以传递的参数为$x$结点。 RB-DELETE-FIXUP的伪代码如下 1234567891011121314151617181920212223242526while x != T.root and x.color == BLACK if x == x.p.left w = x.p.right if w.color == RED // 情况1 w. color = BLACK x.p.color = RED LEFT-ROTATE(T,x.p) w = x.p.right // 新的w，因为新的w必然是黑色，所以情况1转换为1情况2/3/4 if w.left.color == BLACK and w.right.color == BLACK w.color = RED x = x.p else if w.right.color == BLACK w.left.color = BLACK w.color = RED RIGHT-ROTATE(T,w) w = x.p.right w.color = x.p.color x.p.color = BLACK w.right.color = BLACK LEFT-ROTATE(T,x.p) x = T.root else .... //和情况1,2,3,4类似，将right和left对调即可x.color = BLACK 这里的删除修复如同插入修复一样，有很多种情况，这里一共是8种情况。但是可以分为前四种和后四种，分割标准是$x$是$x.p$的左结点，还是右结点。这里我们只讨论$x$是左结点的情况，即前四种。后四种为前四种的对称，如同插入修复的对称一样,解法只要将前四种中的$left$改为$right$，反之亦然。 整个算法是一个循环和一个将x.color设为Black的语句。退出循环的条件是$x$是红色（实际上$x$有红-黑两个颜色属性）或$x$是根。 在这种情况下将$x$设为单一黑色（即x.color = Black）可以修复性质1，且不会破坏性质5，因为 (1) 如果$x$是根，那么删除一个黑色，是整棵树的黑高都减一，依然满足性质5 (2) 如果$x$是红-黑，即贡献了一个黑高，设为黑色后，依然是贡献一个黑高，满足性质5 将$x.color$设为黑色，因为$x$和$x.p$都为红色而造成的性质4的破坏也会被修复。 而且如上讨论，违背性质2的情况，必然是$z$最多只有一颗子树，即$y=z$，$x$作为$y$的子结点且为红色的情况，那么将$x$设为黑色，同样修复了性质2。这种情况下$x$就是根结点，并不会进入循环，将直接执行最后一句。 因此退出循环后的x.color = BLACK语句将同时修复性质1,2,4。现在需要关心的是该如何退出循环。 现在先分析前四种情况。这四种情况的分类是根据$x$的兄弟$w$（在$x$=$x.p.left$的情况下$w$即为$x.p.right$）。 因为进入循环是$x$是两个黑色属性，所以$w$必然存在且一定有两个子结点。不然通过$x$抵达叶子的黑高一定大于到达$w$的黑高。$w$的子结点也必然有两个子结点，因为只有$w$与$w.left$或$w.right$都为黑色，才能刚好与$x$的两个黑色相抵。如果其中一个为红色，那么则需要更深的树才能抵消。 $w$是红色为情况1。 如果$w$是黑色的，再细分为三个情况 $w$是黑色，且右结点是黑色，左结点是黑色为情况2 $w$是黑色，且右结点是黑色，左结点是红色，为情况3 $w$是黑色，且右结点是红色，左结点是红色或黑色，为情况4 对于情况1的修复： 因为$w$是红色，所以$w.p$即$w.p$必然是黑色的。将$w.p$与$w$的颜色对调，且对$w.p$进行左旋，如下图所示，不会违背任何的红黑树性质。 上图以及之后其他的对于各种情况的修复图中，黑色结点表示黑色，深灰色结点，如上图中的$D$表示红色，浅灰色结点表示可能是黑可能是红。 同样因为$w$是红色的，$w$的两个子结点也必然是黑色的，在上述的操作后，原$w$的左结点将会成为$x$的新兄弟，即成为新的$w$，为黑色。 如之前所述，$w$也必然有两个子结点，根据子结点的情况，情况1会变为情况2或3或4。 对于情况2的修复： 在情况2下，因为$x$是双重黑色，$w$是黑色，所以从他们两个结点中都取出一个黑色，即$x$变为单个黑色，$w$变为红色。将这个取出的黑色给予$x.p$。 这个操作只有在$w$的两个结点都是黑色的情况下（即情况2）才能执行，不然当$w$变为红色，将会与它的子结点违背性质4。 因为$x$和$w$都为黑色，所以$x.p$的颜色并不能确定（下图中由浅灰色表示），增加了额外黑色后，可能为黑-黑也可能为红-黑。 从$x$和$w$中都取出一个黑色，相当于将$x.p$的两个子树的黑高都减一，而此时将黑色给予$x.p$相当于将将失去的黑高补了回来。 此时$x.p$成为了破坏性质1的结点，因此将他设为新的$x$并再次进入循环。 如果是由情况1转换为的情况2，那么再次进入循环后，将不满足循环条件直接退出循环。因为在情况1修复后$x.p$为红色，在情况2修复后被给予了额外的黑色后，变为红-黑，不满足循环条件，因此退出。 对于情况3的修复： 情况3通过降$w$（黑色）与$w.left$（红色）的颜色对换，并对$w$执行右旋，再将原$w.left$设为新$w$转换为情况4。如下图所示。 对于情况4的修复： 在情况4中，先将$w$与$w.p$的颜色互换，然后对$w.p$进行左旋，$w$取代原先$w.p$的位置。如下图所示 分析三个结点$A$,$C$和$E$的黑高，发现$A$的黑高多了1，$C$的黑高不变，$E$的黑高少了1。因此我们将$A$的一个黑高给$E$，这样三个结点的黑高都不变。$A$结点即为$x$，原先有两个黑色，现在减去一个变成单独的黑色结点，满足性质1。$E$原先为红色，现在多了一个黑色，变为黑色结点。 因此情况4的最终修复效果如下 在这个情况下，所有的结点都满足了性质1。所以将$x$直接指向$T.root$来退出循环即可。 之所以情况2无法直接退出循环，是因为在情况2的修复后，原$x.p$仍然破坏了性质1，所以需要进入循环继续修复。 后四种情况的修复与前四种对称，这里不在赘述。 RB-DELETE操作本身没有循环，所以时间复杂度由TREE-MINIMUM和RB-DELETE-FIXUP共同决定。 如同普通二叉搜索树，TREE-MINIMUM时间复杂度为$O(\\lg n )$。 而RB-DELETE-FIXUP，只有情况2会再次进入循环，剩下的三种情况都是转换为其他情况或者在下一次直接退出循环。而情况2每次都会将$x$上移，所以在最坏情况下时间复杂度也为$O(\\lg n)$。 综上RB-DELETE的时间复杂度为$O(\\lg n ) + O(\\lg n)$，即$O(\\lg n)$。 RB-DELETE与RB-DELETE-FIXUP的c++代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657bool RBTree::Delete(int value){ RBTreeNode* toDelete = Search(value); if (toDelete == nullNode) return false; RBTreeNode* toDeleteTrack = toDelete;//this track will be removed from the tree NodeColor originDeleteTrackColor = toDeleteTrack-&gt;color; RBTreeNode* toReplaceTrack; if (toDelete-&gt;left == nullNode) { toReplaceTrack = toDelete-&gt;right; TransPlant(toDelete, toReplaceTrack); } else if (toDelete-&gt;right == nullNode) { toReplaceTrack = toDelete-&gt;left; TransPlant(toDelete, toReplaceTrack); } else //Both children are not nullNode { toDeleteTrack = GetMinimum(toDelete-&gt;right);//The track is Successor //This track will moved in toDelete's postion originDeleteTrackColor = toDeleteTrack-&gt;color; toReplaceTrack = toDeleteTrack-&gt;right; if (toDeleteTrack-&gt;parent == toDelete)//Track is toDelete's rightChild { toReplaceTrack-&gt;parent = toDeleteTrack; } else { TransPlant(toDeleteTrack, toReplaceTrack); toDeleteTrack-&gt;right = toDelete-&gt;right; toDeleteTrack-&gt;right-&gt;parent = toDeleteTrack; } TransPlant(toDelete, toDeleteTrack); toDeleteTrack-&gt;left = toDelete-&gt;left; toDeleteTrack-&gt;left-&gt;parent = toDeleteTrack; toDeleteTrack-&gt;color = toDelete-&gt;color; //set the pointer be null to ensure children and parent won't be released toDelete-&gt;parent = nullptr; toDelete-&gt;right = nullptr; toDelete-&gt;left = nullptr; delete toDelete; } if (originDeleteTrackColor == BLACK) { DeleteFixUp(toReplaceTrack); } return true;} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869void RBTree::DeleteFixUp(RBTreeNode* toReplaceTrack){ while (toReplaceTrack != rootNode &amp;&amp; toReplaceTrack-&gt;color == BLACK) { if (toReplaceTrack == toReplaceTrack-&gt;parent-&gt;left) //The first four cases { RBTreeNode* uncle = toReplaceTrack-&gt;parent-&gt;right; if (uncle-&gt;color == RED) //case1 { uncle-&gt;color = BLACK; toReplaceTrack-&gt;parent-&gt;color = RED; LeftRotate(toReplaceTrack-&gt;parent); uncle = toReplaceTrack-&gt;parent-&gt;right; //to case 2/3/4 } if (uncle-&gt;left-&gt;color == BLACK &amp;&amp; uncle-&gt;right-&gt;color == BLACK) { uncle-&gt;color = RED; //case2 toReplaceTrack = toReplaceTrack-&gt;parent; } else { if (uncle-&gt;right-&gt;color == BLACK) { uncle-&gt;left-&gt;color = BLACK; uncle-&gt;color = RED; RightRotate(uncle); // to case4 uncle = toReplaceTrack-&gt;parent-&gt;right; } uncle-&gt;color = toReplaceTrack-&gt;parent-&gt;color; toReplaceTrack-&gt;parent-&gt;color = BLACK; //case4; uncle-&gt;right-&gt;color = BLACK; RightRotate(toReplaceTrack-&gt;parent); toReplaceTrack = rootNode; } } else//The remaining four cases,as the symetry of the first four { RBTreeNode* uncle = toReplaceTrack-&gt;parent-&gt;left; if (uncle-&gt;color == RED) { uncle-&gt;color = BLACK; toReplaceTrack-&gt;parent-&gt;color = RED; RightRotate(toReplaceTrack-&gt;parent); uncle = toReplaceTrack-&gt;parent-&gt;left; } if (uncle-&gt;right-&gt;color == BLACK &amp;&amp; uncle-&gt;left-&gt;color == BLACK) { uncle-&gt;color = RED; toReplaceTrack = toReplaceTrack-&gt;parent; } else { if (uncle-&gt;left-&gt;color == BLACK) { uncle-&gt;right-&gt;color = BLACK; uncle-&gt;color = RED; LeftRotate(uncle); uncle = toReplaceTrack-&gt;parent-&gt;left; } uncle-&gt;color = toReplaceTrack-&gt;parent-&gt;color; toReplaceTrack-&gt;parent-&gt;color = BLACK; uncle-&gt;left-&gt;color = BLACK; RightRotate(toReplaceTrack-&gt;parent); toReplaceTrack = rootNode; } } } toReplaceTrack-&gt;color = BLACK;} 引用： Introduction to Algorithms 3rd Sep.2009","link":"/IA-Chapter13-Notes/"},{"title":"《算法导论》 第五章笔记","text":"《算法导论》 第五章笔记。 5.1节介绍了整章中作为例子的雇佣问题，并简单介绍了两个分析随机问题的方法，概率分析和随机化算法。 5.2节介绍了分析随机问题中的重要工具，指标随机变量，并使用概率分析方法分析了雇佣问题的平均花费。 5.3节使用随机化算法分析雇佣问题的期望花费，并且介绍了两种实现随机值产生器的方法。 5.4节尚未整理。 Chapter 5 Probabilistic Analysis and Randomized Algorithms The hiring problem 雇佣问题（Hiring Problem）是假设一个雇佣公司与一家HR服务公司签订协议帮助它雇佣一位秘书。HR服务公司会每天向雇佣公司提供一个候选人，雇佣公司将面试该候选人，如果候选人比现在的秘书优秀，则解雇现在的秘书，雇佣候选人。这个操作是每天都在进行的，即如果每天来的候选人都比前一天的更优秀，则会每天解雇昨天雇佣的人，然后再雇佣新的候选人。整个过程的伪代码实现如下： 1234567HIRE-ASSISTANT(n)best = 0;for i = 1 to n interview candidate i if candidate i better than candidate best best = i hire candidate i 雇佣公司需要为每一个候选人向HR服务公司付一笔钱，记为$C_i$，在正式雇佣员工时需要再额外付给HR服务公司一笔钱，这笔钱款项较大，记为$C_h$。在这个算法中，关心的复杂度不再是时间复杂度而是最终需要付给HR服务公司的钱的多少，如果候选人一共有$n$人，一共雇佣过其中$m$人，则算法的复杂度为$O(C_in+C_hm)$，其中$C_in$是固定的，主要需要关心的就是$C_hm$。 可以明显看出，$m$越大，即雇佣过的人越多，复杂度越高。而$m$的大小是与候选人的情况相关的。 Worst-case analysis 最坏情况下，即候选人是从最差到最好的顺序给的，那么$m=n$。在最好情况下，即候选人是从最好到最坏的顺序下给的，那么$m=1$。 但是最好和最差情况是很少出现的，所以需要真正关心的是通常情况下的花费，或者说各个情况下平均需要的花费。 这里先简单的阐述下概率分析方法和随机化算法方法，在6.2和6.3节会进行更详细的分析。 Probabilistic analysis 概率分析（Probabilistic analysis）是通过概率来分析问题，通常使用概率分析来分析算法的运行时间，但这里用概率分析来分析雇佣的花费。 为了实施概率分析，需要知道所有输入情况的概率分布，或者猜测出一个所有输入情况的概率分布，然后根据这些输入情况的分布来计算出所有情况下的平均花费，将其称为平均情况运行时间（Average-case running time）。 对于雇佣问题而言，所有输入可能的概率是相同的，即这是个均匀概率分布（Unifrom random permutation）。对于一共有$n$个候选人，第一个候选人一共$n$种可能，第二个候选人有$n-1$种…依次类推，最后一个候选人就只有1种可能，综合起来看，$n$个候选人的排列组合有$n!$种可能，因此每个排列的可能性为$1/n!$ Randomized algorithms 为了使用概率分析的方法，需要知道输入的分布可能或者对分布可能进行一个猜测，在随机化算法（Randomized algorithms）中则不需要。可以使用随机函数主动的让算法中的一部分成为随机。 在雇佣问题中，无论输入是什么情况，每天都是随机的从输入中抽取一个候选人，这样无论输入是什么情况，算法的结果都由算法中随机函数部分决定。 称一个算法被随机化（Randomized）了，如果算法的结果不仅由输入决定，还由一个被随机数生成器（Random-Nunmber generator）产生的数值决定。 对于随机化算法的复杂度分析，是根据随机数生成器生成的数值的概率分布来计算出运行时间，将其称为期望运行时间（Expected running time）。 Indicator random variables 指标随机变量（Indicator random variables）提供一个在概率（probabilities）和期望（expectations）之间转换的方法。事件$A$的指标随机变量$I{A}$定义为： $$ I{A}=\\begin{cases} 1 &amp; \\text{if A occurs,}\\\\ 0 &amp; \\text{if A does not occur.} \\end{cases} $$ 举一个简单的例子说明指标随机变量与期望值的关系。假设翻转一枚硬币，将结果是正面称为事件$H$，是反面称为事件$T$，即样本空间为$S={H,T}$，其中两个事件的概率都为0.5，即$Pr{H}=Pr{T}=1/2$。 将事件$H$的指标随机变量定义为$X_H$，即 $$ X_H=I{H}= \\begin{cases} 1 &amp; \\text{if H occurs,}\\\\ 0 &amp; \\text{if T occurs.} \\end{cases} $$ 事件$H$的期望值为$E[X_H]$： $$ E[X_H]=E[I{H}]\\\\ = 1 \\cdot Pr{H} + 0\\cdot Pr{T} \\\\ = 1\\cdot (1/2)+0\\cdot(1/2)\\\\ =1/2 $$ 定理5.1： 给定一个样本空间$S$和一个事件$A$在样本空间中，定义$X_A=I{A}$，则$E[X_A]=Pr{A}$ 证明如下： $$ E[X_A]=E[I{A}]\\\\ = 1 \\cdot Pr{A} + 0\\cdot Pr{\\bar{A}} \\\\ = Pr{A} $$ Analysis of hiring problem using indicator random variables 为了使用概率分析，假设候选人都是以一个随机的顺序出现（在5.3节使用随机化算法的话将不再需要这个假设）。将X作为随机变量，其值表示为整个面试过程中总计录用的次数。 根据期望随机变量的定义，可X的期望值可表示为： $$ E[X]=\\sum_{x=1}^{n} x \\cdot Pr{\\ X=x} $$ 该式子需要计算，$x=1,x=2\\dotsc x=n$情况下的概率。这个概率的计算较为复杂，可以使用指标随机变量来简化上式。 将第$i$位候选人被录用的随机变量定义为$X_i$，则 $$ X_i = I{\\text{candidate i is hired} } =\\\\ =\\begin{cases} 1 &amp; \\text{if candidate i is hired} \\\\ 0 &amp; \\text{if candidate i is not hired} \\end{cases} $$ 可知所有候选人录取的总次数是各个候选人被录取随机变量的总和，即$X=X_1+X_2+\\dotsc + X_n$。 由根据定理5.1可知，$E[X_i]=Pr{\\text{candidate i is hired} }$ 第$i$个候选人前已经出现了$i-1$个候选人，加上第$i$个自己，一共有$i$个候选人且每个候选人被录取的概率相同，因此第$i$个候选人被录取的概率为$1/i$。 综上，可得 $$ E[X] = E[\\sum_{i=1}^{n}X_i] \\\\ = \\sum_{i=1}^{n} E[X_i] \\\\ = \\sum_{i=1}^{n} 1/i \\\\ = \\ln n + O(1) $$ 因此，使用概率分析可得平均情况下录取候选人的成本为$O(C_h \\ln n)$ Randomized algorithms 随机化算法与概率分析两个方法的不同点在于，概率分析是假设一个输入的分布，而随机化算法是引入输入的分布。 概率分析下，对于一个算法，如果输入值是不变的，则结果也是不变的，不同的输入产生不同的值。 但是在随机化算法下，输入值不变也可能产生不同的结果，因为算法内部有随机生成器。也因此，没有特定的输入会产生最差情况。 随机化算法的伪代码如下： 12345678910RANDOMIZED-HIRE-ASSISTANT(n)randomly permute the list of candidatesbest = 0for i = 1 to n interview candidate i if candidate i is better than candidate best best = i hire candidate i 与之前算法的唯一不同就是引入了randomly permute the list of candidates。在执行了该语句，产生了随机输入后，剩余部分的分析如上节的概率分析一样。 上节的输入分布是猜测出来的，而这里的输入分布则是通过该语句生成出来的。 因此通过随机化算法也同样可以得到结论，录取候选人的成本为$O(C_h \\ln n)$。但使用概率分析的时候，将结果称为平均情况下的结果，在使用随机化算法的时候，将结果称为期望结果。两者实际上非常相似，更多的是命名方面的区分。 Randomly permuting arrays 许多随机化算法都是通过随机排列输入数组来引入随机化的。 一个通常的随机排列数组的方法是给数组中的每个元素$A[i]$一个随机的优先级值$P[i]$，然后根据优先级值排列元素次序。如原始数组为${1,2,3,4}$，随即优先级值为${36,3,62,29}$，则原始数组排列为${2,4,1,3}$。 该方法伪代码如下： 123456PERMUTE-BY_SORTING(A)n = A.lengthlet P[1..n] be a new arrayfor i = 1 to n P[i] = RANDOM(1,n^3)sort A using P as sort keys 在伪代码中，将$1\\sim n^3$作为范围选取优先级值，是为了保证每个优先级值大概率是不一样的。在实际代码中，这样实现可能会产生问题。 上述算法中sort A using P as sort keys的复杂度由所使用的排列算法决定，通常时间复杂度为$O(n\\lg n)$。 还需要证明该算法产生的是均匀随机排列(unifrom random permutation)。在雇佣问题下，即证明每个排列的可能性是$1/n!$。 假设需要求所有候选人水平是递增的排列，第一个候选人有$n$种可能，他水平最低的可能性为$1/n$，第二个候选人在剩下的人（$n-1$）中水平最低的概率为$1/(n-1)$，之后的候选人概率依次类推。 将$E_i$定义为事件，第$i$个候选人水平第$i$低，则所有候选人水平是递增的概率为： $$ Pr{E_1 \\cap E_2 \\cap E_3 \\cap \\dotsi \\cap E_n}\\\\ = Pr{E_1} \\cdot Pr{ E_2 | E_1} \\cdot Pr{E3 | E_2 \\cap E_1} \\cdot \\dotsb Pr{E_i | E_{i-1} \\cap E_{i-1} \\cap \\dotsb \\cap E_1 }\\\\\\dotsb Pr{E_n | E_{n-1} \\cap E_{i-1} \\cap \\dotsb \\cap E_1 } \\\\ = \\frac{1}{n} \\cdot \\frac{1}{n-1} \\cdot \\dotsb \\cdot \\frac{1}{1}\\\\ = \\frac{1}{n!} $$ 这里是证明了所有候选人水平递增的排列出现概率为$1/n!$，用同样的方法可以证明其他的排列下概率也都为$1/n!$，因此得证。 还由一种随机排列的方法，是通过将$A[i]$与$A[i]\\sim A[n]$间的一个元素互换生成随机数组排列，伪代码如下： 1234RANDOMIZE-IN-PLACE(A)n = A.lengthfor i = 1 to n swap A[i] with A[RaNDOM(i,n)] 该算法的时间复杂度为$O(n)$。 同样需要证明该算法的输出结果满足均匀随机排列。 在一个有$n$个值的均匀随机排列中取连续$k$个值，取第一个值有$n$种可能，第二个有$n-1$种可能，第$k$个有$n-k+1$种可能。因此连续k个值的排列一共有$n!/(n-k)!$种可能性。 需要检测该算法是否满足此特性。 根据上式，对于第$i$个候选人，前面$i-1$个候选人的排列有$n!/(n-i+1)!$种可能，将前$i-1$个候选人的排列称为事件$E_1$。将第$i$个候选人的选人概率定义为$E_2$，因为第$i$个候选人是从$A[i \\dotsb n]$中选取的，所以概率为$1/(n-i+1)$。 前$i$的候选人的排列是在事件$E_1$和事件$E_2$同时发生的情况下产生的，即 $$ Pr{E_2 \\cap E_1 } = Pr{E_2 |E_1 } \\cdot Pr{E_1 } \\\\ = \\frac{1}{n-i+1} \\cdot \\frac{n-i+1}{n!} \\\\ = \\frac{(n-i)!}{n!} $$ 满足均匀随机排列特性，因此得证。 当取$i=n$时，即$n$个候选人时某个排列组合的概率，可得$(n-i)!/n!=1/n!$，与概率分析的结果相同。 Probabilistic analysis and further uses of indicator random variables //TODO 引用： Introduction to Algorithms 3rd Sep.2009","link":"/IA-Chapter5-Notes/"},{"title":"《算法导论》 第四章笔记","text":"《算法导论》第四章笔记。包括分治法的介绍，最大子数组问题算法与分析，矩阵相乘问题问题算法与分析，代入法、递归树法、主方法求时间复杂度。 4.6节尚未整理。 Chapter 4. Divide-and-Conquer 在分析分治法的时候一般无视了许多细节，例如在分析归并排序时，如果考虑到$n$存在奇、偶情况，那么表达式应该写成 $$ T(n)=\\begin{cases} \\Theta(1) &amp; \\text{ if } n=1 \\\\ T(\\lceil n/2 \\rceil)+T(\\lfloor n/2 \\rfloor)+\\Theta(n) &amp; \\text{ if } n&gt;1 \\end{cases} $$ 但在实际中，通常会无视向上取整，向下取整和一些边界条件，所以在归并排序分析时写成 $$T(n)=2T(n/2)+\\Theta(n)$$ The Maximum-subarray problem 从一个整数数组中找寻出值最大的子数组。如下图所示的数组中，$A[8…11]$即为最大数组，和为43 A brute-force solution 暴力破解法：通过双重循环遍寻所有的子数组情况，找出最大的数组。通过上一个子数组的和加上当前元素即可求得当前子数组的和，所以计算子数组和的花费为$O(1)$，遍历所有子数组需要的时间花费为$O(n^2)$，所以总体算法时间为$O(n^2)$ 暴力破解的代码实现如下： 1234567891011121314151617181920int FindMaximumSubarray_BruteForce(int* originArray, int arrayLength, int&amp; leftIndex, int&amp; rightIndex){ int maxSum = -INT_MAX, sum = 0; leftIndex = rightIndex = 0; for (int i = 0; i &lt; arrayLength; i++) { sum = 0; for (int j = i; j &lt; arrayLength; ++j) { sum += originArray[j]; if (sum &gt; maxSum) { maxSum = sum; leftIndex = i; rightIndex = j; } } } return maxSum;} A solution using divide-and-conquer 分治法求最大子数组问题的思路为，把原数组等分为两个部分，左半数组和右半数组。这时候求得的最大数组只可能是三种情况：完全在左半数组中，完全在右半数组中，处在左右半数组交界的地方。 所以分治法求最大子数组的伪代码如下，代码中依次求三种情况的最大子数组，然后比较求得原数组的最大子数组。（在求左右半边的最大子数组时使用了迭代）。 1234567891011121314151617FIND-MAXIMUM_SUBARRAY(A,low,high)//A为原数组，low，high分别表示拆分出的左或右数组的左右Indexif high==low //只有一个元素时，即为最大子数组 return [low,high,A[low]]else mid=[(low + high)/2] (left-low, left-high, left-sum)= FIND-MAXIMUM_SUBARRAY(A,low,mid) (right-low, right-high, right-sum)= FIND-MAXIMUM_SUBARRAY(A,mid+1,high) (cross-low, cross-high,cross-sum)=FIND-MAX-CROSSING-SUBARRAY(A,low,mid,high) if left-sum &gt;=right-sum &amp;&amp; left-sum&gt;=cross-sum return [left-low,left-high,left-sum] else if right-sum&gt;=left-sum &amp;&amp; right-sum &gt;= cross-sum return [right-low,right-high,right-sum] else return [cross-low,cross-high,cross-sum] 在求左右半边的最大子数组时使用了迭代，现在还要解决的就是求交叉最大子数组FIND-MAX-CROSSING-SUBARRAY函数的定义。 交叉最大子数组一定一部分处于左半数组，一部分处于右半。从Index mid处向左和向右各寻找最大的左部分，然后将左右部分结合便形成了最大的交叉子数组。 求交叉最大子数组伪代码如下： 12345678910111213141516171819202122FIND-MAX-CROSSING-SUBARRAY(A,low,mid,high)left-sum= -MAXsum=0;for i= mid downto low sum = sum + A[i] if sum &gt; left-sum left-sum=sum; max-left-Index=iright-sum= -MAXsum=0;for i= mid to high sum = sum + A[i] if sum &gt; right-sum right-sum=sum; max-right-Index=ireturn (max-left-index,max-right-index,left-sum + right-sum) 完整C++实现代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768int FindMaximumSubarray_DivideAConquer(int* originArray, int leftIndex, int rightIndex, int&amp; maxLeftIndex, int&amp; maxRightIndex){ if (leftIndex == rightIndex) { maxLeftIndex = maxRightIndex = leftIndex; return originArray[leftIndex]; } int midIndex = (leftIndex + rightIndex) / 2; int sumLeft = 0, leftMaxLeftIndex = 0, leftMaxRightIndex = 0; sumLeft = FindMaximumSubarray_DivideAConquer(originArray, leftIndex, midIndex, leftMaxLeftIndex, leftMaxRightIndex); int sumRight = 0, rightMaxLeftIndex = 0, rightMaxRightIndex = 0; sumRight = FindMaximumSubarray_DivideAConquer(originArray, midIndex + 1, rightIndex, rightMaxLeftIndex, rightMaxRightIndex); int sumCross = 0, crossMaxLeftIndex = 0, crossMaxRightIndex = 0; sumCross = FindCrossingMaximumSubarray(originArray, leftIndex, midIndex, rightIndex, crossMaxLeftIndex, crossMaxRightIndex); if (sumLeft &gt;= sumRight &amp;&amp; sumLeft &gt;= sumCross) { maxLeftIndex = leftMaxLeftIndex; maxRightIndex = leftMaxRightIndex; return sumLeft; } else if (sumRight &gt;= sumLeft &amp;&amp; sumRight &gt;= sumCross) { maxLeftIndex = rightMaxLeftIndex; maxRightIndex = rightMaxRightIndex; return sumRight; } else { maxLeftIndex = crossMaxLeftIndex; maxRightIndex = crossMaxRightIndex; return sumCross; }}int FindCrossingMaximumSubarray(int* originArray, int leftIndex, int midIndex, int rightIndex, int&amp; maxLeftIndex, int&amp; maxRightIndex){ int maxSumLeft = -INT_MAX; int sum = 0; for (int i = midIndex; i &gt;= leftIndex; i--) { sum += originArray[i]; if (sum &gt; maxSumLeft) { maxLeftIndex = i; maxSumLeft = sum; } } int maxSumRight = -INT_MAX; sum = 0; for (int i = midIndex + 1; i &lt;= rightIndex; i++) { sum += originArray[i]; if (sum &gt; maxSumRight) { maxRightIndex = i; maxSumRight = sum; } } return maxSumLeft + maxSumRight;} Analyzing the divide-and-conquer algorithm 分治法求最大子数组的是将原问题拆分为三个部分，（1）求左半部分的最大子数组 （2）求右半部分的最大子数组（3）求交叉部分的最大子数组，所以我们可以将原问题的时间花费$T(n)$改写为 $$ T(n)=\\Theta(1)+2T(n/2)+\\Theta(n)+\\Theta(1) \\\\ =2T(n/2)+\\Theta(n) $$ 其中两个$\\Theta(1)$分别表示拆分问题和合并答案的时间，$\\Theta(n)$表示求交叉最大子数组的时间。 这个表达式与归并排序的表达式相同，所以我们可以得出求最大子数组的分治法复杂度为$T(n)=\\Theta(n\\lg(n))$ Strassen’s algorithms for matrix multiplication 对于两个大小为$n\\times n$的矩阵$A$和$B$，它们的乘积$C=A\\cdot B$中的每个元素$c_{ij}, i,j = 1,2,\\dotsc n$，可表示为： $$ c_{ij}=\\sum_{k=1}^{n}a_{ik}\\cdot b_{kj} $$ 该方法用伪代码可表示为 123456789SQUARE-MATRIX-MULTIPLY(A,B)n= A.rowslet C be a new n*n matrixfor i = 1 to n for j = 1 to n c_ij = 0 for k = 1 to n c_ij=c_ij+a_ik*b_kjreturn C c++实现如下： 12345678910111213141516Matrix MatrixMultiply(const Matrix&amp; A, const Matrix&amp; B){ Matrix result(A.row, B.column); for (int i = 0; i &lt; A.row; i++) { for (int j = 0; j &lt; B.column; ++j) { for (int k = 0; k &lt; A.column; k++) { result.data[i][j] = result.data[i][j] + A.data[i][k] * B.data[k][j]; } } } return result;} 伪代码实现假设相乘的两个矩阵大小都是$n\\times n$，在c++实现中可以是任意满足矩阵相乘的条件的矩阵大小。 可以很容易的看出，SQUARE-MATRIX-MULTIPLY的复杂度为$O(n^3)$ A simple dividea-and-conquer algorithm 可以用分治法来解决矩阵相乘问题，为了简化问题，假设两个相乘的矩阵大小都是$n\\times n$，且$n$的值为某个2的次幂。 首先将两个相乘的矩阵都拆成四部分，即每部分的长度为$n/2$，可以将每部分都看作是一个简单元素，于是问题转换为了两个$2\\times2$矩阵的运算（两个$2\\times2$矩阵中的每个元素都是一个子矩阵）。对于其中子矩阵相乘的计算可使用相同策略，即再进一步拆分成四个更小的子矩阵。 数学说明如下，A和B为两个相乘的矩阵，C为结果矩阵： $$ A=\\begin{pmatrix} A_{11} &amp; A_{12}\\\\ A_{21} &amp; A_{22} \\end{pmatrix} $$ $$ B=\\begin{pmatrix} B_{11} &amp; B_{12}\\\\ B_{21} &amp; B_{22} \\end{pmatrix}, $$ $$ C=\\begin{pmatrix} C_{11} &amp; C_{12}\\\\ C_{21} &amp; C_{22} \\end{pmatrix} $$ $$ C=A \\cdot B =\\begin{pmatrix} C_{11} &amp; C_{12}\\\\ C_{21} &amp; C_{22} \\end{pmatrix}=\\begin{pmatrix} A_{11} &amp; A_{12}\\\\ A_{21} &amp; A_{22} \\end{pmatrix}\\cdot \\begin{pmatrix} B_{11} &amp; B_{12}\\\\ B_{21} &amp; B_{22} \\end{pmatrix} $$ C中的各子矩阵的计算可以看作是普通元素的计算，即满足： $$ C_{11}=A_{11}\\cdot B_{11} +A_{12} \\cdot B_{21}\\\\ C_{12}=A_{11}\\cdot B_{12} +A_{12} \\cdot B_{22}\\\\ C_{21}=A_{21}\\cdot B_{11} +A_{22} \\cdot B_{21}\\\\ C_{22}=A_{21}\\cdot B_{12} +A_{22} \\cdot B_{22}\\\\ $$ 可以看到，需要8个子矩阵的相乘，每个子矩阵的大小是$n/2$，即将问题拆分成了8个子问题。 分治计算矩阵相乘的伪代码如下： 1234567891011121314151617SQUARE-MATRIX-MULTIPLY-RECURSIVE(A,B)n = a.rows;let C be a new n*n matrixif n == 1 c_11=a_11 * b_11else divide A,B,C into 4 submatrix C_11 = SQUARE-MATRIX-MULTIPLY-RECURSIVE(A_11,B_11)+ SQUARE-MATRIX-MULTIPLY-RECURSIVE(A_12,B_21) C_12 = SQUARE-MATRIX-MULTIPLY-RECURSIVE(A_11,B_22)+ SQUARE-MATRIX-MULTIPLY-RECURSIVE(A_12,B_22) C_21 = SQUARE-MATRIX-MULTIPLY-RECURSIVE(A_21,B_11)+ SQUARE-MATRIX-MULTIPLY-RECURSIVE(A_22,B_21) C_12 = SQUARE-MATRIX-MULTIPLY-RECURSIVE(A_21,B_12)+ SQUARE-MATRIX-MULTIPLY-RECURSIVE(A_22,B_22)return C 其中divide A,B,C into 4 submatrix将产生3*4个子矩阵，每个子矩阵的大小为$n/2$，创建子矩阵时需要拷贝数据，即这操作的总时间复杂度为$\\Theta(n^2)$。 另外计算$C$的各部分时，需要将迭代得到的数据进行累加，每次累加的对象都是一个大小为$n/2$的子矩阵，因此这些累加操作的时间复杂度也为$\\Theta(n^2)$。 综上，这个分治法的时间表达式为$T(n)=8T(n/2)+\\Theta(n^2)$。根据之后的章节可得知，该式子符合主方法的第一个情况，因此复杂度为$O(n^3)$。 伪代码中的创建子矩阵和数据拷贝的相关操作实际上是可以通过指针操作来省掉的，如以下C++实现，通过函数的形参来标识子矩阵的位置和大小： 123456789101112131415161718192021222324252627282930Matrix* MatrixMultiply_Recursive(Matrix* A, Matrix* B, Matrix* result, int resultStartRow, int resultStartCol, int aStartRow, int aStartCol, int bStartRow, int bStartColumn, int subMatSize){ //This method assume that the size of Matrix is n*n where n is an exact power of 2 //StartRow and startColumn indicate where subMatrix starts, three pairs of value individually for A,B and result //The subMatrix of A and B should be the same size, so there is only on subMatrixSize value if (result == nullptr) result = new Matrix(A-&gt;row, B-&gt;column); if (subMatSize == 1) result-&gt;data[resultStartRow][resultStartCol] = result-&gt;data[resultStartRow][resultStartCol] + A-&gt;data[aStartRow][aStartCol] * B-&gt;data[bStartRow][bStartColumn]; else { subMatSize /= 2; //result 11 MatrixMultiply_Recursive(A, B, result, resultStartRow, resultStartCol, aStartRow, aStartCol, bStartRow, bStartColumn, subMatSize);//A11*B11 MatrixMultiply_Recursive(A, B, result, resultStartRow, resultStartCol, aStartRow, aStartCol + subMatSize, bStartRow + subMatSize, bStartColumn, subMatSize);//A12*B21; //result 12 MatrixMultiply_Recursive(A, B, result, resultStartRow, resultStartCol + subMatSize, aStartRow, aStartCol, bStartRow, bStartColumn + subMatSize, subMatSize);//A11*B12 MatrixMultiply_Recursive(A, B, result, resultStartRow, resultStartCol + subMatSize, aStartRow, aStartCol + subMatSize, bStartRow + subMatSize, bStartColumn + subMatSize, subMatSize);//A12*B22 //result 21 MatrixMultiply_Recursive(A, B, result, resultStartRow + subMatSize, resultStartCol, aStartRow + subMatSize, aStartCol, bStartRow, bStartColumn, subMatSize);//A21*B11 MatrixMultiply_Recursive(A, B, result, resultStartRow + subMatSize, resultStartCol, aStartRow + subMatSize, aStartCol + subMatSize, bStartRow + subMatSize, bStartColumn, subMatSize);//A22*B21 //result 22 MatrixMultiply_Recursive(A, B, result, resultStartRow + subMatSize, resultStartCol + subMatSize, aStartRow + subMatSize, aStartCol, bStartRow, bStartColumn + subMatSize, subMatSize);//A21*B12 MatrixMultiply_Recursive(A, B, result, resultStartRow + subMatSize, resultStartCol + subMatSize, aStartRow + subMatSize, aStartCol + subMatSize, bStartRow + subMatSize, bStartColumn + subMatSize, subMatSize);//A22*B22 } return result;} 注意上述C++实现中，子矩阵结果的累加也放到了$n==1$情况下处理，因此整个算法的时间复杂度可表示为$T=8T(n/2)$ 虽然少了后置项$\\Theta(n^2)$，但此式仍然是满足主方法的第一种情况，且结果仍然是$T=\\Theta(n^3)$ Strassen’s method 在上述的分治法中，一共需要8次子矩阵的相乘才能得到最终结果。而在施特拉森方法（Stressen’s method）中，仅需要7次子矩阵的相乘。 如上节一样，将A，B视作两个需要相乘的矩阵，矩阵大小都是$n\\times n$，且$n$的值为某个2的次幂。C为相乘的结果。 施特拉森方法的步骤如下： 将A，B，C各拆分成四部分。 创建10个矩阵 $S_1 \\dotsc S_{10}$，每个子矩阵的大小都是$n/2$。这10个矩阵的值都可以通过A，B的子矩阵相互加减得到。 创建7个矩阵，$P_1 \\dotsc P_7$，每个子矩阵的值都可以通过步骤2的10个矩阵与A，B的子矩阵相乘得到。 结果C的4个子矩阵，可以通过步骤3中的7个矩阵加减得到。 步骤1如果通过拷贝，则时间复杂度为$\\Theta(n^2)$，如果通过指针操作，时间复杂度为$\\Theta(1)$ 步骤2是加减操作，所以时间复杂度为$\\Theta(n^2)$ 步骤3是子矩阵的相乘，但是与分治法不同的是，这里只需要7个矩阵的相乘操作，即原问题拆分为了7个子问题。 步骤3是加减操作，所以时间复杂度为$\\Theta(n^2)$。 可以看出，施特拉森方法的时间复杂度表达式为： $T(n)=7T(n/2)+\\Theta(n^2)$ 符合主方法的第一种情况，可得出时间复杂度为$T(n)=O(n^{\\lg 7})$，比递归法求解矩阵相乘效率更高。 步骤2的10个矩阵的值具体计算如下： $$ S_1=B_{12}-B_{22} \\\\ S_2 = A_{11} +A_{12} \\\\ S_3 = A_{21}+A_{22} \\\\ S_4 = B_{21}-B_{11} \\\\ S_5 = A_{11}+A_{22} \\\\ S_6 = B_{11}+B_{22} \\\\ S_7 = A_{12}-A_{22} \\\\ S_8 = B_{21}+B_{22} \\\\ S_9 = A_{11}-A_{21} \\\\ S_{10} = B_{11}+B_{12} : $$ 步骤3的7个矩阵的值具体计算如下： $$ P_{1} = A_{11} \\cdot S_{1} = A_{11} \\cdot B_{12} - A_{11} \\cdot B_{22}\\\\ P_{2} = S_{2} \\cdot B_{22} = A_{11} \\cdot B_{22} + A_{12} \\cdot B_{22}\\\\ P_{3} = S_{3} \\cdot B_{11} = A_{21} \\cdot B_{11} + A_{22} \\cdot B_{11}\\\\ P_{4} = A_{22} \\cdot S_{4} = A_{22} \\cdot B_{21} - A_{22} \\cdot B_{11}\\\\ P_{5} = S_{5} \\cdot S_{6} = A_{11} \\cdot B_{11} + A_{11} \\cdot B_{22} + A_{22} \\cdot B_{11} + A_{22} \\cdot B_{22}\\\\ P_{6} = S_{7} \\cdot S_{8} = A_{12} \\cdot B_{21} + A_{12} \\cdot B_{22} - A_{22} \\cdot B_{21} - A_{22} \\cdot B_{22}\\\\ P_{7} = S_{9} \\cdot S_{10} = A_{11} \\cdot B_{11} + A_{11} \\cdot B_{12} - A_{21} \\cdot B_{11} - A_{21} \\cdot B_{12} $$ 可以发现最终7个矩阵的计算都可以通过A和B的子矩阵获得，即在实际算法的实现中，可以跳过步骤2中关于$S_1 \\dotsc S_10$的实现。 步骤4的C子矩阵值计算如下： $$ C_{11}=P_{5} +P_{4}-P_{2}+P_{6} \\\\ C_{12}=P_{1} +P_{2} \\\\ C_{21}=P_{3} +P_{4} \\\\ C_{22}=P_{5} +P_{1}-P_{3}+P_{7} \\\\ $$ 完整的C++实现如下: 123456789101112131415161718192021222324252627282930313233Matrix MatrixMultiply_Strassen(const Matrix&amp; A, const Matrix&amp; B){ if (A.row == 1 &amp;&amp; A.column == 1 &amp;&amp; B.row == 1 &amp;&amp; B.column == 1) { Matrix result(A.row, B.column); result.data[0][0] += A.data[0][0] * B.data[0][0]; return result; } else { Matrix A_11 = createSubMatrix(A, 0, 0, A.row / 2), A_12 = createSubMatrix(A, 0, A.column / 2, A.row / 2); Matrix A_21 = createSubMatrix(A, A.row / 2, 0, A.row / 2), A_22 = createSubMatrix(A, A.row / 2, A.column / 2, A.row / 2); Matrix B_11 = createSubMatrix(B, 0, 0, B.row / 2), B_12 = createSubMatrix(B, 0, B.column / 2, B.row / 2); Matrix B_21 = createSubMatrix(B, B.row / 2, 0, B.row / 2), B_22 = createSubMatrix(B, B.row / 2, B.column / 2, B.row / 2); Matrix P_1 = MatrixMultiply_Strassen(A_11, B_12) - (MatrixMultiply_Strassen(A_11, B_22)); Matrix P_2 = MatrixMultiply_Strassen(A_11, B_22) + (MatrixMultiply_Strassen(A_12, B_22)); Matrix P_3 = MatrixMultiply_Strassen(A_21, B_11) + (MatrixMultiply_Strassen(A_22, B_11)); Matrix P_4 = MatrixMultiply_Strassen(A_22, B_21) - (MatrixMultiply_Strassen(A_22, B_11)); Matrix P_5 = MatrixMultiply_Strassen(A_11, B_11) + (MatrixMultiply_Strassen(A_11, B_22)) + (MatrixMultiply_Strassen(A_22, B_11)) + (MatrixMultiply_Strassen(A_22, B_22)); Matrix P_6 = MatrixMultiply_Strassen(A_12, B_21) + (MatrixMultiply_Strassen(A_12, B_22)) - (MatrixMultiply_Strassen(A_22, B_21)) - (MatrixMultiply_Strassen(A_22, B_22)); Matrix P_7 = MatrixMultiply_Strassen(A_11, B_11) + (MatrixMultiply_Strassen(A_11, B_12)) - (MatrixMultiply_Strassen(A_21, B_11)) - (MatrixMultiply_Strassen(A_21, B_12)); Matrix C_11 = P_5 + (P_4)-(P_2)+(P_6); Matrix C_12 = P_1 + (P_2); Matrix C_21 = P_3 + (P_4); Matrix C_22 = P_5 + (P_1)-(P_3)-(P_7); Matrix result(C_11, C_12, C_21, C_22); return result; }} The substitution method for solving recurrences 代入法求迭代复杂度分为两步： 猜出解的表达形式 用数学归纳法找出解的常数并证明解是正确的。 如有表达式 $$T(n)=2T(\\lfloor n/2 \\rfloor)+n$$ 表达式的形式与归并排序算法很类似，所以我们时间复杂度为$T(n)=O(n\\lg n)$。需要证明的是，存在某正常数$c$使得$T(n)\\leq cn\\lg n$。 根据数学归纳法，先假设存在一个$m&lt;n$，对于$m$表达式成立，在这里将$m$取$\\lfloor n/2 \\rfloor$，如果上述表达式对于$\\lfloor n/2 \\rfloor$成立，所以$T(\\lfloor n/2 \\rfloor)\\leq \\lfloor n/2\\rfloor \\lg(\\lfloor n/2\\rfloor)$，代入原表达式，原表达式为 $$ T(n)\\leq 2(c\\lfloor n/2\\rfloor \\lg(\\lfloor n/2\\rfloor))+n \\\\ \\leq cn \\lg(n/2)+n \\\\ = cn\\lg n-cn\\lg 2+n \\\\ = cn\\lg n +(1-c)n $$ 所以只要取$c\\leq1$即能满足$n$也符合猜测。 注意，在数学归纳法中，边界条件也要符合猜测，在本例中，如果$T(1)$即为第一个表达式，那么需要满足$T(1)\\leq 1\\lg(1)=0$，但往往在$T(1)$情况下，时间为常量，于是这就存在了矛盾。为了解决这个矛盾，我们可以假设式子是在大于一个常数$n_0$情况下才满足，那么边界条件也就成为了$n_0$。 Subtleties 有的时候，我们可以猜出正确的表达式，但是无法正确的证明，如表达式 $$ T(n)=T(\\lfloor n/2 \\rfloor)+T(\\lceil n/2 \\rceil)+1 $$ 猜测时间复杂度为$T(n)=O(n)$，于是尝试想证明$T(n) \\leq cn$，同样我们假设在$&lt;n$的情况下条件满足，即 $$ T(n) \\leq c\\lfloor n/2 \\rfloor + c \\lceil n/2 \\rceil+1 \\\\ =cn+1 $$ 这只能表明，$T(n)\\leq cn+1$但不能证明想要的$T(n)\\leq cn$。 但可以通过一个有更低项的表达式来证明我猜测，如$T(n)=cn-d$，$d$为大于0的常数，代入上式得， $$ T(n) \\leq (c\\lfloor n/2 \\rfloor -d)+ (c \\lceil n/2 \\rceil -d )+1 \\\\ =cn-2d+1\\\\ =cd -d -(1-d) $$ 那么只要取$d\\geq 1$就能满足猜测表达式。 这与通常的直觉相反，因为我们在证明$T(n)=cn$时失败了，那在再次尝试时，应该猜一个值更大的函数，但是我们用了一个值更小（减去了一个更小项）的函数却证明成功了。这是因为通常猜测的表达式越接近答案，证明过程也就越严格，所以我们取了一个相离较远相对宽松的值反而容易证明。 Avoiding pitfalls 避免跌入证明的陷阱里，我们在证明时要确认最终的表达式确实是我们想要的式子。例如在猜测式子$T(n)=2T(\\lfloor n/2 \\rfloor)+n$的复杂度，猜测$T(n)=O(n)$，即需要证明$T(n)\\leq cn$，代入式子可得 $$ T(n)\\leq 2(c\\lfloor n/2 \\rfloor)+n \\\\ \\leq cn+n \\\\ = (c+1)n $$ 这时候很容易错误的认为$\\leq (c+1)n$即满足了$\\leq cn$，但$c$是我们指定的常量，小于$c+1$并不一定小于$c$，所以猜测并不成立。 Changing variables 有时候一些代数变换可以帮助猜测出解，如有式子 $$ T(n)=2T(\\lfloor \\sqrt{n} \\rfloor)+\\lg n $$ 可以将$m=\\lg n$即$n=2^m$代入上式，得 $$ T(2^m)=2T(2^{m/2})+m $$ 再将$T(2^m)$的关系表示为$S(m)$，得 $$ S(m)=2S(\\frac{m}{2})+m $$ 此时，式子的表达与归并排序相同，所以可得$S(m)=O(m\\lg m)$，将$m= \\lg n$带回式子，得 $$ S(\\lg n)=O(\\lg n \\lg \\lg n) $$ 又$S(m)=T(2^m)$所以$S(\\lg n)=T(2^{\\lg n})=T(n)$ 所以 $$ T(n)=O(\\lg n \\lg \\lg n) $$ The recursion-tree method for solving recurrences 在递归树中，每一个节点都表示一个子问题的花费，整个问题的时间花费即为所有节点的花费总和。在计算时我们通常计算树的每一层的花费，然后再将所有的层数花费累加进而得到整棵树的花费。 通常在使用递归树时，我们会忽略一些细节，得到一个近似的答案作为猜测，再使用代入法去验证。当然也可以事无巨细的使用递归树来作为时间复杂度的证明。 如需要求得式子$T(n)=3T(\\lfloor n/4 \\rfloor)+\\Theta(n^2)$的时间复杂度，我们首先忽略向下取整，变为求式子$T(n)=3T(n/4)+cn^2$ 这个式子可以拆分为下图所示 $T(\\frac{n}{4})$又可以表达为$T(\\frac{n}{4})=3T(\\frac{n}{16})+c(\\frac{n}{4})^2$，于是树可以进一步拆分为： 同理类推，最终树可以拆分为: 每一层都对需要平方的$n$除以4，直到最后变为1，设最后一层（数值为1）的层数为$i$，则有表达式 $$\\frac{n}{4^i}=1$$ 注意，这里的x取值是从0，所以第一层的数值为$n(\\frac{1}{4})^0=n$，求得最后一层的层数为 $$i=\\log_4n$$ 因为是从0开始，所以总层数为$\\log_4n+1$ 设行数为$i$，则每一层的节点数为$3^i$，每个节点为$c(\\frac{n}{4^i})^2$，所以每一层的值为 $$ 3^ic(\\frac{n}{4^i})^2\\\\ =(\\frac{3}{16})^icn^2 $$ 所以整棵树的时间为 $$ T(n)=\\sum_{i=0}^{\\log_4n-1}(\\frac{3}{16})^icn^2+3^ {\\log_4n}\\Theta(1)\\\\ =\\sum_{i=0}^{\\log_4n-1}(\\frac{3}{16})^icn^2+ n\\log_43\\Theta(1)\\\\ =\\sum_{i=0}^{\\log_4n-1}(\\frac{3}{16})^icn^2+ \\Theta(n\\log_43) $$ 上式为等比数列，可以套等比数列公式求得，但我们可以先进一步简化 $$ T(n)=\\sum_{i=0}^{\\log_4n-1}(\\frac{3}{16})^icn^2+ \\Theta(n\\log_43) \\\\ \\leq \\sum_{i=0}^{\\infty}(\\frac{3}{16})^icn^2+ \\Theta(n\\log_43) \\\\ $$ 这时套入等比公式 $$\\sum _{k=0}^{\\infty}x^k=\\frac{1}{1-x}$$ 可得 $$ T(n)\\leq \\sum_{i=0}^{\\infty}(\\frac{3}{16})^icn^2+ \\Theta(n\\log_43) \\\\ =\\frac{1}{1-{\\frac{3}{16}}}cn^2+\\Theta(n\\log_43) \\\\ =\\frac{16}{13}n^2+\\Theta(n\\log_43)\\\\ =0(n^2) $$ 之后可以用代入法来验证结果 需要证明的就是$T(n)\\leq dn^2$ $$ T(n^2)\\leq 3d(n/4)^2+cn^2//// =\\frac{3}{16}dn^2+cn^2 $$ 只要$\\frac{3}{16}d+c$&lt;$d$，即可满足条件，即$d\\geq \\frac{16}{13}c$即可 The Master method for solving recurrences 主方法提供了针对形如$T(n)=aT(n/b)+f(n)$的一系列迭代算法的复杂度计算套用公式。 主方法定理存在三个情况： 如果存在常量$\\epsilon$满足$f(n)=O(n^{\\log_ba-\\epsilon})$，则$T(n)=\\Theta(n^{\\log _ba})$ 如果有$f(n)=\\Theta(n^{\\log_ba})$，则$T(n)=\\Theta(n^{\\log_ba}\\lg n)$ 如果存在常量满足$f(n)=\\Omega(n^{\\log_ba+\\epsilon})$，且对于足够大的$n$，存在常量$c&lt;1$满足$af(n/b)\\leq cf(n)$，则$T(n)=\\Theta(f(n))$ 可以发现定理的三个情况都是$f(n)$对$n^{\\log_ba}$的比较。而且要注意$\\epsilon$的存在，他表示关系式都必须是多项式渐进大于或多项式渐进小于。需要“即使相差一个因子$n^\\epsilon$，不等式仍然成立“。 Using the master method 式子$T(n)=9T(n/3)+n$ 可知$a=9,b=3,f(n)=n$，$n^{\\log_ba}=n^2$，只要$\\epsilon&lt;=1$，都可满足$f(n)=O(n^{\\log_ba-\\epsilon})$，符合条件一，时间复杂度为$T(n)=\\Theta(n^2)$ 式子$T(n)=T(2n/3)+1$ 可知$a=1,b=3/2,f(n)=1$，$n^{\\log_ba}=n^{\\log_3/21}=n^0=1$，即$f(n)=1=\\Theta(1)=\\Theta(n^{\\log_ba})$，所以满足条件二，时间复杂度为$T(n)=\\Theta(\\lg n)$ 式子$T(n)=3T(n/4)+n\\lg n$ 可知$a=3,b=4,f(n)=n\\lg n,n^{\\log_ba}=n^{\\log_43}=n^{0.793}$，取$\\epsilon$足够小，如取0.1则满足$f(n)=n\\lg n=\\Omega (n^{0.89})$ 如果要满足条件三，仍然需要满足，存在$c$使得$af(n/b)\\leq cf(n)$，即需要满足$\\frac{3n}{4}\\lg \\frac{n}{4}\\leq cn\\lg n$ $$\\frac{3n}{4}\\lg \\frac{n}{4}=\\frac{3n}{4}\\lg n -\\frac{3}{2}n$$ 如果取$c=3/4$，则不等式可以转换为 $$ \\frac{3n}{4}\\lg n -\\frac{3}{2}n \\leq \\frac{3n}{4}\\lg n $$ 条件满足，所以原式子满足条件三，所以结果为$T(n)=\\Theta(n\\lg n)$ 式子$T(n)=2T(n/2)+n\\lg n$ 可知$a=2,b=2,f(n)=n\\lg n,n^{\\log_ba}=n$ 因为$f(n)=n\\lg n$大于$n^{\\log_ba}=n$，所以很容易误以为这个式子满足条件三，但实际上条件需要满足多项式渐进大于，在本例子中需要存在一个$\\epsilon$，使得$\\lg n$渐进大于$n^{\\epsilon}$，但对于任意$\\epsilon &gt;0$，这个式子都不满足。所以这个式子并不满足条件三，不能使用主方法来求得时间复杂度。 Proof of the master theorem //TODO 引用： Introduction to Algorithms 3rd Sep.2009","link":"/IA-Chapter4-Notes/"},{"title":"《如何阅读一本书》 笔记","text":"《如何阅读一本书》思维导图、简评、笔记与摘要。 简评 反思了下自己2018年的读书或许自己太注重读书的量而没有关心读书的质，以至于许多的书看过后并没有留下什么印象。想起了曾经在Kindle上读过的《如何阅读一本书》，这本书在当时给自己留下了很深的印象，但没有付诸于实践。在春节假期的后半段决定重写阅读这本书来帮助自己在新的一年提高阅读的质量。 读书过程中按照书的章节做了完整的笔记与摘要，笔记与摘要内容很长，没必要完整阅读，主要是为了以后如果需要复习可以回忆起特定章节的内容。同时为了以后可以快速回忆起整本书的主要建议，整理了对应的思维导图。 合格的阅读应该是带有主动思考的阅读，作者认为主动阅读需要回答四个基本问题： 整体而言，这本书到底在谈些什么？ 作者局部细说了什么？怎么说的？ 这本书说的有道理吗，是全部有有道理还是部分有道理？ 这本书跟你有什么关系？如果这本书给了你一些资讯，你一定要问问这些资讯有什么意义。 作者提出要通过三个层次的阅读来回答这四个问题：检视阅读、分析阅读、主题阅读，并分别讲解了每个层次中需要遵循的规则或要点。 作者还分别解析了面对不同种类的书籍该如何调整这些规则与要点，并给出了阅读特定种类书籍的建议。 全书主要关注的是主动阅读中该如何去有效的思考，这样的一个较高层次的指导，针对于读书过程中如何做笔记以及如何整理书中的内容这样更实践性的指导仅是一笔带过。 思维导图 笔记与摘要 阅读的层次 阅读的活力与艺术 信息时代使得人们可以轻易的获取大量的知识，这些知识也包括了媒体人经过设计和包装后再次传递出来的知识。但这样的行为实际上让平常人失去了独自思考的能力，并且将他人的结论误认为是“自己”的成果。 太多的资讯就如同太少的资讯一样，都是一种对理解力的阻碍。换句话说，现代的媒体正以压倒性的泛滥资讯阻碍了我们的理解力。 如何将知识分子的态度与观点包装起来，是当今最有才智的人在做的最活跃的事业之一。 主动阅读 读书或多或少是一个主动的行为，人总不能眼神呆滞放空大脑还能进行有效的阅读。作者和读者的关系如同投手和打击手，读书是一个作者和读者配合的工作。作者在写书时会考虑该怎样让读者理解，而读者则要学会如何理解作者的各种表达方式和内容。 第一提醒读者，阅读可以是一件多少主动的事。第二要指出的是，阅读越主动，效果越好。 其实完全相反，听众或读者的“接收”，应该像是棒球赛中的捕手 才对。 捕手在接球时所发挥的主动是跟投手或打击手一样的。 捕手的艺术就在能接住任何球的技巧—— 快速球、曲线球、变化球、慢速球等等。同样地，阅读的艺术也在尽可能掌握住每一种讯息的技巧。 阅读的目标：为获取资讯而读，以及为增进理解而读 阅读的目标分为两种，一是为获取资讯而读，二是为增进理解而阅读。 例如一个人对于美国历史已经有了一部分的了解，也有一些自己的理解。当一份新的资料，他用自己原先的理解角度完全可以解释的话，那这份资料的阅读就只是第一种阅读，而如果在新资料中他获得了新的理解，那就是第二种阅读了。 为获取资讯而读 如果很了解，你就获得了资讯（但你的理解力不一定增强）。…这本书的讯息只是将你还没读这本书之前你们便共同了解的东西传达出来而已。…这样的读物能增加我们的资讯，却不能增进我们的理解力，因为在开始阅读之前，我们的理解力就已经与他们完全相当了。 为增进理解而读 只有一种方式是真正地在阅读。没有任何外力的帮助，你就是要读这本书。你什么都没有，只凭着内心的力量，玩味着眼前的字句，慢慢地提升自己，从只有模糊的概念到更清楚地理解为止。这样的一种提升，是在阅读时的一种脑力活动，也是更高的阅读技巧。 这是一个凭借着头脑运作，除了玩味读物中的一些字句之外，不假任何外助，以一己之力来提升自我的过程。 这个东西的水平就是比阅读的人高上一截。这个作者想要表达的东西，能增进阅读者的理解力。 阅读就是学习：指导型的学习，以及自我发现型学习之间的差异 学习的过程，首先是吸收资讯，之后是被这些资讯启示进而提升理解力。 如果你运用的只是你的记忆力，其实你除了那些讯息之外一无所获。你并没有被启发。要能被启发，除了知道作者所说的话之外，还要明白他的意思，懂得他为什么会这么 初学者的无知在于未学，而学者的无知在于学后。”第一种的无知是连字母都没学过，当然无法阅读。第二种的无知却是读错了许多书。英国诗人亚历山大·蒲伯（Alexander Pope）称这种人是书呆子，无知的阅读者。总有一些书呆子读的太广，却读不通。 指导型学习和自我发现型学习的区别并非指导型学习是被动的，自我发现型学习是主动的，两者都是主动的，没有一种学习是死气沉沉的，指导型学习更确切的可以表达为“辅助型的自我发现学习。” 事实上，要区分得更清楚一些的话，我们可以称指导型的学习是“辅助型的自我发现学习”。 两者的主要区别实际在于教材，前者是基于他们传递的讯息，后者则是自我和世界。 当他被指导时，在老师帮助下自我发现时，学习者的行动立足于传达给他的讯息。 当学习者在没有任何老师指导帮助下开始学习时，学习者则是立足于自然或世界，而不是教导来行动。 非辅助型的自我发现学习——是阅读自我或世界的学习。就像指导型学习（被教导或辅助型学习）是阅读一本书，包括倾听，从讲解中学习的一种艺术。 两种学习方法都需要用到思考。不同的是，在自我发现型的学习中在思考后还会凭借自己的感觉去运用想象，而这是在指导型学习中被遗忘或忽略的过程。 思考只是主动阅读的一部分。一个人还必须运用他的感觉与想象力。一个人必须观察，记忆，在看不到的地方运用想象力。我们要再提醒一次，这就是在非辅助型的学习中经常想要强调的任务，而在指导型的任务，或倾听学习中被遗忘或忽略的过程。 阅读的艺术包括了所有非辅助型自我发现学习的技巧：敏锐的观察、灵敏可靠的记忆、想象的空间，再者当然就是训练有素的分析、省思能力。 老师的出席与缺席 上一节阐述指导型学习的过程中，举了阅读和倾听两个例子，倾听存在有活生生的老师教导，而阅读往往只能靠自己。 倾听是从一位出现在你面前的老师学习——一位活生生的老师——而阅读确实跟一位缺席的老师学习。 如果一本书就是你的老师的话，你就得一切靠自己。 本书的目的就是教导读者如何靠自己更好的阅读一本书。 阅读的层次 第一层阅读：基础阅读 基础阅读解决的是认出书中所有的字符和知道这些话在说什么。基础阅读基本在小学阶段就已经训练完毕。这一层阅读的熟练与否也影响阅读的速度。 大部分的困难都是技术性的问题，有些可以追溯到早起阅读教育的问题。因此，大部分的速度课程都着眼在这个层次的阅读上。 第二个阅读：检视阅读 这个层次也称为略读或预读，检视阅读解决的问题是在一段时间内了解到一本书的重点。在这个层次阅读中需要从表面观察这本书，了解到这本书在谈些什么，框架是怎样的。大部分人往往都忽略了检视阅读的重要性。 因此，用另一种方式来形容这个层次的阅读，就是在一定的时间之内，抓出一本书的重点 我们想要强调的是，大多数人，即使是许多优秀的阅读者，都忽略了检视阅读的价值。他们打开一本书，从第一页开始读起，孜孜不倦，甚至连目录都不看一眼。因此，他们在只需要粗浅翻阅一本书的时候，却拿出了仔细阅读、理解一本书的时间。 第三层阅读：分析阅读 分析阅读就是全盘、完整、仔细的阅读。 如果说检视阅读是在有限的时间内，最好也最完整的阅读，那么分析阅读就是在无限的时间里，最好也最完整的阅读。 弗兰西斯·培根曾经说过：“有些书可以浅尝即止，有些书是要生吞活剥，只有少数的书是要咀嚼与消化的。”分析阅读就是要咀嚼与消化一本书。 第四层阅读：主题阅读 主题阅读是最复杂、最系统化、最主动、最花力气的阅读。主题阅读需要读者在不同的书之间找到相关之处，甚至于得出一个哪本书中都没有提过的结论。 在做主题阅读时，阅读者会读很多的书，而不是一本书，并列举出这些书之间相关之处，提出一个所有的书都谈到的主题。 借助他所阅读的书籍，主题阅读者要能架构出一个可能在哪一本书中都没有提到的主题分析。 阅读的第一个层次：基础阅读 学习阅读的阶段 第一个阶段为阅读准备阶段，这一阶段从出生开始到6-7岁为止，包括身体和智力方面的准备，如有良好的视力和听力，有基本的认知能力等。 第二个阶段，孩子会阅读一些简单的读物，在这个阶段中，孩子会有一些基本的阅读技巧如字句的使用，字句的含义等。 第三个阶段，孩子会拥有快速建立字汇的能力，通过上下文提供的线索，去猜测不熟悉的字眼。同时在这个阶段孩子也会自发性的去阅读 第四个阶段，精炼与增进前面所学的技巧。在这个阶段学生开始消化他的阅读经验，可以对作者提出的观点进行比较。 这通常一个完成了正常学业的成年人都是已经通过了这四个阶段的。 阅读的阶段与层次 当一个人通过了上述四个阶段时，他便已经精通了第一个层次的阅读，但也仅此而已。 一般而言，在度过四个阶段时，都有老师相伴，都是辅助型的自我发现阅读。而之后的阅读便会开始非辅助型自我发现阅读。 更高层次的阅读与高等教育 一个人文素养优良的高中，就算什么也没做，也该培养出能达到分析阅读的读者。一个优秀的大学，就算什么也没贡献，也该培养出能进行主题阅读的读者。 阅读与民主教育的理念 我们一定要比一个人人识字的国家更进一步。我们的国人应该变成一个个真正“有能力”的阅读者，能够真正认知“有能力”这个字眼的含义。 阅读的第二个层次：检视阅读 检视阅读一：有系统的略读或粗读 略读的步骤： 看书名页，有序就先看序，对书的主题有个概念。 研究目录页，对书的基本架构做概括性的理解。 检阅书的缩影，快速评估这本书涵盖了哪些议题。 如果是新书，看下书衣上出版者的介绍。 上述四个步骤完成后，基本对于一本书已经有了基本的资讯。如果是决定要仔细读或者决定不读，这时将书放在一边，否则便继续做一下的略读。 在第二步看完目录页后，挑些认为和主题息息相关的篇章看看。 把书随便翻翻，任意读个一两段，以这样的方式把全书翻阅一遍，寻找主要论点的讯号，留意主题的基本脉动。也可以直接看书的最后几页，因为往往作者会在最后几页中整理自己的观点。 上述的六个步骤应该在一小时内完成。 你可以把自己想做一个侦探，在寻找一本书的主题或思想的线索。随时保持敏感，就很容易让一切状况清楚。 检视阅读二：粗浅的阅读 粗浅的阅读即在阅读过程中发现自己理解不了的部分，就略过继续读下去，读到能读懂的部分就继续看下去，这样先对书有一个了解。在之后的阅读中，这部分的了解会帮助理解那些难懂的部分。 头一次面对一本难读的书的时候，从头到尾先读一遍，碰到不同的地方不要停下来查询或思索。 阅读的速度 速读和检视阅读都是加快读书的速度，但速读更多层面上时解决基础阅读层面的困难。检视阅读之所以快是因为读者只读了书中一小部分，而且是用不同的方式去读，不同的目标去读。 检视阅读的两个方式都需要快速的阅读，一个熟练的检视阅读者想要读一本书时，无论碰到多难读或多长的书，都能很快的运用者两种方式读完。 许多书其实是连略读都不值得的，另外一些书只需要快速读过就可以了。有少数的书需要用某种速度，通常是相当慢的速度，才能完全理解。 逗留与倒退 速读解决了基础阅读的两个问题，逗留和倒退，我们可以用手引导眼睛来解决问题。 许多人在阅读时会用半出声的方式阅读，在阅读一行字的时候在五六个地方发生逗留，而且常在每阅读两三行之后，眼睛就自然地“倒退”。这些都很大程度影响了阅读的速度。 纠正的方法也很简单，用手指着段落且手移动的速度大于眼睛看的速度，这样持续的增加手的速度，阅读的速度也就相应地提高了。 理解的问题 速读课程在增加阅读速度的同时也增加了理解力，因为要保证快速的阅读速度，读者也只能专注于阅读的东西上。但理解力也不仅仅等同于专注力，它往往还有超越了基础阅读的部分，这也是这本书需要讨论的部分。 检视阅读的摘要 检视阅读的两个步骤都是分析阅读之前的预备动作。 如何做一个自我要求的读者 在阅读时保持清醒或昏昏欲睡取决的于阅读的目标是否是获得利益，如果是则就会保持清醒，也会在阅读时尽可能的保持主动。 主动阅读的基础：一个阅读者要提出的四个基本问题 整体而言，这本书到底在谈些什么？ 作者局部细说了什么？怎么说的？ 这本书说的有道理吗，是全部有有道理还是部分有道理？ 这本书跟你有什么关系？如果这本书给了你一些资讯，你一定要问问这些资讯有什么意义。 这四个问题是阅读的基本规则，也是在分析阅读中要讨论的主要议题。 任何一种超越基础阅读的阅读层次，核心就在你要努力提出问题。这也是有自我要求的阅读者与没有自我要求的阅读者之间，有天壤之别的原因。 在阅读的过程中，要记得提出这些问题。除此之外，你还要知道如何精准、正确地回答这些问题。如此训练而来的能力，就是阅读的艺术。 检视阅读可以给出前两个问题的一部分答案，同时也对后两个问题有帮助。分析阅读则要回答第三个问题，最后一个问题是主题阅读中最重要的部分。 如何让一本书真正属于你自己 要完全拥有一本书，必须把书的一部分变成自己的一部分，而这个最好的方法就是写下来。 为什么对阅读而言，在书上做笔记是不可或缺的事 那会让你保持清醒 阅读如果是主动的，便会有思考，而思考的表现就是用语言表达出来——无论是说出来还是写出来 将自己的感想写下来，能帮助理解作者的思想 有以下几种记笔记的方法 画底线 强调 在底线处外的栏外再加画一道线 再次强调 在空白处做星号或其他符号。要慎用，只用来强调书中十来个最重要的声明或段落即可。 在空白处编号，记录下作者某个论点的一连串论述 在空白处记下其他的页码。把相关的要点集中在一起。 将关键字或句子圈起来——这与画底线的功能是一样的 在空白处做笔记。写下问题或者自己想法 也可以在书前面的空白页上写下自己的想法或整理全书的大纲。 三种做笔记的方法 结构笔记 在检视阅读的过程中，要回答的问题是：第一，这是本什么样的书？第二，整本书在谈的是什么？第三，作者是借着怎样的整体框架来发展他的观点或陈述他对这个主题的理解？你应该做笔记把这些答案写下来。 检视阅读时做的结构笔记在之后的分析阅读中将会派上用处。 概念笔记 等你做分析阅读时，关于这本书准确性与意义的问题，你就要提出答案了。在这个层次的阅读里，你做的笔记就不再是跟结构有关，而是跟概念有关了。 辩证笔记 对一个已经熟练同时读好几本相同主题书籍的专业阅读者来说，还有一个更高层次的记笔记的方法，那就是针对一场讨论情境的笔记。 培养阅读的习惯 各种阅读方法都是一种规则，而将规则变化为习惯需要大量的练习。这些规则在现在看来是割裂的，但当我们真正熟练时，规则便会融为一体。这就如同学习滑雪的过程，一开始也需要学习一个个单一的动作，但最终这些动作都会连接在一起。 要养成习惯，除了不断的运作联系之外，别无他法。 知道一项艺术的规则，跟养成习惯是不同的。 而你不能照规则来做，就不可能养成一种艺术或任何技能的习惯 换句话说，你一定要学会忘掉哪些分开的步骤，才能表现出整体的动作，而每一个单一的步骤都还要确实表现的很好。但是为了要忘掉这些单一的动作，一开始你必须先分别学会每一个单一的动作。只有这样，你才能将所有的动作连接在一起。 一开始是，学习者只会注意到自己与那些分开来的动作。等所有分开的动作不再分离，渐渐融为一体时，学习者便能将注意力转移到目标上，而他也具备了达成目标的能力了。 阅读的第三个层次：分析阅读 一本书的分类 书籍分类的重要性 分析阅读的第一步需要知道自己读的是什么种类的书。 分析阅读的第一个规则可以这么说：规则一，你一定要知道自己在读的是哪一类书，而且要越早知道越好。最好早在你开始阅读之前就先知道。 一本论说性的书的主要目的是在传达知识。 分析阅读的第一个规则，虽然适用于所有的书籍，却特别适合用来阅读非小说，论说性的书。 通过之前的检视阅读来完成这一规则 之前我们已经建议过，一开始时，你要先检视这本书——用检视阅读先浏览一遍。 从一本书的书名中你能学到什么 许多人常不去看书名的原因是因为觉得书籍的分类是没有必要的。但书籍的分类并不是最终目的，最终目的是了解到这一种类的书具体在谈些什么。 书籍分类存在有一些标准，首先可以分为虚构的小说类和传递知识的论述类，而论述类又可以再细分。 我们会指出这个普遍的错误，是因为许多人以为他们知道这本书的书名，而事实上只有少之又少的人真的用心读过书名，也想过其中的含意。 许多人会忽略书名或序言的原因之一是，他们认为要将手边阅读的这本书做分类是毫无必要的。 只有当你在不同的书籍之间能找出区别，并且定出一些合理又经得起时间考验的分类时，这个规则才会更简单明白一些。 光是将书籍分类到某一个种类中还是不够的。要跟随第一个阅读步骤，你一定要知道这个种类的书到底是在谈些什么？ 除了实用手册与（广义的）道德论述之外，另一种实用型的作品也要提一下。任何一种演说，不论是政治演说或道德规劝，都是想告诉你该做些什么，或你该对什么事有什么样的反应。 实用性vs理论性作品 理论性书籍教导知识，实用性书籍引导行动。 实用是与某种有效的做法有关，不管是立即或长程的功效。而理论所关注的却是去明白或了解某件事。如果我们仔细想想这里所提出来的粗略的道理，就会明白知识与行动之间的区别。 理论性的作品是在教你这是什么，实用性的作品在教你如何去做你想要做的事，或你认为应该做的事。 严格来说，任何一本教我们如何生活，该做什么，不该做什么，同时说明做了会有什么奖赏，不做会有什么惩罚的伦理的书，不论我们是否同意他的结论，都得认定这是一本实用的书。 理论性作品的分类 如果一本理论的书所强调的内容，超乎你日常、例行、正常生活的经验，那就是科学的书。否则就是一本哲学的书。 既然书本所要传达给我们的知识不同，对我们的指导方式也会不同。 透视一本书 书的架构如同人的骨架，分析阅读的目的就在意找出这个骨架。无论什么书存在架构，即使是小说、诗集。 分析阅读的第二个规则：使用一小段文字来叙述整本书的内容。书籍的分类让读者明白了这是本怎么样的书，这里我们要进一步知道这本书要干什么。 分析阅读的第三个规则：将书中重要的篇章列举出来，说明他们如何按照顺序组成一个整体的架构。 每一本书的封面之下都有一套自己的骨架。作为一个分析阅读的读者，你的责任就是要找出这个骨架。 但是，任何一本值得读的书，都会有一个整体性与组织架构。否则这本书会显得乱七八糟，根本没法阅读。而烂书就是如此。 分析阅读的第二个规则是：使用一个单一的句子，或最多几句话（一小段文字）来叙述整本书的内容。 必须能用几句话，告诉你自己，或别人，这整本书在说的是什么。（如果你要说的话太多，表示你还没有将整体的内容看清楚，而只是看到了多样的内容。） 第三个规则可以说成是：将书中重要篇章列举出来，说明它们如何按照顺序组成一个整体的架构。 一本好书，就像一栋好房子，每个部分都要很有秩序地排列起来。每个重要部分都要有一定的独立性。 但是却一定要跟其他部分连接起来——这是与功能相关——否则这个部分便无法对整体的智能架构作出任何贡献了。 结果与规划：叙述整本书的大意 关于第二个规则的两个建议：一是书的作者本身很可能已经整理的书的重点，通常在序言中，二是我们不需要把作者整理的重点作为唯一的说明。 首先，一位作者，特别是好的作者，会经常想要帮助你整理出他书中的重点。 其次，是要小心，不要把我们提供给你的那些书的重点摘要，当作是它们绝对又唯一的说明。 驾驭复杂的内容：为一本书拟大纲的技巧 第二规则和第三规则的联系在于，第二规则着重与整体，而第三规则强调复杂度，且运用第二规则抓住整体后会有助于我们用第三规则对重要部分进行透视。 可以参考这个公式来进行大纲的罗列。 我们可以依照第三个规则，将内容大纲排列如下：（1）作者将全书分成五个部分，第一部分谈的是什么，第二部分谈的是什么，第三部分谈的是别的事，第四部分则是另外的观点，第五部分又是另一些事。（2）第一个主要的部分又分成三个段落，第一段落为X，第二段落为Y，第三段落为Z。（3）在第一部分的第一阶段，作者有四个重点，第一个重点是A，第二个重点是B，第三个重点是C，第四个重点是D等等。 第三规则对于第二规则的重要性在于：除非遵循规则三，否则无法有效的运用规则二。如果读者没有用规则三理解整本书的框架，那么规则二得出的整体性结论又如何保证正确呢？ 第二个规则在指导你注意一本书的整体性，第三个则在强调一本书的复杂度。要这样区分还有另一个理由。当你掌握住一本书的整体性时，便会立刻抓住其中一些重要的部分。但是这每个部分的本身通常是很复杂，各有各的内在结构需要你去透视。 你只要尽力而为就行了。毕竟，这个规则并没有要你将作者没有放进去的东西加在里面。你的大纲是关于作品本身的纲要，而不是这本书要谈的主题的纲要。 用另一种方法来说，就是除非你遵循规则三——要求你说明组成整体的各个部分——否则就没有办法有效地运用规则二——要求你作全书的重点摘要。 阅读与写作的互惠技巧 运用规则三实际上就是去透视一本书的骨架。对于写作者而言，对于骨架和血肉的理解也同样重要，写作者应该先有了一本书的骨架后再往上添加血肉。 如果作者跟老师无法将自己要传达的东西整理出架构，不能整合出要讲的各个部分的顺序，他们就无法指导读者和学生去找出他们要讲的重点，也没法发现全书的整体架构。 如果他是个好作者，就不会将一个发育不良的骨架埋藏在一堆肥肉里，同样的，也不会瘦得皮包骨，让人一眼就看穿。 书，真的就跟人或动物是一模一样的。——血肉，就是为纲要所作的进一步详细解释，或是我们有时候所说的“解读”（read out）。 发现作者的意图 在这一节阐述了第四个规则：找出写作者问的问题。第四个规则和前两条规则实际上是前后呼应的关系，在做规则二、三 时实际上就会完成规则四，而规则四则会帮助更好的完成规则二、三。 这第四个规则可以说是：找出作者要问的问题。一本书的作者在开始写作时，都是有一个问题或一连串的问题，而这本书的内容就是一个答案，或许多答案。 你应该有办法说出整本书想要解答的问题是什么。如果主要的问题很复杂，又分成很多部分，你还要能说出次要的问题是什么。你应该不只是有办法完全掌握住所有相关的问题，还要能明智地将这些问题整合出顺序来。哪一个是主要的，哪个是次要的？哪个问题要先回答，哪些是后来才要回答的？ 分析阅读的第一个阶段 四个规则将会提供读者对于一本书架构的认识。当完成了四个规则后，实际上我们就完成了分析阅读的第一个阶段，这一阶段主要探究的是一本书在谈些什么的问题（一本书的骨架）。要注意这里的阶段并非一个前后顺序的概念，没必要为了四个规则将一本书读一遍后又为了完全其他规则读一遍又一遍。 这四个规则在一起，能提供读者对一本书架构的认识。当你运用这四个规则来阅读一本书，或任何又长又难读的书时，你就完成了分析阅读的第一个阶段。除非你是刚开始练习使用分析阅读，否则你不该将“阶段”一词当作一个前后顺序的概念。 与作者找出共通的词义 从这里开始阐述分析阅读第二阶段，这个阶段也有四个规则。 第一个规则：找出共通的词义，找出单字，并且确认这些单字在使用时最精确的意义 1.只要模糊地带还存在，就表示作者和读者之间对这些单字的意义还没有共识。为了要达成完全的沟通，最重要的是双方必须要使用意义相同的单字——简单来说，就是，找出共通的词义达成共识。 单字VS.词义 每一个单字都有多种不同的解释，但单字在一段话中往往只有一个解释（论述书基本如此，小说和诗词会有例外），这就是词义。我们需要知道一本书的作者在这段话的中点的词义。 找出关键字 关键字很可能是让你头疼无法理解的词。 如果你把觉得有困扰的字圈出来，很可能就找出了作者有特定用法的那些字了。之所以会如此，是因为如果作者所用的都只是一般日常用语的含义，对你来说就根本不存在有困扰的问题了。 从一个读者的角度来看，最重要的字就是那些让你头痛的字。这些字很可能对作者来说也很重要。 专业用于及特殊词汇 一些在特定的专业词汇如点、线、面等，又如经济中财富，资本，土地这样的词汇。 事实上，你也会发现一些对你来说并不是日常用语的字，因而发现那是一些重要的字眼。 某些知识领域有一套完整的专门用语，在一本这种主题的书中找出重要的单字，相形之下就很容易了。 另外一个线索是，作者与其他作者争执的某个用语就是重要的字。 如果读者碰到一个不了解的字不愿意深思，或至少作个记号，那他不了解的这个字就一定会给他带来麻烦。 大多数人都习惯于没有主动的阅读。没有主动的阅读或是毫无要求的阅读，最大的问题就在读者对字句毫不用心，结果自然无法跟作者达成共识了。 找出字义 通过上下文的联系找出正确的词义。 首先，要判断这个字是有一个还是多重意义。如果有多重意义，要看这些意义之间的关系如何。最后，要注意这些字在某个地方出现时，使用的是其中哪一种意义。看看上下文是否有任何线索，可以让你明白变换意义的理由。最后这一步，能让你跟得上字义的变化，也就是跟作者在使用这些字眼时一样变化自如。 你一定要利用上下文自己已经了解的所有字句，来推敲出你所不了解的那个字的意义。 整个过程有点像是在玩拼图时尝试错误的方法。你所拼起来的部分越多，越容易找到还没拼的部分，原因只不过剩下的部分减少了。 判断作者的主旨 第五个规则与单字和词义有关，第六个规则与句子有关，我们要找到作者的主旨。而第七个规则与论述有关，我们需要通过一连串的句子来了解作者的论述过程。可以看到五六七规则是有逻辑联系的，从单字（或词）到句子再到一连串的句子。 书里的提案，也就是主旨，也是一种声明。那是作者在表达他对某件事的判断。 但是读者却要先与作者达成共识，才能明白作者的主旨是什么，以及他所声明的是什么样的判断。 第六个，也就是我们现在要讨论的，是与句子及提案有关的规则。 我们从共识谈到主旨，再谈到论点，表达的方法是从字（与词）到一个句子，再到一连串的句子（或段落）来作说明。 句子与主旨。 如同单字与词义一样，句子和主旨同样不是一一对应的。 在区分句子与主旨之间，我们已经说得够清楚了。它们并不是一对一的关系。不只是一个单一的句子可以表达出不同的主旨，不管是有歧义的句子或复合句都可以，而且同一个主旨也能用两个或更多不同的句子来说明。 第六个规则可以说是：将一本书中最重要的句子圈出来，找出其中的主旨。第七个规则是：从相关文句的关联中，设法架构出一本书的基本论述。 找出关键句 关键句的标志：首先是阐述作者判断的句子，其次是找到在规则五中遇到的关键字组成的句子。 从作者的观点来看，最重要的句子就是在整个论述中，阐述作者判断的部分。 找出组成关键句的文字来。如果你已经将重要的字圈出来了，它一定会引导你看到值得注意的句子。 但是当你想要在阅读中获得理解时，你要追寻的就不是那种新奇的感觉了。 就因为有这些原因，我们所讨论的规则是要帮助你理解一本书，而不是满足你的好奇心。 找出主旨 从关键句中找出主旨和找出关键字中的词义两者都需要从上下文中推导出作者真正的含义，但也有两个不同点。一是后者牵扯的内容比较多，二是一个复杂的句子往往包含了多个主旨。 测试是否真的懂了句子主旨的方法，一是用自己的话来将主旨重写表达一遍，二是举出一个自己所经历的主旨所描述的尽力。 在找出文字所表达的意思与句子所阐述的主旨之间，只有两个不同之处。一个是后者所牵涉的内容比较多。就像你要用周边的其他字来解释一个特殊的字一样，你也要借助前后相关的句子来了解那个问题句。 另一个不同是，复杂的句子通常要说明的不只一个主旨。除非你能分析出所有不同，或相关的主旨，否则你还是没有办法完全诠释一个重要的句子。 如果要求你针对作者所写的某个句子作解释，而你只会重复他的话，或在前后顺序上作一些小小的改变，你最好怀疑自己是否真的了解了这句话。 你能不能举出一个自己所经历过的主旨所形容的经验，或与主旨有某种相关的经验？ 找出论述 论述的基本单位是一系列先后有序，有时还带有例证和理由的主旨。分析阅读的第七个规则为：——找出论述的段落，如果没有则需要自己从不同的段落中找出关键句子，然后整理前后顺序的主旨进而形成论述。 论述的标志，一是所有的论述都包含声明，二是要记住有两种论述：以事例证明的归纳法和通过连串通则证明的演绎法，三是找到作者哪些事情认为是假设，哪些是能证明的，哪些是不证自明的。 指导我们阅读的第七个规则的逻辑单位，是“论述”——一系列先后有序，其中某些还带有提出例证与理由作用的主旨。 如果可以，找出书中说明重要论述的段落。但是，如果这个论述并没有这样表达出来，你就要去架构出来。你要从这一段或那一段中挑选句子出来，然后整理出前后顺序的主旨，以及其组成的论述。 首先，要记住所有的论述都包含了一些声明。其次，要区别出两种论述的不同之处。一种是以一个或多个特殊的事实证明某种共通的概念，另一种是以连串的通则来证明更进一步的共通概念。前者是归纳法，后者是演绎法。再次，找出作者认为哪些事情是假设，哪些是能证实的或有根据的， 找出解答 分析阅读的第一阶段（整理内容大纲）和第二阶段（诠释内容）后就是诠释一本书的最后步骤———找出解答。在第二阶段与作者达成共识，抓到他的主旨与论述后，我们应该提出更进一步的问题（在阶段四我们已经提出了基本问题——作者的问题是什么？），作者想要的问题哪些解决了？为了解决问题，他又引出了哪些问题？无论是新问题还是旧问题，哪些他知道自己还没有解决。第八个步骤便是找出这些问题的解答。 至此分析阅读的第二阶段已经完成，这一个阶段通过四个规则解决了一本书到底在说什么的问题（诠释一本书的内容，一本书的血肉）。 这也是诠释一本书的内容的最后一个步骤。除此之外，那也将分析阅读的第一个阶段（整理内容大纲）与第二阶段（诠释内容）连接起来了。 分析阅读的第二个阶段，或找出一本书到底在说什么的规则 公正的评断一本书 主动的阅读必须在懂得书之后评论并提出批评。评论及批评便是分析阅读的第三阶段也是最后一个阶段。 主动的阅读不会为了已经了解一本书在说些什么而停顿下来，必须能评论，提出批评，才算真正完成了这件事。 受教是一种美德 最能批评的读者往往是最能学习的读者，因为受教也是一种美德，当读者完全读懂一本书后，他便与这本书的作者有了平等的地位，这时候他应该整理出自己的想法，让书的作者受教。 受教或是能学习是一种极为主动的美德。一个人如果不能自动自发地运用独立的判断力，他根本就不可能学习到任何东西。 最能学习的读者，也就是最能批评的读者。这样的读者在最后终于能对一本书提出回应，对于作者所讨论的问题，会努力整理出自己的想法。 修辞的作用 一本书的写作过程中会有修辞让读者能更好的理解，作为读者修辞的作用则是知道别人尝试说服我们时该如何的回应及评论。 相对的，在读者或听者的立场，修辞的技巧是知道当别人想要说服我们时，我们该如何反应。同样的，文法及逻辑的技巧能让我们了解对方在说什么，并准备作出评论。 暂缓评论的重要性 分析阅读的第九规则：在评论前必须能肯定的说“我了解了”。所以对于一本书评价有“我同意”、“我不同意”和“我暂缓评论”，因为有些书籍需要读者有了相关的背景或读了其他的书后才能给出中肯的平价。 我们会认为这些原则代表一种礼节，让读者不只是有礼貌，还能有效地回话的礼节。 第九个规则：在你说出“我同意”，“我不同意”，或“我暂缓评论”之前，你一定要能肯定地说：“我了解了。” 避免争强好辩的重要性 分析阅读的第十原则：当不同意作者观点时，要理性表达自己的意见，不要无礼的辩驳或争论。 规则十：当你不同意作者的观点时，要理性地表达自己的意见，不要无理地辩驳或争论。 化解争议 把不同意见当做是有可能解决的问题。上一个原则时提醒不要争强好辩，这一个原则则是提醒不要绝望的与不同的意见抗争。因为不同的意见可能来自于情绪或者知识水平的不相当。所以与人对话时，即使有不同的意见，最终还是有希望达成共识。 真正的只是和个人的观点间是存在差异的，读者应当专注于真正知识。分析阅读规则十一：尊重知识与个人观点的不同，相信不同意见大体上是可解决的，读者要为自己的不同意见找到理论基础。 至此分析阅读的第三阶段完成，这一阶段通过三个规则教导读者如何在阅读后与作者进行“辩论”，探究作者是否正确与作者的论述是否完整。 第二个规则是敦促你不要争强好辩，这一个规则是提醒你不要绝望地与不同的意见对抗。 一个人在与别人对话时，就算有不同的意见，最后还是有希望达成共识。他应该准备好改变自己的想法，才能改变别人的想法。他永远要先想到自己可能误解了，或是在某一个问题上有盲点。 他们认为任何事都只是一个观点问题。我有我的观点，你也有你的，我们对自己的观点都有神圣不可侵犯的权利，就像我们对自己的财产也有同样的权利。如果沟通是为了增进知识，从这个角度出发的沟通是不会有收获的。 一个读者如果不能区别出知识的理论说明与个人观点的阐述，那他就无法从阅读中学到东西。他感兴趣的顶多只是作者个人，把这本书当作是个人传记来读而已。当然，这样的读者无所谓同意或不同意，他不是在评断这本书，而是作者本身。 读者要就真正的知识与他个人观点以及作者个人观点之不同之处，作出区分。 必须为自己的观点找出理由来。当然，如果他赞同作者的观点，就是他与作者分享同样的理论。但是如果他不赞同，他一定要有这么做的理论基础。否则他就只是把知识当作个人观点来看待了。 规则十一，尊重知识与个人观点的不同，在作任何评断之前，都要找出理论基础。 这三个规则在一起所说明的是批评式阅读的条件，而在这样的阅读中，读者应该能够与作者“辩论”。 赞同或反对作者 在赞同或反对作者前首先要做到的都是理解作者。 当你透过对一本书的诠释理解，与作者达成了共识之后，才可以决定同意他的论点，或是不同意他的立场。 偏见与公正 要与作者理想化的辩证就必须满足以下三种条件： 不要情绪化 把自己的前提和假设摊出来。因为一场好的辩论是不会为了假设而争吵的，对假设的争论往往是存在偏见的。 派别之争必然存在盲点，要解决这些盲点，应尽量做到不偏不倚。 作者给出了一套站在对立角度来评论一本书的方法： 书作者的知识不足 书作者的知识有错误 书作者的推论无法令人信服 书作者的分析不够完整 要作到理想化的辩论就必须满足以下三种条件： 第一点，因为人有理性的一面，又有动物的一面，所以在争辩时就要注意你会带进去的情绪，或是在当场引发的脾气。否则你的争论会流于情绪化，而不是在说理了。当你的情绪很强烈时，你可能会认为自己很有道理。 第二点，你要把自己的前提或假设摊出来。你要知道你的偏见是什么——这也是你的预先评断。否则你就不容易接受对手也有不同假设的权利。 第三点也是最后一点，派别之争几乎难以避免地会造成一些盲点，要化解这些盲点，应尽力尝试不偏不倚。 这套方法指出四种站在对立角度来评论一本书之道。我们希望即使读者想要提出这四种评论时，也不会陷入情绪化或偏见的状态中。 以下是这四点的摘要说明。 他可以用以下的概念向作者说明：（1）你的知识不足（uninformed）。（2）你的知识有错误（misinformed）。（3）你不合逻辑——你的推论无法令人信服。（4）你的分析不够完整。 判断作者的论点是否正确 上述批评的前两个角度都是在阐述书的作者的前提是有缺陷的，作者需要补充知识，第三个角度是说书的作者不合逻辑推论荒缪。 说一位作者知识不足，就是在说他缺少某些与他想要解决的问题相关的知识。 说一位作者的知识错误，就是说他的理念不正确。这样的错误可能来自缺乏知识，但也可能远不止于此。不论是哪一种，他的论点就是与事实相反。 这两个评论合在一起，指出的是作者的前提有缺陷。他需要充实知识。他的证据与论点无论在质与量上都还不够好。 说一位作者是不合逻辑的，就是说他的推论荒谬。一般来说，荒谬有两种形态。一种是缺乏连贯，也就是结论冒出来了，却跟前面所说的理论连不起来。另一种是事件变化的前后不一致，也就是作者所说的两件事是前后矛盾的。 判断作者论述的完整性 前三个批评角度是与作者的声明与论述相关的，如果读者读懂了一本书，而且无法找到证据来支持前三个批评点的话，那就只能同意作者的观点，你所能表达的最多是不喜欢。 第四个批评点是说整本书不完整架构存在问题，但一本书不能做到尽善尽美，所以批评者要指出哪些部分存在问题，不然这个问题就是毫无意义的。 我们刚谈过的前面三个批评点，是与作者的声明与论述有关的。 如果你说你读懂了，而你却找不出证据来支持前面任何一个批评点的话，这时你就有义务要同意作者的任何论点。这时你完全没有自主权。你没有什么神圣的权利可以决定同意或不同意。这时候你唯一能说的可能只是你“不喜欢”这个结论。你并不是在反对。你只在表达你的情绪或偏见。如果你已经被说服了，就该承认。（如果你无法提出证据来支持前三项批评点，但仍然觉得没有被作者说服，可能在一开始时你就不该说你已经读懂了这本书。） 第四点——这本书是否完整了——与整本书的架构有关。 说一位作者的分析是不完整的，就是说他并没有解决他一开始提出来的所有问题，或是他并没有尽可能善用他手边的资料，或是他并没有看出其间的含意与纵横交错的关系，或是他没法让自己的想法与众不同。…因此，作这样的评论是毫无意义的。除非读者能精确地指出书中的问题点。 分析阅读的三个阶段 前四个规则帮助回答第一个问题：这本书在谈些什么。后四个规则帮助回答第二个问题：作者是如何阐述的？剩下的三个阅读规则以及批评观点的特点解决了第三个与第四个问题，这本书是真实的吗？有意义吗？ 前三个问题都与人类语言的沟通特性有关，都是帮助我们更好的了解讯息和判断信息的准确，第四个问题则是区分了讯息与理解之间的差异。 上述的阅读规则等只是衡量阅读层次的理想标准，当我们评论一个人读得很好时，我们需要有一个标准来作为衡量依据。 本书在第七章结尾时，已经提出分析阅读的前四个规则，以便帮助你回答对一本书提出来的一个基本问题：这本书大体上来说是在谈些什么？同样的，在第九章的结尾，诠释一本书的四个规则能帮助你回答第二个问题，这也是你一定会问的问题：这本书详细的内容是什么？作者是如何写出来的？很清楚，剩下来的七个阅读规则——评论的智慧礼节、批评观点的特别标准——能帮助你回答第三与第四个基本问题。你一定还记得这两个问题：这是真实的吗？有意义吗？ 无论如何，这些规则只是衡量阅读层次的理想标准。 我们心中应该要有这些标准来作衡量的依据。太多时候，我们是用这样的句子来形容一个人阅读的量，而非阅读的质。 辅助阅读 前面提到的规则都是聚焦在书本身，这可以称为“内在阅读”，而辅助阅读或称外在阅读则是借助其他人来阅读一本书。我们免不了会把作者对某件事的声明与结论拿来和我们已知的进行比较，所以外在阅读是不可避免的，但有些读者太过于依赖外在阅读，所以这里要做些特殊说明。 辅助阅读的来源可以分为四个部分： 相关经验 其他的书 导论与摘要 工具书 我们免不了会把某一位作者对某件事的声明与结论，拿来跟我们所知的，许多不同来源的经验作比较。这也就是俗话说的，我们不应该，也不可能完全孤立地阅读一本书。 许多读者太依赖外在的辅助了，我们希望你了解这是毫无必要的。 外在的辅助来源可以分成四个部分。在这一章中，我们会依照以下的顺序讨论出来：第一，相关经验。第二，其他的书。第三，导论与摘要。第四，工具书。 相关经验的角色 有两种相关经验可以帮助我们阅读有困难的书，一般经验与特殊经验。一般经验来自于生活，他对一方面对阅读小说有关，一方面与阅读哲学书籍有关。特殊经验则来自于特殊经历或实验，一般与阅读科学性作品有关。而历史作品因其掺杂着科学与虚构，所以与两种经验都相关。 一般经验在一方面与阅读小说有关，另一方面与阅读哲学书籍有关。 特殊经验主要是与阅读科学性作品有关。 阅读历史作品，同时与一般经验及特殊经验都有关。这是因为历史掺杂着虚构与科学的部分。 其他的书可以当做阅读时的外在助力 许多伟大的作品都是有相互关联且存在先后顺序的，我们在读一本书时不能忽略这样的关系。在之前有提到看一本书时需要整理出书的脉络以帮助我们理解书，而相关性的书可以提供一个更大的脉络网。 许多伟大的作品不只是互相有关联，而且在写作时还有特定的先后顺序，这都是不该忽略的事。 外在辅助阅读的主要功用在于延伸与一本书相关的内容脉络。 就像一整本书的脉络是由各个部分贯穿起来一样，相关的书籍也能提供一个大型的脉络，以帮助你诠释你正在阅读的书。 如何运用导读和摘要 我们要尽量少用导读与摘要因为导读并不一定都是对的，而且导读会限制读者的想法，应该在完整阅读一本书后再阅读一本书的导读，否在你的思路很可能被导读带着走。 而摘要的作用一是可以唤醒读书时的记忆，二是在做主题阅读时，可以知道某些特定的议题与主题的相关性。但摘要是绝不能代替真正的阅读。 在运用这些资料时要特别聪明，也就是要尽量少用。这么说有两个理由。 第一，一本书的导读并不一定都是对的。 尽量少用导读的第二个原因是，就算他们写对了，可能也不完整。…阅读这类导读，尤其是自以为是的导读，会限制你对一本书的理解，就算你的理解是对的。 外在的阅读规则是除非你看完了一本书，否则不要看某个人的导读。这个规则尤其适用于一些学者或评论家的导言。 如果你已经看过全书，知道这些导读如果有错，是错在哪里，那么这样的导读就不会对你造成伤害。但是如果你完全依赖这样的书，根本没读过原书，你的麻烦就大了。 摘要的用途： 敌意，如果你已经读过一本书，这些摘要能唤醒你的记忆。…第二，在主题阅读时，摘要的用处很大，你可以因此知道某些特定的议题与你的主题密切相关。摘要绝不能代替真正的阅读，但有时却能告诉你，你想不想或需不需要读这本书。 如何运用工具书 工具书对矫正无知的功能是有限的，在使用工具书前必须要有一些自己的想法，其次还需要知道自己的问题属于哪一类，需要找哪一类的工具书。在正式工具书前，还要知道工具书是如何使用的。 工具书对矫正无知的功能是有限的。那并不能帮助文盲，也不能代替你思考。 首先你必须有一些想法，不管是多模糊的想法，那就是你想要知道些什么？你的无知就像是被光圈围绕着的黑暗。…其次，你一定要知道在哪里找到你要找的答案。你要知道自己问的是哪一类的问题，而哪一类的工具书是回答这类问题的。…你还必须有第三种知识。你必须要知道这本书是怎么组织的。 对一无所知的人来说，工具书可说是毫无用处。 如何使用字典 从一开始，教育的动机便左右了字典的编排，当然，保留语言的纯粹与条理是另一个原因。 即使如此，在你第一次阅读一本好书时，也不要急着使用字典，除非是那个字与作者的主旨有很大的关联，才可以查证一下。 如何使用百科全书 使用百科全书时不仅要找特定的知识，还要通过索引看彼此相关联的事实。 他基本上要找的是真实的知识，但他不能单独只看一种事实。百科全书所呈现给他的是经过安排的一整套的事实——一整套彼此相关的事实。 在这里，索引的功能就跟目录一样，不过并不十分理想。因为索引是在同一个标题下，把百科全书中分散得很广，但是和某一个相关主题有关的讨论都集中起来。 阅读不同读物的方法 如何阅读实用型的书 之前在分析阅读中提到的规则主要是以理论性的书作为模版探究出来的所以并不一定完全适用于任何书籍，特别是小说会有较大的出入。 两种实用性的书 任何实用性的书都不能解决书中提到的问题，理论性的书可以回答自己的提出问题，而实用性的书则必须依靠读者的行动才能完成。 实用性的书可以分为两类，一是在说明规则的书，如本书，二是阐述形成规则原理的书。 无论哪一种的试用书，我们都要找出规则该如何运用在实际中，这应当是了解任何一种实用性书籍的最高原则。所以评判实用性书籍不仅仅要判断作者的观点是否准确，还需要判断他的目标与自身的目标是否一致。 无论如何，你还是看得出来它是实用性的书。它要处理的那些问题的本质会露底。这样的书所谈的总是人类行为领域中，怎样可能做得更好或更糟。 你的判断主要是与结果达成共识，而非方法。就算方法非常真实有用，如果所达到的目的是我们不关心或不期望的结果，我们也不会有半点兴趣的。 说服的角色 实用性书籍的作者通常是一个雄辩家，因为他要作者相信他给出的建议。作为读者我们要能觉察出作者的雄辩，对他的推销存有抵抗力。 当你在阅读任何一种实用书时，一定要问你自己两个主要的问题。第一：作者的目的是什么？第二：他建议用什么方法达到这个目的？ 你可以知道为什么实用书的作者多少都是个雄辩家或宣传家。因为你对他作品最终的评断是来自你是否接受他的结论，与他提议的方法。这完全要看作者能不能将你引导到他的结论上。 不想被宣传所困惑，就得了解宣传的内容是什么。难以察觉的隐藏式雄辩是最狡猾的。那会直接打动你的心，而不经过你的头脑，就像是从背后吓你一跳，把你吓得魂不附体一样。 赞同实用书之后 读一本书时需要的四个问题，在阅读实用性书籍时需要一些调整。 第一个问题：这本书在谈些什么？ 并没有太大改变，仍然需要回答，并作出书的框架。 第二个问题：作者是如何表达的 改变也不大，我们仍然要找到作者的共识，主旨与论述。但规则四与规则八应调整为“找出作者想要你做什么”和“了解他要你这么做的目的”。 第三个问题：内容真实吗？ 这一条要改动的较多，实用性的书籍虽然也需对真实性做确认，判断作者的论述是否正确，但更重要的是判断是否接受作者最终的目的 第四个问题：这本书的意义？ 这一条完全改变了。理论性的书阅读后，我们对于主题的观点或许会存在改变，这便是理论书的意义，而这个改变并不需要采取行动。而赞同一本实用性的书，则需要确实的采取行动。 你在读一本书时要提出的四个问题，到了读实用性的书时有了一点变化。 赞同一本实用性的书，却确实需要你采取行动。如果你被作者说服了，他所提议的结论是有价值的，甚至进一步相信他的方法真的能达到目的，那就很难拒接作者对你的要求了。你会照着作者希望你做的方式来行动。 如何阅读想象文学 读想象文学的“不要” 作者首先阐述了论述性作品与文学作品的差异，通过这些来解释为何不能像读哲学作品般读小说。 首先论述性作品要传达的是知识，而文学作品要传达的是经验。文学作品通过描述和读者的想象力来增加读者的经验，所以我们不要抗拒想象文学带给你的影响力。 第二文学作品常会使用文字的多重字义而论述性作品则完全清晰没有其他含义。所以我们在想象作品中不要去找共识、主旨和论述。 最后我们不要用适用于传递知识，与真理一致的标准来批判小说，只要小说能够自圆其说就可以了。 不要抗拒想象文学带给你的影响力。 阅读一部伟大的文学作品的规则应该以达成某种深沉的经验为目标。这些规则应该尽可能去除我们体验这种深刻感受的阻碍。 在想象文学中，不要去找共识、主旨或论述。 我们也可以从小说在我们想象中所创造出来的经验中学习 不要用适用于传递知识的，与真理一致的标准来批评小说。 想象文学的一般规则 想象文学的规则也与其他书籍一样可分为三组：一是找到作品整体与部分的架构，二是定义和诠释书籍的内容，三是评论书籍。 对于第一组规则，想象文学需要首先将文学作品分类，如抒情诗，戏剧，小说等。二是要能抓住整本书的大意，看是否能用几句话概括情节。三是要能知道整本书是如何架构的，了解故事发展的脉络。 对于第二组规则： 前面说了小说不要去找共识、主旨和论述，但对于第二组规则，这三个元素是根本所在，所以想象文学的第二组规则需要进行对应的替换。 首先共识的载体是字词，小说则是插曲、事件、角色与他们的思想、语言、感觉及行动。如同在逻辑作品中需要和作者达成共识一样，阅读想象文学时需要对这些元素非常熟悉。 第二，共识与主旨的载体是句子，小说中则是场景与背景。读者要能在这个想象的场景中身临其境。 第三，论述对应了一系列的主旨，在小说中则是情节。 对于第三组规则： 在论述性作品中，这里的规则是在完全理解一本书之前不要表达同意或反对。在这里，规则应该对应改为——在由衷感激作者试着为你创造的经验之前，不要批评一本想象的作品。 因此在批评一本想象文学时，要客观的指出书中的哪些时间造成了方案。在表达喜好时也要表明理由。 除非你能简要地说明剧情——不是主旨或论述——否则你还是没有抓住重点。在情节中就有大意。 在小说中，这些部分就是不同的阶段，作者借此发展出情节来——角色与事件的细节。在安排各个部分的架构上，这两种类型的书各有巧妙。在科学或哲学的作品中，各个部分必须有条理，符合逻辑。在故事中，这些部分必须要在适当的时机与规划中出现，也就是从开头、中间到结尾的一个过程。 你要知道带来高潮的各种不同的关键是什么，高潮是在哪里、又如何发生的，在这之后的影响又是什么？ 这些要素就是逻辑作品中的共识。就像你要跟逻辑作品的作者达成共识一样，你也要能熟知每个事件与人物的细节。如果你对角色并不熟悉，也无法对事件感同身受，你就是还没有掌握到故事的精髓。 共识与主旨有关。小说的要素与整个表现的场景或背景有关。…阅读小说时类似指导你找出作者主旨的规则，可以说明如下：在这个想象的世界中宾至如归。知道一切事件的进行，就像你亲临现场，身历其境。 这些场景或背景，社会的组合，是小说中各个要素之间静态的联系（如同主旨一样）。而情节的披露（如同论述或推论）是动态的联系。亚里士多德说情节是一个故事的灵魂。 在你还不了解一本书之前，不要评论一本书——不要说你同意或反对这个论点。所以在这里，类似的规则是：在你衷心感激作者试着为你创造的经验之前，不要批评一本想象的作品。 亨利·詹姆斯（HenryJames）在《小说的艺术》（TheArtofFiction）中曾说道：“我们要接纳作者的主题、想法与前提。我们所能批评的只是他所创造出来的结果。” 如果你只是被动地阅读一本小说（事实上，我们强调过，要热情地阅读），是没法欣赏一本小说的。 要完成批评这件事，你要客观地指出书中某些事件造成你的反感。你不只要能说明你自己为什么喜欢或不喜欢，还要能表达出这本书中哪些地方是好的，哪些是不好的，并说明理由才行。 阅读故事、戏剧与诗的一些建议 阅读一本书的四个问题，前三个问题在之前已经阐述了，关于第四个问题，这本书与我何关？作者在这里给出了答案，想象文学往往并不能让论述性书一样直接引导出行为，它只是给读者带来经验，经验可能会引导出行动，但这与书本身已经无关了。所以读想象文学唯一要做的就是感受与体验。 然后作者给出了各种想象文学的阅读建议。 暴君并不怕唠叨的作家宣扬自由的思想——他害怕一个醉酒的诗人说了一个笑话，吸引了全民的注意力。” 所谓“纯”艺术，并不是因为“精致”或“完美”，而是因为作品本身就是一个结束，不再与其他的影响有关。就如同爱默生所说的，美的本身就是存在的唯一理由。因此，要将最后一个问题应用在想象文学中，就要特别注意。如果你受到一本书的影响，而走出户外进行任何行动时，要问问你自己，那本书是否包含了激励你的宣言，让你产生行动力？ 如何阅读故事书 第一个建议：一口气读完 第二个建议：批评故事前区分故事是满足了我们个人潜意识的需求，还是满足大多数人潜意识的需求。 之所以谈到潜意识是因为，小说之所以是人类不可或缺的，是因为它能满足我们潜意识或者意识中的许多需求。 理想上来说，一个故事应该一口气读完， 小说能满足我们潜意识或意识中许多的需要。 我们喜欢某种人，或讨厌某种人，但却并不很清楚为什么。如果是在小说中，某个人受到奖励或处罚，我们都会有强烈的反应。我们会甚至因而对这本书有艺术评价之外的正面或负面的印象。 其实，在每个人的面具之下，潜意识里都可能有些虐待狂或被虐狂。这些通常在小说中获得了满足，我们会认同那位征服者或被虐者，或是两者皆可。 因此，在批评小说时，我们要小心区别这两种作品的差异：一种是满足我们个人特殊潜意识需求的小说——那会让我们说：“我喜欢这本书，虽然我并不知道为什么。”另一种则是满足大多数人潜意识需求的小说。用不着 关于史诗的重点 史诗的阅读较为困难，要求集中注意力全心参与并运用想象力。 如何阅读戏剧 剧本不像小说能将背景描述的非常清楚，而且剧本并非一个完整的作品，完整的剧本只能出现在舞台上。所以剧本的阅读要读者假装可以看到舞台的实景， 要阅读萧伯纳式的剧本，却不读萧伯纳所写的前言，就等于是拒绝了作者最重要的帮助，不让他辅助你理解这出戏。 关于悲剧的重点 阅读悲剧时有两点建议，一是悲剧的精髓在于时间，二是读悲剧时，旁边的台词要想象是一个和自己身高差不多的人念出，而悲剧人物的台词则是出自一个高大的人。这样才更符合悲剧演出时的场景。 第一，记住悲剧的精髓在时间，或是说缺乏时间。如果在希腊悲剧中有足够的时间，就没有解决不了的事。问题是时间永远不够。决定或选择都要在一定的时刻完成，没有时间去思考，衡量轻重。 在读旁白的部分时，你要想象这些台词是跟你一般身高的人所说出来的话，而在读悲剧人物的台词时，你要想象这是出自一个大人物的口中， 如何阅读抒情诗 阅读抒情诗第一是无论自己懂不懂都要一口气读完，二是读完后重读一遍大声的念出来，三是大部分的抒情诗都存在一些冲突，尝试去寻找，四是不要太依赖于作者和背景资料。 诗仍是由文字组成的，而且是以条理分明，精巧熟练的方式所组合出来的。 阅读抒情诗的第一个规则是：不论你觉得自己懂不懂，都要一口气读完，不要停。 他们没法立即了解这行诗，便以为整首诗都是如此了。他们在字谜间穿梭，想重新组合混乱的语法，很快地他们放弃了，并下结论说：他们怀疑现代诗对他们而言是太难理解了。 任何一首诗都有个整体大意。除非我们一次读完，否则无法理解大意是什么，也很难发现诗中隐藏的基本感觉与经验是什么。 阅读抒情诗的第二个规则是：重读一遍——大声读出来。…你的耳朵会抗议你的眼睛所忽略的地方。 这可能只是因为我们怀疑自己的阅读能力。只要一个人愿意努力，几乎任何人都能读任何诗。 伟大的抒情诗值得再三玩味。而在放下这首诗的时候，我们对这首诗所有的体会，可能更超过我们的认知。 如何阅读历史书 难以捉摸的史实 历史学家关心的是过去发生的事，而且也很难有一个严格的检验标准，所以了解历史书真正发生了什么事是极为困难的。 历史的理论 历史如果非要在科学和小说间做出个选择，更接近于小说。历史学家个人对的理论会很大程度上影响对于历史的描述，所以真正想要了解一个事件或时期的历史，就很有必要多看一些相关的论著，从多个角度观察。 他可能有一套理论或哲学，像是上帝掌管人间的事物一样，编纂出适合他理论的历史。或者，他会放弃任何置身事外或置身其上的模式，强调他只是在如实报导所发生过的事件。 因为关于历史的理论不同，因为历史家的理论会影响到他对历史事件的描述， 为了追求真相，我们必须从更多不同的角度来观察才行。 历史的普遍性 阅读历史的目的并不在于了解历史所处的那个时代，而是为了了解目前发生的事，历史是存在普遍性的。 阅读历史的要点在于：一是对于感兴趣的历史或时期，要阅读一种以上的历史书。二是阅读历史时不仅要知道历史本身更要了解背后的动机。 希望经由他所观察到的错误，以及他个人受到的灾难与国家所受到的苦楚，将来的人们不会重蹈覆辙。 阅读历史的两个要点是：第一，对你感兴趣的事件或时期，尽可能阅读一种以上的历史书。第二，阅读历史时，不只要关心在过去某个时间、地点真正发生了什么事，还要读懂在任何时空之中，尤其是现在，人们为什么会有如此这般行动的原因。 阅读历史书要提出的问题 这里仍然是每一本书都需要回答的四个问题。 第一个问题是要了解历史书描写的特殊且限定范围的主题。第二个问题是要知道历史书是按照怎么样的方法来架构的，是按照年代还是地区或者其他方法。第三个问题是历史书是否准确，这可以从两个方向去考虑，一是这本书是否逼真，二是作者是否误用了材料。最后一个问题是与我何干，历史总会提供一些可行性，因为我们可以根据历史去做一些事或者规避一些事。 如何阅读传记与自传 传记有很多种，第一种是定案本，这类书有很高的权威性，应该用读历史书的方法来阅读，第二种是授权本，是由继承人或重要的朋友来写的，所以读者必须要了解到授权本的作者存在的偏见。介于这两种传记中间的是一般传记，我们可以当一般的小说来读。 但无论是哪种传记，我们要牢记的是，传记本身都存在作者自身的影响，所以对于任何传记都要存有怀疑心。 定案本的传记绝不能用来写活着的人。 一本定案本的传记是历史的一部分——这是一个人和他生活的那个时代的历史，就像从他本人的眼中所看到的一样。应该用读历史的方法来读这种传记。“授权本”（authorized）传记又是另一回事了。这样的工作通常是由继承人，或是某个重要人物的朋友来负责的。因为他们的写作态度很小心，因此这个人所犯的错，或是达到的成就都会经过润饰。 没有人能反驳你的时候，你可能会掩盖事实，或夸大事实，这是无可避免的事。 对于任何自传都要有一点怀疑心，同时别忘了，在你还不了解一本书之前，不要妄下论断。至于“这本书与我何干？”这个问题，我们只能说：传记，就跟历史一样，可能会导引出某个实际的、良心的行动。 如何阅读关于当前的事件 人的大脑会不可避免如过滤器一样排除掉自认为不准确的信息，所以我们在阅读当前事件时需要关心作者本身的情况，要知道他带着怎样的过滤器，并提出一系列问题：（1）作者想要证明什么？（2）他想要说服谁？（3）他具有的特殊知识（或者说偏见）是什么？（4）他使用的特殊语言是什么？（5）他真的知道自己在说什么吗（作者本身也可能在不知情的情况下存在知识不足而写出错误的东西）？ 一个记者尽管可能抱持着最大的善意，一心想提供读者真实的资料，在一些秘密的行动或协议上仍然可能“知识不足”。他自己可能知道这一点，也可能不知道。当然，如果是后者，对读者来说就非常危险了。 写作当代事件的作者却可能（虽然不见得一定）在希望你用某一种方式了解这件事的过程中，有他自己的利益考虑。就算他不这么想，他的消息来源也会这么想。你要搞清楚他们的利益考虑，阅读任何东西都要小心翼翼。 关于文摘的注意事项 一些新闻报刊会浓缩新闻形成最基本要素的资讯，作为读者我们要尝试读出言外之意，并选择合适的部分去阅读原著。 如何阅读科学与数学 作者首先在这里限定了讨论的范围是科学与数学的经典之作及现代科普著作，排除了专业的研究论文。 通常不是这个领域中的读者根本无法阅读这类文章。这样的倾向有明显的好处，这使科学的进步更加快速。 了解科学这一门行业 作为一个门外汉阅读上述的两种书并非要成为专业领域人士，相反只是为了了解科学的历史与哲学。作为一个门外汉我们也应当了解伟大的科学家们想要解决的是什么问题。 这样的态度可以用萧伯纳的一句名言来作总结：“有能力的人，就去做。没有能力的人，就去教。” 其中没有一本真的很难读，就算牛顿的《自然哲学的数学原理》（MathematicalPrinciplesofNaturalPhilosophy），只要你真的肯努力，也是可以读得通的。 阅读科学经典名著的建议 科学作品的论述一般是两种方法，一是归纳法，二是演绎法。归纳法需要了解理论基础，而门外汉往往没有，这就需要依靠实验。二是推论，推论就常需要用到数学。 伟大的科学作品，尽管最初的假设不免个人偏见，但不会有夸大或宣传。你要注意作者最初的假设，放在心上，然后把他的假设与经过论证之后的结论作个区别。一个越“客观”的科学作者，越会明白地要求你接受这个、接受那个假设。科学的客观不在于没有最初的偏见，而在于坦白承认。 科学不是编年史，科学家跟历史学家刚好相反，他们要摆脱时间与地点的限制。他要说的是一般的现象，事物变化的一般规则。 面对数学的问题 把数学当做是一种语言来学习即可，数学的演绎过程同样具有架构与脉络，而且数学还不存在歧义。 原因是当我们的话题牵涉到情绪时，我们很难理解一些言外之意。数学却能让我们避免这样的问题。只要能适当地运用数学的共识、主旨与等式，就不会有情绪上言外之意的问题。 我们在这里所谈的只是针对一个真正有范围限制的问题，作出真正逻辑的解释。在解释的清晰与问题范围有限制的特质之中，有一种特别的吸引力。在一般的谈话中，就算是非常好的哲学家在讨论，也没法将问题如此这般说得一清二楚。 掌握科学作品中的数学问题 关于数学成为阅读科学作品中的障碍有两点需要说明，一是读者至少可以把基础程度的数学读的更明白，二是如果你读一本书的目的是为了了解数学本身，那你需要从头读到尾并且伴随着纸笔的运算，否则可以选择略读或跳过，只需要关心定理的说明和推论的结果即可。 关于科普书的重点 阅读科普书与阅读科学作品类似，而且更为简单。科普性的科学书籍虽然是理论性的书，但往往也会带来些实用性的结果，如该如何面对环保问题，如何看待核等。 如何阅读哲学书 哲学家提出的问题 哲学家提出的问题分为两类，第一类是关于存在与变化，这类问题属于理论或思辩型的部分。第二部分关于善与恶，好与坏，这类属于哲学中的实用部分。 根据亚里士多德的说法，哲学来自怀疑。那必然是从孩提时代就开始的疑问，只是大多数人的疑惑也就止于孩提时代。 就算有答案，我们也常告诉孩子说没有答案，或是要他们不要再问问题了。碰到那些看来回答不了的问题时，我们觉得困窘，便想用这样的方法掩盖我们的不自在。所有这些都在打击一个孩子的好奇心。他可能会以为问问题是很不礼貌的行为。 能够保留孩子看世界的眼光，又能成熟地了解到保留这些问题的意义，确实是非常稀有的能力——拥有这种能力的人也才可能对我们的思想有重大的贡献。 成人复杂的生活阻碍了寻找真理的途径。 如果思辨或理论型的哲学主要在探讨存在的问题，那就属于形上学。如果问题与变化有关——关于特质与种类的演变，变化的条件与原因——就是属于自然哲学的。如果主要探讨的是知识的问题——关于我们的认知，人类知识的起因、范围与限制，确定与不确定的问题——那就属于认识论（epistemology）的部分，也称作知识论。就理论与规范哲学的区分而言，如果是关于如何过好生活，个人行为中善与恶的标准，这都与伦理学有关，也就是理论哲学的领域；如果是关于良好的社会，个人与群体之间的行为问题，则是政治学或政治哲学的范畴，也就是规范哲学的领域。 现代哲学与传承 把存在与改变，人类该做什么该追求什么的问题看作为第一顺位的问题，把关于第一顺位问题中的知识，回答第一问题时的思考模式，该如何表达回答等问题称为第二顺位问题。现代哲学已经不相信第一顺位问题可以被哲学家解决，都将注意力投入于第二哲学中。 今天的哲学，就像当前的科学或数学一样，已经不再为门外汉写作了。第二顺位的问题，几乎可以顾名思义，都是些诉求比较窄的问题，而专业的哲学家，就像科学家一样，他们唯一关心的只有其他专家的意见。 哲学方法 哲学问题没有实验可以做，没有特殊现象可以观察，唯一能做的只有思考，哲学问题的检验标准就是人的一般经验。 哲学家对于问题答案的探究也并非寻找更多的经验，只是比一般人更深入的思考问题。但有着一种情况需要避免，即哲学家误将科学性问题当做哲学问题进行思考，如古代的哲学家会去思考天体的运动等。 要避免这样的困难，读者必须有能力把哲学家所处理真正哲学性的问题，和他们可能处理，但事实上应该留给后来科学家来寻找答案的其他问题作一区别。 哲学家的分类 哲学的方法只有思考以这种，但哲学家们最少用了五种方法来论述哲学。第一种是以柏拉图为典型的哲学对话，第二种是以康德和亚里士多德为典型的哲学论文或散文，第三种是以阿奎那为典型的面对异议型，这种会先对异议的观点进行批判，再提出自己的观点并加以论证。第四种是系统化哲学，这是以笛卡尔和斯宾诺莎为典型的，他们常识用数学这样的组织方式将哲学整理出来。第五种是尼采这样的格言形式 从对立与冲突中，让真理逐渐浮现，这是中世纪非常盛行的想法。 数学的方法还是比较适合几何或其他的数学问题，而不适合用在哲学问题上。当你阅读斯宾诺莎的时候，可以像你在阅读牛顿的时候那样略过很多地方，在阅读康德或亚里士多德时，你什么也不能略过。 阅读哲学的提示 阅读哲学最为关键的是找到哲学家在作品背后隐藏的中心思想和原则，这个很难，或许要花费许多年的时间，而且很难给出恰当的建议。 所谓你对某件事“有了概念”，也就是你对自己具体经验到的某些事情的普遍性层面有了了解。 假装相信一些其实你并不相信的事，是很好的心智训练。当你越清楚自己的偏见时，你就越不会误判别人的偏见了。 读者在面对一本哲学书时，除了阅读以外，什么也不能做——那也就是说，要运用你的思考。除了思考本身外，没有任何其他的帮助。 厘清你的思绪 哲学家彼此的意见常常不合一但这不应该成为阅读哲学书的困扰，一是因为有些问题尚未被解决，二是厘清自己的思绪才重要，用别人的意见并没有解决问题，只是逃避问题。 关于神学的重点 神学分为自然神学和教义神学。自然神学是哲学的一种，可当做哲学书来观看。教义神学则是信徒所信奉的经文，在阅读这类书时常会犯两个错误，一是拒绝接受，阅读时应该要记住，经文对于有信仰的人来说是一种知识而非假设。二是认为原则是教义的，那么其论证、推论、结果也是教义的。这里要做区分，原则是教义的，但如果推论存在错误，那么也会得出无效的结论。 谈到这里，你该明白一个没有信仰的读者要阅读神学书时有多困难了。在阅读这样的书时，他要做的就是接受首要原则是成立的，然后用阅读任何一本好的论说性作品都该有的精神来阅读。 如何阅读“经书” 对于信徒而言，经书中不会存在错误，这是前提，并且有义务从中找到意义，并能从其他的事实中举证其真实性。 如何阅读社会科学 什么是社会科学 社会科学包含了很多其他的学科，如人类学、经济学、政治学与社会学，社会科学关心的是文化、制度与环境因素。 阅读社会科学的容易处 一是作品的内容通常取自于读者熟悉的经验，二是我们熟悉社会科学的术语，三是社会科学讨论的问题，我们通常已经有了一些思考与意见。 阅读社会科学的困难处 让阅读社会科学阅读简单的元素也造成了它的困难，一是因为我们对社会科学讨论的问题已有自己的意见，所以我们常会拒绝作者的观点。二是因为对于许多记者和专栏作家让某些社会科学的术语承担了太多的责任，已经超出了其本身应该覆盖的范围，这就造成了术语意义的不明确。三是因为社会科学混杂了太多的不同学科，所以很难区分书的元素。 如果你要回答阅读任何作品都该提出的头两个问题，你一定要先检查一下你自己的意见是什么。如果你拒绝倾听一位作者所说的话，你就无法了解这本书了。 其中一个理由是，社会科学并不能数学化，另一个理由是在社会或行为科学中，要说明用语比较困难。 阅读社会科学作品最困难的地方在于：事实上，在这个领域中的作品是混杂的，而不是纯粹的论说性作品。 阅读社会科学作品 阅读社会科学时常常要读好几本书，而非一本，一是因为社会科学存在一定的时效性，作品要不断的推陈出新，二是社会科学是一个较新的学科，经典作品还不多。这也就引出了之后要讨论的主题阅读。 阅读的最终目标 阅读的第四个层次：主题阅读 主题阅读是要读多本书，但确定一个主题究竟牵扯到哪些书是一个困难的事，往往在一开始我们确定的书目会非常的庞大，我们要将其删减至一个合理的范围。 在主题阅读中，检视阅读所扮演的角色 收集到主题的书目后，首先要通过检视阅读检视上面所有的书，这样第一会帮助你对主题有个清晰的概念，第二它可以简化书目。 他们阅读每一本书或每一篇文章都花上同样的时间与努力，结果他们该花精神好好阅读的书却没有读好，倒把时间花在那些不太值得注意的书上了。 主题阅读的五个步骤 步骤一：找到相关的章节，这仍然依靠检视阅读，通常建议再次检视删减后的书目，找到相关的章节，所以主题阅读并不是完整的阅读一本书目。 步骤二：带领作者与你达成共识。在主题阅读时，我们要建立自己的一套词汇，然后将各个作者的观点，用我们自己的词语进行表达。 步骤三：厘清问题。步骤二中我们建立了词汇，步骤三则是要建立一套主旨，最好的方法就是列出一系列可以讲问题说明白的问题。问题可以从概念的存在与特质、概念如何发现，如何表达，有什么影响等角度出发。 步骤四：界定议题。当有了问题后会发现各个作者用了不同的方式去表达，这时候我们就要将观点分类形成议题。 步骤五：分析讨论。我们需要说明问题的不同答案并说明原因以及我们将答案分类的依据。 客观的必要性 注意在上述步骤五中，我们并非要通过主题阅读去找到一个问题的确切答案，因为这样就失去了讨论的客观性。主题阅读需要的是自己不预设立场，即使在最终的总结部分，也要有作者原文的支持。 换句话说，主题阅读的目的，并不是给阅读过程中发展出来的问题提供最终答案，也不是给这个计划开始时候的问题提供最终解答。 主题阅读所追求的这种特质，可以用这句话来作总结：“辩证的客观。”简单来说，主题阅读就是要能面面俱到，而自己并不预设立场。当然，这是个严格的理想，一般人是没法做到的。 在分析问题时必须先建立一套中立的词汇。这样的中立语言还是必要的，而且在总结一个作者的论述时，一定要用这套中立的语言，而不是作者的语言。但是伴随着总结，一定要有仔细引用的作者原文，以免对文意有所扭曲，这样阅读者才能自己判断你对作者所作的诠释是否正确。 主题工具书 一些工具书已经整理了某个主题的书目甚至章节，他们可以引导我们进行主题阅读。 构成主题阅读原则 主题阅读的原则即是将作者的话用自己的语言表示，将不同作者拉到一起讨论一个问题。 阅读与心智的成长 好书能给我们什么帮助 阅读超越自己头脑的书能带来思想的增长否则就只有资讯的提升，一本好书也能让人更好的了解自己和世界。 你必须能操纵超越你能力的书，或像我们所说的，阅读超越你头脑的书。只有那样的书能帮助你的思想增长。除非你能增长心智，否则你学不到东西。 伟大的经典就是在帮助你把这些问题想得更清楚一点，因为这些书的作者都是比一般人思想更深刻的人。 书的金字塔 世间的书大部分都是对阅读技巧毫无帮助，因为他们已经在你的能力之类。有些书在你的能力之外值得值得做分析阅读，但 在第一次的阅读后，你就不再需要再次去读他们，因为这本书已经增长了你的理解力，你的能力已经和这本书持平了。还有一小部分书，在你阅读后仍然存有疑问，如果你知道疑惑在哪，那你可以马上再次进行阅读，但有些你无法理解，且每次的重写阅读都能让你看到新的东西，这是因为你的每次重新阅读都让你的能力增长了些许，而提升的理解力会让你产生新的感受。 如果这本书是属于前面我们所说第二种类型的书，重读的时候，你会发现书中的内容好像比你记忆中的少了许多。当然，原因是在这个阶段中你的心智成长了许多。你的头脑充实了，理解力也增进了。书籍本身并没有改变，改变的是你自己。 生命与心智的成长 人有内在的生命力量，主动阅读能让我们的心智保持活力和成长。 除此之外，似乎也没法说明为什么许多工作忙碌的人一旦退休之后就会立刻死亡。他们活着是因为工作对他们的心智上有所要求，那是一种人为的支撑力量，也就是外界的力量。一旦外界要求的力量消失之后，他们又没有内在的心智活动，他们便停止了思考，死亡也跟着来了。","link":"/HowToReadABookNotes/"},{"title":"《算法导论》 第十五章笔记","text":"《算法导论》 第十五章笔记，介绍动态规划的概念及一些运用了动态规划的算法。 15.4及15.5节尚未整理 Chapter 15. Dynamic Programming 动态规划(Dynamic Programming)如分治法(divide-and-conquer method)一样都是通过组合子问题的解答来解决问题。两者的区别在于： 分治法的子问题是互相独立的，不存在重叠 动态规划的子问题是相互重叠的，不同的子问题可能存在重叠子问题。若对于每个子问题都求解一次，则会出现重复计算 动态规划常被用来解决最优问题（optimization problems），这种问题通常有许多可能的解答，动态规划的目标是求得一个最优解（通常是众多解答中的最大值或最小值）。 动态规划的步骤如下： 找到最优解的结构 递归定义最优解的值 计算出最优解的值，通常是通过一个自下而上的递归方式解决 使用计算得出的数据构建出最优解 步骤1-3是动态规划解决问题的基础，如果只需要求得最优解的值而非最优解本身，可以忽略步骤4。 Rod cutting 钢条切割问题(Rod cutting)是假设存在一个钢条，切割成不同长度可以卖不同的钱，设切割出的长度为$i$，对应这一段长度的卖价为$P_i$。假设钢条长度从1-10的卖价如下 长度 1 2 3 4 5 6 7 8 9 10 价格 1 5 8 9 10 17 17 20 24 30 一段长度为$i$的钢条，一共有$2^{n-1}$个切割方法。因为将长度为$i$的钢条看作是有$i$个长度为1的结点进行分类，一共有$n-1$个连接点，每个连接点都可以选择切或者不切，所以有$2^{n-1}$个可能。 如有3个结点，1-2的切分和2-1的切分看作是两种可能。 设一段钢条在卖价最大化的情况下要切分成$k$块，则总长度为$n$的钢条可以表示为 $n=i_1+i_2+…+i_k$，最大化的总价为为$r_n$，可表示为$r_n=p_{i_1}+p_{i_2}+…+p_{i_k}$ 对于上面假设的卖价，对应钢条的长度从1-10，各自的最佳卖价和切割方法如下 如切割方式$2+2$表示写成两半，一块为长度为2，另一块也为2.如果切割方式与总长度相同，如都为3,则表示不切割即为最佳切割方式。 钢条总长度 最大化卖价 最佳切割方式 1 1 1 2 5 2 3 8 3 4 10 2+2 5 13 2+3 6 17 6 7 18 1+6 / 2+2+3 8 22 2+6 9 25 3+6 10 30 10 表格中的最佳切割方式是钢条切割问题的最佳解，而最大化卖价是最佳切割方式的数值。 可以把求得$r_n$，即整个钢条的最大化过程看作先切割一刀，这时候钢条变成了两部分，左部分就不再动了，对右部分继续切割，找到右部分的最佳切割方式，即对右部分求最佳解。数学可表示为 $$ r_n= \\max_{1\\leq i \\leq n}(p_i + r_{n-i}) $$ 这就是钢条切割问题的最佳解结构：整个问题的最佳解是与子问题的最佳解相关的。如上式中，最佳解的值是依赖于子问题的最佳解的值得到的。 递归解法 递归解法的伪代码如下，这个方法就是对式子$r_n=\\max_{1\\leq i \\leq n}(p_i + r_{n-i})$的实现 12345678CUT-ROD(p,n)if n == 0 return 0q = -MAXfor i = 1 to n q = max (q, p[i] + CUT-ROD(p,n-i))return q 但这个运算是非常低效的，因为它存在许多的重复计算，如对于$n=4$，算法会在循环中分别以$n=0,n=1,n=2,n=3$调用CUT-ROD算法，而在以$n=3$调用时又会在循环中以$n=0,n=1,n=2$调用，这就造成了重复运算。调用时的计算如下图 图中的每个结点表示一次调用，结点中的数值表示$n$的取值，可以看到有非常多重复的结点。 设$T(n)$为该算法的执行时间，可以表示为 $$ T(n)= 1 + \\sum _{i=1}^{n} T(n-i) $$ 可取$j=n-1$，将式子转换为 $$ T(n)= 1 + \\sum _{j=0}^{n-1} T(j) $$ 可通过数学归纳法证明该式子的时间复杂度为$T(n)=2^n$，是一个指数型增长的式子，所以该算法的效率十分低下。 $T(n)=1 + \\sum _{j=0}^{n-1} T(j)=2^n$的证明如下： 当n=0时$T(0)=2^0=1$，满足式子，得证 当n&gt;0时 $$ T(n)=1+\\sum _{j=0}^{n-1} 2^{j} \\\\ =1 + 2^0 \\cdot \\frac{1-2^{n}}{1-2} \\\\ = 1 + (2^n -1) \\\\ = 2^n $$ 满足原式子，得证。 递归解法的c++实现如下: 1234567891011121314int CutRod(int* priceTable, int rodLength){ if (rodLength == 0) return 0; int price = INT_MIN; for (int i = 1; i &lt;= rodLength; i++) //cut from 1 to length(equals to no cuts) { int tempPrice = priceTable[i] + CutRod(priceTable, rodLength - i); if (tempPrice &gt; price) price = tempPrice; } return price;} using dynamic programming for optimal rod cutting 在上一节的递归算法中，因为大量重复的计算导致了算法的低效。在动态规划的解法中，实际上是通过将计算过的子问题的解存储下来，之后再次遇到直接返回结果即可，所以动态规划本质上是一个空间与时间的权衡(time-memory trade-off)。 通过动态规划，基本可以将一个时间复杂度为指数型的算法（如$2^n$）转换为一个多项式型的算法（如$n^2$） 动态规划一般有两种解法，一种是自顶向下备忘录法（top-down with memoization），一种是自底而上法(bottom-up method)。下面会以钢铁切割问题分别说明两种方法： 自顶向下备忘录法 这种方法与之前的递归法结构几乎相同，也是严格按照动态规划解法的定义，即将运算过的子问题答案记录下来。切割钢条问题使用自顶向下的备忘录法伪代码如下： 12345678910111213141516171819MEMOIZED-CUT-ROD(p,n):r = new array[n+1]for i =0 to n r[i] = -MAXreturn MEMOIZED-CUT-ROD-AUX(p,r,n)MEMOIZED-CUT-ROD-AUX(p,r,n):if r[n] &gt; 0 //means there are record for this subproblem return r[n]if n == 0 q = 0else q = -MAX for i = 1 to n q = max (q, p[i] + MEMOIZED-CUT-ROD-AUX(p,r,n-i))r[n] = qreturn q MEMOIZED-CUT-ROD主要功能是初始化一个数组$r$，这个数组存储了所有计算过的子问题的答案，MEMOIZED-CUT-ROD-AUX实际对应之前的递归算法CUTROD，不同点只是当发现答案记录过就直接返回。 c++ 代码如下: 1234567891011121314151617181920212223242526272829303132333435363738int MemoizedCutRod(int* priceTable, int rodLength){ //create an array from 0 to rodLength, array length is (rodLength+1) //array[0] = 0, array[rodLength] means the max PriceMemo for rod of rodLength int* maxPriceMemo = new int[rodLength + 1]; for (int i = 0; i &lt; rodLength + 1; i++) { maxPriceMemo[i] = INT_MIN; } int maxPrice = MemoizedCutRodAux(priceTable, maxPriceMemo, rodLength); //for (int i = 1; i &lt; rodLength + 1; i++) //{ // cout &lt;&lt; &quot;Max price for &quot; &lt;&lt; i &lt;&lt; &quot; is &quot; &lt;&lt; maxPriceMemo[i] &lt;&lt; endl; //} return maxPrice;}int MemoizedCutRodAux(int* priceTable, int* maxPriceMemo, int rodLength){ if (maxPriceMemo[rodLength] &gt; 0)//has record return maxPriceMemo[rodLength]; int price = INT_MIN; if (rodLength == 0) price = 0; else for (int i = 1; i &lt;= rodLength; i++) { int tempPrice = priceTable[i] + MemoizedCutRodAux(priceTable, maxPriceMemo, rodLength - i); if (tempPrice &gt; price) price = tempPrice; } maxPriceMemo[rodLength] = price; return price;} priceTable表示不同长度的钢条的价格数组，初始化定义为： 1int priceTable[] = { 0,1,5,8,9,10,17,17,20,24,30 }; 注意这里的数组长度都为$rodLength+1$，这是为了将长度与Index对齐，如长度为1的钢板的最大售价，则使用$maxPriceMemo[1]$即可。 自底而上法 自底而上法形式上更为简单，但它利用了动态规划的一个特性：较大的子问题包含较小的子问题。 因此如果从最小的子问题开始解决，那么在解决后面更大的子问题时，它所依赖的所有小子问题都已经有了解答，也就不需要像自顶向下备忘法那样去检查是否子问题已经有了答案。 所以如果要求长度为$n$的钢条的最大售价，只要从长度为1开始求起，依次求到长度为$n$ 伪代码如下： 1234567891011121314BOTTOM-UP-CUT-ROD(p,n)r = new array[n+1]for i =0 to n r[i] = -MAXr[0] = 0for i = 1 to n q = -MAX for j = 1 to i q = MAX(q , p[j] + r[i-j]) r[i]=qreturn r[n] c++代码如下： 12345678910111213141516171819202122232425262728293031323334int BottomUpCutRod(int* priceTable, int rodLength){ //Init for maxPriceMemo int* maxPriceMemo = new int[rodLength + 1]; for (int i = 0; i &lt; rodLength + 1; i++) { maxPriceMemo[i] = INT_MIN; } maxPriceMemo[0] = 0; //Calculate the MaxPriceMemo for length from 1 to length for (int i = 1; i &lt;= rodLength; i++) { //Calculate cutRod for length = i int price = INT_MIN; for (int j = 1; j &lt;= i; j++) { int tempPrice = priceTable[j] + maxPriceMemo[i - j]; if (tempPrice &gt; price) price = tempPrice; } maxPriceMemo[i] = price; } for (int i = 1; i &lt; rodLength + 1; i++) { cout &lt;&lt; &quot;Max price for &quot; &lt;&lt; i &lt;&lt; &quot; is &quot; &lt;&lt; maxPriceMemo[i] &lt;&lt; endl; } return maxPriceMemo[rodLength];} 两个方法的时间复杂度实际上都是$\\Theta(n^2)$。BOTTOM-UP-CUT-ROD中因为有个双重循环，所以时间复杂度为$\\Theta(n^2)$，MemoizedCutRod中虽然只有一个循环，但在每次的循环中，可能会递归调用并需要解决子问题，子问题并不会重复调用，因此一共解决$n$个子问题，循环加上解决子问题的时间可得到时间复杂度同样为$\\Theta(n^2)$。 虽然两个方法的时间复杂度都是$\\Theta(n^2)$，但是BOTTOM-UP-CUT-ROD在实际使用中因为减少了函数的递归调用时间，所以更为高效。 Subproblem graphs 子问题图（subproblem graphs）是一个有向图，每一个顶点都对应一个子问题。如果代表子问题$x$的结点指向代表子结点$y$的结点，则说明$x$问题的解依赖于$y$。 子问题图如下,它可以看作是表示递归解法的图的精简版，删除了所有重复的点，也表示子问题并不会被重复的计算： 子问题图可以用来获知动态规划问题的时间复杂度，因为图中的一个结点表示一个子问题，图中连接结点的边表示用来组合两个子问题答案的时间，因此用来解决整个动态规划问题的时间基本上与子问题图的顶点数+边数是呈线性关系的。 Reconstructing a solution 上面的所有关于钢条切割问题的算法都只计算了钢条的最大售价（最佳解的值），而对于这个问题真正的解，如何切割钢条（最后钢条要切成几块，每块多长），并没有得出。所以上面的所有步骤都只完成了解动态规划问题四步骤的前三步。 为了得到最佳解需要对上面的步骤进行调整，调整有非常简单，在计算中再多保留一些数据即可。 以自底向上的BOTTOM-UP-CUT-ROD为例，在算法中，在算法中用了p[j] + r[i-j]来表示第一刀砍的长度$j$与剩下部分$i-j$。在售价最大的情况下，记录下第一刀砍的长度$j$即能获得动态规划的最佳解，因为在每一次的循环中，都将当前长度下第一刀砍的长度保存了下来，那么在剩下的长度越来越小的过程中，整个切割过程的每一刀长度都被记录了下来。 伪代码如下，这里的数组$s$即为记录第一刀长度的数组： 1234567891011121314151617EXTENDED-BOTTOM-UP-CUT-ROD(p,n)r = new array[n+1]s = new array[n+1]for i =0 to n r[i] = -MAXr[0] = 0for i = 1 to n q = -MAX for j = 1 to i q = MAX(q , p[j] + r[i-j]) r[i]=q s[i]=jreturn s and s c++代码如下，形参中的cutLength即表示不同长度下第一刀要砍的距离： 12345678910111213141516171819202122232425262728293031323334void ExtendedBottomUpCutRod(int* priceTable, int rodLength, int* maxPriceMemo, int* cutLength){ for (int i = 0; i &lt; rodLength + 1; i++) { maxPriceMemo[i] = INT_MIN; } maxPriceMemo[0] = 0; //Calculate the MaxPriceMemo for length from 1 to length for (int i = 1; i &lt;= rodLength; i++) { //Calculate cutRod for length = i int price = INT_MIN; for (int j = 1; j &lt;= i; j++) { int tempPrice = priceTable[j] + maxPriceMemo[i - j]; if (tempPrice &gt; price) { price = tempPrice; cutLength[i] = j; } } maxPriceMemo[i] = price; } //for (int i = 1; i &lt; rodLength + 1; i++) //{ // //cout &lt;&lt; &quot;Max price for &quot; &lt;&lt; i &lt;&lt; &quot; is &quot; &lt;&lt; maxPriceMemo[i] &lt;&lt; endl; // cout &lt;&lt; &quot;First cut length for &quot; &lt;&lt; i &lt;&lt; &quot; is &quot; &lt;&lt; cutLength[i] &lt;&lt; endl; //}} 获得了最佳解后就可打印出对于长度为$n$的钢条，每一刀需要砍的长度，伪代码算法如下 123456PRINT-CUT-ROD-SOLUTION(p,n)(r,s) = EXTENDED-EXTENDED-BOTTOM-UP-CUT-ROD(p,n)while n &gt; 0 print s[n] n = s - n c++实现如下： 1234567891011121314151617int CutRodSolution(int* priceTable, int rodLength){ int* maxPriceMemo = new int[rodLength + 1]; int* cutLength = new int[rodLength + 1]; ExtendedBottomUpCutRod(priceTable, rodLength, maxPriceMemo, cutLength); int remainLength = rodLength; while (remainLength &gt; 0) { int length = cutLength[remainLength]; cout &lt;&lt; &quot;to Cut &quot; &lt;&lt; length &lt;&lt; endl; remainLength = remainLength - length; } return maxPriceMemo[rodLength];} Matrix-chain multiplication 定义有一系列的矩阵$&lt;A_1,A_2,…,A_n&gt;$，要计算这一些矩阵的乘积即$A_1A_2…A_n$。因为矩阵满足乘法合并律，所以可以决定哪一部分先相乘。 如一共有三个矩阵$&lt;A_1,A_2,A_3&gt;$，则$((A_1A_2)A_3)$与$(A_1(A_2A_3))$两种计算顺序最后得到的结果是相同的，但是这两种顺序花费的时间是不同的。 这里先给出矩阵相乘的算法： 123456789101112MATRIX-MULTIPLY(A,B)if A.columns != B.rows error &quot;incompatible dimensions&quot;else let C be a new A.rows X B.columns matrix for i = 1 to A.rows for j = 1 to B.columns c[i][j] = 0 for k = 1 to A.columns c[i][j] = c[i][j] + a[i][k] * b[k][j] return C c++实现如下： 1234567891011121314151617Matrix* Matrix::multiply(Matrix* mat){ int matColumn = mat-&gt;column; Matrix* result = new Matrix(row, matColumn); for (int i = 0; i &lt; row; i++) { for (int j = 0; j &lt; matColumn; j++) { result-&gt;data[i][j] = 0; for (int k = 0; k &lt; column; k++) { result-&gt;data[i][j] = result-&gt;data[i][j] + data[i][k] * mat-&gt;data[k][j]; } } } return result;} 设两个相乘的矩阵分别为$A$和$B$，从上面的算法实现中可以看出，矩阵相乘的时间复杂度为$O(A.row\\times B.column\\times A.column)$。 在三个矩阵$&lt;A_1,A_2,A_3&gt;$的例子中,假设$A_1$的大小为$10\\times100$，$100\\times 5$，$5\\times50$。 如果计算顺序为$((A_1A_2)A_3)$，则整个计算需要进行的操作数为$10\\times5\\times100 +10\\times50\\times5=7500$。 如果计算顺序为$(A_1(A_2A_3))$，则整个计算需要进行的操作数为$100\\times50\\times5+10\\times50\\times100=75000$ 两种计算顺序的计算量差距在10倍。 将矩阵乘法问题（matrix-chain multiplication problem）定义为：对于数目为$n$的一些列矩阵$&lt;A_1,A_2,…,A_n&gt;$，为了满足矩阵相乘的要求，矩阵$A_i$的大小都为$p_{i-1}\\times p_i$，要求的使相乘计算量最小的矩阵相乘顺序。 Counting the number of parenthesizations 首先确认暴力枚举所有可能的顺序这个方法是很低效的，用$P(n)$来表示所有可能的计算顺序。设有$n$个矩阵，当$n=1$的情况下，只有一种可能，当$n\\geq 2$的情况下，可以将$n$拆成两部分，$k$和$n-k$，所有的可能为这两部分可能的乘积，即$P(k)P(n-k)$。所以, $$ P(n)= \\begin{cases} 1 &amp; \\text{ if } n=1 \\\\ \\sum_{k=1}^{n-1} P(k)P(n-k) &amp;\\text{ if } n \\geq 2 \\end{cases} $$ 可以用数学归纳法证明$P(n)$的时间复杂度为$\\Omega(2^n)$： 在$n=1$的情况下，$P(n)=1$，得证 在$n\\geq2$的情况下，假设$p(n)=c2^n$代入式子得 $$ P(n)=\\sum_{k=1}^{n-1} c2^k\\cdot c2^{n-k} \\\\ =\\sum_{k=1}^{n-1} c^2 2^n\\\\ =c^2(n-1)2^n\\\\ \\geq c_1 2^n $$ 即$P(n)\\geq c_1 2^n$，也得证。 因此暴力枚举所有可能的顺序时间复杂度是一个指数型的函数， 效率是十分低下的。 Applying dynamic programming 可以用动态规划来解决这个问题，这里根据之前定义的动态规划四步骤来解决答案： 找到最优解的结构 递归定义最优解的值 计算出最优解的值，通常是通过一个自下而上的递归方式解决 使用计算得出的数据构建出最优解 Step 1:The structure of an optimal parethesization 用符号$A_{i…j}$表示矩阵序列$A_i,A_{i+1},…,A_{j}$的乘积，在$i\\neq j$的情况下，可以将矩阵序列拆成两部分，$A_i,A_{i+1},…,A_{k}$和$A_{k+1},A_{k+2},…,A_{j}$，其中$i\\leq k &lt; j$。 整个$A_{i…j}$的花费变成了$A_{i…k}$的花费加上$A_{k+1…j}$的花费再加上将两部分结果相乘的时间。 在按两部分分割下，如果$A_{i…j}$是最佳解，那么分出的$A_{i…k}$和$A_{k+1…j}$两部分也必然是各自的最佳解，因为如果其中一个可以更优的话，那么$A_{i…j}$则也可以变得更优。 因此矩阵相乘问题的最优解也变为了先求得两个子问题的最优解，再将两个最优解合并起来。 Step2: A recursive solution 用$m[i,j]$来表示$A_{i…j}$的操作量，根据Step1中的解释，$A_{i…j}$的花费变成了$A_{i…k}$的花费加上$A_{k+1…j}$的花费再加上将两部分结果相乘的时间。 因为矩阵$A_i$的尺寸为$p_{i-1}\\times p_i$，所以矩阵$A_{i…k}$为$p_{i-1}\\times p_k$，矩阵$A_{k+1…j}$的尺寸为$p_{k}\\times p_j$。因此将两部分合并的操作数为$p_{i-1}p_kp_j$。 当$i=j$时，只有一个矩阵即不需要相乘，这种情况下$m[i,j]$为0，综上 $$ m[i,j] = \\begin{cases} 0 &amp; \\text{ if } i=j \\\\ \\min_{i\\leq k &lt;j} {m[i,k]+m[k+1,j]+p_{i-1}p_kp_j} &amp; \\text { if } i &lt;j \\end{cases} $$ 但$m[i,j]$表示的只是最佳解的值，为了获得最佳解，需要定义一个$s[i,j]$，它记录每个子问题的最佳解时$k$的值。 Step 3: Computing the optimal costs $m[i,j]$的计算依赖于矩阵的尺寸$p_{i-1} \\times p_i$，如果存在$n$个矩阵，则表示数据尺寸的数组有$n+1$个元素，因为对于$A_1$而言，尺寸为$p_0 \\times p_1$，所以$p$的数组是从0到$n$。 使用数组$m[i,j]$来表示$A_i…A_j$的最少操作数。其中$i$的取值范围是$1\\sim n$，$j$的取值范围是$1\\sim n$。当$i=j$时，$m[i,j]=0$ 使用数组$s[i,j]$表示$A_i…A_j$有最少操作数时，$k$的取值。其中$i$的取值范围是$1\\sim {n-1}$，$j$的取值范围是$2\\sim n$。这是因为如果$i$必须小于$j$，如果$i=j$，那么根本就没有$k$的存在。 对于矩阵序列$A_i…A_j$，一共有$l$个元素，$l=i-j+1$ 计算矩阵序列最佳解的算法伪代码如下： 1234567891011121314151617MATRIX-CHAIN-ORDER(p)n = p.length -1m = new matrix[1~n][1~n]s = new matrix[1~n-1][2~n]for i = 1 to n //matrix chain only has one matrix m[i,i] = 0for l = 2 to n for i = 1 to n-l+1 // set i's arrange according to the length j = i + l -1 //we can calculated the j according to the i and l m[i,j]= MAX for k = i to j-1 q = m[j,k] + m[k+1,j] + p[i-1]p[k]p[j] if q &lt; m[j,k] m[i,j] = q s[i,j] = k return m and s 上述伪代码的第6-7行，即对于m[i,i] = 0的处理，实际上就是表示整个矩阵序列只有一个矩阵的情况。 算法的核心是从第八行开始的三重循环，最外层循环l = 2 to n，表示矩阵序列中的矩阵数量从$2\\sim n$的情况。因为算法使用了自底向上的方法，所以从矩阵数量为$2$开始计算直到矩阵数量为$n$。 第二层循环i =1 to n-l+1，是对于$i$数值的循环，因为矩阵序列的长度为$l$，所以$i$最大为$n-l+1$，否则$j=i+l-1$会大于$n$。 因为$l$和$i$都已经确认，所以在第二层循环中，可以算出$j=i+l-1$，至此$m[i,j]$中的$i$和$j$都已经确认，剩下要求的就是分割点$k$。 第三层循环k=i to j-1是循环$k$取值的每一个可能，并检查其是否是最佳值，如果是则填入$m[i,j]$和$s[i,j]$ c++实现如下： 12345678910111213141516171819202122232425262728293031void MatrixChainOrder(int* matrixSizeArray, Matrix* minMultiplications, Matrix* minMultiplicationCut){ int totalMatrixLength = minMultiplications-&gt;row; for (int i = 0; i &lt; totalMatrixLength; i++) minMultiplications-&gt;data[i][i] = 0; for (int matrixLength = 2; matrixLength &lt;= totalMatrixLength; matrixLength++) { for (int i = 0; i &lt; totalMatrixLength - matrixLength + 1; i++) { int j = matrixLength + i - 1; minMultiplications-&gt;data[i][j] = INT_MAX; for (int k = i; k &lt;= j - 1; k++) { int tempMin = minMultiplications-&gt;data[i][k] + minMultiplications-&gt;data[k + 1][j] + matrixSizeArray[i] * matrixSizeArray[k + 1] * matrixSizeArray[j + 1]; if (tempMin &lt; minMultiplications-&gt;data[i][j]) { minMultiplications-&gt;data[i][j] = tempMin; minMultiplicationCut-&gt;data[i][j] = k; } } } } minMultiplications-&gt;PrintMatrix(15); cout &lt;&lt; endl; minMultiplicationCut-&gt;PrintMatrix(15);} c++实现中，matrixSizeArray表示存有矩阵尺寸的数组，如有$n$个矩阵，则该数组大小为$n+1$。minMultiplications等同于伪代码中的$m[i,j]$，minMultiplicationCut等同于伪代码中的$s[i,j]$。这两个都用了Matrix进行表示，两个Matrix尺寸都为$n$。虽然在伪代码中，$s[i,j]$的尺寸只要是$n-1$即可，但这里为了实现方便，还是用了$n$。 如果输入的matrixSizeArray数据有7个数据，即表示有6个矩阵，且初始化为: 1int matrixSizeArray[] = { 30,35,15,5,10,20,25 }; 则C++运算结果如下： 结果中的-842150451是Int数值的默认值，在不同电脑上可能不一样。 minMultiplications的对角线表示长度为1的情况，这时候不需要操作了，即为0。从对角线向右上角，每一条都长度+1的情况。右上角顶点$15125$即表示长度为6时的结果。 同理，minMultiplicationCut的对角线有表示长度为1的情况，但因为长度只有1，所以没法分割，也就是没法定义k，因此这个矩阵的对角线值是未定义的即-842450451。同样的从对角线向右上角，每一条都长度+1的情况。 将两个矩阵结果的未定义部分删去，并进行一个旋转，让对角线变成水平，则结果如下图所示，左边是$m[i,j]$，右边是$s[i,j]$： 算法是从最底部逐渐向上运行。 图中的$s[i,j]$与代码运行的结果不同，每一个数值都大了1，这是因为代码中矩阵位置是从0开始，而图解中是从1开始。 因为算法有三种循环，所以时间复杂度为$O(n^3)$，且算法需要$\\Theta(n^2)$的空间复杂度。 Step 4: Constructing an optimal solution 在步骤三中求得的$m[i,j]$只是最佳解的值。如例子中如果要求6个矩阵的最小工作量，可以从$m[i,j]$的最顶部获得，为$15125$。但如果要求6个矩阵最佳情况下该以怎样的顺序进行计算，步骤三并没有直接给出。这里可以通过步骤三中获得的$s[i,j]$矩阵获取矩阵相乘最佳情况下的顺序。 伪代码如下： 123456789PRINT-OPTIMAL-PARENS(s,i,j)if i == j print &quot;A_&quot;ielse print &quot;(&quot; PRINT-OPTIMAL-PARENS(s,i,s[i,j]) PRINT-OPTIMAL-PARENS(s,s[i,j]+1,j) print &quot;)&quot; 这里利用了步骤三中求得的$s[i,j]$，如果输入值为$0 \\sim 5$（以C++实现的数据为准，所以不是$1\\sim6$），则算法的图解如下： 黑色表示$(i,j)$，蓝色表示$s[i,j]$的取值，红色表示算法中的输出。 最后树以中序打印则为结果(因为算法中都是在递归左树和右树前先打印了数据，所以是中序) c++实现如下： 12345678910111213void PrintOptimalParens(Matrix* minMultiplicationsCut, int i, int j){ if (i == j) cout &lt;&lt; &quot;A_&quot; &lt;&lt; i; else { cout &lt;&lt; &quot;(&quot;; int k = minMultiplicationsCut-&gt;data[i][j]; PrintOptimalParens(minMultiplicationsCut, i, k); PrintOptimalParens(minMultiplicationsCut, k + 1, j); cout &lt;&lt; &quot;)&quot;; }} 输入值为$0\\sim5$的话，最终结果为$((A_0(A_1A_2))((A_3A_4)A_5))$。 Elements of dynamic programming 一个优化问题可以用动态规划解决必须有两个关键因素：最优子结构（Optimal substructure）和重叠的子问题（overlapping subproblems）。 Optimal substructure 如果一个问题具有最优子结构，那么这个问题的最优解一定是伴随着他的子问题的最优解。 可以从以下步骤找寻问题的最优结构： 问题的第一部分首先可以通过一个选择进行切分。切分后会产生一个或多个子问题。 这一步相当于先确定最内层的循环表达形式，如在切割钢条问题中是选择第一刀切割的长度$l$，矩阵乘法问题中是分割矩阵的位置(求$k$)。 在步骤一的选择中，假设已经知道最优解的选择是什么。 步骤一中的值是需要一个循环来遍历每个可能的值并找到最佳值的，步骤二即假设已经找到了最佳解。 限定子问题空间，即运用最优解的子问题（在步骤二中假设已经知道了解决每个问题的最优解）。限定子问题空间时尽可能简单。 例如对于钢条切割问题，子问题空间包含的问题是长度为$i$的钢条的最优切割问题，$i$取值从$1\\sim n$。因此钢条切割问题外部只有一层循环。 但对于矩阵乘法问题，求$A_1A_2…A_n$的最佳分割方式，分割并不一定是从$A_1$开始的，所以需要子问题的两端都需要变化，即$A_i…A_j$，其中$i$的取值是$1\\sim n$，$j$的取值是$i$到$n$。（$i$和$j$决定了矩阵序列的长度，在实际算法中，取$i$和长度$l$变量，$j$根据$i$和$l$算出）。因此矩阵乘法问题的子问题空间包含两个变量，外部有双层循环。 证明用来构成问题最优解的子问题本身必须是最优解。可以通过反证法，如果子问题不是最优解，那么将问题中的这一部分子问题替换为最优解，原问题能获取到更优的解。这个证明方法称为“剪切-黏贴”（Cut-and-Paste）方法 对于不同的问题，最优子结构的不同体现在两个方面（这里关注的是循环最内层的表达式） 原问题的最优解包含多少个子问题 在确定最优解使用哪些子问题时，要考察多少种可能。 对于钢条切割问题，最优解只需要包含一个子问题，求钢条切割一刀后，剩下部分的最佳切割方式。对于长度为$n$的钢条，第一刀长度一共有$n$种可能性。 对于矩阵乘法问题，最优解需要包含两个子问题，切割后的$A_i…A_k$与$A_k…A_j$各自的最佳切分方式。对于$A_i…A_j$，$k$的取值一共有$j-i$种可能性。 可以从一个问题一共可能的子问题个数和每个子问题需要考察的可能性数量两方面来确定一个问题的时间复杂度。 例如钢条切割问题，长度为$n$的钢条，一共有$\\Theta(n)$个子问题，每个子问题最多有$n$个可能性，所以时间复杂度为$O(n^2)$。对于矩阵乘法问题，因为$i$和$j$的变化，一共有$\\Theta(n^2)$个子问题，每个子问题最多有$n-1$个可能性，所以时间复杂度为$O(n^3)$。 Subtitles 需要注意不要在不是最优子结构的时候使用动态规划。 如求有向图的最短路径可以使用动态规划，但求最长路径就无法使用动态规划。这里的最长路径限定没有闭环，不然可以通过无限次闭环来增加路径。 以结点$u$到结点$v$为例子，在最短路径问题下是存在最佳子结构的。假设在$u$到$v$的最短路径上存在结点$w$，$u$到$w$和$w$到$v$都必然是最短路径。否则应用剪切黏贴法，如果有$u$到$w$的更短路径，那么用更短的路径替换则能得到$u$到$v$的更优解。 但在最长路径问题下是不存在最佳子结构的，即$u$到$v$的最长路径上存在结点$w$，$u$到$w$和$w$到$v$不一定是各自的最长路径。以下图为例 。 如果求$q$到$t$的的最长路径，那么应该是$q\\rightarrow r \\rightarrow t$。但是$q\\rightarrow r$并不是$q$到$r$的最长路径，其最长路径为$q \\rightarrow s \\rightarrow t \\rightarrow r$，$r$到$t$的最长路径为$r \\rightarrow q \\rightarrow s \\rightarrow t$。而$q$到$r$和$r$到$t$不能取各自最长路径的原因是，如果这么做了就会形成闭环回路。 虽然最长路径和最短路径都是将原问题拆分为了两个子问题，但是因为最长路径的两个子问题是相关的，所以不能用动态规划。例如在求$q$到$r$的最长路径的子问题时，因为用了$q \\rightarrow s \\rightarrow t$,在求$r$到$t$的时候就不能使用$q \\rightarrow s \\rightarrow t$，否则就存在了闭。即一个子问题的解会干扰到另一个子问题的求解，这就是子问题相关。 在最短路径问题下，不存在子问题相关，在两个子问题中也不会出现相同的结点。证明如下： 如果从$u$到$w$和从$w$到$v$两个子问题中都需要经过结点$x$，即路径时$u\\rightarrow x\\rightarrow w$和$w \\rightarrow x \\rightarrow v$，那么$x \\rightarrow w$和$w \\rightarrow x$可以相互抵消，最终路径为$u \\rightarrow x \\rightarrow v$。这又与经过$w$的假设不匹配，所以两端路径不可能都经过$x$。 Overlapping subproblems 另一个动态规划需要满足的要求是重叠子问题，即在递归子问题空间中的问题时，子问题是需要是重复出现的，而不是一直出现新的子问题。与动态规划相对的是分治法，在分治法中，解决的每个的子问题都是全新的子问题，其中也不包含已经解决的小子问题。 如矩阵乘法问题中，$m[3,4]$这个子问题的求解，在求$m[2,4]$,$m[1,4]$,$m[3,5]$等中都会出现。下图展示了在求解$m[1,4]$的过程中，出现的子问题，其中深色部分为已经出现过的子问题。 因为使用了自底向上法或者备忘录法来规避了子问题的重复计算时间，动态规划的时间复杂度才能是多项式级别的，否则是指数形式。 在切割钢条问题的一节中，已经从数学上证明了迭代求解切割钢条问题复杂度为$O(2^n)$，也可证明矩阵乘法问题，迭代求解的复杂度也为$O(2^n)$。迭代法的伪代码为： 12345678910111213RECURSIVE-MATRIX-CHAIN(p,i,j)if i == j return 0m[i,j] = MAXfor k = i to j-1 q = RECURSIVE-MATRIX-CHAIN(p,i,k) + RECURSIVE-MATRIX-CHAIN(p,k+1,j) + p[i-1]p[k]p[j] if q &lt; m[i,j] m[i,j] = qreturn m[i,j] c++代码如下： 123456789101112131415int RecursiveMatrixChain(int* matrixSizeArray, Matrix* minMultiplications, int i, int j){ if (i == j) return 0; minMultiplications-&gt;data[i][j] = INT_MAX; for (int k = i; k &lt; j; k++) { int tempMin = RecursiveMatrixChain(matrixSizeArray, minMultiplications, i, k) + RecursiveMatrixChain(matrixSizeArray, minMultiplications, k + 1, j) + matrixSizeArray[i] * matrixSizeArray[k + 1] * matrixSizeArray[j + 1]; if (tempMin &lt; minMultiplications-&gt;data[i][j]) minMultiplications-&gt;data[i][j] = tempMin; } return minMultiplications-&gt;data[i][j];} 时间复杂为 $$ T(n)\\geq \\begin{cases} 1 &amp; n=1 \\\\ 1 + \\sum_{k=1}^{n-1}(T(k)+T(n-k)+1) &amp; n &gt; 1 \\end{cases} $$ 可以用数学归纳法证明$T(n)=O(2^n)$ 假设$T(n)=\\Omega(2^n)$，可取$T(n)\\geq 2^{n-1}，$当$n=1$时，$T(n)\\geq 1 = 2^0$，得证。 当$n\\geq 2$时， $$ T(n) \\geq 1 + \\sum_{k=1}^{n-1}(T(k)+T(n-k)+1) \\\\ = 1 + \\sum_{k=1}^{n-1} T(k) +\\sum_{k=1}^{n-1}T(n-k) +\\sum_{k=1}^{n-1} 1 \\\\ = 1 + \\sum_{k=1}^{n-1} T(k) + \\sum_{i = n-1}^{1} T(i) +(n-1) \\\\ = 2\\sum_{i=1}^{n-1}2^{i-1}+n \\\\ = 2(2^{n-1}-1)+n \\\\ = 2^n -2 +n \\\\ \\geq 2^{n-1} $$ 得证。而使用动态递归的方法，将时间复杂度变味了$n^3$，大幅提升了算法的效率。 Reconstructing an optimal solution 为了重构出最佳解（在写算法时，关注的是最佳解的值），需要在计算过程中保留一些关键数据，如在矩阵乘法问题中保存每一步的$k$值，即矩阵$s[i,j]$ Memoization 如在求解钢条切割问题一样，矩阵乘法问题也可以通过自顶向下的备忘录法解决，伪代码如下： 12345678910111213141516171819MEMOIZED-MATRIX-CHAIN(p)n = p.length - 1m = new matrix[1~n][1~n]for i = 1 to n for j = i to n m[i,j] = MAXreturn LOOKUP-CHAIN(m,p,1,n)LOOKUP-CHAIN(m,p,i,j)if m[i,j] &lt; MAX return m[i,j]else for k = i to j-1 q = LOOKUP-CHAIN(m,p,i,k) + LOOKUP-CHAIN(m,p,k+1,j) + p[i-1]p[k]p[j] if q &lt; m[i,j] m[i,j] = qreturn m[i,j] c++代码如下： 1234567891011121314151617181920212223242526272829void MemoizedMatrixChain(int* matrixSizeArray, Matrix* minMultiplications){ for (int i = 0; i &lt; minMultiplications-&gt;row; i++) { for (int j = 0; j &lt; minMultiplications-&gt;column; j++) minMultiplications-&gt;data[i][j] = INT_MAX; } LookupChain(matrixSizeArray, minMultiplications, 0, 5);}int LookupChain(int* matrixSizeArray, Matrix* minMultiplications, int i, int j){ if (minMultiplications-&gt;data[i][j] &lt; INT_MAX) return minMultiplications-&gt;data[i][j]; if (i == j) minMultiplications-&gt;data[i][j] = 0; else { minMultiplications-&gt;data[i][j] = INT_MAX; for (int k = i; k &lt; j; k++) { int tempMin = RecursiveMatrixChain(matrixSizeArray, minMultiplications, i, k) + RecursiveMatrixChain(matrixSizeArray, minMultiplications, k + 1, j) + matrixSizeArray[i] * matrixSizeArray[k + 1] * matrixSizeArray[j + 1]; if (tempMin &lt; minMultiplications-&gt;data[i][j]) minMultiplications-&gt;data[i][j] = tempMin; } } return minMultiplications-&gt;data[i][j];} 该算法的时间复杂度同样为$O(n^3)$ 如果一个问题的子问题空间中的所有问题都必须被解决，那么自底向上法的效率更高，因为它减少了函数调用堆栈的花销。但如果子问题空间的问题并一定需要全部被解决，那么自顶向下备忘法可能效率更高，因为他只会计算需要用到的子问题。 Longest common subsequence //TODO Optimal binary search trees //TODO 引用： Introduction to Algorithms 3rd Sep.2009","link":"/IA-Chapter15-Notes/"},{"title":"《算法导论》 第六章笔记","text":"《算法导论》中第六章笔记。 关于堆与堆排序。 Chapter 6 Heapsort 如归并排序一样，堆排序的时间复杂度为$O(nlgn)$，但与归并排序不同的是，堆排序在运行过程中仅需要固定大小的外部空间，即运行时所需的内存不会因为输入规模的上升而上升，这一点与插入排序一样。 所以堆排序是结合了插入排序和归并排序两者的优点。 “堆”（Heap）这一称呼最早就是针对于堆排序的，但是在一些语言的垃圾回收概念中存在堆栈的概念。这两者虽然名字相同，但实际上是完全不同的存在。 Heap 堆（Heap）或称二叉堆（Binary Heap）是一种用数组来表示近似完全二叉树的数据结构。树中的每一个元素都对应数组中的一个元素，树除了最下面一层，其余层都是满的。 二叉堆与二叉树如下图所示： 在数组中，用一个变量heap-size来表示数组中真正元素的个数。如一个数组可能长度为10，但其中真正的元素个数为5，剩下的都为空，即$0\\leq A.heap-size \\leq A.length$。 树的根节点用$A[1]$表示，所有结点可根据以下伪代码计算其父结点，左子树以及右子树。这些操作都是单纯的乘二或除二，因此可以用位运算来实现。 12345678PARENT(i)return i/2LEFT(i)return 2iRIGHT(i)return 2i+1 c++ 实现如下，注意因为c++中的索引是从0开始，所以index值需要做相应调整： 123456789101112int parent(int index){ return ceil(index / 2.0) - 1;}int left(int index){ return index * 2 + 1;}int right(int index){ return index * 2 + 2;} 有两种二叉堆：最大堆（max-heaps）与最小堆（min-heaps）。对于最大堆，每个结点都需要满足最大特性（max-heap property），即 $$ A[Parent(i)] \\geq A[i] $$ 可以因此判断出在最大堆中最大的元素存储在根结点。同理最小堆需要满足$A[Parent(i)] \\leq A[i]$，最小的元素存储在根结点。 之后的几个章节都默认以最大堆作为对象进行分析 将一个堆看作一棵树后，将一个结点的高度定义为这个结点到叶子的最长单一路径，一棵树的高度定义为根节点的高度。因为堆是近似完全二叉树，所以对于有$n$个结点的堆来说，其高度为$\\Omega(\\log n)$。 Maintaining the heap property 通过函数MAX-HEAPIFY来保持堆的特性，该函数需要传入需要处理的数组$A$和需要进行处理的元素索引值$i$。 调用前默认元素$i$的左树$LEFT(i)$和右树$RIGHT(i)$都满足最大特性，但元素$i$本身可能违背，即元素$i$可能小于它的子结点。 MAX-HEAPIFY操作是将值$A[i]$“向下沉”，即将更小的$A[i]$值向树的更底层传递，伪代码如下： 12345678910111213MAX-HEAPIFY(A,i)l = LEFT(i)r = RIGHT(i)if l &lt;= A.heapSize and A[l] &gt; A[i] largest = l;else largest = i;if r &lt;= A.heapSize and A[r] &gt; A[largest] largest = r;if (largest != i) exchange A[i] with A[largest] MAX-HEAPIFY(A,largest) c++代码实现如下： 12345678910111213141516171819202122void MaxHeapify(int index, int dataLength){ if (index &gt;= dataLength) { cout &lt;&lt; &quot;Invalid index &quot; &lt;&lt; index &lt;&lt; endl; return; } int largest = index; int lIndex = left(index); int rIndex = right(index); if (lIndex &lt; dataLength) largest = dataArray[index] &gt; dataArray[lIndex] ? index : lIndex; if (rIndex &lt; dataLength) largest = dataArray[rIndex] &gt; dataArray[largest] ? rIndex :largest; if (largest != index) { int temp = dataArray[index]; dataArray[index] = dataArray[largest]; dataArray[largest] = temp; MaxHeapify(largest, dataLength); }} 伪代码中的exchange操作的结果就是值更大的结点向树的上方传递，值小的结点向树的下方下沉。 算法的图解如下： (a)图到(b)中，值为14的结点向上移动，值为4的结点向下移动。(b)到©图，值为8的结点向上移动，值为4的结点向下移动。 该算法实际上是一个递归，对结点(i)调用后，会对原先拥有最大结点的子树进一步调用（MAX-HEAPIFY（A，largest））。 如果一个树的结点数目为$n$，其子树最多拥有$2n/3$个结点。首先因为二叉堆需要满足近似完全二叉树，即只有最下一层的结点可能是不满的。因此最大比例情况发生在最下层结点一半是空的时候，此时非空另一半的子树拥有最大比例的子结点。 如下图所示，此时树中一共有11个结点，根节点的左子树此时拥有的结点比例是最大的，为7/11。 一个树的结点数目为$n$，其子树最多拥有$2n/3$个结点。证明如下： 首先如果树的每一层结点数是上一层的两倍，根据等比数列公式可以求得，高度为$h$的树，其结点总数为： $$ \\frac{a_1-a_nq}{1-q} \\\\ =\\frac{1- 2^{h-1}2}{1-2} \\\\ =2^h-1 $$ 最大比例情况下，即最底层的结点一半为空的情况下，最大子树所占结点数目的比例计算如下： $$ \\frac{2^{h-1}-1}{2^h-1 - \\frac{2^{h-1}}{2}} $$ 该式子的分子是子树的结点总数，在最大情况下子树可以看作是一颗层数小1的满树($2^{h-1}-1$)。分母是整棵树的结点数，为满树($2^h-1$)减去最下一层结点的一半（$\\frac{2^{h-1}}{2}$）. 对上式求极限可得： $$ \\lim_{n\\rightarrow \\infty} \\frac{2^{h-1}-1}{2^h-1 - \\frac{2^{h-1}}{2}} \\\\ =\\lim_{n\\rightarrow \\infty} \\frac{2^{-1}-\\frac{1}{2^h}}{1-\\frac{1}{2^h}-2^{-2}}\\\\ =\\frac{\\frac{1}{2}-0}{1-0-\\frac{1}{4}} \\\\ = \\frac{2}{3} $$ 因此MAX-HEAPIFY(A,i)的时间复杂度递归表达式可以写作 $$ T(n)\\leq T(2n/3) +\\Theta(1) $$ 该式子满足主方法的第二种情况，因此可以算出时间复杂度为$T(n)=O(\\lg n)$ Building a heap 可以通过自底向上（即从树的第一个非叶子结点开始向上调用直到根结点）的调用MAX_HEAPIFY方法将一个普通数组转换为满足最大特性的数组。将这个方法称为BUILD-MAX-HEAP(A) 对于一个数组$A$，索引值从$\\lfloor n/2 \\rfloor +1$到$n$都是这个树的叶子。 证明如下： 如果一个结点的索引值为$\\lfloor n/2 \\rfloor +1$，求这个结点的左结点，可得： $$ LEFT(\\lfloor n/2 \\rfloor +1)\\\\ =2(\\lfloor n/2 \\rfloor +1)\\\\&gt;2( (\\frac{n}{2}-1)+1)\\\\ =n-2+2 =n $$ 即他的左子树的结点索引值已经大于了$n$，所以他的左子树是不存在的。 使用的同样的方法，也可以证明对于索引值为$\\lfloor n/2 \\rfloor$的结点，其左结点是存在的。 BUILD-MAX-HEAP(A)的伪代码如下，其核心为自底向上对所有的非叶子结点进行MAX-HEAPIFY 1234BUILD-MAX-HEAP(A)A.heap-size=A.lengthfor i = A.length/2 downto 1 MAX-HEAPIFY(A,i) c++代码实现如下： 12345void BuildMaxHeap(){ for (int i = dataLength / 2 - 1; i &gt;= 0; i--) MaxHeapify(i, dataLength);} 算法图解如下，从(a)到(e)分别表示每一次的循环，(f)为最终结果。 该算法会调用$O(n)$次MAX-HEAPIFY算法，所以复杂度为$O(n\\lg n)$。但这个复杂度并不是紧密的上限。 考虑到对于一个拥有$n$个结点的树，其树高为$\\lfloor \\lg n \\rfloor$。 且可以证明对于高度为$h$的层（这里的高度0是指最下面一层，高度1为倒数第二层，依次类推），节点数最多为$\\lceil n/2^{h+1}\\rceil$。 证明如下： 在前面已经得知，对于一个数组$A$，索引值从$\\lfloor n/2 \\rfloor +1$到$n$都是这个树的叶子。那么可以计算出，一棵树的叶子结点个数为$n-(\\lfloor n/2 \\rfloor +1)+1=\\lceil n/2 \\rceil$。非叶子结点个数为$n-\\lceil n/2 \\rceil= \\lfloor n/2 \\rfloor$ 用数学归纳法证明 对于高度为0的层，即叶子层，其结点个数为$\\lceil n/2 \\rceil$，满足$\\lceil n/2^{h+1}\\rceil$。 对于高度为h-1的层，条件满足。对于高度为$h-1$的层到顶部的结点个数即为一棵树非叶子结点的个数，即$\\lfloor n/2 \\rfloor$。 因此式子为 $$ \\lceil \\frac{\\lfloor n/2 \\rfloor}{2^{h-1+1}} \\rceil \\\\ &lt; \\lceil \\frac{n/2}{2^{h-1+1}} \\rceil \\\\ = \\lceil \\frac{n}{2^{h+1}} \\rceil $$ 即可推导出原式，因此原式得证。 对于BUILD-MAX-HEAP(A)而言，每一次调用MAX-HEAPIFY都与调用时的高度相关，即每个MAX-HEAPIFY的时间复杂度为$O(h)$。 因此整个算法的时间复杂度可表示为 $$ \\sum_{h=0} ^{\\lfloor \\lg n \\rfloor} \\lceil \\frac{n}{2^{h+1}} O(h) \\rceil \\\\ = O( n \\sum_{h=0} ^{\\lfloor \\lg n \\rfloor}\\frac{h}{2^h} )\\\\ = O( n \\sum_{h=0} ^{\\infty}\\frac{h}{2^h} ) $$ 套用公式 $$ \\sum_{k=0}^{\\infty} kx^k=\\frac{x}{(1-x)^2} $$ 得 $$ O( n \\sum_{h=0} ^{\\infty}\\frac{h}{2^h} \\\\ =O(2n)=O(n) $$ 所以BUILD-MAX-HEAP(A)的紧密时间复杂度为$O(n)$ The heapsort algorithm 对排序算法，首先需要调用BUILD-MAX-HEAP(A)算法将数组转换为满足最大特性的数组。满足最大特性后，数组的第一个元素即为最大值，将数组的最后一个值与第一个值进行交换，然后将数组的有效大小缩小（相当于不再追踪最后一个元素，因为此时最后一个元素是原第一个元素即最大元素）。然后再针对新的第一个元素调用MAX-HEAPIFY(A,1)即可。 伪代码如下： 123456HEAPSORT(A)BUILD-MAX-HEAP(A)for i = A.length downto 2 exchange A[1] with A[i] A.heapSize = A.heapSize - 1 MAX-HEAPIFY(A,1) c++代码实现如下 123456789101112131415void heapSort(){ BuildMaxHeap(); for (int tempDataLength = dataLength; tempDataLength &gt; 1;tempDataLength--) { int temp = dataArray[0]; dataArray[0] = dataArray[tempDataLength - 1]; dataArray[tempDataLength - 1] = temp; MaxHeapify(0, tempDataLength - 1); } //This part is not related to the heapsort //Output the sort result and recover the heap HeapDebug(); BuildMaxHeap();} 算法图解如下，(a)为初始状态，(b)到(j)每次循环调用完MAX-HEAPIFY后的结果，(k)为最终结果： 该算法的时间复杂度为$O(n\\lg n)$。因为BUILD-MAX-HEAP的复杂度为$O(n)$，且调用了$O(n)$次复杂度为$O(\\lg n)$的MAX-HEAPIFY算法。 Priority Queue 优先队列（Priority queues）是二叉堆排序的一个应用。 如有一系列任务，每个任务有不同的优先级，每次任务处理完后需要在剩下的任务中选取优先级最高的任务进行处理。可以将一个任务看作是一个结点，任务的优先级看作是结点的值，因此每次选取任务时只要从最大堆中取第一个元素即可。存放这些任务的队列即为优先队列。 也可以通过二叉堆来实现事件的回放，每一个事件作为树中的一个结点，事件的时间作为结点的值。因此在回放事件时，每次只要取最小堆中的第一个元素即可。 一个优先队列需要实现如下几个命令： INSERT(S,x) 将元素x插入队列S中 MAXIMUM（S）返回S中的最大元素 EXTRACT—MAX(S)返回并取出S中的最大元素 INCREASE-KEY(S,x,k)增加S中的元素x的值至k，k必须大于原先x的值。 MAXIMUM伪代码如下： 12HEAP-MAXIMUM(A)return A[1] c++代码实现如下： 1234int Maximum(){ return dataArray[0];} EXTRACT-MAX(S)的伪代码如下： 12345678HEAP-EXTRACT-MAX(A)if A.heap-size &lt; 1 error &quot;heap under flow&quot;max = A[1]A[1] = A[A.heapSize]A.heapSize--MAX-HEAPIFY(A,1)return max; c++代码实现如下： 12345678int ExtractMaximum(){ int max = dataArray[0]; dataArray[0] = dataArray[--dataLength]; if (dataLength != 0) MaxHeapify(0, dataLength); return max;} EXTRACT-MAX的时间复杂度为$O(\\lg n)$ INCREASE-KEY的伪代码如下： 1234567HEAP-INCREASE-KEY(A,i,key)if key &lt; A[i] error &quot;new key is smaller than current key&quot;A[i] = keywhile i &gt; 1 and A[PARENT(i)] &lt; A[i] exchange A[i] with A[PARENT(i)] i = PARENT(i) c++代码实现如下： 1234567891011121314151617181920212223void IncreaseKey(int index, int newValue){ if (index &gt;= dataLength) { cout &lt;&lt; &quot;Invalid index in IncreaseKey&quot; &lt;&lt; endl; return; } if (dataArray[index] &gt;= newValue) { cout &lt;&lt; &quot;No need to update&quot; &lt;&lt; endl; return; } dataArray[index] = newValue; int parentIndex = parent(index); cout &lt;&lt; &quot;parent index is &quot; &lt;&lt; parentIndex &lt;&lt; endl; while (index &gt; 0 &amp;&amp; dataArray[parentIndex] &lt; newValue) { dataArray[index] = dataArray[parentIndex]; dataArray[parentIndex] = newValue; index = parent(index); parentIndex = parent(index); }} INCREASE-KEY的算法主要思想是将更大数值的结点与父结点比较，如果更大则向上移动。这里的操作与MAX-HEAPIFY实际上是相反的，MAX-HEAPIFY是将更小的数值向下沉。最坏情况下循环的次数与堆的高度相同，即时间复杂度为$O(\\lg n)$ 算法图解如下,(a)图是原先的值，(b)图是将值改为15后，©和(d)为循环过程： INSERT的伪代码如下： 1234MAX-HEAP-INSERT(A.key)A.heapSize = A.heapSize+1A[A.heapSize] = -MAXHEAP-INCREASE-KEY(A,A.heapSize,key) c++代码实现如下： 1234567891011void Insert(int value){ dataLength++; if (dataLength &gt; arrayLength) { cout &lt;&lt; &quot;The heap is full&quot; &lt;&lt; endl; return; } dataArray[dataLength - 1] = -INT_MAX; IncreaseKey(dataLength - 1, value);} INSERT算法是先加入一个无限小的结点，再通过INCREASE-KEY方法将这个结点的值改为需要的值。该算法的时间复杂度与INCREASE-KEY相同，即$O(\\lg n)$ 引用： Introduction to Algorithms 3rd Sep.2009","link":"/IA-Chapter6-Notes/"},{"title":"《LearnOpenGL》 笔记（二）","text":"Hello Window 引入相关库 123#include &lt;glad/glad.h&gt;#include &lt;GLFW/glfw3.h&gt;#include &lt;iostream&gt; 初始化GLFW 1234glfwInit();glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); glfwWindowHint函数的第一个参数用来表示要设定的参数，所有参数都是以GLFW_开头，函数的第二个参数是需要设定的值。 glfwWindowHint接受的参数与参数值，可以在GLFW文档中设置。 创建GLFW窗口 12345678GLFWwindow *window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, &quot;LearnOpenGL&quot;, NULL, NULL);if (window == NULL){ std::cout &lt;&lt; &quot;Failed to create GLFW window&quot; &lt;&lt; std::endl; glfwTerminate(); return -1;}glfwMakeContextCurrent(window); 通过glfwCreateWindow函数创建窗口，前两个参数设置窗口的宽和高，第三个参数设置窗口名，最后两个参数教程中未做解释。该函数会返回一个GLFWWINDOW类型的指针。 glfwMakeContextCurrent将glfwCreateWindow返回的表示窗口的指针绑定给当前线程环境。 初始化GLAD 12345if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)){ std::cout &lt;&lt; &quot;Failed to initialize GLAD&quot; &lt;&lt; std::endl; return -1;} GLAD用来管理OpenGL函数的地址，因此在调用任何的OpenGL函数前需要先对GLAD进行初始化。 需要给gladLoadGLLoader指定读取函数地址的函数，函数地址是系统相关的。在绑定了窗口后，可以通过glfwGetProcAddress函数获取到相应系统给出的函数地址。 因此需要先初始化GLFW，绑定GLFW窗口，再初始化GLAD，然后才能使用OpenGL相应的函数。 渲染循环 12345678while (!glfwWindowShouldClose(window)){ glClearColor(0.2f, 0.3f, 0.3f, 1.0f); glClear(GL_COLOR_BUFFER_BIT); glfwSwapBuffers(window); glfwPollEvents();} glClearColor设置ClearColor的颜色。 glClear设置需要清理的对象，这里仅清理颜色缓存。 glfwSwapBuffers设置双缓冲。如果仅使用单缓存时可能会有图像闪烁的原因，因为图像并不是瞬间被画出，而是从左至右，从下至上逐像素画出。为避免这种情况的发生，可以用双缓存，当前缓存在显示时，后缓存进行读取，当后缓存读完，交换前后缓存，如此，图像可瞬间画出。 glfwPollEvents用来检查是否有事件触发，包括键盘事件，鼠标事件，和窗口事件等。（即使不需要处理输入，也仍然要设定该函数）。 按键处理 12345void processInput(GLFWwindow *window){ if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) glfwSetWindowShouldClose(window, true);} glfwGetKey用来获取当前窗口按下的按键。 glfwSetWindowShouldClose设置当前窗口需要被关闭，调用该函数后，窗口会被关闭。 processInput函数需要在函数主循环中被调用，保证一直检查输入状态。 Viewport设置 123456glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);void framebuffer_size_callback(GLFWwindow *window, int width, int height){ glViewport(0, 0, width, height);} 设置在窗口尺寸改变时，设置回调，并在回调中，调用glViewport函数更改viewport。 终止GLFW 1glfwTerminate(); 源码 CPP 引用： Hello Window","link":"/LearnOpenGL-Notes-2/"},{"title":"《LearnOpenGL》 笔记 (一)","text":"Creating a Window 在OpenGL前，首先需要创建OpenGL的上下文和用于绘制的窗口等，这些内容是与操作系统相关的，而OpenGL则是希望成为一个夸平台的工具，因此OpenGL本身并不复杂这些内容的处理，需要用户自己来进行相关的环境配置。好在一些现有的库以及帮助完成了工作，这里首先需要进行的就是相关库的配置。 GLFW GLFW是一个开源的OpenGL库，主要为创建窗口，OpenGL上下文，处理用户输入等功能提供了简单的API。 从官网中下载GLFW源文件，然后再下载并安装CMake软件推荐，windows平台下推荐下载msi版本。 安装Cmake后，按下图进行配置，从上到下三个红框分别表示，GLFW的源代码地址，编译后结果的输出地址以及编译对象，这里因为想搭建的是VSCode环境下的地址，所以选择了MinGW Makefiles。其中第三个红框的窗口时通过按左下角的Configure按钮呼出的。 配置完成后，勾选上最上面的BUILD_SHARD_LIBS选项后点积Generate按钮。 输出后，进入输出结果的地址，并通过mingw32-make命令进行编译，如下： 注意这一步需要安装mingw工具。 完成后进入src文件夹，其中的glfw3.dll和libglfw3dll.a即为所需要的静态链接文件。 而需要的头文件，则在glfw3的源代码路径下的include文件夹中 GLAD OpenGL实质上是一个标准，因此对于不同的显卡厂商而言，会做出不同的OpenGL相关驱动，也因此OpenGL函数的地址并不能在编译时刻确定，只能在Runtime时找到相关的函数指针地址再使用该指针进行操作，无疑这是一个很繁琐的功能。 而GLAD库简化了相关操作，并且GLAD库使用了网络服务来简化了编译过程，只要在其网站上选择目标语言和相关OpenGL类型之后，就可以直接生成出想要的内容并直接下载，网站上的相关设置如下： 当下载GLAD内容后，进入文件夹，并通过命令行运行如下两个命令来生成需要的静态链接文件。 12gcc .\\src\\glad.c -c -I.\\include\\ar -rc libglad.a glad.o 第一条命令时将.c文件编译为.o文件，第二条命令是将.o文件转换为静态链接.a文件。生成的libglad.a文件即为需要的静态链接文件。 GLAD需要的头文件在include文件夹下。 配置VS Code 首先安装C/C++ Project Generator插件帮助创建相关的文件夹，安装插件并运行Create C++ Project后，将之前生成的GLFW和GLAW的静态链接文件和头文件分别拷贝至lib和include文件夹下，如下所示： 还需要对Makefile文件进行修改，修改后的结果如下： 1234567891011121314151617181920212223242526272829303132333435363738394041CC := g++CFLAGS := -std=c++17 -Wall -Wextra -gBIN := binSRC := srcINCLUDE := includeLIB := libLIBRARIES := -lglad -lglfw3dll # Add Lib fileifeq ($(OS),Windows_NT)EXECUTABLE := main.exeSOURCEDIRS := $(SRC)INCLUDEDIRS := $(INCLUDE)LIBDIRS := $(LIB)elseEXECUTABLE := mainSOURCEDIRS := $(shell find $(SRC) -type d)INCLUDEDIRS := $(shell find $(INCLUDE) -type d)LIBDIRS := $(shell find $(LIB) -type d)endifCINCLUDES := $(patsubst %,-I%, $(INCLUDEDIRS:%/=%))CLIBS := $(patsubst %,-L%, $(LIBDIRS:%/=%))SOURCES := $(wildcard $(patsubst %,%/*.cpp, $(SOURCEDIRS)))OBJECTS := $(SOURCES:.cpp=.o)all: $(BIN)/$(EXECUTABLE).PHONY: cleanclean: -$(RM) $(BIN)/$(EXECUTABLE) -$(RM) $(OBJECTS)run: all ./$(BIN)/$(EXECUTABLE)$(BIN)/$(EXECUTABLE): $(SOURCES) # Use SOURCES instead of OBJECTS to avoid complile without include/lib $(CC) $(CFLAGS) $(CINCLUDES) $(CLIBS) $^ -o $@ $(LIBRARIES) 主要的修改点如上注释所示，一是添加了静态文件的链接，原MakeFile文件只是制定了lib文件夹，但需要链接文件夹中的哪些文件并没有说明，需要修改LIBRARIES文件进行说明。其中的-lglad表示链接libglad.a文件，-lglfw3dll表示链接libglfw3dll.a文件。二是将原最后编译步骤中的OBJECTS对象改成了SOURCES。这是因为如果设定了OBJECTS则会隐式的进行一步cpp文件到.o文件的编译，而这次编译并没有指定include和lib目录，则会造成编译失败。 lib文件夹中的glfw.dll文件需要手动的复制到与最后生成的exe文件同目录下，这里即是bin文件夹。 可将如下代码拷贝至main.cpp文件中，并按下F5自动编译运行，或在Makefile所在目录下通过命令行命令mingw32-make run编译运行。 1234567891011121314151617181920212223242526272829303132333435#include &lt;glad/glad.h&gt;#include &lt;GLFW/glfw3.h&gt;#include &lt;iostream&gt;const unsigned int SCR_WIDTH = 800;const unsigned int SCR_HEIGHT = 600;int main(){ glfwInit(); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); GLFWwindow *window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, &quot;LearnOpenGL&quot;, NULL, NULL); if (window == NULL) { std::cout &lt;&lt; &quot;Failed to create GLFW window&quot; &lt;&lt; std::endl; glfwTerminate(); return -1; } glfwMakeContextCurrent(window); if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) { std::cout &lt;&lt; &quot;Failed to initialize GLAD&quot; &lt;&lt; std::endl; return -1; } while (!glfwWindowShouldClose(window)) { glClearColor(0.0f, 1.f, 0.0f, 1.0f); glClear(GL_COLOR_BUFFER_BIT); glfwSwapBuffers(window); glfwPollEvents(); } glfwTerminate(); return 0;} 结果应该为一个绿色的窗口，如下所示： 至此整个学习OpenGL的环境设置完成。 引用： vscode OpenGL环境搭建 Creating a window","link":"/LearnOpenGL-Notes-1/"},{"title":"Markdown教程","text":"Hexo、Github的项目介绍，简书，有道云笔记，EverNote等等软件和博客网站都支持Markdown语言。 Markdown语言的设计目标是让编写者可以注重文章的内容，以一种较为简单高效的方法完成文章格式的编写。 本篇文章会介绍Markdown比较常见的语法，并介绍一些Markdown的编写工具。 Markdown语法 标题 12# 一级标题## 二级标题 最多可以到六级标题为止 markdown语法符号，比如#，后都需要加上一个空格确保生效 引用 123456&gt; 引用内容&gt;&gt; 引用内容换行//这里空了一行就会引起让引用标记中断&gt; 引用内容&gt; 这样没法换行 引用内容 引用内容换行 引用内容 这样没法换行 根据markdown语法，所有都需要中间空一行，但上例中没有空行，在Next上仍然换行了。这可能是Next的Bug或Feature，但仍然推荐严格安装markdown语法规则添加空行。 在引用之中我们仍然可以使用Markdown语言，比如 12&gt; 引用内容&gt;&gt; 引用中的引用 引用内容 引用中的引用 清单 123* 一号* 二号* 三号 一号 二号 三号 1231. 一号2. 二号3. 三号 一号 二号 三号 在清单内如果需要有段落，则要在新的一段前加入tab。 1234561. 一号清单2. 二号清单 二号清单段落段落段落段落二号清单段落段落段落段落二号清单段落段落段落段落二号清单段落段落段落段落二号清单段落段落段落段落二号清单段落段落段落段落3. 三号清单 一号清单 二号清单 二号清单段落段落段落段落二号清单段落段落段落段落二号清单段落段落段落段落二号清单段落段落段落段落二号清单段落段落段落段落二号清单段落段落段落段落 三号清单 代码块 用前后两段三个`来表示一个代码块 123/```cs 演示 Debug.Log(&quot;这是一段代码&quot;);```/ 演示1Debug.Log(&quot;这是一段代码&quot;); 为了防止演示代码被误认为是一个新的代码块，在演示行前后加了/，实际使用时不需要 分割线 用三个***或—或___来表示一段分割线，在分割符号所在行内不能有其他东西 1*** 超链接 超链接的实现有两种方式,inline和reference inline方式，是用[]包裹住需要加入超链接的文字，用()包裹住超链接地址 1[百度](www.baidu.com) 百度 refernece方式，是用[]包裹住需要加入超链接的文字，再接一个[]包裹住超链接文字的Tag，再文章的其他地方（最少需要在下一行），通过[]:()来标记tag的地址，以简化多段文字指向同一个超链接的情况的编写。 12345[谷歌][google][google]:(www.google.com) 谷歌 超链接的[]和()符号后都不需要跟空格 图片 图片与超链接语法相似，只不过在包裹超链接前的[]前加入一个感叹号即可 1![头像地址](https://xuejiaw.github.io/uploads/blackCat.jpg) 表格 1234| 分类1 | 分类2 || ------- | ------- || 数据1 | 数据2 || 数据3 | 数据4 | 分类1 分类2 数据1 数据2 数据3 数据4 如果表格中的元素需要换行，可加入&lt;br&gt;作为\\n Next特定标签 使用Next编写博客时，可以在文章的md文件中使用一些特定的标记来增加文章样式。 居中简介 在使用了&lt;!--more--&gt;标记后，可以在文章首页增加文章的简介并添加阅读全文按钮，使用cq标记则可以在文章简介前后加入双引号，并居中显示简介。 123文章简介。 文章简介。 Note 加入更多样式的Note，可以在主题配置文件的note字段修改样式 12345note: style: simple icons: true border_radius: 3 light_bg_offset: 0 123{% note [class] %}内容内容{% endmessage %} 内容内容 支持的class有default,primary,success,info,warning,danger 颜色高亮 将部分文字修改颜色 1&lt;label style=&quot;color:red&quot;&gt; 红色文字 &lt;/label&gt; 红色文字 Tab 加入可切换的tab页面 1234567891011{% tabs Tab名字 , 2 %}&lt;!--格式 &lt;tabs 名字,初始状态点第几个tab&gt; --&gt;&lt;!-- tab --&gt; &lt;!-- 这里tab后也能跟名字，这样可以改写每个Tab各自的名字，否则使用上面定义的名字--&gt;第一个Tab&lt;!-- endtab --&gt;&lt;!-- tab --&gt;第二个Tab&lt;!-- endtab --&gt;&lt;!-- tab --&gt;第三个Tab&lt;!-- endtab --&gt;{% endtabs %} 第一个Tab 第二个Tab 第三个Tab 注意在Tabs中插入代码块存在Bug，如果要插入代码，可以使用Hexo的Code Tags 123{% codeblock 测试 lang:csharp %}Debug.Log(&quot;ABC&quot;){% endcodeblock %} 测试1Debug.Log(&quot;ABC&quot;) Markdown编辑工具 VSCode 现在我编写Markdown时主要使用的就是VSCode，VSCode本身即支持Markdown的实时预览，在运行Markdown: 打开侧边预览功能后即可，默认快捷键时Ctrl K +V 如果使用VSCode编写Markdown，推荐安装Paste Image插件，该插件可以直接将截图复制进md文件，并且下载到本地。 Typora Typora是一个轻量级的专门的Markdown编写工具，我从Typora换为VSCode的主要原因也就是觉得没必要多装一个应用，并非Typora本身存在什么缺陷。 Onenote + OneMarkdown 我从大学开始是一个OneNote的重度使用者，但无奈目前OneNote不支持Markdown，于是只能寻找一些曲线救国的方法。]OneNoteGem](https://www.onenotegem.com/addins.html)是一个付费的OneNote插件，其中有一个模块叫做OneMarkdown。 当使用付费版之后，在OneMarkdown上编辑的页面会自动同步到OneNote上。 OneMarkdown最终的显示效果并不是太理想，所以Onenote+OneMakeDown最好只作为数据的归档使用。OneNoteGem在淘宝上有相应的店家，但OneMakeDown因为销量太低没有上架，所以要购买需要单独找店家资讯。 段落首行缩进 Markdown本身是一个基于英文设计的标记语言，所以本身对于中文习惯的段落首行缩进并没有支持，如果直接使用空格会发现整个段落都进行了缩进。我们可以通过将中文输入法切换为全角（一般快捷键为Shift+Space）后再输入两个空格解决。 HTML缩进 表格中的内容如果需要缩进，直接输入空格或者tab会被MD忽视。所以需要借助HTML转义符&amp;ensp;或&amp;emsp;，前者是半角转义符，后者是全角转义符。 1&amp;emsp;&amp;emsp;缩进的文字 缩进的文字 参考 https://markdown.tw/ https://almostover.ru/2016-01/hexo-theme-next-test/","link":"/MarkdownTutorial/"},{"title":"正则表达式教程","text":"介绍了正则表达式的元字符、缩写、前后预查、标记位、贪婪与惰性匹配和捕捉模式一系列概念。 主要是Github上教程的学习笔记。 正则表达式简介 正则表达式（Regular Expression）是一种用来搜索特定字符的表达式。在一些语言的字符串的模式匹配中可以使用正则表达式来找寻子字符串，在Unix系统中也可以用正则表达式来搜索文件。熟练运用正则表达式可以减少寻找子字符串的逻辑判断。 例如 ^[a-z0-9_-]{3-15}$ 表示可以用来判断一个字符串是否满足以下条件 由小写字母、数字、或者_-组成 位数在3-15位 所以字符串 john_doe 满足搜索条件而字符串 Jo 不满足。 元字符 元字符 介绍 实例 . 匹配除了换行符外的所有符号 “.ar” =&gt; The car parked in the garage. [] 匹配在该方括号内的所有字符 “[Tt]he”=&gt;The car parked in the garage. [^ ] 匹配除了在该方括号内的所有字符 “[^c]ar”=&gt;The car parked in the garage. * 匹配大于等于0个*号前的字符 “[a-z]*”=&gt;The car parked in the garage.“\\s*car\\s*”=&gt;The car parked in the garage. + 匹配大于等于1个+号前的字符 “c.+t”=&gt;The car parked in the garage. ? 标记? 之前的字符为可选 “[T]?he”=&gt;The car parked in the garage. {n, m} num个字符，n&lt;=num&lt;=m。可以不指定n或者m，则只约束一边的大小 “[0-9]{2, 3}”=&gt;The number was 9.9997 but we rounded it off to 10.0“[0-9]{2, }”=&gt;The number was 9.9997 but we rounded it off to 10.0“[0-9]{3}”=&gt;The number was 9.9997 but we rounded it off to 10.0 (xyz) 严格匹配字符xyz (was)=&gt;The number was 9.9997 but we rounded it off to 10.0 | 或运算符，匹配 | 前或后的字符 “(c|g)ar”=&gt;The car parked in the garage.“(T|t)he|car”=&gt;The car parked in the garage. \\ 转义符，用来匹配 [ ] *这样的元字符 “(f|m)at.?”=&gt;The fat cat sat on the mat. ^ 匹配输入的开头 “(T|t)he”=&gt;The car parked in the garage.“^(T|t)he”=&gt;The car parked in the garage. $ 匹配输入的结尾 “(at.)”=&gt;The fat cat.sat.on the mat.“(at.)$”=&gt;The fat cat.sat.on the mat. 缩写 正则表达式也提供了一些常见的匹配模式的缩写 缩写 含义 \\w [a-zA-Z0-9_] \\W [^\\w_] \\d [0-9] \\D [^\\d] \\s 空白字符[\\t\\n\\f\\r\\p] \\S [^\\s] \\t 制表符 \\n 换行符 \\f 换页符 \\r 回车符 \\p \\r\\n 前后预查 前后预查是用来选择匹配出来的字符中的某一部分，例如有字符串 $ 3.22 $4.44 $10.88 ，只想获取跟在$后的数字和小数点，所以应该只匹配4.44和10.88。我们将$称为预查表达式，我们将通过$来定位我们想要的特定数字。 预查字符 介绍 实例 ?= 正前向预查，?=前是需要匹配的内容，?=后跟着预查表达式，匹配之后必须跟着预查表达式 $(?=[0-9.]+) =&gt; $ 3.22 $4.44 and $10.88 匹配的内容是$，预查表达式是[0-9.]+ ?! 负前向预查，?! 前是需要匹配的内容，?! 后跟着预查表达式，匹配之后必须不跟着预查表达式 $(?![0-9.]+) =&gt; $ 3.22 $4.44 and $10.88 ?&lt;= 正后向预查，?&lt;=后跟着预查表达式，再之后是需要匹配的内容，匹配内容之前必须跟着预查表达式 (?&lt;=$)[0-9.]+ =&gt; $ 3.22 $4.44 and $10.88匹配的内容是[0-9.]+，预查表达式是$ ?&lt;! 负后向预查，?&lt;! 后跟着预查表达式，再之后是需要匹配的内容，匹配内容之前必须不跟着预查表达式 (?&lt;!$)[0-9.]+ =&gt; $ 3.22 $4.44 and $10.88 标记位 标记位 介绍 实例 i 无视大小写 /The/ =&gt; The fat cat sat on the mat./The/gi =&gt;The fat cat sat on the mat. g 全局搜索（如果这个flag没有开启，则只匹配第一个搜索到的结果） /.(at)/ =&gt; The fat cat sat on the mat./.(at)/g/ =&gt; The fat cat sat on the mat. m 多行匹配锚点，将^,&amp;的工作范围从全文变成每行 /.at(.)?$/ =&gt; The fatcat saton the mat./.at(.)?$/gm =&gt; The fatcat saton the mat. 贪婪匹配和惰性匹配 像*和+默认都是贪婪模式，这意味着模式会尽可能的匹配更长的字符。可以在*和+后跟上?字符转换为惰性匹配模式。 /(.*at)/ =&gt; The fat cat sat on the mat. /(.*?at)/ =&gt; The fat cat sat on the mat. 捕捉模式 捕捉模式相当于将模式匹配的字符组保存到内存中，方便之后引用。这个严格意义上超脱了正则表达式本身的功能，是在其他语言使用正则表达式时的一个功能。默认的(&lt;Pattern&gt;)操作符就是开启了捕捉模式，如要关闭的话，在括号后跟上?:即可，如(?:&lt;Pattern&gt;) Github正则表达式教程 ： https://github.com/ziishaned/learn-regex#learn-regex 在线模式匹配测试 : https://regex101.com/r/ahfiuh/1 模式匹配图解 : https://regexper.com/","link":"/RegularExpressionTutorial/"},{"title":"《Andrew Rollings and Ernest Adams on Game Design chapters》 第七章笔记","text":"《Andrew Rollings and Ernest Adams on Game Design chapters》 第七章笔记 作者在这一章表明了游戏性最重要的是挑战。 作者给出了一系列纯粹的挑战类型，和应用挑战的方法。 Chapter 7 GamePlay Use of Language 这里作者同样提出了游戏设计语言缺乏的问题，关于这个问题，可以见《Formal ABstract Design Tools》 笔记 Defining GamePlay 作者将玩游戏性定义为：在模拟环境下一个或多个相关联的挑战。 关于这个定义，作者要强调的是： 基本元素是挑战，如一系列相关的选择并不是游戏（看哪部电影，吃哪个口味的爆米花） 游戏中的挑战是相互关联的，存在因果关系 挑战存在的环境应该是一个自洽的模拟环境 Pure Challenges 这里作者先定义了纯粹的挑战，纯粹的挑战是所有游戏挑战的原型。 许多种类的挑战都能被运用在游戏中，但是游戏中的挑战大多数是心理性质的，但也包含一部分身体上的挑战（如反应速度，眼手协调）。 游戏中的挑战可以分为显式挑战（Explicit Challenge）和隐式挑战（Implicit Challenge）。显示挑战是设计师故意设计的挑战，如时间限制。隐式挑战是由游戏中的元素自然形成的挑战，如一个多人的RPG游戏，自然而言会形成让玩家决定该如何分配资源的挑战。通常而言，显示挑战更直接和有紧迫感，隐式挑战更有吸引力。 接下来的都是作者定义的不同类型的纯粹挑战，并没有限定是游戏中存在的挑战。 Logic and inference Challenge 逻辑（Logic）和推理（Inference）挑战考验是测试玩家洗手信息并运用信息来做决策的能力。 逻辑主要在玩家拥有完整信息的时候使用，如围棋。 而当信息不完整的时候，逻辑就相对来说没有那么必要，信息的缺口必须通过推理能力来填充。推理是用已知的信息来推导，猜测未知信息的能力。如扑克牌中，熟练的玩家可以根据其他玩家丢出的牌，猜测他们手上持有的牌。 而例如星际争霸这样的游戏，玩家获得的也是不完整的信息。在游戏中，玩家需要根据不完整的信息推理出当前整个地图正在发生的情况（对手在干嘛），这对于玩家而言是个重要的挑战。 有完整信息的游戏通常存在一个问题：游戏元素太过于简单，当有完整信息的时候，游戏的挑战很容易就局限在逻辑上，如大部分的桌游。 而不完整信息对人来说是一个正常现象，因为人所处的真实世界就是不完整信息，且人有基本的好奇。所以不完整信息反而会更有吸引力。 Lateral-Thinking Challenges 横向思考（Lateral-Thinking）挑战可以说是另一种推理挑战。横向思考能力是要玩家可以结合过去的经验和知识来完成任务。 这些经验和知识可以是内在的（Intrinsic），也可以是外在的（Extrinsic）。内在表示知识是从游戏世界中获取的，外在表示知识是从游戏外的世界获得的。 Memory Challenges 记忆（Memory）挑战是要玩家可以回忆起以往的游戏。这是个纯粹内在的过程，即玩家需要回忆的信息完全是在游戏世界中的，不需要回忆正式世界中与游戏无关的其他信息。 Intelligence-Based Challenges 智力（Intelligence-Based）挑战是完全依赖于玩家智力的挑战。这种挑战在现实生活中和在游戏世界中都很少出现。通常而言，只有IQ测试数以一个完全依赖智力的挑战。 但是智力挑战常常与其他的挑战结合在一起。 Knowledge-Based Challenges 知识（Knowledge-Based）挑战依赖于玩家的知识。 同样如在横向思考挑战中提到的，这些知识可以是内在的，可以是外在的。 注意横向思考挑战考研的是结合过往知识的能力，而知识挑战是纯粹的挑战过去知识储备量，如问答。 但实际上大部分的知识挑战也是与横向思考挑战结合在一起的，同时内在的知识挑战几乎在所有游戏中都能找到。但是RPG游戏和冒险游戏中内在的知识挑战最为明显，如果说删除一个玩家的内在知识，如突然给他一个游戏中途的记录，玩家几乎很难玩下去，因为他缺乏了之前的内在知识，他无法了解游戏的进行。 Pattern-Recognition Challenges 模式识别（Pattern-Recognition）挑战依赖人的大脑的基本能力就是模式识别。人的大脑会隐式的去构造一个对象的原型，然后将新遇到的事物与生成的原型们进行比较，来判断他们是属于哪个种类。 但是有的时候，人的模式识别能力又会错误的运行，出现了空想式的错误（Pareidolia）。如人长时间的看着云，就会觉得云像某个形状。 一些简单的游戏会利用人的模式识别能力，如俄罗斯方块。俄罗斯方块一局时间足够长后，方块下落的速度会非常快，这时候玩家已经很难识别出每个方块的具体形状，此时更多的依靠的是本能，即看到一个方块就知道他属于方块中的某一个。 模式识别处理信息会很快，但它要求信息足够的简单。通常模式识别会和一些反应速度挑战结合在一起，如游戏德国心脏病。 大部分的游戏实际或多或少都有模式识别，这让游戏对于玩家而言更可控（manageable）。如在游戏中，当看到一个门是可以打开的后，看到其他的长得不一样的门时玩家也会觉得他能被打开。马里奥游戏中，每个Boss的行为习惯通常和关卡与其他的Boss类似，所以玩家也能够将其归于某个模式中，能快速的猜测出正确的打法。 Moral Challenges 道德（Moral）挑战是一个更高层次的挑战，道德通常由universal,cultural,triibal,personal四个层面，每个层面都比前一个层面范围要小一些。 通常来说，道德挑战并没有绝对的对错，如为了救饿死的老人去偷东西，到底是对还是错呢？同时玩家做出道德挑战时也会收到自己在现实生活中的影响。 游戏中的道德挑战应该是限定于游戏环境中的，如游戏世界中的universal就是游戏世界本身，需要注意的是，这个世界是由游戏设计师创建的，所以这个世界的逻辑，元素也是受限于设计师自己的能力。culture通常是指一个大区域的影响，如东方西方，culture也可以进一步被细分，如美国，中国，而文化层面的选择可以是“是否要接纳一个宗教”等。tribal是一个更小的层面，如家庭，队伍。小队层面的道德挑战最经典就是是否要去救某一个队友。personal层面的道德挑战即只影响做出抉择的个体自己。 道德挑战很少被认为是非黑即白的，玩家在一个道德困境中被迫做出决策通常是一个meaningful play的体现。 Spatial-Awareness Challenges 空间认知（Spatial-Awareness）挑战通常是一个隐式的挑战。 目前绝大部分的电子游戏都是显示在2D平面上的，玩家需要根据2D平面的现实来想象出3D空间。在一些模拟游戏中，如飞行模拟，这种空间挑战更为明显，如玩家需要判断离地距离等。 Coordination Challenges 协调挑战通常是需要玩家执行一个模拟的行为，如跳跃，设计，躲避等，这个行为通常需要多个细小的操作结合在一起（鼠标决定访问，一个按键决定前进方向，另一个按键决定向上跳跃）。 同时协调挑战也常与时间元素结合在一起，如马里奥游戏中，跳跃的长短决定于玩家根据按键的时间，或玩家需要在确切的时间按下跳跃才能跳过障碍物。 协调条找的平衡很难，因为这个一定程度上与玩家的身体能力有关。 Reflect/Reaction Time Challenges 反应速度挑战测试玩家对时间的把控能力，这个挑战通常会与其他的挑战结合在一起。 Physical Challenges 生理挑战很少出现在游戏中。 但目前也有一些引用，如跳舞毯，Kinect。 Applied Challenges 游戏中的挑战通常是上述的多个挑战的结合，一个游戏的挑战觉得了游戏玩家的反应，即决定了游戏的目标。 以下是几种挑战应用的例子。 Races 一种比其他的玩家更快获得胜利的形式，这种形式应用的挑战与游戏形式有关，可以是协调能力，可以是反应速度。 Puzzles 谜题主要是是一种精神层面上的挑战，谜题需要玩家了解游戏内元素的关系，并做出实验并观察结果（推理，横向思考，识别等挑战）。 对于游戏设计而言，一个谜题不应该让玩家纯粹的去做实验和观察，需要给玩家足够的信息让玩家对于该如何进行有一定的思路。不然游戏本身就完全变成了无意义的盲猜。 Exploration 玩家通常会很喜欢新鲜事物和探索，但是如果只有探索元素，那么游戏就会变成观光，变得很无聊。所以通常的方法是将探索与挑战结合在一起。 如探索过程中有锁住的门，这样就结合了解密挑战。或者陷阱，但要注意陷阱必须以某种方式可以被玩家规避，否则这个陷阱的存在就是没有意义的（玩家的行为不造成任何的区别）。或者迷宫，一个优秀的迷宫应该结合谜题或者模式识别，让玩家可以从迷宫中获得走出去的线索，同时迷宫也需要玩家在闹钟包含有一个地图的信息，这又是记忆挑战。 Conflict 冲突是很多游戏的核心元素，通常冲突意味着某一方需要打败其他人获得胜利。 冲突的形式也可以是多种多样的，如策略上的冲突，道德层面上的冲突。 通常而言，小范围的冲突，即人与人之间的冲突，是更快速，让人激动和本能的（Visceral）。 Economies 经济是指一个系统中资源可以被移动或交换，无论是物理上的移动位置，还是概念上的所有权改变。 大部分的游戏都包含有经济，如FPS中的，弹药（可以从别的玩家身上获取），生命值（被别的人家的行为消耗）。 经济上的挑战大多是要玩家理解游戏中的元素并知道该如何优化他们，如大富翁中理解房产意味着什么，并决定是否该购买，该升级的等。 许多游戏还会给玩家多个元素，让他们在元素之间获取平衡。如有些生存游戏，包含面包和水，玩家可以决定面包换水或水换面包，这种决策会引入meaningful play。 Conceptual Challenges 概念上的挑战是要玩家可以理解新鲜事物。 对于游戏设计师而言，概念调整是最有趣的设计，因为它的自由度最高 侦探游戏可以看作是一种概念上挑战的游戏，玩家收集到的新证据就是新事物，而玩家需要能理解其背后隐藏的信息。 引用： Andrew Rollings and Ernest Adams on Game Design. Andrew Rollings and Ernest Adams (2003)","link":"/RollingAndAdams-Chapter7-Notes/"},{"title":"《Rules of Play》 第十五章笔记","text":"《Rules of Play》 第十五章笔记 这一章中，作者区分了宏观层面和微观层面的不确定性。 再将不确定性分为三种certain，uncertain，risk。 之后通过两个例子说明，不确定性如何结合到游戏中。 最后提出了数学层面上的概率与玩家体会到的概率之间是存在差距的。 Chapter 15: Games as Systems of Uncertainty Introducing Uncertainty 不确定性是每个游戏的核心特征。正是有位对游戏结果的不确定性，才能给玩家目的感，如果游戏的结果是确定的，那么玩家何必要玩呢？玩家的行为并没有造成任何的区别，换句话来说，不确定性一定程度上提供了游戏的意义。 游戏的不确定性可以从两个层面表达： 宏观层面（Macro-level）：游戏总体的结果的不确定性 微观层面（Micro-level）：游戏中设计的特定行为的结果 “不确定性”这个词本身表示了随机性和机会，但这并不意味着只有那些包含随机性（如色子）的游戏才有不确定性，由技能主导的游戏同样有不确定性（围棋的胜负是不确定的）。 所有游戏在宏观层面都提供了不确定性，但是在微观层面并不是都提供了（如围棋）。 Certainty，Uncertainty，and Risk 数学家Richard Epstein在The Theory of Gambling and Statistical Logic一书中将所有的赌博行为都描述为是一种决策，而决策又可根据行为与结果之间的关系，分为三种：不确定（uncertainty），冒险（risk），确定（certainty）。 确定 一个完全是确定的游戏很难称作为游戏，因为结局已定，玩家的行为没有任何影响，玩家也很难感受到快乐。 冒险 冒险也是用来描述不确定的情况的，只不过在这个情况，玩家对于不确定性的信息是了解的，如知道概率等。如丢硬币游戏就是冒险游戏，虽然最后的结果不知道，但是玩家知道每个结果发生的概率都是50%。 不确定 剩下的不确定分类中，玩家对于当前的不确定情况不知道任何信息。如随机加入一场网上的围棋比赛，在比赛前对手的实力是完全不确定的，他可能是一个职业选手，也可能是个完全的菜鸟。 大部分的游戏都是冒险和不确定的结合。 The Feeling of Randomness 玩家的不确定感并一定来自于游戏中的随机事件。 如跳棋，虽然游戏中的每一步都是玩家自己的选择，但是如果你在别人的回合时闭上眼镜，然后只在自己的回合睁开。 a. 对于经验不丰富的玩家，睁眼时的场景会有不确定感，因为他无法从游戏的场景中抽取出逻辑，当前的情况对他而言就如同是随机的。 b. 对于经验足够丰富的玩家，他或许就可以从这个场景中猜测出前面的其他玩家做出了什么行为，对于他而言这个实验就没有不确定感。 上述例子中，玩家的不确定感是来自于玩家自己的经验，而不是游戏中的随机设计。 游戏中是否让玩家有随机感比游戏中是否真的有随机因素更重要。如果一个游戏完全没有随机感，那么玩家可能会觉得很无聊，或者觉得竞技性过强。如果一个游戏随机感过多，玩家可能就会觉得游戏很混乱。但无论是什么情况，最重要的都是让玩家的选择是有意义的，即使没有随机感，也要让玩家能通过技巧改变结果，即使很混乱，也要让玩家觉得可以通过某个策略来改变结果。 Probability in Games 这一节是针对微观层面机会的研究。数学上对于不确定性的描述为“概率（Probability）”。 对于概率的研究，有一定的矛盾感： 概率本身给游戏带来了随机感和混乱，即增加了不确定性 对于概率的研究却让玩家知道了不确定性的本质，即从uncertain像risk转变，减少了不确定性 Dice Probability 这一节作者首先推导了一个色子筛出各点数的概率，又推到了两个色子筛出各点数的概率，这里不赘述。 之所以要求得不同情况的概率，是因为对于概率的了解与玩家的决定与玩家游戏时的结果是相关的。 如两个色子筛出7的概率最大，通常大富翁棋盘有40格。这意味着6轮游戏后很可能就有玩家走到了第二圈，这时候游戏就会出现踩到别人财产付租金的情况了。 Change and Game Play 对于那些完全由概率决定的游戏，玩家对于游戏的结果本质上是没有任何控制性的，游戏的结果纯粹由概率决定，玩家只能被动的接受游戏的结果。Rogor Caillois认为这样的游戏是没有意义的，但实际上许多完全由概率决定的游戏很有趣，最简单的就是丢硬币。 这里作者给出了两个具体的例子帮助分析，第一个是蛇梯棋（Chutes and Ladders），如下图所示： 在蛇梯棋中，玩家不需要做任何决策，他要做的只是扔色子，然后移动相应的步数（碰到梯子的下段，则自动移动到顶端，碰到蛇的头部则自动滑落到蛇的底部）。 虽然游戏是完全由概率决定的，但是梯子和蛇这两个元素的存在，让玩家前进的速度不再是只有色子决定，即增加了许多的意外因素，而玩家对于意外因素的渴望就构成了乐趣，掷色子的意义变为了“遇到梯子，避免蛇”。 同样的还有彩票，彩票本质上也是个纯粹概率游戏。玩家需要选取一个彩票形式（刮刮卡还是双色球），以及选取一个数字。虽然这个选取过程严格意义上来说是没有意义的，无论怎么选结果都是完全由概率决定。但是这个选取的过程，让玩家对于纯粹的概率游戏有了“参与感”，会有寄托于自己好运的感觉。 因此meaningful play也不一定完全来自于玩家的策略选择与对应的结果，也可能来自于运气的假象。 这里作者给出了两个使用概率来增添游戏趣味性的例子，第一个是雷暴，第二个是小猪 Case Study One： Thunderstorm *雷暴（Thunderstorm）*是德国很著名的家庭游戏。 这个游戏是多人参加，通常4-8人比较合适，需要六个色子。 a. 第一个玩家丢出所有的色子，如果其中出现了1，则安全通过，将所有是1的色子取出，将剩下的色子顺时针给下一位玩家。如果玩家丢除的色子中没有1，则在自己面前画一笔房子，然后将色子传给下一位玩家。 b. 如果某个玩家面前的房子已经完成，且又遇到了没有丢出1的情况，则该玩家被淘汰。 c. 当只有一个玩家时，游戏结束，剩下的玩家为胜者。 房子如下所示： 雷暴这个游戏也是个纯粹的运气游戏。但是这个有趣的点在于每一轮玩家拿到的色子数量是不确定的，第一个玩家有6个色子，所以色出1的概率很高。之后随着游戏的进行，将色出过1的色子逐渐拿走，很可能之后的玩家只有一个色子，此时色出1就很困难了。 在游戏中，每个玩家的概率是由之前玩家的结果决定的，这提供了一定的戏剧性并且会有紧张的气氛在（每个人都不希望他前面的玩家色出很多1）。这种戏剧性和紧张氛围赋予了游戏的意义。 Case Study Two：Pig 小猪（Pig）也是多人参与，通常3-5人比较合适，需要一个色子。 a. 第一个玩家丢出色子，色子的点数即为获取的分数。玩家可以选择继续丢色子，然后累加获取的分数。但如果丢出了1，则这一轮累加的所有分数清零。玩家也可以选择不丢色子，那么这一轮获取的分数就会记录在本子上。 b. 当上一个玩家选择不丢色子后，色子顺时针给下一个玩家，重复上述操作。 c. 直到某一个玩家分数到达100分，游戏结束。该玩家会获胜者。 小猪游戏中玩家需要做出决策（继续丢色子，还是放弃），每个决策的结果是不可控的，是由概率（玩家可以算出概率）决定的，选择继续丢可能加分也可能失去这一轮所有分数。 游戏的趣味性来源于玩家的决策和概率之间的抗衡，随着丢色子的次数越来越多，丢出1的概率也就越大。玩家此时的决策也会更加的困难，这也会增加紧张气氛。这种抉择和紧张气氛赋予了游戏的意义。 Breakdowns in Uncertainty 这一部分作者讨论了一些概率元素最终并不没有像设计师预想的那样工作的情况。 Breakdown 1: Computer Randomness 实际上计算机并不能产生随机数字，所有产生随机数的程序都是伪随机。但是对于大部分的游戏设计来说，计算机产生的伪随机数也足够用了。只是设计师要记住，计算机生成的随机数有时是会出错的。 比如理想上1-100的随机数，出现的数字是均匀的分布在1-100之中的，但可能因为程序的出错，在每个区间的数组出现的概率特别大。 Breakdown 2：Strategizing Change 第二个要注意的是，玩家会不会通过某种策略将改变了原先的随机事件想要达成的效果。例如小队中的成员在个特定时间段随机一位受到伤害，玩家会不会通过在特定时间前踢出一些弱小玩家，来避免他们收到伤害。 Breakdown 3： Probability Fallacies 概率存在一些谬论（Fallacies），即玩家理解中的概率，和真实的概率可能是不一样的。 以下是一些常规的谬论： 高估大赌注（Overvaluing the long shot）：即对于低可能，但是高回报的项目会有过多的自信，即会更倾向于选择低可能高回报的项目，而不是选择一个更安全的项目。 认为概率是累加的（The tendency to think of successive chance events as additive）：一个色子时丢出1的概率是1/6，但是丢出2个色子时出现1的概率，并不是2/6,而是11/36。 蒙特卡洛现象（The Monte Carlo Syndrome）：即认为上一次的事件会影响下一次的事件。但实际上多次没有丢出6，和下一次丢不丢出6并没有关系。 过度关心好结果（Overemphasis on good outcomes）：人们会高估一个好结果事件发生的概率。中彩票和被车撞实际上概率时差不多的，但是人们会更相信自己能中彩票而不是被车撞。 雷击两次现象（Lightning striking twice）：和蒙特卡洛现象类似，人们也会倾向于认为好事成双和低概率坏事不会多次发生（连续被雷击中），但实际上一个事件发生的概率和之前事件并没有联系。 好运（Luck）：纯粹从数学角度来说，并没有好运这个东西。 上述的每个谬论对于设计而言都是一个重要提示，比如设计师给了玩家两个选择，一个是低可能高回报，一个是低回报高可能，设计师就要预见到玩家会更倾向于选择前者。设计师的设计目标玩家感受到的随机性，而不是真实数学意义上的随机性。 同时上述提及的三个概率方面的破坏（Breakdown），实际上也可以被运用。针对电脑伪随机，是否可以以此作为灵感，故意设计一个不是那个平衡的随机方法。针对策略规避概率，是否故意的允许玩家去采取某些策略。针对谬论，是否故意设计一个运气系统，虽然运气在理性层面上是不存在的。 Meaningful Chance 几率存在的意义并不是单纯的增加不确定性。它是要给玩家好处，或者坏处，或者某种信念，如“我希望得到xxx”，“我猜我能得到XXX”等等。 引用： 1.Rules of Play 2003","link":"/RulesOfPlay-Chapter15-Notes/"},{"title":"《Andrew Rollings and Ernest Adams on Game Design chapters》 第八章笔记","text":"《Andrew Rollings and Ernest Adams on Game Design chapters》 第八章笔记 Chapter 8. The Internal Economy of Games and Game Balacning 对于游戏平衡的问题很难有确切的答案，因为游戏平衡中需要牵扯到一个人为因素，即玩家本身。 设计师所考虑的游戏平衡是对于玩家的平均水平而言的，因为游戏很难对于各种水平的玩家都是平衡的。但这也就造成了设计游戏平衡时的一个常见问题，即设计师认为自己的水平即是平均水平，最后制作出一款自己很满意，但是玩家不满意的游戏。 What is Game balance 一个平衡的游戏，其获胜的主要因素应该是玩家的水平，这不是说平衡的游戏不能有意外因素，但技术好的玩家应该有更大的几率获胜，除非他这局的运气特别特别差。 游戏平衡就是个不断的实验-&gt;纠正（Trial-and-error）错误的过程。 对于电子游戏而言，存在太多的变量会影响玩家的体验，即它是一个N维空间的优化问题。一些传统的游戏研究可能并不适合于电子游戏，因为他们太过于简单。在一些其他学科中，有现成的N维空间优化解决技术，但是电子游戏与其他学科不同的点在于它有玩家这个人为因素，即各种变量的平衡并不是一个完全客观理性的数学问题。 反复的实验-&gt;纠正很可能是平衡电子游戏唯一的方法。但这个方法很浪费资源和时间，并且有个更严重的问题是，很难定义什么到底平衡的。 这里作者将平衡分为两种静态平衡（Static balance）和动态平衡（Dynamic balance）。 STATIC BALANCE 静态平衡时关于游戏规则的，即这些规则时如何相互联系，如战争游戏中单位的战斗力，动作游戏中跳跃的距离等等。通常玩家们提及游戏平衡时，它们指的就是静态平衡。 在静态平衡游戏的过程中，设计师需要保证游戏是公平的，所有的元素都是无缝的相互联系，且不会有主导的或者一些隐藏的策略毁坏整个游戏的体验。 Randomness and Average Values 通常可使用回报矩阵（Payoff matrices）来展示各个元素之间的平衡。如果有B1,B2,R1,R2四个元素，且它们的回报矩阵如下所示： B1 B2 R1 0 -2 R2 3 0 这表示当R1遇到B1时，两者可能谁都不会占到便宜。当R1遇到B2时，则通常R1会损失2的数值。R2的分析同理。 回报矩阵的关键是，它是一个统计学意义上的值，即上表中的数值并不是针对于一个特定的事件，它是分析多个相似事件后得到的平均情况。 Dominant Strategies 占优策略（Dominant Strategies）是传统游戏理论中的术语。占优策略指的是指一个策略在所有情况下都能比其他策略更好。其中占有策略还可以进一步分为强占优策略和弱占优策略，前者是保证这个策略一定会赢，后者是保证这个策略一定不会输。 对于游戏而言，在大多数的情况下要避免占有策略的发生。 下面为作者举得一个占优策略的例子： Wife’s Birthady No Wife’s Birthday Buy Flowers 10 20 Don’t but Flowers -100 0 可以看出，无论那种情况下（是妻子生日或者不是），买花都是一个更好的策略，即买花是占优策略。 如果将这个例子运用到游戏中，就需要通过加上其他的限制来避免其成为占优策略，如给花一个昂贵的售价，那么在非妻子生日时买花就会有一个负得分。 但如之前所述，电子游戏中有太多的变量，对于一个玩家的占优策略可能对于另一个玩家就不是。 一个理想化的解决方法是模拟一个完美的玩家，这个玩家只会做出最优的解，然后用来完美玩家进行测试，避免占优策略的出现。但是这个方法还是与现实有误差，这个方法是一个数学层面上的解决方案，但因为几乎所有的玩家都不会是“完美玩家”，因此对于实际游戏的参考价值并不是很大，大多数的游戏都无法列出一个完整的回报矩阵。 在游戏中，通常会有三个原因造成占优策略的发生： 战术导致，如RTS游戏中，当近点时Rush通常会有很好的收益 不平衡的单位，如一个单位设计的过强，只要生产该单位就大概率能获得胜利 Bug，金手指之类的方法，将直接破坏游戏平衡 游戏中的占优策略能让玩家更容易的获得胜利，但是对于大部分的玩家而言，游戏是为了乐趣而不是为了赢。 Symmetry 对称（Symmetry）是最简单的平衡游戏的方法。 如象棋，开局时双方的棋子类型，位置是完全一样的，这造就了游戏的平衡。但是像象棋这样的镜像对称通常只能运用于一些抽象概念的游戏中，因为这种对称会让玩家觉得不自然和一定程度上的无聊。 但是体育模拟游戏又是一个例外，因为即是在现实生活中，很多体育游戏都是对称的（同意的人数，同意的人员分配）。 要注意的是，游戏中的对称指的是功能上的对称，而不是完全的一样，如体育游戏中，双方都有2个后卫，但这两个后卫的能力可能是不一样。 RTS游戏中对称平衡，如一个玩家开局被山包围，另一个玩家开局被水包围等等。 对称的平衡方式消灭了平衡中的许多变量，简化了平衡工作，但是这也容易导致玩家的行为受限于某种方式，让游戏不再有趣。 Transitive Relationships 传递关系（Transitive Relationships）定义了多个元素之间一种单向的关系。如下图所示，A能打败B，B能打败C 这种关系的回报矩阵如下： 传递关系在游戏中非常常见，如FPS单机游戏中，玩家的装备越来越好，怪越来越强。这些装备之间形成了传递关系，怪物之间也形成了传递关系，即游戏后段的武器和怪物无疑可以轻易打败游戏初期的武器和怪物。 传递关系在游戏中主要是为了鼓励玩家持续的推进游戏进度。在游戏的过程中，玩家会越来越强，但这个传递关系也会有一个重点，如玩家的死亡或游戏结束。 还有一种三元的非传递关系（three-way intransitive relationship），最简单的例子就是游戏石头剪刀布，如下所示： 回报矩阵： Scissors Paper Rock Scissors 0 1 -1 Paper -1 0 1 Rock 1 -1 0 石头剪刀布是一个零和的游戏，但是游戏也可以设计为非零和的游戏。 这种非传递关系相较于传递关系更有趣。但是它很容易被玩家找出规律所在，然后玩家可能就会通过某些策略来规避这种关系，所以通常在游戏中需要用其他元素来包装这个关系，或者说关系在游戏中可以动态的发生变换。 Trade-Offs 权衡（Trade—Offs）在游戏中也是一个非常常见的元素。它是指某一个元素一方面比另一个元素好，但是另一方面又不如另一个元素。 如游戏中常出现的数显就是权衡的设计，就是力量，敏捷，智力三个属性。玩家在升级后，可以选择其中一个属性进行加点。 通常来说，设置用来进行权衡的元素是需要相互独立（orthogonal）的，否则玩家的选择就没有意义。如一个属性表示质量，另一个属性表示浮动力，这两个属性实际上是相关的，玩家选了其中一个就会很大程度上影响另一个。 同时，也要保证多个用来权衡的元素，相互之间的收益的相等的，虽然它们的收益体现在不同的方面。 Combination 有些情况下，当平衡游戏时，多个单独的元素可以组合在一起视作同一个元素，一起来平衡，如RTS游戏中的兵种组合。 通常来说，如果每个单独元素在设计时平衡的很好，那么它们组合在一起后，平衡也不会太差。 Emergence 出现（Emergence）是一系列简单的规则组合成一个复杂的结果。在现实生活中，也有许多Emergence的元素，看，听，触摸这些简单的规则构成了生活中大部分的复杂行为。 如在第八章中作者定义的，游戏是一个模拟环境，受限于硬件和软件的实现，游戏世界不可能将现实生活中所有元素都包含进来，通常游戏只会包含一部分的元素。 但是优秀的游戏，应该让这些被包含进的元素可以被完美的运用，让它们能组合成一个复杂的情况，这就是Emergence的魅力。如塞尔达传说，马里奥都是很好的运用Emgerence的例子。 当然Emergence也有缺点，如果被包含进来的元素并没有完全被利用，那么这些仅含的元素就会变成玩家仅有的玩法，游戏就会变得无趣。另外如果某一个元素不平衡， 则很可能导致占优策略。 Feedback Loops 关于反馈系统，在《Rules of Play》 第十八章笔记有详细说明。 反馈系统是静态平衡与动态平衡的交界线，它开始时的状态是静态平衡的，但是运行后就是动态平衡了。 Summary of Static Balance 静态平衡时关于游戏规则，游戏初始状态下的平衡。 动态平衡则是关于玩家与游戏系统交互的平衡。 DYNAMIC BALANCE 动态平衡可以分为两种，第一种是消极平衡，第二种是主动平衡。 消极平衡是指修改系统，让系统始终对于玩家而言是平衡的，而且平衡点不会改变 主动平衡是指针对于玩家的行为，动态的修改平衡点。 What are we balancing？ 但无论是哪种平衡，其关键都是重新在平衡点处构成平衡。 平衡游戏的目的是让游戏公平且统一，不会允许玩家去找出错误或游戏的弱点来获取额外的优势。 一个游戏应该保证在初始时是平衡的（通过静态平衡设置的各种规则，在运行时通过动态平衡也保证平衡。 通常动态平衡有以下三种平衡方式： 恢复平衡 保持平衡 摧毁平衡构建新平衡点 Restoring a Balance 如果玩家的目标是恢复平衡，那么游戏的目标就是让游戏系统重回平衡点。游戏系统中会有力量创造出不平衡状态，但是当玩家介入后，这个力量应该消失或者变得微弱，让玩家可以重新将系统变为平衡。 如拼图游戏，就是一个从混乱状态（不平衡），通过玩家的操作逐渐恢复平衡的过程。 Maintaining Balance 如果玩家的目标是保持平衡，那么游戏的目标就是阻止让游戏不平衡的力量。 如俄罗斯方块，在一开始的游戏状态是整洁的，玩家的行为就是不要让新出来的方块破坏平衡。在游戏的过程中，破坏平衡的力量会越来越强（方块下落越来越快），这就对玩家构成了挑战。 Destroying a Balance 如果玩家的目标是破坏平衡，那么游戏系统就会尝试去恢复平衡（玩家和系统的角色与在恢复平衡时的角色相反）。 注意这个破坏平衡，并一定指从平衡状态变为混乱状态，它也可以是从一个平衡状态变为另一个平衡状态。 如一个RPG游戏，游戏开始的设定是外星人统治了世界，这已经是一个平衡的状态了，玩家的任务就是让这个世界变为人类统治的世界（变为另一个平衡状态）。 Balanced Systems 游戏平衡的目标是为了保证玩家的游戏体验，可以从以下几个角度分析： 提供一个恒定的挑战 给玩家一个可预料的，公平的游戏体验 防止停滞（Stagnation） 防止琐事（Trivialities） 允许设置不同难度（可选）。 Providing a Consistent Challenge 一个游戏的难度应该在玩家进行时平缓的增加，但有些游戏违背了这个规则，游戏的难度在中途比游戏后期更难，这种设计很容易让玩家在中途过后，突然觉得游戏变的无聊。 Providing a Perceivably Faip Playing Experience 玩家享受游戏的一个重要原因就是玩家是否觉得这个游戏是公平的，可预测的。这里的公平指的是玩家觉得是否公平，而不是要求游戏本身绝对公平。 游戏中可以设计一些欺骗的行为，如当玩家处于最后一名时，倒数几名的赛车速度会慢下来。但是这种欺骗行为不要让玩家意识到。 另外游戏中，如果某些事情会让玩家没有胜利可能，那么这些事情应该在早期就让玩家知道，或者透露出足够的线索。如游戏最后需要一把钥匙开门，在游戏前期就需要通过某些方法告诉玩家要去寻找钥匙，而不是到了最后玩家发现自己只能重新读档。或者玩家知道最后需要某个东西开门，但是设计并没有给出这个东西的线索，需要玩家自己去猜是需要钥匙，还是魔法书，一旦猜错只能读档重来。 这里的关键就是让游戏的推进是利用玩家已知的知识和信息。如果一个游戏，玩家必须通过攻略或重新读档这样的方式才能进行，那么这个游戏的设计是失败的。 另一个重要的保证玩家觉得游戏公平的因素，就是保住新玩家。当新玩家加入游戏，并被有经验的玩家屠杀时，很容易就觉得这个游戏不公平。通常很多游戏提供的单人模式就是为了保护新人玩家，给新玩家一个练习自己技术的地方。 游戏中的死亡也是一样的道理，通常来说，如果一个玩家失败了，他应该要明确的知道自己死亡的原因，即这个原因是可控的，即玩家需要有方法可以避免死亡。 Avoiding Stagnation 停滞在游戏中是一个很恼怒的状态，指的是当玩家在游戏中抵达了一个进度，然后不知道自己该如何推进。 在很多情况下，停滞是很难被避免的，因为不同玩家的思考能力，探索能力是不同的。但这个可以通过平衡来解决，如当游戏发现玩家在一个地方停留了太久后，给出多余的提示等。 Avoiding Trivialities 琐事指的是，玩家需要做出大量的零碎的决定，而且这些决定对于游戏的最终结果没有明确的影响。 的确有的游戏会通过零碎的决定让玩家更有参与感，但是这些选择应该是可选的，即玩家是自愿去做琐碎的决定，而不是被强迫去做。 RTS游戏中也存在许多细小的决定，如决定每个单位如何行走等。但是这些决定对于最终的游戏结果是有影响的，所以不算是琐事。 Setting the Difficulty Level 游戏玩家第一次接触游戏的平衡工作，就是选择难度。通常来说，难度会分为四个等级，简单，正常，困难，噩梦。 网络游戏中通常没有难度选择，它们通过将不同的玩家进行分割来处理难度水平（处于不同的地图，处于不同的天梯等级）。 还有一些游戏会通过动态调节游戏难度，如当玩家表现很差时，降低游戏难度，让表现很好时增加游戏难度。但这个方法有两个缺点。第一，会给玩家造成被欺骗感，第二，玩家可能利用这个规则，如故意表现得很差降低游戏难度。 通常来说，单机游戏中的难度选择会通过两种方式改变难度，敌人更强或者敌人更多。如简单难度每过一关，敌人数目增加5%，正常难度每过一关，敌人数量增加10%。 现在的一些单机游戏，还会通过让敌人更聪明来增加难度，即修改AI的表现。 Tools For BALANCING Design for Modification 当设计游戏时，应该是面向修改设计的。 为了能更好的修改，通常先设计游戏规则，再设计游戏运用这些规则的元素。一旦规则被平衡了，修改其中的元素不会让平衡效果偏差的太过于严重，在规则的限制下，这些元素也不会相互干扰。 如之前所述，游戏平衡工作是一个反复试错的过程，在修改元素或规则来进行平衡时，要记得控制变量法 Design Prototyping 在开发一款游戏前，应该先开发一个游戏的模板，最好用一个简单的程序语言进行开发。 Future Potential 因为手动的进行参数的平衡并不高效，未来可能会有自动手机玩家数据，然后进行参数调整的平衡方法。如发现某一个英雄被玩家使用的过多，且胜率很高，自动下调这个英雄的一些属性。 引用： 1.Rules of Play 2003","link":"/RollingAndAdams-Chapter8-Notes/"},{"title":"《Rules of Play》 第十七章笔记","text":"《Rules of Play》 第十七章笔记 这一章中，作者将信息看作游戏中可以被交互的一部分，玩家通过对于信息的交互获得meaningful play。 信息可以分为完整信息和不完整信息。 信息也可以根据了解的对象被分为四种：被所有玩家知道，只被一个玩家知道，只被游戏知道，随机产生。 同时，作者用桌游魔法森林作为例子，讲述了信息是如何运用在游戏中的。 Chapter 17: Games as Systems of Information Introducing a Different Kind of Information 这一章中，将游戏看作是一个交互系统，信息是其中一个用来玩的元素。针对不同的游戏，信息可以获取，可以被隐藏，或重新安排，被遗忘等等。如游戏扑克牌，玩家要考虑的就是如何隐藏信息（自己手上的牌），和推测出别人的信息（别人手上的牌）。 Prefect and Imperfect Information 完整信息（Perfecc Information）是指所有玩家在任意时刻都知道的元素，如下围棋时，棋盘上棋子的位置。 不完整信息（Imprefect Information）是指在游戏过程中，一部分的信息对于玩家而言是隐藏的。 一个游戏中的信息，无论是完整的还是不完整的，都不影响其成为一个meaningful play的游戏。只是信息的情况不同，设计的思路也需要相应变化。如对于完整信息的游戏，它更适合做对抗性的游戏。而不完整的游戏，更适合包含一些神秘故事，或者背叛，诡计，策略等设计元素 设计师Celia Pearce在他的书The interactive Book中将游戏信息分为了四种： 所有玩家都知道的信息：被丢出的牌 只有一个玩家知道的信息：玩家自己手中的牌 只有游戏知道的信息，如扑克牌中还没有被发给任一玩家的牌 随机产生的信息：如色子 在游戏中，信息所处的类别是在发生变化的，如一张牌在还未发出时，是只有游戏知道的信息，当发给一个玩家后，就成为了只有一个玩家知道的信息，当被使用时，就成为了所有玩家都知道的信息。 Enchanted Information 时刻要注意的是，无论如何，游戏中操作信息的设计其目的都是产生meaningful play。 这里作者以桌游*魔法森林（Enchanted Forest）*作为例子进行说明。 在游戏中，卡堆上翻出第一张卡片，作为城堡需要寻找的宝藏，每棵树下随机藏有各种宝藏。玩家通过色子进行移动（但可以自己选择前进的方向），如果达到一棵树下，玩家可以自己查看这棵树下的宝藏（不给其他玩家看），当抵达城堡时，玩家需要指出哪颗树下藏有宝藏，玩家自己翻开所指的树下宝藏，如果是对的，则将牌展示给所有的其他玩家，并将此宝藏收入囊中。如果是错的，则牌不会被展示给其他玩家，同时玩家自己回到原点。 可以看出，在游戏中，信息是逐渐被揭露给玩家的，玩家可以通过翻看树下的宝藏来获取信息，当某一个玩家猜对卡片后，树下的宝藏也会被展示给所有人。游戏过程中玩家首先需要记住信息，即已经翻看的卡片下的宝藏是什么，同时还需要主动的构建自己的信息系统，如玩家可以选择优先看哪条路上的树。 Each turn，Enchanted 如上节所述，在魔法森林的游戏中，玩家需要自己决定查看哪条路上的树，这种抉择就是meaningful play的信号。在游玩的过程中，充斥着玩家对于信息的处理，探索哪部分信息的决策（选择探索的路），信息记忆的挑战（记住已经翻看的宝藏），以及猜测（如果到达城堡时，需要找到的宝藏自己并没有见过）。 当游戏进程发生变化，玩家的这些信息处理也会相应的发生变化，如选择探索的路可能会受别的玩家影响（要不要和别人探索一样的路），猜测的准确性（当探索的牌越多，猜测的准确性就越高，因为剩下的为未探索牌越来越少）。 同时游戏中的信息也不是割裂的，它一定程度上是玩家共享的，即存在信息经济（economy of information）。如某一个玩家达到城堡后，却无法准确的猜出宝藏的位置，可能就意味着这个玩家探索的道路上没有宝藏。 可以看出信息存在两个形态，游戏中本身存在的客观信息（Object information，数据层面的意义），和玩家获取到的信息（Perceived Information）。 在游戏中，信息从客观信息到获取信息的过程创造了游戏的意义，这个过程并不是一个等价的转换。优秀的玩家获取的信息是大于客观信息的存在的，如虽然他只翻阅了五张牌，但他可以通过别的玩家的行为分析出其他信息，因此获取的信息是大于翻阅五张牌所揭露的客观信息。 作为设计师在设计游戏时要考虑到这两种信息的转换。 Hiding and Revealing Systems 电子游戏中有许多隐藏或揭露信息的游戏元素： 战争迷雾（The Fog of War）： 只有自己单位附近的地图才能被揭露真实状态。 秘密地点或隐藏的位置（Secret Locations and Hidden Moves）： 许多游戏中一些地点或元素在游戏一开始对于玩家是隐藏的（不完整信息），即玩家需要在游戏过程中逐渐发现。如马里奥奥德赛中，游戏的地图是逐渐探索的，这种逐渐发现的节奏可以给玩家带来代入感。 物品交易（Item Econonies）： 一些游戏中，一些物品虽然暂时没法被玩家获得，但它却展示给玩家看（完整信息）。这种展示所有信息的方法让玩家对于未来的游戏进度可以做计划。 规则作为信息（Rules as Information）：如很多模拟游戏中，一开始只能做一些非常简单的操作，但随着对于游戏理解的加深，能做的操作也越来越多（规则越来越多）。 对于设计师而言，信息不能隐藏太多，不然玩家可能会觉得困扰。同样的信息也不能太多，出现在游戏中的信息应该是要能从玩家的交互中获取意义的，如果一个信息并不能被理解或者不能被融入到游戏中，这个信息就是没有意义的。 同时信息应该是逐渐被揭露给玩家的，否则玩家会一下子突如其来的信息吓到，而且无从下手。 引用： 1.Rules of Play 2003","link":"/RulesOfPlay-Chapter17-Notes/"},{"title":"《Rules of Play》 第十八章笔记","text":"《Rules of Play》 第十八章笔记 这一章作者将游戏看作是一个控制系统。 主要介绍了游戏中的正反馈和负反馈。 Chapter 18: Games as Cybernetic Systems Introducing Cybernetic Systems 这一章回简单的介绍控制论（Cybernetic），主要关注于游戏运行时系统的变换，和游戏中哪些形式上的结构让这些改变发生。 Elements of a Cybernetic System 控制系统的概念是指一个系统的输入和输出会由系统内部的结构自行调整。通常的系统的输入是对于环境的检测，而输出是系统做出的行为，即如何去改变环境。 一个控制系统包含三个元素：传感器（Sensor），比较器（Comparator）和催化器（Activator）。一个控制系统由这三个元素构成一个闭环，传感器接受环境信息，比较器比较环境环境信息决定要做什么改动，催化器做出具体的改动影响环境，环境由会进一步被接收器感知，即构成了一个闭环。也因此控制系统有时也会被成为反馈系统（Feedback Systems）和反馈循环（Feedback Loops）。 控制系统最常见的应用就是温度控制器，如下所示： 一个控制系统可以是正反馈的，也可以是负反馈的。 正反馈系统（Positive）： 系统持续性的向一个方向变换。如传感器接收到温度后，比较是否大于30°，如果大于则加热。这样房间的温度就会越来越热。 正反馈系统的效果是累加的（Cumulative）。 负反馈系统（Negative）： 负反馈系统是朝相反方向变换。如传感器接收到温度后，比较是否大于30°，如果大于则开始降温，如果小于10°则开始加热，这样房间的温度保持在一个区间之内。 负反馈系统的效果是平衡（Equilbrium）。 Feedback Systems in Games 在游戏中，控制系统如下所示： 其中 游戏状态（Game state）表示游戏当前的状态，如格斗游戏中的血量，玩家的位置，战斗的地图等等。这是一个完全的游戏常规元素的理解，即不会包含玩家的技能，情绪，经验等等信息。 评分方法（scoring function）表示状态改如何被测量，如玩家的血量如何体现是长度还是数字。评分方法等同于传统控制系统中的传感器。 控制器（Controller）表示系统中查看评分方法的结果，并决定要采取什么操作，等同于传统控制系统中的比较器。 游戏调整方法（Game mechanical bias）表示游戏中调节状态的方法，等同于传统控制系统的催化器。 如在一个赛车游戏中，可以通过嵌入反馈系统来决定下一轮时的发车位，如果前一轮的第一名处于最前方的发车位，那么就是正反馈系统，反之如果成绩越差的车手发车位越靠前就是负反馈系统。 Positive and Negative Basketball 这里作者以篮球游戏作为例子来帮助分析正反馈系统和负反馈系统。 在正反馈系统的实现下，如果两个队伍的分值每相差5分，分数高的队伍会增加一名球员。这样随着比赛的进行，分数高的队伍球员会越来越多，即优势越来越大，比分差距会扩大。 在负反馈系统的实现下，如果两个队伍的分值每相差5分，分数高的队伍会失去一名球员。这样随着比赛的进行，分数高的队伍球员会越来越少，他们也就越来越难打，这样比分差距会收拢。 Racing Loops 这里作者以两个实际的游戏例子说明通过不同思路实现的负反馈系统。 第一个是索尼平台上的赛车游戏Wipeout，这个游戏实现负反馈是通过修改游戏元素的属性。 在游戏中电脑控制的赛车速度是会被调整的，如果玩家处于第一名，那么第二名的赛车速度会上升尝试追上玩家。如果玩家处于最后一名，那么最后面的几辆车速度会降低，让玩家可以追上。 这样的负反馈系统，保证玩家与电脑控制的赛车之间差距不会过大。 另一个例子是任天堂的Super Monkey，这个游戏是通过玩家的能力。 在游戏中，玩家可以减去道具干扰其他玩家。跑在前方的玩家更有可能收到其他玩家的攻击，而跑在后面的玩家则有更高的几率捡到加速道具。 这个负反馈系统同样保证了玩家之间的差距不会过大。 如之前所述，游戏的结果需要是不确定的，这样游玩才有意义。这上述两个例子通过负反馈缩小玩家之间的差距，都是让游戏的结果不确定，不然的话跑在前面的玩家大概率就是获胜者，对于之后的玩家而言游戏就是无意义的。 Positive Feedback in a Game 正反馈系统出现在许多格斗游戏中。如被攻击的对象会出现硬直，这样就会收到更多的攻击。 正反馈会提供一个戏剧性的结果，一个细微的差距可能就会导致巨大的差异，因此让游戏更为紧张。 但是正反馈必须有终止条件，不然玩家在开局收到一次攻击后，就会硬直，并不断的收到攻击，那么游戏就没法进行了。 在格斗游戏中的击飞效果，就是这个终止条件。当收到攻击的对象承受了足够大的伤害后，就会被击飞，击飞时攻击的玩家就无法继续攻击，这样一次正反馈就结束了。 还有的游戏是通过策略等方法来补偿正反馈。如魔兽争霸中，拥有更多金矿的玩家会有更多的经济收入，那么就会有更多的士兵，也就导致优势会不断的扩大。但是弱势的一方却可以通过战术来终止优势方的优势扩大，如进攻分矿。 Dynamic Difficulty Adjustment 动态难度调节（Dynamic Difficult Adjustment，DDA）根据玩家的表现使用反馈系统来调整游戏难度。 游戏难度在不同的玩家之间很难平衡，经验丰富的玩家对于同一个难度可能觉得无聊，而这个难度对于新手又可能觉得无法突破。 顽皮狗的游戏*古惑狼（Crash Bandicoot）*中使用了DDA来动态的调整游戏难度。即当玩家在一个点反反复复死去后，游戏会自动做出调整，如出现更多的帮助道具，出现更少的怪物等。同理，但玩家的游玩过程过于顺畅，游戏也会相应变难。 但是DDA是一个非常刻意的调整，很可能会损害玩家的游戏体验。玩家经过了反反复复的练习，变得更加数量，想要快速的通过游戏，结果游戏却相应的变得更难，这对于玩家而言有一种欺骗感，感觉自己是在“被游戏玩”。 A Simple Die Roll 游戏的反馈系统，也可以仅仅通过一个规则来实现。 如在游戏蛇梯棋中，接近重点的玩家，必须准确的丢出距离终点步数的色子数。 这个规则就是一个负反馈系统，它潜在缩短了落后玩家与第一名玩家的距离。只要第一名玩家不色出那个确切的点数，他就永远无法获胜。 如果没有这个负反馈系统，那么蛇梯棋在某些时间点就会变得没有意义。例如第一名玩家距离重点只有两步，而落后玩家距离重点还有20步，此时游戏的结果就已经是确定的了。即使第一名玩家每次都色出1，两回合后也能胜利，而两回合的时候对于落后20步的玩家，是不可能追上的。 注意，这个严格意义上不是一个控制系统，因为没有传感器，比较器，催化器的元素存在。但它的思想仍然是控制系统其中负反馈的思想。 Putting Feedback to Use 反馈系统可以帮助平衡游戏。以下是正负反馈特点的总结： 正反馈系统 a. 让游戏结果不稳定 b. 让游戏时间缩短 c. 放大胜利果实 负反馈系统 a. 让游戏结果稳定 b. 让游戏时间延长 c. 缩小胜利果实 太多的正反馈会让一个游戏结果失控，一旦玩家获取到了一点优势，优势会不可控制的持续扩大，直到游戏结束。 太多的负反馈让游戏太过无聊，玩家获取到的优势会因为各种原因丧失，这样双方的差距始终无法拉开。 平衡正反馈和负反馈是创造meaningful play的关键。一个优秀的游戏设计应该让游戏过程自始自种都是有意义的，即优秀的玩家其优秀的行为是有意义的，能获取到回报，但是对于落后的玩家而言，他们同样有机会去翻盘，让他们在落后时的努力也存在意义。 同时要注意的是，不要过多的加入反馈系统，如之前所述，它可能会造成玩家的被欺骗感。例如如果一个玩家的赛车无论跑的多快，由电脑控制的第二名的赛车都能跟在玩家背后，那玩家的努力的意义在哪？ 控制系统会一定程度上剥夺玩家对于游戏的控制，而控制感又是玩家游戏乐趣的一大来源。但实际上这两者并不矛盾，玩家的控制感和玩家是否真的完全控制游戏并不存在必然关系。如同之前章节中，不确定感也不一定来自不确定的随机一样。Meaningful Play针对的是玩家的感受，而不是游戏的规则。 Afterword： Don’t Forget the Participant 控制系统在学术上还分为，第一类控制系统和第二类控制系统。其中第一类控制系统完全由自身决定，而第二类控制系统还由旁观者决定。 这一章中提到的控制系统为第一类控制系统，但如果考虑到了游戏的文化层面或其他社会层面，则控制系统可能会受外界因素的干扰，成为第二类控制系统。 引用： 1.Rules of Play 2003","link":"/RulesOfPlay-Chapter18-Notes/"},{"title":"《Rules of Play》 第三章笔记","text":"《Rules of Play》 第三章笔记 主要介绍Meaningful Play的概念 可以从两方面来评判Meaningful play，描述性和评价性。 其中评价性又可以从可感知性和协调性两方面进行评价。 Chapter 3: Meaningful Play Introducing Meaningful Play Huizinga在他的书Homo Ludens中提到玩耍是比文化更古老的存在。 Huizinga在很多方面去尝试重新定义玩耍，并找出玩耍的重要意义。 Meaning and Play 创建一个对于玩家而言有意义的良好游戏体验，是成功的游戏设计中一个重要的目标，或许还是最重要的一个。可以将这种设计目标称为meaningful play。 玩耍并不仅仅是从游戏本身诞生的，它还和玩家是如何与游戏交互有关。例如象棋的规则，棋盘，棋子等这些并不能构成meaningful play。meaningful play是从玩家和游戏系统的交互中诞生的，同时也要考虑游戏当前的状态中，如下棋子这个行为之所以有意义，是因为它处在一个棋局中。 玩家在游戏中每做出一个选择，实施这个选择的行为就会产出一个结果。玩游戏的过程就是不断的做选择和实施行为。在一个游戏系统中，所有的事件都被设计成要能支撑一个有意义的选择（如下棋子，如何打回球等），实施这些选择的行为产生的结果也会影响游戏系统。即玩家在游戏中每个行为都会改变游戏的状态，也就让这个游戏系统有了新的意义。 Two Kinds of Meaningful Play 定义Meaningful Play有两方面的考虑。 第一方面是描述性（descriptive）的考虑，即考虑play是否有意义。一个游戏行为导致了一个游戏结果这种交互方式创造了玩耍的意义。 每个游戏都让玩家采取某些行为，然后再为这些行为设定了相应的产出，因为这种设计描述了每个游戏中会发生什么，所以将这种定义称为描述性的定义。 第二方面是评价性（evluateive）的考虑，即考虑play是否有足够的意义？或者怎么样的play是更有意义的？这个方面可以再细分为两个方面 首先是游戏行为是否是可感知的（Discernable），即游戏对于玩家行为给出的结果，对于玩家而言是否能感知到。 如对一个陨石进行炮击，如果没有任何的反馈，如爆炸，陨石改变了运动轨迹，炮击与陨石擦过等，那么玩家无法确定自己是否真的命中了陨石，也就会怀疑之前的操作究竟有没有意义。 又比如一个桌游，如果玩家采取了行动后，无法得知这个行为的结果是让自己离成功更进一步还是更加遥远，那么这个行为对于玩家而言用于是没有意义的。 一个游戏的可感知性（Discernability）就是让玩家知道他们采取的行为究竟产生了怎么样的结果。 另外还能判断游戏行为是否是整体化的，协调的（Integrated）。一个整体的，协调的游戏行为产生的结果是要能结合在游戏更大的情景中，即游戏的行为不仅仅在当下能产出一个玩家可感知的结果，也要同样能影响游戏后续的发展。 可感知的游戏行为，是让玩家知道自己的导弹有没有打中陨石，整体化的游戏行为是决定玩家打中陨石与否这个行为本身又产生了什么深远的影响（陨石轨道改变了一些，所以不会撞到地球等）。 meaningful play可以在游戏的多个方面同时运用，在各种层面上提升玩家的体验。如可以在学科上，如围棋中的一步在数学上的考虑，或在社会层面上，如多个玩家组成了一个游戏论坛，甚至在文化层面上，如围棋冠军可以形成一个围棋热潮等。 引用： 1.Rules of Play 2003","link":"/RulesOfPlay-Chapter3-Notes/"},{"title":"《Rules of Play》 第六章笔记","text":"《Rules of Play》 第六章笔记 这一章中主要讨论了游戏的交互。 作者首先罗列了不同人对于交互的定义，然后推导出自己对于交互的多价模型，并强调这一章将重点讨论其中的显式交互。 然后作者区分了设计者所能设计的是让交互变得有意义的环境。 之后作者谈论了交互中的关键部分“选择”，先是给出了交互结构中的最小微粒&quot;行为-&gt;结果&quot;单元，再通过五个问题对应的五个步骤剖析了选择的过程， 最后阐述游戏设计者并不能直接的限定所有的交互可能，而是通过设计的规则创建一个“可能性空间”。 Chapter 6： Interactivity Introducing Interactivity 玩的过程就暗示了存在交互性：玩游戏，玩玩具，与人玩，都是与被玩的对象进行交互。 这种交互也发生在玩的各种层面上，从游戏本身的交互，到社会中与玩家的交互，还有游戏所诞生的文化的交互。 Defining Interactivity 首先需要定义交互是什么，如果任何事物都可以是交互的对象，那么这个概念也就不再能帮助解决设计问题，因为它实在是太过于宽泛。 传播理论学家Stephen W.Littlejohn把“系统中存在有相互关系的元素称为是可交互的”。 数字媒体理论家Brenda Laurel强调了交互体验的可描述性，将交互系统定义为是个表征空间。这个空间描述了一些事物，人们可以参与在这个空间中去理解事物，这个行为就是交互。 理论学家Andy Cameron在表征空间的基础上强调了直接干预（Direct intervention）的概念，即“交互是需要有能力以有意义的方式干预表征本身，而不是简单的从不同角度去理解。” 游戏设计师Chris Crawdord认为交互是一个周期性的活动，两个参与者需要轮流的进行倾听，思考和反馈。交互的质量取决于每个子活动（倾听，思考和反馈）的质量。 但所有的这些解释都没有解释交互应该如何发生以及在何处发生。而这俩问题才是设计游戏交互的关键点。 A Multivalent Model of Interaction 作者设计了一个多价模型来描述交互，该模型将上述的所有对交互的定义蕴含在其中，且定义了四种交互的类型或者说是四种交互的参与程度，其中每个类型都有可能与其他类型同时发生。 Mode 1：认知交互（Cognitive interactivity; or interpretive participation） 认知交互是一种心理学，情绪上和智能上的人与系统的交互。如当一个玩家玩一款冒险游戏时，他对于游戏世界的复杂想象就是一种认知交互。 Mode 2：功能性交互（Functional interactivity；or utilitarian participation ） 功能性交互是与系统组件（无论是真实的还是虚拟的）的交互。如游戏的交互界面是怎么样的？按钮多硬？系统的反应延迟是怎么样的？在高分辨率的显示器上字体显示效果如何等 Mode 3：显式互动（Explicit interactivity;or participation with designed choices and procedures） 显式互动是关于玩家在游戏规则限定下做出的选择，遇到的随机事件，游戏的动态模拟等等构成的玩家交互体验。 Mode 4：超越对象互动（Beyond-the-object-interactivity；or participation within the culture of the object） 超越对象交互，是超过了设计系统本身体验的交互。如粉丝文化。 这章之后的章节将主要关注显式互动。但需要注意的是四种互动是相互联系的，如玩扑克牌，选择是否切牌是显式互动，牌的质量和大小影响了功能性互动，牌上印的花纹则又是超越对象互动（不同国家扑克牌的花纹通常是与其文化相关的）。 But Is it “Designed Interaction” 为了设计交互性，首先需要了解设计师需要设计哪种交互。 需要记住的是在第三章所述的，meaningful play不仅仅与玩家行为以及系统反馈有关（Descriptive），还与行为执行时的情景有关（Evaluative）。 “某人丢出了一个苹果”是一个交互，但不是一个设计的交互。“丢出苹果”在系统中包含了多个元素的交互，如手，苹果，地面。但是它并不存在于一个上下文中，即这个交互行为是没有意义的。 但如果为这交互设计一个上下文，如两个人在互相丢苹果，并且记录丢出的数量。这样通过一个简单的设计，交互就有了意义。 Interaction and Choice 在游戏中，玩家需要做出选择，系统会根据选择的行为做出相应的回应。选择和回应中的关系一定程度上决定了游戏交互的深度和质量。 考虑游戏中的选择时，可以从两个层次考虑游戏的选择设计：微观（Micro）和宏观（Macro）。微观角度代表了小，实时反馈的选择；宏观角度是这些微观的选择如何结合在一起构成一个更大的游戏体验变换的轨迹。 微观和宏观的选择设计是交织在一起的，无疑有些设计很难判断它到底是微观的还是宏观的。 例如在文字冒险游戏中（输入文字指令，系统同样会以文字告知结果）。在命令行中输入指令就是微观选择，而这些选择在宏观层面上最终或许会构成多种不同的结局。即使在输入行中输入错误的指令（如指令是get rock，而输入是grab rock），也是有意义的，因为系统对于错误输入的提示，也帮助了玩家进一步了解系统规则的边界。 又例如在Black jack（21点）游戏中，每一次选择是否加牌都是微观选择，但这些选择的结果构成了宏观选择（每一次微观的选择都增加了牌一共的点数）。 上面两个例子都说明了微观和宏观上选择是可以很自然的切换，它们将作为一个协调的整体展现给玩家。如果每个行为的结果都是可感知的且整体性的，那么选择就会构成meaningful play。 游戏设计师Doug Church在文章Formal Abstract Design Tools中描述了，在格斗游戏中，玩家的每个控制指令都是统一的，且可以通过屏幕上的角色体现出来（可感知性，同时也是微观的选择）。而且看别人玩游戏，可以看出为什么别人打的比自己更好（整体协调性，同时也是宏观选择的体现）。 可以看出，宏观选择不仅包括在整个游戏过程中该做什么，它还包括是否要继续玩游戏这款游戏和与谁竞争。如果在格斗游戏中，并没有足够的meaningful play，玩家将不知道为什么输，也就会失去对游戏的兴趣。相反，如果每次都能知道为什么对手比自己做的更好，那么输这个行为就是有意义的。 Choice Molecules 构建一个大的有意义的交互结构，其中最小的微粒就是行为-&gt;结果单元。 如在游戏Asteroids中一共有五个按键：左转，右转，前进，开火，跳跃。每个行为-&gt;结果单元就是由这五个按键和他们对于的结果构成的。在游戏进行过程中，每个行为-&gt;结果单元都会形成后一个单元的选择时的情景，单元直接的连接是非常顺畅的，所以玩家根本意识不到自己在一分钟内会做出几百次选择。 Anatomy of a Choice 选择这个概念乍看起来十分的简单，但实际上是一个复杂的结构。在阐述行为-&gt;结果单元时，需要问如下五个问题，这五个问题构成了对选择的剖析（Anatomy of a Choice）。这五个问题同样也是选择时的五个步骤，这五个步骤如果可以顺畅的连接在一起，也就能产生顺畅的行为-&gt;结果单元的连接，最后meaningful play。 在玩家做出选择前发生了什么？ 这个问题是描述玩家做出选择时的状态。无论是微观还是宏观的选择都与这个问题相关。 可能的选项是如何传递给玩家的？ 玩家做出选择时，需要知道可能的选项有哪些。如上述Asteroids的例子中，玩家可能的选项就是五个按键，它通过游戏面板告知了玩家 玩家如何做出选择？ 这个问题与上个问题相关。选项告知玩家后玩家该如何做出选择，通过按按钮，还是语音，或是其他？ 选择的结果是什么，会对未来造成什么影响？ 这个问题是关于玩家行为的结果，而且这个结果是特指内在的结果。玩家的行为在游戏系统中将会怎样产生更深远的影响的，这个影响暂时不会展示给玩家。 游戏的结果是如何传递给玩家的？ 这个问题同样是关于玩家行为的结果，这里的结果是外在的表现。如游戏画面中的角色做出了位移等。 第五个问题解答后将自然的回到第一个问题。因为第五个问题的答案，即产生的结果又构成了下一个选择时的状态。 上述的五个问题，有些是内在的事件（Internal events），有些是外在的事件（external events）。其中问题1,3,4是内在事件，问题2,5是外在事件。 游戏包含内在事件的特征暗示了游戏系统实际上是会记录一部分玩家的行为的，为了在之后产生深远影响。Jesper Juul在文章Play Time, Event Time, Themability中将游戏描述为一台状态机。 下标为Asteroids和下棋两个游戏针对五个选择问题的回答： 针对选择的剖析可以帮助解决游戏设计时的问题。如觉得一款游戏没有足够的meaningful play，可能就是因为在一系列行为-&gt;结果单元的连接中出现了断档，如 如果觉得游戏中的决定并没有什么大影响。问题可能出现在步骤四中，玩家的行为并没有在游戏系统内部构成一个有意义的结果。 如果玩家不知道下一步要做什么。这个现象在大型的冒险游戏中很普遍，问题可能处在步骤二中，问题的选项并没有很清晰的告知玩家。 如果玩家并不知道为什么会输。问题很可能出现在步骤五中，即游戏当前的状态并没有很好的告知玩家。玩家并不知道当前的游戏状态因此无法把握游戏的走向，也就对最终的结果感到困惑。 如果玩家不知道一个操作是否产生了结果。问题可能出在步骤三和四中，即玩家做出了操作，而系统并没有对操作做出相应的反应。这种情况看似很少见，但在一些新鲜的交互方式中很有可能出现，如重力感应，运动传感器等。 Space of Possibility 现在许多关于游戏和交互的作品并不是从一个玩家的视角出发，而是作为一个外在的观察者。但是游戏交互需要的是体验，而不是观察。 创造一个游戏意味着创造一个复杂的系统，这个系统可能会以意想不到的方式被玩家所使用。作为一个游戏设计者，应该让游戏中的各种行为都变得有意义，而不是去打断或者限制玩家的行为。 游戏设计者的工作并不是设计玩家该如何玩，他们的设计工作是去创建一个玩耍可以发生的环境，间接的引导玩家的行为。将玩家未来的所有行动所构成的空间，称为可能性空间（Space of Possibility）。这个概念将游戏设计（design），含义（meaning），系统（system），可交互性（interactive）连接在了一起。 这空间中的所有可能性的意义都来自于游戏设计。游戏设计者也不是直接的去构建这个空间，而是通过设计的游戏规则间接的产生这个空间。 游戏设计是对自己设计的规则，对玩家，对游戏本身产生信心，期望他们能共同创造meaningful play。但最终是否成功，永远无法预先得知，了解游戏设计的关键只是帮助你去接近这个期待。 Game design is an act of faith-in your rules, in your players, in your game itself. Will your game create meaningful play? You can never know for sure. Further Reading The Design of Everyday Things by Donald Norman Formal Abstract Design Tools by Doug Church The Art of Interactive Design: A Euphorious and Illuminating Guide to Building Successful Software by Chris Crawford 引用： 1.Rules of Play 2003","link":"/RulesOfPlay-Chapter6-Notes/"},{"title":"《Rules of Play》 第二十二章笔记","text":"《Rules of Play》 第二十二章笔记 22.1节作者规则和玩在游戏中的关系。 22.2节作者尝试解释玩是什么，并给出了玩的三个分类： 22.3节作者给出了玩的定义 22.4节作者解释了Transformative Play的概念 22.5-22.7节，作者分别对玩的三个定义进行分析。 Defining Play Introducing Play 玩游戏这个操作在玩家体验到游戏的规则时就发生了。 从形式角度来看，游戏中的规则构成了游戏内核的关键。但是把游戏仅看作是形式系统是很危险的事，游戏设计者要意识到设计游戏的最终目的并不是设计游戏规则，即使这些规则很有创意或者很优雅。 游戏规则仅仅是用来创建玩这个过程的，如果游戏设计者拘泥于去设计优雅的游戏规则而忽略了玩家的感受，那么这个设计者就是走错了方向。玩游戏的时的体验才是游戏的灵魂。 在玩游戏时，应该是将游戏作为一个体验和获得快乐的系统。 What Is Play 作者在这一节尝试解释玩是什么。 心理学家J.Barnard Gilmore在Child’s Play一书中说，“即使不是所有人都能在什么是玩耍上达成共识，但是所有人都在准确的知道什么不是玩耍。” 首先作者回顾了在第七章中定义的游戏和玩的两个可能关系： 游戏是玩的子集：如扮演医生或追逐打闹就不属于游戏的范畴 玩是游戏的一部分：除了规则和文化，玩是游戏的重要部分。 这两个关系都是正确的，第一个是个描述性的区分，把游戏作为正式世界中所有的关于玩的集合的一部分。第二个是为概念性的区分，把玩描述为游戏中的一部分。 作者之后又提出，在英文中，Play一词覆盖的范围是非常广的，还有些情况都不适合于玩耍或游戏这两个范围。因此作者将Play一词描述的活动分为三类： 游戏（Game Play） 玩游戏是一个比较狭窄的分类，是那些符合第七章中定义的活动。 玩耍活动（Ludic Activities） Ludic一词来源于拉丁语Ludus,即意为玩。玩耍活动包括的不仅仅是游戏，如小猫玩毛球，两个人互相丢飞盘等都是玩耍活动。这种活动并没有一个可量化的结果系统，因此不能算是游戏。 好玩的（Being Playful） 这是一个最广的分类范围，它不仅仅是包含传统意义上的玩耍活动，还包括脑海中好玩的想法，而这种想法最终会投射入某种活动。如取外号或打油诗，就是一种对文字的玩耍。 上述三个活动分类的结构如下： A General Definition of Play 这里作者给出了玩的定义，上述三个定义的活动都能套入这个定义： 玩是在一个严格结构内的自由活动 即玩是一个系统的体现，它体现了这个系统结构下还能自由活动的范围。 对于上述的三个分类来说： 游戏 玩游戏过程无疑是在游戏所设定的框架（游戏规则）下 玩耍活动 玩耍活动实际上也是存在限定的，如玩抛飞盘就有关于物理规则和参与人员的身体素质等。玩的过程就是就是在反复测试这个限制的边界，抛的更高，更快等 好玩的 外号，打油诗这种实际上也是在语言的语法限定下，去做词汇和短语的自由调整。 玩之所以能存在就是因为有严格的结构，但也是因为做出了一些反结构的行为。如俚语和打油诗虽然符合语法的规则，但是与官方的使用时不同的。像墙壁上丢球能进行，是因为物理规律和墙壁的存在，但丢球这个行为却又不是墙设计的目的。总之，玩这个行为体现出一种反结构和抵抗，但这个行为又是有趣的，它用现有存在的结构发明了一些新的事物（外号→新的语言，丢球→新的行为）。 Transformative Play 当玩耍发生时，它可能可以改变现有的严格结构。如哲学家James S.Hans说，“玩的目的不是在现有的结构下舒适的活动，而是为了通过玩来发展结构”。比如一个好玩的俚语可能最终变成了谚语，成为了正式语言中的一部分。 将这种形式的玩耍称为Transformative play。Transformative Play是玩耍的一种特例，它在现有结构中自由活动会改变当前的结构。Transformative Play在三种玩耍分类中都可能发生： 游戏： 在比赛中，规则会进行调整来让游戏保持挑战性和趣味性 玩耍活动： 儿童的玩耍活动的规则一直会发生变化，甚至会根据玩耍时的情况即兴修改。 好玩的： 如艺术的一些边缘风格最早就是处于玩乐性质，但最后可能就发展成了潮流。 Being Playful 好玩是玩的最广泛的定义。 玩的存在是同时来源于结构和反结构。 如谐音梗的行为，仅在语言本身存在的情况下才有意义，而谐音梗又是与语言本身的定义是违背的。 每个玩耍都有可能成为Transformative Play 与在饭桌上说了一个谐音梗，或许整个饭桌的话题就变成了谐音梗，于是产生谐音梗的语境就发生了变化。 好玩对于游戏设计的提示在于，生活中的普通行为都可以通过加入适当的灵感变成好玩的事。比如排队，开车，看新闻等等行为都可以通过加入一些元素变成一个好玩的事件。 玩是人类活动的一个潜在行为，任何事物都可以称为玩的灵感来源。 Ludic Activities 区分游戏和其他活动的主要点在于是否有可量化结果。 在Roger Caillois的Man,Play,and Games一书中对于玩耍活动有进一步的分类： $Ag\\hat{o}n$：竞争游戏（Competitive Play） $Alea$：几率游戏（Chance-based play）。游戏的结果与玩家无关，更多是因为运气。 $Mimicry$：角色扮演游戏和假装游戏（Role-Playing and make-believe play）。玩家有一种自己就是假象人物的感受，在过程中遗忘和隐藏自己的特性来假装是另一个人。 $Ilinx$：与物理眩晕感相关的玩耍（Playing with the physical sensation of vertigo）。如小孩子原地告诉旋转，然后眩晕的走路玩 Coilois的四个分类都适用于作者给出的对于玩的定义： 竞争游戏和几率游戏：这两个游戏都有系统的规则限定，即使是几率游戏，也是有玩家自己参与，只是希望系统能给出一个更好运的结果。 角色扮演游戏和假装游戏：都是在现有的现实框架下，通过想象做一些自由的移动 眩晕感相关游戏：是基于感官和物理系统的，只不过是利用旋转来获得一种与平常行为不同的感受。 同时Coilois又进一步通过两个分类，将上述的四个分类进行扩展。这两个分类是Paida，表示一种无规则的，即兴的玩耍，Ludus表示一种受规则约束，规范化的玩耍。因此，一共又8个分类，如下所示： 大部分的游戏都使用了多个属于上表中不同分类的元素，如一个角色扮演游戏（Mimicry）可以在玩家快速移动时加入眩晕效果（Ilinx）。 Coilois的分类方法可以成为一个有价值的游戏设计工具，因为它帮助分类了游戏设计中的问题。 Game Play 游戏的体验，是通过玩家的参与来获得的。好玩和玩耍活动包含了许许多多的玩耍形式，而游戏只是其中的一小部分。 游戏无疑是在系统设定的规则内运行的。玩游戏的喜好是玩家游戏规则的直接体现。 在这一章讨论其他的玩，其目的是想找寻如何做出有意义的玩，而不是去调查社会或心理学上对于游戏的存在意义的讨论。 之后的章节会讨论游戏的体验品质，包括玩的心理学，对于情感的表达，游戏促进个人玩耍风格方式等。 引用： 1.Rules of Play 2003","link":"/RulesOfPlay-Chapter22-Notes/"},{"title":"《Rules of Play》 第七章笔记","text":"《Rules of Play》 第七章笔记 本章首先区分了游戏和玩的概念 然后从八种不同的游戏定义角度出发推导出作者对于游戏的定义。 最后介绍了两种看似与游戏定义不符的特例，智力游戏与角色扮演类游戏。 Chapter 7：Defining Games 对于游戏的定义不仅仅是帮助将游戏设计与其他的设计区分开来，更可以帮助人们对于什么是有意义的玩有更深的理解 Play and Game 第一步要区分玩和游戏这两个概念。根据定义方式的不同，玩可以是比游戏更大的概念，也可以是更小的概念 Relationship one： Games are a subset of play 一些玩可以称作为游戏，如躲避球，在这种玩耍下，玩家要遵循一个规则，并且尽量获得胜利。 而另一些玩耍则很难称之为游戏，如在海滩上追逐嬉闹。 实际上大部分的玩都不够有组织化，所以无法称之为游戏。 从类型学方法上来说，游戏是玩的子集，如图： Relationship two：Play is a component of games 在另一些思考角度下，游戏可以视作包含了玩这个概念，玩只是游戏中众多观察和理解角度之一。 从概念方法上来说，玩时游戏的子集，如图： Comparing Definitions 可以看出定义玩和定义游戏是不同的。 作者尝试通过比较前人对游戏的定义来归纳出游戏的定义。但需要提及的一点是在许多的语言中，玩和游戏是使用同一个词汇的，因此在定义过程中，玩和游戏便混合在了一起。作者在这一章对于这种混合的定义仍然会采纳，只不过侧重点在于游戏。 Definition 1：David Parlett Pelett首先区分了正式游戏和非正式游戏的区别。非正式游戏是那些没有明确目标的游戏，如孩子与玩偶的玩耍。 对于正式游戏Pelett给出了二元结构： 终结性：正式游戏从定义上来说有一个获胜者，获胜即是游戏的结束，也是游戏的目标。 意义：正式有游戏有一系列各方都同意的规则和可以使用的设备，可以使用这些设备去获胜。 在Pelett的定义下，非正式游戏其实就是普通的玩，而正式游戏中的获胜目标和规则是关键部分。 Definition 2：Clark C.Abt Abt定义游戏为：游戏是两个或多个独立的决策者参与的活动，在活动中它们在限定条件下去寻找达到目标的方法。或者说是在一系列竞争者和规则的限定下，去赢得目标。 Abt的定义在一定程度上太狭隘：游戏并不一定是竞争环境，也可能是合作的。 同时Abt的定义又在一定程度上太宽泛：按照定义，政治活动等也能算是游戏。 Definition 3：Johann Huizinga Huizinga定义的是玩，他的定义是：玩是一种脱离原本的生活的免费且不严肃的活动，但同时又能完全的吸引玩家。它同时也是个和物质利益无关的的活动，它限定在自己根据一系列规则设定的空间时间框架内。玩也可以促进社会团体的形成，将团队与外界世界区分开来。 Huizinga的定义更加的抽象，他来描述了游玩时的感受，比如吸引但不严肃。但是这些特征并不能很好的定义游戏，一个设计差到无法吸引人的游戏难道就不是游戏了吗？ 但这个定义最大的问题还是在于没有明显区分玩和游戏的概念。 Definition 4：Roger Caillois Caillois同样给出了玩的定义: 自由：玩并不是强制性的 独立性：游戏的环境是一个预先定义和设定好的优先空间和时间 不确定性：过程和结果都无法确定 无产出：游戏不会产生货物或者财富。对于玩家而言，游戏开始时和结束时的情况是一样的。 被规则管理：有自己的独立规则 虚构的：构造一个与现实不同的世界，或者一个与现实完全相反的世界 但Caillois的一些定义与游戏似乎是不相关的。如他提到了自由性，但如果一个游戏是被朋友逼着玩的，它就不是游戏了吗？还有不确定性，一个游戏的老手和游戏的新手一起竞赛，其结果几乎是必然的，难道这就不是游戏了吗？ Definition 5：Benard Suits Suits的对于游戏的定义主要是以下几点： 活动：游戏是个活动 自愿性：游戏可以自由加入 游戏有明确的目标： 规则：规则是游戏的一部分 低效性：游戏的规则限制了行为，让它不再搞笑 共识：规则是被所有玩家接受的 Suits在定义中第一次涉及了低效性，为此他提出了游戏态度（lusory attitude）这个概念，这是对于玩家的一种状态描述。游戏态度理论的一部分是说，游戏中的规则是让游戏变得不高效，如人需要过马路，最高效的方法就是直接穿过去，但是规则限定了人必须走斑马线。游戏态度理论的另一部分就是描述，玩家必须接纳这些规则，正是对这些没必要的障碍的接纳，才让玩游戏变成了可能。 Definition 6：Chris Crawford Crawford提出了四个分类游戏的重要特征： 体现性（Representation）：游戏是一个封闭的正式系统，它体现了正式世界的一个子集。封闭是指游戏是一个完全的自给自足的结构。正式是指游戏有自己的一套规则。游戏创造了一个主观的对现实情感世界的简单体现。 相互影响(Interaction):游戏提供了相互影响元素，这是它们有吸引性的一个重要理由。它体现了游戏世界是如何结合在一起的，改变是如何发生的。 冲突（Conflict）：有相互影响就自然而然就会有冲突。同时游戏还存在障碍，让玩家不会轻易的完成目标。 安全性（Safety）：游戏让人体验心理上的冲突和危险，但保证了物理上的安全。游戏是一个安全的体验现实的方法。 Crawford是第一个将游戏称为系统的人，他也是第一个从电子游戏角度来定义游戏的人。 Definition 7：Greg Gostikyan Gostikyan定义游戏为：游戏一种艺术形式，在其中玩家为管理资源做出一系列决策，并通过游戏代币（Game token，这里的含义不仅仅是钱）来达成目标。 Gostikyan是唯一一个没有将规则纳入游戏定义的人，他也是唯一一个将游戏视作为艺术文化的人。 Definition 8：Elliot Avedon and Brian Sutton-Smith 在Sutton-Smith和Avedon对于游戏的定义为：游戏是一个自愿参加的练习控制的系统，其中会有竞争，同时还有一系列为了获得不同结果而定义的规则。 A Comparsion 下图是上述所有定义提到的点： 只有规则和目标这两项是大部分人都同意的。 Our Definition 作者在对游戏的定义是：游戏是一个玩家参与的，有人造冲突，被规则所限定，有可量化结果的系统。 其中可量化的结果就是区分普通非正式的玩耍和游戏的体现。 作者同时也给出了游戏设计的定义：游戏设计是游戏设计师创造游戏的过程，玩家可以通过游戏进行有意义的玩。 The puzzle of Puzzles 后面会描述两种游戏类型，这两个游戏类型看起来似乎适合游戏的定义又似乎不合适。 首先是各种智力游戏（Puzzles）。智力游戏是一种特殊的游戏形式，是因为它们有固定的答案。智力游戏完全符合作者对游戏的定义，其中的冲突存在于玩家和系统之间。 从智力游戏的角度来思考游戏，可以帮助构筑游戏。比如，当感觉一个冒险游戏太过于开放的时候，或许这个游戏应该有更多的puzzle-like的游戏因素来塑造玩家的成就感（Puzzle-like的元素是可控的）。而当感觉冒险游戏缺乏游玩的感觉时，可能就是因为有太多的Pizzle-Like的因素，让人觉得所有的可能就是限定了的。 Role-Playing Games 角色扮演类游戏（Role-Playing Games）从定义上来看缺乏可量化的结果，但其实这是一个观察角度的问题。 如果从整个游戏的角度来看，角色扮演类游戏确实没有一个可量化的分数之类的结果。但是从游戏中的每一部分去看，在游戏过程中有任务的完成，或角色的升级等，这些都是一个量化结果。 举这两个例子是想说明当遇到一个游戏似乎不满足游戏的定义，应该更多的是从扩大游戏定义的角度去思考，这才会推动游戏的发展。 Further Reading Homo Ludens,Johann Huizinga Man,Play,Games,Roger Caillois 引用： 1.Rules of Play 2003","link":"/RulesOfPlay-Chapter7-Notes/"},{"title":"ShadowsocksR 翻墙教程","text":"简单的介绍ShadowsocksR是什么及如何自己购买并搭建ShadowsocksR需要的服务器。 ShadowsocksR 概述 ShadowsocksR（下简称SSR）的前身ShadowSocks（下简称SS）,是被设计用来混淆数据，用来瞒过墙的实时流量检测，其作者在15年8月被有关部门约谈后，删除了Github上的源码及文档^1。 SSR则是在SS作者停止项目更新后，由另一个作者制作的第三方的版本，加强了混淆协议和插件版本。SS和SSR的工作逻辑并不是加密数据，而是通过伪装来增加GFW(The Great Firewall of China)识别的难度。 “We don’t need security. We need indistinguishability from random bytes.”^2 SS只有一种混淆方式且用户无法自行选择，在作者放弃项目后，这个混淆方式逐渐被墙所识别，所以现阶段SS几乎已经无法正常使用。 搭建SSR翻墙 搭建SSR的基本流程为： 购买国外服务器 在国外服务器上安装SSR软件（作为Server） 安装SSR客户端，并访问国外服务器（作为Client） 市面上有很多售卖翻墙服务的，他们大部分都是自己完成了上述的1,2步骤，然后将配置好的服务器地址售卖给用户，让用户自己使用SSR客户端进行翻墙。这样服务的弊端首先在于服务器的共享会限制网速，其次由于大量的IP访问同一台服务器，增加了被GFW识别的概率，服务器也容易被Ban，导致服务的不稳定性。 购买服务器 服务器可在Bandwagon（下简称搬瓦工）上进行购买，最便宜的套餐为50美元一年，支持支付宝支付。 在购买的过程中，会需要你进行注册，用邮箱即可。 配置服务器 购买完成后，点击搬瓦工页面上方的，ClientArea按钮，进入个人管理，并依次点击Services-&gt;MyServices-&gt;KiwiVM Control Panel，进入管理面板。 进入管理面板后，先点击Stop，将当前服务禁止。注意在这个界面也显示了服务器的地址，记录下这个地址，之后需要用到。 点击左侧Install new OS安装新的操作系统，选择ubuntu 12.04 X86_04，同意款项，并安装。 如果需要BBR加速的话，建议选择最高的X64版本，因为BBR依赖于4.9以上的Linux内核 严格意义上，SSR服务端安装脚本并不依赖于特定系统版本，CentOS 6+，Debian 7+，Ubuntu 12+的系统均可。如果在某版本的系统上出现安装错误（如2019年4月前后，Debian服务器访问失效，导致对应依赖库无法安装），可尝试使用其他版本的系统。 在OS安装后，会显示处SSH的登录密码及端口，通过截图或者其他方法将它们保存下来，之后的步骤需要用到。通常情况下，搬瓦工也会发送一封邮件到你的注册邮箱告诉你密码及端口。 安装SSR软件 在服务器上安装SSR软件，首先你需要登录到服务器上，一般使用软件Xshell，该软件不是免费的，但有一个月的试用期。 在安装完并打开Xshell后，会自动弹出会话窗口，点击右上角新建，然后将我们在之前步骤中记录下的服务器地址及SSH端口号填入。 点击确认后，会自动回到会话窗口，双击刚刚建立的会话，输入用户名root，在连接过程中会提示SSH安全警告，点击接受并保持即可，之后会弹出SSH用户省份验证窗口，将之前记录下的密码填入即可。 成功登录后，界面如下。 之后我们就要进行SSR软件安装，复制命令 123wget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.shchmod +x shadowsocks-all.sh./shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log 在Xshell界面，通过鼠标右键黏贴，然后回车运行，首先我们选择需要运行的脚本，在这里我们需要的是ShadowsocksR。之后会需要用户输入一系列信息，如密码，端口，混淆方式，加密方式等。下图中红框位置即为输入信息，这些参数都可以根据自己的情况调整（如端口号可随意设为1111），通常而言不会引发问题。 SSR软件安装完成后，所有的设定信息都会显示出来 至此，服务器上安装SSR软件结束。 安装SSR客户端 SSR客户端下载地址： Windows/OSX：https://github.com/shadowsocks/shadowsocks-windows/releases Android: https://github.com/shadowsocks/shadowsocks-android OSX: https://github.com/shadowsocksr-backup/ShadowsocksX-NG/releases IOS: Potatso Lite、shadowrocket等软件 配置SSR客户端 以Windows端为例，运行SSR程序后，右键小飞机图标，选择编辑服务器，将之前安装服务器上SSR软件后的一系列信息填入。 再右键，将模式设置为全局模式。 至此，一切步骤完成，可以打开游览器，尝试是否可以正常访问谷歌。 BBR加速 BBR是一套TCP拥塞控制算法，由谷歌开源并提交到Linux内核，在Linux4.9以上，可以使用这套算法来加速网络访问速度。 先使用以下命令来检测Linux内核版本 1uname -r 大于4.9就可以直接切换，如果小于4.9的话，可以选择安装更高版本的OS。 之后通过以下命令只要下载并运行脚本 1wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh &amp;&amp; chmod +x bbr.sh &amp;&amp; ./bbr.sh 完成后运行以下语句验证BBR是否正常工作 1sysctl net.ipv4.tcp_congestion_control net.core.default_qdisc 显示以下结果说明运行成功 12net.ipv4.tcp_congestion_control = bbrnet.core.default_qdisc = fq 如果在安装过程中遇到任何问题，可以直接在下面评论区提出。 SS原工程 https://github.com/shadowsocks/shadowsocks SS作者关于安全性的回复 https://github.com/shadowsocks/shadowsocks/issues/169 https://sphard3.github.io/ssr/ssr.html SSR服务端安装脚本作者 https://teddysun.com/486.html/comment-page-60#comments","link":"/ShadowsocksRTutorial/"},{"title":"《漫画数据库》 笔记 （一）","text":"《漫画数据库》 第一、二、三章笔记。 包括介绍数据库的一些术语限定，关系运算，E—R模型介绍，以及表格规范化。 Chapter 1. What is a database 一个所有数据被每个人共享的系统称为数据库，数据不共享会导致很多问题如内存浪费和数据不同步。 数据库是被多人使用的，所以它必须提供方便的输入和输出接口。 数据库的安全性和权限需要被关注。 数据库的并行处理（如多个人同时修改一个数据）需要被关注。 数据库需要有错误恢复机制来处理异常情况，如磁盘损坏，数据意外丢失等。 DBMS-Database management system Chapter 2.What is a relational detabase? 术语限定 如有一个表 产品ID 产品名 单价 备注 101 西瓜 800 G 有种子 102 草莓 150 G 103 苹果 120 G 104 柠檬 200 G 表中每一列称为字段（Field），每一行称为记录（Record）。可以理解为一个产品就是一个记录，产品的一个属性称为字段。每一个记录都有一系列相同类型的字段。 表中每一个记录的产品ID都是不同的，而类似于单价这样的字段可能存在重复，我们称这些不会有重复的字段为唯一（Unique）。 像字段备注中，有一些数据为空，这些空的数值称为空值（Null） 不同类型的数据库 有宛如树形结构的数据库，称为层次数据模型（Hierarchical Data Model），在层次数据模型中，每个字子数据都只有一个母数据。 有网状结构的数据库，称为网状数据模型（Network Data Model），在网状数据模型中，每个子数据都有多个母数据 还有二元表状的数据库， 称为关系数据模型（Relational Data Model） 在关系数据模型中，称表格为关系（Relation），之前的记录也称为行，之前的字段也称为列。像产品ID这样关键的，作为记录标识的字段，称为主键(Primary key)。 关系运算 关系数据模型可以用数学概念来处理数据。 关系数据模型一共有8个操作，分别为并（Union）,差（Difference）,笛卡尔积（Cartesian Product）,除（Division）,交（Intersection）,投影（Projection）,选择（Selection）,连接（Join），这些操作都可以相互组合。 如存在两个表 商品名称 单价 西瓜 800G 草莓 150G 苹果 120G 柠檬 200G 商品名称 单价 西瓜 800G 草莓 150G 栗子 200G 柿子 350G 并（Union） 并操作，就是将两个表的记录合并在一起，形成一个总表。并操作结果为： 商品名称 单价 西瓜 800G 草莓 150G 苹果 120G 柠檬 200G 栗子 200G 柿子 350G 差（Difference） 差是求两个表差异的记录，如表一差表二，结果为 商品名称 单价 苹果 120G 柠檬 200G 表二差表一，结果为 商品名称 单价 栗子 200G 柿子 350G 交（Intersection） 交是求两表相同的记录，交的结果为 商品名称 单价 西瓜 800G 草莓 150G 笛卡尔积（Cartesion Product） 笛卡尔积是求两个表所有行的排列组合，如有商品表和出口国表 商品编码 商品名称 单价 101 西瓜 800G 102 草莓 150G 103 苹果 120G 出口国编码 出口国名称 12 米纳米王国 23 阿尔法王国 25 理陀儿王国 两表笛卡尔积的结果为： 商品编码 商品名称 单价 出口编码 出口国名称 101 西瓜 800G 12 米纳米王国 101 西瓜 800G 23 阿尔法王国 101 西瓜 800G 25 理陀儿王国 102 草莓 150G 12 米纳米王国 102 草莓 150G 23 阿尔法王国 102 草莓 150G 25 理陀儿王国 103 苹果 120G 12 米纳米王国 103 苹果 120G 23 阿尔法王国 103 苹果 120G 25 理陀儿王国 笛卡尔表的结果就是将原先两个表的记录都排列组合。 并、差、交和笛卡尔积都为集合运算 投影（Projection） 投影是求表中的某列（可以一列或多列），结果如 产品名 西瓜 草莓 苹果 柠檬 选择（Selection） 选择是求表中的某行（可以一行或多行），结果如 商品名称 单价 香瓜 800G 连接（Join） 如存在两个表，商品表和销售表 商品编码 商品名称 单价 101 西瓜 800G 102 草莓 150G 103 苹果 120G 104 柠檬 200G 日期 商品编码 数量 11/1 102 1100 11/1 101 300 11/5 103 1700 11/8 101 500 连接操作是将两个表通过相同的字段连接起来，这里的字段即为商品编码。结果为 日期 商品编码 商品名称 单价 数量 11/1 102 草莓 150G 1100 11/1 101 香瓜 800G 300 11/5 103 苹果 120G 1700 11/8 101 香瓜 800G 500 我们将销售表中的商品编码称为外键(foreign key)，外键参照其他表中的主键进行联合。 除（division） 除运算就是在被除表格中找到除表格中所包含的行，并将除表格中的字段去除的操作。如有两个表销售表和出口国表，前者为被除表格，后者为除表格 出口国编码 出口国名称 日期 12 米纳米王国 3/5 12 米纳米王国 3/10 23 阿尔法王国 3/5 25 理陀儿王国 出口国编码 出口国名称 12 米纳米王国 23 阿尔法王国 结果为 日期 3/5 3/10 注意，除的结果不包含重复行 Chapter 3. Let us Design a databases E-R模型 可以使用E-R模型帮助分析问题和设计数据库，E表示实体（Entity），R表示关系（Relationship）。 现实生活中物体可以标识为实体，如水果和出口目的地，实体间的交互称为关系，如我们将水果卖到出口目的地，“卖”就是关系。 有多种水果也有多个出口目的地，所以这个例子中的两个实体都代表多个对象，这个关系称为多对多关系。在E-R模型中实体的数量也需要被考虑。如果只将一种水果卖给多个地方，就为一对多关系。这种实体间对应的个数称为基数(Cardinality)。 规范化表格 为了避免数据冲突（同一个数据在不同表中不一样，可能因为部分未更新而造成）而将表格拆分开的过程称为规范化（Normalized）。 非范式（Unnormalized）表格存在一个记录的一个字段存在多个数值，如 报表编码 日期 出口国编码 出口国名称 商品编码 商品名称 单价 数量 因为一次报表可以买多个商品，所以一个报表编码可以对应多个商品编码，因此该表为非范式表格。 第一范式（First Normal）的表格满足一栏中只有一个项目，每一列都是不可分割的基本数据项。我们将上表拆分，可以得到第一范式表格，主要就是将商品编码与报表编码拆分。 报表编码 日期 出口国编码 出口国名称 报表编码 商品编码 商品名称 单价 数量 表一中，报表编码为主键 表二中，报表编码和商品编码的组合为主键。并不是表示表二存在两个主键。 满足主键值可以确认其他列的表格称为第二范式表格。如果主键是多个字段的组合，那么其他列必须同时受这多个字段的控制。 本例中，如果关注第一范式中的表二，可以发现商品的名称和单价也存在与表格中，但实际上这两者只受商品编码控制（即使我们只知道商品编码，我们也能知道单价和名称），而表二的主键是商品编码和报表编码的组合，因此表二并不符合第二范式要求。我们可以将表二进行拆分。 表一保持不变 报表编码 日期 出口国编码 出口国名称 表二拆分为 报表编码 商品编码 数量 商品编码 商品名称 单价 拆分出的第一个表，主键为报表编码和商品编码的组合。第二个表格，主键为商品编码。 满足主键值唯一确定其他列（即不存在间接性确认）的表格称为第三范式表格。 在上面的表一中，存在间接性确认。出口国名称虽然受报表编码的控制，但实际上是出口国名称受出口国编码影响，出口国编码受报表编码控制。所以存在间接控制，不满足第三范式。 因此将表一进行拆分为两个表格 报表编码 日期 出口国编码 出口国编码 出口国名称 表一的主键为报表编码，表二的主键为出口国编码。 剩下的表格保持不变，即 报表编码 商品编码 数量 商品编码 商品名称 单价 现在我们一共有四个表，表一中的出口国编码参照表二的主键出口国编码，表一与表二连接。同理表三中的报表编码参照表一的主键报表编码，表三与表一连接。表三中的商品编码参照表四的主键商品编码，表三与表四连接。 不同表格建立相互联系的键叫做外键（Foreign Key），外键用来参照其他表格的主键。表一中的出口国编码，表三中的报表编码,商品编码，三者都是外键。 设计数据库 设计数据库的步骤可以分为概念模式，内部模式,外部模式三部分 概念模式：将现实世界模型化确认数据库理论结构的阶段。概念模式是通过E-R模型描述现实世界，并进一步规范化表格实现的。 内部模式：内部模式从计算机内部物理构造考虑，设计目的是让数据库可以被高速检索。 外部模式：外部模式是从用户和应用角度来考虑，设计目的是让用户和程序可以方便使用。 引用： The Manga Guide to Databases 2009","link":"/TheMangaGuideToDatabasesNotes-1/"},{"title":"《漫画数据库》 笔记 （二）","text":"《漫画数据库》 第四、五、六章笔记。 包括介绍SQL环境的配置，SQL语言的基本操作，事物的概念，数据库部分优化概念及分布式数据库。 MySQL环境配置 《漫画数据库》一书没有说明如何配置MYSQL环境，而在第四章中却开始说明一些SQL语句，这就导致读者没地方实践语句。 在这里先简单介绍如何配置MySQL环境，主要参考网上的MySQL教程。 MySQL程序安装 Windows系统上可以直接安装MySQL全家桶来完成SQL环境的配置。 安装过程基本傻瓜式，但需要注意在安装中有设置密码的步骤，这个密码在之后登陆服务器时会用到。 安装过程并没有直接将MySQL Server添加到系统环境中，MySQL Server的安装地址默认在于C:\\Program Files\\MySQL\\MySQL Server 8.0\\bin，将这个地址默认添加到系统环境中即可，关于如何添加系统环境这里不赘述。 通过Shell连接MySQL 配置完成后，可以通过命令mysql -u &lt;userName&gt; -p登陆Server，这里需要输入密码，密码即为安装过程中设置的那个。 12PS C:\\Users\\wxj&gt; mysql -u root -pEnter password: ********* Welcome to the MySQL monitor. Commands end with ; or \\g 可以使用命令 show databases来查看目前的数据库 123456789101112mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || sakila || sys || world |+--------------------+6 rows in set (0.00 sec) 通过MYSQL WorkBench连接MySQL 如图打开workBench后依次点击，操作分别是增加连接，设置连接名字（任取），设置密码，确认密码设置，确认连接设置。添加完成后效果如下图所示， 双击连接便能打开数据库界面。 注意红框处的数据库名称与我们通过shell所展现的是一样的。在右侧的Query窗口可以编写SQL语句 使用MySQL Workbench新建数据库 在SCHEMAS界面邮件，选择新建数据库，然后设置新数据名字并Apply即可 创建完成后，同样在SCHEMAS界面，双击新形成的数据库将他设置为默认的数据库即可。 执行SQL文件 在设置完默认的数据库后，运行的SQL文本会自动基于当前的数据库。可以只用快捷键Ctrl+Shift+Enter执行整个SQL文件的命令，或使用CTRL+ENTER执行当前语句的命令。 Chapter 4. Let us learn about SQL 数据定义语言（Data Definition Language，DDL） 用来创建、更改和删除表 数据操作语言（Data Manipulation Language，DML） 用来操作数据，如插入，更改，删除数据 数据控制语言（Data Control Language，DCL） 用来控制数据库，如保护多人同时使用数据库也不会有冲突 SQL的命令(Statement)是由短语(Phrase)组成的，如SELECT,WHERE都为短语。 创建表格 使用短语CREATE TABLE创建表格 1234567891011121314151617CREATE TABLE &lt;TableName&gt;( &lt;FieldName&gt; &lt;FieldType&gt; PRIMARY KEY(&lt;FieldName&gt;))如create table if not exists `SALES_TABLE`(`REPORT_CODE` int Not NULL,`EXPORT_DATE` date,`EXPORT_DESTINATION_CODE` int,primary key(REPORT_CODE) -- set primary Key); 使用短语ALTER修改表格 12345678ALTER TABLE &lt;TableName&gt;&lt;Phrase&gt;-- 为product_table 表格增加DISTRICT列，且让他排在`UNIT_PRICE`后alter table product_tableadd column `DISTRICT` VARCHAR(45) nullafter `UNIT_PRICE`; 表格添加及删除数据 使用短语Insert into及values来添加数据 123456789101112131415insert into &lt;TableName&gt;(&lt;FieldName1&gt;,&lt;FieldName2&gt;)values (&lt;Field1Data&gt;,&lt;Field2Data&gt;), (&lt;Field1Data&gt;,&lt;Field2Data&gt;);-- 如insert into sales_table(REPORT_CODE,EXPORT_DATE,EXPORT_DESTINATION_CODE)values (1101,'2019-03-05',12), (1102,'2019-03-07',23), (1103,'2019-03-08',25), (1104,'2019-03-10',12), (1105,'2019-03-12',25); 使用delete from及where短语删除数据 1234567delete from &lt;TableName&gt;where &lt;condtion&gt;;-- 如delete from product_tablewhere PRODUCT_CODE=101; 使用update,set,where更新数据 12345678update &lt;tableName&gt;set &lt;FieldName&gt;=&lt;FieldData&gt;where &lt;Condition&gt;-- 如update product_table set DISTRICT='South Sea' where PRODUCT_CODE=101 or PRODUCT_CODE=104;update product_table set DISTRICT='Middle' where PRODUCT_CODE=102;update product_table set DISTRICT='North Sea' where PRODUCT_CODE=103; 查看数据 使用短语SELECT FROM，WHERE，以及比较运算符,关系运算符以及通配符来选择数据，SQL支持的比较运算符和关系运算符如下： 比较运算符 含义 关系运算符 含义 通配符 含义 A = B A等于B AND 与 * 匹配任意长度的任意字符 A &gt; B A大于B OR 或 - 匹配长度为1的任意字符 A &gt;= B A大于等于B NOT 非 A &lt; B A小于B A &lt;= B A小于等于B 语句形式如下 1234567891011121314151617select &lt;FieldName&gt;from &lt;TableName&gt;where &lt;condition&gt;;-- 如搜索数量大于1000的产品,且显示表中所有数据select * from sales_statement_tablewhere QUANTITY&gt;1000;-- 这里使用了*来表示所有数据，如果我们仅想显示一个PRODUCT_CODEselect PRODUCT_CODE from sales_statement_tablewhere QUANTITY&gt;1000;-- 取所有产品名以n结尾的产品select * from product_tablewhere PRODUCT_NAME like '%n'; SQL还自带了一些函数帮助计算，如求最大值，求行数等 函数 含义 COUNT(*) 求行数 COUNT(FieldName) 求非空值行的行数 COUNT( Distinct FieldName) 求除了空值和重复值的行数 SUM(FieldName) 求各行总和 AVG(FieldName) 求各行平均 MAX(FieldName) 求各行最大 MIN(FieldName) 求各行最小 如 1234-- 求一共有几个数量大于1000的销售产品select COUNT(*) from sales_statement_tablewhere QUANTITY&gt;1000; 分组计算 使用短语group by进行分组 123select &lt;FieldName&gt;from &lt;TableName&gt;group by &lt;FieldName&gt; 如有列表 PRODUCT_CODE PRODUCT_NAME UNIT_PRICE DISTRICT 101 MELON 800 South Sea 102 STRAWBERRY 150 Middle 103 APPLE 120 North Sea 104 LEMON 200 South Sea 201 Chestnut 100 North Sea 202 Persimmon 160 Middle 301 Peach 130 South Sea 302 Kiwi 200 South Sea 想通过DISTRICT进行分组，可以使用 123select DISTRICT,AVG(UNIT_PRICE),UNIT_PRICEfrom product_tablegroup by DISTRICT; 这里选择的是分组完后价格的平均值，输出结果为 DISTRICT AVG(UNIT_PRICE) UNIT_PRICE South Sea 332.5 800 Middle 155 150 North Sea 110 120 因为表的一项只能显示一个数值，所以在分组后的UNIT_PRICE项，只能显示这个分组的第一个数值。 分组完后的数据如果需要筛选，应该使用短语having而非where 12345678910select DISTRICT,AVG(UNIT_PRICE),UNIT_PRICEfrom product_tablegroup by DISTRICThaving AVG(UNIT_PRICE)&gt;=200;select DISTRICT,COUNT(*)from product_tablegroup by DISTRICThaving count(*)&gt;=3; 结果为 DISTRICT AVG(UNIT_PRICE) UNIT_PRICE South Sea 332.5 800 DISTRICT COUNT(*) South Sea 4 使用子查询检索 例如我们需要打印出销售额大于1000的产品名称，销售额是在销售表中，产品名称是在产品表中，这时就需要用到子查询。先重销售表中查询处满足条件的记录，再基于得到的记录查询名称。子查询(Subquery)使用短语In即可，这里是相当于先运行了括号内的内容，再执行外部的查询。 1234select * from product_tablewhere PRODUCT_CODE IN(select PRODUCT_CODE from sales_statement_tablewhere QUANTITY&gt;=1000); 另外还有相关子查询(CORRELATED SUBQUERY)，相关子查询最大的区别是先运行括号外的内容，再将结果一条条传递给括号内的查询，如 1234567select * from sales_statement_table Uwhere QUANTITY &gt;( select avg(QUANTITY) from sales_statement_table where PRODUCT_CODE=U.PRODUCT_CODE); 这里将外部查询的表sales_statement_table命名为U，并将查询的结果传递给内部查询。例如sales_statement_table表中的第一个元素的PRODUCT_CODE为101，那么实际上在第一次运行时，内部查询相当于 123select avg(QUANTITY) from sales_statement_table where PRODUCT_CODE=101 得到结果后，再将结果（这里是平均值）传递给外部查询。这个相关子查询的工作是找出订单产品销售额大于该产品平均销售额的订单。 制作视图 视图(View)相当于是一个虚拟表，它仅是用来被用户查看。生成视图的表成为基表(Base table)，使用短语Create view创建 12345678910111213create view &lt;ViewName&gt;(&lt;ViewField&gt;) -- 如果Field完全与BaseTable一样，可忽略as select * from &lt;BaseTableName&gt;where &lt;Condition&gt;;-- 如create view expensive_product_tableas select * from product_tablewhere UNIT_PRICE&gt;=200; 删除视图与表 使用短语drop 12drop view &lt;ViewName&gt;;drop table &lt;TableName&gt;; Chapter 5. Let us operate a databases 事物 用户的一系列成功操作成为事物(Transaction)。数据库必须保证即使多个事物同时执行，也不会发生矛盾，和即使事物处理过程中发生了意外，数据也不允许发生矛盾。数据库事物通过具有ACID属性来保证不会产生数据矛盾。 属性 含义 A（Atomicity），原子性 事物必须结束于提交或回滚 C（Consistency），一致性 执行数据库事物时不能损坏数据库的一致性 I（Isolation），隔离性 多个事物的执行时互不干扰的 D（Durability），持久性 事物完成后，事物对于数据的更改会持久的保留在数据库中 Atomicity，原子性 事物必须以提交(Commit)或者回滚(Rollback)作为结束，提交是确定数据库事物的处理，回滚是取消事物处理的指令。提交和回滚是自动执行，但也能通过命令COMMIT和ROLLBACK来显示执行。 Consistency，一致性 如描述，数据库需要保证不会损坏数据库数据的一致性 Isolation，隔离性 如果多个事物同时执行并返回了同样的结果，将这一些列事物称为安排（Schedule），并称这些安排是可序列化(Serializable)的。事物的隔离性要求安排必须是可序列化的。 通常我们使用锁(Lock)来满足可序列化，锁又分为共享锁(shared lock)和独占锁(exclusive lock)，前者是读取数据时使用，后者是写入数据时使用。使用共享锁时，其他事务可以假设共享锁，但是不能加设独占锁。使用独占锁时，其他事务不能加设任何锁。 为了确保事务可以序列化，需要遵守一定的规则，规则其中一项就是两阶段封锁(two-phase locking)（书中未做详细解释）。 另外还需要注意锁的粒度(Granularity)。粒度越大表示锁控制的数据就越大，这样一个事务设锁的次数会减少可以减少CPU负担，但是因为加锁的数据大，导致等等的对象会增多且等待时间上，所以同时可以执行的事务就减少了。反之同理。 除了加锁外，还有其他的控制方法。如时间戳控制(Timestamp control)和乐观控制(Optimistic control)。 （1） 时间戳控制是在执行一个事务时指定一个时间戳，当有另一个事务以更新的时间戳更新数据时，之前时间戳的事务将会被静止并回滚。 （2） 乐观控制允许读操作，而在写操作时会检查是否有其他的事务已经更新了数据，如果有回滚该操作。 在实际运用中，实际上可以设定隔离等级(Levels of islation),隔离等级分为四个,READ UNCOMMITTED，READ COMMITEED,REPEATABLE READ,SERIALIZABLE,默认为SERIALIZABLE。 根据隔离等级的不同，可能发生以下现象 脏读 非重复读 虚读 READ UNCOMMITTED 可能发生 可能发生 可能发生 READ COMMITEED 不发生 可能发生 可能发生 REPEATABLE READ 不发生 不发生 可能发生 SERIALIZABLE 不发生 不发生 不发生 脏读（Dirty Read）表示在事物1提交前，事物2就读取了某数据。 非重复读(Non-repeatable Read) 表示一个事务重复读取了两次数据，然后得到了不一样的值。可能原因就是其他的事务并行的更新了数值。 虚读（Phantom Read）表示一个事务搜索匹配某模式的数据时返回了错误值但是因为其他的事务在并行的更新数据，所以搜索到了错误数据。 持久性（Durability） 可以使用命令GRANT指定用户访问数据库或者表的权限,被授权的用户也可以附带WITH GRANT OTION信息来给其他用户权限，在取消某用户权限时，可以使用REVOKE。可设定的权限包括SELECT,INSERT,UPDATE,DELETE,ALL。 另外可以使用视图来管理权限，如将表格中的一部分数据生成视图，然后针对视图给用户权限。 12345GRANT &lt;Privileges&gt; ON &lt;TableName or viewName&gt; TO &lt;User&gt; (WITH GRANT OPTION);GRANT SELECT,UPDATE ON product_table TO business_department;GRANT SELECT,UPDATE ON product_table TO overseas_business_department with grant option;REVOKE SELECT,UPDATE ON product_table FROM business_department; 异常处理 数据库必须包含某种机制来保证意外发生时数据仍然正确。可能的意外包括 事务错误（Transaction failure） 当事务错误发生时，事务将无法被提交，将会进行回滚处理。 系统错误（System failure） 如发生断电等情况，将发生系统错误，在系统重启后，未提交的事务将会被回滚(Roll backward)，已经提交的事务将会进行前滚（Roll forward）。 这里已经被提交的事务限定在上一个检查点(CheckPoints)后的提交。检查点的生成与缓存数据相关，在数据库写入数据时会被短暂的存储在缓存中，当缓存内的数据和数据库同步后，将会生成一个检查点。 介质错误（Media failure） 包含数据的硬盘发生损坏时称为介质错误。在这种情况下，将会恢复备份数据且在备份数据生效后，事务将会被前滚。 索引 当数据库非常庞大时，搜索特定数据可能会需要花费很长的时间，这时候就需要用到索引(Indexes)。索引有两种方式，B树和散列（Hash）。 B树 B树相当于用树形结构来存储数据，每个节点都是经过了排序的，每个父节点都包含了子节点中最大值和最小值的信息，这样就可以加快节点的搜索。 散列 散列通过一个散列函数来求得数据的存储地址，但散列只适用于完全一致的搜索，如找寻编码为101的数据，而类似找寻值大于XX 这样的搜索就不匹配。 搜索优化 如存在一个搜索命令 1234SELECT dates,product_nameFROM product,salesWHERE unit_price &gt;= 200AND product.product_code = sales.product_code 这个操作可以看作由三个步骤组成 将产品表和销售表两个表组合在一起 找出单价大于200的产品 抽出日期和产品名两列 但这样的三个步骤可以有两种排列方式（1）按上述的步骤进行执行（2）先在两个表中各自抽出相关列，然后在产品表中找出满足条件的产品，然后在将两列结合在一起。 第二种方式有更高的效率，因为先抽取了列然后选择可以减少最后合并的工作量。 通常数据库的操作按照，先选择，在投影，最后合并的操作顺序，这样可以减少相关的工作量。 合并操作优化 对于合并操作来说，也有三种合并实现方式 嵌套循环 即先从需要合并的表一找出需要合并的一行，然后遍历搜寻表二中符合的行。然后在表一中寻找需要合并的下一行 排序合并 即先对两个表各自排序，然后再合并。因为排序后两个表都可以按照一个顺序来合并，所以会提升效率。但需要考虑排序的时间。 散列 即通过散列函数快速的找到需要合并的两个表匹配的数据。 优化原则 规则导向 因为对于一个操作，可以有不同的执行顺序但能获取一样的结果。所以可以预先多个规则来指定步骤的执行顺序，如之前的先选择，在投影,最后合并就是一个规则。 成本导向 成本导向是根据数据库内的统计数据，再根据这些数据来选择优化的方式。成本导向相对于规则导向更灵活，但需要定期生成统计数据，统计数据的生成和分析都需要花费额外的时间。 Chapter 6. Databases are everywhere 网络与数据库 当网页与数据库一起工作时，整个系统由三层组成，称为三层客户端服务器(threetier client/server system)，包括表示层(presentation layer)，逻辑层(logic layer)和数据层(data layer)。 表示层 表示层接受用户输入，并会显示数据库检索结果。 逻辑层 逻辑层对SQL命令进整合，对数据进行加工 数据层 数据层由数据库服务器处理，对数据库进行查询，并返回检索结果。 使用存储程序 为了避免网络的数据传输，数据库有存储程序，可以存储一些高频的SQL查询命令。有三种存储程序，存储过程（Stored procedure），存储功能(Stored function)和触发器（Trigger）。分别用来，存储没有返回值的才做，存储拥有返回值的操作，和在操作完成后自动存储。 分布式数据库 数据库本身可以被分散到不同的地点而通过网络相连接。尽管数据库被分散了，但是用户仍然可以把它当作一个数据库来进行处理。 数据库可分为水平分布和垂直分布两种，前者指的是使用多个同级别的数据库服务器的存储方式，这些服务器各自可以使用别的服务器的数据。后者指的是每个数据库服务器具有不同功能的分布方式，由承担主要任务的主服务器和承担其他处理任务的服务器构成。 分布式数据库的数据也必然是由各数据库服务器各自存储，而数据的分配方式也同样分为水平分配和垂直分配两种。水平分配指的是不同的服务器各自存储表的不同行（记录），而垂直分配则是不同的服务器各自存储表的不同列（字段）。 为了避免不同的数据库服务器同时操作而导致数据冲突，分布式数据库采用名为两阶段提交(two-phase commit)的方法。 两阶段提交包括有协调者(coordinator)和参与者(participant)且由两个阶段组成 第一个阶段由协调者询问各参与者是否可以提交事物 第二阶段是协调者根据参与者返回的结论，进行相关操作，如果所有参与者都返回可以提交，则进行提交，反之有任何一个参与者拒绝了提交，则回滚事物。 下图分别为成功提交和失败提交的例子。 数据库复制 在分布式数据库中为了减少网络的负载，数据库设置了复制功能。我们将主要的数据库服务器称为主数据库(Primary database)，以及存有复制数据的服务器成为复制数据库(replica)。 复制数据库分为读取专用和可更新两种，前者复制服务器仅能读取主数据库的信息，后者可以对数据进行修改并且同步给主数据库以及其他数据库。 引用： The Manga Guide to Databases 2009","link":"/TheMangaGuideToDatabasesNotes-2/"},{"title":"《The Use of Digital Games to Teaching Computer Graphic》 笔记","text":"这篇论文中，作者表达了希望可以通过游戏来帮助图形学教学，并探讨了以下几个问题： 图形学课程的范畴 图形学不同教学方式 电子游戏对于高等教育的帮助 目前图形学课程中，交互式游戏的例子 The Use of Digital Games to Teaching Computer Graphics: an Open Opportunity 原文中有大量source作为例子，在这里不会将所有的被引用source的内容整理再次。 但会通过类似于[2]这样的标记，这个说明该部分内容在原文的第二篇引用中有详细说明。 Introduction 3D空间想象的概念对于部分学生来说很难理解。 游戏和图形学都是需要可视化，而且都需要交互，所以这两者很匹配，有结合在一起的可能。 The Computer Graphic Curriculum 这一部分作者首先讨论了图形学的范畴，然后阐述了多年来图形学教学的变化。 The Computer Graphics Knowledge Base 在2006年的报告中，ACM SIGGRAPH将图形学分为了17个子领域[1]，如下所示： The Modern Computer Graphics Curriculum 在1970-1980年代，受限于昂贵的图形学硬件，只有少数的大学提供了图形学课程。课程也大多局限在底层的硬件教学，基本渲染算法和3D模型的介绍。 在1980-1990年代，图形学硬件相对来说价格变得容易承受了一些。图形学课程变为了大学教育中的常见课程，课程关注底层算法，图形学硬件，数学，光照和颜色的原理和一些基本API的使用。 从1990倒现在，因为图形学硬件变得更便宜，和一些高标准的图形学库出现（OpenGL，Direct3D），图形学课程设计变为选择更好的软件工具来提升教学体验，目前主流的教学都是选择C/C++以及OpenGL库。 因为目前大多数较低层的算法和整个渲染处理都被结合进硬件层，所以课程的主题也发生了很大的变换。现在对于不同层次和目标的图形学学习者，通常会覆盖不同的主题。如对于计算机科学的学生，可能仍然需要关注于数学和一些底层的渲染知识。对于软件工程的学生，可能更多的是学习一些高层的编程框架。对于媒体的学生，则是关注于一些图形建模的商业软件等。 Some students on the CG syllabus 这里是作者总结了一些别人的关于图形学范畴大纲研究。 第一份报告[17]是在1990年代后期发布的，这一份报告研究了美国23个大学的图形学研究范畴。关注度最高的主题包括，摄像机/观察者坐标变换，硬件，光照模型，3D变换，用户交互，物体表示，阴影模型，颜色模型，曲线，隐藏表面取出，光栅化（viewing/camera transformations, hardware,lighting models, 3D transformations, user interaction, object representation, shading models, color models, curves, hiddensurface removal, and rasterization）。 第二份报告是在2005年发表[18]，这一份报告研究了超过70个学术项目课程。发现许多的课程已经不仅仅局限在传统的3D图形范畴，更关注于图形学，图像处理，人机交互三个领域的结合，而且对于2D内容的关注也逐渐加深。 第三方报告是在2016年发表[19]，这一份报告选取了美国近400个关于图形学的课程研究。发现上述第一份报告中主要关注的主题，现在都出现在了教科书中。而且现在的课程开始关注于工业与学术的联系。这一份报告同时建议，之前的图形学17个子领域应该缩减为9个[3]：艺术设计，动画，数字成像，物理，视觉感知，可视化通信，数学，认知科学，计算机编程(Art and design, animation, digital imaging, physics, visual perception, visual communication, mathematics, cognitive sciences, and computer programming)。另外图形学课程必须强调多学科的结合，其基本框架应该是科学，技术和艺术原则的结合。 在2013年，ACM和IEEE还发布了一个关于计算机课程的指导文件[20]，其建议课程应该包含图形学的基本概念，基本与高级渲染，几何模型，动画和可视化，每一个学习了图形学课程的学生应该都有能力进行2D/3D的坐标转换，同时有对于3D渲染的基本了解。 General Approaches To Teaching Computer Graphics 这一部分作者总结了不同的图形学教学的方法 目前图形学的教学方式可以分为以下六种： Survey 调查法是提供一个对于图形学的笼统概念，而且并不提供编程相关的内容。 这一方法在图形学学科的初期被使用的较多，主要原因是当时并没有足够的软硬件进行其他的教学方式。 Bottom-Up 自底向上法一开始学习一些最底层的算法，数学方法和其他的基本元素，然后逐渐的向更高层的知识学习。例如一开始学习如何画直线，如何画二维曲线，然后再一步步的变换为2D形状，3D形状。 很多经典的图形学书籍都是采用这个方法。 Top-Down [8] 自顶向下法一开始分析和实现一些图形学的软件，然后再逐渐的去了解其底层的知识。好比先学习如何开车，再学习汽车的构造等等。 这些年，大部分的教学都是通过自顶向下法。 自底向上法可能更适合于一些立志研究计算机科学的人，他们对底层的知识有更高的要求。而对于软件工程和艺术家而言，自顶向下法更为合适。 Constructivist [26] 建构法是老师不再为每个主题提供一个复杂的教学内容，而是去指引学生构建一个对于学科的概念知识。让学生可以通过对不同主题的教学内容进行可视化，实验，测试来得到知识。 Breadth-First [27] 广度优先法类似于自顶向下法。只不过广度优先更强调跨学科的尝试，而自顶向下法仍然是针对不同专业的人，给他们特定的学习内容。 Project-Based Learning(PBL) [28] 基于项目的学习法是让学生通过解决特定问题或完成项目来学习知识。 这一方法成立的前提是目前C++，OpenGL等语言和库已经相对成熟，学生可以很快的搭建出一个软件的框架。 Digital Games as a Leaning Strategy In Higher Education 这一部分作者探讨了在高等教育中用电子游戏帮助学习的例子 电子游戏可以可以提供一个沉浸式的学习体验，在许多的学科研究中也已经证明了电子游戏帮助学习的有效性[34,35]。 现在也有一系列通过游戏来帮助学生学习编程的例子[36,37,38,39]。 对于软件工程的学生而言，基于游戏学习可以再细分为两种类型，第一种是真正的用游戏来学习（Game-Based Leaning,GBL），另一种是基于游戏开发的学习（Game-Development-Based Learning，GDBL）[43] The Use of Digital Games and Interactive Simulators to Teaching Computer Graphics 这一节作者针对说明了在图形学的教学中，用游戏和模拟方法来提升教学体验的例子 对于图形学的教学，除了上述的两种游戏教学法（GBL和GDBL），还有一种提供交互的模拟方法（simulator）。这种方法严格意义上无法被称之为是游戏，但学生同样可以通过交互进行修改参数之类的操作，来实时进行实验和看到变化。 GDBL Approaches 这种方法是让学生通过开发一款游戏来了解图形学的知识。 主要的例子有[44]，其中老师开发了一款名为GameX的平台，学生在上面通过使用OpenGL和DirectX来进行开发游戏。而且他针对不同的学生，可以开放不同程度的API。 类似的还有[45]，一款名为eNYyMyCar的平台，其中学生可以共享和展示自己的开发成果。 还有`[46]也是一个实现，这个实现还结合了各种其他的游戏方面的知识。 Interactive Simulators Simulator的例子有[47,48,49,50,51,52] 这些例子都是通过让学生对某个主题的模拟程序进行交互，来查看效果。 GBL approaches [54]开发了一个网页游戏，学生通过解密学习知识。 [55]一款2016年的游戏，学生要通过各种坐标变换来获得游戏要求的形状。 Discussion 作者从1990年到2016年，一共找到了11个交互的图形学教学，其中5个是交互模拟，4个是GDBL，2个是GBL。 交互模拟是最早出现的，但是绝大部分都是出现在90年代，只有1个是在2000年早期。 GDBL都是使用类似于OpenGL，Direct3D这样的框架让学生进行开发游戏。 GBL很少，所以作者认为在GBL的方面，还能有很多工作进行开展。 引用： González-Campos, J. S., Arnedo-Moreno, J., &amp; Sánchez-Navarro, J. (2018, April). The use of digital games to teaching computer graphics: An open opportunity. In 2018 IEEE Global Engineering Education Conference (EDUCON) (pp. 1988-1996). IEEE.","link":"/TheUseofDigitalGamestoTeachingComputerGraphic-Notes/"},{"title":"《旅行的艺术》 笔记","text":"作者：阿兰·德波顿 《旅行的艺术》的结构、内容笔记以及摘要 思维导图 结构笔记 这本书并非一本旅游指南，也没有细枝末节的分析旅行中的每一个过程，相较于旅行过程这本书实际更加关心的是旅行者的内心世界。阿兰·德波顿在每一节中都会将自己旅行的感受和福楼拜、波德莱尔、梵高、霍珀等艺术家的经历相结合，来讨论旅行中的一些因素对自己的影响和意义。 本书主题包括旅行的出发、过程和回归。其中旅行的过程又探讨了动机、风景和艺术这三部分旅行要素。 在出发这一部分中，作者首先讨论了对旅行的期待，对于旅行的期待很容易被艺术作品激发，如作者自己就因为一本《冬日艳阳》而前往了巴巴多斯岛。但是旅行的真实情况会与心中的期望存在较大的差异，一是因为激发我们的艺术作品会将真实生活中无聊和琐碎隐藏，它让我们错以为存在一个没有任何杂质的生活，二是因为旅行的过程会存在身体和心灵的干扰，导致我们无法对专注于旅程中的美。 之后作者提到了旅程中的一些特定地方，包括交通工具和路边的加油站和小餐馆等。这些地方都会让人有逃离生活的感觉。作者会在他不开心的时候会前往希思罗机场，那些飞离的飞机给他带来一种前往陌生生活的渴望。查尔斯·波德莱尔是一个充满了对生活之外地方渴望的诗人，他甚至于对旅途中的交通工具也充满了兴趣，作者认为这是因为交通工具存在一些象征性的含义，如飞机的迅疾上升存在着一种人生转机的暗示，空中的云朵则带来一种宁静等等。然后作者介绍了公路边的加油站和小餐馆这些给人带来孤独感觉的地方，霍珀的许多作品描述了这种孤独。但旅途中的这些场所的孤独与我们在都市热闹中感到的孤独比不相同，在这些地方人与人之间的隔阂是一种大家都心知肚明的存在，于是也就不存在热闹中置身度外的那种痛苦，反而是一种与周围人群强烈认同的感觉。在这一节的最后描述了火车和旅馆，火车上闪过的风景和旅馆中与家中不同的装饰都是一种变化的存在，让人摆脱以往的思维定势。总之旅行出发时的这些特定地方都已经带来了与平常生活不同的感受，给人们改变日常生活中陋习的可能。 在旅行过程的部分，首先谈到的是动机，这里主要描述了两种旅行的动机，追求异国情调和满足好奇心。 一些简单但充满异国情调的东西也会让我们感到快乐，因为这些东西表明了我们已经到了另一个地方，如之前所说的，远离了原先的生活。但有时异国情调所带来的快乐也有更深层的含义——那些物品所表达的正是本国求之不得的东西。作者着重用了福楼拜的例子来阐述这个问题，埃及的骆驼，喧闹的生活，“粗俗”的表达和行为反而让福楼拜感到快乐，因为他认为这些与他所厌恶的法国虚伪的资产阶级正好相反。这种因为与日常生活不同所造就的魅力也体现在异国的异性身上，他们所展现的一些我们自己不具备的个性会让人充满魅力。 但异国情调带来的魅力很可能随着时间而渐渐流逝，因为这种魅力本质上是出于我们逃避生活的一种狂热和幻想，我们错以为与原先生活的不同就是美好。但也有可能，这些狂热的魅力也会被更理性和现实的好感所替代，如同福楼拜在埃及生活9个月后，即使存在一些失望但仍然觉得埃及的生活满足他对东方最初的幻想。 然后是满足好奇心的问题，亚历山大·冯·洪堡在南美洲的探险是一种为了获得知识的好奇心满足，如地球磁场的分布，海拔对于植物的影响等。但这样的好奇心在当下已经不再实用，我们可以通过旅游指南之类的东西得到这些知识，于是这里作者提出了一种新的好奇心的追求，针对知识来提出自己的问题，并最终让自己的生活得到升华。但提出问题也并非一件易事，这需要旅客在先前有相关的知识积累。 旅行过程中风景是非常重要的因素，书中主要谈论的是乡村与城市和壮阔的风景。 乡村与城市会对人产生不同的影响，因为人会随着周围环境的人或物的转变而变化。大自然中一些景物会给人带来某种价值的能量，如橡树代表尊严，松树代表坚毅等。诗人华兹华斯坚定的认为大自然对于人存在积极向上的作用，在一开始人们并不相信他的理论，但随着时间的推移，人们开始相信了城市会造就人的焦虑和炫耀。18世纪的后期也迎来了城市居民涌向乡村的历史运动。 壮阔的风景也同样拥有对于人道德提升的作用。壮阔并不等同于美丽，只有景致表明了人类意志所不能左右的力量，体现了人类的脆弱和渺小称之为壮阔。壮阔的景色让人意识到一种人类意志无法对抗的存在，也因此人能坦然面对自己的缺憾。同时壮阔的景象也很容易让人联想到一些远比人类强大的力量，而这很容易与宗教联系在一起，如《旧约》中的《约伯记》就是把上帝与壮阔的力量所联系的一节。 艺术不仅影响在旅行出发时会引起人们的期待，也同样会扩大游客在旅行中的眼界。每一个大师都会在真实世界中选择他认为的突出品质，并将其通过艺术表达出来。如梵高描绘的普罗旺斯的柏树，莫奈的落日等等。正是这些作品让游客发现了风景的欣赏价值，18世纪前后，英国人民对本岛旅游的逐渐热衷也是因为相关事件点关于英国风景的作品逐渐的增多。 艺术还有一个作用就是可以让游客真正的拥有美。人们会用很多方式来试图拥有美，如照相、购买纪念品等等。但是约翰·罗斯金提出了用绘画拥有美，绘画并不是最终目的，更重要的是绘画时的观察，它迫使我们去观察美，并对美产生了判断，知道是什么造就了美。 书的最后作者谈到了旅途的终点——回归。我们应当如旅行般看待回归后的日常生活，梅伊斯特的《我的卧室之旅》一书就在探讨这个事。旅行的快乐并非来自于旅行本身而是旅行时的心境，如果我们能像旅行时一样用谦卑、好奇的态度看待平常生活，自然也会发现平常忽略的有趣的地方。 概念笔记及摘抄 出发 对旅行的期待 对于旅行的渴望很容易被激发，如作者期望前往巴巴多斯岛进行旅游，就仅是因为一本看了一本《冬日艳阳》。但在旅行的过程中我们会发现期望与现实往往存在较大的差异，这里作者举了于斯曼的《逆流》中的例子，《逆流》中的主人公德埃桑迪斯打算前往伦敦旅行，但在一家英式餐馆吃饭时，意识到对于一个地方的想象可能和实际情况之间存在令人沮丧的差异，于是便取消了旅行计划。 而这个的原因一是因为我们对于旅行的过多期待大多是由艺术作品引起的。艺术品常将生活中的琐碎与无聊省略，这造成人们对理想生活的期待，但真实世界却充满着重复、不着边际、没有条理的情节。回忆很美好的原因也在于回忆也会省略生活中不美好的部分。二是因为旅行无法如同期待一样美好还因为旅行时的身体和心灵的干扰。这里作者以自己在巴巴多斯岛旅游的经历作为例子，在巴巴多斯时会对旅行结束后的工作产生焦虑以及旅行过程中与旅伴的争斗造成了之后旅行的不愉快。 他说明了人生中许许多多的事件（甚至是整个人生）是如何为一些最简单、最经不起推敲的快乐图景所影响；而一次开销巨大，超出经济承受能力的旅程的起因又如何可能仅仅是因为瞥见了一张摄影照片 旅行还是很少迫使人去考虑一些超越实际、需要深层思索的哲学层面的问题。我们经常得到应该到何处旅行的劝告，但很少有人告诉我们为什么要到那个地方 期待和艺术的想象省略、压缩，甚至切割掉生活中无聊的时段，把我们的注意力直接导向生活中的精彩时分而毋须润饰或造假，结果是，它们所展现的生活气韵生动，井然有序。这种气韵和秩序是我们纷扰错乱的现实生活所不能呈现的。 旅行时，置身于真实的荷兰，我们的体验也因此奇怪而平淡，全然不及在卢浮宫的荷兰化作展厅里游览一个下午来得兴奋，因为在这几间展室里，收藏有荷兰和荷兰人生活中的最美好的方面。 我的身体和心灵是难缠的旅伴，难以欣赏这趟旅行之美 只有当我们不必亲临某地去面临额外的挑战，我们方能最自如地置身其中。 无论是赏心悦目的事物，还是实实在在的东西，我们从中获得幸福的关键似乎取决于这样一个事实，那就是我们必须首先满足自己情感或心理上的一些更为重要的需求，诸如对理解、爱、宣泄或尊重的需求。 旅行中的特定场所 这一节中作者用作家作家查尔斯·波德莱尔和画家爱德华·霍珀的作品来阐述旅行中的特定场所。查尔斯·波德莱尔是一个充满了对于生活之外地方的向往的人，他认为自己真正的愿望就是离开现在的地方，任何地方即可。类似的感情作者也同样拥有，作者在家不开心的时候，常会选择前往希思罗机场，那里的场景会让他产生对于全然陌生的地方的渴望。 波德莱尔期待的不仅仅是旅途起点和终点，如车站、码头、机场，他同样也羡慕哪些交通工具。这里作者认为这些交通工具和旅行过程中的场景会带来一些象征性的含义。如飞机的迅疾的上升是实现人生转机的极佳象征，所以飞机的起飞会带来心灵的愉悦。云朵带来的是一种宁静，因为我们恐惧和悲伤的来源，都被藏在了云朵的下方。 公路边的加油站和小餐馆给人孤独的感受，但在这些地方，孤独并不让人觉得难以忍受，因为周围的人也都彼此保持着距离，这与自己在热闹中无法融入的孤独是完全不同的。霍珀有许多的作品都展现了这种孤独，如《自动贩卖店》、《加油站》。这种孤独是温柔的，此时的孤独不是那种置身于欢笑和群闹中，让人意识到心境和环境之反差并觉得痛苦的那种孤独；它源于陌生的人群，在这里大家都明白，沟通的障碍客观存在，对爱的渴求也难以实现。 还有旅行过程中的火车和旅馆，在火车行进过程中看到一直在变化的风景有助于我们思考，而旅馆中与自己家不同的装饰则帮助我们摆脱思维定势。 这是一种常见的隔阂感，对任何独处者，这种感觉有助于减轻它们在孤独状态下的压抑感。在公路旁的小餐馆、午夜时分的自助餐厅、旅店的大堂和火车站的咖啡馆，我们可能不太能感觉到那种在偏僻的公共场所油然而生的孤独和疏离感、反倒重新发现一种同周围人群的强烈认同。……在这些地方，我们更容易摆脱心中的感伤——这种近乎避难所的装饰更能让我们放松 旅行，或者那种漫无目的的漂泊的过程，其价值在于它们能让我们体验情感上巨大的转变 18世纪以来，人类的同情和了解不再源自于社群活动，而是来自于人们的漂泊经验。因此一种基本的疏离、沉默和孤独已成为人性和社群的载体，对抗着普通社会阶层的苛严僵固、冷漠无情和自私自利的闲适。 ——雷蒙德·威廉斯《乡村和城市》 这些偏僻孤立的地方给我们提供了一种实实在在的场景，使我们能暂时摆脱因循僵滞的日常生活中难以改易的种种自私的安逸、种种陋习和拘囿 动机 异国情调 在到达一个新的地方旅游时，我们可能因为一些简单的但是却充满异国情调的东西感到快乐，因为这些东西表明我们已经到了另一个地方，远离了原先的生活。 有时我们在异国会因为一些非常细小的事物引发很强的感受，这是出于我们对于生活细节的关注。对于异国情调感到快乐，往往是因为这些事物表现出的一些东西，正是我们在本国苦求而不得的东西。如作者在阿姆斯特丹看到红色的大门与白色内墙的装饰，竟然产生出想居住于此的想法，其本质是因为这些建筑表现出的现代意识，而这与作者在伦敦看到的模仿古典的建筑风格表现出的封闭保守心态相反。 作者在这一节详细介绍了福楼拜在埃及旅游及生活时的例子。 福楼拜的一些想法与他所处的法国相悖，而他又对于东方文化存在向往，于是在1849年与朋友一起前往了埃及。 福楼拜在其著作《庸见词典》中对法国的资产阶级进行了强烈的讽刺，在他眼中法国的资产阶级是一个虚伪、势利且充满着歧视的社会阶级。在法国，他自身的想法与所处的社会存在分歧，而在埃及，他的观念及想法则能大行其道。 福楼拜认为生活的本质是混乱和喧嚣的，除了艺术作品，其他制造秩序的企图都是吹毛求疵和假正经。所以对于法国的建筑他认为有太多的矫饰和做作，而埃及生活的选校和颜色缤纷的建筑则让他喜欢不已。 福楼拜思想中有个核心就是，他认为人不仅仅是有思想的动物，同时也是需要拉屎撒尿的动物，需要把这种直率的理念纳入世界观。所以他有时会认为所处的时代有伪善和假正经，他常常用人类的种种不足来警策世人。但他发现埃及则是坦然的接受了生活的双重性（粪便-理智，纯洁-性欲等），在埃及人们可以不分性别，不计身份的交流，即使最有德行、最受尊敬的女性也能用最低级、最庸俗的交谈。 福楼拜认为骆驼是最让人心动的东西之一，他认为骆驼具有恬淡韧毅和朴拙单纯的天性，在静默中表现出勇毅和谦恭，而这正与法国中产阶层的傲慢天性相反。 在异域时，本地的人也会因为他所具有的异域情调让他更有魅力。如果爱是寻找与自身的不同，那么异域的人则正好满足了这个需求。福楼拜在埃及时也爱上了一个女子库丘克，而且终其一生也没有将其忘记。 我们对于异国他乡的好感来自于它与自己生活的不同之处，但最初抵达异国他乡时的美好只是我们逃避生活的一种狂热和幻想，随着时间的推移，这些美好可能会消散，也可能会以一种更理性、现实的好感替代。福楼拜在埃及生活9个月后对埃及有了正确的认识，与最初的幻想相比，失望肯定是有的，但他认为在埃及的生活仍然满足他最初对于东方的想象，并且扩展了当初的一些狭隘观念。 不管这些由异国的细小（和无声）的事物所引发的强烈反应看上去是多么荒谬，这情形至少同我们的私人生活有相通之处。……如果我们因注重这些细节的东西而自责，那么我们必将忽略生活中的细节本身所具有的丰富含义 就福楼拜而言，对东方的凝视能帮助他从自己的生活环境中解脱出来，暂时将那种富足却委琐的生活以及世俗的思维定势抛于脑后 在异域，一个有吸引力的人除了具有我们本国人所具有的魅力外，他所处的国度的异域情调也让他生辉不少。如果爱是寻求那些我们自身所不具备、却让我们所爱之人独有的个性魅力，那么，当我们和异域情人相爱时，我们更有理由期待自己融入一种我们自身文化所缺失的价值和观念之中. 这次见面只能让福楼拜愈发伤感：“无边的悲哀……这就是结局！我将再也不能见到她。记忆中她的容颜将慢慢消失”。事实上，这以后福楼拜终其一生都未忘记库丘克的容颜。 尽管福楼拜希望能摆脱他所认为的欧洲现代资产阶级的那种极端的愚蠢，但他发现，不管身处何地，这种愚蠢无时不伴随着他：“愚蠢是一种顽固的东西；如果你试图从你的生活中根除这种愚蠢，那么，你的生活也就随之毁掉了…… 他（福楼拜）对波伊特文说：“一个中产者也许会说，'你若去那里，你将会有强烈的幻灭感。'但我很少有幻觉，更少体验幻灭感。总有人给谎言以妆饰，还说一切的诗意都基于各类幻觉，这实在是一种愚蠢的滥调。 福楼拜：你问我，我所眼见的东方是否同原来的想象相符。是的，是相符的；而且超乎我的想象，这里的一切极大地扩展了我先前对东方的狭隘观念。以前对东方的一些模糊不清认识，现在都变得具体清晰起来。 好奇心 作者在这一节通过将自己在马德里的旅游经历与亚历山大·冯·洪堡在南美洲探险的经历做类比来讨论旅游时好奇心的问题。 好奇心首先是对于新事物的发现，如洪堡靠着新天文钟和六分仪重新绘制了南美洲的地图，研究了地球磁场，测量气温及海拔对植物的影响等，这些都是洪堡因为好奇心而去测量得到的对新事物的理解。但是对于在马德里的作者而言，并不存在什么新事物，一切的东西都已经被测量完成，只需要从旅游指南上获取即可。 好奇心也应当是针对知识提出自己的问题，一切知识应当让自己的生命得到升华。作者借尼采的表述提出了一种新的旅游方式：借历史建筑看到历史，再通过历史了解社会和身份的形成过程，让自己得到延续性和归属感。 这种新旅行方式是一种与个人息息相关的方式，但是现在的旅游指南会给个人带来一种无形的压力，因为它在潜移默化中迫使读者接受其权威性，而影响游客自己的判断。洪堡在南美洲探索时的自由，也正是因为欧洲人很少去南美洲，他者经验的缺失造就了洪堡好奇心的自由。 所以我们要意识到并尽量减少先入之见的指南对自己好奇心的影响。 最后作者探究了好奇心的由来，他以洪堡在秘鲁坎博拉索火山上对一个苍蝇产生浓厚兴趣的例子展开。洪堡在幼年时就对植物生长环境和气候地理如何影响动植物产生浓厚兴趣并进行过相关研究，所以在火山一万多英尺的高处见到苍蝇时，洪堡才会对此感到兴奋。 好奇是需要成长过程中通过无数小问题来积累的。大多数游客不会对景物产生质疑和欣喜正是因为我们在旅行前没有积累和具备所需要的知识积累。旅游景点的地理原因进一步加深了游客的这一问题，游客常会在一个地区接二连三的观赏一系列内核毫无相关的景物，如作者在马德里参观了18世纪的皇家宫殿后去了索菲亚王后艺术中心，而后者收藏的却是20世纪的艺术作品。如果是为了对18实际的皇家建筑风格有更深的了解，应当前往布拉格或圣彼得堡进行参观。 对于任何旅人来说，一个为求得真知而进行的旅程，远比一个四处观光之旅得到更多的好处。 尼采: 评判我所学的任何东西，都应以它是否让我受益为准则，而不是考虑它是否满足他人的利益。我对事物的发现应当让我更具活力：他们必须以某种方式使我“生命升华” 歌德：我厌恶所有那些只提供指示，却未能丰富或鼓动我活动的东西。 尼采：历史中总是一次又一次地出现一些对过往的伟大事物进行反思的人，他们从中获取力量，深深感受到人类生命的辉煌灿烂。 当旅游指南对一个旅游景点赞赏有加时，它无形中产生一股压力，迫使读者接受其权威性，缔造一股热忱，至于景点会使游客感受到沉默、幸福还是兴致勃勃，它则毫不关心。 好奇心像是由一些一连串向外拓展，并且有时延伸到深处的小问题所引起……如果环境和个人性情的发展得以配合，我们在成年的岁月中会继续探讨这些问题。人们的好奇心会涵盖更广阔的天地，最后达到什么都觉得新鲜、有趣的阶段。那些混沌的大问题便引出了更细微和深奥的问题。 惟有经历好奇心的漫长演化，看到沙巴提尼设计的具新古典形式外观的大教堂，才会觉得欣喜，而不会陷入无聊、沮丧。 洪堡:人们常说我同时对太多东西感兴趣，例如植物学、天文学和解剖比教学。但你果真能够抑制一个人的求知欲，不让他了解和拥抱周遭的一切吗？ 风景 乡村与城市 作者在因私事前往英格兰湖区，在前往乡村的旅途作者联想到了18世纪后期的城市居民涌向乡村的历史运动及一位描写乡村的诗人威廉·华兹华斯。在华兹华斯前，大自然很少收到诗人们的关注，而华兹华斯则认为大自然中的各种现象有助于矫正城市人的心灵。一开始华兹华斯的主张收到了大量的质疑，有人批评他是故作幼稚，但是随着时间的推移他的主张收到越来越多的支持，在1830年左右人们开始欣赏和赞扬华兹华斯的诗歌。华兹华斯认为城市造就了人的焦虑和炫耀，而仅有乡野可以对抗城市的不良影响。 作者之后以自身的思考和华兹华斯的观点探讨了为何大自然对都市生活有纠正作用。首先我们要认同的前提是，人会随着周围的人或物的转变而变化。而大自然的中一些景物则有提示我们某种价值的能力，如橡树象征尊严，松树象征坚毅，悬崖让人产生崇高的念头。 作者认为大自然能给人带来精神的慰藉，但是往往这样的慰藉只能持续几小时。但是华兹华斯却认为存在一种“凝固的时间点”，在大自然中看到的景象可以永远的留在我们记忆中，每当遇到困境时，这些记忆就会出现与困境形成对比，带给我们慰藉。作者也曾体验过这样的凝固时间点：在一天下午，作者被困在伦敦的交通堵塞中，而他突然涌现了湖区周围的一片森林的景象，驱散了他的焦虑。 以前，诗人不过是很随意或习惯性地看待自然现象，但是它们在华兹华斯笔下却成了最伟大的主题。 诗人解释说，大自然中的各种现象，包括小鸟、小溪、水仙和绵羊，都是不可或缺的，因为它们能矫正和治疗城市人备感困顿的心灵。 诗人谴责城市造成的一系列窒息生命的情感，包括对我们所处社会地位的焦虑，对他人成就的羡慕，以及在陌生人面前炫耀的欲望。他直言不讳地表示，城市人毫无主见，只限于在街边或饭桌上道听途说、人云亦云。虽然他们生活舒适，却从未放弃追逐新鲜事物，即使他们什么都不缺、而幸福也与他们想要追逐的东西无关。另外，想在这样拥挤而焦躁的生活圈子里与他人建立真诚的情谊，要比在一个孤立的居住环境还要困难。 华兹华斯说：大自然会指引我们从生命和彼此身上寻找“一切”存在着的美好和善良的东西”，自然是“美好意念的影像”，对于扭曲、不正常的都市生活有纠正的功能。 华兹华斯在信中几乎明确指出自然界所包含的价值。他说“一位伟大的诗人……应该在某种程度上纠正人们的思想感情……使他们的感情更健全、纯洁和永久，也就是与大自然产生共鸣、更加和谐。” 如果我们对这个时代或精英的价值观感到痛心，那么思及地球生命的丰富多彩，或许会让我们感到释然，让我们记住。这个世界除了大人物的事业，还有在原野鸣叫的草地鹨。 我的思绪被带离了繁忙的交通和拥挤的人群，回到了那些我叫不出名字、却非常清晰可见的树木面前。这些树木成了我思绪得以休息的避风港，它们保护着我，使我免于陷入焦虑的漩涡，并且在那个下午给了我一部分生存的理由。 壮阔 作者首先探讨了壮阔的定义，壮阔一词来自于希腊作家隆基努斯的一篇名为《论壮阔》的论文。壮阔一词是用来形容那些雄壮、空旷或险峻的并能给人带来美好而充满道德的感觉的风景。 作者为了体验到自己的渺小而前往了西奈南部的沙漠，沙漠中四亿年前形成的幽谷，2300米高的花岗岩山，让作者陶醉，但也让他感到人在面对宇宙的力量和迭代时，是多么的脆弱和渺小。 英国政治家埃蒙德·伯克在他《关于壮阔和美丽理念之源的哲学探究》一书中谈到，景色的壮阔往往和感觉的脆弱有关。壮阔并不是美丽，一个景致只有让人感受到大于人类，甚至是威胁人类的力量才是壮阔，壮阔表现了人类意志说不能左右的力量。而类似于春天的草原，城市的河畔，柔美的山谷只能是美丽，而称不上壮阔。 之后作者探究了为什么人会去追求那些壮阔的场景。比我们强大的东西可能会引发我们的憎恨，也可能引起我们的敬畏，而这取决于那个东西是否具有尊贵的风度。强大却卑劣的东西会让人觉得被羞辱，而强大且尊贵之物则让人敬畏。如我们视食人鱼的力量为邪恶且充满掠夺性，而把野牛的力量看作坦率而正大光明。 那些壮阔而崇高的东西给了我们一种面对自己不足的方法，即坦然面对那些缺憾。壮阔的景象能让我们意识到一些事物是人类意志所无法对抗的，只能臣服。 最后作者提到了壮阔往往会和宗教联系到一起。壮阔的景象很容易让人联想到他是由一个远比人类强大的人所建造。西方人被壮阔景色吸引的时候正好是传统的上帝信仰式微的时候，壮阔的场景让人和宗教中超然的力量保持感情上的联系。在《旧约》中的《约伯记》是把上帝和壮阔联系最具体的一个章节，约伯心地善良从未作恶，但却落到了家庭破灭，倾家荡产且身怀重病的地步，约伯对于自己的命运感到疑惑。上帝却将他的注意力引向类似于雷电、暴雨等自然现象，告诉他发生事与愿违时不要惊讶，因为人根本不能彻底理解宇宙的逻辑。 “当我想到……我占有的这个小小的空间正要被无垠的空间吞噬，然而对无垠的空间，我一无所知，连空间也不知道我的存在，这个念头让我惊恐，我也惊讶于自己出现在此空间而非彼空间：我有什么理由出现在此地而非彼地，有什么理由出现在此时而非彼时？是谁让我置身于此？”——帕斯卡尔《沉思录》 这里的山和山谷让人很自然地联想到，这个地球是由人类双手以外的东西建构的，他的力量比我们所有人力量的总和还要强大。 这个世界对约伯而言可能缺乏逻辑性，但是这不表示师姐本身缺乏逻辑。我们不能用自己的人生去衡量一切，而应该通过壮阔的景致提醒我们人类的渺小和脆弱。 壮阔景观的雄伟和力量有其象征意义。那就是：让我们无怨无悔地接受那些无法跨越的转改，以及无法理解的事件。 如果我们用更长的时间与它们相伴，他们会帮助我们心服口服地接受那些无法理解而又令人苦恼的事情，并接受我们终将化为尘土这一事实。 艺术 令人眼界大开的艺术 作者在普罗旺斯的旅行中发现并没有像梵高作品中那样充满魅力的景致，人在看到风景后的就会迅速的产生感受，这个感受很难被改变，但是提高审美能力可以让我们发现一些被忽视的地方，发现风景的欣赏价值，而艺术是最能提升我们欣赏风景能力的方法。 作者之后举了梵高的例子来说明了艺术的本质，梵高在35岁时前往普罗旺斯的阿尔勒小镇，一是为了画南方的风景，二是希望别人可以通过自己的作品“看到南方”。梵高相信可以通过艺术来让人大开眼界，看到更广阔的世界是因为梵高自己也从之前大师中感受到了这种艺术的力量，莫奈让他了解了落日，伦勃朗让他了解了晨光，维米尔让他知道了阿尔勒镇的少女。 之所以人们可以从大师的作品中看到其他事物，是因为每一个现实主义的作品都代表了作者本身的选择，画家从真实世界中选择他所认为的突出品质并通过画笔表现出来。我们有的时候批评画家的话不像，也是因为画家做出的选择与我们认知中想要突出的品质并不符合。这里作者举了梵高的例子，有人说梵高的柏树、房子、太阳、星空等太过夸张，但这实际上是梵高选择了自己觉得最重要的东西来表达，梵高所追求的像并不等同于摄影师，更多的是一个事物的真实想法，如同诗人在描述一个事物时可能比严谨的急着更能找到事情的真相。 艺术的这个能力逐渐影响了旅行，18世纪前，英国的风景很少出现在艺术作品中，而在之后类似的作品渐渐的多了起来也让英国人民更原意游历他们自己本岛的情形。 衡量每一个杰出画家的标志就是他们是否能够让我们更加清楚地看到世界的某些部分。 世界是如此复杂并足以使两幅描绘同一个地方的现实主义作品因艺术家风格和气质的不同，而呈现出完全不同的景象。 在惠斯勒画出伦敦的雾之前，伦敦并没有雾。在凡·高画出普罗旺斯的柏树以前，普罗旺斯的柏树一定也少得多。——王尔德 凡·高向他妹妹解释的“夜晚甚至比白天更加色彩斑斓……只有你注意着它，你才会看到有些星星是淡黄色的，其他的星星有一种粉红色的光芒，或者泛着绿色、蓝色，和勿忘我的光辉。不用说，只有在蓝黑背景上放置白色的小点，显然是不够的。 凡·高告诉他弟弟，他追求的“像”不同于虔诚的摄影师所追求的逼真。他所关注现实中的那一部分，有的时候需要加以扭曲、省略或者更换颜色，方能在画面上表现出来，但是依旧使他感兴趣的是真实——“相似性”。他愿意牺牲一种幼稚的现实主义来成就一种更加深刻的现实主义。 绘画是多么地虚伪，它使我们不在赞美事物本身，而兴奋地赞美绘画所表现出来的与事物的相似性。——沉思录 如果这些画家是精确地再现他们眼前的图景，那么在一幅画中我们将要赞叹的对象便只是画家的技巧和他本人的声名了。这样说来，或许帕斯卡尔说的绘画无用论确实没错。但是，如同尼采所言，画家并不单纯地再现，他们有所选择，有所强调，同时他们还致力于表现他们眼中的真实，因而值得让人真心喝彩。 只有那些世界的角落已经被艺术家们描画或描写之后，我们才会有兴趣去探索它们。 对美的拥有 我们对于许多的地方都只是走马观花，但还是有些地方会给我们带来震撼，迫使我们去注意他们，这些地方的特色笼统来说，可以用“美”来概括。对于美我们总有一种想要占有成为生命一部分的渴望。拍照是常见的方法，还有人会用买一些纪念品的方式。而约翰·罗斯金提出了一种不同的方法。 罗斯金医生都在用一种不是为了娱乐消遣而是为了美的方法进行旅行，他一天旅行不超过50英里，并且每隔几英里就停下来观赏风景。对于美，罗斯金提出了5个重要结论 美是由许多复杂因素组合而成，对人的心灵和视觉产生冲击。 人有一种与生俱来的倾向，对美作出反应并渴望拥有美 对拥有美比较低级的表现就是渴望买纪念品或者拍照等。 高级点的拥有美的方式，就是理解美并理解自己敏感与哪些促成美的因素。 对于追求高级拥有美方式的最有效方法就是通过艺术，如书写和绘画，这并不考虑我们是有具有这样的才华。 罗斯金在伦敦工人学院教人绘画时表达他并不是希望把工匠变成艺术家，而是希望绘画让他们成为快乐的工匠。绘画让人去关注事物而不是走马观花，这种观察就会让人对美的组成有深刻理解，进而获得对于美的深刻记忆。 罗斯金认为技术只是让人更容易的接触美，但没有让拥有美和欣赏美变得简单。现在人使用相机并不是把它作为观察的补充，而是作为替代品，认为只要有一张相片即可。真正的对美的拥有，是要注意到它的各种原色和了解他们的结构，在绘画时我们就会意识到自己先前对于事物时多么地无知。而且绘画也能让人有基本的审美能力，能对美和丑进行判断，从简单的“我喜欢……”变为“我喜欢……因为……”。 语言与绘画类似，极致的景致往往让人意识到语言的贫乏。作者在给湖区朋友的明信片上，简单的形容“这片湖很美”但其实我们更应该问自己并回答，“这片湖美在哪里，为什么如此吸引人”。只有这样我们才能更接近于“为什么一个场景可以打动我们”这种问题的答案。 罗斯金：现在，请记住，绅士们，我并没有试图教你们画，只是教你们去观察。 罗斯金：我们在旅行时，如果我们放弃每小时走100英里，从从容容地行走，我们或许会变得健康些、快乐些或明智些。世界之大，远超过我们的眼界可以容纳的范围，不管人们走得多慢；走得快，他们也不会看到更多。真正正规的东西是所思和所见，不是速度。 罗斯金曾经提及说这种爱源于一种渴望。“不为名声，不为服务于别人，也不为自己，而是来自一种像吃或喝一样的本能。”而绘画、吃饭、喝水这三件事之所以可以相提并论，是因为他们全部涉及自己从这个师姐吸收好的元素，把好的东西输进来。 罗斯金：我相信视觉比绘画来得重要；我宁可教我的学生绘画，从而让他们学会热爱自然，而不会教他们盯着自然，从而让他们学会绘画。 回归 习惯 作者在这一节通过梅伊斯特的文章叙述了如何我们在日常的生活中获得如旅行般的快乐。 作者觉得在旅行结束后返回冷漠的伦敦让他绝望。塞维尔·德·梅伊斯特曾写过一篇《我的卧室之旅》的文章教人如何在日常生活中找寻快乐，他用旅人的眼光去注视沙发和床，去欣赏房间内的家具。梅伊斯特认为，旅行中获得的快来更多取决于旅行时的心境而不是旅行本身。而感受力是旅行心境最重要的特征，需要有谦卑的态度去接近新的地方，对有趣东西的判断，不带有任何的成见。在刚到新地方时，我们的敏感性会带领我们注意很多东西，在之后我们注意的东西就会越来越少。 独自旅行也有助于感受力的提升。在多人一起旅行时，我们很大程度上收到了周围人的影响，我们会想让自己看起来正常，这样我们就无法去关注那些细小但自己感到有趣的事物，我们需要调整自己的状态，而这便影响了求知欲。 冯·洪堡在他的自传体笔记中写到他旅游的动机是从无聊的生活转向一个奇妙的世界。洪堡的遥远世界是指南美洲，而梅伊斯特为这两个世界划分了新的接线，他认为故乡也能提供有趣的东西。多年后读到梅伊斯特著作的尼采也给出了相同的观念，他认为只有少数的人可以化腐朽为神奇，在平淡无奇的日常生活中使自己成长。 人类不快乐的惟一原因是他不知道如何安静地待在他的房间里。——帕斯卡尔《沉思录》 大家都习惯了，认为这个世界本身就很无聊——于是，生活正如他们所预期的一样无趣。 洪堡：我被一种不确定的渴望所激励，这种渴望就是从一种令人厌倦的日常生活转向一个奇妙的世界 尼采：有些人知道如何利用他们的日常生活中平淡无奇的经验，使自己成为沃土，在这片沃土上每年能结出三次果实，而其他一些人（为数众多）则只会逐命运之流，逐时代和国家变化之流，就像一个软木塞一样在上面漂来漂去。当我们观察到这一切后，我们会把人分为两类：一种人可以化腐朽为神奇，另一种人则是化神奇为腐朽，绝大部分人是后者，前者则为数寥寥。 我们遇见过许多穿越沙漠的人，在冰上漂泊或在丛林里穿越的人，然而他们的灵魂里，我们无法找寻到他们所见的痕迹……让我们在前往远方之前，先关注一下我们已经看到的东西。","link":"/TheArtOfTravelNotes/"},{"title":"V2Ray  翻墙教程","text":"简单介绍V2Ray以及如何通过V2Ray搭建梯子。 SS及SSR因为其易用性和使用人数的广泛，已经逐渐被GFW识别。但最近我和我的朋友搭建的SSR都相继因为IP被禁而无法使用。我可以理解而且在一定程度上也是支持GFW的存在，但在一些情况下也不得不需要绕过GFW来找寻一些工作中需要的资料。这篇教程也是为那些同样有迫切需要的人而写，技术无罪，但切不可利用技术行恶。 V2Ray概述 V2Ray是ProjectV下的一个工具。ProjectV是一个帮助打造专属基础网络通信的工具集合，V2Ray是其中最核心的一个工具，主要负责网络协议和功能的实现，目前最多的使用场景就是使用特殊的网络协议来绕开GFW的深度包检测进而实现翻墙的目的。 V2Ray搭建 V2Ray服务端安装 使用V2Ray搭梯子同样需要购买VPS及使用SSH登录VPS进行配置，这一部分在之前的ShadowsocksR 翻墙教程已经做了说明，这里就不重复介绍了。需要注意的一点是，为了避免安装过程中出现command not found等问题，建议使用Debian 8.x以上或Ubantu 16.04以上的版本操作系统，我个人使用的是Ubuntu 18.04 x86_64操作系统。 如果出现SSH无法登录购买的VPS服务器，可能是VPS的IP被封，可以通过网址ping.pe进行检测，在输入要检测的VPSIP地址后，该网站可以从全球不同的节点去访问该地址，如果国内的节点丢包率都在100%，则说明该IP已经被封。如果是在搬瓦工上购买的VPS，可以在https://bwh88.net/ipchange.php网站上进行付费的更换IP服务，目前价格是8美元左右。 在windows环境下因为WSL的加入，可以不下载XShell直接进行连接，使用命令 ssh root@&lt;ip&gt; -p &lt;port&gt;即可 因为V2Ray的验证方式包含时间，客户端及服务端的时间误差必须在90秒内，这个时间误差是考虑了时区问题的，比如客户端位于东八区，时间为23点20分，服务端位于西四区，时间为11点20分，虽然绝对时间不同，但是这是因为时区造成的，实际两者不存在误差，即可以正常运行。 在成功通过SSH连接到VPS后可以通过date -R命令检查服务端（VPS）的时间及时区，如果结果存在问题，可以使用date --set命令来修改时间，如sudo date --set=&quot;2017-01-22 16:16:23&quot;。 客户端的时间即为终端电脑或手机的时间，这里就不说明修改时间的方式了。 检查完时间后，通过运行wget https://install.direct/go.sh命令下载V2Ray安装脚本。 下载完成后，通过命令sudo bash go.sh运行脚本 安装后会有如上图的结果，其中PORT和UUID两项（即图中马赛克部分）需要记录下来，在之后客户端的配置中需要用到。 在安装后,V2Ray并不会自动启动，我们还需要通过命令sudo systemctl start v2ray手动启动V2Ray。如果运行语句后无任何信息输出及表面v2ray启动成功。 如果以后需要更新V2Ray，再次运行安装命令sudo bash go.sh即可，这样会在保留配置文件的情况下更新V2Ray并重新启动。 可以使用命令cat /etc/v2ray/config.json来查看服务器端V2Ray的配置，后续章节会说明V2Ray的配置文件。 V2Ray服务器加速 安装了服务器后可安装锐速加速算法： 1wget –N —no–check–certificate https://raw.githubusercontent.com/91yun/serverspeeder/master/serverspeeder-all.sh &amp;&amp; bash serverspeeder-all.sh V2Ray客户端安装 安卓版本 下载V2RayNG软件,Google商店可以搜索到，或者在工程发布地址下载app-universal-release.apk并进行安装。 软件安装成功后，点击右上角加号并选择手动输入Vmess，然后将服务器的地址，以及之前服务器安装成后，显示的PORT和UUID分别填入端口和用户ID两个选项中，加密方式选择为Auto即可。 Windows版本 在V2RayN工程发布地址分别下载v2rayN-Core和v2rayN压缩包，并将其解压到一个目录下。 v2rayN-Core官方发布地址为https://github.com/v2ray/v2ray-core/releases 之后在解压目录中找到v2rayN文件，并双击运行，在界面左上角选择服务器-添加VMess服务器并如上述安卓版本一样，将对应信息填入。服务器添加完成后，双击运行。为方便运行可以在系统右下角的折叠栏中找到V2Ray图标，右键并选择启用HTTP代理，并将HTTP代理模式选择为全局代理。 之后的教程中将会说明全局代理与PAC区别，以及介绍Chrome插件SwitchyOmega的使用。 MAC及IOS版本 因为我并没有苹果设备，所以这两个版本未进行过验证。但搜寻下来，普遍推荐MAC上使用V2RayX软件，IOS上使用Shadowrocket软件。两者都要注意在添加服务器时需要选择VMess类型，剩下的就是服务器地址，端口，ID的填写，这个与安卓与Windows版本并无差异，这里就不详细说明了。 V2Ray官方版本并没有一个可视化的UI界面，以上推荐的软件都是针对V2Ray官方提供的v2ray-core项目的外部封装。我们可以在v2ray-core项目地址上下载该版本，下载对应的压缩包并解压后，在目录下的config.json填写入相应的参数，并运行v2ray.exe即完成了客户端的运行。但对于绝大部分用户来说仍然更熟悉可视化界面，所以我在这里还是推荐了不同平台上对应的第三方软件。 V2Ray基本原理 至此，V2Ray的配置已经结束，之后的内容是对于V2Ray工作原理的一个基本说明。因为我也是这几天在SSR被封禁后才查询了一些V2Ray相关的资料，所以这里也只是将我自己对V2Ray原理的一些理解写出，如果要探究细节问题话，建议查看文末引用部分的官方文档。 V2Ray连接通路 在前面V2Ray搭建章节，我们将V2Ray分为两个部分——客户端及服务端，其实严格意义上，V2Ray并没有服务端与客户端的概念。每个V2Ray进程可以看作一个盒子，每个盒子存在至少一个入口(Inbounds)以及最少一个出口(Outbounds)，整个V2Ray的工作原理实际上就是多个盒子串联起来形成一个连接通路。如果我们用服务端及客户端的概念来看我们分别运行在VPS上的V2Ray以及运行在电脑上的V2Ray（或安卓等终端），那么连接通路就是： 游览器&lt;—&gt;客户端inbound&lt;—&gt;客户端outbound&lt;—&gt;服务端inbound&lt;—&gt;服务端outbound&lt;—&gt;目标网站 所以我们并不需要为每一个终端设置一个对应的VPS上的V2Ray，因为这些终端设备的切换只是更改了客户端这一个盒子，而服务端并不关心客户端是什么，只需要客户端能有正确的inbounds和outbounds即可。 每一个V2Ray进程都需要一个配置文件来指定需要的参数，其中最重要的参数便是Inbounds和Outbounds。下面会针对这个配置文件进行一些说明，为了简化阐述，我们将运行在PC上的V2Ray看作是客户端，运行在VPS上的V2Ray看作是服务端。 客户端配置文件 在客户端的配置文件为安装目录下的文件config.json，文件是以json格式进行编写。这里不会详细的去分析客户端配置文件的每一行，我们目前只关注于inbounds和outbounds，我也不会对每个字段都进行分析。如果需要了解每一部分的每一个字段，可以查询v2ray的官方文档中配置文件这一章节。 首先看inbounds，以下是我自己的客户端的配置文件中的inbounds部分。 123456789101112131415161718192021&quot;inbounds&quot;: [ { &quot;port&quot;: 10808, &quot;listen&quot;: &quot;127.0.0.1&quot;, &quot;protocol&quot;: &quot;socks&quot;, &quot;sniffing&quot;: { &quot;enabled&quot;: true, &quot;destOverride&quot;: [ &quot;http&quot;, &quot;tls&quot; ] }, &quot;settings&quot;: { &quot;auth&quot;: &quot;noauth&quot;, &quot;udp&quot;: true, &quot;ip&quot;: null, &quot;clients&quot;: null }, &quot;streamSettings&quot;: null } ] 可以看到inbounds字段包含一个数组，在当前的配置文件中，数组中只有一个元素(仅有一个大括号)，官网中将inbounds中的每一个元素定义为InboundObject。这里也对应了之前所说的，一个v2Ray进程可以有多个inbound，同理也可以有多个outbound。在有多个bound的情况下，可以使用routing字段来设定选择的规则，在未设定该字段时，默认以第一个bound进行运作，之后的章节会简单说明下routing字段。 这里的配置文件所想表达的就是：从127.0.0.1（listen）地址的10808端口(port字段)以socks协议(protocol字段)从上一级（在本例中为游览器）接受数据。（如果在V2RayN等软件中设置为全局模式，则实际上是监听所有端口） 关于不同协议的设置都放在settings字段中,根据协议的不同settings中的字段格式也会不同，这里就不对每个协议进行说明了。 sniffing和streanSetting分别代表探测流量类型的设置和底层传输配置,因为这两个部分修改的比较少，我也没做研究。还是那句话，有需要看官方文档。 然后是outbounds部分，outbounds也同样是数组结构，其中每一个元素称为OutboundObject，这里因为篇幅关系，我仅黏贴了第一个OutboundObject 1234567891011121314151617181920212223242526272829303132&quot;outbounds&quot;: [ { &quot;tag&quot;: &quot;proxy&quot;, &quot;protocol&quot;: &quot;vmess&quot;, &quot;settings&quot;: { &quot;vnext&quot;: [ { &quot;address&quot;: &quot;67.216.197.176&quot;, &quot;port&quot;: 27533, &quot;users&quot;: [ { &quot;id&quot;: &quot;25585281-69bd-4b72-9239-303bee11f555&quot;, &quot;alterId&quot;: 64, &quot;email&quot;: &quot;t@t.tt&quot;, &quot;security&quot;: &quot;auto&quot; } ] } ], &quot;servers&quot;: null, &quot;response&quot;: null }, &quot;streamSettings&quot;: { //因为篇幅省略了该部分 }, &quot;mux&quot;: { &quot;enabled&quot;: true } }, { //另一个outboundObject } 可以看到这里用的协议就是vmess协议，这就是V2Ray与SSR最大的区别，SSR用的协议是Shodowsocks。这里settings字段中的设置就是针对于vmess协议的了，我们可以看到需要填写服务端的地址，端口及id，这里就是之前我们在配置客户端中需要填写的数据，我们在UI中添加服务器时，软件实际上就是修改了安装目录下的这个文件。 这个OutboundObject实际表达的意思为：将从Inbound中获取到的数据，以vmess协议发送给67.216.97.176地址的27533端口，在vmess中以25585281-69bd-4b72-9239-303bee11f555作为ID进行加密。 其他的字段含义同样可以在官方文档中找寻到，这里就不详细说明了。 服务端配置文件 服务器的上配置文件地址为/etc/v2ray/config.json，我们可以在Xshell中通过cat命令进行查看，如果需要则可以使用vi命令进行修改，在修改完成后可以使用v2ray提供的test命令来检查配置文件的语法和格式是否正常（不包含连接性问题的检查）。 123cat /etc/v2ray/config.jsonvi /etc/v2ray/config.json/usr/bin/v2ray/v2ray -test -config /etc/v2ray/config.json 还是以我自己的服务端(地址为67.216.197.176)配置文件为例，首先我们看inbounds部分 12345678910111213&quot;inbounds&quot;: [{ &quot;port&quot;: 27533, &quot;protocol&quot;: &quot;vmess&quot;, &quot;settings&quot;: { &quot;clients&quot;: [ { &quot;id&quot;: &quot;25585281-69bd-4b72-9239-303bee11f555&quot;, &quot;level&quot;: 1, &quot;alterId&quot;: 64 } ] }}], 如上所述，Inbounds是从上一级接受数据，这里的上一级就是我们的客户端V2Ray。客户端V2Ray的outbounds协议为vmess，所以这里对应的inbounds协议为vmess，同理id，端口也要一一对应。 然后再看outbounds部分 1234&quot;outbounds&quot;: [{ &quot;protocol&quot;: &quot;freedom&quot;, &quot;settings&quot;: {}} 这里的协议为freedom，即直接发送给下一级，在本例子中为目标网址。 综上整个连接通路的详细流程为：游览器通过socks协议将数据发送给客户端，客户端用Vmess协议将数据加密并传出，服务端用Vmess协议接受数据并解密，服务端直接用解密后的数据访问目标网站。正是因为客户端在传出数据时进行了加密，所以可以躲避GFW的深度包检测，当数据成功传递给服务端时，只要将数据进行解密，就可以正常的浏览目标网站。 V2Ray路由选择 前面可以注意到在一些OutboundObject中有字段tag，这个字段就是供选择时区分不同的Object。选择的规则是在routing字段中进行设定，这里我们还是通过一个例子进行说明 123456789&quot;routing&quot;: { &quot;domainStrategy&quot;: &quot;IPOnDemand&quot;, &quot;rules&quot;: [ { &quot;type&quot;: &quot;field&quot;, &quot;outboundTag&quot;: &quot;direct&quot;, &quot;domain&quot;: [&quot;geosite:cn&quot;] // 中国大陆主流网站的域名 }, ]} domainStrategy字段表示选择时的策略，当前的IPOnDemand表示如果有任何基于IP的规则，则立即以这些规则进行匹配。rules字段则是匹配的具体规则，注意这个字段也是个数组，我们可以指定多个规则。 规则中的type变量目前只有field这一个参数，所以也就不需要纠结。domain字段表示以域名进行匹配，例子中满足匹配的条件是中国大陆主流网站的域名。outboundTag则表示如果匹配成功，则选择tag为direct的OutboundObject。 关于匹配的其他规则如何写，如按IP进行匹配等，可以看官网上路由配置这一章节。 V2Ray官网 https://v2ray.com/ V2Ray白话教程 https://toutyrater.github.io/","link":"/V2RayTutorial/"},{"title":"Git 子模块 Submodule 教程","text":"介绍git submodule的使用与可能遇到的问题。 很久没有更新博客，打开一看发现awesome的图标都无法显示了，版本回滚后仍然无法显示，估计是nexT更新导致的，查看后发现的确nexT更新了大版本。 但是原始工程在家里的台式机上，发现笔记本从github上拉下的工程并没有将nexT作为一个git仓库，于是只能将整个文件夹删除后进行覆盖更新。 但这样的方式肯定是不能长久维护的，于是想将nexT作为项目的子模块进行管理。在这里我整理了使用git submodule对项目进行子模块管理的方法和常见问题。 git命令 添加子模块 如需要将远程项目xuejiaW/hexo-theme-next作为子模块，并且下载到目录themes/next下，则运行命令 1git submodule add git@github.com:xuejiaW/hexo-theme-next.git themes/next 然后可以看到目录下出现了.gitmodules文件，其中记录了子模块保持地址及Url 123[submodule &quot;themes/next&quot;] path = themes/next url = git@github.com:xuejiaW/hexo-theme-next.git 查看子模块 12345git submodule//可以看到类似结果//733d8e492aafe21abc971f853aa9e7b8b6196425 themes/next (v7.4.0-13-g733d8e4)//表示子模块最新的patch及子模块保存地址 初始化及更新子模块 12345git submodule init//初始化本地的子模块配置文件，在拉取了一个带有子模块的工程后，需要先执行initgit submodule update//更新子模块（如子模块文件夹为空，则会下载子模块） 提交子模块修改 当子模块有修改时，在主项目上git status并不会完全显示修改的文件，只会显示被修改的子文件夹，如 1modified: themes/next (modified content) 然后需要进入子模块进行常规的add，commit等操作，将子模块的改动提交 123cd themes/nextgit add --agit commit -s -m&quot;Modify submodule&quot; 在子模块提交时，请确认分支是否正确，否则可能会造成提交到远程仓库的commit ID不符，导致其他工程开发者在运行git submodule update时出错 此时回到主工程，再次status查看 12345cd ../../git status...modified: themes/next (new commits) 用diff语句查看改动，可以看到改动的是子模块最新的commit ID，这可以理解为主工程保留了每个子模块最新的commit ID指针，当运行git submodule update时，就是将每个子模块更新至各自最新的commit ID 12345git diff themes/next...-Subproject commit 733d8e492aafe21abc971f853aa9e7b8b6196425+Subproject commit 1da46ea43f2084eb2be519162b8d9ccb8d45e660 将这个改动提交，那么远程仓库也就更新了子模块的最新指针。 删除子模块 删除子模块相比于之前的操作要复杂些 删除.gitmodules中的子模块内容 删除.git/config中的子模块内容 删除.git/modules中的子模块对应文件夹 运行git rm --cached -r themes/next删除对应子模块文件夹的索引 删除子模块文件夹 常见问题 xxx already exists in the index 出现在git submodule add时，说明同一文件夹路径下有其他子模块。如果已经手动删除，错误仍然存在，可能是路径索引导致，需要完整执行删除子模块操作。 server does not allow request for unadvertised object 出现在git submodule update时，说明主工程中保持的最新的子模块commit id，无法在服务器子模块工程中找到，可能是因为子模块改动未提交，或者提交分支错误导致commit id改变。 引用： Git 工具 - 子模块 https://git-scm.com/book/zh/v1/Git-工具-子模块 Git submodule 子模块的管理和使用 https://www.jianshu.com/p/9000cd49822c","link":"/gitSubmoduleTutorial/"},{"title":"VR UI设计规范","text":"Google I/O 2017，DayDream团队提出的UI设计规范。 dmm概念 在VR的设计中，UI物体会因为距离用户的远近距离不同导致视觉上大小的变化。对于设计师而言，他们只能针对2D画面进行设计，而无法给出UI距离用户的距离，所以在游戏引擎中很难将UI调至设计师希望的样子。 我们可以用角度来解决这个问题，不同距离不同大小的物体，只要他们在视线内所占的角度是相同的，那么对于人眼来说，他们看起来就是相同的大小。如下图所示： 上图左上角的dmm单位就是DayDream团队提出的用以解决这问题的单位，dmm(distance-independent millimeter，距离不相关毫米)，我们将1米外看起来长为1毫米的长度定义为1dmm，按定义可知2m外看起来为2mm的长度也为1dmm。在2D设计软件中，我们将软件中的1px看作为1mm。这样当设计师给出一张480*320像素的图片，这张图的含义即为在1米外看起来长480毫米，高320毫米的图片。 文字最小尺寸 一个文字看的是否清楚取决于用了多少像素的去渲染这个文字。在这里首先解释下PPD（Pixel Per Degree）的概念，在VR设备中我们用一块屏幕来显示一定宽度视场角的内容，如HTV Vive的双眼分辨率为2160*1200，单眼分辨率为1080*1200，视场角为110°，则HTV vive的PPD为1080/110约为9.8即1°的画面平均含有9.8个像素。在PPD越低的设备上，我们要保证一个文字足够清晰就需要扩大文字在设备中所占的角度来确保它有足够的像素。DayDream团队给出的文字所占角度与设备PPD关系的图如下： 以设备PPD为12.6进行计算， 则文字需要有1.6°的高度，也就是文字需要有12.6*1.6=20.16个屏幕上的像素进行渲染。如果使用dmm而非像素来进行统计的话，可以使用公式 $2\\tan(\\frac{angle}{2})*1000$ 来进行计算。如这里需要角度为1.6°，则结果为 $2\\tan(\\frac{1.6}{2})*1000=27.9$ dmm，即在2D设计软件中需要用28个像素来表示，也就是28号字体，对于3D场景来说则是28毫米。 Unity中使用 Unity中Scale为1表示为1米 建立一个Demo场景，首先存在根物体ParentUI，Z轴值为1，表示距离我们1米远，Scale为1 在ParentUI下有个带有Canvas组件的物体Canvas Menu,它的Scale为0.001，这是因为在dmm概念中所有的计算单位都是毫米，所以我们需要将米转换为毫米。 这样在Canvas Menu下的所有UI组件都可以按设计图给的尺寸调整大小，如一张图片大小为400*320，在Unity中我们就将其Width,Height设为400,320。 当我们需要将UI放的更远，而保持UI大小不变的话，整体调整ParentUI的Scale即可，如 其他 UI的中心水平应该在水平线下6°左右 人保持头不动时，理想的视线范围是左右30°以内，带上颈部旋转的话，理性范围是左右60°以内 引用： Google I/O 视频 Google Design Sticker Sheet 如何 VR 界面设计规范与实操","link":"/VRUIDesignGuideLine/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","link":"/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"3D数学","slug":"3D数学","link":"/tags/3D%E6%95%B0%E5%AD%A6/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"论文笔记","slug":"论文笔记","link":"/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"},{"name":"游戏设计","slug":"游戏设计","link":"/tags/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/"},{"name":"计算机网络","slug":"计算机网络","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"博文笔记","slug":"博文笔记","link":"/tags/%E5%8D%9A%E6%96%87%E7%AC%94%E8%AE%B0/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"数据结构与算法","slug":"数据结构与算法","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"图形学","slug":"图形学","link":"/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"OpenGL","slug":"OpenGL","link":"/tags/OpenGL/"},{"name":"标记语言","slug":"标记语言","link":"/tags/%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/"},{"name":"效率提升","slug":"效率提升","link":"/tags/%E6%95%88%E7%8E%87%E6%8F%90%E5%8D%87/"},{"name":"翻墙梯子","slug":"翻墙梯子","link":"/tags/%E7%BF%BB%E5%A2%99%E6%A2%AF%E5%AD%90/"},{"name":"软件推荐","slug":"软件推荐","link":"/tags/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"虚拟现实","slug":"虚拟现实","link":"/tags/%E8%99%9A%E6%8B%9F%E7%8E%B0%E5%AE%9E/"}],"categories":[{"name":"读书笔记","slug":"读书笔记","link":"/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"图形学","slug":"读书笔记/图形学","link":"/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"计算机语言","slug":"读书笔记/计算机语言","link":"/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/"},{"name":"论文笔记","slug":"论文笔记","link":"/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"},{"name":"计算机网络","slug":"读书笔记/计算机网络","link":"/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"博文笔记","slug":"博文笔记","link":"/categories/%E5%8D%9A%E6%96%87%E7%AC%94%E8%AE%B0/"},{"name":"游戏设计","slug":"读书笔记/游戏设计","link":"/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/"},{"name":"设计模式","slug":"读书笔记/设计模式","link":"/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"教程","slug":"教程","link":"/categories/%E6%95%99%E7%A8%8B/"},{"name":"数据结构与算法","slug":"读书笔记/数据结构与算法","link":"/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Hexo","slug":"教程/Hexo","link":"/categories/%E6%95%99%E7%A8%8B/Hexo/"},{"name":"标记语言","slug":"教程/标记语言","link":"/categories/%E6%95%99%E7%A8%8B/%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/"},{"name":"翻墙梯子","slug":"教程/翻墙梯子","link":"/categories/%E6%95%99%E7%A8%8B/%E7%BF%BB%E5%A2%99%E6%A2%AF%E5%AD%90/"},{"name":"数据库","slug":"读书笔记/数据库","link":"/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Git","slug":"教程/Git","link":"/categories/%E6%95%99%E7%A8%8B/Git/"}],"pages":[{"title":"分类","text":"","link":"/categories/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}]}