<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>《C++ Primer》 第六章笔记 - 三叔胡言乱语的地方</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="三叔胡言乱语的地方"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="三叔胡言乱语的地方"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="《C++ Primer》 第六章笔记。 关于函数的定义，函数参数的传递方式，函数重载，函数指针。"><meta property="og:type" content="blog"><meta property="og:title" content="《C++ Primer》 第六章笔记"><meta property="og:url" content="https://wangxuejia.blog/CPPPrimer-Chapter6-Notes/"><meta property="og:site_name" content="三叔胡言乱语的地方"><meta property="og:description" content="《C++ Primer》 第六章笔记。 关于函数的定义，函数参数的传递方式，函数重载，函数指针。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://wangxuejia.blog/CPPPrimer-Chapter6-Notes/CPPPrimer-Chapter6-Notes/Ch_6.png"><meta property="article:published_time" content="2020-02-22T10:10:29.000Z"><meta property="article:modified_time" content="2023-04-02T12:21:20.011Z"><meta property="article:author" content="三叔"><meta property="article:tag" content="读书笔记"><meta property="article:tag" content="C++"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://wangxuejia.blog/CPPPrimer-Chapter6-Notes/CPPPrimer-Chapter6-Notes/Ch_6.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://wangxuejia.blog/CPPPrimer-Chapter6-Notes/"},"headline":"《C++ Primer》 第六章笔记","image":["https://wangxuejia.blog/CPPPrimer-Chapter6-Notes/CPPPrimer-Chapter6-Notes/Ch_6.png"],"datePublished":"2020-02-22T10:10:29.000Z","dateModified":"2023-04-02T12:21:20.011Z","author":{"@type":"Person","name":"三叔"},"publisher":{"@type":"Organization","name":"三叔胡言乱语的地方","logo":{"@type":"ImageObject","url":{"text":"三叔胡言乱语的地方"}}},"description":"《C++ Primer》 第六章笔记。 关于函数的定义，函数参数的传递方式，函数重载，函数指针。"}</script><link rel="canonical" href="https://wangxuejia.blog/CPPPrimer-Chapter6-Notes/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">三叔胡言乱语的地方</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-02-22T10:10:29.000Z" title="2020/2/22 18:10:29">2020-02-22</time>发表</span><span class="level-item"><time dateTime="2023-04-02T12:21:20.011Z" title="2023/4/2 20:21:20">2023-04-02</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a><span> / </span><a class="link-muted" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/">计算机语言</a></span><span class="level-item">1 小时读完 (大约8834个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">《C++ Primer》 第六章笔记</h1><div class="content"><p>《C++ Primer》 第六章笔记。</p>
<p>关于函数的定义，函数参数的传递方式，函数重载，函数指针。</p>
<p><img src="CPPPrimer-Chapter6-Notes/Ch_6.png" alt="第六章内容"></p>
<span id="more"></span>
<h1>Chapter 6 Functions</h1>
<h2 id="Function-Basics">Function Basics</h2>
<h4 id="Parameters-and-Arguments">Parameters and Arguments</h4>
<p>函数的形参（Parameters）和实参（Arguments）是一一对应关系，但是编译器不能保证形参被初始化的顺序。</p>
<h4 id="Function-Parameter-List">Function Parameter List</h4>
<p>为了与C语言兼容，C++同样允许用void来作为形参的参数，如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数的名字是可选的。但是如果没有设置参数名字，但因为参数没有名字所以无法在函数内部引用。但是未命名的参数还是需要指定实参的，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pareNoName</span><span class="params">(<span class="type">int</span>, <span class="type">float</span> fval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pareNoName(0.1f);//Although int doesn&#x27;t have name, we still must assign it</span></span><br><span class="line"><span class="built_in">pareNoName</span>(<span class="number">3</span>, <span class="number">0.1f</span>);</span><br></pre></td></tr></table></figure>
<h4 id="Function-Return-Type">Function Return Type</h4>
<p>函数返回的类型不能是数组类型，也不能是函数类型，但可以返回函数和数组的指针，以及函数的调用（相当于返回调用的函数的结果）。</p>
<h3 id="Local-Objects">Local Objects</h3>
<p>对于一个变量而言，需要关注它的作用域以及生命周期。</p>
<p>在函数内部定义的变量称为局部变量，如果局部变量与全局变量有相同的名称，局部变量会隐藏全局变量的定义，如果想要调用全局变量，需要用到作用域符号<code>::</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> val = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestLocalObject</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> val = <span class="number">3</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;local val is &quot;</span> &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;global val is &quot;</span> &lt;&lt; ::val &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    local val is 3</span></span><br><span class="line"><span class="comment">    global val is 2</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>全局变量的生命周期是从定义到程序终止，局部变量的生命周期是当退出了作用域。</p>
<h4 id="Automatic-Objects">Automatic Objects</h4>
<p>函数的形参就是自动物体（Automatic Objects），它们在函数开始时被分配创建， 在函数终结时被释放。</p>
<h4 id="Local-static-Objects">Local static Objects</h4>
<p>局部静态物体是在第一次被调用时创建，在程序终止时被摧毁，作用域在函数内部。如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">count_calls</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> ctr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ++ctr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestStaticObjects</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">count_calls</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1</span></span><br><span class="line"><span class="comment">    2</span></span><br><span class="line"><span class="comment">    3</span></span><br><span class="line"><span class="comment">    4</span></span><br><span class="line"><span class="comment">    5</span></span><br><span class="line"><span class="comment">    6</span></span><br><span class="line"><span class="comment">    7</span></span><br><span class="line"><span class="comment">    8</span></span><br><span class="line"><span class="comment">    9</span></span><br><span class="line"><span class="comment">    10</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态的局部变量执行的是值初始化，因此即使是内建类型，它也会默认值，不会像普通的内建局部变量一样变成未定义的。</p>
<h3 id="Function-Declarations">Function Declarations</h3>
<p>如同变量一样，函数也只能被定义一次，但可以多次声明。</p>
<p>如果是函数声明，则使用分号取代函数主体，也因为声明并没有函数主体，所以所有的形参有没有名字都没有区别。</p>
<p>如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pareName</span><span class="params">(<span class="type">int</span> val, <span class="type">float</span> fval)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pareName</span><span class="params">(<span class="type">int</span>, <span class="type">float</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>一个函数的类型由函数名字，返回类型以及形参类型决定，函数的类型也成为函数原型(function prototype)。</p>
<h4 id="Function-Declarations-Go-in-Header-Files">Function Declarations Go in Header Files</h4>
<p>函数的声明应该在头文件中，函数的定义在源文件中，这样如果后续要修改函数的声明，只需要改动一处即可。</p>
<p>在定义函数的源文件中，需要引入声明的头文件。</p>
<h3 id="Separate-Compilation">Separate Compilation</h3>
<h4 id="Compiling-and-Linking-Multiple-Source-Files">Compiling and Linking Multiple Source Files</h4>
<p>如我们将函数<code>GetNum</code>声明在头文件<code>GetNum.h</code>中，将函数的定义写在源文件<code>GetNum.cpp</code>中，将调用<code>GetNum</code>的语句写在源文件<code>Chapter6_Functions.cpp</code>中，则所有的文件内容如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//GetNum.h</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetNum</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//GetNum.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GetNum.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetNum</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Chapter6_Functions.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GetNum.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">GetNum</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>对于有多个源文件（CPP）文件的情况下，编译时要把所有的源文件都带上，源文件的顺序并不造成影响，如：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ Chapter6_Functions.cpp GetNum.cpp</span><br></pre></td></tr></table></figure>
<p>也可以单独编译（带上-c flag）某个源文件（必须是与其他源文件不依赖的），将其编译为.o文件，之后再编译其他依赖该源文件的文件时，只要带上.o文件，而不需要重新编译该文件，如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -c GetNum.cpp</span><br><span class="line">g++ Chapter6_Functions.cpp GetNum.o</span><br></pre></td></tr></table></figure>
<h2 id="Argument-Passing">Argument Passing</h2>
<p>当调用函数时，实际上是用实参初始化了形参，初始化的过程与一般的参数初始化一样。而如果形参的类型是引用的话，那么会直接绑定至实参，否则的话初始化时会拷贝实参的值。</p>
<p>如果形参的参数是引用，称实参是引用传递（Paseed by reference或called by reference）。</p>
<p>如果形参的类型不是引用，那么实参会进行拷贝，称实参是值传递（Passed by value或called by value）。</p>
<h3 id="Passing-Arguments-by-Value">Passing Arguments by Value</h3>
<p>当形参是值传递时，修改函数中的局部变量并不会影响实参。</p>
<h4 id="Pointer-Parameters">Pointer Parameters</h4>
<p>指针与其他非引用的变量一样，形参会通过拷贝实参的值进行初始化。但是指针的值即是指向的对象，因此拷贝生成的形参与实参指向的是同一个变量，也因此通过形参修改对象也同样会影响实参指向的对象。</p>
<p>如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(<span class="type">int</span> *val1, <span class="type">int</span> *val2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = (*val1);</span><br><span class="line">    *val1 = *val2;</span><br><span class="line">    *val2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Exercise6_10</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> val1 = <span class="number">10</span>, val2 = <span class="number">5</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Val 1 is &quot;</span> &lt;&lt; val1 &lt;&lt; <span class="string">&quot;, Val2 is &quot;</span> &lt;&lt; val2 &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">Swap</span>(&amp;val1, &amp;val2);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Val 1 is &quot;</span> &lt;&lt; val1 &lt;&lt; <span class="string">&quot;, Val2 is &quot;</span> &lt;&lt; val2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Passing-Argument-by-Reference">Passing Argument by Reference</h3>
<p>使用引用传递就可以在函数内部修改实参的值，如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestCallByReference</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> val1 = <span class="number">10</span>, val2 = <span class="number">5</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Val 1 is &quot;</span> &lt;&lt; val1 &lt;&lt; <span class="string">&quot;, Val2 is &quot;</span> &lt;&lt; val2 &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">Swap</span>(val1, val2);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Val 1 is &quot;</span> &lt;&lt; val1 &lt;&lt; <span class="string">&quot;, Val2 is &quot;</span> &lt;&lt; val2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(<span class="type">int</span> &amp;val1, <span class="type">int</span> &amp;val2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = val1;</span><br><span class="line">    val1 = val2;</span><br><span class="line">    val2 = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Using-Reference-to-Avoid-Copies">Using Reference to Avoid Copies</h4>
<p>函数可以通过将形参设置为引用类型来避免拷贝的过程，进而可以提升性能。</p>
<p>且尽量使用const reference，本章的后小节会进行说明。</p>
<h4 id="Using-Reference-Parameters-to-Return-Additional-Information">Using Reference Parameters to Return Additional Information</h4>
<p>一个函数只可以返回一个值，在需要返回多个参数的时候，也可以通过引用，将要返回的参数作为形参的一部分传递进函数，并在函数内部修改成结果的值。</p>
<h3 id="const-Parameters-and-Arguments">const Parameters and Arguments</h3>
<p>如普通的参数初始化一样，当使用实参来初始化形参时，top-level的const会被无视，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestConstParametersAndArguments</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> ci = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">func</span>(ci);</span><br><span class="line">    <span class="built_in">func</span>(i);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    value is 3</span></span><br><span class="line"><span class="comment">    value is 2</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;value is &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void func(int i) &#123;&#125;//Error,redefines</span></span><br></pre></td></tr></table></figure>
<p>函数func的形参类型为const int，但是可以用int的来进行初始化，因为这里是top-level的const。也因此函数<code>func(int)</code>和函数<code>func(const int)</code>是无法同时定义的，不然当使用int调用参数时，两个函数都可匹配。</p>
<h4 id="Use-Reference-to-const-When-Possible">Use Reference to const When Possible</h4>
<p>当可能的时候尽量使用const referencce，因为</p>
<ol>
<li>const reference可以避免函数中意外的修改实参值</li>
<li>普通reference形参，不能通过字面值进行初始化</li>
<li>普通reference形参，不能通过非const实参进行初始化</li>
</ol>
<p>如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> string ss = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="comment">// funs(&quot;&quot;);//error,can not use literal to initialize string reference</span></span><br><span class="line"><span class="comment">// funs(ss);//error,can not use const string to initialize stringreference</span></span><br><span class="line"><span class="built_in">funss</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="built_in">funss</span>(ss);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">funs</span><span class="params">(string &amp;s)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">funss</span><span class="params">(<span class="type">const</span> string &amp;s)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Array-Parameters">Array Parameters</h3>
<p>虽然可以使用数组作为形参，但当数组作为形参的时候，是无法进行有效的值拷贝的。因为数组无法进行拷贝初始化，且当调用数组时，调用的实际上是指向数组第一个元素的指针。</p>
<p>以下三个函数定义，实际上是完全等效的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span>[])</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span>[<span class="number">10</span>])</span></span>;</span><br></pre></td></tr></table></figure>
<p>即可以使用其中任意一个作为声明，再用另一个作来进行定义，而想声明其中两个则是不行的，因为会形成重复定义，后两个在编译的过程中会变换为第一种的写法。也因此，即使定义的是最后一种写法，看起来是要求一个大小为10的const int数组，但仍然可以传递普通的int指针进去，如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>, j[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">print</span>(&amp;i);</span><br><span class="line"><span class="built_in">print</span>(j);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span>[<span class="number">10</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为即使形参使用数组，也会在编译时转换为指针，所以函数是不知道传进来的数组大小的，因此需要额外的信息来指定数组大小，以下为三种普遍的方式：</p>
<h4 id="Using-a-Marker-to-Specify-the-Extent-of-an-Array">Using a Marker to Specify the Extent of an Array</h4>
<p>如之前所示，C风格的字符串实际上是const char[]，而C风格的字符串用来判断是否是数组结尾就是用一个空白的字符作为数组结束的标记位（Marker），如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">char</span> cp[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (*cp)</span><br><span class="line">            cout &lt;&lt; *cp++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">abcd</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>但是这种方法需要找到一个几乎不会作为正常数据的值，否则就会与正常数据产生干扰。</p>
<h4 id="Using-the-Standard-Liberary-Conventions">Using the Standard Liberary Conventions</h4>
<p>第二种方法是通过标准库中的<code>begin</code>和<code>end</code>方法来传递数组的开始与结束指针，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> j[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">begin</span>(j), <span class="built_in">end</span>(j));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *beg, <span class="type">const</span> <span class="type">int</span> *end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (beg != end)</span><br><span class="line">        cout &lt;&lt; *beg++ &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="Explicitly-Passing-a-Size-Parameter">Explicitly Passing a Size Parameter</h4>
<p>函数中使用一个形参来指定数组的大小，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(j, <span class="built_in">end</span>(j) - <span class="built_in">begin</span>(j));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *beg, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i != size; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *beg++ &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="Array-Parameters-and-const">Array Parameters and const</h4>
<p>可以使用在形参使用数组的引用，这个方法可以限定传递的数组的大小，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> valList[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">print</span>(valList);</span><br><span class="line"><span class="comment">//print(j); // j is int array with size 2,so can&#x27;t pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> (&amp;arr)[<span class="number">5</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> val : arr)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意数组的大小也是数组类型的一部分，所以对数组进行引用限定了数组大小，例子中只有数组大小是5的数组可以传递。</p>
<h4 id="Passing-a-Multidimensional-Array">Passing a Multidimensional Array</h4>
<p>对于多维数组，可以通过使用一个数组的指针进行传递，如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> mat[<span class="number">3</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">5</span>, <span class="number">6</span>&#125;&#125;;</span><br><span class="line"><span class="built_in">print</span>(mat, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> (*matrix)[<span class="number">2</span>], <span class="type">int</span> rowSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != rowSize; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j != <span class="number">2</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; matrix[i][j] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>其中因为传入的是长度为2的数组的指针，所以在循环中，可以确认内部循环的最大值为2。<code>matrix[i]</code>实际上获取的是长度为2的数组，但是会自动转为int*，所以<code>matrix[i][i]</code>实际上对一个int*使用<code>[j]</code>。也可以通过解引用符进行访问，即写成<code>*((*(matrix + i)) + j)</code></p>
<p>需要注意的是，无法直接通过指针的指针，如<code>int**</code>来进行传递的。因为数组的大小是类型的一部分，在上例中，<code>mat</code>的会自动转换为<code>int*[2]</code>而不是<code>int*</code>。因此如果函数的形参为<code>int**</code>，将无法匹配。如果要使用指针的指针来传递，那么就必须用指针来表示多维数组，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Initial array</span></span><br><span class="line"><span class="type">int</span> **matrix = <span class="keyword">new</span> <span class="type">int</span> *[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != <span class="number">3</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    matrix[i] = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">2</span>];</span><br><span class="line">    matrix[i][<span class="number">0</span>] = <span class="number">2</span> * i;</span><br><span class="line">    matrix[i][<span class="number">1</span>] = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(matrix, <span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">//release data</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != <span class="number">3</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] matrix[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] matrix;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> **matrix, <span class="type">int</span> rowSize, <span class="type">int</span> columnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != rowSize; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j != columnSize; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; matrix[i][j] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="main-Handling-Command-Line-Options">main: Handling Command-Line Options</h3>
<p>c++的main函数入口，可以是无参的，也可以是以下的格式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>第一个int参数表示传入的参数数量，第二个是C风格的字符串的类型表示传入的参数。通常最少有一个参数，该参数是运行的exe文件的路径，如定义main函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;argc count is &quot;</span> &lt;&lt; argc &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != argc; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;arg is &quot;</span> &lt;&lt; argv[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当直接启动编译完的exe文件，<code>./a.exe</code>，输出结果为</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">argc count is 1</span><br><span class="line">arg is D:\Study-Notes\C++Primer\Chapter6_Functions\a.exe</span><br></pre></td></tr></table></figure>
<p>当启动exe并传入参数时，<code>./a.exe 1 2 3</code>，输出结果为：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">argc count is 4</span><br><span class="line">arg is D:\Study-Notes\C++Primer\Chapter6_Functions\a.exe</span><br><span class="line">arg is 1</span><br><span class="line">arg is 2</span><br><span class="line">arg is 3</span><br></pre></td></tr></table></figure>
<h3 id="Functions-with-Varying-Parameters">Functions with Varying Parameters</h3>
<p>有的时候并不了解一个函数究竟需要多少个形参，如一个函数需要来处理错误信息，但错误信息的数量是不固定的。</p>
<p>为了处理这样的情况，在C++11的特性中，有两个方法，第一种是通过<code>initializer_list</code>，第二种是通过<code>variadic</code>模板。第二种方法将在16.4中进行说明。</p>
<p>C++还有一种名为<code>elipsis</code>的参数类型，可以实现传递不同数量的实参，但是该方法应该仅在与C接口进行通信时使用。</p>
<h4 id="initializer-list-Parameters">initializer_list Parameters</h4>
<p>initializer_list是一种表示数组的标准库中的类型，支持的操作如下表：</p>
<table>
<thead>
<tr>
<th>代码</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>initializer_list<T> lst;</td>
<td>默认初始化</td>
</tr>
<tr>
<td>initializer_list<T> lst{a,b,c}</td>
<td>参数初始化，元素是初始值的拷贝，且list中的元素都是const的</td>
</tr>
<tr>
<td>lst2(lst)</td>
<td>initializer_list的拷贝或赋值</td>
</tr>
<tr>
<td>lst2 = lst</td>
<td>同上</td>
</tr>
<tr>
<td>lst.size()</td>
<td>返回initializer_list中的元素数量</td>
</tr>
<tr>
<td>lst.begin()</td>
<td>返回第一个元素的指针</td>
</tr>
<tr>
<td>lst.end()</td>
<td>返回最后一个元素后面的指针</td>
</tr>
</tbody>
</table>
<ul>
<li>initializer_list的拷贝操作实际上并没有拷贝，而是共享被拷贝对象的元素</li>
</ul>
<p>如同vector，initializer_list也是模板类，需要指定元素的类型。</p>
<p>如表格中所述，initializer_list中的元素都是const的，无法进行修改。</p>
<p>当调用initializer_list作为参数的函数时，如果想传递一系列的值来直接初始化initializer_list，则这些值必须放在大括号内。</p>
<p>使用例子如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestVaryingParameters</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">error_msg</span>(&#123;<span class="string">&quot;functionX&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_msg</span><span class="params">(initializer_list&lt;string&gt; il)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> beg = il.<span class="built_in">begin</span>(); beg != il.<span class="built_in">end</span>(); ++beg)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *beg &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">functionX abc def </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="Ellipsis-Parameters">Ellipsis Parameters</h4>
<p>Elipsis是C++用来访问C中的库的，书中也未进行详细说明。但日后使用到时再进行查询。</p>
<h2 id="Return-Types-and-the-return-Statement">Return Types and the return Statement</h2>
<h3 id="Functions-with-No-Return-Value">Functions with No Return Value</h3>
<p>在无返回值的函数中，编译器会在函数尾部隐式的加入一个return语句。</p>
<h4 id="Functions-That-Return-a-value">Functions That Return a value</h4>
<p>如果函数的返回值不为空，则必须写明有return语句返回该类型的值，或者是返回一个可以隐式转换为该类型的值。</p>
<p>如果函数中有判断语句，且在某些case下没有返回值，那么编译器有可能可以检测出该错误，也有可能检测不出来，当检测不出来时，函数的结果是未定义的。</p>
<h4 id="How-Values-Are-returned">How Values Are returned</h4>
<p>函数中返回的值，会用来初始化一个临时的变量，该临时的变量会作为函数的返回结果。如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">ReturnThePluralVersionOfWord</span><span class="params">(<span class="type">size_t</span> ctr, <span class="type">const</span> string &amp;word, <span class="type">const</span> string &amp;ending)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (ctr &lt;= <span class="number">1</span>) ? word : word + ending;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当ctr &lt;= 1时，返回的是word的拷贝，当ctr &gt; 1时，返回的是一个未命名的临时string，其中的值为word + ending。</p>
<h4 id="Nerver-Return-a-Reference-or-Pointer-to-a-Local-Object">Nerver Return a Reference or Pointer to a Local Object</h4>
<p>如果要避免函数返回参数的时的拷贝，可以将返回类型设置为引用。但要注意千万不要返回本地局部变量的引用或指针。如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> string &amp;<span class="title">manip</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string ret;</span><br><span class="line">    <span class="keyword">if</span> (!ret.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span> ret; <span class="comment">//error,return reference of local variable</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;empty&quot;</span>;<span class="comment">//error, return reference of a temporary string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在例子中，如果返回的是ret，那么返回的是一个局部变量的引用，当退出函数时，该变量会被释放，于是引用的就是一个空参数。如果返回的是&quot;empty&quot;，实际上返回的是值为empty的临时变量的引用。</p>
<p>这两种返回方式的结果都是未定义的。</p>
<h4 id="Reference-Returns-Are-Lvalues">Reference Returns Are Lvalues</h4>
<p>如果一个函数返回的是类型，那么该函数返回的是右参数。如果一个函数返回的是类型的引用，那么该函数返回的是左参数。因此可以将返回结果为引用的函数放在等式的左边，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> &amp;<span class="title">Get_Val</span><span class="params">(string &amp;str, string::size_type ix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str[ix];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;abc&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">Get_Val</span>(s,<span class="number">0</span>) = <span class="string">&#x27;A&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h4 id="List-Initializing-the-Return-Value">List Initializing the Return Value</h4>
<p>在C++11特性下，函数可以通过大括号括其一系列返回的函数，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">process</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;Bb&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该例子中，会返回一个临时的vector<string>变量，变量中有三个元素，由返回值来充填。</p>
<h4 id="Return-from-main">Return from main</h4>
<p>main函数虽然指定了返回类型为int，但却可以不写返回语句，这是因为当没有返回语句时，编译器会补上return 0。</p>
<p>main函数返回0表示执行成功，返回其他数值通常表示执行不成功，具体的定义是系统相关的，要返回系统不相关的值，可以使用头文件<code>cstdlib</code>。如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(someFailure)</span><br><span class="line">        <span class="keyword">return</span> EXIST_FAILURE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> EXIST_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两者都是预处理器的变量，所以不需要定义作用域或using语句。</p>
<h4 id="Recursion">Recursion</h4>
<p>在函数中可以再调用自己，这种称为递归。</p>
<p>main函数中不能再调用自己。</p>
<h3 id="Returning-a-Pointer-to-an-Array">Returning a Pointer to an Array</h3>
<p>同样因为数组无法被拷贝，一个函数无法返回数组类型，但是返回数组的指针。关于定义返回数组指针的函数，有以下几种方法</p>
<h4 id="Typedef-Using">Typedef / Using</h4>
<h4 id="Functions-That-Return-Class-Types-and-the-Call-Operator">Functions That Return Class Types and the Call Operator</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> arrt[<span class="number">10</span>];</span><br><span class="line"><span class="comment">// using arrt = int[10];// equally</span></span><br><span class="line"></span><br><span class="line"><span class="function">arrt *<span class="title">funcArray</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="Declaring-a-Function-That-Returns-a-Pointer-to-an-Array">Declaring a Function That Returns a Pointer to an Array</h4>
<p>像声明指向数组的变量那样直接定义，如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (*<span class="built_in">funcArray</span>())[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<p>funcArray()表明形参为空，(*funcArray())表明返回的是一个指针类型。</p>
<h4 id="Using-a-Trailing-Return-Type">Using a Trailing Return Type</h4>
<p>该方法是C++11的特性，Trailing Return可以针对任何的类型的函数，但针对返回值为数组的指针的函数时尤为有效。如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">funcArray</span><span class="params">()</span> -&gt; <span class="title">int</span> <span class="params">(*)</span>[]</span>;</span><br></pre></td></tr></table></figure>
<p>该方法下，用auto替代原先定义返回类型的地方。</p>
<h4 id="Using-decltype">Using decltype</h4>
<p>因为对数组使用decltype，返回的是数组类型，而不是指针类型，如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> odd[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> even[] = &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>&#125;;</span><br><span class="line"><span class="keyword">decltype</span>(odd) *<span class="built_in">funcArray</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;odd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Overloaded-Functions">Overloaded Functions</h2>
<p>main函数无法被重载</p>
<h4 id="Defining-Overloaded-Functions">Defining Overloaded Functions</h4>
<p>重载函数必须在形参的类型或者形参的数量上有区分。无法仅仅通过函数的返回类型来进行重载。</p>
<h4 id="Overloading-and-const-Parameters">Overloading and const Parameters</h4>
<p>无法仅通过形参的top-level的const属性进行函数重载，如下两个函数虽然不同，但却会造成重复定义。因为当调用函数时，top-level的const属性会被无视，因此对于调用者而说，两个函数是没有区别的，它们实际差异是体现在函数body中对形参的处理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone)</span></span>;</span><br><span class="line">Record lookup[(<span class="type">const</span> Phone);</span><br></pre></td></tr></table></figure>
<p>但如果const的区别是low-level的，那么是可以进行重载的，如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Record <span class="title">loopup</span><span class="params">(Account&amp;)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">loopup</span><span class="params">(<span class="type">const</span> Account&amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>对于调用者而言，上面的两个函数是不同的。如果使用的实参是const的，那么将无法直接调用第一个函数。当使用的形参是非const的，那么会优先调用第一个函数，关于重载函数的调用选择规则会在之后的小节中进行说明。</p>
<h4 id="const-cast-and-Overloading">const_cast and Overloading</h4>
<p>如有以下函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> string &amp;<span class="title">shorterString</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt; s2.<span class="built_in">size</span>() ? s1 : s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数的形参是low level的const引用，返回的类型也为low level的const引用。如果调用的实参为非const的引用，会进行隐式的类型转换，此时返回结果将仍然是const的引用。</p>
<p>而如果想要实现，传入的实参是const的，返回为const类型；传入的实参是non-const类型，返回也会non-const类型，就需要进行函数重载。如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string &amp;<span class="title">shorterString</span><span class="params">(string &amp;s1, string &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> string &amp;r = <span class="built_in">shorterString</span>(<span class="built_in">const_cast</span>&lt;<span class="type">const</span> string &amp;&gt;(s1), <span class="built_in">const_cast</span>&lt;<span class="type">const</span> string &amp;&gt;(s2));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">const_cast</span>&lt;string &amp;&gt;(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里通过调用形参为const引用的版本来获取结果，注意在调用函数时，需要将形参转换为const类型，否则调用的将还是这个函数本身，即形成了无止境的递归。在返回结果时将const引用的版本返回的const string&amp;转换为string&amp;。</p>
<h4 id="Calling-an-Overloaded-Function">Calling an Overloaded Function</h4>
<p>从一系列重载函数中找到正确的函数，这个过程叫做函数匹配（Function matching）。</p>
<p>对于调用重载函数，一共有三种可能的结果：</p>
<ol>
<li>编译器找到了最佳的匹配函数（Best match），最终将调用该函数。</li>
<li>编译器没有找到任何可以匹配的函数（No match），最终编译器将报错。</li>
<li>编译器找到了多个匹配的函数，且无法从中判断出谁匹配度更高，为歧义调用（Ambiguous call），最终编译器将报错。</li>
</ol>
<h3 id="Overloading-and-Scope">Overloading and Scope</h3>
<p>如果在内层的代码范围内声明或者定义一个名字，则在外层代码块范围中同样名字的对象将被隐藏。这个规则同时适用于变量和函数。</p>
<p>如下代码，在内层作用域中定义的变量和函数将隐藏外层作用域中的同名变量与函数，如果要调用外层作用域的话需要<code>::</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">read</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;readed&quot;</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> string &amp;s)</span> </span>&#123; cout &lt;&lt; s &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">double</span> d)</span> </span>&#123; cout &lt;&lt; d &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fooBar</span><span class="params">(<span class="type">int</span> ival)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> read = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// string s = read();//error, read() is hidden, in this scope read is a bool variable</span></span><br><span class="line">    string s = ::<span class="built_in">read</span>(); <span class="comment">//ok,use :: to indicate search name is global scope</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decalare a function in the inner scope.This action is rare in practice.</span></span><br><span class="line">    <span class="comment">//Here we only use this to illustrate scope hidding</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="comment">// print(&quot;value :&quot;);//error, print(const string &amp;s) is hidden.</span></span><br><span class="line">    <span class="built_in">print</span>(ival);</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">3.14</span>);<span class="comment">//ok, but it will call print(int)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在C++中，如果调用了一个名字的对象，编译器会在当前作用域首先找该名字的对象（可能不存在，可能一个，可能多个）。如果对象不存在的话，才会去外部作用域查找。</p>
<p>因此在上述代码中，调用<code>print</code>函数，编译器在当前的作用域找到了<code>print(int)</code>，就不会在外层的作用域查找了，于是<code>print(double)</code>与<code>print(const string&amp;)</code>都不会被作为重载的候选人，更不会进行函数匹配。</p>
<h2 id="Features-for-Specialized-Uses">Features for Specialized Uses</h2>
<h3 id="Default-Arguments">Default Arguments</h3>
<p>可以为形参设定默认参数。但如果为一个形参设定了默认参数，该形参后面的所有形参都必须指明默认参数。</p>
<p>如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(<span class="type">int</span> ht = <span class="number">24</span>, <span class="type">int</span> wid = <span class="number">80</span>,<span class="type">char</span> background = <span class="string">&#x27; &#x27;</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>如果仅想要修改最后一个变量，其他的变量仍然按默认参数，也仍然必须写明前面的参数。</p>
<p>如调用<code>screen('?')</code>，看起来实参类型为<code>char</code>，与最后一个参数相匹配，但在调用过程中，形参与实参是一一对应的，该表达式等同于<code>screen('?', 80, ' '</code>，即<code>'?'</code>会被转换为int作为第一个参数。</p>
<h4 id="Default-Argument-Declarations">Default Argument Declarations</h4>
<p>C++中，只可以定义一个变量，但可以多次声明变量。但是对于默认参数而言，每个形参的默认参数都最多被声明一次，如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>,<span class="type">char</span> = <span class="string">&#x27; &#x27;</span>)</span></span>;</span><br><span class="line"><span class="comment">// string screen(int,int,char = &#x27;*&#x27;);</span></span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(<span class="type">int</span>=<span class="number">24</span>,<span class="type">int</span>=<span class="number">80</span>,<span class="type">char</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在第一条语句执行后，第二条语句无法通过编译，因为它重新声明了char类型的形参的默认值，造成了重复定义。而第三条语句仍然可以执行，且第三条语句执行后，函数<code>screen</code>的三个形参都有了默认值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>, <span class="type">char</span> = <span class="string">&#x27;*&#x27;</span>)</span></span>;</span><br><span class="line"><span class="comment">// string screen(int, int, char = &#x27; &#x27;);</span></span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(<span class="type">int</span> = <span class="number">24</span>, <span class="type">int</span> = <span class="number">80</span>, <span class="type">char</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height, <span class="type">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;width is &quot;</span> &lt;&lt; width &lt;&lt; <span class="string">&quot;, height is &quot;</span> &lt;&lt; height &lt;&lt; <span class="string">&quot;, c is &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">screen</span>();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">width is 24, height is 80, c is *</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="Default-Argument-Initializers">Default Argument Initializers</h4>
<p>函数的默认参数可以是任何可以转换为形参类型的表达式，如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> vall = <span class="number">20</span>;</span><br><span class="line"><span class="type">char</span> cc = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printDefaultArgument</span><span class="params">(<span class="type">int</span> ran = rand(), <span class="type">int</span> w = vall, <span class="type">char</span> c = cc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;random is &quot;</span> &lt;&lt; ran &lt;&lt; <span class="string">&quot;, w is &quot;</span> &lt;&lt; w &lt;&lt; <span class="string">&quot;, c is &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestDefaultArgument</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printDefaultArgument</span>();</span><br><span class="line">    vall = <span class="number">30</span>;</span><br><span class="line">    <span class="type">char</span> cc = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    <span class="built_in">printDefaultArgument</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">random is 41, w is 20, c is a</span></span><br><span class="line"><span class="comment">random is 18467, w is 30, c is a</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>上述代码中，<code>printDefaultArgument</code>函数第一个形参<code>ran</code>的默认值是一个函数，函数会随机取一个int值，第二个和第三个形参都是全局变量。</p>
<p>在函数<code>TestDefaultArgument</code>中调用<code>printDefaultArgument</code>函数，第二次调用前先改变了全局变量<code>vall</code>的值，然后定义了一个同名新局部变量<code>cc</code>。但是因为<code>printDefaultArgument</code>函数的第三个形参实际上是全局变量中的<code>cc</code>，所以在第二次调用<code>printDefaultArgument</code>时，第三个形参的数值并没有发生改变。</p>
<h3 id="Inline-and-constexpr-Functions">Inline and constexpr Functions</h3>
<p>在大多数的设备下，函数调用是一个花费较大的操作，需要拷贝实参，记录和回复调用时的状态等。<code>inline</code>关键字可以减少函数的调用。</p>
<h4 id="inline-Functions-Avoid-Function-Call-Overhead">inline Functions Avoid Function Call Overhead</h4>
<p>如果定义一个函数为<code>inline</code>的，那么编译器会在编译阶段，将函数调用的地方换成函数主体，这样就避免了函数的调用。这样的函数称为内联函数（inline Function）。</p>
<p>如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">const</span> string &amp;<span class="title">shorterString</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt; s2.<span class="built_in">size</span>() ? s1 : s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意并不是函数加上了<code>inline</code>关键字就一定会变成内联函数，<code>inline</code>关键字如同一个申请，至于函数最终是否会变成内联由编译器决定。通常而言，递归函数和行数大于75行的函数是不会变成内联函数的。</p>
<h4 id="constexpr-Functions">constexpr Functions</h4>
<p>//TODO</p>
<h4 id="Put-inline-and-constexpr-Functions-in-Header-Files">Put inline and constexpr Functions in Header Files</h4>
<p>和其他的函数不同，内联函数在一个程序中是可以被多次定义的，如:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GetNum.h</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetNum</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">GetDoubleNum</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetNum.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetNum</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">GetDoubleNum</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3.14</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Chapter6_Functions.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// int GetNum()</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     return 10;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">GetDoubleNum</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4.15</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">GetDoubleNum</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4.15</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>可以看到在<code>Chapter6_Functions.cpp</code>和<code>GetNum.cpp</code>两个源文件中都对<code>GetDoubleNum</code>函数进行了定义，且仍然可以正常运行。而如果尝试在<code>Chapter6_Functions.cpp</code>中再次定义<code>GetNum</code>函数，则会发生编译错误。</p>
<p>这是因为对于内联函数而言，是在本源文件中搜索内联函数的定义然后进行替代。</p>
<p>最合理的方式是将内联函数的定义放在头文件中，这样在使用include时，实际上就将内联函数的定义拷贝到了源文件中。</p>
<h3 id="Aids-for-Debugging">Aids for Debugging</h3>
<p>可以使用预处理器来帮助C++进行调试工作，即实现在开发过程中，可以打出调试log，而在实际程序中log则不予显示的方法。</p>
<h4 id="The-assert-Preprocessor-Macro">The assert Preprocessor Macro</h4>
<p>预处理宏（Preprocessor Macro）是一种预处理器变量，运行起来有点像内联函数。</p>
<p><code>assert</code>预处理器宏可以接纳一个表示condition的表达式，定义在头文件<code>cassert</code>中，且因为是预处理器变量，因此不需要设定命名空间。当表达式的结果为false时，将打出信息并且终止程序的运行。如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">3</span>, b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">assert</span>(a &lt; b);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Assertion failed!</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Program: D:\Study-Notes\C++Primer\Chapter6_Functions\a.exe</span></span><br><span class="line"><span class="comment">File: Chapter6_Functions.cpp, Line 50</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Expression: a &lt; b</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><code>assert</code>通常是用来判断那些不可能发生的情况，如当某个数值超过了阈值等。</p>
<h4 id="The-NDEBUG-Preprocessor-Variable">The NDEBUG Preprocessor Variable</h4>
<p><code>assert</code>的运行状态预处理变量<code>NDEBUG</code>决定，如果该变量被定义了，则<code>assert</code>不会被执行。</p>
<p>因此可以通过在代码中加入<code>#define NDEBUG</code>来关闭<code>assert</code>的调试。也可以直接在编译时通过flag -D来加入这句话，如</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">g++ Chapter6_Functions.cpp </span><br><span class="line"></span><br><span class="line">$ ./a.exe </span><br><span class="line"></span><br><span class="line">Assertion failed!</span><br><span class="line"></span><br><span class="line">Program: D:\Study-Notes\C++Primer\Chapter6_Functions\a.exe</span><br><span class="line">File: Chapter6_Functions.cpp, Line 50</span><br><span class="line"></span><br><span class="line">Expression: a &lt; b</span><br><span class="line"></span><br><span class="line">g++ Chapter6_Functions.cpp -D NDEBUG</span><br><span class="line"></span><br><span class="line">$ ./a.exe </span><br><span class="line">4.15</span><br></pre></td></tr></table></figure>
<p>也可以进一步利用NDEBUG来定义自己的调试函数，如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Debug</span><span class="params">(<span class="type">const</span> string &amp;msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NDEBUG</span></span><br><span class="line">    cout &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C++还提供了一些帮助调试的预处理器变量：</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>func</strong></td>
<td>当前的函数名</td>
</tr>
<tr>
<td><strong>FILE</strong></td>
<td>当前文件名</td>
</tr>
<tr>
<td><strong>LINE</strong></td>
<td>当前行号</td>
</tr>
<tr>
<td><strong>TIME</strong></td>
<td>该文件被编译的时间</td>
</tr>
<tr>
<td><strong>DATE</strong></td>
<td>该文件被编译的日期</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestPreprocessorVariable</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Function is &quot;</span> &lt;&lt; __func__ &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;File is &quot;</span> &lt;&lt; __FILE__ &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Line is &quot;</span> &lt;&lt; __LINE__ &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Time is &quot;</span> &lt;&lt; __TIME__ &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Dateis &quot;</span> &lt;&lt; __DATE__ &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Function is TestPreprocessorVariable</span></span><br><span class="line"><span class="comment">File is Chapter6_Functions.cpp</span></span><br><span class="line"><span class="comment">Line is 78</span></span><br><span class="line"><span class="comment">Time is 16:49:12</span></span><br><span class="line"><span class="comment">Dateis Feb 22 2020</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Function-Matching">Function Matching</h2>
<p>函数匹配过程可以分为三步：</p>
<ol>
<li>找出候选函数（candidate functions），通过函数的名字，找到所有可能的重载函数（注意作用域隐藏）。</li>
<li>找出可选函数（viable functions），在候选函数中通过形参数量和类型找出可以被调用的函数</li>
<li>找出最佳匹配，在所有的可选函数中根据规则找出最佳匹配函数。</li>
</ol>
<p>以下是找最佳匹配函数的规则，排名越靠前的函数，会越优先被选取</p>
<ol>
<li>
<p>实参类型与形参类型完全匹配，包括<br>
a. 实参类型与形参类型相同，不需要任何转换<br>
b. 实参是数组或函数，形参是对应的指针类型<br>
c. 实参和形参的差距是可以无视的top-level const</p>
</li>
<li>
<p>需要进行const转换<br>
low level的const转换，如实参是nonconst的引用，形参是const的引用。</p>
</li>
<li>
<p>需要进行数值提升（promotion）<br>
较小的整数类型会自动转换成int或更高类型的整数类型。如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ff</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ff</span><span class="params">(<span class="type">short</span>)</span></span>;</span><br><span class="line"><span class="built_in">ff</span>(<span class="string">&#x27;a&#x27;</span>);<span class="comment">//Call ff(int)</span></span><br></pre></td></tr></table></figure>
<p>因为十进制的字面值会自动转换为最小为<code>int</code>的变量，所以<code>a</code>的最终类型为int。所以可以与<code>ff(int)</code>完全匹配，但是与<code>ff(short)</code>需要进行一次转换。</p>
</li>
<li>
<p>需要进行算数转换或者指针转换<br>
算数类型的转换，如int转float,int转double。注意只要都是算数转换，则它们的排名就是一样的，无论正在进行的类型转换是什么。</p>
<p>指针转换指的是，0转换为空指针，non const的指针可以转换为void*，任何指针都可以转换为<code>const void*</code>。</p>
</li>
<li>
<p>需要进行类转换（14.9节中进行说明）</p>
</li>
</ol>
<p>如果出现了多个可选函数由相同的排名，则会出现歧义调用（Ambiguous call）。如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">f</span>(<span class="type">int</span>,<span class="type">int</span>);</span><br><span class="line"><span class="built_in">f</span>(<span class="type">double</span>,<span class="type">double</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// f(42,2.56); // ambiguous call</span></span><br></pre></td></tr></table></figure>
<p>对于调用<code>f(42,2.56)</code>无论是访问<code>f(int,int)</code>和<code>f(double,double)</code>都是进行了一次算数转换，所以这两个函数的优先级一样的，为歧义调用。</p>
<p>还有类似于</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">manip</span><span class="params">(<span class="type">long</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">manip</span><span class="params">(<span class="type">float</span>)</span></span>;</span><br><span class="line"><span class="comment">// manip(3.14); // ambiguous call</span></span><br></pre></td></tr></table></figure>
<p>无论调用哪个函数都会进行算数转换，即使转换的目标类型不同，但是函数的优先级仍然是一样的，所以为歧义调用。</p>
<h2 id="Pointers-to-Functions">Pointers to Functions</h2>
<p>函数指针就是指向函数的指针，指针的类型需要匹配要指向的函数的形参数量，形参类型和返回值类型。如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> (*pf)(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;); <span class="comment">// uninitialized</span></span><br></pre></td></tr></table></figure>
<p>pf为指向两个形参都是<code>const string&amp;</code>，返回值为bool的函数的指针。如可以指向</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">lengthCompare</span><span class="params">(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>但是并不能指向类内成员函数，即使形参和返回值类型一样，因为类内函数实际上有一个this指针的传递</p>
<p>注意，定义pf时，外面的括号不能缺少，不然变成</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> *<span class="title">pf</span><span class="params">(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>上述代码意思为一个名为pf的返回值为bool*的函数的声明。</p>
<h4 id="Using-Function-Pointers">Using Function Pointers</h4>
<p>在赋值和使用函数指针的时候，取地址符(&amp;)以及解引用符(*)都可以被省略。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> (*fp)(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;) = lengthCompare;</span><br><span class="line"><span class="comment">// bool (*fp)(const string &amp;, const string &amp;) = &amp;lengthCompare;//equal to above</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> b1 = <span class="built_in">fp</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;goodbyte&quot;</span>);</span><br><span class="line"><span class="type">bool</span> b2 = (*fp)(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;goodbyte&quot;</span>);<span class="comment">// equal to above</span></span><br><span class="line"><span class="type">bool</span> b3 = <span class="built_in">lengthCompare</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;goodby&quot;</span>);<span class="comment">//equal ro above</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b1: &quot;</span> &lt;&lt; b1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b2: &quot;</span> &lt;&lt; b2 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b3: &quot;</span> &lt;&lt; b3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">b1: 0</span></span><br><span class="line"><span class="comment">b2: 0</span></span><br><span class="line"><span class="comment">b3: 0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">当使用函数指针时，赋值给函数指针的函数的类型必须与函数指针的类型完全一致。</span><br><span class="line"></span><br><span class="line">```<span class="function">cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ff</span><span class="params">(<span class="type">int</span> val)</span></span>;</span><br><span class="line"><span class="built_in">void</span> (*p1)(<span class="type">unsigned</span> <span class="type">int</span>) = ff;</span><br><span class="line"><span class="comment">// void (*p2)(int) = ff; //error, can&#x27;t convert unsigned int to int</span></span><br></pre></td></tr></table></figure>
<h4 id="Function-Pointer-Parameters">Function Pointer Parameters</h4>
<p>无法将函数类型作为函数的形参类型，但是可以将函数指针作为形参的函数类型。如同数组一样，如果将函数的形参类型设置为某个函数类型，那么会形参类型会自动转换为该函数类型的指针，如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span>[])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">(<span class="type">const</span> string &amp;s1,<span class="type">const</span> string &amp;s2,<span class="type">bool</span> pf(<span class="type">const</span> string&amp;,<span class="type">const</span> string&amp;))</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">(<span class="type">const</span> string &amp;s1,<span class="type">const</span> string &amp;s2,<span class="type">bool</span> (*pf)(<span class="type">const</span> string&amp;,<span class="type">const</span> string&amp;))</span></span>;</span><br></pre></td></tr></table></figure>
<p>上述代码，每一组是完全相同的。</p>
<p>调用形参为函数指针的函数时，也可以省略取地址符，如以下两个语句是完全相同的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">useBigger</span>(s1, s2, lengthCompare);</span><br><span class="line"><span class="built_in">useBigger</span>(s1, s2, &amp;lengthCompare);</span><br></pre></td></tr></table></figure>
<p>但当使用<code>decltype</code>时，使用函数类型以及函数类型的指针返回的结果是不同的，如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Func and Func2 are function type</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="type">bool</span> <span class="title">Func</span> <span class="params">(<span class="type">const</span> string &amp;,<span class="type">const</span> string &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(lengthCompare)</span> Func2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//FuncP and FuncP2 are pointer to function type</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(*FuncP)</span> <span class="params">(<span class="type">const</span> string &amp;,<span class="type">const</span> string &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(lengthCompare)</span> *FuncP2</span>;</span><br></pre></td></tr></table></figure>
<p>上述代码，每组等效，但是第一组定义的是函数类型的别名，第二组定义的是函数指针的别名。</p>
<p>但使用函数类型和函数指针的别名来定义函数时，又可以直接进行转换，如下两句，完全等效</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">(s1, s2, Func)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">(s1, s2, FuncP)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="Returning-a-Pointer-to-Function">Returning a Pointer to Function</h4>
<p>如同数组一样，无法将函数类型作为函数的返回值，但可以返回函数类型的指针。如需要定义函数<code>f1</code>，形参为int，返回值类型为指向形参为(int*,int)，返回值为int的函数的指针。</p>
<p>以下是四种定义返回类型为函数指针的函数的方法，分别是使用别名，直接定义，使用trailing方法，使用decltype</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Method1: use alias</span></span><br><span class="line"><span class="keyword">using</span> F = <span class="built_in">int</span>(<span class="type">int</span> *, <span class="type">int</span>);      <span class="comment">//F is Function type,retun type is int</span></span><br><span class="line"><span class="keyword">using</span> FF = <span class="type">int</span> *(<span class="type">int</span> *, <span class="type">int</span>);   <span class="comment">//F is Function type,retun type is pointe to int</span></span><br><span class="line"><span class="keyword">using</span> PF = <span class="built_in">int</span> (*)(<span class="type">int</span> *, <span class="type">int</span>); <span class="comment">//FP is pointer to Function type</span></span><br><span class="line"><span class="function">PF <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="comment">// F f1(int); //error, function type can not be return type</span></span><br><span class="line"><span class="function">F *<span class="title">f1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Method 2: directly</span></span><br><span class="line"><span class="comment">//like directly define return is pointer to array, which looks like</span></span><br><span class="line"><span class="comment">//int (*f1(int)) [10];</span></span><br><span class="line"><span class="built_in">int</span> (*<span class="built_in">f1</span>(<span class="type">int</span>))(<span class="type">int</span>*,<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Method 3: use trailing return</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span> -&gt; <span class="title">int</span> <span class="params">(*)</span><span class="params">(<span class="type">int</span> *, <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Method4: use decltype</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func1</span><span class="params">(<span class="type">int</span>*,<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">decltype</span>(func1)* <span class="built_in">f1</span>(<span class="type">int</span>);</span><br></pre></td></tr></table></figure>
<article class="message is-info">
        
        <div class="message-body">
            <p>引用：</p>
<ol>
<li><em>Cpp Primer</em> 5th Aug.2012</li>
</ol>

        </div>
    </article>
<hr>
</div><div class="article-licensing box"><div class="licensing-title"><p>《C++ Primer》 第六章笔记</p><p><a href="https://wangxuejia.blog/CPPPrimer-Chapter6-Notes/">https://wangxuejia.blog/CPPPrimer-Chapter6-Notes/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>三叔</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2020-02-22</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2023-04-02</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a><a class="link-muted mr-2" rel="tag" href="/tags/C/">C++</a></div><!--!--></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/alipay.jpg" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/wechat.jpg" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/3DMathPrimerForGraphicsAGameDevelopment-Chapter1-Notes/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">《3D数学基础：图形和游戏开发》第一章笔记</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/CPPPrimer-Chapter5-Notes/"><span class="level-item">《C++ Primer》 第五章笔记</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="content" id="valine-thread"></div><script src="//cdn.jsdelivr.net/npm/leancloud-storage@3/dist/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@1.4.16/dist/Valine.min.js"></script><script>new Valine({
            el: '#valine-thread',
            appId: "TGA1EB8Nf5aw6uJBpw45pBJQ-gzGzoHsz",
            appKey: "z1vCYavVUbCGuMjNMcrsvShN",
            placeholder: "匿名的！不需要注册！想说啥直接说吧！",
            avatar: "mm",
            avatarForce: false,
            meta: ["nick","mail","link"],
            pageSize: 10,
            lang: "zh-CN",
            visitor: true,
            highlight: true,
            recordIP: false,
            
            
            
            enableQQ: true,
            requiredFields: [],
        });</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.jpg" alt="三叔"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">三叔</p><p class="is-size-6 is-block">XR 行业的 Unity 开发者</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">71</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">15</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">18</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://www.zhihu.com/people/wang-xue-jia-20" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/xuejiaW"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Zhihu" href="https://www.zhihu.com/people/wang-xue-jia-20"><i class="fab fa-zhihu"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Jike" href="https://web.okjike.com/u/9ca63fe3-362f-458a-84ba-ec92a1dad321"><i class="fa-solid fa-j"></i></a></div></div></div><!--!--><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E5%8D%9A%E6%96%87%E7%AC%94%E8%AE%B0/"><span class="level-start"><span class="level-item">博文笔记</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%99%E7%A8%8B/"><span class="level-start"><span class="level-item">教程</span></span><span class="level-end"><span class="level-item tag">8</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E6%95%99%E7%A8%8B/Git/"><span class="level-start"><span class="level-item">Git</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%99%E7%A8%8B/Hexo/"><span class="level-start"><span class="level-item">Hexo</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%99%E7%A8%8B/%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">标记语言</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%99%E7%A8%8B/%E7%BF%BB%E5%A2%99%E6%A2%AF%E5%AD%90/"><span class="level-start"><span class="level-item">翻墙梯子</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"><span class="level-start"><span class="level-item">论文笔记</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="level-start"><span class="level-item">读书笔记</span></span><span class="level-end"><span class="level-item tag">58</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"><span class="level-start"><span class="level-item">图形学</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="level-start"><span class="level-item">数据库</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">数据结构与算法</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/"><span class="level-start"><span class="level-item">游戏设计</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="level-start"><span class="level-item">计算机网络</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">计算机语言</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="level-start"><span class="level-item">设计模式</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-09-24T15:13:39.000Z">2020-09-24</time></p><p class="title"><a href="/LearnOpenGL-Notes-2/">《LearnOpenGL》 笔记（二）</a></p><p class="categories"><a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a> / <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%BD%A2%E5%AD%A6/">图形学</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-05-25T12:41:17.000Z">2020-05-25</time></p><p class="title"><a href="/LearnOpenGL-Notes-1/">《LearnOpenGL》 笔记 (一)</a></p><p class="categories"><a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a> / <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%BD%A2%E5%AD%A6/">图形学</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-05-13T23:07:55.000Z">2020-05-14</time></p><p class="title"><a href="/CPPPrimer-Chapter8-Notes/">《C++ Primer》 第八章笔记</a></p><p class="categories"><a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a> / <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/">计算机语言</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-04-13T14:08:54.000Z">2020-04-13</time></p><p class="title"><a href="/3DMathPrimerForGraphicsAGameDevelopment-Chapter9-Notes/">《3D数学基础：图形和游戏开发》第九章笔记</a></p><p class="categories"><a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a> / <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%BD%A2%E5%AD%A6/">图形学</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-04-07T06:55:42.000Z">2020-04-07</time></p><p class="title"><a href="/3DMathPrimerForGraphicsAGameDevelopment-Chapter8-Notes/">《3D数学基础：图形和游戏开发》第八章笔记</a></p><p class="categories"><a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a> / <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%BD%A2%E5%AD%A6/">图形学</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2020/"><span class="level-start"><span class="level-item">2020</span></span><span class="level-end"><span class="level-item tag">38</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/"><span class="level-start"><span class="level-item">2019</span></span><span class="level-end"><span class="level-item tag">32</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/"><span class="level-start"><span class="level-item">2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/3D%E6%95%B0%E5%AD%A6/"><span class="tag">3D数学</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hexo/"><span class="tag">Hexo</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OpenGL/"><span class="tag">OpenGL</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8D%9A%E6%96%87%E7%AC%94%E8%AE%B0/"><span class="tag">博文笔记</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"><span class="tag">图形学</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%88%E7%8E%87%E6%8F%90%E5%8D%87/"><span class="tag">效率提升</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="tag">数据库</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><span class="tag">数据结构与算法</span><span class="tag">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/"><span class="tag">标记语言</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/"><span class="tag">游戏设计</span><span class="tag">14</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BF%BB%E5%A2%99%E6%A2%AF%E5%AD%90/"><span class="tag">翻墙梯子</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%99%9A%E6%8B%9F%E7%8E%B0%E5%AE%9E/"><span class="tag">虚拟现实</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="tag">计算机网络</span><span class="tag">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"><span class="tag">论文笔记</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="tag">设计模式</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="tag">读书笔记</span><span class="tag">58</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/"><span class="tag">软件推荐</span><span class="tag">2</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">三叔胡言乱语的地方</a><p class="is-size-7"><span>&copy; 2023 三叔</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>