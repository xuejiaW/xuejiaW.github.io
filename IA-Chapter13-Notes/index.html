<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>《算法导论》 第十三章笔记 - 三叔胡言乱语的地方</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="三叔胡言乱语的地方"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="三叔胡言乱语的地方"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="《算法导论》 第十三章笔记 红黑树实现"><meta property="og:type" content="blog"><meta property="og:title" content="《算法导论》 第十三章笔记"><meta property="og:url" content="https://xuejiaw.github.io/IA-Chapter13-Notes/"><meta property="og:site_name" content="三叔胡言乱语的地方"><meta property="og:description" content="《算法导论》 第十三章笔记 红黑树实现"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://xuejiaw.github.io/IA-Chapter13-Notes/IA-Chapter13-Notes/2019-11-06-16-54-51.png"><meta property="og:image" content="https://xuejiaw.github.io/IA-Chapter13-Notes/IA-Chapter13-Notes/2019-11-07-00-05-44.png"><meta property="og:image" content="https://xuejiaw.github.io/IA-Chapter13-Notes/IA-Chapter13-Notes/2019-11-07-10-52-42.png"><meta property="og:image" content="https://xuejiaw.github.io/IA-Chapter13-Notes/IA-Chapter13-Notes/2019-11-09-20-08-02.png"><meta property="og:image" content="https://xuejiaw.github.io/IA-Chapter13-Notes/IA-Chapter13-Notes/2019-11-09-20-30-37.png"><meta property="og:image" content="https://xuejiaw.github.io/IA-Chapter13-Notes/IA-Chapter13-Notes/2019-11-09-20-35-41.png"><meta property="og:image" content="https://xuejiaw.github.io/IA-Chapter13-Notes/IA-Chapter13-Notes/2019-11-09-20-44-24.png"><meta property="og:image" content="https://xuejiaw.github.io/IA-Chapter13-Notes/IA-Chapter13-Notes/2019-11-16-15-17-38.png"><meta property="og:image" content="https://xuejiaw.github.io/IA-Chapter13-Notes/IA-Chapter13-Notes/2019-11-16-17-09-19.png"><meta property="og:image" content="https://xuejiaw.github.io/IA-Chapter13-Notes/IA-Chapter13-Notes/2019-11-16-16-28-06.png"><meta property="og:image" content="https://xuejiaw.github.io/IA-Chapter13-Notes/IA-Chapter13-Notes/2019-11-16-17-31-28.png"><meta property="og:image" content="https://xuejiaw.github.io/IA-Chapter13-Notes/IA-Chapter13-Notes/2019-11-16-17-39-14.png"><meta property="og:image" content="https://xuejiaw.github.io/IA-Chapter13-Notes/IA-Chapter13-Notes/2019-11-16-18-16-43.png"><meta property="og:image" content="https://xuejiaw.github.io/IA-Chapter13-Notes/IA-Chapter13-Notes/2019-11-16-18-20-17.png"><meta property="article:published_time" content="2019-11-16T15:12:31.000Z"><meta property="article:modified_time" content="2023-04-02T12:23:06.561Z"><meta property="article:author" content="三叔"><meta property="article:tag" content="读书笔记"><meta property="article:tag" content="数据结构与算法"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://xuejiaw.github.io/IA-Chapter13-Notes/IA-Chapter13-Notes/2019-11-06-16-54-51.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://xuejiaw.github.io/IA-Chapter13-Notes/"},"headline":"《算法导论》 第十三章笔记","image":["https://xuejiaw.github.io/IA-Chapter13-Notes/IA-Chapter13-Notes/2019-11-06-16-54-51.png","https://xuejiaw.github.io/IA-Chapter13-Notes/IA-Chapter13-Notes/2019-11-07-00-05-44.png","https://xuejiaw.github.io/IA-Chapter13-Notes/IA-Chapter13-Notes/2019-11-07-10-52-42.png","https://xuejiaw.github.io/IA-Chapter13-Notes/IA-Chapter13-Notes/2019-11-09-20-08-02.png","https://xuejiaw.github.io/IA-Chapter13-Notes/IA-Chapter13-Notes/2019-11-09-20-30-37.png","https://xuejiaw.github.io/IA-Chapter13-Notes/IA-Chapter13-Notes/2019-11-09-20-35-41.png","https://xuejiaw.github.io/IA-Chapter13-Notes/IA-Chapter13-Notes/2019-11-09-20-44-24.png","https://xuejiaw.github.io/IA-Chapter13-Notes/IA-Chapter13-Notes/2019-11-16-15-17-38.png","https://xuejiaw.github.io/IA-Chapter13-Notes/IA-Chapter13-Notes/2019-11-16-17-09-19.png","https://xuejiaw.github.io/IA-Chapter13-Notes/IA-Chapter13-Notes/2019-11-16-16-28-06.png","https://xuejiaw.github.io/IA-Chapter13-Notes/IA-Chapter13-Notes/2019-11-16-17-31-28.png","https://xuejiaw.github.io/IA-Chapter13-Notes/IA-Chapter13-Notes/2019-11-16-17-39-14.png","https://xuejiaw.github.io/IA-Chapter13-Notes/IA-Chapter13-Notes/2019-11-16-18-16-43.png","https://xuejiaw.github.io/IA-Chapter13-Notes/IA-Chapter13-Notes/2019-11-16-18-20-17.png"],"datePublished":"2019-11-16T15:12:31.000Z","dateModified":"2023-04-02T12:23:06.561Z","author":{"@type":"Person","name":"三叔"},"publisher":{"@type":"Organization","name":"三叔胡言乱语的地方","logo":{"@type":"ImageObject","url":{"text":"三叔胡言乱语的地方"}}},"description":"《算法导论》 第十三章笔记 红黑树实现"}</script><link rel="canonical" href="https://xuejiaw.github.io/IA-Chapter13-Notes/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">三叔胡言乱语的地方</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-11-16T15:12:31.000Z" title="2019/11/16 23:12:31">2019-11-16</time>发表</span><span class="level-item"><time dateTime="2023-04-02T12:23:06.561Z" title="2023/4/2 20:23:06">2023-04-02</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a><span> / </span><a class="link-muted" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></span><span class="level-item">1 小时读完 (大约7989个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">《算法导论》 第十三章笔记</h1><div class="content"><p>《算法导论》 第十三章笔记 红黑树实现</p>
<span id="more"></span>
<h1>Chapter 13. Red-Black Trees</h1>
<p>红黑树是众多让二叉搜索树达到平衡的树形结构之一。树达到平衡可以保证动态操作，如删除，插入，搜索等，复杂度都为$O(lgn)$。</p>
<h2 id="Properties-of-red-black-trees">Properties of red-black trees</h2>
<p>红黑树是一种特殊的二叉搜索树，每个结点需要花费额外一个bit来存储结点的颜色信息，颜色为红或者黑。红黑树保证了整棵树，不会有一个路径是另一个路径的两倍长。</p>
<p>红黑树满足以下五个特性：</p>
<ol>
<li>所有结点要么是黑要么是红</li>
<li>根节点是黑色的</li>
<li>每个叶子（这里指NULL结点）是黑色的</li>
<li>如果一个结点是红色的，那么他的两个子结点是黑色的（即不会有连续的两层是红）</li>
<li>所有结点到任意叶子的简单路径上（不存在绕行）有相同的黑色结点数</li>
</ol>
<p>将任意结点到叶子的路径上黑色结点的数目成为<code>黑高(black-height)</code>，表达为$bh(x)$。将一棵树的黑高定义为：根节点到叶子的黑高。</p>
<ul>
<li>黑高的计算并不包含结点自己。例如，根节点必然是黑色的，但如果一棵树，只有根节点，那么他的黑高是0，因为根节点并不纳入黑高的计算。</li>
</ul>
<p>用一个哨兵（用<code>T.nil</code>表示）来指代叶子结点（NULL），这样所有的叶子和根节点的父节点都为<code>T.nil</code>。</p>
<p>将除了叶子结点外的所有结点成为<code>内部结点(internal nodes)</code>，否则为外部结点<code>external nodes</code></p>
<article class="message is-info">
        
        <div class="message-body">
            <p>定理：一个有$n$个内部结点的红黑树，其高度最多为$2\lg (n+1)$</p>

        </div>
    </article>
<p>定理证明如下：</p>
<ol>
<li>
<p>首先需要证明定理：对于任意一个结点$x$，至少有$2^{bh(x)}-1$个内部子结点</p>
<p>用推导法证明该定理：</p>
<p>(1)如果结点<code>x</code>的高度是0，则<code>x</code>一定是叶子结点。其黑高为0，那么内部子节点为$2^0-1=0$，即0个内部子节点，满足</p>
<p>(2) 如果结点<code>x</code>的高度不为0，且有两个子结点。根据特性5，可以推得如果这个子结点是红色，则这个子结点的黑高为$bh(x)$，如果子结点是黑色，则子结点的黑高为$bh(x)-1$。</p>
<p>因为$x$的黑高为$bh(x)$，如果子结点是黑色的，则这个子结点本身提供了一个黑色结点，所以它的黑高只能为父结点黑高减1，即$bh(x)-1$，反之子结点是红色的，那么这个结点不提供黑色结点，他的黑高和父结点一样，为$bh(x)$</p>
<p>所以结点$x$至少有 $2*(2^{bh(x)-1}-1) +1$个结点，这里两个子结点的各自内部子结点数计算都取更小的黑高数$bh(x)-1$，式子最后实际上应该是+2的，即$x$的两个子结点，但这里取更小的1，式子计算得$2^{bh(x)}-1$，即满足定理。</p>
</li>
<li>
<p>根据红黑树的特性4，红色结点的子结点必为黑色。所以红色结点出现最多的情况也只能是红黑相间，红色结点不可能连续出现而黑色结点可以。因此一个节点的黑高数最起码是其高度的一半，即$bh(x)&gt;\frac{h}{2}$。</p>
</li>
<li>
<p>结合1和2中得出的结论。1中得出了</p>
<p>$$<br>
n \geq 2^{bh(x)}-1<br>
$$</p>
<p>2中得出了</p>
<p>$$<br>
bh(x)&gt;\frac{h}{2}<br>
$$</p>
<p>所以</p>
<p>$$<br>
n \geq 2^{bh(x)}-1 \geq 2^{\frac{h}{2}} -1<br>
$$</p>
<p>即</p>
<p>$$<br>
2^{\frac{h}{2}} \leq n+1<br>
$$</p>
<p>即</p>
<p>$$<br>
h \leq 2 \lg (n+1)<br>
$$</p>
<p>得证。</p>
</li>
</ol>
<p>因为一个有$n$个结点的红黑树，其高度$h$最多为$2\lg (n+1)$，且二叉搜索树的操作时间复杂度都为$O(h)$，所以红黑树操作的时间复杂度为$O(\lg n)$</p>
<h2 id="Rotations">Rotations</h2>
<p>红黑树的插入和删除操作都可能破坏红黑树特性。为了保证红黑树的特性，可以在两个操作后通过修改结点的颜色，和改变树的部分结构保证其仍然满足红黑树的特性。</p>
<p>通过<code>Rotate</code>操作来修改树的部分结构，这个操作要保证修改树结构的同时<strong>不会影响二叉搜索树的特性</strong>。<code>Rotate</code>分为<code>leftRotate</code>和<code>rightRotate</code>，因为两个操作基本是镜像的，所以这里只对<code>leftRotate</code>作具体分析。</p>
<p>在对于一个结点$x$进行左旋时，$x$必须含有右子树，将$x$的右子树称为$y$。左旋操作的支点可以看作是$x$和$y$的交界点，左旋操作为：用y替换x的位置，将$y$原先的左子树变为$x$的右子树,将$x$变为$y$的左子树，。</p>
<p>左旋和右旋的示意图如下：从左到右是对于y的右旋，从右到左是对x的左旋</p>
<ul>
<li>无论是左旋还是右旋，被旋转的节点深度都+1，（变得更靠下）</li>
</ul>
<p><img src="IA-Chapter13-Notes/2019-11-06-16-54-51.png" alt="左旋及右旋操作"></p>
<p>左旋操作的伪代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">TREE-ROTATE(T,x)</span><br><span class="line"></span><br><span class="line">y = x.right;</span><br><span class="line"></span><br><span class="line">//用y替换x的位置</span><br><span class="line">y.p = x.p</span><br><span class="line">if( x.p == NULL)</span><br><span class="line">    T.root = y</span><br><span class="line">else if ( x == x.p.left )</span><br><span class="line">    x.p.left = y</span><br><span class="line">else</span><br><span class="line">    x.p.right = y</span><br><span class="line"></span><br><span class="line">//将y的左结点变为x的右结点</span><br><span class="line">x.right = y.left</span><br><span class="line">if y.left != NULL</span><br><span class="line">y.left.p = x</span><br><span class="line"></span><br><span class="line">//将x作为y的左子树</span><br><span class="line">y.left = x</span><br><span class="line">x.p = y</span><br></pre></td></tr></table></figure>
<p>c++代码的实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">RBTree::LeftRotate</span><span class="params">(RBTreeNode* node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (node == nullNode || node-&gt;right == nullNode)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Invalid operation: LeftRotate&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	RBTreeNode* lowerRight = node-&gt;right;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//lowerRight replace node&#x27;s place</span></span><br><span class="line">	lowerRight-&gt;parent = node-&gt;parent;</span><br><span class="line">	<span class="keyword">if</span> (node-&gt;parent == nullNode)</span><br><span class="line">	&#123;</span><br><span class="line">		rootNode = lowerRight;</span><br><span class="line">		nullNode-&gt;right = rootNode;</span><br><span class="line">		nullNode-&gt;left = rootNode;</span><br><span class="line">		nullNode-&gt;parent = rootNode;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (node == node-&gt;parent-&gt;left)</span><br><span class="line">	&#123;</span><br><span class="line">		node-&gt;parent-&gt;left = lowerRight;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		node-&gt;parent-&gt;right = lowerRight;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//lowerRight&#x27;s left subtree become node&#x27;s right subtree</span></span><br><span class="line">	node-&gt;right = lowerRight-&gt;left;</span><br><span class="line">	<span class="keyword">if</span> (lowerRight-&gt;left != nullNode)</span><br><span class="line">	&#123;</span><br><span class="line">		lowerRight-&gt;left-&gt;parent = node;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//node as lowerRight&#x27;s left subtree</span></span><br><span class="line">	node-&gt;parent = lowerRight;</span><br><span class="line">	lowerRight-&gt;left = node;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>右旋操作与左旋操作对称，只要将左旋操作中的left都换为right,right都换为left即可。</p>
<p>这里直接给出右旋操作的c++代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">RBTree::RightRotate</span><span class="params">(RBTreeNode* node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//As the symmetry of LeftRotate</span></span><br><span class="line">	<span class="keyword">if</span> (node == nullNode || node-&gt;left == nullNode)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	RBTreeNode* lowerLeft = node-&gt;left;</span><br><span class="line"></span><br><span class="line">	lowerLeft-&gt;parent = node-&gt;parent;</span><br><span class="line">	<span class="keyword">if</span> (node-&gt;parent == nullNode)</span><br><span class="line">	&#123;</span><br><span class="line">		rootNode = lowerLeft;</span><br><span class="line">		nullNode-&gt;left = rootNode;</span><br><span class="line">		nullNode-&gt;right = rootNode;</span><br><span class="line">		nullNode-&gt;parent = rootNode;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (node == node-&gt;parent-&gt;right)</span><br><span class="line">	&#123;</span><br><span class="line">		node-&gt;parent-&gt;right = lowerLeft;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		node-&gt;parent-&gt;left = lowerLeft;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	node-&gt;left = lowerLeft-&gt;right;</span><br><span class="line">	<span class="keyword">if</span> (lowerLeft-&gt;right != nullNode)</span><br><span class="line">	&#123;</span><br><span class="line">		lowerLeft-&gt;right-&gt;parent = node;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	node-&gt;parent = lowerLeft;</span><br><span class="line">	lowerLeft-&gt;right = node;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>左旋及右旋操作的时间复杂度都为$O(1)$</p>
<h2 id="Insertion">Insertion</h2>
<p>红黑树插入算法的思想为，先像普通的二叉搜索树一样插入结点，然后调用<code>RB-INSERT-FIXUP</code>函数调整树使其满足红黑树特性。</p>
<p>红黑树插入算法与普通的二叉搜索树插入算法主要有四个区别：</p>
<ol>
<li>
<p>用<code>T.nil</code>替代<code>NULL</code></p>
</li>
<li>
<p>将<code>T.nil</code>设为新插入结点的子结点</p>
</li>
<li>
<p>新插入结点的颜色为红色</p>
<p>这是为了保证性质5。如果新插入的结点设为黑色，那么新结点所在路径黑高则会增加，而另一条路径不变，则违背了性质5）。</p>
</li>
<li>
<p>插入后，调用<code>RB-INSERT-FIXUP</code>函数</p>
</li>
</ol>
<p>Insert伪代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">RB-INSERT(T,z)</span><br><span class="line"></span><br><span class="line">z.left = T.nil</span><br><span class="line">z.right = T.nil</span><br><span class="line">z. color = RED</span><br><span class="line"></span><br><span class="line">y = T.nil</span><br><span class="line">x = T.root</span><br><span class="line">while x != T.nil</span><br><span class="line">    y = x</span><br><span class="line">    if z.key &lt; x.key</span><br><span class="line">        x = x.left</span><br><span class="line">    else</span><br><span class="line">        x= x.right</span><br><span class="line">z.p = y</span><br><span class="line">if y == T.nil</span><br><span class="line">    T.root = z</span><br><span class="line">else if z.key &lt; y.key</span><br><span class="line">    y.left = z</span><br><span class="line">else</span><br><span class="line">    y.right = z</span><br><span class="line"></span><br><span class="line">RB-INSERT-FIXUP(T,z)</span><br></pre></td></tr></table></figure>
<p>c++ 实现如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">RBTree::Insert</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	RBTreeNode* toInsert = <span class="keyword">new</span> <span class="built_in">RBTreeNode</span>();</span><br><span class="line">	toInsert-&gt;value = value;</span><br><span class="line">	toInsert-&gt;color = RED;</span><br><span class="line">	toInsert-&gt;right = nullNode;</span><br><span class="line">	toInsert-&gt;left = nullNode;</span><br><span class="line"></span><br><span class="line">	RBTreeNode* targetNode = rootNode;</span><br><span class="line">	RBTreeNode* targetNodeParent = nullNode;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (targetNode != nullNode)</span><br><span class="line">	&#123;</span><br><span class="line">		targetNodeParent = targetNode;</span><br><span class="line">		<span class="keyword">if</span> (value &lt; targetNode-&gt;value)</span><br><span class="line">		&#123;</span><br><span class="line">			targetNode = targetNode-&gt;left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (value &gt; targetNode-&gt;value)</span><br><span class="line">		&#123;</span><br><span class="line">			targetNode = targetNode-&gt;right;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (targetNodeParent == nullNode)<span class="comment">//Tree is empty</span></span><br><span class="line">	&#123;</span><br><span class="line">		rootNode = toInsert;</span><br><span class="line">		rootNode-&gt;parent = nullNode;</span><br><span class="line">		nullNode-&gt;left = rootNode;</span><br><span class="line">		nullNode-&gt;right = rootNode;</span><br><span class="line">		nullNode-&gt;parent = rootNode;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (value &lt; targetNodeParent-&gt;value)</span><br><span class="line">		&#123;</span><br><span class="line">			targetNodeParent-&gt;left = toInsert;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			targetNodeParent-&gt;right = toInsert;</span><br><span class="line">		&#125;</span><br><span class="line">		toInsert-&gt;parent = targetNodeParent;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">InsertFixUp</span>(toInsert);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后面要解决的问题就是函数<code>RB-INSERT-FIXUP(T,z)</code>的实现，在进入讨论前，需要先明确几点</p>
<ol>
<li>
<p>性质1不可能违背，因为新插入的结点是红色</p>
</li>
<li>
<p>性质3不可能违背，因为新插入的结点两个叶子设为了黑色</p>
</li>
<li>
<p>性质5不可能违背，因为新插入的结点为红色，且替换的是原来NULL的地方</p>
</li>
<li>
<p>可能违背的只有性质2和性质4。</p>
<p>当新插入的结点$z$是根节点时，违背性质2</p>
<p>当新插入的结点父节点是红色时，违背性质4</p>
</li>
<li>
<p>在每次插入新结点前，树的状态一定是满足红黑树的，这意味着同时性质2和性质4最多被违背一个。</p>
<p>如果违背了性质2，那么说明新插入的$z$是树中唯一的结点，那么不可能违背性质4</p>
<p>如果违背了性质4，那么说明$z$和$z.p$都为红色。$z.p$不可能是根节点，不然在插入$z$前就已经为违背了红黑树特性2，$z.p.p$必然为黑色，否则也是在插入前就违背了性质4。因此违背性质4的情况下，不可能违背性质2。</p>
</li>
</ol>
<p>这里算法更多的是关注违背性质4时的处理方式，因为性质2比较好修复，只要将根节点的颜色改变即可。</p>
<p><code>RB-INSERT-FIXUP(T,z)</code>算法一共对插入新结点后，可能出现的违背红黑树原则的6种情况进行修复。前三种情况出现在$z.p$是$z.p.p$的左结点，后三种情况是$z.p$是$z.p.p$的右结点。前三种与后三种情况的修复是对称的，将前三种修复时的左旋操作改成右旋操作即为后三种情况的修复。因此这里只关注于前三种情况的讲解。</p>
<p>前三种(z.p = z.p.p.left )情况的区分在于$z$的$uncle$的颜色，即$z.p.p.right$的颜色。</p>
<ol>
<li>如果$z.p.p.right$为红色，无论$z$是$z.p$的哪科子树，都为情况1。</li>
<li>如果$z.p.p.right$为黑色，且$z$是$z.p$是右子树，则为情况2。</li>
<li>如果$z.p.p.right$为黑色，且$z$是$z.p$是左子树，则为情况3。</li>
</ol>
<p><img src="IA-Chapter13-Notes/2019-11-07-00-05-44.png" alt="三种情况的示意图"></p>
<p>对于情况1的修复：</p>
<p>如图示，$z$为红色，$z.p$和$z.uncle$都是红色。情况1的修复步骤为：</p>
<ol>
<li>
<p>将$z.p$和$z.uncle$都变为黑色</p>
<p>这样违背性质4的连续红色结点就消失了。</p>
</li>
<li>
<p>将$z.p.p$变为红色</p>
<p>因为$z.p$和$z.uncle$都变成了黑色，所有包含他们的通路，黑高都+1。考虑到包含了$z.p$和$z.uncle$的通路必然都包含$z.p.p$，所以为了保证通路上的黑高不变，将$z.p.p$变为红，这样增加的黑高就弥补了。</p>
</li>
<li>
<p>将$z$指针指向$z.p.p$</p>
<p>因为将$z.p.p$变为了红色，所以可能$z.p.p$和$z.p.p.p$会出现违背性质4的情况。将$z$指针指向$z.p.p$即可重新通过<code>RB-INSERT-FIXUP(T,z)</code>算法进行判断。</p>
</li>
</ol>
<p>情况1修复的图解如下：</p>
<p><img src="IA-Chapter13-Notes/2019-11-07-10-52-42.png" alt="情况1的修复"></p>
<p>对于情况2、3的修复：</p>
<p>在情况2和3下，$z.uncle$是黑色，因此$z.uncle$和$z.p$的颜色不同，也就不能像情况1的修复一样统一改成黑色，不然会影响他们子树的黑高。因此这两种情况需要用到旋转来修复。</p>
<p>情况2下$z$作为$z.p$的右子树，因此可以对$z.p$进行左旋。于$z.p$进行左旋后，将原先$z.p$定义为$z$即转换为了情况3，如下图所示</p>
<p><img src="IA-Chapter13-Notes/2019-11-09-20-08-02.png" alt="情况2转换为情况3"></p>
<p>对于情况3，我们对$z.p.p$，即上图中的$C$进行右旋。旋转后如下图所示。</p>
<p><img src="IA-Chapter13-Notes/2019-11-09-20-30-37.png" alt="情况3对于z.p.p右旋"></p>
<p>可以看到路径存在$A$结点的树的黑高都减一（原先父结点是黑色的$C$,现在变成了红色的$B$），而包含$C$结点的路径黑高是不变的。而且此时$A$和$B$还是不满足性质4。这里再将原先的$B$调整为黑色，原先的$C$调整为红色。对于包含$A$的路径而言，黑高+1，对于包含$C$的路径而言，黑高不变，因为路径上一个结点变成了红，一个结点变成了黑。因此情况三的最终变化如下：</p>
<p><img src="IA-Chapter13-Notes/2019-11-09-20-35-41.png" alt="情况3变化"></p>
<p>情况3调整后性质4和5都满足了，而不像情况1调整后仍然可能存在违背性质4的可能。</p>
<p>另外对于情况2和3的处理，不能是情况3通过右旋$z.p$来转换为情况2再进行修复。因为如果在情况2下对$C$进行右旋，会出现如下情况。</p>
<p><img src="IA-Chapter13-Notes/2019-11-09-20-44-24.png" alt="对情况2进行直接修复"></p>
<p>此时满足了性质4，但是包含$\alpha$结点路径的黑高少了1，如果为了满足性质5将$A$结点和$C$结点调整颜色，那么$C$结点和$B$结点又会违背性质4。</p>
<p>情况4，5，6的调整与情况1，2，3是镜像这里就不复述了。</p>
<p>整个给出<code>RB-INSERT-FIXUP(T,z)</code>的伪代码实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">RB-INSERT-FIXUP(T,z)</span><br><span class="line"></span><br><span class="line">while z.p.color == RED</span><br><span class="line">	if z.p == z.p.p.left // Case 1,2,3</span><br><span class="line">		y= z.p.p.right</span><br><span class="line">		if (y.color == RED) //Case 1</span><br><span class="line">			z.p.color = BLACK</span><br><span class="line">			y.color = BLACK</span><br><span class="line">			z.p.p.color = RED</span><br><span class="line">			z = z.p.p</span><br><span class="line">		else</span><br><span class="line">			if z == z.p.right //Case 2</span><br><span class="line">				z = z.p</span><br><span class="line">				LEFT-ROTATE(T,z)</span><br><span class="line">			z.p.color = BLACK // Case 3,下一次循环将直接退出</span><br><span class="line">			z.p.p.color = RED</span><br><span class="line">			RIGHT-ROTATE(T,z.p.p)</span><br><span class="line">	else //Case 4,5,6</span><br><span class="line">		...</span><br><span class="line">		//和情况1,2,3类似，将right和left对调即可</span><br><span class="line">T.root.color = BLACK //保证性质2</span><br></pre></td></tr></table></figure>
<p>c++代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RBTree::InsertFixUp</span><span class="params">(RBTreeNode* node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (node-&gt;parent-&gt;color == RED)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (node-&gt;parent == node-&gt;parent-&gt;parent-&gt;left)<span class="comment">//The first three cases</span></span><br><span class="line">		&#123;</span><br><span class="line">			RBTreeNode* uncle = node-&gt;parent-&gt;parent-&gt;right;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (uncle-&gt;color == RED) <span class="comment">//Case 1</span></span><br><span class="line">			&#123;</span><br><span class="line">				node-&gt;parent-&gt;color = BLACK;</span><br><span class="line">				uncle-&gt;color = BLACK;</span><br><span class="line">				node-&gt;parent-&gt;parent-&gt;color = RED;</span><br><span class="line">				node = node-&gt;parent-&gt;parent;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (node == node-&gt;parent-&gt;right) <span class="comment">//Case 2</span></span><br><span class="line">				&#123;</span><br><span class="line">					node = node-&gt;parent;</span><br><span class="line">					<span class="built_in">LeftRotate</span>(node);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">//Case3</span></span><br><span class="line">				node-&gt;parent-&gt;color = BLACK;</span><br><span class="line">				node-&gt;parent-&gt;parent-&gt;color = RED;</span><br><span class="line">				<span class="built_in">RightRotate</span>(node-&gt;parent-&gt;parent);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//The remainging three cases, as the symmetry of the first three</span></span><br><span class="line"></span><br><span class="line">			RBTreeNode* uncle = node-&gt;parent-&gt;parent-&gt;left;</span><br><span class="line">			<span class="keyword">if</span> (uncle-&gt;color == RED)</span><br><span class="line">			&#123;</span><br><span class="line">				node-&gt;parent-&gt;color = BLACK;</span><br><span class="line">				uncle-&gt;color = BLACK;</span><br><span class="line">				node-&gt;parent-&gt;parent-&gt;color = RED;</span><br><span class="line">				node = node-&gt;parent-&gt;parent;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (node == node-&gt;parent-&gt;left)</span><br><span class="line">				&#123;</span><br><span class="line">					node = node-&gt;parent;</span><br><span class="line">					<span class="built_in">RightRotate</span>(node);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				node-&gt;parent-&gt;color = BLACK;</span><br><span class="line">				node-&gt;parent-&gt;parent-&gt;color = RED;</span><br><span class="line">				<span class="built_in">LeftRotate</span>(node-&gt;parent-&gt;parent);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	rootNode-&gt;color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为<code>RB-INSERT</code>操作是一层层的向下搜索可以插入的点，所以复杂度与树的高度有关，即为$O(\lg n)$，<code>RB-INSERT-FIXUP</code>操作只有在情况1的情况下会继续循环，且每次循环前都将$z$向上移两位，因此执行次数是层数的一半，时间复杂度也为$O(\lg n)$。综上，红黑树插入操作总体的时间复杂度为$O(\lg n)$。</p>
<h2 id="Deletion">Deletion</h2>
<p>如二叉搜索树一样，红黑树的删除操作同样需要<code>Transplant</code>操作来用一个结点替换另一个，这里与二叉搜索树不同的只是将<code>Null</code>变为了<code>T.nil</code>，以及在设置$v.p$时不需要额外的判断，因为即使$v$是哨兵，访问$v.p$也不会出错</p>
<p>伪代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RB-TRANSPLANT(T,u,v)</span><br><span class="line">if u.p == T.nil</span><br><span class="line">	T.root = v</span><br><span class="line">else if u == u.p.left</span><br><span class="line">	u.p.left = v</span><br><span class="line">else</span><br><span class="line">	u.p.right = v</span><br><span class="line">v.p=u.p</span><br></pre></td></tr></table></figure>
<p>c++代码实现如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RBTree::TransPlant</span><span class="params">(RBTreeNode* originNode, RBTreeNode* newNode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (originNode-&gt;parent == nullNode)</span><br><span class="line">	&#123;</span><br><span class="line">		rootNode = newNode;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (originNode == originNode-&gt;parent-&gt;left)</span><br><span class="line">	&#123;</span><br><span class="line">		originNode-&gt;parent-&gt;left = newNode;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		originNode-&gt;parent-&gt;right = newNode;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	newNode-&gt;parent = originNode-&gt;parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在二叉搜索树的删除操作中，最复杂的情况，即被删除节点$z$有两个子树，且他的<code>successor</code>不是$z$的右子树。</p>
<p>这时候需要执行的操作是，将$successor.right$替换$successnor$的位置，再用$successor$替换$z$的位置。因为整个操作牵扯到三个节点$succcessor.right,successor,z$的变化，所以在红黑树的操作下，这三个结点都需要被确认是否会造成红黑树性质的破坏。</p>
<p>在删除算法中，将需要移进或者移出原先$z$位置的结点命名为$y$，需要记录$y$结点的位置，因为如果他是黑色的，那么他的移动会破坏红黑树的性质5。需要替代$y$位置的点用$x$表示。</p>
<p>删除操作的伪代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">y = z //这里y表示要移除z位置的结点，即z自己</span><br><span class="line">y-original-code = y.color</span><br><span class="line">if z.left == T.nil</span><br><span class="line">	x = z.right</span><br><span class="line">	RB-TRANSPLANT(T,y,x) //用z的右树替代z，即用x替代z，即用x替代y</span><br><span class="line">else if z.right = T.nil</span><br><span class="line">	x = z.left</span><br><span class="line">	RB-TRANSPLANT(T,y,x) //用z的左树替代z，即用x替代z，即用x替代y</span><br><span class="line">else</span><br><span class="line">	y = TREE-MINIMUM(z.right) //y表示z.successor，这里y表示需要移进z位置的结点</span><br><span class="line">	x = y.right //如普通的搜索二叉树一样，用y的右子树替代y的位置</span><br><span class="line">	if y.p == z</span><br><span class="line">		x.p = z //在普通二叉搜索树中，y.p == z的情况不需要任何操作，这里因为设置了x，所以需要为x指定父节点</span><br><span class="line">	else</span><br><span class="line">		RB-TRANSPLANT(T,y,x) //TRANSPLANT操作同时也为x设置了父结点，即x.p = y.p</span><br><span class="line">		y.right = z.right</span><br><span class="line">		y.right.p = y</span><br><span class="line">	RB-TRANSPLANT(T,z,y)</span><br><span class="line">	y.left = z.left</span><br><span class="line">	y.left.p = y</span><br><span class="line">	y.colour = z.clour //在y移动到了z的位置后，用z的颜色表示y的颜色，这样就保证了y有原先z.p不会违背性质4</span><br><span class="line">if(y-original-color == Black)//在原先的y结点是黑色的情况下，会引发问题（后面会解释），所以需要修复</span><br><span class="line">	RB-DELETE-FIXUP(T,x)</span><br></pre></td></tr></table></figure>
<p>在伪代码的最后，仅在原$y$结点颜色为黑色的时候调用修复函数<code>RB_DELETE_FIXUP</code>,因为$y$结点如果原先为红色，则不会违反任何的红黑树性质</p>
<ol>
<li>因为$y$是红的，所以移动$y$不会造成树的黑高的变化，性质5也就不会被破坏</li>
<li>因为在代码的20行将$z$的颜色赋给了$y$，所以不会发生$y$与$z.p$=破坏性质4的情况。</li>
<li>$x$作为替代$y$的结点，如果$y$是红的,$x$就是黑色的，移动$x$也不会造成破坏性质4的情况</li>
<li>$y$是红色的，$y$不可能是树的根，所以根也不会发生变化，性质2也不会被破坏</li>
<li>性质1，3在操作中根本没有相关改动的地方，肯定不会被破坏</li>
</ol>
<p>而$y$结点如果是黑色的，则可能会存在以下情况</p>
<ol>
<li>如果$y$根节点，而且$y$的子结点是红色，那么破坏性质2。</li>
</ol>
<ul>
<li>这种情况只有$y$表示的是移出$z$位置的结点时($y=z$)才可能发生。否则$y$移入$z$的位置，且$y$是黑色的，不可能破坏性质2。如果$y$表示是移出$z$位置，说明$z$最多只有一个子树，这种情况下$y$的子结点即为$x$。</li>
</ul>
<ol start="2">
<li>
<p>如果$x$和$x.p$都为红色，那么破坏性质4。</p>
<p>首先分析$x$和$x.p$的可能取值。</p>
<p>（1） $x$可能是$y.left$（在$z$只有左结点）或者$y.right$（在$z$有两种结点的情况或$z$只有右结点）。</p>
<p>（2） $x.p$在大部分情况下都为$y.p$，除了$x$在$z$有两个结点，且$y$是$z.right$的情况下，$x.p$=$y$。</p>
<p>因为$x$和$x.p$都是红色，且$y$是黑的，所以$x.p$不能等于$y$。因此发生的情况一定是$z$有两个结点，且$y$不等于$z.right$或$y$只有右结点。即如下图所示的两种情况：</p>
<p><img src="IA-Chapter13-Notes/2019-11-16-15-17-38.png" alt="删除z违背性质4的情况"><br>
<img src="IA-Chapter13-Notes/2019-11-16-17-09-19.png" alt="删除z违背性质4的情况2"></p>
</li>
<li>
<p>任意包含了$y$的路径都会出现黑高减一的情况，违背性质5</p>
<p>(1) 在$y$表示移出$z$位置的结点的情况下(即 $y$ = $z$ )，因为$z$和$y$都是黑色，所以删除$z$结点必然会出现黑高减一</p>
<p>(2) 在$y$表示移入$z$位置的结点的情况下(即 $y$ = $z.successor$ )，仍然会出现黑高减一。如果$z$是黑色的，那么同样是$y$和$z$都是黑色，删除$z$结点出现黑高减一。如果$z$是红色的，删除$z$不会造成黑高减一，但是因为在算法的最后为了保证新移入的$y$不会与树的上层发生冲突，所以将$y$设为了原先$z$的颜色，即将$y$变为了黑色，因此同样黑高减一。</p>
</li>
</ol>
<p>在这里为了解决包含$y$的路径出现的黑高减一现象，将额外的一个黑色给予$x$结点，因为包含有$y$的路径一定包含$x$（因为$x$=$y$或者$y.right$）。因为修复了黑高减一的问题，性质5满足了，但因为$x$现在是拥有两个黑色，或者是一黑一红，因此违背了性质1，即所有结点要么是红色，要么是黑色。</p>
<ul>
<li>这里给$x$一个额外黑的操作并没有在代码中体现，只是一个思路。因此$x$的颜色在代码中判断，依然按$x$之前的颜色判断。</li>
</ul>
<p>因此RB-DELETE-FIXUP一共需要解决三个性质的问题即，性质1，2，4。且性质1是针对$x$结点，所以传递的参数为$x$结点。</p>
<p>RB-DELETE-FIXUP的伪代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">while x != T.root and x.color == BLACK</span><br><span class="line">	if x == x.p.left</span><br><span class="line">		w = x.p.right</span><br><span class="line">		if w.color == RED // 情况1</span><br><span class="line">			w. color = BLACK</span><br><span class="line">			x.p.color = RED</span><br><span class="line">			LEFT-ROTATE(T,x.p)</span><br><span class="line">			w = x.p.right // 新的w，因为新的w必然是黑色，所以情况1转换为1情况2/3/4</span><br><span class="line">		if w.left.color == BLACK and w.right.color == BLACK</span><br><span class="line">			w.color = RED</span><br><span class="line">			x = x.p</span><br><span class="line">		else</span><br><span class="line">			if w.right.color == BLACK</span><br><span class="line">				w.left.color = BLACK</span><br><span class="line">				w.color = RED</span><br><span class="line">				RIGHT-ROTATE(T,w)</span><br><span class="line">				w = x.p.right</span><br><span class="line">			w.color = x.p.color</span><br><span class="line">			x.p.color = BLACK</span><br><span class="line">			w.right.color = BLACK</span><br><span class="line">			LEFT-ROTATE(T,x.p)</span><br><span class="line">			x = T.root</span><br><span class="line">	else</span><br><span class="line">		....</span><br><span class="line">		//和情况1,2,3,4类似，将right和left对调即可</span><br><span class="line">x.color = BLACK</span><br></pre></td></tr></table></figure>
<p>这里的删除修复如同插入修复一样，有很多种情况，这里一共是8种情况。但是可以分为前四种和后四种，分割标准是$x$是$x.p$的左结点，还是右结点。这里我们只讨论$x$是左结点的情况，即前四种。后四种为前四种的对称，如同插入修复的对称一样,解法只要将前四种中的$left$改为$right$，反之亦然。</p>
<p>整个算法是一个循环和一个将x.color设为Black的语句。退出循环的条件是$x$是红色（实际上$x$有红-黑两个颜色属性）或$x$是根。</p>
<p>在这种情况下将$x$设为单一黑色（即x.color = Black）可以<strong>修复性质1</strong>，且不会破坏性质5，因为</p>
<pre><code>(1) 如果$x$是根，那么删除一个黑色，是整棵树的黑高都减一，依然满足性质5

(2) 如果$x$是红-黑，即贡献了一个黑高，设为黑色后，依然是贡献一个黑高，满足性质5
</code></pre>
<p>将$x.color$设为黑色，因为$x$和$x.p$都为红色而造成的<strong>性质4的破坏也会被修复</strong>。</p>
<p>而且如上讨论，违背性质2的情况，必然是$z$最多只有一颗子树，即$y=z$，$x$作为$y$的子结点且为红色的情况，那么将$x$设为黑色，同样<strong>修复了性质2</strong>。这种情况下$x$就是根结点，并不会进入循环，将直接执行最后一句。</p>
<p>因此退出循环后的<code>x.color = BLACK</code>语句将同时修复性质1,2,4。现在需要关心的是该如何退出循环。</p>
<p>现在先分析前四种情况。这四种情况的分类是根据$x$的兄弟$w$（在$x$=$x.p.left$的情况下$w$即为$x.p.right$）。</p>
<ul>
<li>因为进入循环是$x$是两个黑色属性，所以$w$必然存在且一定有两个子结点。不然通过$x$抵达叶子的黑高一定大于到达$w$的黑高。$w$的子结点也必然有两个子结点，因为只有$w$与$w.left$或$w.right$都为黑色，才能刚好与$x$的两个黑色相抵。如果其中一个为红色，那么则需要更深的树才能抵消。</li>
</ul>
<ol>
<li>$w$是红色为情况1。</li>
</ol>
<p>如果$w$是黑色的，再细分为三个情况</p>
<ol start="2">
<li>
<p>$w$是黑色，且右结点是黑色，左结点是黑色为情况2</p>
</li>
<li>
<p>$w$是黑色，且右结点是黑色，左结点是红色，为情况3</p>
</li>
<li>
<p>$w$是黑色，且右结点是红色，左结点是红色或黑色，为情况4</p>
</li>
</ol>
<p>对于情况1的修复：</p>
<p>因为$w$是红色，所以$w.p$即$w.p$必然是黑色的。将$w.p$与$w$的颜色对调，且对$w.p$进行左旋，如下图所示，不会违背任何的红黑树性质。</p>
<p><img src="IA-Chapter13-Notes/2019-11-16-16-28-06.png" alt="情况1修复"></p>
<ul>
<li>上图以及之后其他的对于各种情况的修复图中，黑色结点表示黑色，深灰色结点，如上图中的$D$表示红色，浅灰色结点表示可能是黑可能是红。</li>
</ul>
<p>同样因为$w$是红色的，$w$的两个子结点也必然是黑色的，在上述的操作后，原$w$的左结点将会成为$x$的新兄弟，即成为新的$w$，为黑色。</p>
<p>如之前所述，$w$也必然有两个子结点，根据子结点的情况，情况1会变为情况2或3或4。</p>
<p>对于情况2的修复：</p>
<p>在情况2下，因为$x$是双重黑色，$w$是黑色，所以从他们两个结点中都取出一个黑色，即$x$变为单个黑色，$w$变为红色。将这个取出的黑色给予$x.p$。</p>
<p>这个操作只有在$w$的两个结点都是黑色的情况下（即情况2）才能执行，不然当$w$变为红色，将会与它的子结点违背性质4。</p>
<p>因为$x$和$w$都为黑色，所以$x.p$的颜色并不能确定（下图中由浅灰色表示），增加了额外黑色后，可能为黑-黑也可能为红-黑。</p>
<ul>
<li>从$x$和$w$中都取出一个黑色，相当于将$x.p$的两个子树的黑高都减一，而此时将黑色给予$x.p$相当于将将失去的黑高补了回来。</li>
</ul>
<p>此时$x.p$成为了破坏性质1的结点，因此将他设为新的$x$并再次进入循环。</p>
<ul>
<li>如果是由情况1转换为的情况2，那么再次进入循环后，将不满足循环条件直接退出循环。因为在情况1修复后$x.p$为红色，在情况2修复后被给予了额外的黑色后，变为红-黑，不满足循环条件，因此退出。</li>
</ul>
<p><img src="IA-Chapter13-Notes/2019-11-16-17-31-28.png" alt="情况2的修复"></p>
<p>对于情况3的修复：</p>
<p>情况3通过降$w$（黑色）与$w.left$（红色）的颜色对换，并对$w$执行右旋，再将原$w.left$设为新$w$转换为情况4。如下图所示。</p>
<p><img src="IA-Chapter13-Notes/2019-11-16-17-39-14.png" alt="情况3的修复"></p>
<p>对于情况4的修复：</p>
<p>在情况4中，先将$w$与$w.p$的颜色互换，然后对$w.p$进行左旋，$w$取代原先$w.p$的位置。如下图所示</p>
<p><img src="IA-Chapter13-Notes/2019-11-16-18-16-43.png" alt="情况4修复1"></p>
<p>分析三个结点$A$,$C$和$E$的黑高，发现$A$的黑高多了1，$C$的黑高不变，$E$的黑高少了1。因此我们将$A$的一个黑高给$E$，这样三个结点的黑高都不变。$A$结点即为$x$，原先有两个黑色，现在减去一个变成单独的黑色结点，满足性质1。$E$原先为红色，现在多了一个黑色，变为黑色结点。</p>
<p>因此情况4的最终修复效果如下</p>
<p><img src="IA-Chapter13-Notes/2019-11-16-18-20-17.png" alt="情况4修复2"></p>
<p>在这个情况下，所有的结点都满足了性质1。所以将$x$直接指向$T.root$来退出循环即可。</p>
<ul>
<li>之所以情况2无法直接退出循环，是因为在情况2的修复后，原$x.p$仍然破坏了性质1，所以需要进入循环继续修复。</li>
</ul>
<p>后四种情况的修复与前四种对称，这里不在赘述。</p>
<p><code>RB-DELETE</code>操作本身没有循环，所以时间复杂度由<code>TREE-MINIMUM</code>和<code>RB-DELETE-FIXUP</code>共同决定。</p>
<p>如同普通二叉搜索树，<code>TREE-MINIMUM</code>时间复杂度为$O(\lg n )$。</p>
<p>而<code>RB-DELETE-FIXUP</code>，只有情况2会再次进入循环，剩下的三种情况都是转换为其他情况或者在下一次直接退出循环。而情况2每次都会将$x$上移，所以在最坏情况下时间复杂度也为$O(\lg n)$。</p>
<p>综上<code>RB-DELETE</code>的时间复杂度为$O(\lg n ) + O(\lg n)$，即$O(\lg n)$。</p>
<p><code>RB-DELETE</code>与<code>RB-DELETE-FIXUP</code>的c++代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">RBTree::Delete</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	RBTreeNode* toDelete = <span class="built_in">Search</span>(value);</span><br><span class="line">	<span class="keyword">if</span> (toDelete == nullNode)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	RBTreeNode* toDeleteTrack = toDelete;<span class="comment">//this track will be removed from the tree</span></span><br><span class="line">	NodeColor originDeleteTrackColor = toDeleteTrack-&gt;color;</span><br><span class="line"></span><br><span class="line">	RBTreeNode* toReplaceTrack;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (toDelete-&gt;left == nullNode)</span><br><span class="line">	&#123;</span><br><span class="line">		toReplaceTrack = toDelete-&gt;right;</span><br><span class="line">		<span class="built_in">TransPlant</span>(toDelete, toReplaceTrack);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (toDelete-&gt;right == nullNode)</span><br><span class="line">	&#123;</span><br><span class="line">		toReplaceTrack = toDelete-&gt;left;</span><br><span class="line">		<span class="built_in">TransPlant</span>(toDelete, toReplaceTrack);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="comment">//Both children are not nullNode</span></span><br><span class="line">	&#123;</span><br><span class="line">		toDeleteTrack = <span class="built_in">GetMinimum</span>(toDelete-&gt;right);<span class="comment">//The track is Successor</span></span><br><span class="line">		<span class="comment">//This track will moved in toDelete&#x27;s postion</span></span><br><span class="line">		originDeleteTrackColor = toDeleteTrack-&gt;color;</span><br><span class="line"></span><br><span class="line">		toReplaceTrack = toDeleteTrack-&gt;right;</span><br><span class="line">		<span class="keyword">if</span> (toDeleteTrack-&gt;parent == toDelete)<span class="comment">//Track is toDelete&#x27;s rightChild</span></span><br><span class="line">		&#123;</span><br><span class="line">			toReplaceTrack-&gt;parent = toDeleteTrack;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">TransPlant</span>(toDeleteTrack, toReplaceTrack);</span><br><span class="line">			toDeleteTrack-&gt;right = toDelete-&gt;right;</span><br><span class="line">			toDeleteTrack-&gt;right-&gt;parent = toDeleteTrack;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">TransPlant</span>(toDelete, toDeleteTrack);</span><br><span class="line">		toDeleteTrack-&gt;left = toDelete-&gt;left;</span><br><span class="line">		toDeleteTrack-&gt;left-&gt;parent = toDeleteTrack;</span><br><span class="line">		toDeleteTrack-&gt;color = toDelete-&gt;color;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//set the pointer be null to ensure children and parent won&#x27;t be released</span></span><br><span class="line">		toDelete-&gt;parent = <span class="literal">nullptr</span>;</span><br><span class="line">		toDelete-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">		toDelete-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">		<span class="keyword">delete</span> toDelete;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (originDeleteTrackColor == BLACK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">DeleteFixUp</span>(toReplaceTrack);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RBTree::DeleteFixUp</span><span class="params">(RBTreeNode* toReplaceTrack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (toReplaceTrack != rootNode &amp;&amp; toReplaceTrack-&gt;color == BLACK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (toReplaceTrack == toReplaceTrack-&gt;parent-&gt;left) <span class="comment">//The first four cases</span></span><br><span class="line">		&#123;</span><br><span class="line">			RBTreeNode* uncle = toReplaceTrack-&gt;parent-&gt;right;</span><br><span class="line">			<span class="keyword">if</span> (uncle-&gt;color == RED)   <span class="comment">//case1</span></span><br><span class="line">			&#123;</span><br><span class="line">				uncle-&gt;color = BLACK;</span><br><span class="line">				toReplaceTrack-&gt;parent-&gt;color = RED;</span><br><span class="line">				<span class="built_in">LeftRotate</span>(toReplaceTrack-&gt;parent);</span><br><span class="line">				uncle = toReplaceTrack-&gt;parent-&gt;right;   <span class="comment">//to case 2/3/4</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (uncle-&gt;left-&gt;color == BLACK &amp;&amp; uncle-&gt;right-&gt;color == BLACK)</span><br><span class="line">			&#123;</span><br><span class="line">				uncle-&gt;color = RED;    <span class="comment">//case2</span></span><br><span class="line">				toReplaceTrack = toReplaceTrack-&gt;parent;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (uncle-&gt;right-&gt;color == BLACK)</span><br><span class="line">				&#123;</span><br><span class="line">					uncle-&gt;left-&gt;color = BLACK;</span><br><span class="line">					uncle-&gt;color = RED;</span><br><span class="line">					<span class="built_in">RightRotate</span>(uncle);   <span class="comment">// to case4</span></span><br><span class="line">					uncle = toReplaceTrack-&gt;parent-&gt;right;</span><br><span class="line">				&#125;</span><br><span class="line">				uncle-&gt;color = toReplaceTrack-&gt;parent-&gt;color;</span><br><span class="line">				toReplaceTrack-&gt;parent-&gt;color = BLACK;          <span class="comment">//case4;</span></span><br><span class="line">				uncle-&gt;right-&gt;color = BLACK;</span><br><span class="line">				<span class="built_in">RightRotate</span>(toReplaceTrack-&gt;parent);</span><br><span class="line">				toReplaceTrack = rootNode;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span><span class="comment">//The remaining four cases,as the symetry of the first four</span></span><br><span class="line">		&#123;</span><br><span class="line">			RBTreeNode* uncle = toReplaceTrack-&gt;parent-&gt;left;</span><br><span class="line">			<span class="keyword">if</span> (uncle-&gt;color == RED)</span><br><span class="line">			&#123;</span><br><span class="line">				uncle-&gt;color = BLACK;</span><br><span class="line">				toReplaceTrack-&gt;parent-&gt;color = RED;</span><br><span class="line">				<span class="built_in">RightRotate</span>(toReplaceTrack-&gt;parent);</span><br><span class="line">				uncle = toReplaceTrack-&gt;parent-&gt;left;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (uncle-&gt;right-&gt;color == BLACK &amp;&amp; uncle-&gt;left-&gt;color == BLACK)</span><br><span class="line">			&#123;</span><br><span class="line">				uncle-&gt;color = RED;</span><br><span class="line">				toReplaceTrack = toReplaceTrack-&gt;parent;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (uncle-&gt;left-&gt;color == BLACK)</span><br><span class="line">				&#123;</span><br><span class="line">					uncle-&gt;right-&gt;color = BLACK;</span><br><span class="line">					uncle-&gt;color = RED;</span><br><span class="line">					<span class="built_in">LeftRotate</span>(uncle);</span><br><span class="line">					uncle = toReplaceTrack-&gt;parent-&gt;left;</span><br><span class="line">				&#125;</span><br><span class="line">				uncle-&gt;color = toReplaceTrack-&gt;parent-&gt;color;</span><br><span class="line">				toReplaceTrack-&gt;parent-&gt;color = BLACK;</span><br><span class="line">				uncle-&gt;left-&gt;color = BLACK;</span><br><span class="line">				<span class="built_in">RightRotate</span>(toReplaceTrack-&gt;parent);</span><br><span class="line">				toReplaceTrack = rootNode;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	toReplaceTrack-&gt;color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<article class="message is-info">
        
        <div class="message-body">
            <p>引用：</p>
<ol>
<li><em>Introduction to Algorithms</em> 3rd Sep.2009</li>
</ol>

        </div>
    </article>
<hr>
</div><div class="article-licensing box"><div class="licensing-title"><p>《算法导论》 第十三章笔记</p><p><a href="https://xuejiaw.github.io/IA-Chapter13-Notes/">https://xuejiaw.github.io/IA-Chapter13-Notes/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>三叔</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2019-11-16</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2023-04-02</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a><a class="link-muted mr-2" rel="tag" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></div><!--!--></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/alipay.jpg" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/wechat.jpg" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/CNI-Chapter1-Notes/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">《计算机网络与因特网》 第一章笔记</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/IA-Chapter12-Notes/"><span class="level-item">《算法导论》 第十二章笔记</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="content" id="valine-thread"></div><script src="//cdn.jsdelivr.net/npm/leancloud-storage@3/dist/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@1.4.16/dist/Valine.min.js"></script><script>new Valine({
            el: '#valine-thread',
            appId: "TGA1EB8Nf5aw6uJBpw45pBJQ-gzGzoHsz",
            appKey: "z1vCYavVUbCGuMjNMcrsvShN",
            placeholder: "匿名的！不需要注册！想说啥直接说吧！",
            avatar: "mm",
            avatarForce: false,
            meta: ["nick","mail","link"],
            pageSize: 10,
            lang: "zh-CN",
            visitor: true,
            highlight: true,
            recordIP: false,
            
            
            
            enableQQ: true,
            requiredFields: [],
        });</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.jpg" alt="三叔"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">三叔</p><p class="is-size-6 is-block">XR 行业的 Unity 开发者</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">71</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">15</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">18</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://www.zhihu.com/people/wang-xue-jia-20" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/xuejiaW"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Zhihu" href="https://www.zhihu.com/people/wang-xue-jia-20"><i class="fab fa-zhihu"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Jike" href="https://web.okjike.com/u/9ca63fe3-362f-458a-84ba-ec92a1dad321"><i class="fa-solid fa-j"></i></a></div></div></div><!--!--><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E5%8D%9A%E6%96%87%E7%AC%94%E8%AE%B0/"><span class="level-start"><span class="level-item">博文笔记</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%99%E7%A8%8B/"><span class="level-start"><span class="level-item">教程</span></span><span class="level-end"><span class="level-item tag">8</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E6%95%99%E7%A8%8B/Git/"><span class="level-start"><span class="level-item">Git</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%99%E7%A8%8B/Hexo/"><span class="level-start"><span class="level-item">Hexo</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%99%E7%A8%8B/%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">标记语言</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%99%E7%A8%8B/%E7%BF%BB%E5%A2%99%E6%A2%AF%E5%AD%90/"><span class="level-start"><span class="level-item">翻墙梯子</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"><span class="level-start"><span class="level-item">论文笔记</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="level-start"><span class="level-item">读书笔记</span></span><span class="level-end"><span class="level-item tag">58</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"><span class="level-start"><span class="level-item">图形学</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="level-start"><span class="level-item">数据库</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">数据结构与算法</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/"><span class="level-start"><span class="level-item">游戏设计</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="level-start"><span class="level-item">计算机网络</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">计算机语言</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="level-start"><span class="level-item">设计模式</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-09-24T15:13:39.000Z">2020-09-24</time></p><p class="title"><a href="/LearnOpenGL-Notes-2/">《LearnOpenGL》 笔记（二）</a></p><p class="categories"><a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a> / <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%BD%A2%E5%AD%A6/">图形学</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-05-25T12:41:17.000Z">2020-05-25</time></p><p class="title"><a href="/LearnOpenGL-Notes-1/">《LearnOpenGL》 笔记 (一)</a></p><p class="categories"><a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a> / <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%BD%A2%E5%AD%A6/">图形学</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-05-13T23:07:55.000Z">2020-05-14</time></p><p class="title"><a href="/CPPPrimer-Chapter8-Notes/">《C++ Primer》 第八章笔记</a></p><p class="categories"><a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a> / <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/">计算机语言</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-04-13T14:08:54.000Z">2020-04-13</time></p><p class="title"><a href="/3DMathPrimerForGraphicsAGameDevelopment-Chapter9-Notes/">《3D数学基础：图形和游戏开发》第九章笔记</a></p><p class="categories"><a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a> / <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%BD%A2%E5%AD%A6/">图形学</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-04-07T06:55:42.000Z">2020-04-07</time></p><p class="title"><a href="/3DMathPrimerForGraphicsAGameDevelopment-Chapter8-Notes/">《3D数学基础：图形和游戏开发》第八章笔记</a></p><p class="categories"><a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a> / <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%BD%A2%E5%AD%A6/">图形学</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2020/"><span class="level-start"><span class="level-item">2020</span></span><span class="level-end"><span class="level-item tag">38</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/"><span class="level-start"><span class="level-item">2019</span></span><span class="level-end"><span class="level-item tag">32</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/"><span class="level-start"><span class="level-item">2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/3D%E6%95%B0%E5%AD%A6/"><span class="tag">3D数学</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hexo/"><span class="tag">Hexo</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OpenGL/"><span class="tag">OpenGL</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8D%9A%E6%96%87%E7%AC%94%E8%AE%B0/"><span class="tag">博文笔记</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"><span class="tag">图形学</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%88%E7%8E%87%E6%8F%90%E5%8D%87/"><span class="tag">效率提升</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="tag">数据库</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><span class="tag">数据结构与算法</span><span class="tag">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/"><span class="tag">标记语言</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/"><span class="tag">游戏设计</span><span class="tag">14</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BF%BB%E5%A2%99%E6%A2%AF%E5%AD%90/"><span class="tag">翻墙梯子</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%99%9A%E6%8B%9F%E7%8E%B0%E5%AE%9E/"><span class="tag">虚拟现实</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="tag">计算机网络</span><span class="tag">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"><span class="tag">论文笔记</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="tag">设计模式</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="tag">读书笔记</span><span class="tag">58</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/"><span class="tag">软件推荐</span><span class="tag">2</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">三叔胡言乱语的地方</a><p class="is-size-7"><span>&copy; 2023 三叔</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>