<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>《算法导论》 第十三章笔记 | 三叔胡言乱语的地方</title><meta name="author" content="三叔"><meta name="copyright" content="三叔"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="《算法导论》 第十三章笔记 红黑树实现">
<meta property="og:type" content="article">
<meta property="og:title" content="《算法导论》 第十三章笔记">
<meta property="og:url" content="https://tuncle.blog/IA-Chapter13-Notes/index.html">
<meta property="og:site_name" content="三叔胡言乱语的地方">
<meta property="og:description" content="《算法导论》 第十三章笔记 红黑树实现">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tuncle.blog/img/avatar.jpg">
<meta property="article:published_time" content="2019-11-16T15:12:31.000Z">
<meta property="article:modified_time" content="2023-04-16T06:32:59.817Z">
<meta property="article:author" content="三叔">
<meta property="article:tag" content="读书笔记">
<meta property="article:tag" content="数据结构与算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tuncle.blog/img/avatar.jpg"><link rel="shortcut icon" href="/img/avatar.jpg"><link rel="canonical" href="https://tuncle.blog/IA-Chapter13-Notes/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":true,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":200,"languages":{"author":"作者: 三叔","link":"链接: ","source":"来源: 三叔胡言乱语的地方","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '《算法导论》 第十三章笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-16 14:32:59'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">71</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img fixed" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="三叔胡言乱语的地方"><span class="site-name">三叔胡言乱语的地方</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">《算法导论》 第十三章笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2019-11-16T15:12:31.000Z" title="发表于 2019-11-16 23:12:31">2019-11-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>30分钟</span></span><span class="post-meta-separator">|</span><span class="leancloud_visitors" id="/IA-Chapter13-Notes/" data-flag-title="《算法导论》 第十三章笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span class="leancloud-visitors-count"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><p>《算法导论》 第十三章笔记 红黑树实现</p>
<span id="more"></span>
<h1 id="Chapter-13-Red-Black-Trees"><a href="#Chapter-13-Red-Black-Trees" class="headerlink" title="Chapter 13. Red-Black Trees"></a>Chapter 13. Red-Black Trees</h1><p>红黑树是众多让二叉搜索树达到平衡的树形结构之一。树达到平衡可以保证动态操作，如删除，插入，搜索等，复杂度都为$O(lgn)$。</p>
<h2 id="Properties-of-red-black-trees"><a href="#Properties-of-red-black-trees" class="headerlink" title="Properties of red-black trees"></a>Properties of red-black trees</h2><p>红黑树是一种特殊的二叉搜索树，每个结点需要花费额外一个bit来存储结点的颜色信息，颜色为红或者黑。红黑树保证了整棵树，不会有一个路径是另一个路径的两倍长。</p>
<p>红黑树满足以下五个特性：</p>
<ol>
<li>所有结点要么是黑要么是红</li>
<li>根节点是黑色的</li>
<li>每个叶子（这里指NULL结点）是黑色的</li>
<li>如果一个结点是红色的，那么他的两个子结点是黑色的（即不会有连续的两层是红）</li>
<li>所有结点到任意叶子的简单路径上（不存在绕行）有相同的黑色结点数</li>
</ol>
<p>将任意结点到叶子的路径上黑色结点的数目成为<code>黑高(black-height)</code>，表达为$bh(x)$。将一棵树的黑高定义为：根节点到叶子的黑高。</p>
<ul>
<li>黑高的计算并不包含结点自己。例如，根节点必然是黑色的，但如果一棵树，只有根节点，那么他的黑高是0，因为根节点并不纳入黑高的计算。</li>
</ul>
<p>用一个哨兵（用<code>T.nil</code>表示）来指代叶子结点（NULL），这样所有的叶子和根节点的父节点都为<code>T.nil</code>。</p>
<p>将除了叶子结点外的所有结点成为<code>内部结点(internal nodes)</code>，否则为外部结点<code>external nodes</code></p>
<div class="note info simple"><p>定理：一个有$n$个内部结点的红黑树，其高度最多为$2\lg (n+1)$</p>
</div>
<p>定理证明如下：</p>
<ol>
<li><p>首先需要证明定理：对于任意一个结点$x$，至少有$2^{bh(x)}-1$个内部子结点</p>
<p>用推导法证明该定理：</p>
<p>(1)如果结点<code>x</code>的高度是0，则<code>x</code>一定是叶子结点。其黑高为0，那么内部子节点为$2^0-1=0$，即0个内部子节点，满足</p>
<p>(2) 如果结点<code>x</code>的高度不为0，且有两个子结点。根据特性5，可以推得如果这个子结点是红色，则这个子结点的黑高为$bh(x)$，如果子结点是黑色，则子结点的黑高为$bh(x)-1$。</p>
<p>因为$x$的黑高为$bh(x)$，如果子结点是黑色的，则这个子结点本身提供了一个黑色结点，所以它的黑高只能为父结点黑高减1，即$bh(x)-1$，反之子结点是红色的，那么这个结点不提供黑色结点，他的黑高和父结点一样，为$bh(x)$</p>
<p>所以结点$x$至少有 $2*(2^{bh(x)-1}-1) +1$个结点，这里两个子结点的各自内部子结点数计算都取更小的黑高数$bh(x)-1$，式子最后实际上应该是+2的，即$x$的两个子结点，但这里取更小的1，式子计算得$2^{bh(x)}-1$，即满足定理。</p>
</li>
<li><p>根据红黑树的特性4，红色结点的子结点必为黑色。所以红色结点出现最多的情况也只能是红黑相间，红色结点不可能连续出现而黑色结点可以。因此一个节点的黑高数最起码是其高度的一半，即$bh(x)&gt;\frac{h}{2}$。</p>
</li>
<li><p>结合1和2中得出的结论。1中得出了</p>
<script type="math/tex; mode=display">
n \geq 2^{bh(x)}-1</script><p>2中得出了</p>
<script type="math/tex; mode=display">
bh(x)>\frac{h}{2}</script><p>所以</p>
<script type="math/tex; mode=display">
n \geq 2^{bh(x)}-1 \geq 2^{\frac{h}{2}} -1</script><p>即</p>
<script type="math/tex; mode=display">
2^{\frac{h}{2}} \leq n+1</script><p>即</p>
<script type="math/tex; mode=display">
h \leq 2 \lg (n+1)</script><p>得证。</p>
</li>
</ol>
<p>因为一个有$n$个结点的红黑树，其高度$h$最多为$2\lg (n+1)$，且二叉搜索树的操作时间复杂度都为$O(h)$，所以红黑树操作的时间复杂度为$O(\lg n)$</p>
<h2 id="Rotations"><a href="#Rotations" class="headerlink" title="Rotations"></a>Rotations</h2><p>红黑树的插入和删除操作都可能破坏红黑树特性。为了保证红黑树的特性，可以在两个操作后通过修改结点的颜色，和改变树的部分结构保证其仍然满足红黑树的特性。</p>
<p>通过<code>Rotate</code>操作来修改树的部分结构，这个操作要保证修改树结构的同时<strong>不会影响二叉搜索树的特性</strong>。<code>Rotate</code>分为<code>leftRotate</code>和<code>rightRotate</code>，因为两个操作基本是镜像的，所以这里只对<code>leftRotate</code>作具体分析。</p>
<p>在对于一个结点$x$进行左旋时，$x$必须含有右子树，将$x$的右子树称为$y$。左旋操作的支点可以看作是$x$和$y$的交界点，左旋操作为：用y替换x的位置，将$y$原先的左子树变为$x$的右子树,将$x$变为$y$的左子树，。</p>
<p>左旋和右旋的示意图如下：从左到右是对于y的右旋，从右到左是对x的左旋</p>
<ul>
<li>无论是左旋还是右旋，被旋转的节点深度都+1，（变得更靠下）</li>
</ul>
<p><img src="IA-Chapter13-Notes/2019-11-06-16-54-51.png" alt="左旋及右旋操作"></p>
<p>左旋操作的伪代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">TREE-ROTATE(T,x)</span><br><span class="line"></span><br><span class="line">y = x.right;</span><br><span class="line"></span><br><span class="line">//用y替换x的位置</span><br><span class="line">y.p = x.p</span><br><span class="line">if( x.p == NULL)</span><br><span class="line">    T.root = y</span><br><span class="line">else if ( x == x.p.left )</span><br><span class="line">    x.p.left = y</span><br><span class="line">else</span><br><span class="line">    x.p.right = y</span><br><span class="line"></span><br><span class="line">//将y的左结点变为x的右结点</span><br><span class="line">x.right = y.left</span><br><span class="line">if y.left != NULL</span><br><span class="line">y.left.p = x</span><br><span class="line"></span><br><span class="line">//将x作为y的左子树</span><br><span class="line">y.left = x</span><br><span class="line">x.p = y</span><br></pre></td></tr></table></figure>
<p>c++代码的实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">RBTree::LeftRotate</span><span class="params">(RBTreeNode* node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (node == nullNode || node-&gt;right == nullNode)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Invalid operation: LeftRotate&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	RBTreeNode* lowerRight = node-&gt;right;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//lowerRight replace node&#x27;s place</span></span><br><span class="line">	lowerRight-&gt;parent = node-&gt;parent;</span><br><span class="line">	<span class="keyword">if</span> (node-&gt;parent == nullNode)</span><br><span class="line">	&#123;</span><br><span class="line">		rootNode = lowerRight;</span><br><span class="line">		nullNode-&gt;right = rootNode;</span><br><span class="line">		nullNode-&gt;left = rootNode;</span><br><span class="line">		nullNode-&gt;parent = rootNode;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (node == node-&gt;parent-&gt;left)</span><br><span class="line">	&#123;</span><br><span class="line">		node-&gt;parent-&gt;left = lowerRight;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		node-&gt;parent-&gt;right = lowerRight;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//lowerRight&#x27;s left subtree become node&#x27;s right subtree</span></span><br><span class="line">	node-&gt;right = lowerRight-&gt;left;</span><br><span class="line">	<span class="keyword">if</span> (lowerRight-&gt;left != nullNode)</span><br><span class="line">	&#123;</span><br><span class="line">		lowerRight-&gt;left-&gt;parent = node;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//node as lowerRight&#x27;s left subtree</span></span><br><span class="line">	node-&gt;parent = lowerRight;</span><br><span class="line">	lowerRight-&gt;left = node;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>右旋操作与左旋操作对称，只要将左旋操作中的left都换为right,right都换为left即可。</p>
<p>这里直接给出右旋操作的c++代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">RBTree::RightRotate</span><span class="params">(RBTreeNode* node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//As the symmetry of LeftRotate</span></span><br><span class="line">	<span class="keyword">if</span> (node == nullNode || node-&gt;left == nullNode)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	RBTreeNode* lowerLeft = node-&gt;left;</span><br><span class="line"></span><br><span class="line">	lowerLeft-&gt;parent = node-&gt;parent;</span><br><span class="line">	<span class="keyword">if</span> (node-&gt;parent == nullNode)</span><br><span class="line">	&#123;</span><br><span class="line">		rootNode = lowerLeft;</span><br><span class="line">		nullNode-&gt;left = rootNode;</span><br><span class="line">		nullNode-&gt;right = rootNode;</span><br><span class="line">		nullNode-&gt;parent = rootNode;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (node == node-&gt;parent-&gt;right)</span><br><span class="line">	&#123;</span><br><span class="line">		node-&gt;parent-&gt;right = lowerLeft;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		node-&gt;parent-&gt;left = lowerLeft;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	node-&gt;left = lowerLeft-&gt;right;</span><br><span class="line">	<span class="keyword">if</span> (lowerLeft-&gt;right != nullNode)</span><br><span class="line">	&#123;</span><br><span class="line">		lowerLeft-&gt;right-&gt;parent = node;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	node-&gt;parent = lowerLeft;</span><br><span class="line">	lowerLeft-&gt;right = node;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>左旋及右旋操作的时间复杂度都为$O(1)$</p>
<h2 id="Insertion"><a href="#Insertion" class="headerlink" title="Insertion"></a>Insertion</h2><p>红黑树插入算法的思想为，先像普通的二叉搜索树一样插入结点，然后调用<code>RB-INSERT-FIXUP</code>函数调整树使其满足红黑树特性。</p>
<p>红黑树插入算法与普通的二叉搜索树插入算法主要有四个区别：</p>
<ol>
<li>用<code>T.nil</code>替代<code>NULL</code></li>
<li>将<code>T.nil</code>设为新插入结点的子结点</li>
<li><p>新插入结点的颜色为红色</p>
<p>这是为了保证性质5。如果新插入的结点设为黑色，那么新结点所在路径黑高则会增加，而另一条路径不变，则违背了性质5）。</p>
</li>
<li>插入后，调用<code>RB-INSERT-FIXUP</code>函数</li>
</ol>
<p>Insert伪代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">RB-INSERT(T,z)</span><br><span class="line"></span><br><span class="line">z.left = T.nil</span><br><span class="line">z.right = T.nil</span><br><span class="line">z. color = RED</span><br><span class="line"></span><br><span class="line">y = T.nil</span><br><span class="line">x = T.root</span><br><span class="line">while x != T.nil</span><br><span class="line">    y = x</span><br><span class="line">    if z.key &lt; x.key</span><br><span class="line">        x = x.left</span><br><span class="line">    else</span><br><span class="line">        x= x.right</span><br><span class="line">z.p = y</span><br><span class="line">if y == T.nil</span><br><span class="line">    T.root = z</span><br><span class="line">else if z.key &lt; y.key</span><br><span class="line">    y.left = z</span><br><span class="line">else</span><br><span class="line">    y.right = z</span><br><span class="line"></span><br><span class="line">RB-INSERT-FIXUP(T,z)</span><br></pre></td></tr></table></figure>
<p>c++ 实现如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">RBTree::Insert</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	RBTreeNode* toInsert = <span class="keyword">new</span> <span class="built_in">RBTreeNode</span>();</span><br><span class="line">	toInsert-&gt;value = value;</span><br><span class="line">	toInsert-&gt;color = RED;</span><br><span class="line">	toInsert-&gt;right = nullNode;</span><br><span class="line">	toInsert-&gt;left = nullNode;</span><br><span class="line"></span><br><span class="line">	RBTreeNode* targetNode = rootNode;</span><br><span class="line">	RBTreeNode* targetNodeParent = nullNode;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (targetNode != nullNode)</span><br><span class="line">	&#123;</span><br><span class="line">		targetNodeParent = targetNode;</span><br><span class="line">		<span class="keyword">if</span> (value &lt; targetNode-&gt;value)</span><br><span class="line">		&#123;</span><br><span class="line">			targetNode = targetNode-&gt;left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (value &gt; targetNode-&gt;value)</span><br><span class="line">		&#123;</span><br><span class="line">			targetNode = targetNode-&gt;right;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (targetNodeParent == nullNode)<span class="comment">//Tree is empty</span></span><br><span class="line">	&#123;</span><br><span class="line">		rootNode = toInsert;</span><br><span class="line">		rootNode-&gt;parent = nullNode;</span><br><span class="line">		nullNode-&gt;left = rootNode;</span><br><span class="line">		nullNode-&gt;right = rootNode;</span><br><span class="line">		nullNode-&gt;parent = rootNode;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (value &lt; targetNodeParent-&gt;value)</span><br><span class="line">		&#123;</span><br><span class="line">			targetNodeParent-&gt;left = toInsert;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			targetNodeParent-&gt;right = toInsert;</span><br><span class="line">		&#125;</span><br><span class="line">		toInsert-&gt;parent = targetNodeParent;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">InsertFixUp</span>(toInsert);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后面要解决的问题就是函数<code>RB-INSERT-FIXUP(T,z)</code>的实现，在进入讨论前，需要先明确几点</p>
<ol>
<li>性质1不可能违背，因为新插入的结点是红色</li>
<li>性质3不可能违背，因为新插入的结点两个叶子设为了黑色</li>
<li>性质5不可能违背，因为新插入的结点为红色，且替换的是原来NULL的地方</li>
<li><p>可能违背的只有性质2和性质4。</p>
<p> 当新插入的结点$z$是根节点时，违背性质2</p>
<p> 当新插入的结点父节点是红色时，违背性质4</p>
</li>
<li><p>在每次插入新结点前，树的状态一定是满足红黑树的，这意味着同时性质2和性质4最多被违背一个。</p>
<p> 如果违背了性质2，那么说明新插入的$z$是树中唯一的结点，那么不可能违背性质4</p>
<p> 如果违背了性质4，那么说明$z$和$z.p$都为红色。$z.p$不可能是根节点，不然在插入$z$前就已经为违背了红黑树特性2，$z.p.p$必然为黑色，否则也是在插入前就违背了性质4。因此违背性质4的情况下，不可能违背性质2。</p>
</li>
</ol>
<p>这里算法更多的是关注违背性质4时的处理方式，因为性质2比较好修复，只要将根节点的颜色改变即可。</p>
<p><code>RB-INSERT-FIXUP(T,z)</code>算法一共对插入新结点后，可能出现的违背红黑树原则的6种情况进行修复。前三种情况出现在$z.p$是$z.p.p$的左结点，后三种情况是$z.p$是$z.p.p$的右结点。前三种与后三种情况的修复是对称的，将前三种修复时的左旋操作改成右旋操作即为后三种情况的修复。因此这里只关注于前三种情况的讲解。</p>
<p>前三种(z.p = z.p.p.left )情况的区分在于$z$的$uncle$的颜色，即$z.p.p.right$的颜色。</p>
<ol>
<li>如果$z.p.p.right$为红色，无论$z$是$z.p$的哪科子树，都为情况1。</li>
<li>如果$z.p.p.right$为黑色，且$z$是$z.p$是右子树，则为情况2。</li>
<li>如果$z.p.p.right$为黑色，且$z$是$z.p$是左子树，则为情况3。</li>
</ol>
<p><img src="IA-Chapter13-Notes/2019-11-07-00-05-44.png" alt="三种情况的示意图"></p>
<p>对于情况1的修复：</p>
<p>如图示，$z$为红色，$z.p$和$z.uncle$都是红色。情况1的修复步骤为：</p>
<ol>
<li><p>将$z.p$和$z.uncle$都变为黑色</p>
<p> 这样违背性质4的连续红色结点就消失了。</p>
</li>
<li><p>将$z.p.p$变为红色</p>
<p> 因为$z.p$和$z.uncle$都变成了黑色，所有包含他们的通路，黑高都+1。考虑到包含了$z.p$和$z.uncle$的通路必然都包含$z.p.p$，所以为了保证通路上的黑高不变，将$z.p.p$变为红，这样增加的黑高就弥补了。</p>
</li>
<li><p>将$z$指针指向$z.p.p$</p>
<p> 因为将$z.p.p$变为了红色，所以可能$z.p.p$和$z.p.p.p$会出现违背性质4的情况。将$z$指针指向$z.p.p$即可重新通过<code>RB-INSERT-FIXUP(T,z)</code>算法进行判断。</p>
</li>
</ol>
<p>情况1修复的图解如下：</p>
<p><img src="IA-Chapter13-Notes/2019-11-07-10-52-42.png" alt="情况1的修复"></p>
<p>对于情况2、3的修复：</p>
<p>在情况2和3下，$z.uncle$是黑色，因此$z.uncle$和$z.p$的颜色不同，也就不能像情况1的修复一样统一改成黑色，不然会影响他们子树的黑高。因此这两种情况需要用到旋转来修复。</p>
<p>情况2下$z$作为$z.p$的右子树，因此可以对$z.p$进行左旋。于$z.p$进行左旋后，将原先$z.p$定义为$z$即转换为了情况3，如下图所示</p>
<p><img src="IA-Chapter13-Notes/2019-11-09-20-08-02.png" alt="情况2转换为情况3"></p>
<p>对于情况3，我们对$z.p.p$，即上图中的$C$进行右旋。旋转后如下图所示。</p>
<p><img src="IA-Chapter13-Notes/2019-11-09-20-30-37.png" alt="情况3对于z.p.p右旋"></p>
<p>可以看到路径存在$A$结点的树的黑高都减一（原先父结点是黑色的$C$,现在变成了红色的$B$），而包含$C$结点的路径黑高是不变的。而且此时$A$和$B$还是不满足性质4。这里再将原先的$B$调整为黑色，原先的$C$调整为红色。对于包含$A$的路径而言，黑高+1，对于包含$C$的路径而言，黑高不变，因为路径上一个结点变成了红，一个结点变成了黑。因此情况三的最终变化如下：</p>
<p><img src="IA-Chapter13-Notes/2019-11-09-20-35-41.png" alt="情况3变化"></p>
<p>情况3调整后性质4和5都满足了，而不像情况1调整后仍然可能存在违背性质4的可能。</p>
<p>另外对于情况2和3的处理，不能是情况3通过右旋$z.p$来转换为情况2再进行修复。因为如果在情况2下对$C$进行右旋，会出现如下情况。</p>
<p><img src="IA-Chapter13-Notes/2019-11-09-20-44-24.png" alt="对情况2进行直接修复"></p>
<p>此时满足了性质4，但是包含$\alpha$结点路径的黑高少了1，如果为了满足性质5将$A$结点和$C$结点调整颜色，那么$C$结点和$B$结点又会违背性质4。</p>
<p>情况4，5，6的调整与情况1，2，3是镜像这里就不复述了。</p>
<p>整个给出<code>RB-INSERT-FIXUP(T,z)</code>的伪代码实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">RB-INSERT-FIXUP(T,z)</span><br><span class="line"></span><br><span class="line">while z.p.color == RED</span><br><span class="line">	if z.p == z.p.p.left // Case 1,2,3</span><br><span class="line">		y= z.p.p.right</span><br><span class="line">		if (y.color == RED) //Case 1</span><br><span class="line">			z.p.color = BLACK</span><br><span class="line">			y.color = BLACK</span><br><span class="line">			z.p.p.color = RED</span><br><span class="line">			z = z.p.p</span><br><span class="line">		else</span><br><span class="line">			if z == z.p.right //Case 2</span><br><span class="line">				z = z.p</span><br><span class="line">				LEFT-ROTATE(T,z)</span><br><span class="line">			z.p.color = BLACK // Case 3,下一次循环将直接退出</span><br><span class="line">			z.p.p.color = RED</span><br><span class="line">			RIGHT-ROTATE(T,z.p.p)</span><br><span class="line">	else //Case 4,5,6</span><br><span class="line">		...</span><br><span class="line">		//和情况1,2,3类似，将right和left对调即可</span><br><span class="line">T.root.color = BLACK //保证性质2</span><br></pre></td></tr></table></figure>
<p>c++代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RBTree::InsertFixUp</span><span class="params">(RBTreeNode* node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (node-&gt;parent-&gt;color == RED)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (node-&gt;parent == node-&gt;parent-&gt;parent-&gt;left)<span class="comment">//The first three cases</span></span><br><span class="line">		&#123;</span><br><span class="line">			RBTreeNode* uncle = node-&gt;parent-&gt;parent-&gt;right;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (uncle-&gt;color == RED) <span class="comment">//Case 1</span></span><br><span class="line">			&#123;</span><br><span class="line">				node-&gt;parent-&gt;color = BLACK;</span><br><span class="line">				uncle-&gt;color = BLACK;</span><br><span class="line">				node-&gt;parent-&gt;parent-&gt;color = RED;</span><br><span class="line">				node = node-&gt;parent-&gt;parent;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (node == node-&gt;parent-&gt;right) <span class="comment">//Case 2</span></span><br><span class="line">				&#123;</span><br><span class="line">					node = node-&gt;parent;</span><br><span class="line">					<span class="built_in">LeftRotate</span>(node);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">//Case3</span></span><br><span class="line">				node-&gt;parent-&gt;color = BLACK;</span><br><span class="line">				node-&gt;parent-&gt;parent-&gt;color = RED;</span><br><span class="line">				<span class="built_in">RightRotate</span>(node-&gt;parent-&gt;parent);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//The remainging three cases, as the symmetry of the first three</span></span><br><span class="line"></span><br><span class="line">			RBTreeNode* uncle = node-&gt;parent-&gt;parent-&gt;left;</span><br><span class="line">			<span class="keyword">if</span> (uncle-&gt;color == RED)</span><br><span class="line">			&#123;</span><br><span class="line">				node-&gt;parent-&gt;color = BLACK;</span><br><span class="line">				uncle-&gt;color = BLACK;</span><br><span class="line">				node-&gt;parent-&gt;parent-&gt;color = RED;</span><br><span class="line">				node = node-&gt;parent-&gt;parent;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (node == node-&gt;parent-&gt;left)</span><br><span class="line">				&#123;</span><br><span class="line">					node = node-&gt;parent;</span><br><span class="line">					<span class="built_in">RightRotate</span>(node);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				node-&gt;parent-&gt;color = BLACK;</span><br><span class="line">				node-&gt;parent-&gt;parent-&gt;color = RED;</span><br><span class="line">				<span class="built_in">LeftRotate</span>(node-&gt;parent-&gt;parent);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	rootNode-&gt;color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为<code>RB-INSERT</code>操作是一层层的向下搜索可以插入的点，所以复杂度与树的高度有关，即为$O(\lg n)$，<code>RB-INSERT-FIXUP</code>操作只有在情况1的情况下会继续循环，且每次循环前都将$z$向上移两位，因此执行次数是层数的一半，时间复杂度也为$O(\lg n)$。综上，红黑树插入操作总体的时间复杂度为$O(\lg n)$。</p>
<h2 id="Deletion"><a href="#Deletion" class="headerlink" title="Deletion"></a>Deletion</h2><p>如二叉搜索树一样，红黑树的删除操作同样需要<code>Transplant</code>操作来用一个结点替换另一个，这里与二叉搜索树不同的只是将<code>Null</code>变为了<code>T.nil</code>，以及在设置$v.p$时不需要额外的判断，因为即使$v$是哨兵，访问$v.p$也不会出错</p>
<p>伪代码如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RB-TRANSPLANT(T,u,v)</span><br><span class="line">if u.p == T.nil</span><br><span class="line">	T.root = v</span><br><span class="line">else if u == u.p.left</span><br><span class="line">	u.p.left = v</span><br><span class="line">else</span><br><span class="line">	u.p.right = v</span><br><span class="line">v.p=u.p</span><br></pre></td></tr></table></figure></p>
<p>c++代码实现如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RBTree::TransPlant</span><span class="params">(RBTreeNode* originNode, RBTreeNode* newNode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (originNode-&gt;parent == nullNode)</span><br><span class="line">	&#123;</span><br><span class="line">		rootNode = newNode;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (originNode == originNode-&gt;parent-&gt;left)</span><br><span class="line">	&#123;</span><br><span class="line">		originNode-&gt;parent-&gt;left = newNode;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		originNode-&gt;parent-&gt;right = newNode;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	newNode-&gt;parent = originNode-&gt;parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在二叉搜索树的删除操作中，最复杂的情况，即被删除节点$z$有两个子树，且他的<code>successor</code>不是$z$的右子树。</p>
<p>这时候需要执行的操作是，将$successor.right$替换$successnor$的位置，再用$successor$替换$z$的位置。因为整个操作牵扯到三个节点$succcessor.right,successor,z$的变化，所以在红黑树的操作下，这三个结点都需要被确认是否会造成红黑树性质的破坏。</p>
<p>在删除算法中，将需要移进或者移出原先$z$位置的结点命名为$y$，需要记录$y$结点的位置，因为如果他是黑色的，那么他的移动会破坏红黑树的性质5。需要替代$y$位置的点用$x$表示。</p>
<p>删除操作的伪代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">y = z //这里y表示要移除z位置的结点，即z自己</span><br><span class="line">y-original-code = y.color</span><br><span class="line">if z.left == T.nil</span><br><span class="line">	x = z.right</span><br><span class="line">	RB-TRANSPLANT(T,y,x) //用z的右树替代z，即用x替代z，即用x替代y</span><br><span class="line">else if z.right = T.nil</span><br><span class="line">	x = z.left</span><br><span class="line">	RB-TRANSPLANT(T,y,x) //用z的左树替代z，即用x替代z，即用x替代y</span><br><span class="line">else</span><br><span class="line">	y = TREE-MINIMUM(z.right) //y表示z.successor，这里y表示需要移进z位置的结点</span><br><span class="line">	x = y.right //如普通的搜索二叉树一样，用y的右子树替代y的位置</span><br><span class="line">	if y.p == z</span><br><span class="line">		x.p = z //在普通二叉搜索树中，y.p == z的情况不需要任何操作，这里因为设置了x，所以需要为x指定父节点</span><br><span class="line">	else</span><br><span class="line">		RB-TRANSPLANT(T,y,x) //TRANSPLANT操作同时也为x设置了父结点，即x.p = y.p</span><br><span class="line">		y.right = z.right</span><br><span class="line">		y.right.p = y</span><br><span class="line">	RB-TRANSPLANT(T,z,y)</span><br><span class="line">	y.left = z.left</span><br><span class="line">	y.left.p = y</span><br><span class="line">	y.colour = z.clour //在y移动到了z的位置后，用z的颜色表示y的颜色，这样就保证了y有原先z.p不会违背性质4</span><br><span class="line">if(y-original-color == Black)//在原先的y结点是黑色的情况下，会引发问题（后面会解释），所以需要修复</span><br><span class="line">	RB-DELETE-FIXUP(T,x)</span><br></pre></td></tr></table></figure>
<p>在伪代码的最后，仅在原$y$结点颜色为黑色的时候调用修复函数<code>RB_DELETE_FIXUP</code>,因为$y$结点如果原先为红色，则不会违反任何的红黑树性质</p>
<ol>
<li>因为$y$是红的，所以移动$y$不会造成树的黑高的变化，性质5也就不会被破坏</li>
<li>因为在代码的20行将$z$的颜色赋给了$y$，所以不会发生$y$与$z.p$=破坏性质4的情况。</li>
<li>$x$作为替代$y$的结点，如果$y$是红的,$x$就是黑色的，移动$x$也不会造成破坏性质4的情况</li>
<li>$y$是红色的，$y$不可能是树的根，所以根也不会发生变化，性质2也不会被破坏</li>
<li>性质1，3在操作中根本没有相关改动的地方，肯定不会被破坏</li>
</ol>
<p>而$y$结点如果是黑色的，则可能会存在以下情况</p>
<ol>
<li>如果$y$根节点，而且$y$的子结点是红色，那么破坏性质2。</li>
</ol>
<ul>
<li>这种情况只有$y$表示的是移出$z$位置的结点时($y=z$)才可能发生。否则$y$移入$z$的位置，且$y$是黑色的，不可能破坏性质2。如果$y$表示是移出$z$位置，说明$z$最多只有一个子树，这种情况下$y$的子结点即为$x$。</li>
</ul>
<ol>
<li><p>如果$x$和$x.p$都为红色，那么破坏性质4。</p>
<p> 首先分析$x$和$x.p$的可能取值。</p>
<p> （1） $x$可能是$y.left$（在$z$只有左结点）或者$y.right$（在$z$有两种结点的情况或$z$只有右结点）。</p>
<p> （2） $x.p$在大部分情况下都为$y.p$，除了$x$在$z$有两个结点，且$y$是$z.right$的情况下，$x.p$=$y$。</p>
<p> 因为$x$和$x.p$都是红色，且$y$是黑的，所以$x.p$不能等于$y$。因此发生的情况一定是$z$有两个结点，且$y$不等于$z.right$或$y$只有右结点。即如下图所示的两种情况：</p>
<p> <img src="IA-Chapter13-Notes/2019-11-16-15-17-38.png" alt="删除z违背性质4的情况"><br> <img src="IA-Chapter13-Notes/2019-11-16-17-09-19.png" alt="删除z违背性质4的情况2"></p>
</li>
<li><p>任意包含了$y$的路径都会出现黑高减一的情况，违背性质5</p>
<p> (1) 在$y$表示移出$z$位置的结点的情况下(即 $y$ = $z$ )，因为$z$和$y$都是黑色，所以删除$z$结点必然会出现黑高减一</p>
<p> (2) 在$y$表示移入$z$位置的结点的情况下(即 $y$ = $z.successor$ )，仍然会出现黑高减一。如果$z$是黑色的，那么同样是$y$和$z$都是黑色，删除$z$结点出现黑高减一。如果$z$是红色的，删除$z$不会造成黑高减一，但是因为在算法的最后为了保证新移入的$y$不会与树的上层发生冲突，所以将$y$设为了原先$z$的颜色，即将$y$变为了黑色，因此同样黑高减一。</p>
</li>
</ol>
<p>在这里为了解决包含$y$的路径出现的黑高减一现象，将额外的一个黑色给予$x$结点，因为包含有$y$的路径一定包含$x$（因为$x$=$y$或者$y.right$）。因为修复了黑高减一的问题，性质5满足了，但因为$x$现在是拥有两个黑色，或者是一黑一红，因此违背了性质1，即所有结点要么是红色，要么是黑色。</p>
<ul>
<li>这里给$x$一个额外黑的操作并没有在代码中体现，只是一个思路。因此$x$的颜色在代码中判断，依然按$x$之前的颜色判断。</li>
</ul>
<p>因此RB-DELETE-FIXUP一共需要解决三个性质的问题即，性质1，2，4。且性质1是针对$x$结点，所以传递的参数为$x$结点。</p>
<p>RB-DELETE-FIXUP的伪代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">while x != T.root and x.color == BLACK</span><br><span class="line">	if x == x.p.left</span><br><span class="line">		w = x.p.right</span><br><span class="line">		if w.color == RED // 情况1</span><br><span class="line">			w. color = BLACK</span><br><span class="line">			x.p.color = RED</span><br><span class="line">			LEFT-ROTATE(T,x.p)</span><br><span class="line">			w = x.p.right // 新的w，因为新的w必然是黑色，所以情况1转换为1情况2/3/4</span><br><span class="line">		if w.left.color == BLACK and w.right.color == BLACK</span><br><span class="line">			w.color = RED</span><br><span class="line">			x = x.p</span><br><span class="line">		else</span><br><span class="line">			if w.right.color == BLACK</span><br><span class="line">				w.left.color = BLACK</span><br><span class="line">				w.color = RED</span><br><span class="line">				RIGHT-ROTATE(T,w)</span><br><span class="line">				w = x.p.right</span><br><span class="line">			w.color = x.p.color</span><br><span class="line">			x.p.color = BLACK</span><br><span class="line">			w.right.color = BLACK</span><br><span class="line">			LEFT-ROTATE(T,x.p)</span><br><span class="line">			x = T.root</span><br><span class="line">	else</span><br><span class="line">		....</span><br><span class="line">		//和情况1,2,3,4类似，将right和left对调即可</span><br><span class="line">x.color = BLACK</span><br></pre></td></tr></table></figure>
<p>这里的删除修复如同插入修复一样，有很多种情况，这里一共是8种情况。但是可以分为前四种和后四种，分割标准是$x$是$x.p$的左结点，还是右结点。这里我们只讨论$x$是左结点的情况，即前四种。后四种为前四种的对称，如同插入修复的对称一样,解法只要将前四种中的$left$改为$right$，反之亦然。</p>
<p>整个算法是一个循环和一个将x.color设为Black的语句。退出循环的条件是$x$是红色（实际上$x$有红-黑两个颜色属性）或$x$是根。</p>
<p>在这种情况下将$x$设为单一黑色（即x.color = Black）可以<strong>修复性质1</strong>，且不会破坏性质5，因为</p>
<pre><code>(1) 如果$x$是根，那么删除一个黑色，是整棵树的黑高都减一，依然满足性质5

(2) 如果$x$是红-黑，即贡献了一个黑高，设为黑色后，依然是贡献一个黑高，满足性质5
</code></pre><p>将$x.color$设为黑色，因为$x$和$x.p$都为红色而造成的<strong>性质4的破坏也会被修复</strong>。</p>
<p>而且如上讨论，违背性质2的情况，必然是$z$最多只有一颗子树，即$y=z$，$x$作为$y$的子结点且为红色的情况，那么将$x$设为黑色，同样<strong>修复了性质2</strong>。这种情况下$x$就是根结点，并不会进入循环，将直接执行最后一句。</p>
<p>因此退出循环后的<code>x.color = BLACK</code>语句将同时修复性质1,2,4。现在需要关心的是该如何退出循环。</p>
<p>现在先分析前四种情况。这四种情况的分类是根据$x$的兄弟$w$（在$x$=$x.p.left$的情况下$w$即为$x.p.right$）。</p>
<ul>
<li>因为进入循环是$x$是两个黑色属性，所以$w$必然存在且一定有两个子结点。不然通过$x$抵达叶子的黑高一定大于到达$w$的黑高。$w$的子结点也必然有两个子结点，因为只有$w$与$w.left$或$w.right$都为黑色，才能刚好与$x$的两个黑色相抵。如果其中一个为红色，那么则需要更深的树才能抵消。</li>
</ul>
<ol>
<li>$w$是红色为情况1。</li>
</ol>
<p>如果$w$是黑色的，再细分为三个情况</p>
<ol>
<li><p>$w$是黑色，且右结点是黑色，左结点是黑色为情况2</p>
</li>
<li><p>$w$是黑色，且右结点是黑色，左结点是红色，为情况3</p>
</li>
<li><p>$w$是黑色，且右结点是红色，左结点是红色或黑色，为情况4</p>
</li>
</ol>
<p>对于情况1的修复：</p>
<p>因为$w$是红色，所以$w.p$即$w.p$必然是黑色的。将$w.p$与$w$的颜色对调，且对$w.p$进行左旋，如下图所示，不会违背任何的红黑树性质。</p>
<p><img src="IA-Chapter13-Notes/2019-11-16-16-28-06.png" alt="情况1修复"></p>
<ul>
<li>上图以及之后其他的对于各种情况的修复图中，黑色结点表示黑色，深灰色结点，如上图中的$D$表示红色，浅灰色结点表示可能是黑可能是红。</li>
</ul>
<p>同样因为$w$是红色的，$w$的两个子结点也必然是黑色的，在上述的操作后，原$w$的左结点将会成为$x$的新兄弟，即成为新的$w$，为黑色。</p>
<p>如之前所述，$w$也必然有两个子结点，根据子结点的情况，情况1会变为情况2或3或4。</p>
<p>对于情况2的修复：</p>
<p>在情况2下，因为$x$是双重黑色，$w$是黑色，所以从他们两个结点中都取出一个黑色，即$x$变为单个黑色，$w$变为红色。将这个取出的黑色给予$x.p$。</p>
<p>这个操作只有在$w$的两个结点都是黑色的情况下（即情况2）才能执行，不然当$w$变为红色，将会与它的子结点违背性质4。</p>
<p>因为$x$和$w$都为黑色，所以$x.p$的颜色并不能确定（下图中由浅灰色表示），增加了额外黑色后，可能为黑-黑也可能为红-黑。</p>
<ul>
<li>从$x$和$w$中都取出一个黑色，相当于将$x.p$的两个子树的黑高都减一，而此时将黑色给予$x.p$相当于将将失去的黑高补了回来。</li>
</ul>
<p>此时$x.p$成为了破坏性质1的结点，因此将他设为新的$x$并再次进入循环。</p>
<ul>
<li>如果是由情况1转换为的情况2，那么再次进入循环后，将不满足循环条件直接退出循环。因为在情况1修复后$x.p$为红色，在情况2修复后被给予了额外的黑色后，变为红-黑，不满足循环条件，因此退出。</li>
</ul>
<p><img src="IA-Chapter13-Notes/2019-11-16-17-31-28.png" alt="情况2的修复"></p>
<p>对于情况3的修复：</p>
<p>情况3通过降$w$（黑色）与$w.left$（红色）的颜色对换，并对$w$执行右旋，再将原$w.left$设为新$w$转换为情况4。如下图所示。</p>
<p><img src="IA-Chapter13-Notes/2019-11-16-17-39-14.png" alt="情况3的修复"></p>
<p>对于情况4的修复：</p>
<p>在情况4中，先将$w$与$w.p$的颜色互换，然后对$w.p$进行左旋，$w$取代原先$w.p$的位置。如下图所示</p>
<p><img src="IA-Chapter13-Notes/2019-11-16-18-16-43.png" alt="情况4修复1"></p>
<p>分析三个结点$A$,$C$和$E$的黑高，发现$A$的黑高多了1，$C$的黑高不变，$E$的黑高少了1。因此我们将$A$的一个黑高给$E$，这样三个结点的黑高都不变。$A$结点即为$x$，原先有两个黑色，现在减去一个变成单独的黑色结点，满足性质1。$E$原先为红色，现在多了一个黑色，变为黑色结点。</p>
<p>因此情况4的最终修复效果如下</p>
<p><img src="IA-Chapter13-Notes/2019-11-16-18-20-17.png" alt="情况4修复2"></p>
<p>在这个情况下，所有的结点都满足了性质1。所以将$x$直接指向$T.root$来退出循环即可。</p>
<ul>
<li>之所以情况2无法直接退出循环，是因为在情况2的修复后，原$x.p$仍然破坏了性质1，所以需要进入循环继续修复。</li>
</ul>
<p>后四种情况的修复与前四种对称，这里不在赘述。</p>
<p><code>RB-DELETE</code>操作本身没有循环，所以时间复杂度由<code>TREE-MINIMUM</code>和<code>RB-DELETE-FIXUP</code>共同决定。</p>
<p>如同普通二叉搜索树，<code>TREE-MINIMUM</code>时间复杂度为$O(\lg n )$。</p>
<p>而<code>RB-DELETE-FIXUP</code>，只有情况2会再次进入循环，剩下的三种情况都是转换为其他情况或者在下一次直接退出循环。而情况2每次都会将$x$上移，所以在最坏情况下时间复杂度也为$O(\lg n)$。</p>
<p>综上<code>RB-DELETE</code>的时间复杂度为$O(\lg n ) + O(\lg n)$，即$O(\lg n)$。</p>
<p><code>RB-DELETE</code>与<code>RB-DELETE-FIXUP</code>的c++代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">RBTree::Delete</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	RBTreeNode* toDelete = <span class="built_in">Search</span>(value);</span><br><span class="line">	<span class="keyword">if</span> (toDelete == nullNode)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	RBTreeNode* toDeleteTrack = toDelete;<span class="comment">//this track will be removed from the tree</span></span><br><span class="line">	NodeColor originDeleteTrackColor = toDeleteTrack-&gt;color;</span><br><span class="line"></span><br><span class="line">	RBTreeNode* toReplaceTrack;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (toDelete-&gt;left == nullNode)</span><br><span class="line">	&#123;</span><br><span class="line">		toReplaceTrack = toDelete-&gt;right;</span><br><span class="line">		<span class="built_in">TransPlant</span>(toDelete, toReplaceTrack);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (toDelete-&gt;right == nullNode)</span><br><span class="line">	&#123;</span><br><span class="line">		toReplaceTrack = toDelete-&gt;left;</span><br><span class="line">		<span class="built_in">TransPlant</span>(toDelete, toReplaceTrack);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="comment">//Both children are not nullNode</span></span><br><span class="line">	&#123;</span><br><span class="line">		toDeleteTrack = <span class="built_in">GetMinimum</span>(toDelete-&gt;right);<span class="comment">//The track is Successor</span></span><br><span class="line">		<span class="comment">//This track will moved in toDelete&#x27;s postion</span></span><br><span class="line">		originDeleteTrackColor = toDeleteTrack-&gt;color;</span><br><span class="line"></span><br><span class="line">		toReplaceTrack = toDeleteTrack-&gt;right;</span><br><span class="line">		<span class="keyword">if</span> (toDeleteTrack-&gt;parent == toDelete)<span class="comment">//Track is toDelete&#x27;s rightChild</span></span><br><span class="line">		&#123;</span><br><span class="line">			toReplaceTrack-&gt;parent = toDeleteTrack;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">TransPlant</span>(toDeleteTrack, toReplaceTrack);</span><br><span class="line">			toDeleteTrack-&gt;right = toDelete-&gt;right;</span><br><span class="line">			toDeleteTrack-&gt;right-&gt;parent = toDeleteTrack;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">TransPlant</span>(toDelete, toDeleteTrack);</span><br><span class="line">		toDeleteTrack-&gt;left = toDelete-&gt;left;</span><br><span class="line">		toDeleteTrack-&gt;left-&gt;parent = toDeleteTrack;</span><br><span class="line">		toDeleteTrack-&gt;color = toDelete-&gt;color;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//set the pointer be null to ensure children and parent won&#x27;t be released</span></span><br><span class="line">		toDelete-&gt;parent = <span class="literal">nullptr</span>;</span><br><span class="line">		toDelete-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">		toDelete-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">		<span class="keyword">delete</span> toDelete;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (originDeleteTrackColor == BLACK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">DeleteFixUp</span>(toReplaceTrack);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RBTree::DeleteFixUp</span><span class="params">(RBTreeNode* toReplaceTrack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (toReplaceTrack != rootNode &amp;&amp; toReplaceTrack-&gt;color == BLACK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (toReplaceTrack == toReplaceTrack-&gt;parent-&gt;left) <span class="comment">//The first four cases</span></span><br><span class="line">		&#123;</span><br><span class="line">			RBTreeNode* uncle = toReplaceTrack-&gt;parent-&gt;right;</span><br><span class="line">			<span class="keyword">if</span> (uncle-&gt;color == RED)   <span class="comment">//case1</span></span><br><span class="line">			&#123;</span><br><span class="line">				uncle-&gt;color = BLACK;</span><br><span class="line">				toReplaceTrack-&gt;parent-&gt;color = RED;</span><br><span class="line">				<span class="built_in">LeftRotate</span>(toReplaceTrack-&gt;parent);</span><br><span class="line">				uncle = toReplaceTrack-&gt;parent-&gt;right;   <span class="comment">//to case 2/3/4</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (uncle-&gt;left-&gt;color == BLACK &amp;&amp; uncle-&gt;right-&gt;color == BLACK)</span><br><span class="line">			&#123;</span><br><span class="line">				uncle-&gt;color = RED;    <span class="comment">//case2</span></span><br><span class="line">				toReplaceTrack = toReplaceTrack-&gt;parent;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (uncle-&gt;right-&gt;color == BLACK)</span><br><span class="line">				&#123;</span><br><span class="line">					uncle-&gt;left-&gt;color = BLACK;</span><br><span class="line">					uncle-&gt;color = RED;</span><br><span class="line">					<span class="built_in">RightRotate</span>(uncle);   <span class="comment">// to case4</span></span><br><span class="line">					uncle = toReplaceTrack-&gt;parent-&gt;right;</span><br><span class="line">				&#125;</span><br><span class="line">				uncle-&gt;color = toReplaceTrack-&gt;parent-&gt;color;</span><br><span class="line">				toReplaceTrack-&gt;parent-&gt;color = BLACK;          <span class="comment">//case4;</span></span><br><span class="line">				uncle-&gt;right-&gt;color = BLACK;</span><br><span class="line">				<span class="built_in">RightRotate</span>(toReplaceTrack-&gt;parent);</span><br><span class="line">				toReplaceTrack = rootNode;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span><span class="comment">//The remaining four cases,as the symetry of the first four</span></span><br><span class="line">		&#123;</span><br><span class="line">			RBTreeNode* uncle = toReplaceTrack-&gt;parent-&gt;left;</span><br><span class="line">			<span class="keyword">if</span> (uncle-&gt;color == RED)</span><br><span class="line">			&#123;</span><br><span class="line">				uncle-&gt;color = BLACK;</span><br><span class="line">				toReplaceTrack-&gt;parent-&gt;color = RED;</span><br><span class="line">				<span class="built_in">RightRotate</span>(toReplaceTrack-&gt;parent);</span><br><span class="line">				uncle = toReplaceTrack-&gt;parent-&gt;left;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (uncle-&gt;right-&gt;color == BLACK &amp;&amp; uncle-&gt;left-&gt;color == BLACK)</span><br><span class="line">			&#123;</span><br><span class="line">				uncle-&gt;color = RED;</span><br><span class="line">				toReplaceTrack = toReplaceTrack-&gt;parent;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (uncle-&gt;left-&gt;color == BLACK)</span><br><span class="line">				&#123;</span><br><span class="line">					uncle-&gt;right-&gt;color = BLACK;</span><br><span class="line">					uncle-&gt;color = RED;</span><br><span class="line">					<span class="built_in">LeftRotate</span>(uncle);</span><br><span class="line">					uncle = toReplaceTrack-&gt;parent-&gt;left;</span><br><span class="line">				&#125;</span><br><span class="line">				uncle-&gt;color = toReplaceTrack-&gt;parent-&gt;color;</span><br><span class="line">				toReplaceTrack-&gt;parent-&gt;color = BLACK;</span><br><span class="line">				uncle-&gt;left-&gt;color = BLACK;</span><br><span class="line">				<span class="built_in">RightRotate</span>(toReplaceTrack-&gt;parent);</span><br><span class="line">				toReplaceTrack = rootNode;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	toReplaceTrack-&gt;color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note info simple"><p>引用：</p>
<ol>
<li><em>Introduction to Algorithms</em> 3rd Sep.2009</li>
</ol>
</div>
<hr>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="Tuncle">三叔</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://tuncle.blog/IA-Chapter13-Notes/">https://tuncle.blog/IA-Chapter13-Notes/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://tuncle.blog" target="_blank">三叔胡言乱语的地方</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="twitter, wechat, weibo"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/CNI-Chapter1-Notes/" title="《计算机网络与因特网》 第一章笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">《计算机网络与因特网》 第一章笔记</div></div></a></div><div class="next-post pull-right"><a href="/IA-Chapter12-Notes/" title="《算法导论》 第十二章笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">《算法导论》 第十二章笔记</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-13-Red-Black-Trees"><span class="toc-number">1.</span> <span class="toc-text">Chapter 13. Red-Black Trees</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Properties-of-red-black-trees"><span class="toc-number">1.1.</span> <span class="toc-text">Properties of red-black trees</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Rotations"><span class="toc-number">1.2.</span> <span class="toc-text">Rotations</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Insertion"><span class="toc-number">1.3.</span> <span class="toc-text">Insertion</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Deletion"><span class="toc-number">1.4.</span> <span class="toc-text">Deletion</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 By 三叔</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Keep Writing</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'TGA1EB8Nf5aw6uJBpw45pBJQ-gzGzoHsz',
      appKey: 'z1vCYavVUbCGuMjNMcrsvShN',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: true
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>