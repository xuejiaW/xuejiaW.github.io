---
created: 2022-06-05
updated: 2025-09-01
tags:
  - 系统设计
  - 编码规范
publishStatus: published
title: 《Unix 编程艺术》 第三章 对比
date: 2023-08-28 22:04
description: 阐述了 Unix 作为操作系统的几个统一性理念，包含有对多任务，协作进程，二进制文件，CLI 等内容的思考，也对比了与 MacOS，Windows 等操作系统的差异。
---

# 3.1 操作系统的风格元素

## 3.1.1 什么是操作系统的统一性理念

Unix 有几个统一性的理念或象征，并塑造了它的 API 及由此形成的开发风格。其中最重要的一点应当是“一切皆文件”模型及在此基础上建立的管道概念。

彻头彻尾的反 Unix 系统，就是没有任何统一性理念，胡乱堆砌起的一些唬人特性而已。

## 3.1.2 多任务能力

Unix 系统拥有抢先式多任务（preemptive multitasking）能力。在 Unix 中，时间片由调度程序来分配，这个调度程序定期中断或抢断正在运行的进程而把控制权交给下一个进程。几乎所有的现代操作系统都支持抢占式调度。

彻头彻尾的反 Unix 系统，就是绝无多任务处理能力一一或者通过对进程管理增设诸多的规定、限制和特殊情况来削弱多任务能力的一个废物。

## 3.1.3 协作进程

在 Unix 中，低价的进程生成和简便的 `进程间通讯（IPC,Inter-Process Communication）` 使众多小工具、管道和过滤器组成一个均衡系统成为可能。

如果操作系统的进程生成代价昂贵，且/或进程控制非常困难、不灵活，后果通常是：

-   编写怪物般巨大的单个程序成为更自然的编程方式。
-   很多策略必须在这些庞大程序中表述。
-   当进程间不得不进行通讯时，要么只能采用笨拙、低效、不安全的机制（比如临时文件），要么就得依赖太多彼此的实现细节，要么彼此需了解对方的太多实现细节。
-   广泛使用多线程来完成某些任务，而这些任务 Unix 只需用互通的多进程就能处理。
-   必须学习和使用异步 IO。

一个操作系统，如果没有灵活的 IPC 和使用 IPC 的强大传统，程序间就得通过共享结构复杂的数据实现通讯。由于一旦有新的程序加入通讯圈，圈子里所有程序的通讯问题都必须重新解决，所以解决方案的复杂度与协作程序数量的平方成正比。更糟糕的是，其中任何一个程序的数据结构发生变化，都说不定会给其它程序带来什么隐蔽的 bug。

彻头彻尾的反 Unix 系统，就是让进程的生成代价高昂，让进程的控制因难而死板，让 IPC 可有可无，对它不予支持或支持很少。

## 3.1.4 内部边界

Unix 至少设立了三层内部边界来防范恶意用户或有缺陷的程序：

1. 第一层是内存管理：Unix 用硬件自身的 `内存管理单元(MMU)` 来保证各自的进程不会侵入到其它进程的内存地址空间。
2. 第二层是为多用户设置的真正权限组——普通用户（非 Root 用户）的进程未经允许，就不能更改或者读取其他用户的文件。
3. 第三层是把涉及关键安全性的功能限制在尽可能小的可信代码块上 。在 Unix 中，即使是 shell（系统命令解释器）也不是什么特权程序。

## 3.1.5 文件属性和记录结构

Unix 文件既没有记录结构也没有文件属性。

对文件属性的操作系统支持会诱导程序员使用不透明的文件格式，让他们依靠文件属性将文件格式对应的解读程序绑在一起。

## 3.1.6 二进制文件格式

彻头彻尾的反 Unix 系统，让所有文件格式都采用不透明的二进制格式，后者要用重量级的工具才能读取和编辑。

## 3.1.7 首选用户界面风格

如果操作系统的 CLI 功能很弱或根本不存在，其后果会是：

-   程序设计不会考虑以未预料到的方式相互协作——因为无法这样设计。输出不能用作输入。
-   远程系统管理更难于实现，更难以使用，更强调网络。
-   即便简单的非交互程序也将招致 GUI 开销或复杂的脚本接口。
-   服务器、守护程序和后台进程几乎无法写出，至少很难以优雅的方式写出。

彻头彻尾的反 Unix 系统，就是没有 CLI，没有脚本编程能力或者，存在 CLI 不能驱动的重要功能。

## 3.1.8 目标受众

“客户端”可以理解为：轻量，只支持单个用户，能够在小型机器上运行，随需开关机器，没有抢先式多任务处理，为低延迟作了优化，大量资源都用在花哨的用户界面上。

“服务器”可以解释为：重量，能够连续运行，为吞吐量优化，完全抢占式多任务处理以处理多重会话。所有的操作系统最初都是服务器操作系统。

客户端操作系统更关注用户的视觉体验，而不是 7\*24 小时的连续正常运行。

彻头彻尾的反 Unix 系统，就是一个自认为比你自己更懂你在干什么的操作系统，然后雪上加霜的是，它还做错了。

## 3.1.9 开发的门坎

区分操作系统的另一个重要尺度就是纯用户转变为开发者的门坎高度。这里有两个重要的成本：一是开发工具的金钱成本，另一个是成为一个熟练开发者的时间成本。

# 3.2 操作系统的比较

## 3.2.2 MacOS

MacOS 有一个不同于 Unix 的坚定统一性理念：Mac 界面方针（the Mac InterfaceGuidelines）。

这些方针非常详细地说明了应用程序 GUI 的表现形式和行为模式。这些原则的一致性在很多重要方面影响了 Mac 用户的文化。

这些方针的主旨是：东西永远呆在你摆的地方。文档、目录和其它东西在桌面上都有固定的、系统不会弄乱的位置，重启后桌面依然保持原样。

## 3.2.4 Windows NT

Windows NT(New Technology) 是微软为高端个人用户和服务器设计的操作系统；Windows XP 是 5.1.

NT 是逐步堆积而成的，缺乏对应于 Unix “一切皆文件” 或 MacOS 左面的统一性理念。

Unix 的系统配置和用户配置数据分散存放在众多的 dotfiles (名字以“.”开头的文件) 和系统数据文件中，而 NT 则集中存放在注册表中。以下后果贯穿于设计中：

-   注册表使得整个系统完全不具备正交性。应用程序的单点故障就会损毁注册表，经常使得整个操作系统无法使用、必须重装。
-   注册表蠕变 (registry creep) 现象：随着注册表的膨胀，越来越大的存取开销拖慢了所有程序的运行。

## 3.2.8 Linux

Linux 并不含任何来自原始 Unix 源码树的代码，但却是一个按照 Unix 标准设计、行为像 Unix 的操作系统。

包容竞争者的目标加上贴近终端用户的动力，促使 Linux 开发者广泛吸收非 Unix 操作系统的设计理念，甚至到了使传统 Unix 显得十分孤立的地步。

