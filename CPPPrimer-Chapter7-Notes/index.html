<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>《C++ Primer》 第七章笔记 - 三叔胡言乱语的地方</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="三叔胡言乱语的地方"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="三叔胡言乱语的地方"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="《C++ Primer》 第七章笔记"><meta property="og:type" content="blog"><meta property="og:title" content="《C++ Primer》 第七章笔记"><meta property="og:url" content="https://xuejiaw.github.io/CPPPrimer-Chapter7-Notes/"><meta property="og:site_name" content="三叔胡言乱语的地方"><meta property="og:description" content="《C++ Primer》 第七章笔记"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://xuejiaw.github.io/CPPPrimer-Chapter7-Notes/CPPPrimer-Chapter7-Notes/Ch_7.png"><meta property="article:published_time" content="2020-02-29T07:57:33.000Z"><meta property="article:modified_time" content="2023-04-02T12:21:20.010Z"><meta property="article:author" content="三叔"><meta property="article:tag" content="读书笔记"><meta property="article:tag" content="C++"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://xuejiaw.github.io/CPPPrimer-Chapter7-Notes/CPPPrimer-Chapter7-Notes/Ch_7.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://xuejiaw.github.io/CPPPrimer-Chapter7-Notes/"},"headline":"《C++ Primer》 第七章笔记","image":["https://xuejiaw.github.io/CPPPrimer-Chapter7-Notes/CPPPrimer-Chapter7-Notes/Ch_7.png"],"datePublished":"2020-02-29T07:57:33.000Z","dateModified":"2023-04-02T12:21:20.010Z","author":{"@type":"Person","name":"三叔"},"publisher":{"@type":"Organization","name":"三叔胡言乱语的地方","logo":{"@type":"ImageObject","url":{"text":"三叔胡言乱语的地方"}}},"description":"《C++ Primer》 第七章笔记"}</script><link rel="canonical" href="https://xuejiaw.github.io/CPPPrimer-Chapter7-Notes/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">三叔胡言乱语的地方</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-02-29T07:57:33.000Z" title="2020/2/29 15:57:33">2020-02-29</time>发表</span><span class="level-item"><time dateTime="2023-04-02T12:21:20.010Z" title="2023/4/2 20:21:20">2023-04-02</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a><span> / </span><a class="link-muted" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/">计算机语言</a></span><span class="level-item">1 小时读完 (大约9169个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">《C++ Primer》 第七章笔记</h1><div class="content"><p>《C++ Primer》 第七章笔记</p>
<p><img src="CPPPrimer-Chapter7-Notes/Ch_7.png" alt="第七章内容"></p>
<span id="more"></span>
<h1>Chapter 7 Classes</h1>
<h2 id="Defining-Abstract-Data-Types">Defining Abstract Data Types</h2>
<p>如果一个类让用户可以任意访问其中的数据，且必须自己定义针对相关数据的操作，则该类不是抽象类型。</p>
<h3 id="Designing-the-Sales-data-class">Designing the Sales_data class</h3>
<p>在本章中，会逐步完善一个称为Sales_data的类，在完善的过程中解释类的特性。</p>
<h3 id="Defining-the-Revised-Sales-data-Class">Defining the Revised Sales_data Class</h3>
<p>成员函数必须在类内声明，可以在类内或类外进行定义。且在类内定义的函数默认是内联（inline）的。</p>
<p>如目前Sales_data类为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::istream;</span><br><span class="line"><span class="keyword">using</span> std::ostream;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Member function</span></span><br><span class="line">    <span class="function">string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> bookNo; &#125;</span><br><span class="line">    <span class="function">Sales_data &amp;<span class="title">combine</span><span class="params">(<span class="type">const</span> Sales_data &amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">avg_Price</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Member variable</span></span><br><span class="line">    string bookNo;</span><br><span class="line">    <span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//nonmember but related function</span></span><br><span class="line"></span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data &amp;, <span class="type">const</span> Sales_data &amp;)</span></span>;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;, <span class="type">const</span> Sales_data &amp;)</span></span>;</span><br><span class="line"><span class="function">istream &amp;<span class="title">read</span><span class="params">(istream &amp;, Sales_data &amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="Introducing-this">Introducing this</h4>
<p>首先注意成员函数:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> bookNo; &#125;</span><br></pre></td></tr></table></figure>
<p>当类的实例化调用函数时，实际上会隐式的传递一个this指针，指针指向该实例的地址，如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sales_data total;</span><br><span class="line">total.<span class="built_in">isbn</span>();</span><br></pre></td></tr></table></figure>
<p>编译器会将<code>total.isbn()</code>调用，改写为类似于如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sales_data::<span class="built_in">isbn</span>(&amp;total);</span><br></pre></td></tr></table></figure>
<p>当在函数内部访问成员变量时都相当于用了<code>this-&gt;</code>。如函数体内访问了bookNo，实际上等同于<code>this-&gt;bookNo</code>，而这个调用下，this指向total，所以访问的是实例化total中的bookNo变量。</p>
<p>另外this是一个const指针，即无法让this指向别的变量。</p>
<h4 id="Intruducing-const-Member-Functions">Intruducing const Member Functions</h4>
<p>同样还是成员函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> bookNo; &#125;</span><br></pre></td></tr></table></figure>
<p>还需要注意到在这个函数的声明中有关键字<code>const</code>，当const跟在参数列表后时，其目的是改变this指针的类型，让this指针是一个指向const变量的指针。整个函数的定义会被编译器翻译为类似如下的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">Sales_data::isbn</span><span class="params">(<span class="type">const</span> Sales_data* <span class="type">const</span> <span class="keyword">this</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;bookNo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>称这样的函数为const函数。</p>
<p>如果该函数不是定义为const的，则const的Sales_data实例将无法调用isbn函数。如同变量的隐式转换规律，一个const变量无法赋值给一个指向非const变量的指针。实例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//In SalesData_Struct.h, modify the declaration of isbn function</span></span><br><span class="line"><span class="function">string <span class="title">isbn</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> bookNo; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Call isbn function</span></span><br><span class="line">Sales_data total;</span><br><span class="line">total.<span class="built_in">isbn</span>();</span><br><span class="line"><span class="type">const</span> Sales_data cTotal;</span><br><span class="line"><span class="comment">// cTotal.isbn();//error</span></span><br></pre></td></tr></table></figure>
<p>在编译器的隐式转换后，<code>cTotal.isbn()</code>会变成用一个<code>const Sales_data* const</code>类型的指针区初始化一个<code>Sales_data* const</code>类型的指针，如之前章节所述，该操作是非法的。</p>
<h4 id="Class-Scope-and-Member-Functions">Class Scope and Member Functions</h4>
<p>类的编译分为两步，首先会先编译所有的声明，然后再编译函数的定义（实现），因此在函数的实现中，可以任意调用其他的成员变量，无论它定义在更前面还是后面。</p>
<h4 id="Defining-a-Member-Function-outside-the-Class">Defining a Member Function outside the Class</h4>
<p>如果在类外定义const函数，同样需要在参数列表后加上const关键字</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">Sales_data::avg_Price</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (units_sold)</span><br><span class="line">        <span class="keyword">return</span> revenue / units_sold;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Defining-a-Function-to-Return-“This”-Object">Defining a Function to Return “This” Object</h4>
<p>如果成员函数返回类型是该类型本身或者该类型的引用，可以返回<code>*this</code>，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Sales_data &amp;<span class="title">Sales_data::combine</span><span class="params">(<span class="type">const</span> Sales_data &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    units_sold += rhs.units_sold;</span><br><span class="line">    revenue += rhs.revenue;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Defining-Nonmember-Class-Related-Functions">Defining Nonmember Class-Related Functions</h3>
<p>一些函数从概念上是某种类型的一部分，但却不是定义在函数的内部。这样的函数声明应该写在该类型的头文件（函数定义可以放在头文件对应的cpp文件中）。</p>
<p>如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//In SalesData_struct.h</span></span><br><span class="line"><span class="comment">//nonmember but related function</span></span><br><span class="line"></span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data &amp;, <span class="type">const</span> Sales_data &amp;)</span></span>;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;, <span class="type">const</span> Sales_data &amp;)</span></span>;</span><br><span class="line"><span class="function">istream &amp;<span class="title">read</span><span class="params">(istream &amp;, Sales_data &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//In SalesData_struct.cpp</span></span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data &amp;lhs, <span class="type">const</span> Sales_data &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Sales_data sum = lhs;</span><br><span class="line">    sum.<span class="built_in">combine</span>(rhs);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="type">const</span> Sales_data &amp;item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    os &lt;&lt; item.<span class="built_in">isbn</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.units_sold &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.revenue &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.<span class="built_in">avg_Price</span>();</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">istream &amp;<span class="title">read</span><span class="params">(istream &amp;is, Sales_data &amp;item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> price = <span class="number">0</span>;</span><br><span class="line">    is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;</span><br><span class="line">    item.revenue = price * item.units_sold;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意在函数<code>print</code>和<code>read</code>中返回的是ostream和istream的引用，这是因为这两个类型不支持拷贝。</p>
<p>在<code>add</code>函数中，首先是一个拷贝初始化<code>Sales_data sum = lhs</code>。C++的默认实现中，拷贝一个类类型会拷贝其中所有的成员变量，因此sum和lhs中的所有成员变量将有相同的值（但在不同的内存中）。</p>
<h3 id="Constructors">Constructors</h3>
<p>构造函数特点：</p>
<ol>
<li>构造函数在实例化创建时被执行。</li>
<li>构造函数与函数类型同名</li>
<li>构造函数没有返回值</li>
<li>构造函数不允许被定义成const函数。因为一个对象的const与否是在创建后才决定的，所以构造函数会在决定constness前先执行。</li>
</ol>
<h4 id="The-Synthesized-Default-Constructor">The Synthesized Default Constructor</h4>
<p>默认构造函数（default constructor）是不需要任何形参的构造函数。</p>
<p>当类没有定义任何构造函数时，编译器会创建合成默认构造函数（synthesized default constructor）。合成默认构造函数的操作为，当参数有类内初始化（变量定义时有初始化值），如<code>int a = 3;</code>，则使用类内初始化值进行值初始化，否则使用变量的默认初始化。</p>
<h4 id="Some-Classes-Cannot-Rely-on-the-synthesized-Default-Constructor">Some Classes Cannot Rely on the synthesized Default Constructor</h4>
<p>一些类无法依赖合成默认构造函数，因为</p>
<ol>
<li>只有类没有定义任何构造函数时，才会有合成默认构造函数</li>
<li>当没有类内初始化值时，合成默认构造函数会使用变量默认初始化，但内建类型（int等）和复合类型（array，pointer）出现在函数内部时默认值是未定义的。所以当且仅当这些参数有类内初始化值时才可以依赖合成默认构造函数，否则构造的结果是未定义的。</li>
<li>有的情况下，编译器无法生成合成默认构造函数。如类中的一个成员变量并没有默认构造函数，合成默认构造函数也就无法去初始化这个变量。因此在这种情况下，需要自己定义默认构造函数。</li>
</ol>
<h4 id="Defining-the-Sales-data-Constructors">Defining the Sales_data Constructors</h4>
<p>Sales_data构造函数定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Inside class body</span></span><br><span class="line"><span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="built_in">Sales_data</span>(<span class="type">const</span> string &amp;s) : <span class="built_in">bookNo</span>(s) &#123;&#125;</span><br><span class="line"><span class="built_in">Sales_data</span>(<span class="type">const</span> string &amp;s, <span class="type">unsigned</span> n, <span class="type">double</span> p) : <span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(n), <span class="built_in">revenue</span>(p * n) &#123;&#125;</span><br><span class="line"><span class="built_in">Sales_data</span>(istream &amp;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Outside class body</span></span><br><span class="line">Sales_data::<span class="built_in">Sales_data</span>(istream &amp;is)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">read</span>(is, *<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述一共定义了四个构造函数，其中三个是在类内定义的，一个是在类外定义的。</p>
<p>在定义默认构造函数时，使用了default关键字，该关键字是C++11的特性，表示希望构造函数表现的如同合成默认构造函数一模一样。</p>
<h4 id="Constructor-Initializer-List">Constructor Initializer List</h4>
<p>在构造函数中的定义中，出现在参数列表后，函数主体前，以<code>:</code>开头的部分称为初始化列表（Initializer List）。初始化列表必须出现在函数定义中，即必须与函数主体一起出现。</p>
<p>当一个成员变量没有出现在初始化列表中时，该函数的初始化逻辑与合成构造函数相同，即有类内初始化值使用类内初始化，否则使用默认初始化。</p>
<ul>
<li>建议为每个成员参数都设置类内初始化值</li>
</ul>
<h4 id="Defining-a-Constructor-outside-the-Class-Body">Defining a Constructor outside the Class Body</h4>
<p>如形参为<code>istream</code>版本的构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Sales_data</span>(istream &amp;);</span><br><span class="line"></span><br><span class="line">Sales_data::<span class="built_in">Sales_data</span>(istream &amp;is)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">read</span>(is, *<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该构造函数没有初始化列表，或者严格意义上说，初始化列表为空。则该构造函数会在执行函数主体前，先按照合成默认构造函数的逻辑初始化所有成员变量，然后再执行函数主体。</p>
<blockquote>
<p>尽量在初始化列表中初始化变量。如果将成员变量的赋值写在构造函数主体内，则实际上是经过了一个默认初始化，再进行了一个赋值。</p>
</blockquote>
<h3 id="Copy-Assignment-and-Destruction">Copy, Assignment, and Destruction</h3>
<p>类还要控制对象是如何被拷贝，赋值和摧毁的。</p>
<ol>
<li>拷贝：当使用对象初始化另一个变量，或作为值类型（没有引用）传递进函数或从函数返回时，对象都会经历拷贝。</li>
<li>赋值：当使用赋值操作符（<code>=</code>）时会经历赋值</li>
<li>摧毁：当对象退出作用域时会被摧毁。在数组和vector中的元素，会在容器摧毁时被摧毁。</li>
</ol>
<p>如果用户没有指定拷贝，赋值和摧毁的实现，编译器都会提供合成版本。以下代码展示了编译器提供的合成赋值操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">total = trans; <span class="comment">// synthesized assignment</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Equals to</span></span><br><span class="line">total.bookNo = trans.bookNo</span><br><span class="line">total.units_sold = trans.units_sold</span><br><span class="line">total.revenue = trans.revenue</span><br></pre></td></tr></table></figure>
<h4 id="Some-Classes-Canot-Rely-on-the-Synthesized-Versins">Some Classes Canot Rely on the Synthesized Versins</h4>
<p>通常来说，有动态内存分配的类不适合合成版本的拷贝，赋值和摧毁（第12章和13.1.4节会解释）。</p>
<p>但是合成版本可以正确处理string和vector，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Test firstOne;</span><br><span class="line">firstOne.value = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">Test secondOne;</span><br><span class="line">secondOne = firstOne;</span><br><span class="line"></span><br><span class="line">firstOne.value[<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;First one value is: &quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : firstOne.value)</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Second one value is: &quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : secondOne.value)</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// First one value is: </span></span><br><span class="line"><span class="comment">// 4 2 3</span></span><br><span class="line"><span class="comment">// Second one value is:</span></span><br><span class="line"><span class="comment">// 123</span></span><br></pre></td></tr></table></figure>
<p>Test类中仅包含一个vector，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到合成默认赋值正确的拷贝了vector中的每个元素。</p>
<h2 id="Access-Control-and-Encapsulation">Access Control and Encapsulation</h2>
<p>public关键字后的变量可以被程序的其他部分访问，private关键字后变量仅能被类中的成员函数访问。</p>
<p>public和private关键字可以出现在类中出现任意多次。</p>
<h4 id="Using-the-class-or-struct-keyboard">Using the class or struct keyboard</h4>
<p>struct和class的<strong>唯一</strong>区别在于，class中没有写在public和private后的成员默认是private的，而struct中则默认是public的（struct中同样可以定义public和private）。</p>
<h3 id="Friends">Friends</h3>
<p>一个类可以允许其他的类或者函数访问其中的非public变量，此时其他的函数或者类被称为友类（函数）（Friends）。</p>
<p>要声明函数是友函数，只需要在类中加上函数的声明，并且最前方加入<code>friend</code>关键字即可。如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data &amp;, <span class="type">const</span> Sales_data &amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;, <span class="type">const</span> Sales_data &amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> istream &amp;<span class="title">read</span><span class="params">(istream &amp;, Sales_data &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> string &amp;s);</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> string &amp;s, <span class="type">unsigned</span> n, <span class="type">double</span> p) : <span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(n), <span class="built_in">revenue</span>(p * n) &#123;&#125;</span><br><span class="line">    <span class="built_in">Sales_data</span>(istream &amp;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//Member function</span></span><br><span class="line">    <span class="function">string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> bookNo; &#125;</span><br><span class="line">    <span class="comment">// string isbn() &#123; return bookNo; &#125; // should be const</span></span><br><span class="line">    <span class="function">Sales_data &amp;<span class="title">combine</span><span class="params">(<span class="type">const</span> Sales_data &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">avg_Price</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">//Member variable</span></span><br><span class="line">    string bookNo;</span><br><span class="line">    <span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>friend</code>关键字只可以出现在类的定义中，而且因为严格意义上它并不是类的一部分，所以可以出现在类中的任意地方，不受public和private影响。</p>
<h4 id="Declarations-for-Friends">Declarations for Friends</h4>
<p>在类内部关于friends的声明并不是函数声明，因此应该在类外部再次声明函数。如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data &amp;, <span class="type">const</span> Sales_data &amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;, <span class="type">const</span> Sales_data &amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> istream &amp;<span class="title">read</span><span class="params">(istream &amp;, Sales_data &amp;)</span></span>; </span><br><span class="line"></span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sales_data returnAddResult(const Sales_data &amp;lhs, const Sales_data &amp;rhs)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     return add(lhs, rhs);</span></span><br><span class="line"><span class="comment">// &#125; //Error</span></span><br><span class="line"></span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data &amp;, <span class="type">const</span> Sales_data &amp;)</span></span>;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;, <span class="type">const</span> Sales_data &amp;)</span></span>;</span><br><span class="line"><span class="function">istream &amp;<span class="title">read</span><span class="params">(istream &amp;, Sales_data &amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>示例代码中的<code>returnAddResult</code>尝试返回<code>add</code>函数的结果，但因为<code>add</code>函数仅被声明为了友函数，并没有真正的进行声明，所以无法访问。</p>
<ul>
<li>虽然即使不在类外部再次声明函数，大部分的编译器也都能正确编译。但是C++标准是要求在类外再次声明的，即使程序在没有再次声明的情况下正常运行了，也不能保证该代码换一个编译器仍然能正常工作。</li>
</ul>
<h2 id="Additional-Class-Features">Additional Class Features</h2>
<p>7.1-7.2以<code>Sales_data</code>这个类作为例子说明了类的一些特性。在这一节中会继续深入探讨这些特性。</p>
<h3 id="Class-Members-Revisited">Class Members Revisited</h3>
<h4 id="Defining-a-Type-Member">Defining a Type Member</h4>
<p>在类内部，也可以定义Type成员。该成员与其他的成员类型一样，是受public和private关键字影响的。但与其他成员不同的是，在使用该类型前，必须已经出现了该类型的定义（对其他成员，会先编译声明，再编译定义，因此成员的位置不造成任何影响），如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// pos i = 0; //error, the pos hasn&#x27;t been </span></span><br><span class="line">    <span class="keyword">typedef</span> string::size_type pos;</span><br><span class="line">    <span class="comment">// using pos = string::size_type; // same with above</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    pos cursor = <span class="number">0</span>, height = <span class="number">0</span>, width = <span class="number">0</span>;</span><br><span class="line">    string content;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当在类外访问该别名时，也需要像访问普通变量一样，如<code>Screen::pos</code></p>
<h4 id="Making-Members-inline">Making Members inline</h4>
<p>如之前所述，定义在类内部的函数会隐式的认为为inline的。也可以通过显示的在函数类内声明或类外定义前加上inline来将函数变为内联函数，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">get</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> content[cursor];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">get</span><span class="params">(pos ht, pos wd)</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">Screen::get</span><span class="params">(pos ht, pos wd)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，<code>get()</code>是隐式的被定义为内联，<code>get(pos ht, pos wd)</code>是显示的被定义为内联，代码中<code>get(pos ht, pos wd)</code>的声明和定义处都加上了关键字inline，实际上只需要在任意一处定义即可。</p>
<p>注意如在第六章中所述，内联函数的定义建议与声明放在同一个头文件中</p>
<h4 id="mutable-Data-Members">mutable Data Members</h4>
<p>mutable数据成员永远不会是const的，即使在const函数中（this指针是指向const的指针）仍然能被修改。如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ChangeAccessCtr</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">size_t</span> accessCtr = <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Screen::ChangeAccessCtr</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ++accessCtr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上述代码中,<code>ChangeAccessCtr</code>是const函数，但因为accessCtr变量是mutable的，所以仍然能够修改accessCtr。</p>
<h3 id="Functions-That-Return-this">Functions That Return *this</h3>
<p>如果某成员函数返回的类型为类的引用，则该函数可以被正确的级联起来，否则虽然可以通过编译，但之后的操作是基于临时变量，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Define class function outside class</span></span><br><span class="line"><span class="function">Screen &amp;<span class="title">Screen::move</span><span class="params">(pos ht, pos wd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pos row = ht * width;</span><br><span class="line">    cursor = row + wd;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Screen &amp;<span class="title">Screen::set</span><span class="params">(<span class="type">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    content[cursor] = c;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Screen <span class="title">Screen::move_copy</span><span class="params">(pos ht, pos wd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pos row = ht * width;</span><br><span class="line">    cursor = row + wd;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Test code</span></span><br><span class="line"></span><br><span class="line"><span class="function">Screen <span class="title">sc</span><span class="params">(<span class="number">20</span>, <span class="number">20</span>, <span class="string">&#x27; &#x27;</span>)</span></span>;</span><br><span class="line">sc.<span class="built_in">move</span>(<span class="number">4</span>, <span class="number">0</span>).<span class="built_in">set</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;content is &quot;</span> &lt;&lt; sc.<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">sc.<span class="built_in">move_copy</span>(<span class="number">4</span>,<span class="number">0</span>).<span class="built_in">set</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;content is &quot;</span> &lt;&lt; sc.<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">content is a</span></span><br><span class="line"><span class="comment">content is a</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>如上述代码所示，<code>move</code>函数返回的是类型的引用，<code>move_copy</code>函数返回的是类型本身，因此实际上返回的是一个经过拷贝初始化临时变量。当对<code>move</code>函数的返回值调用<code>set</code>时，原先的值被修改了，而对<code>move_copy</code>函数的返回值调用<code>set</code>时，被修改的实际上是返回的临时变量。</p>
<h4 id="Returning-this-from-a-const-Member-Function">Returning *this from a const Member Function</h4>
<p>如果成员函数是const函数，且返回类型是该类型的指针或引用，那么该指针或引用是指向const变量的。也因此无法级联调用其他非const的函数，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//In Screen.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">const</span> Screen &amp;<span class="title">Display</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> Screen &amp;<span class="title">Screen::Display</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; content;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//In Chapter7_Classes.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sc.Display().set(&#x27;a&#x27;); //error when there is no nonconst overload</span></span><br></pre></td></tr></table></figure>
<p>在上述代码中，因为<code>Display</code>函数是const的，因此传入的this指针是<code>const Screen * const</code>类型，也因此如果返回的是<code>*this</code>，返回类型为<code>const Screen&amp;</code>。</p>
<p>调用语句<code>sc.Display().set('a')</code>失败，是因为set不是const函数，所以其this指针类型为<code>Screen * const</code>，而传入的是Display返回的变量指针，类型为<code>const Screen * const</code>，所以无法进行隐式转换。</p>
<h4 id="Overloading-Based-on-const">Overloading Based on const</h4>
<p>解决上述问题的方法是，定义一个非const的函数进行重载，因为函数的const与否实际是决定传入的this指针的类型，而且是low level的const区别，所以可以进行重载。如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//In Screen.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">const</span> Screen &amp;<span class="title">Display</span><span class="params">(ostream &amp;)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> Screen &amp;<span class="title">Display</span><span class="params">(ostream &amp;)</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">do_display</span><span class="params">(ostream &amp;os)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> Screen &amp;<span class="title">Screen::Display</span><span class="params">(ostream &amp;os)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">do_display</span>(os);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//In Screen.cpp</span></span><br><span class="line"><span class="function">Screen &amp;<span class="title">Screen::Display</span><span class="params">(ostream &amp;os)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">do_display</span>(os);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Screen::do_display</span><span class="params">(ostream &amp;os)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    os &lt;&lt; content;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//In Chapter7_Classes.cpp</span></span><br><span class="line">sc.<span class="built_in">Display</span>(cout).<span class="built_in">set</span>(<span class="string">&#x27;a&#x27;</span>); <span class="comment">// correct,when there is nonconst overwrite</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上述代码中，<code>sc.Display(cout).set('a')</code>可以成功运行，因为类中定义了const和非const两个版本的Display函数。该语句实际调用的是非const版本的Display，其中会调用const函数<code>do_display</code>，调用中存在将指向非const对象的指针（this指针）隐式转换为指向const对象的指针的过程。</p>
<h3 id="Class-Type">Class Type</h3>
<p>每个类都定义了一个独特的类型。两个不同的类即使其中的所有成员都一模一样，也无法相互赋值，但可以通过指针进行转换。如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//In Test.h</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">First</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> memi = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> getMem = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Second</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> memi = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> getMem = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//In Chapter7_Classes.cpp</span></span><br><span class="line"></span><br><span class="line">First first;</span><br><span class="line">Second sec;</span><br><span class="line">first.memi = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sec = first; //Error</span></span><br><span class="line"></span><br><span class="line">Second *sp = <span class="built_in">reinterpret_cast</span>&lt;Second *&gt;(&amp;first);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sp value is &quot;</span> &lt;&lt; sp-&gt;memi &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sp value is 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="Class-Declarations">Class Declarations</h4>
<p>可以在没有定义类的情况下声明类，如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">NotDefined</span>;</span><br></pre></td></tr></table></figure>
<p>这种声明称为前向声明(forward declaration)。在执行完声明，但还没有执行完定义前，类<code>NotDefined</code>是不完整类型（incomplete type）。编译器知道了该类型是类，但还不知道其中包含有什么成员。</p>
<p>当创建一个类型的实例化时，该类型必须经过了定义。否则编译器不知道需要为他分配多少的内存。</p>
<p>不完整类型只能用于三个地方：</p>
<ol>
<li>定义该类型的指针或引用</li>
<li>作为函数声明中的参数或者返回类型。注意是声明，不是定义</li>
<li>作为静态类型成为类的成员</li>
</ol>
<p>在类的定义过程中，类还是不完整的。因为不完整类型可以用于以上三个地方，所以一个类型可以将本类型的指针或引用作为成员参数，或作为静态成员。也可以用本类型作为成员函数的形参和返回值。如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TestNotDefined</span></span><br><span class="line">&#123;</span><br><span class="line">    NotDefined *np;</span><br><span class="line">    <span class="type">static</span> NotDefined ns;</span><br><span class="line">    <span class="function">NotDefined <span class="title">functionAboutNotDefine</span><span class="params">(NotDefined)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Friendship-Revisited">Friendship Revisited</h3>
<p>一个类可以将另一个类或者某个类中特定的成员函数作为友类或友函数。</p>
<h4 id="Friendship-between-Classes">Friendship between Classes</h4>
<p>在类中定义另一个类为友类，同样需要使用关键字<code>friend</code>，另外还需要指定类型为class，如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//In Screen.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Window_mgr</span>;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与定义普通的友函数一样，定义友类的语句可以出现在类定义内部的任何地方。此时，虽然出现了<code>Window_mgr</code>类名，但并不需要<code>Window_mgr</code>类被定义，甚至不需要其被声明。</p>
<p>定义<code>Window_mgr</code>类的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//In Window_mgr.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Screen.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Window_mgr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ScreenIndex = vector&lt;Screen&gt;::size_type;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">(ScreenIndex index)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;Screen&gt; screens&#123;<span class="built_in">Screen</span>(<span class="number">5</span>, <span class="number">5</span>, <span class="string">&#x27;a&#x27;</span>)&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//In Window_mgr.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Window_mgr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Window_mgr::Clear</span><span class="params">(ScreenIndex index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Screen &amp;s = screens[index];</span><br><span class="line">    s.content = <span class="built_in">string</span>(s.height * s.width, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里因为需要真切的用到Screen类型，所以需要引入<code>Screen.h</code>文件。注意在函数Clear的实现中，访问了Screen中的private成员，如height和width。</p>
<blockquote>
<p>友类或友函数性质不能传递，即A将B定义为朋友，B将C定义为朋友。但C并不是A的朋友，因此不能访问A中变量。</p>
</blockquote>
<h4 id="Making-A-member-Function-a-Friend">Making A member Function a Friend</h4>
<p>上例中是将完整的Window_mgr定义为友类，所以类中的所有函数都可以访问Screen的私有成员，存在一定的风险性。Screen可以仅将Window_mgr中的Clear函数定义为友函数，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//In Screen.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Window_mgr.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Window_mgr::Clear</span><span class="params">(ScreenIndex)</span></span>;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//In Window_mgr.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">Screen</span>;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Window_mgr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ScreenIndex = vector&lt;Screen&gt;::size_type;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">(ScreenIndex index)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;Screen&gt; screens;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//In Window_mgr.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Window_mgr.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Screen.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Window_mgr::Clear</span><span class="params">(Window_mgr::ScreenIndex index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Screen &amp;s = screens[index];</span><br><span class="line">    s.content = <span class="built_in">string</span>(s.height * s.width, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意当设置某类中的成员函数作为另一个类的友函数时，要额外注意引用依赖问题。</p>
<p>在本例中，因为在Screen类里要访问Window_mgr中的clear函数，所以这时就必须引入（include）<code>Window_mgr.h</code>。但这就会造成<code>Screen.h</code>中<code>include &quot;Window_mgr.h&quot;</code>，<code>Window_mgr.h</code>中<code>include &quot;Screen.h&quot;</code>的相互依赖。</p>
<p>实际上在<code>Window_mgr.h</code>中根本不需要访问<code>Screen</code>类中的成员，而仅仅是将<code>Screen</code>类作为形参类型和Vector中元素类型，因此完全可以使用不完整类型，即仅仅声明Screen类，代码中写为<code>class Screen;</code>。而在<code>Window_mgr.cpp</code>中因为需要访问了<code>Screen</code>类中的成员，所以必须引入<code>Screen.h</code>。</p>
<p>总结定义和声明顺序应该为：</p>
<ol>
<li>定义<code>Window_mgr</code>类，其中只能声明<code>Clear</code>函数，不能定义<code>Clear</code>函数，否则就需要访问到<code>Screen</code>中的成员，则必须引用<code>Screen.h</code>，这里要避免引用。当需要用到<code>Screen</code>类型本身时，声明<code>Screen</code>类。</li>
<li>定义<code>Screen</code>类，其中声明<code>Window::mgr</code>为友函数。此步骤需要引入<code>Window_mgr</code>的定义。</li>
<li>定义<code>clear</code>函数，此步骤需要引入<code>Screen</code>类定义</li>
</ol>
<h4 id="Overloaded-Functions-and-Friendship">Overloaded Functions and Friendship</h4>
<p>在声明一个函数为友函数时，需要带上函数的返回类型和参数。因此当友函数有重载类型时，仅会将满足友函数定义的那个版本作为友函数。</p>
<h4 id="Friend-Declarations-and-Scope">Friend Declarations and Scope</h4>
<p>如之前所述，友类和友函数的声明，并非是该函数的真正声明。该函数未进行外部声明时，仍然是无法被其他的函数使用的，如下代码所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// X() &#123; f(); &#125; //error</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void X::g() &#123; return f(); &#125; //error</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">X::h</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">f</span>(); &#125;</span><br></pre></td></tr></table></figure>
<p>虽然代码中声明了<code>f()</code>为友函数，但构造函数和函数<code>g()</code>都是在外部声明前想访问函数<code>f()</code>，所以都会造成编译错误，而<code>h()</code>在外部声明后再进行定义，因此就能正常访问。</p>
<h2 id="Class-Scope">Class Scope</h2>
<h4 id="Scope-and-Members-Defined-outside-the-Class">Scope and Members Defined outside the Class</h4>
<p>类的定义本身就是一个作用域，因此在类外定义成员函数时需要加上<code>::</code>操作符。</p>
<p>当成员函数的名字出现后，它的参数列表和定义主体就是在作用域里面的了。因此在参数列表和定义主体中访问类中成员时不需要加上<code>::</code>操作符。但是返回类型是在作用域外的，所以返回类型是类中的成员类型，则需要加上<code>::</code>操作符。如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//In Window_mgr.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Window_mgr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ....</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">(ScreenIndex index)</span></span>;</span><br><span class="line">    <span class="function">ScreenIndex <span class="title">addScreen</span><span class="params">(<span class="type">const</span> Screen &amp;s)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//In Window_mgr.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Window_mgr::Clear</span><span class="params">(ScreenIndex index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Screen &amp;s = screens[index];</span><br><span class="line">    s.content = <span class="built_in">string</span>(s.height * s.width, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Window_mgr::ScreenIndex <span class="title">Window_mgr::addScreen</span><span class="params">(<span class="type">const</span> Screen &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    screens.<span class="built_in">push_back</span>(s);</span><br><span class="line">    <span class="keyword">return</span> screens.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在例子中，当<code>ScreenIndex</code>出现在了参数列表中时不需要加上<code>Window_mgr::</code>修饰作用域，但是当<code>ScreenIndex</code>作为返回类型时则必须加上。</p>
<h3 id="Name-Lookup-and-Class-Scope">Name Lookup and Class Scope</h3>
<p>C++找寻一个名字的含义时步骤是：</p>
<ol>
<li>现在使用该名字的作用域里搜索该名字的声明，声明必须出现在使用之前</li>
<li>如果名字在当前作用域没有找到，在其嵌套的作用域中寻找（同样需要出现在使用之前）</li>
<li>如果找不到声明，则报错</li>
</ol>
<p>类编译的顺序为：</p>
<ol>
<li>先编译所有的声明</li>
<li>所有声明编译完，整个类的成员都是可见后，再编译函数主体等定义部分。</li>
</ol>
<h4 id="Name-Lookup-for-Class-Member-Declarations">Name Lookup for Class Member Declarations</h4>
<p>C++找寻名字的策略和类编译顺序共同决定了以下结果：</p>
<ol>
<li>当名字出现在返回类型或者参数列表中时，该名字必须在使用前已经声明过</li>
<li>当名字出现在成员函数主体中时，如果在使用该名字前无法在函数内部找到该名字的声明，则在类内部搜索该名字，所有的类成员变量都会被搜索，无论它的出现顺序。</li>
</ol>
<p>如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> Money;</span><br><span class="line">string bal;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Money <span class="title">balnce</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> bal; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Money bal;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，函数<code>balance</code>返回的bal是成员变量<code>Money bal</code>，而不是全局变量string，即使成员变量的声明在全局变量<code>bal</code>使用后面。</p>
<h4 id="Type-Names-Are-Special">Type Names Are Special</h4>
<p>通常而言，Type声明可以在嵌套的作用域中重新修改，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> Money;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testTypedef</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Money i;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">int</span> Money;<span class="comment">//correct</span></span><br><span class="line">    Money j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i的类型为double，j的类型为int。</p>
<p>但是在类中不允许重新定义，即使是一样的类型，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> Money;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Money <span class="title">balnce</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> bal; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// typedef double Money; //error, class not allow redefine</span></span><br><span class="line">    Money bal;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>很多的编译器仍然会允许类内进行type重定义，但这样的行为是不符合标准的，无法保证在更换了编译器后仍然能正常工作。</p>
</blockquote>
<h4 id="Normal-Block-Scope-Name-Lookup-inside-Member-Definitions">Normal Block-Scope Name Lookup inside Member Definitions</h4>
<h4 id="After-Class-Scope-Look-in-the-Surrounding-Scope">After Class Scope, Look in the Surrounding Scope</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//In Screen.cpp</span></span><br><span class="line"><span class="type">int</span> height = <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Screen::dummyFcn</span><span class="params">(pos height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;height is &quot;</span> &lt;&lt; height &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Screen height is &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;height &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Global height is &quot;</span> &lt;&lt; ::height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//In Chapter7_Classes.cpp</span></span><br><span class="line"><span class="function">Screen <span class="title">s</span><span class="params">(<span class="number">10</span>, <span class="number">2</span>, <span class="string">&#x27; &#x27;</span>)</span></span>;</span><br><span class="line">s.<span class="built_in">dummyFcn</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">height is 3</span></span><br><span class="line"><span class="comment">Screen height is 10</span></span><br><span class="line"><span class="comment">Global height is 5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="Constructors-Revisited">Constructors Revisited</h2>
<h3 id="Constructor-Initializer-List-2">Constructor Initializer List</h3>
<h4 id="Constructor-Initializers-Are-Sometimes-Required">Constructor Initializers Are Sometimes Required</h4>
<p>const成员变量必须通过初始化列表进行初始化，因为在构造函数体内部的操作实际上是赋值不是初始化，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConstRef</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">ConstRef</span>(<span class="type">int</span> ii) : <span class="built_in">ci</span>(ii), <span class="built_in">ri</span>(ii)</span><br><span class="line">    &#123;</span><br><span class="line">        i = ii;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ConstRef(int ii) //error</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     ri = i;</span></span><br><span class="line">    <span class="comment">//     ci = i;</span></span><br><span class="line">    <span class="comment">//     i = ii;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> ci;</span><br><span class="line">    <span class="type">int</span> &amp;ri;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上述代码中，<code>ci</code>和<code>ri</code>必须通过初始化列表进行初始化，而i可以出现在初始化列表中（初始化），或者在出现在构造函数体内（先被默认初始化，因为是内置类型，所以结果为未定义，再将ii赋值给它）</p>
<h4 id="Order-of-Member-Initialization">Order of Member Initialization</h4>
<p>成员参数的初始化顺序是由其在声明中出现的顺序决定的，和在初始化列表中的顺序无关。如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Num</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Num</span>(<span class="type">int</span> val) : <span class="built_in">j</span>(val), <span class="built_in">i</span>(j) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;i value is: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;j value is: &quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Num <span class="title">n</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">n.<span class="built_in">Print</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">i value is: 0</span></span><br><span class="line"><span class="comment">j value is: 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>在上例中，初始化列表中是先出现用<code>val</code>值初始化<code>j</code>，再通过<code>j</code>初始化<code>i</code>。但因为类的声明顺序中，是先声明了<code>i</code>再声明<code>j</code>。所以实际上的运行逻辑为，用未定义的<code>j</code>初始化了<code>i</code>，再通过<code>val</code>值初始化了<code>j</code>。</p>
<p>因此输出结果为<code>i</code>为0，<code>j</code>为2，<code>i</code>的值实际上是未定义的。</p>
<h3 id="Delegating-Constructors">Delegating Constructors</h3>
<p>代理构造函数时可以通过该类中的另一个构造函数来完成初始化，如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">Sales_data::Sales_data</span><span class="params">(<span class="type">const</span> string &amp;s, <span class="type">unsigned</span> n, <span class="type">double</span> p)</span> : bookNo(s), units_sold(n), revenue(p * n)</span></span><br><span class="line"><span class="function">&#123;</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Constructor with 3 parameters&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">Sales_data::Sales_data</span><span class="params">()</span> : Sales_data(<span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span><br><span class="line"><span class="function">&#123;</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Constructor with no Parameters&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">Sales_data::Sales_data</span><span class="params">(<span class="type">const</span> string &amp;s)</span> : Sales_data(s, <span class="number">0</span>, <span class="number">0</span>)</span></span><br><span class="line"><span class="function">&#123;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// inline Sales_data::Sales_data(istream &amp;is) : Sales_data(),revenue(0) &#123; read(is, *this); &#125;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">Sales_data::Sales_data</span><span class="params">(istream &amp;is)</span> : Sales_data()</span></span><br><span class="line"><span class="function">&#123;</span></span><br><span class="line">    <span class="built_in">read</span>(is, *<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，当使用了代理构造函数时，初始化列表中就不能出现其他的变量初始化了，如上述代码尝试同时使用代理构造函数和初始化revenue就失败了。</p>
<p>当一个构造函数使用另一个代理构造函数时，代理构造函数的列表初始化会先运行，然后它的函数体会执行，最后执行本构造函数的函数体，如使用语句<code>Sales_data s</code>调用无参构造函数，它会调用三个参数的代理构造函数，输入结果如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Constructor with 3 parameters</span></span><br><span class="line"><span class="comment">Constructor with no Parameters</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>可以看出，三个参数的代理构造函数先运行了，然后运行的是无参构造函数。</p>
<h3 id="The-Role-of-the-Default-Constructor">The Role of the Default Constructor</h3>
<p>无论一个对象是被默认初始化还是值初始化（相关概念在3.3.1节中），默认构造函数都会被执行。</p>
<p>默认初始化在以下情况会发生：</p>
<ol>
<li>当在代码作用域中定义了非static的变量或者数组，且数组没有初始化列表（<code>&#123;&#125;</code>）</li>
<li>当一个类有使用合成默认构造函数的类成员。</li>
<li>当类中的成员在构造函数中并没有通过初始化列表进行初始化，这些成员会被默认初始化。</li>
</ol>
<p>值初始化在以下情况发生：</p>
<ol>
<li>定义数组时，提供了初始化列表，但是列表大小小于数组大小，剩余元素被值初始化。</li>
<li>当定义局部static变量</li>
<li>对于类类型，使用<code>T()</code>形式进行声明，所以Vector(n)，里面的元素都进行的是值初始化。</li>
</ol>
<h3 id="Using-the-Default-Constructor">Using the Default Constructor</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NoDefault</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NoDefault</span>(<span class="type">const</span> string);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    NoDefault my_mem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A a;</span></span><br><span class="line"><span class="comment">// A a = A();</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// B()&#123;&#125;; //error</span></span><br><span class="line">    <span class="built_in">B</span>() : <span class="built_in">b_member</span>(<span class="string">&quot;&quot;</span>)&#123;&#125;;</span><br><span class="line">    NoDefault b_member;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上述代码中，<code>NoDefault</code>没有默认构造函数。当<code>A</code>包含有<code>NoDefault</code>类型的成员，A的合成默认构造函数就无法使用，因为其无法调用<code>NonDefault</code>变量的默认构造函数。</p>
<p>语句<code>A a;</code>使用的是默认初始化，<code>A a=A()</code>使用的是值初始化，但两者都无法通过编译。</p>
<p>同理，在<code>B</code>中必须手动的在初始化列表中为<code>NonDefault</code>类型变量初始化，否则在尝试调用其默认构造函数时会发生错误。</p>
<h3 id="Implicit-Class-Type-Conversions">Implicit Class-Type Conversions</h3>
<p>可以通过<strong>一个参数</strong>被调用的类构造器提供了隐式类型转换，从调用参数转换为该类型。</p>
<p>如<code>Sales_data</code>类提供了只需要一个const string引用的构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">Sales_data::Sales_data</span><span class="params">(<span class="type">const</span> string &amp;s)</span> : Sales_data(s, <span class="number">0</span>, <span class="number">0</span>)</span></span><br><span class="line"><span class="function">&#123;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此可以从const string类型隐式转换为Sales_data，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Sales_data &amp;<span class="title">Sales_data::combine</span><span class="params">(<span class="type">const</span> Sales_data &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    units_sold += rhs.units_sold;</span><br><span class="line">    revenue += rhs.revenue;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">string null_book = <span class="string">&quot;9999&quot;</span>;</span><br><span class="line">Sales_data item;</span><br><span class="line">item.<span class="built_in">combine</span>(null_book);</span><br></pre></td></tr></table></figure>
<p>上述代码中<code>null_book</code>会隐式转化成<code>Sales_data</code>对象，然后传递给<code>combine</code>函数。</p>
<p>注意这一步中，<code>null_book</code>隐式转换成的对象是一个临时变量，当combine函数执行完后就会被抛弃。</p>
<h4 id="Only-One-Class-Type-Conversions-Is-Allowed">Only One Class-Type Conversions Is Allowed</h4>
<p>需要注意，语句<code>item.combine(&quot;9999&quot;)</code>无法通过编译。</p>
<p>因为<code>&quot;9999&quot;</code>类型是C类型的字符串，它要先隐式转换为<code>string</code>，<code>string</code>再隐式转换为<code>Sales_data</code>，该过程包含了两次隐式转换，而C++的隐式转换仅支持一次，所以编译器无法执行。</p>
<h4 id="Suppressing-Implicit-Conversions-Defined-by-Constructors">Suppressing Implicit Conversions Defined by Constructors</h4>
<p>可以通过<code>explicit</code>关键字禁止构造函数的隐式转换，<code>explicit</code>关键字仅能出现在类内的成员函数声明中。如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Sales_data</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span>;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">string null_book = <span class="string">&quot;9999&quot;</span>;</span><br><span class="line">Sales_data item;</span><br><span class="line"><span class="comment">// item.combine(null_book);// error, when constructor isexplicit</span></span><br><span class="line">item.<span class="built_in">combine</span>(<span class="built_in">Sales_data</span>(null_book));<span class="comment">//Direct Initialization</span></span><br><span class="line">item.<span class="built_in">combine</span>(<span class="built_in">static_cast</span>&lt;Sales_data&gt;(null_book));<span class="comment">//static_cast</span></span><br></pre></td></tr></table></figure>
<p>在上述代码中可以看到，Sales_data构造函数被定义为了explicit，隐式转换不再能执行，但仍然可以通过直接初始化和<code>static_cast</code>进行转换。</p>
<p>标准库中：</p>
<ol>
<li>string类型有通过const char*的构造函数，如<code>string(&quot;abc&quot;)</code>，该构造函数不是explicit的</li>
<li>vector类型中有通过int的构造函数，如<code>vector(2)</code>，该构造函数是explicit的</li>
</ol>
<h3 id="Aggregate-Classes">Aggregate Classes</h3>
<p>如果一个类满足以下条件，则它是一个聚合类（Aggregate Classes）：</p>
<ol>
<li>所有的成员变量都是public的</li>
<li>没有定义任何的构造函数</li>
<li>没有任何的类内初始值（如<code>int a = 1</code>）</li>
<li>没有基类，没有虚函数。</li>
</ol>
<p>如下就是一个聚合类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Data</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ival;</span><br><span class="line">    string s;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于聚合类，可以通过大括号进行初始化，大括号中的参数按顺序与聚合类中定义的变量一一初始化。如果大括号中的参数数量小于聚合类中的数据数量，后面的参数进行值初始化。如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Data val1&#123;<span class="number">0</span>, <span class="string">&quot;Anna&quot;</span>&#125;;</span><br><span class="line">Data val2&#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Literal-Classes">Literal Classes</h3>
<p>//TODO,after read 2.4.4</p>
<h2 id="static-Class-Members">static Class Members</h2>
<p>当给成员变量加上<code>static</code>关键字后，该变量就变成了静态成员变量，静态成员变量也受到public，private等关键字的影响。</p>
<p>静态成员可以是const的，但静态函数不允许是const的。如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account_S</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        amount += amount * interestRate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">rate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> interestRate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">rate</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string owner;</span><br><span class="line">    <span class="type">double</span> amount;</span><br><span class="line">    <span class="type">static</span> <span class="type">double</span> interestRate;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">double</span> cRate;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">InitRate</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// static double CInitRate() const; //error static member function can&#x27;t be const</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一个类的对象实际上并不包含其中的静态成员，因此静态函数也没有this指针，所以定义为函数定义为const与否并没有意义。</p>
<h4 id="Using-a-Class-static-Member">Using a Class static Member</h4>
<p>可以通过作用域操作符，对象本身，对象引用，对象指针等来访问静态成员，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> r = Account_S::<span class="built_in">rate</span>();</span><br><span class="line">Account_S ac1;</span><br><span class="line">Account_S *ac2 = &amp;ac1;</span><br><span class="line">r = ac1.<span class="built_in">rate</span>();</span><br><span class="line">r = ac2-&gt;<span class="built_in">rate</span>();</span><br></pre></td></tr></table></figure>
<p>对于普通成员函数而言，可以直接通过访问静态成员，如<code>Account_S</code>中的方法<code>calculate</code>，其中直接访问了静态成员<code>interestRata</code>。</p>
<h4 id="Defining-static-Members">Defining static Members</h4>
<p>当在类外定义静态成员函数时，不需要再次写明<code>static</code>关键字，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Account_S::rate</span><span class="params">(<span class="type">double</span> rate)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    interestRate = rate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为静态成员变量不是类对象的一部分，因此不能使用类内初始值，也不会被构造函数初始化（但可以在构造函数函数体内赋值），如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account_S</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Account_S() : interestRate(0) //error</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Account_S</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        interestRate = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// static double interestRate = 2;//error</span></span><br><span class="line">    <span class="type">static</span> <span class="type">double</span> interestRate;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当尝试使用类内初始值时就会发生编译错误，静态成员变量的初始化过程与静态成员函数定义过程相同，如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//inside class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account_S</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">double</span> RateD;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> RateD interestRate;</span><br><span class="line">    <span class="type">static</span> <span class="type">double</span> interest;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">InitRate</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//outside class</span></span><br><span class="line">Account_S::RateD Account_S::interestRate = <span class="built_in">InitRate</span>();</span><br><span class="line"><span class="type">double</span> Account_S::interest = <span class="number">2.0</span>;</span><br></pre></td></tr></table></figure>
<p>如同在定义成员函数时一样，当成员函数的名字出现后，参数列表和函数主体就已经在作用域内部了。同理在上述定义中，当成员变量<code>interestRate</code>名字出现后，其余的部分就已经在作用域里了（变量的参数类型在名字出现前，所以不在作用域里），因此<code>InitRate</code>不需要使用作用域操作符来访问。</p>
<h4 id="In-Class-Initialization-of-static-Data-Members">In-Class Initialization of static Data Members</h4>
<p>//TODO，关于 costexpr</p>
<h4 id="static-Members-Can-be-Used-in-Ways-Ordinary-Members-Can’t">static Members Can be Used in Ways Ordinary Members Can’t</h4>
<ol>
<li>当一个类型是不完整类型时，无法使用该类型作为类中普通成员变量的类型，但可以作为类中静态成员变量的类型，如</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">static</span> Bar mem1;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>可以在类中使用静态成员变量作为成员函数的初始值，而普通成员变量不行，如</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account_S</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// void TestDefaultValue(double a = amount)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">// &#125;//can not use member variable as default parameters</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">TestDefaultValue</span><span class="params">(<span class="type">double</span> a = interest)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;<span class="comment">//can use member variable as default parameters</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> amount;</span><br><span class="line">    <span class="type">static</span> <span class="type">double</span> interest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<article class="message is-info">
        
        <div class="message-body">
            <p>引用：</p>
<ol>
<li><em>Cpp Primer</em> 5th Aug.2012</li>
</ol>

        </div>
    </article>
<hr>
</div><div class="article-licensing box"><div class="licensing-title"><p>《C++ Primer》 第七章笔记</p><p><a href="https://xuejiaw.github.io/CPPPrimer-Chapter7-Notes/">https://xuejiaw.github.io/CPPPrimer-Chapter7-Notes/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>三叔</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2020-02-29</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2023-04-02</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a><a class="link-muted mr-2" rel="tag" href="/tags/C/">C++</a></div><!--!--></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/alipay.jpg" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/wechat.jpg" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/3DMathPrimerForGraphicsAGameDevelopment-Chapter3-Notes/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">《3D数学基础：图形和游戏开发》第三章笔记</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/3DMathPrimerForGraphicsAGameDevelopment-Chapter2-Notes/"><span class="level-item">《3D数学基础：图形和游戏开发》第二章笔记</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="content" id="valine-thread"></div><script src="//cdn.jsdelivr.net/npm/leancloud-storage@3/dist/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@1.4.16/dist/Valine.min.js"></script><script>new Valine({
            el: '#valine-thread',
            appId: "TGA1EB8Nf5aw6uJBpw45pBJQ-gzGzoHsz",
            appKey: "z1vCYavVUbCGuMjNMcrsvShN",
            placeholder: "匿名的！不需要注册！想说啥直接说吧！",
            avatar: "mm",
            avatarForce: false,
            meta: ["nick","mail","link"],
            pageSize: 10,
            lang: "zh-CN",
            visitor: true,
            highlight: true,
            recordIP: false,
            
            
            
            enableQQ: true,
            requiredFields: [],
        });</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.jpg" alt="三叔"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">三叔</p><p class="is-size-6 is-block">XR 行业的 Unity 开发者</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">71</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">15</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">18</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://www.zhihu.com/people/wang-xue-jia-20" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/xuejiaW"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Zhihu" href="https://www.zhihu.com/people/wang-xue-jia-20"><i class="fab fa-zhihu"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Jike" href="https://web.okjike.com/u/9ca63fe3-362f-458a-84ba-ec92a1dad321"><i class="fa-solid fa-j"></i></a></div></div></div><!--!--><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E5%8D%9A%E6%96%87%E7%AC%94%E8%AE%B0/"><span class="level-start"><span class="level-item">博文笔记</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%99%E7%A8%8B/"><span class="level-start"><span class="level-item">教程</span></span><span class="level-end"><span class="level-item tag">8</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E6%95%99%E7%A8%8B/Git/"><span class="level-start"><span class="level-item">Git</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%99%E7%A8%8B/Hexo/"><span class="level-start"><span class="level-item">Hexo</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%99%E7%A8%8B/%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">标记语言</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%99%E7%A8%8B/%E7%BF%BB%E5%A2%99%E6%A2%AF%E5%AD%90/"><span class="level-start"><span class="level-item">翻墙梯子</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"><span class="level-start"><span class="level-item">论文笔记</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="level-start"><span class="level-item">读书笔记</span></span><span class="level-end"><span class="level-item tag">58</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"><span class="level-start"><span class="level-item">图形学</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="level-start"><span class="level-item">数据库</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">数据结构与算法</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/"><span class="level-start"><span class="level-item">游戏设计</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="level-start"><span class="level-item">计算机网络</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">计算机语言</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="level-start"><span class="level-item">设计模式</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-09-24T15:13:39.000Z">2020-09-24</time></p><p class="title"><a href="/LearnOpenGL-Notes-2/">《LearnOpenGL》 笔记（二）</a></p><p class="categories"><a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a> / <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%BD%A2%E5%AD%A6/">图形学</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-05-25T12:41:17.000Z">2020-05-25</time></p><p class="title"><a href="/LearnOpenGL-Notes-1/">《LearnOpenGL》 笔记 (一)</a></p><p class="categories"><a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a> / <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%BD%A2%E5%AD%A6/">图形学</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-05-13T23:07:55.000Z">2020-05-14</time></p><p class="title"><a href="/CPPPrimer-Chapter8-Notes/">《C++ Primer》 第八章笔记</a></p><p class="categories"><a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a> / <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/">计算机语言</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-04-13T14:08:54.000Z">2020-04-13</time></p><p class="title"><a href="/3DMathPrimerForGraphicsAGameDevelopment-Chapter9-Notes/">《3D数学基础：图形和游戏开发》第九章笔记</a></p><p class="categories"><a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a> / <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%BD%A2%E5%AD%A6/">图形学</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-04-07T06:55:42.000Z">2020-04-07</time></p><p class="title"><a href="/3DMathPrimerForGraphicsAGameDevelopment-Chapter8-Notes/">《3D数学基础：图形和游戏开发》第八章笔记</a></p><p class="categories"><a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a> / <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%BD%A2%E5%AD%A6/">图形学</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2020/"><span class="level-start"><span class="level-item">2020</span></span><span class="level-end"><span class="level-item tag">38</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/"><span class="level-start"><span class="level-item">2019</span></span><span class="level-end"><span class="level-item tag">32</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/"><span class="level-start"><span class="level-item">2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/3D%E6%95%B0%E5%AD%A6/"><span class="tag">3D数学</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hexo/"><span class="tag">Hexo</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OpenGL/"><span class="tag">OpenGL</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8D%9A%E6%96%87%E7%AC%94%E8%AE%B0/"><span class="tag">博文笔记</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"><span class="tag">图形学</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%88%E7%8E%87%E6%8F%90%E5%8D%87/"><span class="tag">效率提升</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="tag">数据库</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><span class="tag">数据结构与算法</span><span class="tag">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/"><span class="tag">标记语言</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/"><span class="tag">游戏设计</span><span class="tag">14</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BF%BB%E5%A2%99%E6%A2%AF%E5%AD%90/"><span class="tag">翻墙梯子</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%99%9A%E6%8B%9F%E7%8E%B0%E5%AE%9E/"><span class="tag">虚拟现实</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="tag">计算机网络</span><span class="tag">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"><span class="tag">论文笔记</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="tag">设计模式</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="tag">读书笔记</span><span class="tag">58</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/"><span class="tag">软件推荐</span><span class="tag">2</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">三叔胡言乱语的地方</a><p class="is-size-7"><span>&copy; 2023 三叔</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>