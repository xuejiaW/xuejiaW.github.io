<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C# $ 字符串插值</title>
    <url>/$_string_interpolation/</url>
    <content><![CDATA[<h1 id="字符"><a class="header-anchor" href="#字符">#</a>$ 字符</h1>
<p>字符串插值（String Interpolation）有许多的实现方式，其中使用 <code>$</code> 字符在现代 C# 中时比较推荐的方式，它提供类似于 <code>String.Format</code> 的效果。</p>
<div class="note info simple"><p>实际根据 <code>$</code> 使用场景的不同，编译器会选择用不同的方式实现字符串插值，<code>String.Format</code> 只是其中一种，具体见 <a href="/$_string_interpolation/#%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82">实现细节</a></p>
</div>
<p>如下分别为使用 <code>$</code> 和 <code>String.Format</code>的示例：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> <span class="keyword">value</span> = <span class="number">3</span>;</span><br><span class="line">Debug.Log(<span class="string">$&quot;Value is <span class="subst">&#123;<span class="keyword">value</span>&#125;</span>&quot;</span>);</span><br><span class="line">Debug.Log(String.Format(<span class="string">&quot;Value is &#123;0&#125;&quot;</span>, <span class="keyword">value</span>));</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Value is 3</span><br><span class="line">Value is 3</span><br></pre></td></tr></table></figure>
<h1 id="使用方式"><a class="header-anchor" href="#使用方式">#</a>使用方式</h1>
<h2 id="创建内插字符串"><a class="header-anchor" href="#创建内插字符串">#</a>创建内插字符串</h2>
<p><code>字符串插值（String Interpolation）</code> 是用来将表达式插入到字符串中的方式，简单的示例如下所示：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> name = <span class="string">&quot;wxj&quot;</span>;</span><br><span class="line">Debug.Log(<span class="string">$&quot;Hello,<span class="subst">&#123;name&#125;</span>.&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Hello,wxj.</span><br></pre></td></tr></table></figure>
<p>其中 <code>$&quot;Hello,&#123;name&#125;.&quot;)</code> 被称为 <code>内插字符串表达式（interpolated string expression）</code>（下简称 <code>内插表达式</code>），最后输出的 <code>Hello,wxj.</code> 被称为 <code>结果字符串（result string）</code></p>
<p>由上例可以看出字符串插值的两个必要因素：</p>
<ol>
<li>在字符串前需要有 <code>$</code> 字符标记，且该字符与后续的 <code>&quot;</code> 间不能有空格。</li>
<li>在内插表达式内部可以有一个或多个 <code>&#123;&#125;</code> ，其中包含着任何返回结果的 C# 表达式，表达式的返回值也可以为 <code>null</code>。</li>
</ol>
<h2 id="包含不同的数据类型"><a class="header-anchor" href="#包含不同的数据类型">#</a>包含不同的数据类型</h2>
<p>对于内插表达式中的各 C# 表达式可以是任何类型的，如下所示：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> item = (Name: <span class="string">&quot;eggplant&quot;</span>, Price: <span class="number">1.99</span>m, perPackage: <span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> date = DateTime.Now;</span><br><span class="line">Debug.Log(<span class="string">$&quot;On <span class="subst">&#123;date&#125;</span>, the price of <span class="subst">&#123;item.Name&#125;</span> was <span class="subst">&#123;item.Price&#125;</span> per <span class="subst">&#123;item.perPackage&#125;</span> items.&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">On 12/10/2021 8:26:07 AM, the price of eggplant was 1.99 per 3 items.</span><br></pre></td></tr></table></figure>
<p>可以看到该内插字符串表达式中包含有各种类型的表达式（<code>string</code>，<code>Decimal</code>，<code>int</code>，<code>DeltaTime</code>），在最终的结果中都被正确的解析。</p>
<p>内插字符串表达式，各表达式都会被转换为 <code>string</code>，且规则如下：</p>
<ol>
<li>如果表达式结果为 <code>null</code> ，将其转换为空字符串。</li>
<li>如果表达式结果不为 <code>null</code>，对其调用 <code>ToString</code> 函数。</li>
</ol>
<h2 id="控制内插表达式的格式"><a class="header-anchor" href="#控制内插表达式的格式">#</a>控制内插表达式的格式</h2>
<p>在内插表达式中，还可以控制各表达式转换到 <code>string</code> 时的格式，如下所示：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">DateTime date = DateTime.Now;</span><br><span class="line"><span class="built_in">float</span> <span class="keyword">value</span> = <span class="number">1.12345678f</span>;</span><br><span class="line">Debug.Log(<span class="string">$&quot;On <span class="subst">&#123;date&#125;</span>, value is <span class="subst">&#123;<span class="keyword">value</span>&#125;</span>&quot;</span>);</span><br><span class="line">Debug.Log(<span class="string">$&quot;On <span class="subst">&#123;date:d&#125;</span>, value is <span class="subst">&#123;<span class="keyword">value</span>:f3&#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">On 12/10/2021 8:39:56 AM, value is 1.123457</span><br><span class="line">On 12/10/2021, value is 1.123</span><br></pre></td></tr></table></figure>
<p>在内插表达式中的各表达式中可以通过 <code>:</code> 后加控制的字符格式化输出。如上例中的 <code>d</code> 和 <code>f3</code> 即为控制字符。</p>
<div class="note info simple"><p><code>:</code> 后的控制字符，相当于在调用 <code>ToString</code> 时作为形参控制表达式的输出。</p>
<p>上述表达式等同于：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Debug.Log(<span class="string">&quot;On &quot;</span> + date.ToString(<span class="string">&quot;d&quot;</span>) + <span class="string">&quot;, value is &quot;</span> + <span class="keyword">value</span>.ToString(<span class="string">&quot;f3&quot;</span>));</span><br></pre></td></tr></table></figure></div>
<h2 id="控制内插表达式的对齐方式"><a class="header-anchor" href="#控制内插表达式的对齐方式">#</a>控制内插表达式的对齐方式</h2>
<p>在内插表达式中的个表达式中可以通过 <code>,</code> 后加数字来控制字符宽度和对其方式，如下所示：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> inventory = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">int</span>&gt;()</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="string">&quot;hammer, ball pein&quot;</span>] = <span class="number">14</span>,</span><br><span class="line">    [<span class="string">&quot;hammer, ball pein a&quot;</span>] = <span class="number">18</span>,</span><br><span class="line">    [<span class="string">&quot;hammer, cross pein&quot;</span>] = <span class="number">5</span>,</span><br><span class="line">    [<span class="string">&quot;screwdriver, Phillips #2&quot;</span>] = <span class="number">14</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> result = <span class="string">$&quot;|<span class="subst">&#123;<span class="string">&quot;Item&quot;</span>,<span class="number">-25</span>&#125;</span>|<span class="subst">&#123;<span class="string">&quot;Quantity&quot;</span>,<span class="number">10</span>&#125;</span>|\n&quot;</span>;</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> inventory)</span><br><span class="line">    result += <span class="string">$&quot;|<span class="subst">&#123;item.Key,<span class="number">-25</span>&#125;</span>|<span class="subst">&#123;item.Value,<span class="number">10</span>&#125;</span>|\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">Debug.Log(result);</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">|Item                     |  Quantity|</span><br><span class="line">|hammer, ball pein        |        14|</span><br><span class="line">|hammer, ball pein a      |        18|</span><br><span class="line">|hammer, cross pein       |         5|</span><br><span class="line">|screwdriver, Phillips #2 |        14|</span><br></pre></td></tr></table></figure>
<p>其中逗号后的数字，如果为负数，则输出为左对齐，如果为正数则右对齐。数字本身表示最少的<strong>字符数</strong>。因此如果显示系统中每个字符的宽度是不相等的话，如 <code>i</code> 和 <code>a</code> 的宽度在某些显示系统下会有较大差异，则即使控制字符宽度也无法实现对其的效果。</p>
<p>如下为相同输出结果在 Unity 的 Console 面板中的展示：<br>
<img src="/$_string_interpolation/image-20211210201354094.png" alt="对齐输出"></p>
<p>表达式格式和对齐方式也可以一起设定，但需要首先设定对其方式，再设定格式。如下首先控制了左对齐，且字符数为 10 个，又设定输出格式为当前小时数：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Debug.Log(<span class="string">$&quot;[<span class="subst">&#123;DateTime.Now,<span class="number">-10</span>:HH&#125;</span>]&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>结果为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[10        ]</span><br></pre></td></tr></table></figure>
<h2 id="内插表达式中使用转义序列"><a class="header-anchor" href="#内插表达式中使用转义序列">#</a>内插表达式中使用转义序列</h2>
<p>如果要在内插表达式中可以使用转义序列，当需要多次使用转义序列时也可使用 原义标识符@ 替代。</p>
<p>如下所示，分别使用使用了转义序列和原文标识符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string userName = &quot;wxj&quot;;</span><br><span class="line">string stringWithEscapes = $&quot;C:\\Users\\&#123;userName&#125;\\Documents&quot;;</span><br><span class="line">string verbatimInterpolated = $@&quot;C:\Users\&#123;userName&#125;\Documents&quot;;</span><br><span class="line">Debug.Log(stringWithEscapes);</span><br><span class="line">Debug.Log(verbatimInterpolated);</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">C:\Users\wxj\Documents</span><br><span class="line">C:\Users\wxj\Documents</span><br></pre></td></tr></table></figure>
<div class="note info simple"><p>C# 8.0 后，<code>$</code> 与 <code>@</code> 的先后顺序不会造成任何影响。在早期版本中，必须先写 <code>$</code> 再写 <code>@</code>。</p>
</div>
<p>在内插表达式中，如果需要输入 <code>&#123;</code>，则按如下方式处理：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[] values = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line">Debug.Log(<span class="string">$&quot;Value is &#123;&#123;<span class="subst">&#123;values[<span class="number">0</span>]&#125;</span>, <span class="subst">&#123;values[<span class="number">1</span>]&#125;</span>&#125;&#125;&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Value is &#123;1, 2&#125;</span><br></pre></td></tr></table></figure>
<p>也可以通过 <code>$@</code> 的结合控制换行，如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> publishDate = <span class="keyword">new</span> DateTime(<span class="number">2017</span>, <span class="number">12</span>, <span class="number">14</span>);</span><br><span class="line"><span class="built_in">string</span> str = <span class="string">$@&quot;This post published on <span class="subst">&#123;publishDate:yyyy-MM-dd&#125;</span> is about</span></span><br><span class="line"><span class="string">interpolated strings.&quot;</span>;</span><br><span class="line">Debug.Log(str);</span><br></pre></td></tr></table></figure>
<p>此时输出为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">This post published on 2017-12-14 is about</span><br><span class="line">interpolated strings.</span><br></pre></td></tr></table></figure>
<h2 id="内插表达式中使用_运算符"><a class="header-anchor" href="#内插表达式中使用_运算符">#</a>内插表达式中使用 ?: 运算符</h2>
<p>因为 <code>:</code> 在内插表达式中用来指定格式，因此当使用 <code>?:</code> 运算符时，必须定义在括号内。如下所示：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">System.Random random = <span class="keyword">new</span> System.Random();</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i != <span class="number">3</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(<span class="string">$&quot;Value is <span class="subst">&#123;(random.Next() % <span class="number">2</span> == <span class="number">1</span> ? <span class="string">&quot;Odd&quot;</span> : <span class="string">&quot;Even&quot;</span>)&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Even</span><br><span class="line">Odd</span><br><span class="line">Odd</span><br></pre></td></tr></table></figure>
<h1 id="实现细节"><a class="header-anchor" href="#实现细节">#</a>实现细节</h1>
<p>根据 <code>$</code> 的实现方式的不同，编译器会选择用不同的方式实现字符串插值。</p>
<h2 id="string_Concat"><a class="header-anchor" href="#string_Concat">#</a>string.Concat</h2>
<p>当插值的对象为类型为 string 时，编译器会选择使用 <code>string.Concat</code>。</p>
<p>如下代码：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> name = <span class="string">&quot;meziantou&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> hello = <span class="string">$&quot;Hello <span class="subst">&#123;name&#125;</span>!&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>编译器会将其转换为：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> name = <span class="string">&quot;meziantou&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> hello = <span class="built_in">string</span>.Concat(<span class="string">&quot;Hello &quot;</span>, name, <span class="string">&quot;!&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="string_Format"><a class="header-anchor" href="#string_Format">#</a>string.Format</h2>
<p>如果插值的对象为类型为非 string 时，编译器会选择使用 <code>string.Format</code>。</p>
<p>如下代码：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">DateTime now = DateTime.Now;</span><br><span class="line"><span class="built_in">string</span> str = <span class="string">$&quot;It is <span class="subst">&#123;now&#125;</span>&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>编译器会将其转换为：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">DateTime now = DateTime.Now;</span><br><span class="line"><span class="built_in">string</span> str = <span class="built_in">string</span>.Format(<span class="string">&quot;It is &#123;0&#125;&quot;</span>, now);</span><br></pre></td></tr></table></figure>
<h2 id="FormattableString"><a class="header-anchor" href="#FormattableString">#</a>FormattableString</h2>
<p>如果插值的对象为类型为 <a href="/formattable_string">Formattable String</a> 时，编译器会选择使用 <code>FormattableStringFactory.Create</code> 创建一个新的 <code>FormattableString</code>。</p>
<p>如下代码：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">object</span> value1 = <span class="string">&quot;Foo&quot;</span>;</span><br><span class="line"><span class="built_in">object</span> value2 = <span class="string">&quot;Bar&quot;</span>;</span><br><span class="line">FormattableString str = <span class="string">$&quot;Test <span class="subst">&#123;value1&#125;</span> <span class="subst">&#123;value2&#125;</span>&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>编译器会将其转换为：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">object</span> value1 = <span class="string">&quot;Foo&quot;</span>;</span><br><span class="line"><span class="built_in">object</span> value2 = <span class="string">&quot;Bar&quot;</span>;</span><br><span class="line">FormattableString str = FormattableStringFactory.Create(<span class="string">&quot;Test &#123;0&#125; &#123;1&#125;&quot;</span>, <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; value1, value2 &#125;);</span><br></pre></td></tr></table></figure>
<p>当真正需要使用该 string 时，会调用 <code>FormattableString.ToString</code> 方法，将其转换为 string。</p>
<h2 id="constants（C_10）"><a class="header-anchor" href="#constants（C_10）">#</a>constants（C# 10）</h2>
<p>在 C# 10 中，支持将内插表达式的结果作为常量。如下所示：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> Username = <span class="string">&quot;meziantou&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> Hello = <span class="string">$&quot;Hello <span class="subst">&#123;Username&#125;</span>!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In previous C# version, you need to use the following concat syntax</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> Hello2 = <span class="string">&quot;Hello &quot;</span> + Username + <span class="string">&quot;!&quot;</span>;</span><br></pre></td></tr></table></figure>
<h2 id="Interpolated_string_handlers（C_10）"><a class="header-anchor" href="#Interpolated_string_handlers（C_10）">#</a>Interpolated string handlers（C# 10）</h2>
<p>C# 10 中针对高性能场景，引入了 <code>InterpolatedStringHandlerArgument</code>，具体见：<br>
<a href="https://devblogs.microsoft.com/dotnet/string-interpolation-in-c-10-and-net-6/?wt.mc_id=dt-mvp-5003978">String Interpolation in C# 10 and .NET 6 - .NET Blog (microsoft.com)</a></p>
<h1 id="Reference"><a class="header-anchor" href="#Reference">#</a>Reference</h1>
<p><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/interpolated">$ - string interpolation - C# reference | Microsoft Docs</a></p>
<p><a href="https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/exploration/interpolated-strings-local">String interpolation - C# tutorial | Microsoft Docs</a></p>
<p><a href="https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/string-interpolation">String interpolation in C# | Microsoft Docs</a></p>
<p><a href="https://www.meziantou.net/interpolated-strings-advanced-usages.htm#interpolated-strings-a9996a-2">Interpolated strings: advanced usages - Meziantou’s blog</a></p>
]]></content>
      <tags>
        <tag>C#</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>《5% 的改变》 摘抄</title>
    <url>/bai_fen_zhi_5_de_gai_bian/</url>
    <content><![CDATA[<h1 id="引言"><a class="header-anchor" href="#引言">#</a>引言</h1>
<p>在心理咨询界，有一条近乎行业共识的准则，那就是不要在咨询中提供建议。这不是故弄玄虚，明知道答案却非要卖关子，而是我们相信，来访者遇到的困境绝非听别人几句话就能解决  (  或者说，几句话就能解决的问题也不至于特意在这里求助  ) 。每个咨询师都了解成功的干预有多难，某种意义上像在打擂台，对抗一个名叫“惯性”的对手。</p>
<p>这些建议真是有益的吗？这件事也值得怀疑。凭什么认定来访者按照我们的建议做就是好的？它是心理咨询师的主观认识和个人偏好：我们认为什么是重要的，习惯用哪些办法解决困难。这偏好适用于咨询师，却未必适合其他人。</p>
<p>最有用的办法往往是靠自己找到的，只是很多人并没有真的在找——即使身陷痛苦，他们也总是在徒劳无功的老路上打转。</p>
<p>很多人都喜欢通过“思考”寻找答案，更安全，更无痛，并且显得更深刻和触及灵魂。但要我来说，还是“做”点什么更管用。行动会直接带来新的经验。我不太看重读者对我在观点上的共鸣，像是“每句话都醍醐灌顶”或者“真相了”。这些说法是在表达：“你说出了我一直同意的道理，很棒，但我没有什么行动。”比起这个，我更想听到的是：“我也不清楚你说得对不对，所以我试了试。” ^3sx5hr</p>
<p>“问题”并不是一个客观存在的东西，它是一种叙事，它建立在提问者过去理解并回应这个世界的视角之上。既然问题是在这个角度下产生的，就无法通过相同的角度解决。 ^xjd7ir</p>
<p>我不同意他看问题的角度，我有不同的视角，但我能否把他当成一个值得尊重的人？是能看到他行动的合理性，还是认定“他犯了错，我要让他承认自己的错误”？——后面这种心态无论怎么美化，都会让我的建议带着一丝不自觉的傲慢，结果可想而知。谁会愿意听一个看轻自己的人说话呢？反过来，一个人越是被理解，越是感到安全，就越是愿意打开自己，面对新的经验。 ^lzp2q5</p>
<p>如何做到发自内心地尊重，又能恰到好处地表达“我不同意你的看法”，拓展当事人看问题的角度？关键在于我们内心是否真的如此相信。</p>
<p>请当事人尝试的变化一定要小之又小，近乎不变。</p>
<ul>
<li>不要对改变的期望太高，有  5%新的经验就已经很好了。改变的悖论往往是这样：如果我说“请你变成那样”，对方会说“可我做不到”。我说“好吧，请保持你原来那样”，对方又会说“这样是不行的，我想改”</li>
<li>“请你保持基本不变的同时，朝着可能的方向改变一点。”书里的一问一答都是如此，乍一看不“解渴”，对方的核心问题没什么变化，有些尝试甚至是在背道而驰，但没关系。重点是他有了不一样的经验。新的经验就是会带来长远的改变。</li>
</ul>
<h1 id="Chapter_1_自我"><a class="header-anchor" href="#Chapter_1_自我">#</a>Chapter 1 自我</h1>
<p>“自我”是自身的一部分，但又不能全然被自己所掌握。人在成长的过程中，多少都会遭遇对自我的失望、恐惧、不接纳。这是最普遍的困惑，也是最抽象、最复杂的困惑。</p>
<p>思考”和“想”是有差别的。“想”是懒惰的自由，“思考”却必须带上复杂难言的现实生活，以及对真实自我的理解。“我想辞职”和“我考虑辞职”，难度差异太大了。 ^rkec9u</p>
<p>大多数痛苦都可以概括成两句话：“我不希望自己这样，但确实我就是这样的。”“我希望像别人一样，但我又做不到那样。”用学术一点的语言，就是理想自我和真实自我之间有差距。解决方案说来简单，就是“接纳”，接受自己真实的样子。</p>
<p>消化了“我不该如此”的错位感，才能看清楚真正的自己是什么样  (  满意也罢，不满也罢  ) 。这还没完，从看清自己到欣赏自己，从欣赏自己到用好自己，从用好自己再到自我实现，每一段都是长期功课。在自我认识、自我成就这件事上，我们有一生的路要走。</p>
<p>5%其实也不错了，问题在于，如果你太想要一个彻底的、长久的改变，你就会被挫败、沮丧和自我否定压垮，最后的结果是连 5%也做不到。你只做到了 0%。</p>
<p>我为什么不继续说服她，她有改变的希望呢？因为我猜，她经历过很多这样的对峙。她渴望改变，然而通篇又在证明自己的无望，这常常会吸引其他人去反驳，去灌输给她希望。改变的责任不知不觉转移到别人身上，她本人反而更抵触：“你们说的希望在哪里呢？我都试过了，真的不行！”——这不是我们想要的结果。何况靠别人灌输的希望始终有限。</p>
<ul>
<li>遇到这种情况，更好的办法是同意她现在的心理现实：如果她认为自己身处谷底，那你就接受这对她来说就是真的（哪怕你实际上不这么看）。彻彻底底站在她这一边。然后呢？行动的责任就落在她自己肩上了：她的人生陷入了大麻烦，她现在已经身处谷底，下一步她打算如何行动呢？</li>
</ul>
<p>虽然疫情是一个客观事件，我们无从选择；但如何让它为自己所用，却是可以主观调整的。选择强调它带来的负面影响，这是一种策略，叫作“防御性悲观”，也就是预先为自己铺好后路：万一失败了，不怪我，怪外部因素。看上去像是一种消极的心态，但是换一个角度，也不失为一种给自己解压松绑、轻装上阵的办法。</p>
<ul>
<li>生活中我们觉得这种心态有点负面，更推崇乐观地面对困难，那当然是一种英雄主义。但我们不能代替当事人的选择。所以我设计了一个仪式，帮助他把无意识的策略转变成有意识的自我对话，怎么选都是对的，但他可以明确意识到自己在做选择。我们看到，当他做出自己的选择——哪怕选择一种“悲观的态度”——他在后面的行动中，就能表现出更大的能动性。</li>
</ul>
<p>“李老师”某种意义上代表着她的那些同龄人，他们似乎秉承一种理性的态度，劝说她减少不必要的执念，轻装上阵，好好生活——可这些声音恰好是问题所在。它们无异于是在说：“这种你坚持的存在方式，是有问题的。”其实呢？没问题，提问者只是痛苦。痛苦是一种感知自己存在的方式。这很正常。世界上多的是人选择这样存在，也安于这样存在。如果把它当成问题，这种认识解决不了任何问题，反而制造了更多痛苦。</p>
<ul>
<li>如果再来一次的话，我会表达得更明确：不要放下。保持住你的痛苦。痛苦当然可以是人存在的方式。它代表着还没有答案的课题，而这个课题是有价值的。它在追问：“我做了能做的一切，但我还是不满足，我还要做什么？”没有答案，那就去找，但问题没有错。不要放弃问题本身。</li>
</ul>
<p>每当你担心小概率事件发生时，就告诉自己，不要心怀侥幸，它注定会发生（更何况你担心的就是已经发生的事）。剩下的问题就是：你必须采取怎样的预防或补救措施？——然后，去把该做的事做到。</p>
<ul>
<li>听上去这跟你现在每天的生活差不多。但至少你这样做是有底气的，不用一边做一边怀疑自己“是不是杞人忧天”，那样是双重的辛苦。</li>
</ul>
<p>从你的日常来看，你不需要真的自律，你只是需要一个叫“自律”的符号，用它带给自己一些积极暗示。</p>
<ul>
<li>这是很重要的自我发现。我们现在动辄讲“自律”，似乎自律是现代人的一种基本美德。但自律本身并不是目标，只是用来实现目标的手段。目标只能是一件具体的事，比如工作，就应该追求工作的完成度。这个过程中伴随着一丝不苟的节奏，就可以被称为“自律”。自律很好，但如果没有确定的目标，单单追求自律的状态，那就是买了一个名叫“自律”的盒子，却丢掉里面的珍珠。</li>
<li>自律这个词本身就有点拧巴。它强调的是一种自我克制，自我违抗——明明不想做一件事，却要自己必须做，这才叫作自律。而且不是做一次两次，要重复，日复一日，从这份坚持中获得某种意义——可是为什么要如此辛苦？如果找一件自己更喜欢的事，高高兴兴地做下来，不是更简单吗？</li>
</ul>
<p>世道艰难，你却如此轻易地拥有现在的生活，玩游戏，画画，还有人可以爱，这是容易让人感到不安的。也许焦虑的用处在于不断地“折磨”你，让你不时感受痛苦，是一种内在的补偿机制。</p>
<ul>
<li>也许在焦虑的时候，你可以用更有效的方式来“折磨”自己。比如做几件你平时没有动力去做的事。</li>
<li>一部分焦虑转化成了我的动力，转化的同时也减轻了我的焦虑。</li>
</ul>
<p>想是想不明白的，解决办法往往需要行动。积极的行动会开启一条“行动让人的状态变好，状态变好又带来更多积极行动”的正反馈循环链路。与之相反的就是“向下螺旋”的恶性循环：因为心情不好，导致什么都不想做；因为什么都没做，导致心情更差。这就是为什么很多人靠思考的方式解决问题，结果越想越难受。这种时候就要少想，多做。一旦开始做事，就启动了“向上螺旋”。</p>
<ul>
<li>有时人们不愿意开始行动，会把原因推给“状态”：“等我状态好了，这些事都会水到渠成。”但这是很难实现的，因为不开始行动，状态不会自己变好。要考虑的恰恰是在状态不好的同时，坚持迈出一小步</li>
</ul>
<p>人在纠结的时候，头脑里总在自我否定，想法一会儿一变：想做的事，事到临头又觉得做不到；想放弃，又不甘心。怎样都不满意。一个有效的应对办法，就是把所有的念头拿“出来”，变成两个或多个角色的对话。写下来，念出来，演出来，都可以。一个想这么做，而另一个刚好反对，如此而已。</p>
<ul>
<li>当几个声音都在一个人的头脑里，来回纠结，难免就让人感到困惑：“我是有什么问题？为什么明明想做的事，偏偏又做不到？”变成几个角色，一下就清楚了——就是头脑里同时有几个人嘛。几个人立场不同，意见谈不拢，也正常。这样的矛盾在生活里比比皆是。</li>
<li>不要预设只能存在一个声音，这是在自己头脑里的暴政——我们总认为自己只能有“唯一”的观点，从而造成了更多的困惑。有时候，允许不同的观点同时表达，本身就带来了沟通和解决的空间。</li>
<li>如果一个人同时存在着两种不同的人生观，它们又指向不同的生活方式，应对这种冲突最简单的方法，就是让两者同时实现。只不过放在生命的不同时间，像是单双日或者单双周。比如说吧，一个人可能想佛系，又觉得佛系不好，放不下自己的雄心壮志，那么与其花时间纠结“哪种人生观更好”，倒不如两种都要：一半时间充分努力，另一半时间充分躺平。</li>
<li>他不需要追求“统一”的生活态度，那样就只有一半的时间是好的，而现在是两种状态都好，都有价值；</li>
</ul>
<p>如果劝他“别担心，事情可能不会像你想的那么糟”，这种劝慰往往没有用。“可能”的另一面就是“不确定”，担心正是基于不确定。对方一句话就可以反问回来：“万一呢？”不要反驳，索性让他设定，担心的事确定会发生。</p>
<ul>
<li>回过头来，最坏的情况都能应对，现在又有什么好怕的呢？</li>
<li>沉浸在害怕中时，人们并不真的了解自己在怕什么，只是有一个强烈的印象：“太糟糕了！”“不可以让它发生！”这时候情绪当头，没办法思考“最大的损失有多大？”“整个过程究竟是怎样的？”当然也就更谈不上应变了：“就算在最坏的情况下，我也能做点什么。”进行了这样的深度加工，才能最有效地减轻焦虑。</li>
<li>焦虑的时候，反而可以多想一想“最坏的结果”。越具体，越实际，越有助于摆脱焦虑。遗憾的是，身边的人往往都在劝说“别想了，不会有事的”，等于还是在强化这样的意思——“它很糟糕”，“确实不能让它发生”。等到双方陷入争辩，就更没有时间对想象中的灾难做现实化的处理。</li>
</ul>
<p>在提建议的同时，不对建议的结果做任何预判。这样，就把建议变成了实验。就像所有实验一样，因为猜不到结果，所以期待。结果可能印证实验者的假设，也可能刚好相反。</p>
<ul>
<li>它把“行动”的目的异化了。做事是为了期待中的结果，这反而让人畏惧不前。</li>
<li>为了确定的结果做事，就有失败的可能。但如果行动的意义在于自我探索，就无所谓“失败”。</li>
</ul>
<h1 id="Chapter_2_原生家庭"><a class="header-anchor" href="#Chapter_2_原生家庭">#</a>Chapter 2 原生家庭</h1>
<p>“原生家庭”，差不多被当成了“童年阴影”的同义词。这是流行于当代的一种伤痕叙事。人们在孩提时代遭遇的不幸，天灾人祸也好，父母失职也好，或者是观念的偏狭、风俗的落后，都在成长关键时期留下了痛苦的烙印，其影响被认为会持续到成年之后。</p>
<ul>
<li>原生家庭的叙事本身就是一种影响的媒介。它把当下的经历和历史建立了联系：自己被描述成受制于过去的、无从反抗的“受害者”，一朝不幸，永远不幸。这成了一个悖论：过去那些事如果不是被反复提起，本不具有那么大的影响力。</li>
<li>有时候，只要我们稍加梳理，原生家庭的解释就未必站得住。它是一种被发明出来的、功能性的解释，看上去是为了解决问题，实际效果却是维持了问题。</li>
<li>过度的责任感让人更绝望，因为找不到其他原因，“只能是因为我不够好”。这时候就要让他看到，“不是我的错”，自己身上发生的一切都事出有因。这是“原生家庭”叙事本来的用意，创造更多的安全、稳定、被接纳。但要把握分寸——承认成长经验的影响，不代表“什么都不做”。接受不能改变的，恰恰是为了改变能改变的：过好我们今后的人生。</li>
</ul>
<p>不要预设她不联络就是生气，万一她是在适应一个人生活呢？下次联系她的时候，你先用正常的语气招呼她：“新年好！我们给你做了爱吃的东西。”</p>
<ul>
<li>她怎么接，都把她假定为有能力的、成长的人。如果她不是，别失望，给她一点时间，下次继续。你不需要再改变</li>
<li>既不绝情，但也不要无端成为出气筒和替罪羊。保持你的稳定，剩下的，她会学着适应。</li>
<li>妈妈那些令我反感的行为和语言，如果不方便反驳，就保持尊重和淡漠。但如果她用更健康的模式对待我，我会积极响应，让她觉得这个方向是对的。</li>
</ul>
<p>拖延的理由有很多种，最让人心疼的一种，大概就是“我必须完全做好一件事，才敢向人交代”。他们不是因为不负责，而是过于尽责了。假如这位提问者看到我的回复，真的可以随随便便置之不理，她就不会有拖延的困扰了。</p>
<p>假如有一件举手之劳的事始终做不到，除了解释为某种缺陷或障碍，另一种解释是，出于某种目的而特意“不去做”。一个成年人有能力拒绝妈妈的影响，却没有拒绝，除了来自母亲的积威之外，多半这个影响也是他（她）自己想要的。</p>
<ul>
<li>当一个年轻人对现状感到不满，对自己要求很严厉，同时也希望多体谅一下自己，那他就会说：“我已经尽力了，值得鼓励”，“都怪妈妈还在苛责我”。这样一来，就可以利用父母的要求，去摆平内心的冲突。看起来好像“难以”摆脱父母，但这总比承认自相矛盾好受一些。</li>
<li>也许当事人是有能力摆脱父母影响的，只是摆脱之后，还有很多属于这一刻的功课——自卑也好，不够成功也罢——那些烦恼仍然存在，并且作为自己的责任，终究只能自己承担。这让人看得更远，也更累。</li>
</ul>
<p>如果想让父母看到你不是那个“不懂事”“乱发脾气”的孩子，请你告诉他们：每次争吵你只是控制不住情绪，但不是真的想让他们难受。为了体现这一点，每次你发现自己又“怼”了父母之后，就为他们做一件小事，比如倒一杯水（或者别的小事），让他们感受到你的善意。</p>
<ul>
<li>你还是可以继续争吵，这是控制不住的。只是吵完了做点不一样的事。</li>
<li>比起“不要吵架”，更有效的建议是“吵也行，吵完倒杯水”。前者是在讲一个道理，正确，但是不知道怎么做。后者则是一个具体的动作，只要想做就能做到。当然了，后者听起来“不太解决问题”。但解决问题未必需要一个人发生由内而外的、连根拔起的改变。他也可以还是他，带着他（暂时没能解决）的问题，只是做了一点不同的动作。在我看来，完成一个动作，比想明白一百个道理更有用。</li>
<li>这样做还有一个附带的好处，它让这件事变得轻松了。“不要吵架”是一根随时绷紧的弦，“吵了再说”则有一种随遇而安的松弛。这反而有助于我们情绪平稳。有些情绪不再被刻意关注之后，自己就会淡化。这叫作“看见”或是“允许”这些情绪。反过来，越是不被允许的情绪，就越难以自控。</li>
</ul>
<p>有研究发现，那些在童年时期失去亲人的孩子，对逝去亲人最难说出口的一种情感是：生气。被重要的人抛弃的生气——“你抛下我而去，留下我在这个世界，一个人遭受那么多委屈。”生气是有理由的，但这份生气好像又不容易表达：你遭遇了比我更大的不幸，我怎么有资格责怪你？</p>
<p>困住你的不只父母的声音，他们就算不吭声，但仍然有一部分压力存在，那就是时间。时间在一年年地流逝，而你暂时还没想好自己想要怎样的生活，这是烦恼的根源。这烦恼本质上是针对自己：你也不知道想要什么。</p>
<ul>
<li>家人念着催生的咒语，反而帮你消解了一部分压力，把个人的烦恼转移给了家庭的矛盾，好像全部问题都来自他们的“催”。他们树了一个靶子。盯着这个靶子，关注点就不再是“如何安排未来的人生”，而变成了“如何应付家人”。</li>
</ul>
<p>阿德勒心理学强调的原则，在处理家庭问题时尤其适用。简单地说，就是要区分一个问题是谁的“课题”。谁的课题，谁负责解决。区分的原则很简单：这个问题让谁感到困扰？谁困扰，就是谁的课题。</p>
<ul>
<li>比如，子女决定了跟什么样的人结婚，如果子女想清楚了，就不困扰，因为这是他（她）的选择。可是父母不同意，他们担心这个对象不可靠，那么这件事就是父母的课题，只有他们为此感到困扰。按照课题分离原则，父母的课题父母自己解决，换句话说，子女并没有义务改变父母（当然更不用屈从）。</li>
<li>很多问题的处理就简单多了，尤其是原生家庭的纷扰，很多都是子女成年之后，抱怨得不到父母的支持：他们不理解自己选择的工作，不认同自己的伴侣，或者在生活观念上跟自己不合，由此又引发了童年时的很多委屈……遇到这些问题，要让做子女的人知道，重要的不是跟父母较劲，你只要按自己的想法，把自己的生活过好，就够了。至于父母怎么想——“那不是你的课题。”</li>
</ul>
<p>仪式的力量：它在生活中是一套约定俗成的、流程化的宣言和动作，比单纯的语言更具有感染力。它常常被用作某种转变的契机。例如，办一场庄重的成人礼，会比单纯的说教更有助于青少年减少孩子气的行为。</p>
<h1 id="Chapter_3_工作与理想"><a class="header-anchor" href="#Chapter_3_工作与理想">#</a>Chapter 3 工作与理想</h1>
<p>很多人都把“克服恐惧”看成目标，我认为不必。恐惧只是一种情绪，一个人带着恐惧这种情绪，照样可以采取行动。归根到底，做了什么是第一位的。</p>
<p>做事甚至不必产生“实际”的结果，行动本身就会开启“向上螺旋”。最初的行动一旦被激活，身体自然会越来越有力量，做的事也越来越多。就像是在滚雪球，从最初的一小点开始，一圈圈越滚越大 。</p>
<p>你需要接受这一点：你在这个阶段，只能拿出 1/7 的时间和精力，也就是一周只有一天做科研。无论你有多么不想接受，这都是现实。</p>
<ul>
<li>你要接受自己本质上属于这样一类人，也许你就没那么焦虑了。然后请你做两件事：第一，把这 1/7 的时间充分利用好，效率最大化（这一点，我估计你已经在做了）；第二，剩下的六天尽情做其他事。</li>
<li>尽量不去把科研看成一件痛苦的事，因为我觉得和一个东西对抗，需要耗费的精力远远大于处理它本身。</li>
</ul>
<p>你对自己能力的信心也带来了一点麻烦。麻烦在于，你不能让自己安于普通人的人生。所以考研失利后，你把“安于另一种人生”等同于“失败”，你必须让自己过不好，才有动力继续证明自己。但你现在越是过得不好，它就越是让你恐惧，破坏了你的努力。</p>
<ul>
<li>所以，这里就有一个悖论：如果你想尽全力证明自己一次，你就必须先安于当下的生活。我给你的建议就是如此：请你先以“不上研究生”为前提，把当下的生活过好。这是一盘大棋，为了更好的考研心态。你可以每天暗暗地复习，但不要再寄托“改变人生”那么大的压力。这只是用来自我证明的游戏，轻装上阵才好。等到有一天，你的生活足够满意了，不觉得非上研究生不可了，你的心态才算是准备好。那时候，你才最有可能一战功成。</li>
<li>现在有一种流行的信念说，成功需要“背水一战”。认为人只有在无路可退的时候才会爆发潜能，甚至于“思考退路”本身都会被当成一种懦弱。我认为这个观念要辩证地看，有一些绝境会激发人的勇气，另一些绝境则让人陷入恐慌，反而没法集中在自己要做的事情上。在这种情况下，思考退路是一种更积极和勇敢的策略。</li>
</ul>
<p>最重要的，就是不要重复已经做过的思考。总在相同的思路中绕圈子，人就没法获得新鲜的想法，问题就仍然得不到答案。</p>
<ul>
<li>很多人拿不定主意，是太想要一个“最终”的答案。但哪里能找到这样的答案呢？可能今年这样想，明年的想法又不一样。每一次都只是阶段性的尝试。先试，试了才会有结果，时间自然会告诉我们对不对。放轻松，不对就改嘛。</li>
<li>尝试的另一个前提是安全。多准备一些试错的成本。</li>
</ul>
]]></content>
      <tags>
        <tag>心理</tag>
        <tag>摘抄</tag>
      </tags>
  </entry>
  <entry>
    <title>《Render Hell》 第二部分 管线</title>
    <url>/book_2_pipeline/</url>
    <content><![CDATA[<h1 id="GPU_Core"><a class="header-anchor" href="#GPU_Core">#</a>GPU Core</h1>
<p>在 GPU Core 中有两个运算单元 <code>floating point unit(FP UNIT)</code> 和 <code>integer unit (INT UNIT)</code> ，当 GPU Core 接收到数据后，会通过这两个运算单元进行计算。</p>
<p><img src="/book_2_pipeline/gif_9-14-2021_9-27-55_am.gif" alt="FP / Int Unit"></p>
<h2 id="Not_Everything_is_done_by_GPU_Cores"><a class="header-anchor" href="#Not_Everything_is_done_by_GPU_Cores">#</a>Not Everything is done by GPU Cores</h2>
<p>对于如分发渲染任务，计算 <code>Tessellation</code>，<code>Culling</code> ，<code>Depth Testing</code>，光栅化，将计算后的 Pixel 信息写入到 Framebuffer 中等工作，并不是不通过 GPU Cores 完成，这些工作会由 GPU 中其他的硬件模块完成（这些模块不受开发者的代码控制）。</p>
<h2 id="Parallel_Running_Pipelines"><a class="header-anchor" href="#Parallel_Running_Pipelines">#</a>Parallel Running Pipelines</h2>
<p>对于 GPU Core 而言，它需要 <code>Streaming Multiprocessor(SM)</code> 为其分配工作，一个 SM 处理来自于 <strong>一个</strong> Shader 的顶点或像素数据。因此当一个 SM 下有多个 Core 时，来自于 <strong>一个</strong> Shader 的顶点或像素就能被并行的处理。当有多个 SM 时，多个 Shader 间也能并行处理。如下图所示：</p>
<p><img src="/book_2_pipeline/untitled.png" alt="Streaming Multiprocessor"></p>
<h1 id="Pipeline_Stages_In_Depth"><a class="header-anchor" href="#Pipeline_Stages_In_Depth">#</a>Pipeline Stages In-Depth</h1>
<div class="note info simple"><p>这一部分从上至下更深入的讲解 GPU Pipeline</p>
</div>
<h2 id="Application_Stage"><a class="header-anchor" href="#Application_Stage">#</a>Application Stage</h2>
<p>对于应用而言，其提交的图形 API 都是提交给 GPU 的驱动，告诉其需要绘制的内容和 Render State。</p>
<p><img src="/book_2_pipeline/gif_9-15-2021_8-41-31_am.gif" alt="Application 提交图像指令给 Driver"></p>
<h2 id="Driver_Stage"><a class="header-anchor" href="#Driver_Stage">#</a>Driver Stage</h2>
<p>驱动会将绘制的数据 Push 到 Command Buffer 中，当 VSync 或 Flush 时，Command Buffer 中的数据会被 Push 到 GPU 中。</p>
<p><img src="/book_2_pipeline/gif_9-15-2021_8-44-49_am.gif" alt="Driver 将指令给 Command Buffer"></p>
<h2 id="Read_Commands"><a class="header-anchor" href="#Read_Commands">#</a>Read Commands</h2>
<p>显卡中的 <code>Host Interface</code> 会负责读取 Command Buffer 传递进来的数据供后续的使用。<br>
<img src="/book_2_pipeline/gif_9-15-2021_8-45-28_am.gif" alt="Host Interface 读取 Command Buffer"></p>
<h2 id="Data_Fetch"><a class="header-anchor" href="#Data_Fetch">#</a>Data Fetch</h2>
<p>一些 Command 包含数据的拷贝。GPU 通常会有一个单独的模块处理从 RAM 拷贝数据到 VRAM 的过程，反之亦然。这些需要拷贝的数据可以是 Vertex Buffer，纹理或其他 Shader 的参数。通常渲染一帧会从传递 Camera 相关的数据开始。</p>
<p>当所有数据准备完成后，GPU 中会有一个模块（Gigathread Engine）负责处理任务的分发。它为每一个要处理的顶点或像素创建一个线程，并将多个线程打包成一个 Package, NVIDIA 将这个 Package 称为 Thread block 。 Thread Block 会被分发给 SM，如下图所示：<br>
<img src="/book_2_pipeline/gif_9-15-2021_8-58-59_am.gif" alt="分配 Thread Block"></p>
<h2 id="Vertex_Fetch"><a class="header-anchor" href="#Vertex_Fetch">#</a>Vertex Fetch</h2>
<p>SM 中仍然包含了多个硬件的单元，其中一个为 <code>Polymorph Engine</code> ，它负责将数据拷贝到各内存部分中，让 Core 在之后的工作中可以更快的访问数据。</p>
<p><img src="/book_2_pipeline/gif_9-15-2021_9-03-27_am.gif" alt="Polymorph Engine 拷贝数据"></p>
<h2 id="Shader_Execution"><a class="header-anchor" href="#Shader_Execution">#</a>Shader Execution</h2>
<p><code>Streaming MultiProcessor (SM)</code> 的主要功能为执行开发者编写的 Shaders。</p>
<p>SM 首先会将之前获取到的 Thread Block 拆分为多个 <code>Warp</code> 。每一个 Warp 包含的线程数根据硬件的不同可能存在差异， Nvidia 平台下一个 Warp 包含 32 个 Thread。<br>
<img src="/book_2_pipeline/pipeline_workdistribution_02.gif" alt="Thread Block to Warp"></p>
<p>SM 中包含多个 <code>Warp Schedulers</code> ，每个 <code>Warp Schedulers</code> 会选择其中一个 Warp，并将需要执行的指令进行翻译。与 Warp 中线程数相同的 GPU Core 会一起逐条执行这些指令。每个 GPU Core 在同一时间点会执行相同的指令，但有着不同的数据（如不同的像素，不同的顶点）。为了简化，如下只展示一个 <code>Warp Schedulers</code> 的情况，过程如下所示：</p>
<p><img src="/book_2_pipeline/pipeline_workdistribution_04.gif" alt="Wrap Schedulers 执行指令"></p>
<div class="note info simple"><p>对于每个 GPU Core 而言，它们无法知晓整个 Shader 指令，它们在仅知晓当前需要执行的那 <strong>一条</strong> 指令。</p>
</div>
<p>需要再次强调的是，一个 Warp 对应的 GPU Cores 在同一时间点会执行相同的指令，不会存在某个时间点一个 Core 执行语句 A，另一个 Core 执行语句 B 的情况。这种限制被称为 <code>lock-step</code> 。</p>
<p>当 Shader 中 IF 指令时，进入分支的 Core 会进行工作，剩下的 Core 会进入“休眠”。同理如果 Shader 中存在循环，那么仍然在循环内的 Core 进行工作，已经完成循环 工作的 Core 进入休眠，直到所有的 Core 都完成了操作。如下所示：</p>
<p><img src="/book_2_pipeline/pipeline_workdistribution_06.gif" alt="Lock Step"></p>
<div class="note info simple"><p>部分 Cores 工作，部分 Cores 休眠的现象称为 <strong><code>divergent threads</code></strong> 应当要尽量避免。</p>
</div>
<p>当 Warp 中需要执行的指令依赖的数据尚未被准备好， SM 会选择另一个 Warp 并执行其中的指令，如下所示：<br>
<img src="/book_2_pipeline/pipeline_workdistribution_07.gif" alt="Memory Stall"></p>
<div class="note info simple"><p>Warp 中指令依赖数据未准备好，必须切换另一个 Warp 继续执行的现象，称为 <code>Memory Stall</code> 。</p>
</div>
<p>如前所述，一个 SM 可能包含多个 Warp Schedulers，也因此可以并行的处理多个 Warps，<br>
<img src="/book_2_pipeline/untitled_1.png" alt="|多个 Warps"></p>
<h2 id="Vertex_Shader"><a class="header-anchor" href="#Vertex_Shader">#</a>Vertex Shader</h2>
<p>每一个顶点着色器的实例对应 <strong>一个</strong> 顶点的处理，且运行在被 SM 管理的一个线程上。<br>
<img src="/book_2_pipeline/pipeline_vertex_shader_01.gif" alt="顶点"></p>
<h2 id="Tessellation"><a class="header-anchor" href="#Tessellation">#</a>Tessellation</h2>
<div class="note info simple"><p>曲面细分阶段中，有两个可编程的着色器， <code>Hull Shader</code> 和 <code>Domain Shader</code></p>
</div>
<div class="note info simple"><p>为何需要曲面细分阶段，而不是直接在模型中增加更多的顶点？</p>
<ol>
<li>相较于更多顶点时数据传输时的开销，通过曲面细分生成更多顶点的开销更低</li>
<li>曲面细分阶段可以控制顶点该如何被细分，如根据摄像机的距离。这样就能产生出更适合实际使用时的顶点数据。</li>
</ol>
</div>
<h3 id="Patch_Assembly"><a class="header-anchor" href="#Patch_Assembly">#</a>Patch Assembly</h3>
<div class="note info simple"><p><code>Patch Assembly</code> 和后续的 <code>Hull Shader</code> ， <code>Tessellation</code> 及 <code>Domain Shader</code> 仅当使用了 <code>曲面细分着色器(Tessellation Shader)</code> 时才会进行。</p>
</div>
<p>Patch Assembly 阶段会把多个顶点打包成一个 Patch 供后续的 Tessellation 阶段处理。究竟多少个 顶点会被打包成一个 Patch，是由开发者决定的，最多 32 个顶点可以被打包成一个 Patch：<br>
<img src="/book_2_pipeline/pipeline_patch_assembly_01.gif" alt="将多个顶点打包为一个 Patch"></p>
<h3 id="Hull_Shader"><a class="header-anchor" href="#Hull_Shader">#</a>Hull Shader</h3>
<p>Hull Shader 处理之前被打包成一个 Patch 的顶点们，并生成一系列的 <code>Tessellation Factor</code> 。这些 Factors 指明了 Patch 中的边该如何细分，和 Patch 的内部该如何细分。</p>
<p>Hull Shader 中也可以指明计算 Factor 的方法，最常见的是根据与摄像机的距离：</p>
<p><img src="/book_2_pipeline/pipeline_hull_shader_01.gif" alt="Tessellation Factor"></p>
<p>另外因为 GPU 仅能对三个基本的几何元素（ Quad，Triangle，Lines）进行细分，Hull Shader 也会指明 Patch 需要按哪个几何元素进行细分。</p>
<h3 id="Tessellation-2"><a class="header-anchor" href="#Tessellation-2">#</a>Tessellation</h3>
<p><code>Polymorph Engine</code> 会根据之前的 Patch 以及得到的 Tessellation Factor 真正的执行细分操作：</p>
<p><img src="/book_2_pipeline/pipeline_tesselation_01.gif" alt="Polymorph Engine"></p>
<p>被细分创造出的顶点会被送回到 <code>GigaThead Engine</code> 中，并被其重新派分给 SM，这些 SM 会将得到的顶点通过 <code>Domain Shader</code> 处理。</p>
<h3 id="Domain_Shader"><a class="header-anchor" href="#Domain_Shader">#</a>Domain Shader</h3>
<p>Domain Shader 会根据 Hell Shader 的输出（ Patch 顶点）以及 Tessellation 的输出（顶点的质心坐标系（ Barycentric Coordinate））调整每个顶点的位置。如果开发者使用了 <code>Displacement map</code> ，则会在这个阶段被使用：</p>
<p><img src="/book_2_pipeline/pipeline_domain_shader01.gif" alt="Domain Shader "></p>
<h2 id="Primitive_Assembly"><a class="header-anchor" href="#Primitive_Assembly">#</a>Primitive Assembly</h2>
<p>图元装配阶段，会将顶点数据（来自于 Vertex Shader 或来自于 Tessellation ）装配成一个个几何图形：<br>
<img src="/book_2_pipeline/pipeline_primitive_assembly_01.gif" alt="图元装配"></p>
<h2 id="Geometry_Shader"><a class="header-anchor" href="#Geometry_Shader">#</a>Geometry Shader</h2>
<div class="note info simple"><p>几何着色器（Geometry Shader）是一个可选 Shadder</p>
</div>
<p>几何着色器会针对 Primitive Assembly 给出的图元进行调整，如它可以将一个点调整为两个三角形：</p>
<p><img src="/book_2_pipeline/pipeline_geometry_shader01.gif" alt="几何"></p>
<div class="note info simple"><p>如果需要大量的生成新顶点，更适合在 Tessellation 阶段进行。</p>
</div>
<div class="note info simple"><p>几何着色器更大意义在于，它是进入光栅化前最后可配置的一个阶段。如它在 <code>Voxelization Techniques</code> 中扮演了重要角色。</p>
</div>
<h2 id="Viewport_Transform_Clipping"><a class="header-anchor" href="#Viewport_Transform_Clipping">#</a>Viewport Transform &amp;&amp; Clipping</h2>
<p>之前的操作，物体都是处在 NDC 空间中的。在 Viewport Transform 中需要将其转换到与屏幕分辨率匹配的空间（Viewport 空间），这个操作被称为 <code>Viewport Transform</code> 或 <code>Screen Mapping</code> 。</p>
<p><img src="/book_2_pipeline/pipeline_screenmapping01.gif" alt="Viewport Transform"></p>
<p>超过了屏幕范围的三角形会被裁剪，这一部分称为 <code>Guard Band Clipping</code> ，如下所示：<br>
<img src="/book_2_pipeline/pipeline_clipping01.gif" alt="Guard Band Clipping"></p>
<h2 id="Rasterizing"><a class="header-anchor" href="#Rasterizing">#</a>Rasterizing</h2>
<p>在运行像素着色器前，需要通过光栅化，将之前的三角形转换为屏幕上的像素。 GPU 硬件中通常包含多个光栅器，并且他们可以同时工作。</p>
<p>每一个光栅器会负责屏幕中的特定区域，因此 GPU 会根据三角形在屏幕中的位置决定他们应当由哪个光栅器进行处理，并将其发送给特定的光栅器。示意图如下所示：</p>
<p><img src="/book_2_pipeline/pipeline_triangle_journey01.gif" alt="指定光栅器"></p>
<div class="note info simple"><p>如果一个三角形足够的大，覆盖了屏幕中的很大一部分，那么可能会同时有多个光栅器为其进行光栅化。</p>
</div>
<p>当光栅器接收到一个三角形数据后，它会首先快速的检查该三角形的朝向<code>（Face Culling）</code> 。如果三角形通过了 Face Culling，则光栅器会根据三角形的边，确定它覆盖了那些 Pixels Quad （ $2\times2$ Piexls，或称为 <code>pre-pixels</code> / <code>pre-fragment</code>），示意图如下所示：<br>
<img src="/book_2_pipeline/pipeline_rasterizing02.gif" alt="确认覆盖的 Pixels Quad"></p>
<p>之所以以 <code>pre-piexles/fragments</code> 作为一个单位，而非单一的 Pixel 作为单位，是因为这样可以计算一些后续操作需要用到的数据（如采样 Mipmap 时需要的导数<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。</p>
<div class="note info simple"><p>一些 Tile-Based 硬件 ，在 <code>pre-pixels/fragments</code> 创建后，可能会有一些硬件层面上的可见性检测。它们会将整个 Tile 发送给一个称为 <code>Z-Cull</code> 的模块，该模块会将 Tile 中的每个像素的深度与 FrameBuffer 中的像素深度进行比较，如果一整个 Tile 的测试都未通过，则该 Tile 会被丢弃。</p>
</div>
<h2 id="Pixel_Shader"><a class="header-anchor" href="#Pixel_Shader">#</a>Pixel Shader</h2>
<p>对于每个 <code>pre-pixels/fragments</code> ，它们会被 Pixel Shaders 进行填色处理。同样的， Pixel Shader 也是运行在 Warp 的一个线程上。</p>
<div class="note info simple"><p>一个 <code>pre-pixels/fragments</code> 实际上是 4 个像素（$2*2$），因此一个 32 线程的 Warp，实际上运行 8 个 <code>pre-pixels/fragments</code> 。</p>
</div>
<p>当核心工作完成后，它们会将得到的数据写入 L2 Cache。</p>
<h2 id="Raster_Output"><a class="header-anchor" href="#Raster_Output">#</a>Raster Output</h2>
<p>在管线的最后，会有称为 <code>Raster Output(ROP)</code> 的硬件模块将 L2 Cache 中存储的 Pixel Shader 运算得到的像素数据写入 VRAM 中的 Frame buffer。</p>
<p>除了单纯的拷贝像素数据， ROPs 还会进行如 Pixel Blending， 抗锯齿时依赖的 Coverage Information 计算等工作。</p>
<h1 id="Reference"><a class="header-anchor" href="#Reference">#</a>Reference</h1>
<p><a href="http://simonschreibt.de/gat/renderhell-book2/">Render Hell – Book II | Simon schreibt.</a></p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a href="https://developer.nvidia.com/content/life-triangle-nvidias-logical-pipeline">Life of a triangler</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <tags>
        <tag>GPU</tag>
      </tags>
  </entry>
  <entry>
    <title>《Render Hell》 第一部分 概览</title>
    <url>/book_1_overview/</url>
    <content><![CDATA[<div class="note info simple"><p>这一部分简单介绍了一些 GPU 的涉及的概念。</p>
</div>
<h1 id="Copy_the_Data"><a class="header-anchor" href="#Copy_the_Data">#</a>Copy the Data</h1>
<div class="note info simple"><p>之所以需要在不同的硬件间拷贝数据，是因为从不同硬件中读取数据的速度差异很大。因此对于当前需要频繁访问的数据，通常会选择将其拷贝到更为高速的内存部分中。</p>
</div>
<div class="note warning simple"><p>GPU 和 显卡 并不是相等的关系 GPU 全称为 Graphics Processing Unit，它指示显卡中的核心计算芯片。整个显卡中还包括显存（VRam），散热器等配件。</p>
</div>
<p>对于所有与绘制相关的资源，如贴图，模型，一开始都是存储在硬盘（HDD）上的 。在整个绘制过程中，它们会先被读取到内存（RAM）中，再被读取到显卡上的显存（VRAM）中。之所以要进行这么一个数据从 HDD 拷贝到 VRAM 中的操作，是因为显卡读取 VRAM 中的内容速度更快。整个过程如下所示：<br>
<img src="/book_1_overview/gif_9-13-2021_8-52-50_am.gif" alt="数据从内存拷贝到显存"></p>
<p>又因为整个过程中数据是被 拷贝 的，因此当数据进入 VRAM 后，在 RAM 中的数据可以被正常销毁，不会影响到后续的绘制。如下所示：<br>
<img src="/book_1_overview/gif_9-13-2021_8-55-43_am.gif" alt="内存中数据可安全销毁"></p>
<p>但是 GPU 访问 VRAM 速度仍然不够快，VRAM 中需要使用到的数据会进一步的被拷贝到 GPU 中的一小块内存上（ on-chip caches），这一块内存被称为 <code>L2 Cache</code> 。过程如下所示：<br>
<img src="/book_1_overview/gif_9-13-2021_9-18-41_am.gif" alt="L2 Cache"></p>
<p>在 GPU 更靠近核心（Core）的地方，还有一片更小的内存，称为 <code>L1 Cache</code> 。因为更靠近核心，所以 <code>L1 Cache</code> 中数据的访问速度相对于 <code>L2 Cache</code> 也更快。 <code>L2 Cache</code> 中的数据在需要被操作时，也会先拷贝到 <code>L1 Cache</code> 中。</p>
<p>在 <code>L1 Cache</code> 中的数据还会被进一步拷贝到 GPU 中被称为 <code>Register</code> 的内存区域，GPU Cores 会从该区域中读取数据，计算并将运算后结果放回到 <code>Register</code> 中：<br>
<img src="/book_1_overview/gif_9-13-2021_9-25-58_am.gif" alt="Register"></p>
<h1 id="Set_the_Render_State"><a class="header-anchor" href="#Set_the_Render_State">#</a>Set the Render State</h1>
<p>对于除了 Mesh 数据外的数据，如顶点/像素着色器，纹理，材质，光照信息，是否半透明等信息都称为 <code>Render State</code> 。</p>
<p>Mesh 数据会使用被设置的 <code>Render State</code> 进行渲染，图形 API 又是一个类似状态机的实现，即设置了 Render State 后，后续的 Mesh 都会使用该 State 进行渲染，直到有了新 State 被设置。示意图如下所示：<br>
<img src="/book_1_overview/gif_9-14-2021_8-47-57_am.gif" alt="State"></p>
<h1 id="Draw_Call"><a class="header-anchor" href="#Draw_Call">#</a>Draw Call</h1>
<p><code>DrawCall</code> 是一个由 CPU 端发出，由 GPU 端接受的绘制 <strong>一个 Mesh</strong> 的指令。该指令只包含指向需要绘制的 Mesh 的指针，而如材质这样的信息是通过 Render State 进行传递，并不会在 <code>DrawCall</code> 中。示意图如下所示：<br>
<img src="/book_1_overview/gif_9-14-2021_8-55-41_am.gif" alt="Draw Call"></p>
<h1 id="Pipeline"><a class="header-anchor" href="#Pipeline">#</a>Pipeline</h1>
<p>当 <code>DrawCall</code> 发送后，GPU 会获取当前的 Render State，和设置的顶点信息（Mesh），并通过渲染管线（Pipeline）将其一步步转换到最终屏幕上所见像素。在管线中，对于顶点和像素的工作会被划分到 GPU 的多个核心中平行处理。整个管线工作的简单示意图如下所示：<br>
<img src="/book_1_overview/gif_9-14-2021_9-02-13_am.gif" alt="Pipeline"></p>
<h1 id="Command_Buffer"><a class="header-anchor" href="#Command_Buffer">#</a>Command Buffer</h1>
<p>CPU 并不是直接将数据传递给 GPU，而是通过 <code>Command Buffer</code> ，这样 CPU 和 GPU 就可以各自独立的工作。如果是直接传递的话，当 GPU 在忙碌时，CPU 无法将数据送给 GPU，就会造成 CPU 的堵塞。</p>
<p>Command Buffer 是一个 <code>FIFO 存储器</code> ，即 GPU 只会取 CPU 最早 Push 进 Command Buffer 中的数据。 Command Buffer 的示意图如下所示：<br>
<img src="/book_1_overview/gif_9-14-2021_9-12-25_am.gif" alt="Command Buffer"></p>
<h1 id="Reference"><a class="header-anchor" href="#Reference">#</a>Reference</h1>
<p><a href="http://simonschreibt.de/gat/renderhell-book1/">Render Hell – Book I | Simon schreibt.</a></p>
]]></content>
      <tags>
        <tag>GPU</tag>
      </tags>
  </entry>
  <entry>
    <title>《Render Hell》 第三部分 常见问题</title>
    <url>/book_3_problems/</url>
    <content><![CDATA[<h1 id="Many_Draw_Calls_Many_Commands"><a class="header-anchor" href="#Many_Draw_Calls_Many_Commands">#</a>Many Draw Calls / Many Commands</h1>
<p>对于一个 API 而言，它不仅仅是将命令发送给 GPU，它还会有额外的如驱动翻译等的开销，因此应当尽可能的使用更少的命令。</p>
<div class="note info simple"><p>对于新的图形 API，如 DirectX12， Vulkan 等，命令的开销会相对较少，但仍然应当尽可能的减少命令的数量。</p>
</div>
<p>如果有一系列很小的 Mesh，相较于每个 Mesh 都使用一个 Drawcall，更理想的做法是将这些 Meshes 组合成一个更大的 Mesh，并通过一个 Drawcall 传送。</p>
<p>因为对于 GPU 而言，绘制一个小 Mesh 的时间是非常快的，而 CPU 将数据发送给 GPU 的时间是相对较长的。</p>
<p>如果是每一个 Mesh 一个 Draw Call 的处理方式，往往瓶颈会出现在 CPU 侧。</p>
<h1 id="Many_Meshes_and_Materials"><a class="header-anchor" href="#Many_Meshes_and_Materials">#</a>Many Meshes and Materials</h1>
<p>如果要渲染许多 Mesh 并使用不同的 Materials，除了需要用许多的命令外，还会额外带来 <code>Flush Pipeline</code> 的问题。</p>
<p>如果多个 Meshes 是用同一种渲染状态，则在一个 Mesh 完成后，另一个 Mesh 可以被很快的装填。而如果更改了材质状态，则管线中的一部分数据需要被刷新，才能进行下一个 Mesh 的绘制，这会造成额外的开销。</p>
<h1 id="Meshes_and_Multi_Materials"><a class="header-anchor" href="#Meshes_and_Multi_Materials">#</a>Meshes and Multi-Materials</h1>
<p>如果一个 Mesh 被赋予了多个材质，则该 Mesh 会被切分成多份再被送入 Command Buffer 中，这无疑也会造成多个 Draw Call 的产生。如下示意图所示，球的左半部分和右半部分各需要一个 Draw Call：<br>
<img src="/book_3_problems/copy_data_from_hdd_to_ram_vram_01_multimaterial.gif" alt="Multi-Materials"></p>
<h1 id="Thin_Triangles"><a class="header-anchor" href="#Thin_Triangles">#</a>Thin Triangles</h1>
<p>如在 Book 2 的 <a href="/book_2_pipeline/#Rasterizing">Rasterizing</a> 中所属，光栅化后的单位是 <code>pre-pixles</code> ，Warp 中的四个线程会被分给一个 <code>pre-pixels</code> 。对于一些没有真正覆盖三角形的 Pixels 而言，它们的颜色并无意义，因此虽然它们在 pre-pixels 中但并不会有线程去计算它们的颜色，这也就造成了 Warp 中线程的浪费。这种性能浪费会比较常见的出现在狭长的三角形中，如下示意图所示：<br>
<img src="/book_3_problems/pipeline_rasterizing03_.gif" alt="Thin Triangles 造成的性能浪费"></p>
<h1 id="Reference"><a class="header-anchor" href="#Reference">#</a>Reference</h1>
<p><a href="http://simonschreibt.de/gat/renderhell-book3/">Render Hell – Book III | Simon schreibt.</a></p>
]]></content>
      <tags>
        <tag>GPU</tag>
      </tags>
  </entry>
  <entry>
    <title>《Render Hell》 第四部分 解决方法</title>
    <url>/book_4_solutions/</url>
    <content><![CDATA[<h1 id="Sorting"><a class="header-anchor" href="#Sorting">#</a>Sorting</h1>
<p>对于多个 Meshes，多个 Materials 的情况，可以通过排序将同一种 Material 的 Mesh 放在一起减少 Render State 的切换，如下所示：<br>
<img src="/book_4_solutions/optimisation_sorting_01.gif" alt="重新排序以减少 State 切换"></p>
<h1 id="Batching"><a class="header-anchor" href="#Batching">#</a>Batching</h1>
<p>在排序完，仍然存在的问题是多个 Meshes 会造成多个 Commands 进而引起过多开销。因此应当将多个 Meshes 结合在一起，通过一次 Draw Call 进行渲染。在调用 API 前将多个 Meshes 合并在一起的过程称为 <code>Batch</code> 。</p>
<p><img src="/book_4_solutions/optimisation_batching_02.gif" alt="Batching"></p>
<div class="note info simple"><p>在 RAM 中将多个 Mesh 结合在一起也是需要开销的（CPU 时间），因此通常选择将静态的 Mesh，如房子，石头等Batch 在一起。 而如果是一系列运动的子弹，因为它们的位置每帧都会移动，所以相当于每帧都需要重新 <code>Batch</code>，这会造成巨大的开销。</p>
</div>
<p>Batch 还会造成一个额外的问题。在未进行 Batch 时，如果一个 Mesh 在 Frustum 外，则它会被直接 Cull 掉。但如果将多个 Meshes Batch 成一个大 Mesh，则即使只有其中的一小部分处在 Frustum 中，整个 Mesh 仍然会被认为需要被绘制。</p>
<p>因此相对于 <code>Batching</code>，更好的解决方法是 <code>Instancing</code></p>
<h1 id="Instancing"><a class="header-anchor" href="#Instancing">#</a>Instancing</h1>
<p><code>Instancing</code> 是提交一次 Mesh，但会告知 GPU 绘制多次，并在 RAM 中指定每次绘制时需要用的状态。因此 <code>Instancing</code> 适合同一个 Mesh 要多次绘制的情况，如草，子弹。示意图如下所示：<br>
<img src="/book_4_solutions/20200129181033200.gif" alt="Instancing"></p>
<h1 id="Multi_Material_Shader"><a class="header-anchor" href="#Multi_Material_Shader">#</a>Multi-Material Shader</h1>
<p>为了解决 Book3 中提到的 <a href="/book_3_problems/#Meshes_and_Multi-Materials">Meshes and Multi-Materials</a> 导致多 Draw Call 的问题，一个解决思路是将多个材质需要用到的数据合并在一个 Shader 中，相当于将多个 Material 合并成了一个 Material。</p>
<p>如原来每个材质需要一个 Diffuse Texture，一个 Normal Texture，可以使用一个包含两个 Diffuse Texture， 两个 Normal Texture 的材质来取代原来的两个材质，并在 Shader 中通过 Blending 的方式达成之前的效果。</p>
<div class="note warning simple"><p>这种实现方式虽然减少了 DrawCall 的数量，但会造成 Blending 的大量额外开销，因此最终性能可能反而下降。</p>
</div>
<h1 id="Skinned_Meshes"><a class="header-anchor" href="#Skinned_Meshes">#</a>Skinned Meshes</h1>
<p>如之前的描述，如果需要通过 Batch 来解决多个子弹占用多个 Draw Call 的问题，则会因为子弹需要每帧移动而造成每帧重新 Batch，这会造成巨大的开销。</p>
<p>有一个解决思路是将所有这些子弹结合在一起作为 Skinned Mesh，其中每个子弹作为一个 Bone，在后续的帧中只需要更新这些 Bone 的位置，而不需要重新进行合并。</p>
<div class="note warning simple"><p>当出现了子弹增加或减少时，则需要重新合并 Mesh</p>
</div>
<h1 id="Reference"><a class="header-anchor" href="#Reference">#</a>Reference</h1>
<p><a href="http://simonschreibt.de/gat/renderhell-book4/">Render Hell – Book IV | Simon schreibt.</a></p>
]]></content>
      <tags>
        <tag>GPU</tag>
      </tags>
  </entry>
  <entry>
    <title>《Computer Networks and Internets》 Ch 01 介绍与概览</title>
    <url>/ch_01_introduction_and_overview/</url>
    <content><![CDATA[<h1 id="Growth_Of_Computer_Networking"><a class="header-anchor" href="#Growth_Of_Computer_Networking">#</a>Growth Of Computer Networking</h1>
<p>计算机网络正在持续的爆炸性成长。在 1970 年代它只是一个非常小范围的研究课题，在 1980 年也只有几个网站，但到现在计算机网络f经成为了生活中的一部分。</p>
<h1 id="Why_Networking_Seems_Complex"><a class="header-anchor" href="#Why_Networking_Seems_Complex">#</a>Why Networking Seems Complex</h1>
<p>计算机网络是一个高速发展的领域。</p>
<p>对于初学者而言，他可能让人觉得很困惑，因为并没有一个最基础的理论来将计算机网络的所有部分联系在一起。有许多组织都定义了计算机网络的标准，而有时这些标准相互之间并不兼容。</p>
<p>计算机网络用语也并没有一个统一的标准，许多组织都定义过自己一套用语规范，这又很容易让初学者们感到困惑。</p>
<h1 id="The_Five_Key_Aspects_of_Networking"><a class="header-anchor" href="#The_Five_Key_Aspects_of_Networking">#</a>The Five Key Aspects of Networking</h1>
<p>计算机网络包括五个关键领域：</p>
<ol>
<li>网络应用与网络编程</li>
<li>数据通信</li>
<li>分组交换与网络技术</li>
<li>TCP/IP 的网络互联</li>
<li>附加的网络概念和技术</li>
</ol>
<h2 id="Network_Applications_and_network_programming"><a class="header-anchor" href="#Network_Applications_and_network_programming">#</a>Network Applications and network programming</h2>
<p>用户使用网络服务和设施是基于一个安装在电脑上的应用程序，这个程序可以与其他电脑上的程序通过网络进行交流。网络程序有很多种类，包括邮件，下载器，游览器等。</p>
<p>所有这些程序都是构建在一个单一的、共享的网络上，因此开发者可以使用同一套接口来进行开发。</p>
<p>计算机网络的知识可以帮助开发者更好的开发网络应用。</p>
<h2 id="Data_Communications"><a class="header-anchor" href="#Data_Communications">#</a>Data Communications</h2>
<p>数据通信是电子工程的主要领域，它基于一些物理现象来传输数据，是一个较底层的方法。</p>
<p>因为数据通信是基于物理概念，所以乍看起来它与计算机网络的学习并没有太深的关系，但数据通信中的一些关键概念影响了通信规范的制定。例如调制中带宽的概念直接影响了网络的吞吐量。</p>
<p>数据通信也引入了复用的概念，即多个来源的数据可以被组合在一起通过一个共享的媒介进行传输，然后再分开传递给不同的目的地。</p>
<p>数据通信包含了许多底层的细节，它为计算机网络构建了基础。</p>
<h2 id="Packet_Switching_And_Networking_Technologies"><a class="header-anchor" href="#Packet_Switching_And_Networking_Technologies">#</a>Packet Switching And Networking Technologies</h2>
<p>通信网络已经从早期的依赖于物理点线进行的点对点电报或电话系统转换为一个通信电路。早期的通过线连接已经转换为通过电交换。</p>
<p><code>分组交换（Packet switching）</code>从最底层的方式改变了网络，是现代网络的基础。多个信息发送者不再需要依赖于专用网络，通过分组交换他们可以通过一个共享的网络来传输数据。</p>
<p>分组交换将数据分为许多小块，称为包 <code>Packets</code>，包中都包含一个目的地的信息。网络中的设备都包含了如何抵达其他地址的信息，当设备接收到一个包后他会解析包中的数据，并选择一个通路将其送给正确的目的地。</p>
<p>因为计算机网络在设计时有许多不同的需求，例如速度，距离，经济成本等，有许多分组交换技术被发明出来，他们针对不同的需求在细节上存在着一些差异。</p>
<h2 id="Internetworking_with_TCP_IP"><a class="header-anchor" href="#Internetworking_with_TCP_IP">#</a>Internetworking with TCP/IP</h2>
<p>在一段时间内，许多研究者都致力于找到一个可以满足所有需求的分组交换技术。在 1973 年，Vinton Cerf 和 Pobert Kahn 认为不存在一种分组交换技术可以满足所有的需求，因此他们致力于将不同的技术融合在一起。他们发展了一系列的标准，并最终成为了<code>TCP/IP协议族(TCP/IP Internet Protocol)</code>(简称为 TCP/IP)。这最终成为了全球网络的基础，并称为计算机网络的一个重要组成部分。</p>
<p>TCP/IP 标准成功的一个重要原因是它宽容的异质性。TCP/IP 使用了一个虚拟的方法来定义网络不相关的包和网络不相关的检测方法。因此即使分组技术在持续的发展，TCP/IP 也始终可以与新的分组技术共存。</p>
<h2 id="Additional_Networking_Concepts_And_Technologies"><a class="header-anchor" href="#Additional_Networking_Concepts_And_Technologies">#</a>Additional Networking Concepts And Technologies</h2>
<p>除了构造网络的硬件和协议，还有大量的其他技术为网络提供了不同偶给你能。</p>
<p>例如 <code>软件定义网络(Software Defined Networking(SDN))</code> 允许管理者定义和控制网络， <code>物联网(Internet to Thing)</code> 让嵌入式系统可以通过网络进行交流。</p>
<h1 id="Public_and_Private_Parts_Of_The_Internet"><a class="header-anchor" href="#Public_and_Private_Parts_Of_The_Internet">#</a>Public and Private Parts Of The Internet</h1>
<p>计算机网络是由 <code>公共网络(Public network)</code> 和 <code>私人网络(Private network)</code> 构成的。</p>
<h2 id="Public_Network"><a class="header-anchor" href="#Public_Network">#</a>Public Network</h2>
<p>公共网络是 <code>服务提供商(Service Provider)</code> 所拥有的服务，服务商会将服务提供给任何订阅了的个人或组织。这里的公共指的是大众都可以订阅这个服务，并不意味着公共网络传输的数据是被暴露在外，所有人都可以获取的。</p>
<h2 id="Private_Network"><a class="header-anchor" href="#Private_Network">#</a>Private Network</h2>
<p>私人网络是指网络的使用权被限制在一个组间。如果服务商将服务租赁给了个人或公司，个人或公司仅在自己的范围内使用这个网络，那么它就是私人网络。</p>
<p>私人网络按其大小可以被分类为以下四种：</p>
<ol>
<li>消费者(Consumer)</li>
<li>小型办公室/家庭办公室(Small Office/Home Office, SOHO)</li>
<li>中小型商用(small-medium Business, SMB)</li>
<li>大型企业(Large enterprise)</li>
</ol>
<h1 id="Networks_Interoperability_And_Standards"><a class="header-anchor" href="#Networks_Interoperability_And_Standards">#</a>Networks, Interoperability, And Standards</h1>
<p>通信至少包含两个实体，信息发送者和信息接受者。为了保证网络中的所有实体都能正确的交流，需要有一个共同的标准。</p>
<p>使用 <code>互操作性(Interoperability)</code> 来表示两个实体是否可以无误的彼此通信。</p>
<p>为了保证实体可以正确的彼此交流，他们需要遵守一系列共同的规则，这些规则被称为 <code>通信协议(Communication protocol/Network protocol/Protocol)</code>。</p>
<ol>
<li>在通信发生错误的时候需要采取的行动也是由通信协议来指定。</li>
<li>通信协议可以是底层的，例如电压或信号的制定，也可以高层的，如软件传输的数据类型。</li>
</ol>
<h1 id="Protocol_Suites_And_Layering_Models"><a class="header-anchor" href="#Protocol_Suites_And_Layering_Models">#</a>Protocol Suites And Layering Models</h1>
<p>为了避免重复工作，每个协议应该只负责其他协议未包含的部分，因此协议的制定并非是相互独立的。将一系列合作的协议称为 <code>族(Suites/Families)</code>。族中的每个协议都只关注通信中的一部分，族中的所有协议组合起来就覆盖了整个通信的所有方面。</p>
<p>一个用来将协议分组的基本抽象是 <code>分组模型(Layering model)</code>，分组模型将所有通信问题分为几个部分，每个部分称为 <code>一层(Layer)</code>。将所有协议按层分组帮助协议的设计者和实现者有效的控制了问题的复杂度，因为他们只需要关注与网络的一个方面即可。</p>
<p>下图展示了因特网的分组模型，也成为 TCP/IP 分组模型：</p>
<p><img src="/ch_01_introduction_and_overview/2019-11-22-20-21-21.png" alt="TCP/IP分组模型"></p>
<h2 id="Layer_1_Physical"><a class="header-anchor" href="#Layer_1_Physical">#</a>Layer 1: Physical</h2>
<p>物理层的协议指定了传输媒介和相关硬件的细节。电子相关的属性，频率，信号等都属于物理层。</p>
<h2 id="Layer_2_Network_Interface_MAC"><a class="header-anchor" href="#Layer_2_Network_Interface_MAC">#</a>Layer 2: Network Interface(MAC)</h2>
<p>网络接口层的协议指定了对网络通信的细节以及网络硬件与 Layer3（Internet 层）的通信细节。硬件地址，网络地址，网络可支持的最大包数据以及传输媒介的协议等信息都属于网络接口层。</p>
<p>TCP/IP 的设计者将这一层命名为 <code>网络接口层（Network Interface）</code>，但一些协会更喜欢称为 <code>数据链路层（Data Link）</code>，工业界又喜欢称为 <code>媒介访问控制层（Media Access Control, MAC）</code></p>
<h2 id="Layer_3：Internet"><a class="header-anchor" href="#Layer_3：Internet">#</a>Layer 3：Internet</h2>
<p>因特网层是因特网的基础。因特网地址结构，因特网包的结构，大包拆分成小包的方式，报告错误的方式都属于因特网层。</p>
<h2 id="Layer_4：Transport"><a class="header-anchor" href="#Layer_4：Transport">#</a>Layer 4：Transport</h2>
<p>传输层协议提供了计算机上的一个应用与另一台机器上的应用交流的方法。如接收端接收数据的最大速率，避免网络堵塞的方法，和保证接收端按顺序接收数据的技术都属于传输层。</p>
<h2 id="Layer_5_Application"><a class="header-anchor" href="#Layer_5_Application">#</a>Layer 5: Application</h2>
<p>应用层的协议指定了通过网络交流的应用传输的数据信息的格式和意义，以及需要执行的步骤。如邮件，文件传输，语音电话等的实现都属于应用层。</p>
<h1 id="How_Data_passes_Through_Layers"><a class="header-anchor" href="#How_Data_passes_Through_Layers">#</a>How Data passes Through Layers</h1>
<p>分组模型并不只是为了帮助理解协议，协议的实现满足某一层协议的输出需要匹配相邻层协议的输入。</p>
<p>如下图展示了两台电脑通过网络传输数据的过程：</p>
<p><img src="/ch_01_introduction_and_overview/2019-11-22-20-59-21.png" alt="网络数据传输过程"></p>
<p>一号电脑是数据的发送方，二号电脑是数据的接收方。数据从一号电脑的应用层逐渐向下传递，通过接口层进入网络，在进入网络并传输后，通过二号电脑的接口层传入，再向上逐渐传递到应用层。</p>
<h1 id="Headers_And_Layers"><a class="header-anchor" href="#Headers_And_Layers">#</a>Headers And Layers</h1>
<p>每一层的协议为了保证数据被正确的传递都进行了一些计算。在发送端的每一层中都将一些额外的信息加到了数据包中，对应的，在接受段的每一层中都将解析并移除这些额外的信息。</p>
<p>这些被协议额外加入的数据称为<code>数据头(header)</code>。以发送端为例，数据头是在数据逐层向下的过程中一步步被加入的，即传输层增加一些数据头，网络层增加一些数据头，接口层增加一些数据头。因此最终的数据会如下图所示，最靠近原始数据的数据头是最早被添加的：</p>
<p><img src="/ch_01_introduction_and_overview/2019-11-22-21-08-20.png" alt="网络数据头添加"></p>
<ul>
<li>虽然图中每个被添加的数据头大小看起来相同，但实际上都不是一个固定的大小。</li>
</ul>
<h1 id="ISO_And_The_OSI_Seven_Layer_Reference_Model"><a class="header-anchor" href="#ISO_And_The_OSI_Seven_Layer_Reference_Model">#</a>ISO And The OSI Seven Layer Reference Model</h1>
<p>在因特网模型发展的过程中，有两个组织定义了一个替代的参考模型，称为<code>开放式系统互联参考七层模型(Open Systems Interconnection Seven-Layer Reference Model)</code>，简称为<code>OSI模型</code>。</p>
<p>这两个组织分别是<code>国际标准化组织（International Organization for Standardization）</code>，简称为<code>ISO</code>和<code>国际电信联盟（International Telecommunications Union）(ITU)</code>中的电信标准部门。</p>
<p><code>OSI</code>协议图如下：</p>
<p><img src="/ch_01_introduction_and_overview/2019-11-22-23-01-16.png" alt="OSI协议"></p>
<p>TCP/IP 协议比 OSI 协议更为高效合理，发展和部署 OSI 协议的工作已经被停滞。许多工作者目前在扩展 OSI 协议的定义来让其符合 TCP/IP，基本是让 Network 层匹配 Internet 层，然后再在 Session 层和 Presentation 层增加一些支持协议。</p>
<p>虽然许多工程师和商业部门知道<code>OSI协议</code>不如<code>TCP/IP协议</code>高效，但他们依然处于某些原因在坚持使用。</p>
<h1 id="Remainder_Of_The_Text"><a class="header-anchor" href="#Remainder_Of_The_Text">#</a>Remainder Of The Text</h1>
<p>书的剩下部分将分为五个部分，基本对应与 1.3 节中提到的五个重要领域。</p>
<p>第一部分介绍网络应用和网络编程</p>
<p>第二部分介绍数据通信和信息传输</p>
<p>第三部分介绍分组交换以及包数据，另外也会介绍一些网络的基本分类，如局域网和广域网</p>
<p>第四部分将介绍 TCP/IP 协议族</p>
<p>第五部分介绍剩下的一些网络相关的技术</p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《Head First 设计模式》 Ch 02 观察者模式</title>
    <url>/ch_02_the_observer_pattern/</url>
    <content><![CDATA[<p>观察者模式（Observer Pattern）定义了一种一对多的依赖关系，当被观察者（<code>Subject</code>）的状态发生变化时，它将会通知观察者们（<code>Observers</code>）进行某种操作。</p>
<p>例如我们希望定义温度计和压力计，在天气信息发生变化时自动更新，而非自己反复的查询是否天气信息有发生变化。这里天气信息就是被观察者，而温度计和压力计就是观察者。</p>
<h1 id="代码示例"><a class="header-anchor" href="#代码示例">#</a>代码示例</h1>
<h2 id="观察者及被观察者接口"><a class="header-anchor" href="#观察者及被观察者接口">#</a>观察者及被观察者接口</h2>
<figure class="highlight cs"><figcaption><span>被观察者</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ISubject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RegisterObserver</span>(<span class="params">IObserver observer</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">UnregisterObserver</span>(<span class="params">IObserver observer</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NotifyObservers</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>观察者</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IObserver</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params">ISubject subject</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="观察者实现"><a class="header-anchor" href="#观察者实现">#</a>观察者实现</h2>
<figure class="highlight cs"><figcaption><span>温度计</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TemperatureObserver</span> : <span class="title">IObserver</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> ISubject subject;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TemperatureObserver</span>(<span class="params">ISubject subject</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">        <span class="keyword">this</span>.subject.RegisterObserver(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params">ISubject subject</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        WeatherData weatherData = subject <span class="keyword">as</span> WeatherData;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注意这里我们是从主动从被观察者那里去获取数据</span></span><br><span class="line">        <span class="keyword">if</span> (weatherData != <span class="literal">null</span>)</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Temperature is &quot;</span> + weatherData.Temperature);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>压力计</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PressureObserver</span> : <span class="title">IObserver</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> ISubject subject;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PressureObserver</span>(<span class="params">ISubject subject</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">        <span class="keyword">this</span>.subject.RegisterObserver(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params">ISubject subject</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        WeatherData weatherData = subject <span class="keyword">as</span> WeatherData;</span><br><span class="line">        <span class="keyword">if</span> (weatherData != <span class="literal">null</span>)</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Pressure is &quot;</span> + weatherData.Pressure);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="被观察者实现"><a class="header-anchor" href="#被观察者实现">#</a>被观察者实现</h2>
<figure class="highlight cs"><figcaption><span>天气数据</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WeatherData</span> : <span class="title">ISubject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;IObserver&gt; observersList;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> Temperature &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> Humidity &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> Pressure &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeatherData</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        observersList = <span class="keyword">new</span> List&lt;IObserver&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">NotifyObservers</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        observersList.ForEach(o =&gt; o.Update(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RegisterObserver</span>(<span class="params">IObserver o</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        observersList.Add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UnregisterObserver</span>(<span class="params">IObserver o</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        observersList.Remove(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">measurementsChanged</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        NotifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetMeasurements</span>(<span class="params"><span class="built_in">float</span> temperature, <span class="built_in">float</span> humidity, <span class="built_in">float</span> pressure</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.Temperature = temperature;</span><br><span class="line">        <span class="keyword">this</span>.Humidity = humidity;</span><br><span class="line">        <span class="keyword">this</span>.Pressure = pressure;</span><br><span class="line">        measurementsChanged();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="测试及结果"><a class="header-anchor" href="#测试及结果">#</a>测试及结果</h1>
<figure class="highlight cs"><figcaption><span>测试代码</span></figcaption><table><tr><td class="code"><pre><span class="line">WeatherData weatherData = <span class="keyword">new</span> WeatherData();</span><br><span class="line">TemperatureObserver temperatureObserver = <span class="keyword">new</span> TemperatureObserver(weatherData);</span><br><span class="line">PressureObserver pressureObserver = <span class="keyword">new</span> PressureObserver(weatherData);</span><br><span class="line"></span><br><span class="line">weatherData.SetMeasurements(<span class="number">30</span>, <span class="number">20</span>, <span class="number">10</span>);</span><br><span class="line">weatherData.SetMeasurements(<span class="number">20</span>, <span class="number">40</span>, <span class="number">5</span>);</span><br><span class="line">weatherData.UnregisterObserver(temperatureObserver);</span><br><span class="line">weatherData.SetMeasurements(<span class="number">10</span>, <span class="number">50</span>, <span class="number">15</span>);</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/ch_02_the_observer_pattern/2019-01-15-23-20-09.png" alt="观察者模式运行结果"></p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>《Head First 设计模式》 Ch 01 策略模式</title>
    <url>/ch_01_the_strategy_pattern/</url>
    <content><![CDATA[<p>策略模式（Strategy Pattern）是使用一些独立的类来各自封装一些通用的算法，这些封装类都继承自同一个接口，该接口定义了算法。对于调用类来说，它只保存一个算法接口的对象，而这个对象所指代的特定算法则可以在运行时动态更改。</p>
<p>例如有我们有一个项目需要描述鸭子，可能有 50 种不同的鸭子都派生自基类 <code>Duck</code>，鸭子一共有三种飞行方式。这时候我们如果将某一种特定的飞行方式写在基类中，则不是使用这个飞行方式的所有派生鸭子都需要对该方法重写。如果我们不在基类中定义，而在各个派生类中实现，则可能多个有相同飞行方式的鸭子派生类都有相同的代码定义飞行方式，这造成了代码冗余。</p>
<p>所以我们可以使用策略模式，将三种飞行方式都派生自接口 <code>FlyBehavior</code>，并在鸭子基类中定义变量<code>FlyBehavior</code>，然后在派生类中选择各自需要的飞行方式即可。</p>
<h1 id="代码示例"><a class="header-anchor" href="#代码示例">#</a>代码示例</h1>
<h2 id="算法接口及实现类"><a class="header-anchor" href="#算法接口及实现类">#</a>算法接口及实现类</h2>
<figure class="highlight cs"><figcaption><span>飞行方法接口</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IFlyBehavior</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Fly</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>飞行方法实现</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FlyNoWay</span> : <span class="title">IFlyBehavior</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fly</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Can not fly&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FlyWithRocket</span> : <span class="title">IFlyBehavior</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fly</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Fly with rocket&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FlyWithWings</span> : <span class="title">IFlyBehavior</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fly</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Fly with wings&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="环境类"><a class="header-anchor" href="#环境类">#</a>环境类</h2>
<figure class="highlight cs"><figcaption><span>鸭子基类</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Duck</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IFlyBehavior flyBehavior;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Duck</span>()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">disPlay</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PerformFly</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        flyBehavior.Fly();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlyBehavior</span>(<span class="params">IFlyBehavior fb</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        flyBehavior = fb;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>鸭子派生类</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BlackDuck</span> : <span class="title">Duck</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BlackDuck</span>() : <span class="title">base</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        setFlyBehavior(<span class="keyword">new</span> FlyWithWings());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">disPlay</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;I am a black duck&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RubberDuck</span> : <span class="title">Duck</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RubberDuck</span>() : <span class="title">base</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        setFlyBehavior(<span class="keyword">new</span> FlyNoWay());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">disPlay</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;I am a rubber duck&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="测试及结果"><a class="header-anchor" href="#测试及结果">#</a>测试及结果</h1>
<figure class="highlight cs"><figcaption><span>测试代码</span></figcaption><table><tr><td class="code"><pre><span class="line">RubberDuck rubberDuck = <span class="keyword">new</span> RubberDuck();</span><br><span class="line">rubberDuck.disPlay();</span><br><span class="line">rubberDuck.PerformFly();</span><br><span class="line"></span><br><span class="line">BlackDuck blackDuck = <span class="keyword">new</span> BlackDuck();</span><br><span class="line">blackDuck.disPlay();</span><br><span class="line">blackDuck.PerformFly();</span><br><span class="line">blackDuck.setFlyBehavior(<span class="keyword">new</span> FlyWithRocket());</span><br><span class="line">blackDuck.PerformFly();</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<p><img src="/ch_01_the_strategy_pattern/2019-01-15-00-12-45.png" alt="策略模式运行结果"></p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>《Head First 设计模式》 Ch 04 工厂模式</title>
    <url>/ch_04_the_factory_pattern/</url>
    <content><![CDATA[<p>工厂模式是为了将对象的实例化与对对象的操作解耦。因为有时我们会根据情况的不同，实例化出对象的不同版本，而我们不希望这种对于情况的判断与逻辑代码耦合在一起。</p>
<p>工厂模式有三个较为常见的变种，简单工厂模式，工厂方法模式，抽象工厂模式，下面会以创建披萨为例子来具体说明。</p>
<h1 id="简单工厂模式"><a class="header-anchor" href="#简单工厂模式">#</a>简单工厂模式</h1>
<p>简单工厂模式严格意义上并不是一个设计模式，只是它被太多人的使用，所以需要单独进行说明。</p>
<p>简单工厂模式会定义一个工厂类来进行对象的实例化。</p>
<p>我们定义一个披萨商店，他将会管理披萨产出的整个流程。我们为了将披萨的生产与之后的操作（如切披萨）拆分开，需要定义一个简单披萨工厂。</p>
<h2 id="代码示例"><a class="header-anchor" href="#代码示例">#</a>代码示例</h2>
<h3 id="披萨类及其实例化"><a class="header-anchor" href="#披萨类及其实例化">#</a>披萨类及其实例化</h3>
<figure class="highlight cs"><figcaption><span>披萨基类</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Pizza</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> Cheese cheese = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">protected</span> Sauce sauce = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">protected</span> Onion onion = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">prepare</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Bake for 25 minutes at 350&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cut</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Cutting the pizza into diagonal slices&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">box</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Place pizza in official PizzaStore box&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Debug</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">        Console.WriteLine(name);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Cheese is &quot;</span> + (cheese != <span class="literal">null</span> ? cheese.ToString() : <span class="string">&quot;Null&quot;</span>));</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Sauce is &quot;</span> + (sauce != <span class="literal">null</span> ? sauce.ToString() : <span class="string">&quot;Null&quot;</span>));</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Onion is &quot;</span> + (onion != <span class="literal">null</span> ? onion.ToString() : <span class="string">&quot;Null&quot;</span>));</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>披萨实现</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CheesePizza</span> : <span class="title">Pizza</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">prepare</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cheese = <span class="keyword">new</span> Cheese();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SaucePizza</span> : <span class="title">Pizza</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">prepare</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        sauce = <span class="keyword">new</span> Sauce();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="披萨商店与简单披萨工厂"><a class="header-anchor" href="#披萨商店与简单披萨工厂">#</a>披萨商店与简单披萨工厂</h3>
<figure class="highlight cs"><figcaption><span>披萨商店</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PizzaStore</span></span><br><span class="line">&#123;</span><br><span class="line">    SimplePizzaFactory simpleFactory;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PizzaStore</span>(<span class="params">SimplePizzaFactory factory</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.simpleFactory = factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">orderPizza</span>(<span class="params"><span class="built_in">string</span> type</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Pizza pizza = simpleFactory.createPizza(type);</span><br><span class="line">        pizza.prepare();</span><br><span class="line">        pizza.bake();</span><br><span class="line">        pizza.cut();</span><br><span class="line">        pizza.box();</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>简单披萨工厂</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SimplePizzaFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">createPizza</span>(<span class="params"><span class="built_in">string</span> type</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Pizza pizza = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (type.Equals(<span class="string">&quot;cheese&quot;</span>))</span><br><span class="line">            pizza = <span class="keyword">new</span> CheesePizza();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (type.Equals(<span class="string">&quot;sauce&quot;</span>))</span><br><span class="line">            pizza = <span class="keyword">new</span> SaucePizza();</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试及结果"><a class="header-anchor" href="#测试及结果">#</a>测试及结果</h2>
<figure class="highlight cs"><figcaption><span>测试代码</span></figcaption><table><tr><td class="code"><pre><span class="line">PizzaStore store = <span class="keyword">new</span> PizzaStore(<span class="keyword">new</span> SimplePizzaFactory());</span><br><span class="line">Pizza pizza = store.orderPizza(<span class="string">&quot;cheese&quot;</span>);</span><br><span class="line">pizza.Debug();</span><br></pre></td></tr></table></figure>
<p>运行结果:<br>
<img src="/ch_04_the_factory_pattern/2019-01-20-21-24-34.png" alt="简单工厂运行结果"></p>
<h1 id="工厂方法模式"><a class="header-anchor" href="#工厂方法模式">#</a>工厂方法模式</h1>
<p>简单工厂提供了一个类来作为对象实例化的工厂，它解决了对象实例化与逻辑代码耦合的问题，但没有提供扩写这个工厂的方法。例如上例中，我们需要在工厂中增加新的产品只能扩写原先的工厂类，但这可能会造成单个工厂类的逻辑过于复杂。<br>
而工厂方法模式则是通过一个抽象函数来作为工厂，在各派生类中重写该函数，达到工厂的扩写。</p>
<p>我们定义一个抽象的披萨商店，并在其中定义一个抽象函数 <code>createPizza</code>，并在披萨商店的继承类中重写这个方法来演示工厂方法模式。</p>
<div class="note warning simple"><p>注意这个例子完全可以通过建立多个简单工厂来实现，这里只是为了说明工厂方法模式的结构。</p>
</div>
<h2 id="代码示例-2"><a class="header-anchor" href="#代码示例-2">#</a>代码示例</h2>
<h3 id="抽象披萨商店及实例化"><a class="header-anchor" href="#抽象披萨商店及实例化">#</a>抽象披萨商店及实例化</h3>
<figure class="highlight cs"><figcaption><span>抽象披萨商店</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">PizzaStore</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">orderPizza</span>(<span class="params"><span class="built_in">string</span> type</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Pizza pizza = createPizza(type);</span><br><span class="line">        pizza.prepare();</span><br><span class="line">        pizza.bake();</span><br><span class="line">        pizza.cut();</span><br><span class="line">        pizza.box();</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Pizza <span class="title">createPizza</span>(<span class="params"><span class="built_in">string</span> type</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>纽约披萨商店</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NYPizzaStore</span> : <span class="title">PizzaStore</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> Pizza <span class="title">createPizza</span>(<span class="params"><span class="built_in">string</span> type</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Pizza pizza = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (type.Equals(<span class="string">&quot;cheese&quot;</span>))</span><br><span class="line">            pizza = <span class="keyword">new</span> NYStyleCheesePizza();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (type.Equals(<span class="string">&quot;sauce&quot;</span>))</span><br><span class="line">            pizza = <span class="keyword">new</span> NYStyleSausePizza();</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>芝加哥披萨商店</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ChicagoPizzaStore</span> : <span class="title">PizzaStore</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> Pizza <span class="title">createPizza</span>(<span class="params"><span class="built_in">string</span> type</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Pizza pizza = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (type.Equals(<span class="string">&quot;cheese&quot;</span>))</span><br><span class="line">            pizza = <span class="keyword">new</span> ChicagoStyleCheesePizza();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (type.Equals(<span class="string">&quot;sauce&quot;</span>))</span><br><span class="line">            pizza = <span class="keyword">new</span> ChicagoStyleSaucePizza();</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="不同风格的披萨实现"><a class="header-anchor" href="#不同风格的披萨实现">#</a>不同风格的披萨实现</h3>
<figure class="highlight cs"><figcaption><span>纽约风格的披萨</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NYStyleCheesePizza</span> : <span class="title">Pizza</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">prepare</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cheese = <span class="keyword">new</span> NYCheese();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NYStyleSausePizza</span> : <span class="title">Pizza</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">prepare</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        sauce = <span class="keyword">new</span> NYSauce();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>芝加哥风格的披萨</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ChicagoStyleCheesePizza</span> : <span class="title">Pizza</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">prepare</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cheese = <span class="keyword">new</span> ChicagoCheese();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ChicagoStyleSaucePizza</span> : <span class="title">Pizza</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">prepare</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        sauce = <span class="keyword">new</span> ChicagoSauce();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试及结果-2"><a class="header-anchor" href="#测试及结果-2">#</a>测试及结果</h2>
<figure class="highlight cs"><figcaption><span>测试代码</span></figcaption><table><tr><td class="code"><pre><span class="line">PizzaStore store = <span class="keyword">new</span> ChicagoPizzaStore();</span><br><span class="line">Pizza pizza = store.orderPizza(<span class="string">&quot;cheese&quot;</span>);</span><br><span class="line">pizza.Debug();</span><br><span class="line">store = <span class="keyword">new</span> NYPizzaStore();</span><br><span class="line">pizza=store.orderPizza(<span class="string">&quot;cheese&quot;</span>);</span><br><span class="line">pizza.Debug();</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/ch_04_the_factory_pattern/2019-01-23-00-29-35.png" alt="工厂方法模式运行结果"></p>
<h1 id="抽象工厂模式"><a class="header-anchor" href="#抽象工厂模式">#</a>抽象工厂模式</h1>
<p>工厂方法模式中的工厂的多态性依赖于继承，比如我们定义的<code>PizzaStore</code>中有个抽象函数<code>createPizza</code>，这个抽象函数即为一个工厂，在各个派生类中我们去重写这个抽象函数，通过继承来实现不同的工厂。而在抽象工厂模式中，我们将定义一个工厂接口，在需要工厂的接口中类中存储这个接口，并在不同的情况下用这个接口不同的实现，来达到工厂的多态性。</p>
<p>另外在工厂方法模式中，因为是通过重写函数的方法来实现，所以一个工厂只能产出一个产品。而在抽象工厂模式中，在一个抽象工厂中却能定义多个制造产品的函数，进而一个抽象工厂可以提供多个产品。</p>
<div class="note info simple"><p>生产出一个产品还是多个产品并不是抽象工厂模式和工厂方法模式的主要区别，他们的主要区别在于工厂方法模式是通过继承来实现工厂的多态，而抽象工厂模式是通过组合。</p>
</div>
<p>我们定义一个披萨原料工厂，来体现抽象工厂模式。</p>
<h2 id="代码示例-3"><a class="header-anchor" href="#代码示例-3">#</a>代码示例</h2>
<h3 id="披萨原料工厂接口及实现"><a class="header-anchor" href="#披萨原料工厂接口及实现">#</a>披萨原料工厂接口及实现</h3>
<figure class="highlight cs"><figcaption><span>披萨原料工厂接口</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">PizzaIngredientFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Onion <span class="title">createOnion</span>()</span>;</span><br><span class="line">    <span class="function">Sauce <span class="title">createSauce</span>()</span>;</span><br><span class="line">    <span class="function">Cheese <span class="title">createCheese</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>纽约披萨原料商店</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NYPizzaIngredientFactory</span> : <span class="title">PizzaIngredientFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cheese <span class="title">createCheese</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NYCheese();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Onion <span class="title">createOnion</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NYOnion();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sauce <span class="title">createSauce</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NYSauce();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>芝加哥披萨原料商店</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ChicagoPizzaIngredientFactory</span> : <span class="title">PizzaIngredientFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cheese <span class="title">createCheese</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ChicagoCheese();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Onion <span class="title">createOnion</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ChicagoOnion();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sauce <span class="title">createSauce</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ChicagoSauce();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note info simple"><p>可以看到在抽象工厂的实现时，用到了工厂方法模式。抽象工厂模式与工厂方法模式并非互斥的两种模式，工厂方法模式实际上内嵌与抽象工厂模式中</p>
</div>
<h3 id="抽象披萨商店及实例化-2"><a class="header-anchor" href="#抽象披萨商店及实例化-2">#</a>抽象披萨商店及实例化</h3>
<figure class="highlight cs"><figcaption><span>抽象披萨商店</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">PizzaStore</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">orderPizza</span>(<span class="params"><span class="built_in">string</span> type</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Pizza pizza = createPizza(type);</span><br><span class="line">        pizza.prepare();</span><br><span class="line">        pizza.bake();</span><br><span class="line">        pizza.cut();</span><br><span class="line">        pizza.box();</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Pizza <span class="title">createPizza</span>(<span class="params"><span class="built_in">string</span> type</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>纽约披萨商店</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> Pizza <span class="title">createPizza</span>(<span class="params"><span class="built_in">string</span> item</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Pizza pizza = <span class="literal">null</span>;</span><br><span class="line">    PizzaIngredientFactory ingredientFactory = <span class="keyword">new</span> NYPizzaIngredientFactory();</span><br><span class="line">    <span class="keyword">if</span> (item == <span class="string">&quot;cheese&quot;</span>)</span><br><span class="line">        pizza = <span class="keyword">new</span> CheesePizza(ingredientFactory);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (item == <span class="string">&quot;sauce&quot;</span>)</span><br><span class="line">        pizza = <span class="keyword">new</span> SaucePizza(ingredientFactory);</span><br><span class="line">    <span class="keyword">return</span> pizza;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>芝加哥披萨商店</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ChicagoPizzaStore</span> : <span class="title">PizzaStore</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> Pizza <span class="title">createPizza</span>(<span class="params"><span class="built_in">string</span> item</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Pizza pizza = <span class="literal">null</span>;</span><br><span class="line">        PizzaIngredientFactory ingredientFactory = <span class="keyword">new</span> ChicagoPizzaIngredientFactory();</span><br><span class="line">        <span class="keyword">if</span> (item == <span class="string">&quot;cheese&quot;</span>)</span><br><span class="line">            pizza = <span class="keyword">new</span> CheesePizza(ingredientFactory);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (item == <span class="string">&quot;sauce&quot;</span>)</span><br><span class="line">            pizza = <span class="keyword">new</span> SaucePizza(ingredientFactory);</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note info simple"><p>注意，这里披萨商店的实现，仍然是通过工厂方法模式。只是在<code>createPizza</code>函数中会实例化一个抽象工厂，并将其传递给对应的<code>Pizza</code>对象</p>
</div>
<h3 id="披萨类及其实例化-2"><a class="header-anchor" href="#披萨类及其实例化-2">#</a>披萨类及其实例化</h3>
<p>在披萨类的实例化中，我们使用了抽象工厂模式，披萨的实例化会包含一个披萨原料的抽象工厂，通过不同的披萨原料工厂来取得不同风味的披萨</p>
<figure class="highlight cs"><figcaption><span>披萨基类</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Pizza</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> Cheese cheese = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">protected</span> Sauce sauce = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">protected</span> Onion onion = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">prepare</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Bake for 25 minutes at 350&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cut</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Cutting the pizza into diagonal slices&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">box</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Place pizza in official PizzaStore box&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Debug</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">        Console.WriteLine(name);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Cheese is &quot;</span> + (cheese != <span class="literal">null</span> ? cheese.ToString() : <span class="string">&quot;Null&quot;</span>));</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Sauce is &quot;</span> + (sauce != <span class="literal">null</span> ? sauce.ToString() : <span class="string">&quot;Null&quot;</span>));</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Onion is &quot;</span> + (onion != <span class="literal">null</span> ? onion.ToString() : <span class="string">&quot;Null&quot;</span>));</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>披萨实现</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CheesePizza</span> : <span class="title">Pizza</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> PizzaIngredientFactory ingredientFactory = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CheesePizza</span>(<span class="params">PizzaIngredientFactory ingredientFactory</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.ingredientFactory = ingredientFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">prepare</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cheese = ingredientFactory.createCheese();</span><br><span class="line">        onion = ingredientFactory.createOnion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SaucePizza</span> : <span class="title">Pizza</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> PizzaIngredientFactory ingredientFactory = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SaucePizza</span>(<span class="params">PizzaIngredientFactory ingredientFactory</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.ingredientFactory = ingredientFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">prepare</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        sauce = ingredientFactory.createSauce();</span><br><span class="line">        onion = ingredientFactory.createOnion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试及结果-3"><a class="header-anchor" href="#测试及结果-3">#</a>测试及结果</h2>
<figure class="highlight cs"><figcaption><span>测试代码</span></figcaption><table><tr><td class="code"><pre><span class="line">PizzaStore pizzaStore = <span class="keyword">new</span> NYPizzaStore();</span><br><span class="line">Pizza pizza = pizzaStore.OrderPizza(<span class="string">&quot;cheese&quot;</span>);</span><br><span class="line">pizza.Debug();</span><br><span class="line">Console.WriteLine(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line">pizzaStore = <span class="keyword">new</span> ChicagoPizzaStore();</span><br><span class="line">pizza = pizzaStore.OrderPizza(<span class="string">&quot;cheese&quot;</span>);</span><br><span class="line">pizza.Debug();</span><br></pre></td></tr></table></figure>
<p>运行结果：<br>
<img src="/ch_04_the_factory_pattern/2019-01-24-01-01-50.png" alt="抽象工厂模式运行结果"></p>
<h1 id="Reference"><a class="header-anchor" href="#Reference">#</a>Reference</h1>
<p><a href="https://dzone.com/articles/factory-method-vs-abstract">https://dzone.com/articles/factory-method-vs-abstract</a><br>
<a href="https://stackoverflow.com/questions/5739611/differences-between-abstract-factory-pattern-and-factory-method">https://stackoverflow.com/questions/5739611/differences-between-abstract-factory-pattern-and-factory-method</a></p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>《Head First 设计模式》 Ch 03 装饰模式</title>
    <url>/ch_03_the_decorator_pattern/</url>
    <content><![CDATA[<p>装饰模式（Decorator Pattern） 提供了一个动态增加一个类功能的方法，主要实现思想是通过一个作为装饰者的类（<code>Decorators</code>）包裹被装饰类（<code>Component</code>）（装饰类以及被装饰类都有共同的基类），<code>Decorators</code> 会在 <code>Component</code> 类的某一个函数执行前或后进行一些操作，进而达到增加功能的作用。</p>
<p>装饰模式主要实现了“代码应该对扩展功能开放而对于修改关闭”的面向对象原则，它在增加新功能的前提下，不需要改动既有的代码，只需要增加新的 <code>Decorators</code> 并且包含既有的 <code>Component</code> 即可。</p>
<p>例如我们要计算一杯咖啡的价格，而这杯咖啡的价格还会受到额外的配料的影响，比如要加抹茶需要额外支付 0.2 元，加奶泡需要额外支付 0.3 元等。如果对各种配料都各自使用一个类来表示，则会存在较多的类需要维护，而且一旦配料发生变化等，还需要进行代码修改。而使用装饰模式则可以将原始的咖啡作为被装饰类，而所有的配料都是装饰类，则配料的更改仅需要增加或删除外部的装饰类即可。</p>
<h1 id="代码示例"><a class="header-anchor" href="#代码示例">#</a>代码示例</h1>
<h2 id="装饰类及被装饰类基类"><a class="header-anchor" href="#装饰类及被装饰类基类">#</a>装饰类及被装饰类基类</h2>
<figure class="highlight cs"><figcaption><span>被装饰类基类</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Beverage</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">string</span> description = <span class="string">&quot;UnKnown Beverage&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">string</span> <span class="title">getDescription</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">double</span> <span class="title">Cost</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>装饰类基类</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">CondimentDecorator</span> : <span class="title">Beverage</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> Beverage beverage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CondimentDecorator</span>(<span class="params">Beverage beverage</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.beverage = beverage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note info simple"><p>注意装饰类基类继承自被装饰类，并存有一个被装饰类的变量，因为装饰类需要在被装饰类操作的基础上进行一定额外的操作，所以它需要存有对被装饰类的引用，同时对外部而言调用者而言，它与被装饰类相同。</p>
</div>
<h2 id="被装饰类实现"><a class="header-anchor" href="#被装饰类实现">#</a>被装饰类实现</h2>
<figure class="highlight cs"><figcaption><span>浓咖啡</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Espresso</span> : <span class="title">Beverage</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Espresso</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        description = <span class="string">&quot;Espresson&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">double</span> <span class="title">Cost</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.99</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="装饰类实现"><a class="header-anchor" href="#装饰类实现">#</a>装饰类实现</h2>
<figure class="highlight cs"><figcaption><span>酱油</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Soy</span> : <span class="title">CondimentDecorator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Soy</span>(<span class="params">Beverage beverage</span>) : <span class="title">base</span>(<span class="params">beverage</span>)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">getDescription</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> beverage.getDescription() + <span class="string">&quot;, Soy&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">double</span> <span class="title">Cost</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.30</span> + beverage.Cost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>奶泡</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Whip</span> : <span class="title">CondimentDecorator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Whip</span>(<span class="params">Beverage beverage</span>) : <span class="title">base</span>(<span class="params">beverage</span>)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">getDescription</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> beverage.getDescription() + <span class="string">&quot;, Whip&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">double</span> <span class="title">Cost</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.30</span> + beverage.Cost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>抹茶</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Mocha</span> : <span class="title">CondimentDecorator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mocha</span>(<span class="params">Beverage beverage</span>) : <span class="title">base</span>(<span class="params">beverage</span>)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">getDescription</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> beverage.getDescription() + <span class="string">&quot;, Mocha&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">double</span> <span class="title">Cost</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.20</span> + beverage.Cost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="测试及结果"><a class="header-anchor" href="#测试及结果">#</a>测试及结果</h1>
<figure class="highlight cs"><figcaption><span>测试代码</span></figcaption><table><tr><td class="code"><pre><span class="line">Espresso espresso = <span class="keyword">new</span> Espresso();</span><br><span class="line">Console.WriteLine(espresso.getDescription() + <span class="string">&quot; Cost: &quot;</span> + espresso.Cost());</span><br><span class="line"></span><br><span class="line">Beverage doubleMochaWhipEspresso = <span class="keyword">new</span> Mocha(<span class="keyword">new</span> Mocha(<span class="keyword">new</span> Whip(espresso)));</span><br><span class="line">Console.WriteLine(doubleMochaWhipEspresso.getDescription() + <span class="string">&quot; Cost: &quot;</span> + doubleMochaWhipEspresso.Cost());</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/ch_03_the_decorator_pattern/2019-01-15-23-43-20.png" alt="装饰模式运行结果"></p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>《Head First 设计模式》 Ch 05 单例模式</title>
    <url>/ch_05_the_singleton_pattern/</url>
    <content><![CDATA[<p>单例模式(Singleton Pattern)可能是最简单，也是被应用最为广泛的设计模式。单例模式保证一个类只会存在一个实例，并且提供了一个公共的接口来访问该实例。</p>
<h1 id="代码示例"><a class="header-anchor" href="#代码示例">#</a>代码示例</h1>
<figure class="highlight cs"><figcaption><span>单例模式</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">object</span> lockObj = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">lock</span> (lockObj)</span><br><span class="line">                    <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">                        instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Constructor the Singleton&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里使用一个<code>lockObj</code>是为了保证多线程安全，如果有多个线程在同一时间第一次调用<code>Instance</code>，则可能存在两个线程都进入了<code>instance == null</code>的分支，这就会造成两次实例化，所以我们需要通过加锁来保证线程安全。但如果我们将锁直接加在第一个<code>If</code>外，则每次调用<code>Instance</code>都有一个加锁的过程，所以这里选择在第一个 If 内加锁，锁内再次检查保证只会有一次实例化。</p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>《Computer Networks and Internets》 Ch 06 信源与信号</title>
    <url>/ch_06_information_sources_and_signals/</url>
    <content><![CDATA[<h1 id="Introduction"><a class="header-anchor" href="#Introduction">#</a>Introduction</h1>
<p>这一章讲解释<code>信源（Information Sources）</code>和携带信息的信号的特征。</p>
<h1 id="Information_Sources"><a class="header-anchor" href="#Information_Sources">#</a>Information Sources</h1>
<p>数据通信理论更关注于较低层次的通信系统，因此信源可以是任意来源，不仅仅是包括计算机上层的键盘，鼠标，摄像机，传感器等等也是信源。</p>
<h1 id="Analog_And_Digital_Signals"><a class="header-anchor" href="#Analog_And_Digital_Signals">#</a>Analog And Digital Signals</h1>
<p>数据通信由两种信息组成，模拟信息或数字信息。模拟信号是由一个连续变化的函数构成，而数字信号则是跳跃变换的，在某个时间点会从一个强度突然跳跃至另一个强度。下图为模拟信号和数字信号的图解，左为模拟信号，右为数字信号：</p>
<p><img src="/ch_06_information_sources_and_signals/2019-11-28-09-30-33.png" alt="模拟信号与数字信号"></p>
<h1 id="Periodic_And_Aperiodic_Signals"><a class="header-anchor" href="#Periodic_And_Aperiodic_Signals">#</a>Periodic And Aperiodic Signals</h1>
<p>信号也可分类为周期信号与非周期信号。周期信号顾名思义表示信号会重复出现，反之为非周期信号。下图为周期信号：</p>
<p><img src="/ch_06_information_sources_and_signals/2019-11-28-09-33-10.png" alt="周期信号"></p>
<h1 id="Sine_Waves_And_Signal_Characteristics"><a class="header-anchor" href="#Sine_Waves_And_Signal_Characteristics">#</a>Sine Waves And Signal Characteristics</h1>
<p>数据通信通常使用 <code>Sin函数</code> 来表示信号。之所以选择 Sin 函数，是因为许多自然界产生的信号强度与时间的函数都是 Sin，如麦克风获取声音后的输出信号，电磁波的信号等。</p>
<p>Sin 函数波的信号特性由四个部分组成：</p>
<ol>
<li>频率（Frequency）：单位时间（通常是秒）内震动出现的个数。单位为赫兹（Hertz,Hz）</li>
<li>波幅（Amplitude）：信号最强和最弱两处的差</li>
<li>相位（Phase）：Sin 拨开始的地方与参考时间（一般是时间 0）的偏移</li>
<li>波长（Wavelength）：一个周期的波在传播媒介中要传播的距离。</li>
</ol>
<p>其中波长是一个媒介相关的特性，与波在媒介中传播的速度相关。剩下的三个特性都可以用数学公式表示，如波$A\sin (\omega t+\phi)$，其中$A$表示波幅，$\phi$表示相位，$\omega$表示频率，当$\omega=2\pi$时表示频率为 1。</p>
<p>数据通信用的波一般都是高频的，一秒内出现百万个循环，对于这种频率的波，通常用兆赫兹（Megahertz,MHz）来表示。高频率波的单位如下表显示：</p>
<p><img src="/ch_06_information_sources_and_signals/2019-11-28-09-53-47.png" alt="频率单位"></p>
<h1 id="Composite_Signals"><a class="header-anchor" href="#Composite_Signals">#</a>Composite Signals</h1>
<p>之前图中的波称为<code>简单信号(Simple Signal)</code>，因为只是以单一的 Sin 波组成。但在实际中，多数信号都是以<code>组合信号（Composite Signal）</code>的形式出现。如下图所示，就是两个不同频率及振幅的波组合成一个新的波。</p>
<p><img src="/ch_06_information_sources_and_signals/2019-11-28-09-57-46.png" alt="组合波"></p>
<h1 id="The_Importance_of_Composite_Signals_And_Sine_Functions"><a class="header-anchor" href="#The_Importance_of_Composite_Signals_And_Sine_Functions">#</a>The Importance of Composite Signals And Sine Functions</h1>
<p><code>调制（Modulation）</code>出来的信号通常是组合信号。数学家<code>傅里叶(Fourier)</code>发现可以从组合信号中解析出他的组成部分，即简单信号。大部分的通信系统都是用组合信号来携带信息，在接收端再将信息拆分成简单信号。</p>
<h1 id="Time_And_Frequency_Domain_Representations"><a class="header-anchor" href="#Time_And_Frequency_Domain_Representations">#</a>Time And Frequency Domain Representations</h1>
<p>之前的所有信号波的图片的 $X轴$ 都是时间，称为信号在<code>时域(Time Domain)</code>内表示。</p>
<p>还有一种表现方式是信号在<code>频域(Frequency Domain)</code>内的表示，如之前 $\sin (2\pi t)$ 和 $0.5\times \sin(2\pi 2 t)$ 组成的复合信号，也用下图在频域中表示：</p>
<p><img src="/ch_06_information_sources_and_signals/2019-11-28-10-29-27.png" alt="频域表示"></p>
<p>图中的 $x轴$ 为频率，$y$ 轴仍为波幅。可以看到在频率为 $1$ 和 $2$ 的地方有波形出现，正好对应函数 $\sin (2\pi t)$ 和 $0.5\times \sin(2\pi 2 t)$ 的频率，波形的振幅也与函数所表现的振幅相同。</p>
<p>因为每个简单波在频域图的 $x$ 轴上只占据一点，所以频域图用来表示复合波形是简单易读的。</p>
<h1 id="Bandwidth_Of_An_Analog_Signal"><a class="header-anchor" href="#Bandwidth_Of_An_Analog_Signal">#</a>Bandwidth Of An Analog Signal</h1>
<p>在计算机网络中经常听到<code>网络带宽(Network Bandwidth)</code>一词，关于网络带宽会在之后的章节中解释，这里先介绍一个相关概念，<code>模拟带宽(Analog Bandwidth)</code>。一个模拟信号的带宽是这个信号最高频率与最低频率之间的差，单位为$Hz$。如一个信号的频域图如下图所示，那么这个信号的贷款为$4KHz$，因为这个信号的最高频率为$5KHz$，最低频率为$1KHz$。</p>
<p><img src="/ch_06_information_sources_and_signals/2019-11-28-10-39-12.png" alt="模拟带宽"></p>
<p>如果一个信号是用频域图来表示的，那么可以很快的看出这个信号的带宽。</p>
<h1 id="Digital_Signals_And_Signal_Levels"><a class="header-anchor" href="#Digital_Signals_And_Signal_Levels">#</a>Digital Signals And Signal Levels</h1>
<p>数字信号是由一系列的固定的 <code>有效电平（Valid Level）</code> 组成且在任意的时间点信号都处于这些有效电平之一。</p>
<p>一些系统用电压来表示数字信号，如电压为 $5V$ 表示信号 1，电压为 $0V$ 表示信号 0，如下图所示：</p>
<p><img src="/ch_06_information_sources_and_signals/2019-11-28-10-55-33.png" alt="电压信号1"></p>
<p>如果将电压划分更细，如电压 $5V$ 表示信号 $11$，电压 $2V$ 表示 $10$，电压 $-2V$ 表示 $01$，电压 $-5V$ 表示 $00$，如下图所示：</p>
<p><img src="/ch_06_information_sources_and_signals/2019-11-28-10-57-06.png" alt="电压信号2"></p>
<p>可以看到传输相同数据(8 bit)的情况下，第二种方法花费的时间少了一半，称第二种方法的 <code>数据速率（Data Rate）</code> 翻倍。因为第一种方法一次只能表示 1bit 的数据（1 或 0），而第二种方法表示了 2bit 的数据。如果电压细分为 $2^n$ 种，则一次性能表达 $n$ bit 的数据。</p>
<p>理论上可以将电压切分到非常小（如分割成一百万个电平等级）达到每次都能传递许多信息的目的，但是实际中因为电力系统并不能区分过小的电压间隔，所以只将电压分割为几个电平等级。</p>
<h1 id="Baud_And_Bits_Per_Second"><a class="header-anchor" href="#Baud_And_Bits_Per_Second">#</a>Baud And Bits Per Second</h1>
<p>数据速率有两方面决定，一方面是上一节中提到的信号有效电平数量（决定每次可以携带多少数据），另一方面是每个有效电平持续的时间。</p>
<p>如上一节中的例子，假设将 1 秒切分为 8 部分（即一秒电平可以变换 8 次）传递数据，一共有 2 个电平等级。那么一秒传递 8 bit 的数据。如果改为有 4 个电平等级，则每次能传递 2 个 bit,一秒传递 16 bit 的数据。如果仍然保持两个电平等级，但将一秒切分为 16 个部分，则同样一秒传递 16 bit 的数据。</p>
<p>将一秒电平可以变换的次数用波特表示(Baud)，波特数越高则一个电平持续的时间越短，如给每个电平 0.001 的持续时间，那么这个系统工作在 1000 Baud。理论上来说波特可以非常高，让每秒传递的数据增多，但是实际上当一个信号持续时间过短系统是无法检测到该信号的。每秒传递的数据量可用以下公式表示:</p>
<p>$$<br>
\text{bits per second} = baud \times \lfloor \log_2{(levels)} \rfloor<br>
$$</p>
<h1 id="Converting_A_Digital_Signal_To_Analog"><a class="header-anchor" href="#Converting_A_Digital_Signal_To_Analog">#</a>Converting A Digital Signal To Analog</h1>
<p>根据傅里叶定理，任意的波形都可以由一系列 Sin 波组成，其中每个 Sin 波都有各自的振幅，相位与频率。</p>
<p>数字信号也可以看作是一个跃变的波形，但是这样的跃变波形需要由无数个 Sin 波才能构成，所以从工程角度来说不可能实现，毕竟不可能找出无数个信源。</p>
<p>所以在实际运用中只能妥协，运用越多的 Sin 波形，最终的复合波形就越接近跃变波形。下图展示了用模拟信号来表示数字信号的过程，图（a）是数字信号，显示为跃变波形，图（b）是用一个 Sin 波来表示，图（C）是两个 Sin 波，图（d）是用三个 Sin 波。可以看到 Sin 波的数量越多，波形越接近跃变信号，而且新增的波的频率越来越高。</p>
<p>一般而言，用三个 Sin 波模拟即可。</p>
<p><img src="/ch_06_information_sources_and_signals/2019-11-28-13-45-45.png" alt="数字电路转模拟电路"></p>
<h1 id="The_Bandwidth_Of_A_Digital_Signal"><a class="header-anchor" href="#The_Bandwidth_Of_A_Digital_Signal">#</a>The Bandwidth Of A Digital Signal</h1>
<p>如之前所述，求一个信号的带宽是求其最大频率和最小频率的差值。对于数字信号来说可以先将他转换为模拟信号（多个 Sin 信号），然后找出最高频率的 Sin 以及最低频率的 Sin。但是如上节所述，数字信号的跃变波形是由无数的 Sin 组成，且 Sin 的频率越来越高，即数字信号的最高频率是无限，因此数字信号的带宽为无限。</p>
<h1 id="Synchronization_And_Agreement_About_Signals"><a class="header-anchor" href="#Synchronization_And_Agreement_About_Signals">#</a>Synchronization And Agreement About Signals</h1>
<p>在实际运用中，发送端和接收端必须保证信号的每次变换间隔是一样的（可看作采样频率），这个问题称为<code>同步问题（Synchronization）</code>，下图展示了发送端和接收端以不同的频率采样会引发的问题，接收端的采样频率（10 次每秒）高于发送端（8 次每秒）。</p>
<p><img src="/ch_06_information_sources_and_signals/2019-11-28-13-57-49.png" alt="采样错误"></p>
<p>在实际运用中，这种频率的差异可能非常小，如误差为$10_{-8}$秒，那可能出现了几百万个 Bit 后才发生一次错误。但在传输速率在亿个 Bit 每秒时，这种细微的差距也会引发大量的错误数据。</p>
<h1 id="Line_Coding"><a class="header-anchor" href="#Line_Coding">#</a>Line Coding</h1>
<p>如上节所述，在数据传递的过程中可能会因为同步问题导致一些错误的发生，有一些方法来帮助避免这些错误的发生。一种是真正发送信号前，先发送一系列的特定模式的字节，如重复的 0 或者重复的 1，通过这些字节来帮助接收端校准，另一种方法称为<code>信道编码（Line Coding）</code>，在这种方式下会添加一些额外的字符来保证接收端能确切的解析出真实的数据。</p>
<p>如一个电路能产生 5V，0，-5V 的电压，可以将 -5V  定义为一个数据的开始。因此 0 信号表示为$-5V, 0V$，1 信号表示为$-5V, 5V$。接收端知道在-5V 信号后才是真正的数据。这种方式的图解如下：</p>
<p><img src="/ch_06_information_sources_and_signals/2019-11-28-14-26-48.png" alt="信道编码例子"></p>
<p>因为信道编码引入了额外的数据来保证真实数据的准确性，所以信道编码降低了真实数据的传输速率。</p>
<h1 id="Manchester_Encoding_Used_In_Computer_Networks"><a class="header-anchor" href="#Manchester_Encoding_Used_In_Computer_Networks">#</a>Manchester Encoding Used In Computer Networks</h1>
<p><code>曼彻斯特编码(Manchester Encoding)</code>是一种信道编码，在计算机网络中曼彻斯特编码主要用于以太网中，所以十分重要。</p>
<p>对电路来说，检测信号的变化比检测信号的强度要简单。因此曼彻斯特编码将 1 信号定义为从零电压跳转为正电压，将 0 信号定义为从正电压跳转为零电压。而且曼彻斯特采样的时间为时间周期的中间，因此可以对于连续 0 或者连续 1 的情况，信号有时间可以回到之前的电压水平，保证下一次的检测正常。曼彻斯特编码的图示如下：</p>
<p><img src="/ch_06_information_sources_and_signals/2019-11-28-14-44-39.png" alt="曼彻斯特编码"></p>
<p>曼彻斯特编码还有一个变化，叫做<code>差分曼彻斯特编码（Differential Manchester Encoding）</code>，这种方法用相对变化来表示信号，0 信号表示信号发生了变化，1 信号表示信号没有变化。采样时间为时间周期点。差分曼彻斯特编码如下图所示：</p>
<p><img src="/ch_06_information_sources_and_signals/2019-11-28-14-48-53.png" alt="差分曼彻斯特编码"></p>
<p>差分曼彻斯特编码的好处在于，即使信号的大小意外的翻转了也不会发生错误（如 5V 变为-5V 之类）。</p>
<h1 id="Converting_An_Analog_Signal_To_Digital"><a class="header-anchor" href="#Converting_An_Analog_Signal_To_Digital">#</a>Converting An Analog Signal To Digital</h1>
<p>模拟信号为了进一步的被处理，必须转换为数字信号。一般转换为数字信号有两种方式,一是 <code>脉冲编码调制(Pulse Code Modulation，PCM)</code>，另一种是 <code>差分调制(Delta modulation)</code></p>
<p>脉冲编码调制是以相同时间间隔去测量模拟信号，并根据模拟信号的强度，将其转换为数字信号，整个流程分为三步，如下图框出的部分所示：</p>
<p><img src="/ch_06_information_sources_and_signals/2019-11-30-21-29-15.png" alt="脉冲编码调制"></p>
<p>以相同时间间隔去测量模拟信号，即为采样，所以上图中的第一部分称为采样。有的时候为了避免采样时间点的信号突变导致的采样失真，会在相关时间点附近多采样几次，然后取平均值作为最后采样值。第二部分称为量化（Quantization），量化是根据模拟信号的强度，将其转换为一个 Int 值，如下图所示，第一个采样的数值，会被量化为 2，第二个采样的数值会被量化为 3，第三个采样的数值会被量化为 6。</p>
<p><img src="/ch_06_information_sources_and_signals/2019-11-30-21-34-25.png" alt="量化"></p>
<p>量化后的数据会被进一步编码为之后需要的数据格式（根据需求而定）。</p>
<p>差分调制的主题思想与脉冲编码调制类似，不同的是在量化阶段他不是对每个采样值进行量化，而是对当前采样值与上一个采样值的差距进行量化。这样节省了许多用来表示数据的 Bit 数，但是缺点在于一旦之前的数据出现了误差，后面的所有数据都会收到影响。</p>
<h1 id="The_Nyquist_Theorem_And_Sampling_Rate"><a class="header-anchor" href="#The_Nyquist_Theorem_And_Sampling_Rate">#</a>The Nyquist Theorem And Sampling Rate</h1>
<p>应该以怎样的采样频率进行采样是数据通信中需要考虑的问题，如果采样频率过低，那么采样出来的信号与原信号可能有较大差异，如果采样频率过高，则会产生大量的数据。</p>
<p>奈奎斯特（Nyquist Theorem）定理提出：为了避免采样失真，采样的最低频率应该是原信号最高频率的两倍。</p>
<h1 id="Nyquist_Theorem_And_Telephone_System_Transmission"><a class="header-anchor" href="#Nyquist_Theorem_And_Telephone_System_Transmission">#</a>Nyquist Theorem And Telephone System Transmission</h1>
<p>经过实验，0 到 4000HZ 的频率基本就能提供人所能接受的音频质量。因此根据奈奎斯特频率，语音信号的采样频率应该是 8000HZ，既一秒有 8000 个采样点。通话系统所用的 PCM 标准规定，每个采样信号用 8-bit 数据表示，所以每秒通话产生的数据量为：</p>
<p>$$<br>
8000 \frac{samples}{second} \times 8 \frac{bits}{sample} = 64000 \frac{bits}{second}<br>
$$</p>
<p>因此电话系统每秒传递 64000-bits 数据（64Kbps），也可见采样频率越高，可携带的数据也就越多。</p>
<h1 id="Nonlinear_Encoding"><a class="header-anchor" href="#Nonlinear_Encoding">#</a>Nonlinear Encoding</h1>
<p>当每个采样点只能用 8 个比特来表示时，线性的 PCM 编码无法很好的体现声音，因为 8 个 Bit 只能表现 256 个值，且线性表示的话，无论是非常低频或高频的部分还是人身大部分集中的部分都用了一样的采样间隔，这造成了浪费。而非线性编码，解决了这个问题，他更关注与人耳最敏感的频率。数字电话标准中有两种非线性编码：</p>
<ol>
<li>$\alpha-law$，主要是欧洲及中国采用的编码方式</li>
<li>$\mu-law$，主要是北美和日韩采用的编码方式</li>
</ol>
<p>$\mu-law$ 算法的主要优势在于它覆盖了更广的频率范围（例如可以更好的还原特别高的声音），缺点在于对于一些弱信号有更多的失真。$\alpha-law$ 在弱信号的失真上有优势，但动态范围更小。</p>
<p>对于国际电话，需要有 $\alpha-law$ 和 $\mu-law$ 之间的转化。</p>
<h1 id="Encoding_And_Data_Compression"><a class="header-anchor" href="#Encoding_And_Data_Compression">#</a>Encoding And Data Compression</h1>
<p><code>数据压缩(Data Compression)</code> 是用来减少用来表达数据的 bit 数的方法。对于数据通信来说，通常在传输前对数据进行压缩。压缩分为两种类型：<code>有损压缩(Lossy)</code>和<code>无损压缩(Lossless)</code>。</p>
<p>有损压缩则通常用来压缩一些人相关的文件，如图片，视频，音频，这种压缩方式会忽视掉一些人无法精确识别的数据，<code>JPEG</code> 和 <code>MPEG-3(MP3)</code> 都是典型的有损压缩。</p>
<p>无损压缩保证压缩后的数据在解压后与原数据相同，一般用于压缩文档之类的文件。大部分的无损压缩都用了字典技术，即如果一个字符串在文件中重复的出现，将这个字符串存放在字典中，之后的出现只要取字典中的索引值即可。</p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《Head First 设计模式》 Ch 06 命令模式</title>
    <url>/ch_06_the_command_pattern/</url>
    <content><![CDATA[<p>命令模式（Command Pattern）将一个请求封装为一个对象，进而将拥有不同的请求的物体参数化，并且还可以请求排队，打印请求日志，支持可逆操作。</p>
<p>命令模式由抽象命令类、具体命令类、接受者、调用者、客户类，五部分组成。其中接受者为被命令封装的类，调用者存放需要执行的类。</p>
<p>我们以一个远程控制装置作为例子，远程控制装置有两个按钮和一个撤回按钮。我们通过命令模式来将远程控制类与具体需要做的操作（如开灯）解耦。在例子中程序入口即为客户端，远程装置为调用者，灯为接受者，有开灯与关灯两个命令</p>
<h1 id="代码示例"><a class="header-anchor" href="#代码示例">#</a>代码示例</h1>
<h2 id="抽象命令类及实现"><a class="header-anchor" href="#抽象命令类及实现">#</a>抽象命令类及实现</h2>
<figure class="highlight cs"><figcaption><span>抽象命令类</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Command</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Execute</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Undo</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>命令类实现</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LightOffCommand</span> : <span class="title">Command</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Light light;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LightOffCommand</span>(<span class="params">Light light</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.light = light;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        light.Off();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Undo</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        light.On();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LightOnCommand</span> : <span class="title">Command</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Light light;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LightOnCommand</span>(<span class="params">Light light</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.light = light;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        light.On();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Undo</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        light.Off();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NoCommand</span> : <span class="title">Command</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;No command execute&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Undo</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;No command undo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="接受者"><a class="header-anchor" href="#接受者">#</a>接受者</h2>
<figure class="highlight cs"><figcaption><span>灯</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Light</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">On</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;The light is on&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Off</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;The light is off&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="调用者"><a class="header-anchor" href="#调用者">#</a>调用者</h2>
<figure class="highlight cs"><figcaption><span>远程控制</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">RemoteControl</span></span><br><span class="line">&#123;</span><br><span class="line">    Command[] commands;</span><br><span class="line">    Command lastCommond;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RemoteControl</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        commands = <span class="keyword">new</span> Command[<span class="number">2</span>] &#123; <span class="keyword">new</span> NoCommand(), <span class="keyword">new</span> NoCommand() &#125;;</span><br><span class="line">        lastCommond = <span class="keyword">new</span> NoCommand();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetCommand</span>(<span class="params"><span class="built_in">int</span> index, Command command</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        commands[index] = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnButtonClick</span>(<span class="params"><span class="built_in">int</span> index</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        commands[index].Execute();</span><br><span class="line">        lastCommond = commands[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnClickUndo</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        lastCommond.Undo();</span><br><span class="line">        lastCommond = <span class="keyword">new</span> NoCommand();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="客户类"><a class="header-anchor" href="#客户类">#</a>客户类</h2>
<figure class="highlight cs"><figcaption><span>函数入口</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Light light = <span class="keyword">new</span> Light();</span><br><span class="line">    RemoteControl remoteControl = <span class="keyword">new</span> RemoteControl();</span><br><span class="line">    remoteControl.SetCommand(<span class="number">0</span>, <span class="keyword">new</span> LightOnCommand(light));</span><br><span class="line">    remoteControl.SetCommand(<span class="number">1</span>, <span class="keyword">new</span> LightOffCommand(light));</span><br><span class="line">    remoteControl.OnButtonClick(<span class="number">0</span>);</span><br><span class="line">    remoteControl.OnButtonClick(<span class="number">1</span>);</span><br><span class="line">    remoteControl.OnClickUndo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="测试及结果"><a class="header-anchor" href="#测试及结果">#</a>测试及结果</h1>
<p>运行结果：</p>
<p><img src="/ch_06_the_command_pattern/2019-02-02-23-26-25.png" alt="命令模式测试结果"></p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>《Computer Networks and Internets》 Ch 05 信息传输概览</title>
    <url>/ch_05_overview_of_data_communications/</url>
    <content><![CDATA[<h1 id="Introduction"><a class="header-anchor" href="#Introduction">#</a>Introduction</h1>
<p>这一章主要是分析通过物理媒介进行信息传递的方法，例如线，光和无线电波等。这些方式在一些细节上不同，但所有方法的基本原理是相通的。</p>
<h1 id="The_Essence_Of_Data_Communications"><a class="header-anchor" href="#The_Essence_Of_Data_Communications">#</a>The Essence Of Data Communications</h1>
<p>数据通信是物理，数学和电气工程三个学科的混合领域。</p>
<ol>
<li>物理：信息的传输依赖于物理媒介</li>
<li>数学：信息需要数字化</li>
<li>电气工程：数据传输需要构建现实中的通信系统</li>
</ol>
<h1 id="Motivation_And_Scope_Of_The_Subject"><a class="header-anchor" href="#Motivation_And_Scope_Of_The_Subject">#</a>Motivation And Scope Of The Subject</h1>
<p>在数据通信领域有三个重要的点，他们定义了数据通信的一些领域</p>
<ol>
<li>
<p>传输的数据可以是任意类型的</p>
<p>传输的数据并不一定是存储在计算机中的<code>bit</code>数据，也可以是从现实世界中获取的信息，如音频和视频。</p>
</li>
<li>
<p>数据的传输依赖于物理系统</p>
<p>数据是基于物理现象来传输的，例如电，电磁波。了解为什么这些物理现象可以被用来传输数据是很重要的。另外也需要理解物理系统的限制，因为这些限制引发的问题和这些问题如何被检测并解决。</p>
</li>
<li>
<p>多个来源的信息可以共享基础媒介来传输</p>
<p>媒介共享在计算机网络中是一个重要角色。了解哪些基础设施是可以被共享的，共享他们的优缺点，以及基于共享而设计的通信模型是很重要的。</p>
</li>
</ol>
<h1 id="The_Conceptual_Pieces_Of_A_Communications_System"><a class="header-anchor" href="#The_Conceptual_Pieces_Of_A_Communications_System">#</a>The Conceptual Pieces Of A Communications System</h1>
<p>每一个来源都需要一些方法来获取信息，调整信息为用于传播的模式，使用共享的物理媒介来传输信息。同时也需要一些方法从物理媒介中抽取出每条信息的目的地地址，并将信息传送给目标地址。整个过程如下图所示：</p>
<p><img src="/ch_05_overview_of_data_communications/2019-11-25-23-24-24.png" alt="数据通信简单模型"></p>
<p>上图是一个非常简化的模型，在实际操作中，在传输数据前，必须对数据进行数字化，也需要加入一些额外的信息防止错误发生。如果考虑到隐私，可能还需要进行加密。在使用共享媒介时，还要保证有方法可以分辨出每条信息且他们不会相互干扰。</p>
<p>为了解释数据通信的每个部分，工程师们制订了一个概念框架来说明通信系统中的每个小主题是如何联系在一起的，概念框架如下图所示：</p>
<p><img src="/ch_05_overview_of_data_communications/2019-11-25-23-28-26.png" alt="概念框架"></p>
<h1 id="The_Subtopics_Of_Data_Communications"><a class="header-anchor" href="#The_Subtopics_Of_Data_Communications">#</a>The Subtopics Of Data Communications</h1>
<p>上一节中的概念框架图中的每一部分都代表了数据通信中的一个小主题。这一节中简单介绍了图中的一些术语，之后的几章中会在对每一部分进行详细说。</p>
<ol>
<li>
<p><code>数据来源(Information Sources)</code>可以是模拟数据或者数字电路。这一部分的关键内容包括信号的特征（<code>振幅(Amplitude)</code>，<code>频率(Frequency)</code>，<code>相位(Phase)</code>），周期性与非周期性，以及模拟信息和数字信息的转换。</p>
</li>
<li>
<p><code>信源编码与解码(Source Encoder and Decoder)</code>。一旦信息被数字化后，信息就可以被转换，这一部分的关键内容包括数据压缩以及压缩后对于传输的影响</p>
</li>
<li>
<p><code>加密与解密(Encryptor and Decryptor)</code>。为了保护信息和保证其可信度，在信息传送前需要进行加密，在接收后需要解密。这一部分的关键内容包括密码学技术与算法。</p>
</li>
<li>
<p><code>信道编码与解码(Channel Encoder and Decoder)</code>。信道编码是用来检测也纠正传输错误。这一部分的关键内容包括检测和限制错误，以及实际应用的技术，如奇偶校验(parity checking)等。</p>
</li>
<li>
<p><code>复用与解复用(Multiplexor and Demultiplexor)</code>。复用是指让多个来源的信息结合在一起并保证可以使用同一个媒介传输的方式。这一部分的关键内容包括介绍同时复用以及分时复用的技术。</p>
</li>
<li>
<p><code>调制与解调(Modulator and Demodulator)</code>。调制是指让用电磁波传递信息的方式。这一部分的关键内容包括模拟信息与数字信息的调制方式，用来进行调制与解调的设备。</p>
</li>
<li>
<p><code>物理通道与传输(Physical Channel and Transmission)</code>。 这一部分的关键内容包括传输媒介与传输方式（如并行，串行），带宽，噪声，干扰，信道容量，</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《Computer Networks and Internets》 Ch 07 传播媒介</title>
    <url>/ch_07_transmission_media/</url>
    <content><![CDATA[<h1 id="Introduction"><a class="header-anchor" href="#Introduction">#</a>Introduction</h1>
<p>这一章将会给出传播媒介的分类，介绍电信号，无线信号，光信号各自的传输特征。在本章节的最后，介绍了奈奎斯特定律和香农理论，分别给出了理想情况和实际情况下最大的信息传输率。</p>
<h1 id="Guided_And_Unguided_Transmission"><a class="header-anchor" href="#Guided_And_Unguided_Transmission">#</a>Guided And Unguided Transmission</h1>
<p>有两种重要的将传输媒介分类的方法：</p>
<ol>
<li>
<p>按传播路径：使用 <code>有向（Guided）</code> 和 <code>无向（Unguided）</code> 来描述传播路径。像铜线和光纤这种提供特定路径的方式称为有向。而像无线电这样的传输称为无向。工程师会通俗的将这两种称为<code>有线(wired)</code>和<code>无线(wireless)</code>，因此光纤也算在有线的范畴。</p>
</li>
<li>
<p>按能的形式：分为三种类型，在线缆上的 <code>电信号（Electrical Energy）</code>，无线上使用的 <code>无线电（Radio）</code>和光纤中使用的 <code>光（Light）</code>。</p>
</li>
</ol>
<h2 id="Taxonomy_By_Forms_Of_Energy"><a class="header-anchor" href="#Taxonomy_By_Forms_Of_Energy">#</a>Taxonomy By Forms Of Energy</h2>
<p>下图展示了按能的形式分类的图，这个分类图也不是完美的，例如在无线电部分分为<code>陆地无线电（Terrestrial Radio）</code>和<code>卫星无线电（Satellite）</code>，但实际上太空空间站的无线电部分两者都不符合。</p>
<p><img src="/ch_07_transmission_media/2019-12-01-15-46-54.png" alt="能力形式分类"></p>
<h1 id="Background_Radiation_And_Electrical_Noise"><a class="header-anchor" href="#Background_Radiation_And_Electrical_Noise">#</a>Background Radiation And Electrical Noise</h1>
<p>所有用电信号传输的电路都需要两根线，一根用来将信号传递给接收方，一根用来将反馈还给发送方。最简单的电传输方式就是使用两根铜线，每根线都用塑料包裹住，来防止相互之间的电干扰，在两根线外还有一层整个包裹起来，为了人方便使用。</p>
<p>但在线缆形式下有许多改进，这主要是因为电信号有以下特征：</p>
<ol>
<li>环境中有随机的电磁辐射，称为<code>噪音（Noise）</code>，如霓虹灯和电机就会发出随机的辐射。一般来说通信系统在正常运行状态下就会产生少量的噪音。</li>
<li>当电磁辐射遇到金属会被吸收进而产生细微的信号，这些信号会对正常的信号造成干扰。</li>
<li>正因为金属能吸收电磁辐射，所以可以用足够的金属放在噪声源和通信系统间，将其作为<code>防护（Shield）</code>。</li>
</ol>
<h2 id="Twisted_Pair_Copper_Wiring"><a class="header-anchor" href="#Twisted_Pair_Copper_Wiring">#</a>Twisted Pair Copper Wiring</h2>
<p>有三种形式的电缆可以减少电磁噪音的干扰：</p>
<ol>
<li>非屏蔽双绞线（Unshielded Twisted Pair, UTP）</li>
<li>同轴电缆（Coaxial cable）</li>
<li>屏蔽双绞线（Shielded Twisted Pair, STP）</li>
</ol>
<p>第一个形式，非屏蔽双绞线在通信中被广泛应用。如名字一样，双绞线是将两根铜线缠绕在一起的形式，这种相互缠绕的形式比两根线平行排布有更好的抗干扰性。如下图所示，（a）为平行排列，蓝线更接近辐射源，于是它相对于灰线吸收了更多的能量，而在（b）图的缠绕形式中，两根线都各有一部分更靠近辐射源，所以整体来说，两者收到的能量是相同的。</p>
<p><img src="/ch_07_transmission_media/2019-12-01-15-06-05.png" alt="双绞线"></p>
<h3 id="Shielding_Coaxial_Cable_And_Shielded_Twisted_Pair"><a class="header-anchor" href="#Shielding_Coaxial_Cable_And_Shielded_Twisted_Pair">#</a>Shielding: Coaxial Cable And Shielded Twisted Pair</h3>
<p>因为非屏蔽双绞线只是让两根线吸收了相同的能量，但噪音还是被吸收了，所以在一些情况下，非屏蔽双绞线仍然会产生问题，如有特别强的电噪音环境，或者特别接近噪声源，或者通信系统中的信号频率很高（频率越高对噪音越敏感）。为了解决这些问题，只能尽量的屏蔽噪声。</p>
<p>一种方法就是<code>同轴电缆（Coaxial Cable）</code>，它在线材的外层增加了一层<code>编织金属屏蔽(Braided metal shield)</code>（如网状）。使用编织样的金属层而非一整块金属层主要是处于便携性的考虑（后者的屏蔽性更好），但相对于非屏蔽双绞线，同轴电缆的便携性还是差的。如电视的信号线，一般都是同轴电缆，同轴电缆如下图所示：</p>
<p><img src="/ch_07_transmission_media/2019-12-01-15-19-14.png" alt="同轴电缆"></p>
<p>屏蔽双绞线则是非屏蔽双绞线和同轴电缆的混合，是两者形式的折中，他在一对或多对双绞线的外层使用了更薄的金属屏蔽层，很多情况下用铝来作为金属屏蔽层（铝更软）。</p>
<p>如之前节所述，为了避免铜线间的电干扰，铜线外层会包裹一层塑料。双绞线是将两个两个包裹着塑料的铜线绞在一起，同轴电缆则是在一根包裹住塑料的导线外包裹金属屏蔽层，屏蔽双绞线是在两根包裹着塑料的铜线绞在一起后再包裹较薄的金属层。</p>
<h3 id="Categories_Of_Twisted_Pair_Cable"><a class="header-anchor" href="#Categories_Of_Twisted_Pair_Cable">#</a>Categories Of Twisted Pair Cable</h3>
<p>一些标准机构为用于计算机网络的双绞线定义了标准，这些机构包括 <code>美国国家标准组织（American National Standards Institute，ANSI）</code>，<code>通信产业联合（Telecommunications Industry Association，TIA）</code>，<code>电子产业联合（Electronic Industries Alliance，EIA）</code>，下图为主要分类：</p>
<p><img src="/ch_07_transmission_media/2019-12-01-15-45-39.png" alt="双绞线分类"></p>
<h1 id="Media_Using_Light_Energy_And_Optical_Fibers"><a class="header-anchor" href="#Media_Using_Light_Energy_And_Optical_Fibers">#</a>Media Using Light Energy And Optical Fibers</h1>
<p>有三种形式的媒介是用光能携带数据的：<code>光纤（Optical Fibers）</code>，<code>红外线传输（Infrared transmission）</code>，<code>点对点激光（Point to Point lasers）</code>。</p>
<h2 id="Optical_Fibers"><a class="header-anchor" href="#Optical_Fibers">#</a>Optical Fibers</h2>
<p>其中最重要的类型是光纤：</p>
<ol>
<li>每根光纤都是一根包裹在塑料外层中的细玻璃线或者透明塑料。</li>
<li>光纤是用于单项传播的。在光纤的一段是一个激光或者 LED，用来发射光，另一端是连接一个感光设备用来检测光。如果数据需要双向传播，则需要用到两根光纤。多根光纤用塑料封壳包裹在一起生成光纤电缆。</li>
</ol>
<p>光纤无法被弯折成直角，但光纤仍然可以弯曲，甚至可以弯曲成一个直径小于 2 英寸的圆，让光纤在弯折状态下仍然可以正常工作，主要是因为光的传播特性。</p>
<p>光从一个低密度物质照射入另一个高密度物质，随着入射的角度不同，光的反应也会不同。存在一个特定的角度，当光以这个角度入射时，光会随着两个物质的交界处传播。当光的入射角大于这个角度时，光会被反射。当光的入射角小于这个角度时，光会发生折射。如下图所示：</p>
<p><img src="/ch_07_transmission_media/2019-12-03-08-31-03.png" alt="光的反射"></p>
<p>光纤运用的是光的反射，有一个特殊的镀层（Cladding）与光纤共同形成一个边界，在传输过程中，光会在上下两个边界内反射前进。</p>
<p>但反射的过程中是存在能量损耗的，而且因为光的反射，光传播的路径是比光的直线传播要长的，因此光在光纤一段发射后，抵达另一端时能量会更低，而且会更分散（Dispersed），如下图所示：</p>
<p><img src="/ch_07_transmission_media/2019-12-03-08-36-42.png" alt="光分散"></p>
<p>上图中，因为接受时的能量更低，所以 Y 轴值更低，且因为能量更分散，所以接受的时间也会拖长，因此在 X 轴上如同被拉伸。</p>
<h3 id="Types_Of_Fiber_And_Light_Transmission"><a class="header-anchor" href="#Types_Of_Fiber_And_Light_Transmission">#</a>Types Of Fiber And Light Transmission</h3>
<p>因为光在传输中的反射导致的分散在长距离使用光纤时会成为严重问题，因此有三个种类的光纤，不同的在性能与价格上权衡，</p>
<ol>
<li>跃变型多模光纤（Multimode，step index fiber）：这种类型的光纤，光纤与镀层中的边界很陡峭，因此光会在边界内频繁的反射，造成大量的能量分散，但是这种光纤价格最便宜。</li>
<li>渐变型多模光纤（Multimode，graded index fiber）：这种类型比跃变型多模稍贵，但是能减少反射进而有更少的能量分散。</li>
<li>单模光纤（Single mode fiber）：这种类型的光纤最贵，但也有最低能量分散。通常用于长距离传输和高比特率的传输。</li>
</ol>
<p>如之前节所述光纤的一端会用来发射光，另一端会用来接收光。在发射端，可以通过<code>发光二极管（Light Emitting Diode，LED）</code>，或者<code>激光二极管（Injection Laser Diode，ILD）</code>。在 接收端可以用<code>感光细胞（Phote-sensitive）</code>或者<code>光敏二极管（Photodiode）</code>。</p>
<h3 id="Optical_Fiber_Compared_To_Copper_Wiring"><a class="header-anchor" href="#Optical_Fiber_Compared_To_Copper_Wiring">#</a>Optical Fiber Compared To Copper Wiring</h3>
<p>光纤的优势：</p>
<ol>
<li>对电噪音免疫</li>
<li>更少的衰减（相对于铜线而言）</li>
<li>更高的带宽</li>
</ol>
<p>铜线的优势：</p>
<ol>
<li>更低的价格</li>
<li>更少的设备要求（光纤的接收端必须被有效的抛光）</li>
<li>更不易被损坏</li>
</ol>
<h2 id="Infrared_Communication_Technologies"><a class="header-anchor" href="#Infrared_Communication_Technologies">#</a>Infrared Communication Technologies</h2>
<p><code>红外线通信（Infrared Communication）</code>也是光能通信的一种，也是点对点技术的一种,电视遥控机就是红外线通信的应用。红外线的频率在人眼可见光的范围外，但是红外线仍然表现的如同可见光，它会很快的消散，可以在坚硬光滑表面反射，会被不透明物体阻挡，薄如纸片的物体会阻挡信号，甚至大气中的水气都会阻碍信号。</p>
<p>因此红外线通信适用于室内使用，适用于距离短且无阻挡的通信。</p>
<p>下图是三种红外线通信的常见技术：</p>
<p><img src="/ch_07_transmission_media/2019-12-03-09-54-25.png" alt="红外线通信技术"></p>
<h2 id="Point_To_Point_Laser_Communication"><a class="header-anchor" href="#Point_To_Point_Laser_Communication">#</a>Point-To-Point Laser Communication</h2>
<p><code>激光通信（Laser Communication）</code>是另一种点对点通信，如红外线通信一样，激光通信也需要一个无阻挡的路径。</p>
<p>但与红外线通信不同的是，激光通信只能覆盖很小的一片区域，激光的宽度通常只有几厘米（这里是宽度，并不是指长度），也正是因为激光的宽度很窄，所以激光传输的接收条件是比较苛刻的，通常是被永久的固定安装。</p>
<p>激光通信的典型应用是楼与楼之间的信号传输，通常在相邻大楼的外墙或者顶楼安装部署用于激光通信的发射和接收装置。</p>
<h1 id="Electromagnetic_Radio_Communication"><a class="header-anchor" href="#Electromagnetic_Radio_Communication">#</a>Electromagnetic(Radio) Communication</h1>
<p>常用 <code>无向性（unguided）</code> 来描述不需要任何介质来传播能量的通信方式。在计算机网络中最常用的依赖于电磁能的无向性技术是无线电传播（Radio Frequency Transmission）。无线电传播相较于光传播有个显著的优势，即可以长距离传播且可穿透阻碍物。</p>
<p>电磁能的使用依赖于他的频率属性，常用<code>波谱（Spectrum）</code>来描述可能的频率范围。全球的各政府分配不同频率的使用权，例如在美国是 <code>联邦通信委员会（Federal Communications Commission）</code>。下图是主要的能量频率波谱，其中无线电的范围基本是 $3KHZ$ 到 $300GHZ$。</p>
<p><img src="/ch_07_transmission_media/2019-12-03-14-44-01.png" alt="波谱"></p>
<h2 id="Signal_Propagation"><a class="header-anchor" href="#Signal_Propagation">#</a>Signal Propagation</h2>
<p>电磁波的频率也决定它传播时的特性，下表是波传播的三大类型：</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>频率范围</th>
<th>传播类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>低频</td>
<td>&lt; 2 MHZ</td>
<td>沿地球表面传输，可能会被地形阻挡</td>
</tr>
<tr>
<td>中频</td>
<td>2 到 30 MHZ</td>
<td>在大气层中反射传播，尤其是在电离层</td>
</tr>
<tr>
<td>高频</td>
<td>&gt;30 MHZ</td>
<td>直线传播，会被障碍物阻挡</td>
</tr>
</tbody>
</table>
<p>无线技术也可被分为以下两类：</p>
<ol>
<li>地表（Terrestrial）：依赖相对贴近地表的设备通信，例如无线电发射器和微博发射器。这些设备一般安装在山顶，人造塔或建筑上。</li>
<li>非地表（Nonterrestrial）：依赖于大气层外的设备，例如轨道卫星</li>
</ol>
<h2 id="Types_Of_Satellites"><a class="header-anchor" href="#Types_Of_Satellites">#</a>Types Of Satellites</h2>
<p>通信卫星可以根据距离地表的距离分为三类：</p>
<ol>
<li><code>近地轨道卫星（Low Earth Orbit,LEO）</code>：</li>
</ol>
<p>有低延迟的优点，但是与地球的相对位置变化的较快，接收端需要追踪卫星。</p>
<ol start="2">
<li><code>中地球轨道卫星（Medium Earth Orbit,MEO）</code>：</li>
</ol>
<p>为地球南北极提供信号的椭圆轨道卫星。</p>
<ol start="3">
<li><code>对地静止轨道卫星（Geostationary Earth Orbit,GEO）</code>：</li>
</ol>
<p>与地面可以保持固定角度，缺点是离地球较远，延迟大。</p>
<h3 id="Geostationary_Earth_Orbit_GEO_Satellites"><a class="header-anchor" href="#Geostationary_Earth_Orbit_GEO_Satellites">#</a>Geostationary Earth Orbit(GEO) Satellites</h3>
<p>从上节对于通信卫星的描述可以看出，通信卫星的权衡主要是在延迟和与轨道周期的权衡（轨道周期与地球自转相差越远，追踪卫星越难）。</p>
<p>这里以<code>对地静止轨道卫星（Geostationary Earth Orbit,GEO）</code>为例，对地静止轨道卫星的距离地表距离约为 35805 千米，计算过程如下：</p>
<p>因为卫星保持在轨道上，所以离心力与万有引力相等，即</p>
<p>$$<br>
{\omega}^2mr=\frac{GMm}{r^2}<br>
$$</p>
<p>化简为：<br>
$$<br>
r^3=\frac{GM}{w^2}<br>
$$</p>
<p>其中，G 是万有引力常数为 $6.67\times 10^-20 {km}^3/kg\cdot {s^2}$，M 是地球质量为 $5.976\times 10^{24} kg$，$\omega$ 为角速度，如果要求对地静止，即角速度与地球自转相同，即：<br>
$$<br>
\omega = \frac{2\pi}{3600*24}=7.29\times10^{-5} rad/s<br>
$$</p>
<p>都代入上式，求得 $r=42172 km$，减去地球半径 6376km，得对地静止轨道卫星的距离地表距离约为35805 千米。</p>
<p>卫星距离如果不足这个数值，其旋转速度就会比地球快，在这个距离下，卫星与地表以相同的速度转动，所以地表上的卫星追踪装置在追踪到卫星后就不需要再次运动，因为两者的角度不会发生变化。但对地静止轨道卫星的最大缺陷是信号的延迟，信号的速度以光速计算，信号的一次来回需要：</p>
<p>$$<br>
2\times \frac{35.8\times 10^6 \text{ meters}}{3\times 10^8 \text{meters/sec}}=0.238 sec<br>
$$</p>
<p>0.2 秒的延迟在许多领域上是无法被接受的。</p>
<h2 id="GEO_Coverage_Of_The_Earth"><a class="header-anchor" href="#GEO_Coverage_Of_The_Earth">#</a>GEO Coverage Of The Earth</h2>
<p>在对地静止轨道上的卫星数量是由限制的。为了避免星号键的相互干扰，卫星与卫星间必须有间隔，间隔的大小与信号的强度相关，但通常而言是 4-8 度，因为整个轨道是 360 度，所以对地静止轨道上最多有 45-90 颗卫星。</p>
<p>最少则需要三颗卫星来覆盖整个地球，如下图所示：</p>
<p><img src="/ch_07_transmission_media/2019-12-03-15-52-33.png" alt="最少三颗卫星"></p>
<p>证明如下，首先根据透视原理，距离一个球体越近，能看到球体的部分越少。在距离球体无限远的距离，最多也只能看到球体的 50%，如下图所示：</p>
<p><img src="/ch_07_transmission_media/2019-12-03-16-17-36.png" alt="透视原理"></p>
<p>将能看到球体的百分比设为 X，离球体的距离设为 d，求的半径设为 R，表达式为：</p>
<p>$$<br>
X=\frac{50%}{1+\frac{R}{d}}<br>
$$</p>
<p>式子是由等比三角形得出的，如下图：</p>
<p><img src="/ch_07_transmission_media/2019-12-03-16-23-46.png" alt="等比证明"></p>
<p>将地球半径 6376KM 及对地静止轨道距离 35805KM 代入，得能看到的范围是约为 42.45%，所以最少需要三颗卫星才能覆盖地球。</p>
<h2 id="Low_Earth_Orbit_LEO_Satellites_And_Clusters"><a class="header-anchor" href="#Low_Earth_Orbit_LEO_Satellites_And_Clusters">#</a>Low Earth Orbit(LEO) Satellites And Clusters</h2>
<p>近地轨道卫星的高度最多为 2000 千米，其主要的缺点在于无法与地面保持相同速度，因此地面上的天线必须旋转来追踪卫星。最低的近地轨道卫星在大约 90 分钟就可以环绕一遍地球，移动速度还是将对较快的，因此对于地面天线来说追踪有一定难度。</p>
<p>通常的解决方式是用卫星群（Clustering）或者阵列部署（Array Deployment）的卫星来解决追踪问题。一系列卫星一同工作来覆盖较大的区域。</p>
<p>如一条信息需要从欧洲传到北美，欧洲的地面基站向此时他上方的卫星发送数据，上方的卫星将信息在卫星群之间传播，一直传送到北美上方的卫星，北美上方的卫星再将信息传送给北美的地面基站。</p>
<h1 id="Tradeoffs_Among_Media_Types"><a class="header-anchor" href="#Tradeoffs_Among_Media_Types">#</a>Tradeoffs Among Media Types</h1>
<p>通信媒介的选择是复杂的，通常需要从以下几个方面权衡：</p>
<ol>
<li>花费（Cost）：材料，安装，操作，维护等的开销</li>
<li>数据速率（Data rate）：每秒可以传送多少数据</li>
<li>延迟（Delay）：数据传播和处理的延迟</li>
<li>信号影响（Affect on signal）：信号是否会衰减和失真</li>
<li>环境（Environment）：对干扰的敏感性和电子噪音</li>
<li>安全性（Security）：是否容易被窃听</li>
</ol>
<h1 id="Measuring_Transmission_Media"><a class="header-anchor" href="#Measuring_Transmission_Media">#</a>Measuring Transmission Media</h1>
<p>可以从两个方面来评判传输媒介：<code>传播延迟（Progagation Delay）</code>和<code>信道容量（Channel Capacity）</code>。</p>
<p><code>奈奎斯特第一准则（Nyquist Theorem）</code> 表明在理想低通信道下的最高码元速率速率是带宽的 2 倍。假设有 K 个电平，则一个码元能传输的 bit 数为 $log_2K$ ，B 表示信道的带宽，因此数据速率可以表达为：</p>
<p>$$<br>
D=2Blog_2K \text{ bits /s}<br>
$$</p>
<p>下面证明奈奎斯特准则：</p>
<p>一个有限带宽的低通滤波器，如果其截至频率为 $\omega_g$ 其频域图如下：</p>
<p><img src="/ch_07_transmission_media/2019-12-03-17-06-01.png" alt="低通滤波器频域"></p>
<p>该滤波器的时域相应图为：</p>
<p><img src="/ch_07_transmission_media/2019-12-03-17-07-06.png" alt="低通滤波器时域"></p>
<p>时域的相应波形时一个拖尾的连续信号，这个拖尾会干扰后续信号。但是从波形上可以看出，在$t=\frac{\pi}{\omega_s},\frac{2pi}{\omega_s}…$处是 0，所以如果在这些间隔点发送码元，则不会被干扰。这些点的间隔时间为$T_s=\frac{\pi}{\omega_s}=\frac{1}{2f_m}$，所以码元速率为$R=\frac{1}{T_s}=2f_m$</p>
<h2 id="The_Effect_of_Noise_On_Communication"><a class="header-anchor" href="#The_Effect_of_Noise_On_Communication">#</a>The Effect of Noise On Communication</h2>
<p>奈奎斯特定理提供了了理论上的最高码元速率，因为他并没有将噪音纳入考虑， 而实际中噪音不可避免。香农在此基础上给出了考虑噪音的数据速率，称为香农定理（Shannon’s Theorem）：</p>
<p>$$<br>
C=B\log_2(1+S/N) bits/s<br>
$$</p>
<p>其中 $S/N$ 称为信噪比，式子中并没有给出电平数量 K，这是因为实际上在考虑噪声时，电平数量是受噪声影响的，噪声越大，为了避免干扰，电平的间隔就只能越大，因此电平数量就越少。</p>
<h2 id="The_Significance_Of_Channel_Capacity"><a class="header-anchor" href="#The_Significance_Of_Channel_Capacity">#</a>The Significance Of Channel Capacity</h2>
<p>奈奎斯特定律鼓励工程师探索更高效的编码方式，因为在最高码元速率受信道带宽限制时，编码方式越高效，一个码元携带的数据就越多，单位时间内就能传输更多的比特。</p>
<p>香农定理给出了真实环境下，数据速率的上限，即无论编码多么高效，在非理想环境（有噪声）下，每秒最大的比特传输量</p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《Head First 设计模式》 Ch 07 适配器模式和外观模式</title>
    <url>/ch_07_the_adapter_and_facade_patterns/</url>
    <content><![CDATA[<h1 id="适配器模式"><a class="header-anchor" href="#适配器模式">#</a>适配器模式</h1>
<p>适配器模式（Adapter Pattern）将一个类的接口转换为用户想要的另一个接口。适配器模式将原先因为接口不兼容的一些类可以一起工作。</p>
<p>例如我们有已经实现的火鸡类和鸭子类，其中鸭子的鸣叫我们使用<code>Quack</code>，火鸡的鸣叫我们用<code>Goggle</code>，两个接口不相同，但在某些情况下，我们不希望具体区分是火鸡还是鸭子，只希望他们都能叫，这时候就需要用适配器模式，将火鸡或鸭子伪装成同一个类。</p>
<h2 id="代码示例"><a class="header-anchor" href="#代码示例">#</a>代码示例</h2>
<h3 id="鸭子及火鸡抽象接口及实现"><a class="header-anchor" href="#鸭子及火鸡抽象接口及实现">#</a>鸭子及火鸡抽象接口及实现</h3>
<figure class="highlight cs"><figcaption><span>鸭子接口</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Duck</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Quack</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Fly</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>鸭子实现</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MallardDuck</span> : <span class="title">Duck</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fly</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;MallardDuck Fly&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Quack</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;MallardDuck Quack&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>火鸡接口</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Turkey</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Gobble</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Fly</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>火鸡实现</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WildTurkey</span> : <span class="title">Turkey</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fly</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;WildTurkey Fly&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Gobble</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;WildTurkey Gobble&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="适配器类"><a class="header-anchor" href="#适配器类">#</a>适配器类</h3>
<figure class="highlight cs"><figcaption><span>火鸡适配器</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TurkeyAdapter</span> : <span class="title">Duck</span></span><br><span class="line">&#123;</span><br><span class="line">    Turkey turkey;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TurkeyAdapter</span>(<span class="params">Turkey turkey</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.turkey = turkey;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fly</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i != <span class="number">5</span>; ++i)</span><br><span class="line">            turkey.Fly();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Quack</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        turkey.Gobble();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试代码及结果"><a class="header-anchor" href="#测试代码及结果">#</a>测试代码及结果</h2>
<figure class="highlight cs"><figcaption><span>测试代码</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    MallardDuck duck = <span class="keyword">new</span> MallardDuck();</span><br><span class="line">    WildTurkey turkey = <span class="keyword">new</span> WildTurkey();</span><br><span class="line">    TestDuck(duck);</span><br><span class="line">    TestDuck(<span class="keyword">new</span> TurkeyAdapter(turkey));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">TestDuck</span>(<span class="params">Duck duck</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    duck.Fly();</span><br><span class="line">    duck.Quack();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/ch_07_the_adapter_and_facade_patterns/2019-02-03-00-10-27.png" alt="适配器模式运行结果"></p>
<h1 id="外观模式"><a class="header-anchor" href="#外观模式">#</a>外观模式</h1>
<p>外观模式(Facade Pattern)为子系统的一系列接口提供了一个统一的，更高级别的接口以简化外部的调用。</p>
<p>外观模式实际上是遵从于<code>最小知识原则</code>，对一些上层的类来说，它不需要了解下面子系统的具体构成，那么我们就用一个中间层（Facade）来将封装这些子系统，形成一个软解耦。</p>
<p>例如我们有一个家庭影院，在播放电影时我们需要打开 DVD 机，打开投影仪，打开放大器，打开音频协调器等，我们可以用一个<code>Facade</code>来将这些操作都封装起来，对于外部调用者来说仅有开始播放电影及关闭播放电影两步。</p>
<h2 id="代码示例-2"><a class="header-anchor" href="#代码示例-2">#</a>代码示例</h2>
<h3 id="子系统"><a class="header-anchor" href="#子系统">#</a>子系统</h3>
<figure class="highlight cs"><figcaption><span>DVD机器</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DvdPlayer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">On</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="keyword">this</span>.GetType().ToString() + <span class="string">&quot; On&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Off</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="keyword">this</span>.GetType().ToString() + <span class="string">&quot; Off&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>投影仪</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Projector</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">On</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="keyword">this</span>.GetType().ToString() + <span class="string">&quot; On&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Off</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="keyword">this</span>.GetType().ToString() + <span class="string">&quot; Off&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>放大器</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Amplifier</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">On</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="keyword">this</span>.GetType().ToString() + <span class="string">&quot; On&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Off</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="keyword">this</span>.GetType().ToString() + <span class="string">&quot; Off&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>音频协调器</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Tuner</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">On</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="keyword">this</span>.GetType().ToString() + <span class="string">&quot; On&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Off</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="keyword">this</span>.GetType().ToString() + <span class="string">&quot; Off&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Facade"><a class="header-anchor" href="#Facade">#</a>Facade</h3>
<figure class="highlight cs"><figcaption><span>家庭影院外观者</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">HomeTheaderFacade</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Amplifier amplifier = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Tuner tuner = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> DvdPlayer dvdPlayer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Projector projector = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HomeTheaderFacade</span>(<span class="params">Amplifier amplifier, Tuner tuner, DvdPlayer dvdPlayer, Projector projector</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.amplifier = amplifier;</span><br><span class="line">        <span class="keyword">this</span>.tuner = tuner;</span><br><span class="line">        <span class="keyword">this</span>.dvdPlayer = dvdPlayer;</span><br><span class="line">        <span class="keyword">this</span>.projector = projector;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">WatchMovie</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        amplifier.On();</span><br><span class="line">        tuner.On();</span><br><span class="line">        dvdPlayer.On();</span><br><span class="line">        projector.On();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endMovie</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        amplifier.Off();</span><br><span class="line">        tuner.Off();</span><br><span class="line">        dvdPlayer.Off();</span><br><span class="line">        projector.Off();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试代码及结果-2"><a class="header-anchor" href="#测试代码及结果-2">#</a>测试代码及结果</h2>
<figure class="highlight cs"><figcaption><span>测试代码</span></figcaption><table><tr><td class="code"><pre><span class="line">HomeTheaderFacade facade = <span class="keyword">new</span> HomeTheaderFacade(<span class="keyword">new</span> Amplifier(), <span class="keyword">new</span> Tuner(), <span class="keyword">new</span> DvdPlayer(), <span class="keyword">new</span> Projector());</span><br><span class="line">facade.WatchMovie();</span><br><span class="line">Console.WriteLine();</span><br><span class="line">facade.endMovie();</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/ch_07_the_adapter_and_facade_patterns/2019-02-03-13-53-18.png" alt="外观模式运行结果"></p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>《Computer Networks and Internets》 Ch 08 可靠性及信道编码</title>
    <url>/ch_08_reliability_and_channel_coding/</url>
    <content><![CDATA[<h1 id="Introduction"><a class="header-anchor" href="#Introduction">#</a>Introduction</h1>
<p>这一部分将介绍信息传输过程中发生错误的原因，以及纠错的方式——信道编码。本部分将着重介绍前向错误纠正技术，并引出汉明距离等概念。</p>
<h1 id="The_Three_Main_Sources_Of_Transmission_Errors"><a class="header-anchor" href="#The_Three_Main_Sources_Of_Transmission_Errors">#</a>The Three Main Sources Of Transmission Errors</h1>
<p>传输中发生的错误可以分为三大类：</p>
<ol>
<li>干扰（Interference）：如第七章所述，环境中存在许多电磁干扰，这些电磁干扰会阻碍无线电传输和线缆中的信号传输。</li>
<li>失真（Distortion）：所有的物理系统都会造成信号的失真。光纤中的光因为移动距离的增加，时域会发生扩张（频域也因此变化）。信道容量会导致一些频率的信号被过滤掉。放在线缆旁边的金属可能会改变线缆内信号的频率，金属也能干扰无线电信号。</li>
<li>衰弱（Attenuation）：信号在媒介中传输的过程中，信号会逐渐衰弱。</li>
</ol>
<p>香农定理给出了减少错误的思路：提高信噪比。</p>
<p>但无论如何噪声不可能被完全的消除，所以许多方法致力于检测错误，在某些情况下自动修复错误。</p>
<p>但是错误的监测机制无疑是会为系统增加开销的，因此系统设计时要考虑在错误影响与错误检测开销间做权衡，如金融系统，1bit 的错误可能会造成很严重的错误，但是在图片中 1bit 的错误可能根本无法被识别到。</p>
<h1 id="Effect_Of_Transmission_Errors_On_Data"><a class="header-anchor" href="#Effect_Of_Transmission_Errors_On_Data">#</a>Effect Of Transmission Errors On Data</h1>
<p>这里要区分传输错误与数据错误，数据是由传输信号在经过例如解码，解调后得到的。传输错误最后都会导致最后的数据出错。主要有三类传输造成的数据错误：</p>
<ol>
<li>
<p>单元位错误（Single Bit Error）：即一系列数据中，只有一位数据被改变了。这通常是因为传输信号的短时间（称为脉冲，Spike）干扰造成的。</p>
</li>
<li>
<p>突发性错误：一系列数据中有多位数据被改变，通常是由长时间的干扰造成的。错误长度是由错误开始位到错误结束位直接的位数决定。如下表，错误的数据由加粗表示，错误长度是 7：</p>
<table>
<thead>
<tr>
<th>发送</th>
<th>1</th>
<th>0</th>
<th>1</th>
<th>1</th>
<th>0</th>
<th>0</th>
<th>0</th>
<th>1</th>
<th>0</th>
<th>1</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr>
<td>接收</td>
<td>1</td>
<td>0</td>
<td><strong>0</strong></td>
<td>1</td>
<td><strong>1</strong></td>
<td>0</td>
<td><strong>1</strong></td>
<td><strong>0</strong></td>
<td><strong>1</strong></td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
</li>
</ol>
<h1 id="Two_Strategies_For_Handling_Channel_Errors"><a class="header-anchor" href="#Two_Strategies_For_Handling_Channel_Errors">#</a>Two Strategies For Handling Channel Errors</h1>
<p>有一系列的方法解决数据错误并增加数据的可靠性，这些方法统称为<code>信道编码(Channel Coding)</code>，这些方法可以被分为两类：<code>前向错误纠正技术（Forward Error Correction，FEC）</code>，<code>自动重传请求技术（Automatic Repeat reQuest，ARQ）</code>。</p>
<p>前向错误纠正技术的主题思想是在发送的数据中增加额外的信息，接收端可以根据这些额外信息来判断是否有错误发生，有些方法可以检测出究竟是哪一位数据发生了错误，并在可能的情况下纠正错误。</p>
<p>自动重传请求技术是让接收端和发送端互换数据来保证数据被正确的传递。</p>
<h1 id="Block_And_Convolutional_Error_Codes"><a class="header-anchor" href="#Block_And_Convolutional_Error_Codes">#</a>Block And Convolutional Error Codes</h1>
<p>前向错误纠正技术可以再细分为两类：</p>
<ol>
<li>分组错误码（Block Error Codes）：分组错误码是将数据分成一块块的，然后对每一块都增加额外信息。每一块的额外信息只针对于该块数据本身。</li>
<li>卷积错误码（Convolutional Error Codes）：卷积错误码是将数据看作一系列 bits，增加的额外信息是由当前的 bit 和之前的 bit 共同决定的。</li>
</ol>
<p>卷积错误码相对于分组错误码需要更多的计算，但是也更能检测出错误。</p>
<h1 id="An_Example_Block_Error_Code_Single_Parity_Checking"><a class="header-anchor" href="#An_Example_Block_Error_Code_Single_Parity_Checking">#</a>An Example Block Error Code: Single Parity Checking</h1>
<p>单一奇偶校验检查（Single Parity Checking）是分组错误码检测的一个例子，可以再分为偶校验检查和奇校验检查。如果将数据分为 $n$ bit 一组，那么每一组增加一位数据，当是偶校验时，$n$ 位数据+1 位额外数据应该一共有偶数个 1，当是奇校验时，$n$ 位数据+1 位额外数据应该一共有奇数个 1。下表为 8 位数据时的例子：</p>
<table>
<thead>
<tr>
<th>原始数据</th>
<th>偶校验</th>
<th>奇校验</th>
</tr>
</thead>
<tbody>
<tr>
<td>00000000</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>01011011</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>01010101</td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>单一奇偶校验是一个比较弱的信道编码，他只能检测错误，但无法检测出错误具体出现在哪一位，也无法纠正错误。而且当有偶数个位发生错误时，错误就无法被检测出来。</p>
<h1 id="The_Mathematics_of_Block_Error_Codes_And_n_k_Notation"><a class="header-anchor" href="#The_Mathematics_of_Block_Error_Codes_And_n_k_Notation">#</a>The Mathematics of Block Error Codes And (n,k) Notation</h1>
<p>如有 $k$ 位 bit 的数据，我们将所有 $2^k$ 种可能出现的数据称为<code>数据字(Datawords)</code>，在这些数据中增加 $r$ 位额外数据，一共有 $n=k+r$ 个数据，所有 $2^n$ 种可能称为<code>编码字(codeworks)</code>，其中编码字中合法的部分，即额外添加的数据与原数据时符合规则的部分，称为<code>码书(Codebook)</code>，并将这种方法标记为$(n,k)$</p>
<p>如单一奇偶校验中，$k=8,r=1$，因此一共有 256 个数据字，也对应了有 256 个合法的编码字，一共有 512 个编码字。</p>
<p>在理想状态下，合法编码字中的任一一位被改变了，改变后的编码字就不是合法编码字。但是在单一奇偶校验的例子中，如果同时改变了合法编码字中的两位，那么结果仍然是一个合法编码字。</p>
<p>没有一个信道编码可以达到理想状态，所以要考虑的就是，合法编码字最少多少位数据要被同时改变，才能产生另一个合法编码字。在单一数字编码中，这个位数为 2。</p>
<h1 id="Hamming_Distance：A_Measure_Of_A_Code’s_Strength"><a class="header-anchor" href="#Hamming_Distance：A_Measure_Of_A_Code’s_Strength">#</a>Hamming Distance：A Measure Of A Code’s Strength</h1>
<p>汉明距离（Hamming Distance）是用来测量一个合法编码字要转换为另一个合法编码字最少要改变的数据位数的方法中需要用到的概念。如果给定两个$n$长度的字符，两个字符的汉明距离就是两个字符间不同的数据数量。</p>
<p>如$d(000,001)=1,d(000,101)=2,d(000,111)=3,d(101,001)=1$。</p>
<p>可以先对两个字符求异或，然后计算异或出来的字符 1 的总数，即为汉明距离。</p>
<h1 id="The_Hamming_Distance_Among_String_In_A_Codebook"><a class="header-anchor" href="#The_Hamming_Distance_Among_String_In_A_Codebook">#</a>The Hamming Distance Among String In A Codebook</h1>
<p>为了计算出一个合法编码字要转换为另一个合法编码字最少要改变的数据位数，先要计算出码书中所有编码字组合的汉明距离。如对 2 位 bit 数据进行单一奇校验检测：</p>
<table>
<thead>
<tr>
<th>数据字</th>
<th>编码字</th>
</tr>
</thead>
<tbody>
<tr>
<td>00</td>
<td>001</td>
</tr>
<tr>
<td>01</td>
<td>010</td>
</tr>
<tr>
<td>10</td>
<td>100</td>
</tr>
<tr>
<td>11</td>
<td>111</td>
</tr>
</tbody>
</table>
<p>一共有 4 个编码字，4 个编码字一一配对一共有 6 种可能，$d(001,010)=2,d(010,100)=2,d(001,100)=2,d(010,111)=2,d(001,111)=2,d(100,111)=2$。6 种可能中最小的汉明距离是 2，所以最少需要更改 2 位数据才能从一个合法编码字变为另一个合法编码字。</p>
<p>因此计算从一个合法编码字转换为另一个合法编码字最少要改变的数据位数过程是，计算出所有码书中的编码字（即合法编码字）两两配对后的所有汉明距离 $d_{min}$，其中的最小值即为所求值。</p>
<h1 id="The_Tradeoff_Between_Error_Detection_And_Overhead"><a class="header-anchor" href="#The_Tradeoff_Between_Error_Detection_And_Overhead">#</a>The Tradeoff Between Error Detection And Overhead</h1>
<p>对于一个编码，最多的能被检测出来的错误位数为$e=d_{min}-1$，如单一奇偶校验，因为$d_{min}=2$，所以最多能正确检测出来的错误位数为 1。</p>
<p>虽然$d_{min}$越大能检测出来的错误位数越多，但这也意味着要增加更多的额外数据，对于$(n,k)$的编码，工程师用编码率（Code Rate）$R=\frac{k}{n}$来表示为了检测出错误信息的编码开销。</p>
<h1 id="Error_Correction_With_Row_And_Column_RAC_Parity"><a class="header-anchor" href="#Error_Correction_With_Row_And_Column_RAC_Parity">#</a>Error Correction With Row And Column(RAC) Parity</h1>
<p>奇偶校验本身是不能进行错误纠正的，但是通过<code>行列奇偶校验（Row And Column Parity）</code>就可以做到。如一共有 12 个 bit 的原始数据，即$k=12$，排成三行四列每一列每一行都进行奇偶校验，增加一个额外位，则一共 8 个额外位，即$r=8，n=k+r=20$，因此这是一个$(20,12)$的编码，如下图所示：</p>
<p><img src="/ch_08_reliability_and_channel_coding/2019-12-05-14-46-47.png" alt="行列奇偶校验"></p>
<p>因此如果一位数据出错，会同时在对应的行和列校验位感知到，因此就可以定位到错误的数据，取反后就能纠正数据。</p>
<p>奇偶校验数据的$d_{min}$还是 2，因此如果错误的位数大于 1，当是偶数时无法被检测到，当是奇数时虽然能检测出错误，但无法纠正。</p>
<h1 id="The_16_Bit_Checksum_Used_In_The_Internet"><a class="header-anchor" href="#The_16_Bit_Checksum_Used_In_The_Internet">#</a>The 16-Bit Checksum Used In The Internet</h1>
<p>有个称为<code>因特网校验和（Internet checksum）</code>的信道编码方法在网络中扮演了重要角色。这个算法的输入可以是任意长度，将输入拆分为一段段 16 字节的的部分，如果不能长度不能被 16 整除，则最后补 0。如下图所示：</p>
<p><img src="/ch_08_reliability_and_channel_coding/2019-12-06-17-25-08.png" alt="拆分为16字节"></p>
<p>算法的流程如下：</p>
<ol>
<li>将输入拆分为以 16-bit 为一组</li>
<li>定义一个 32-bit 的变量（这里称为$C$）作为结果。</li>
<li>将每一组 16-bit 的数据累加给$C$</li>
<li>将$C$的前 16 位累加给后 16 位</li>
<li>将$C$的后 16 位取反，如果取反后全是 0，则将其改为全是 1</li>
<li>此时$C$的 16 位即为校验和。</li>
</ol>
<p>可以看出最后的校验和也是 16 位的数据，将校验和作为新的一组 16-bit 放在原数据后（经过了补 0 的原数据）发送出去。接收端接受信息后重复算法流程，如果数据没有发生错误，最后接收端计算出的校验和应该是 FFFF。</p>
<p>下面以两个例子进行说明：</p>
<ol>
<li>
<p>例子 1<br>
如果发送端输入数据为<code>0100 1000 0110 0101</code>，<code>0110 1100 0110 1100</code>，<code>0110 1111 0010 0001</code>，计算过程如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">   0100 1000 0110 0101</span><br><span class="line">   0110 1100 0110 1100</span><br><span class="line">+  0110 1111 0010 0001</span><br><span class="line">----------------------------</span><br><span class="line">1  0010 0011 1111 0010</span><br></pre></td></tr></table></figure>
<p>将高 16 位移到后 16 位</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">  0010 0011 1111 0010</span><br><span class="line">+                   1</span><br><span class="line">-------------------------</span><br><span class="line">  0010 0011 1111 0011</span><br></pre></td></tr></table></figure>
<p>取反后得到：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1101 1100 0000 1100</span><br></pre></td></tr></table></figure>
<p>这即为校验和</p>
<p>对于接收端，因为将校验和也一并发送了过去，所以接收端的计算过程如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">   0100 1000 0110 0101</span><br><span class="line">   0110 1100 0110 1100</span><br><span class="line">   0110 1111 0010 0001</span><br><span class="line">+  1101 1100 0000 1100</span><br><span class="line">----------------------------</span><br><span class="line">1  1111 1111 1111 1110</span><br></pre></td></tr></table></figure>
<p>将高 16 位移到后 16 位</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">  1111 1111 1111 1110</span><br><span class="line">+                   1</span><br><span class="line">-------------------------</span><br><span class="line">  1111 1111 1111 1111</span><br></pre></td></tr></table></figure>
<p>取反后得到：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">0000 0000 0000 0000</span><br></pre></td></tr></table></figure>
<p>因为全为 0，所以改为全为 1</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1111 1111 1111 1111</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>例子 2<br>
如果发送端输入数据为<code>1111 1111 1111 1111</code>，<code>1111 1111 1111 1111</code>，<code>0000 0000 0000 0001</code>，计算过程如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">   1111 1111 1111 1111</span><br><span class="line">   1111 1111 1111 1111</span><br><span class="line">+  0000 0000 0000 0001</span><br><span class="line">----------------------------</span><br><span class="line">1  1111 1111 1111 1111</span><br></pre></td></tr></table></figure>
<p>将高 16 位移到后 16 位</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">  1111 1111 1111 1111</span><br><span class="line">+                   1</span><br><span class="line">-------------------------</span><br><span class="line">1 0000 0000 0000 0000</span><br></pre></td></tr></table></figure>
<p>此时虽然高 16 仍然有数值，但不需要再次累加，后 16 位取反后得到：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1111 1111 1111 11111</span><br></pre></td></tr></table></figure>
<p>这即为校验和</p>
<p>对于接收端，因为将校验和也一并发送了过去，所以接收端的计算过程如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">   1111 1111 1111 1111</span><br><span class="line">   1111 1111 1111 1111</span><br><span class="line">   0000 0000 0000 0001</span><br><span class="line">+  1111 1111 1111 1111</span><br><span class="line">----------------------------</span><br><span class="line">10 1111 1111 1111 1110</span><br></pre></td></tr></table></figure>
<p>将高 16 位移到后 16 位</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">  1111 1111 1111 1110</span><br><span class="line">+                  10</span><br><span class="line">-------------------------</span><br><span class="line">1 0000 0000 0000 0000</span><br></pre></td></tr></table></figure>
<p>取反后得到：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1111 1111 1111 1111</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="Cyclic_Redundancy_Codes_CRCs"><a class="header-anchor" href="#Cyclic_Redundancy_Codes_CRCs">#</a>Cyclic Redundancy Codes(CRCs)</h1>
<p>在高速网络中，有一个称为<code>循环冗余码(Cyclic Redundancy Codes,CRCs)</code>的信道编码方法。循环冗余码有三个主要优点：</p>
<ol>
<li>可以对任意长度的数据进行计算</li>
<li>可以充分的检测出错误</li>
<li>可以通过硬件实现，所以非常的高效</li>
</ol>
<p>求$CRC$的计算过程可以看作是两个二进制数的相除，一个代表原数据，一个代表一个特定的除数（可根据不同的情况设置，除数的设置决定错误检测的能力），如果需要求得$N$长度的$CRC$，则需要$N+1$长度的被除数。二进制数相除的过程可以看作是多项式相除，如果原数据是$1010$，除数设置为$1011$，则计算过程如下图：</p>
<p><img src="/ch_08_reliability_and_channel_coding/2019-12-07-00-01-18.png" alt="CRC计算过程"></p>
<h1 id="An_Efficient_Hardware_Implementation_Of_CRC"><a class="header-anchor" href="#An_Efficient_Hardware_Implementation_Of_CRC">#</a>An Efficient Hardware Implementation Of CRC</h1>
<p>CRC 算法的实现硬件是由<code>移位寄存器(Shift Register)</code>和<code>异或门(Exclusive or gates)</code>构成的。在计算 CRC 前，硬件会初始化将移位寄存器中的所有位改为 0，上例中的除数$1011$，对应的硬件图如下：</p>
<p><img src="/ch_08_reliability_and_channel_coding/2019-12-07-00-06-02.png" alt="1011硬件"></p>
<p>TODO：为什么这么设计的原因。</p>
<h1 id="Automatic_Repeat_Request_ARQ_Mechanisms"><a class="header-anchor" href="#Automatic_Repeat_Request_ARQ_Mechanisms">#</a>Automatic Repeat Request(ARQ) Mechanisms</h1>
<p>自动重传请求技术（Automatic Repeat Request,ARQ）需要发送端和接收端传递信息来检测错误。当一方发送数据给另一方时，接收方需要传递一个回执给发送方。如果在一段时间后发送方仍然没有收到回执，则认为数据丢失，重新发送数据。</p>
<p>自动重传请求技术适合只能检测错误，但不能修复错误的系统。当接收方检测出数据有错误后，将数据丢弃并不传递回执，那么发送方就会再次发送数据。</p>
<h1 id="Reference"><a class="header-anchor" href="#Reference">#</a>Reference</h1>
<p><a href="https://en.wikipedia.org/wiki/polynomial_long_division">多项式除法</a><br>
<a href="https://heasarc.gsfc.nasa.gov/docs/heasarc/ofwg/docs/general/checksum/node11.html">1’s Complement Arithmetic</a></p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《Head First 设计模式》 Ch 08 模板方法模式</title>
    <url>/ch_08_the_template_method_pattern/</url>
    <content><![CDATA[<p>模版方法模式（Template Method Pattern）定义了一个算法的操作步骤，但其中的某些步骤需要派生来对应实现。</p>
<ul>
<li>
<p>工厂方法&gt;模式就是模版方法模式的一种运用。</p>
</li>
<li>
<p>策略模式和模版方法模式都是将算法的实现抽象出来，不同的是策略模式的实现依靠组成，而模版方法模式依靠继承。</p>
</li>
</ul>
<p>例如我们需要准备咖啡和茶，准备咖啡基本步骤为烧开水，加入咖啡粉，将咖啡倒入杯子，增加牛奶或糖（可选），准备茶的基本步骤为烧开水，加入茶粉，将茶倒入杯子，增加柠檬（可选）。我们发现在制作两个饮料的过程中，烧开水和倒入杯子这两个步骤是一样的，剩下的两个步骤，向烧开的水中增加相应的粉和增加配料，这两部分也是类似的，于是我们可以用模版方法模式，将这两步骤作为抽象方法。</p>
<h1 id="代码示例"><a class="header-anchor" href="#代码示例">#</a>代码示例</h1>
<h2 id="算法模版基类"><a class="header-anchor" href="#算法模版基类">#</a>算法模版基类</h2>
<figure class="highlight cs"><figcaption><span>咖啡因饮料模版</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">CaffeineBeverage</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrepareRecipe</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        boilWater();</span><br><span class="line">        brew();</span><br><span class="line">        pourInCup();</span><br><span class="line">        <span class="keyword">if</span> (NeedCondiments())</span><br><span class="line">            addCondiments();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">brew</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">addCondiments</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">boilWater</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Boiling Water&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pourInCup</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Pouring Water&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">bool</span> <span class="title">NeedCondiments</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note info simple"><p>例子中<code>brew</code>和<code>addCondiments</code>即为模版函数，而<code>NeedCondiments</code>这种提供了基本实现，但派生类中仍然可以重写的函数被称为钩子（<code>Hook</code>）。</p>
</div>
<h2 id="咖啡因饮料实现"><a class="header-anchor" href="#咖啡因饮料实现">#</a>咖啡因饮料实现</h2>
<figure class="highlight cs"><figcaption><span>咖啡</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Coffee</span> : <span class="title">CaffeineBeverage</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">addCondiments</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Add sugar and Milk&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">brew</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Dripping coffee through filter&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> <span class="title">NeedCondiments</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>茶</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Tea</span> : <span class="title">CaffeineBeverage</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">addCondiments</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Adding lemon&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">brew</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Steeping the tea&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="测试代码及结果"><a class="header-anchor" href="#测试代码及结果">#</a>测试代码及结果</h1>
<figure class="highlight cs"><figcaption><span>测试代码</span></figcaption><table><tr><td class="code"><pre><span class="line">Coffee coffee = <span class="keyword">new</span> Coffee();</span><br><span class="line">Tea tea = <span class="keyword">new</span> Tea();</span><br><span class="line">coffee.PrepareRecipe();</span><br><span class="line">Console.WriteLine();</span><br><span class="line">tea.PrepareRecipe();</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<p><img src="/ch_08_the_template_method_pattern/2019-02-03-15-59-58.png" alt="模版方法模式运行结果"></p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>《Head First 设计模式》 Ch 09 模板方法模式</title>
    <url>/ch_09_the_iterator_and_composite_pattern/</url>
    <content><![CDATA[<h1 id="迭代器模式"><a class="header-anchor" href="#迭代器模式">#</a>迭代器模式</h1>
<p>迭代器模式(Iterator Pattern)提供了一种访问聚合对象但不需要关心其内部实现方法的方式。</p>
<p>例如我们存在两个菜单，第一个菜单表示早餐，第二个表示晚餐，第一个菜单其中的菜品用<code>List</code>来存储，第二个菜单其中的菜品用<code>Array</code>来存储。在这种情况下就需要使用迭代器模式，为两个菜单提供一个供外部调用的访问菜品的接口。</p>
<h2 id="代码示例"><a class="header-anchor" href="#代码示例">#</a>代码示例</h2>
<p>我们在两个菜单类中添加<code>createIterator</code>函数来返回迭代器，对于外部调用者，如测试代码中的<code>PrintMenu</code>,它只需要调用<code>hasNext</code>及<code>next</code>即可而不需要关心菜单中的具体实现。</p>
<h3 id="菜单"><a class="header-anchor" href="#菜单">#</a>菜单</h3>
<figure class="highlight cs"><figcaption><span>Pancake菜单</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PancakeHouseMenu</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;MenuItem&gt; menuItemsList = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PancakeHouseMenu</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        menuItemsList = <span class="keyword">new</span> List&lt;MenuItem&gt;();</span><br><span class="line">        addItem(<span class="string">&quot;K&amp;B&#x27;s Pancake Breakfast&quot;</span>, <span class="string">&quot;Pancake with eggs and toast&quot;</span>, <span class="literal">true</span>, <span class="number">2.99f</span>);</span><br><span class="line">        addItem(<span class="string">&quot;Regular&#x27;s Pancake Breakfast&quot;</span>, <span class="string">&quot;Pancake with eggs and sausags&quot;</span>, <span class="literal">true</span>, <span class="number">2.99f</span>);</span><br><span class="line">        addItem(<span class="string">&quot;Blueberry&#x27;s Pancake Breakfast&quot;</span>, <span class="string">&quot;Pancake with eggs and fresh blueberries&quot;</span>, <span class="literal">true</span>, <span class="number">2.99f</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">createIterator</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PancakeIterator(menuItemsList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addItem</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">string</span> description, <span class="built_in">bool</span> vegetarian, <span class="built_in">float</span> price</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        MenuItem menuItem = <span class="keyword">new</span> MenuItem(name, description, vegetarian, price);</span><br><span class="line">        menuItemsList.Add(menuItem);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>Diner菜单</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DinerMenu</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">int</span> MaxItemsCount = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">private</span> MenuItem[] menuItemsArray = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> numberOfItems = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DinerMenu</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        menuItemsArray = <span class="keyword">new</span> MenuItem[MaxItemsCount];</span><br><span class="line">        addItem(<span class="string">&quot;Vegetarian BLT&quot;</span>, <span class="string">&quot;Fakin Bacon with tomato&quot;</span>, <span class="literal">true</span>, <span class="number">2.99f</span>);</span><br><span class="line">        addItem(<span class="string">&quot;BLT&quot;</span>, <span class="string">&quot;Bacon with tomato&quot;</span>, <span class="literal">true</span>, <span class="number">3.99f</span>);</span><br><span class="line">        addItem(<span class="string">&quot;Soup of the day&quot;</span>, <span class="string">&quot;Soup of the day and salad&quot;</span>, <span class="literal">false</span>, <span class="number">3.29f</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addItem</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">string</span> description, <span class="built_in">bool</span> vegetarian, <span class="built_in">float</span> price</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (numberOfItems &gt;= MaxItemsCount)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        MenuItem menuItem = <span class="keyword">new</span> MenuItem(name, description, vegetarian, price);</span><br><span class="line">        menuItemsArray[numberOfItems++] = menuItem;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">createIterator</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DinerMenuIterator(menuItemsArray);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="迭代器接口及实现"><a class="header-anchor" href="#迭代器接口及实现">#</a>迭代器接口及实现</h3>
<figure class="highlight cs"><figcaption><span>迭代器接口</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Iterator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">bool</span> <span class="title">hasNext</span>()</span>;</span><br><span class="line">    <span class="function"><span class="built_in">object</span> <span class="title">next</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>迭代器实现</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PancakeIterator</span> : <span class="title">Iterator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;MenuItem&gt; itemsList = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> currentPosition = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PancakeIterator</span>(<span class="params">List&lt;MenuItem&gt; itemsList</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.itemsList = itemsList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">hasNext</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> currentPosition &lt; itemsList.Count &amp;&amp; itemsList[currentPosition] != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">next</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> itemsList[currentPosition++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DinerMenuIterator</span> : <span class="title">Iterator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> MenuItem[] itemsArray = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> currentPosition = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DinerMenuIterator</span>(<span class="params">MenuItem[] items</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.itemsArray = items;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">hasNext</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> currentPosition &lt; itemsArray.Length &amp;&amp; itemsArray[currentPosition] != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">next</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> itemsArray[currentPosition++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试代码及结果"><a class="header-anchor" href="#测试代码及结果">#</a>测试代码及结果</h2>
<figure class="highlight cs"><figcaption><span>测试代码</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    DinerMenu dinerMenu = <span class="keyword">new</span> DinerMenu();</span><br><span class="line">    PancakeHouseMenu pancakeHouseMenu = <span class="keyword">new</span> PancakeHouseMenu();</span><br><span class="line"></span><br><span class="line">    PrintMenu(dinerMenu.createIterator());</span><br><span class="line">    Console.WriteLine();</span><br><span class="line">    PrintMenu(pancakeHouseMenu.createIterator());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintMenu</span>(<span class="params">Iterator iterator</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())</span><br><span class="line">    &#123;</span><br><span class="line">        ((MenuItem)iterator.next()).Debug();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/ch_09_the_iterator_and_composite_pattern/2019-02-03-23-36-01.png" alt="迭代器模式运行结果"></p>
<h1 id="组合模式"><a class="header-anchor" href="#组合模式">#</a>组合模式</h1>
<p>组合模式（Composite Pattern）是用树形结构来组合对象进而体现一种局部-整体的层次结构。组合模式可以让调用者以统一的方式对待单个物体和多个物体的组合。</p>
<p>例如我们需要打印一个菜单上的所有菜品，但菜单中可能还包含子菜单，子菜单中又可能包含子菜单等等，但对于外部调用者而言则不希望关注这些细节。我们可以通过定义一个基类，无论是菜品还是菜单都继承自这个基类，这样对于菜单而言，无论是子菜单还是菜品都是同一个基类，可一起管理。对于外部调者而言只 x 需要关心这个基类即可。</p>
<h2 id="代码示例-2"><a class="header-anchor" href="#代码示例-2">#</a>代码示例</h2>
<h3 id="共同抽象类基类"><a class="header-anchor" href="#共同抽象类基类">#</a>共同抽象类基类</h3>
<figure class="highlight cs"><figcaption><span>菜单元素</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">MenuComponent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params">MenuComponent menuComponent</span>)</span> &#123; <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Remove</span>(<span class="params">MenuComponent menuComponent</span>)</span> &#123; <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> MenuComponent <span class="title">GetChild</span>(<span class="params"><span class="built_in">int</span> i</span>)</span> &#123; <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">protected</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">string</span> Description &#123; <span class="keyword">get</span>; <span class="keyword">protected</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">float</span> Price &#123; <span class="keyword">get</span>; <span class="keyword">protected</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">bool</span> Vegetarian &#123; <span class="keyword">get</span>; <span class="keyword">protected</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Debug</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(Name + <span class="string">&quot; , &quot;</span> + Description + <span class="string">&quot; , &quot;</span> + Vegetarian + <span class="string">&quot; , &quot;</span> + Price);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="菜单及菜品实现"><a class="header-anchor" href="#菜单及菜品实现">#</a>菜单及菜品实现</h3>
<figure class="highlight cs"><figcaption><span>菜单</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Menu</span> : <span class="title">MenuComponent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;MenuComponent&gt; menuComponetsList = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Menu</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">string</span> description</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        menuComponetsList = <span class="keyword">new</span> List&lt;MenuComponent&gt;();</span><br><span class="line">        Name = name;</span><br><span class="line">        Description = description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params">MenuComponent menuComponent</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        menuComponetsList.Add(menuComponent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Remove</span>(<span class="params">MenuComponent menuComponent</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        menuComponent.Remove(menuComponent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> MenuComponent <span class="title">GetChild</span>(<span class="params"><span class="built_in">int</span> i</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> menuComponetsList[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Debug</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(Name + <span class="string">&quot; , &quot;</span> + Description);</span><br><span class="line">        menuComponetsList.ForEach(menuComponent =&gt; menuComponent.Debug());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>菜品</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MenuItem</span> : <span class="title">MenuComponent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MenuItem</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">string</span> description, <span class="built_in">bool</span> vegetarian, <span class="built_in">float</span> price</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Name = name;</span><br><span class="line">        Description = description;</span><br><span class="line">        Vegetarian = vegetarian;</span><br><span class="line">        Price = price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试代码及结果-2"><a class="header-anchor" href="#测试代码及结果-2">#</a>测试代码及结果</h2>
<figure class="highlight cs"><figcaption><span>测试代码</span></figcaption><table><tr><td class="code"><pre><span class="line">Menu menu = <span class="keyword">new</span> Menu(<span class="string">&quot;General Menu&quot;</span>, <span class="string">&quot;Holds all menus and menu items&quot;</span>);</span><br><span class="line">Menu dinnerMenu = <span class="keyword">new</span> Menu(<span class="string">&quot;Dinner Menu&quot;</span>, <span class="string">&quot;Holds dinner menu items&quot;</span>);</span><br><span class="line">Menu breakfastMenu = <span class="keyword">new</span> Menu(<span class="string">&quot;Breakfast Menu&quot;</span>, <span class="string">&quot;Holds Breakfast menu items&quot;</span>);</span><br><span class="line">menu.Add(dinnerMenu);</span><br><span class="line">menu.Add(breakfastMenu);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">breakfastMenu.Add(<span class="keyword">new</span> MenuItem(<span class="string">&quot;K&amp;B&#x27;s Pancake Breakfast&quot;</span>, <span class="string">&quot;Pancake with eggs and toast&quot;</span>, <span class="literal">true</span>, <span class="number">2.99f</span>));</span><br><span class="line">breakfastMenu.Add(<span class="keyword">new</span> MenuItem(<span class="string">&quot;Regular&#x27;s Pancake Breakfast&quot;</span>, <span class="string">&quot;Pancake with eggs and sausags&quot;</span>, <span class="literal">true</span>, <span class="number">2.99f</span>));</span><br><span class="line">breakfastMenu.Add(<span class="keyword">new</span> MenuItem(<span class="string">&quot;Blueberry&#x27;s Pancake Breakfast&quot;</span>, <span class="string">&quot;Pancake with eggs and fresh blueberries&quot;</span>, <span class="literal">true</span>, <span class="number">2.99f</span>));</span><br><span class="line"></span><br><span class="line">dinnerMenu.Add(<span class="keyword">new</span> MenuItem(<span class="string">&quot;Vegetarian BLT&quot;</span>, <span class="string">&quot;Fakin Bacon with tomato&quot;</span>, <span class="literal">true</span>, <span class="number">2.99f</span>));</span><br><span class="line">dinnerMenu.Add(<span class="keyword">new</span> MenuItem(<span class="string">&quot;BLT&quot;</span>, <span class="string">&quot;Bacon with tomato&quot;</span>, <span class="literal">true</span>, <span class="number">3.99f</span>));</span><br><span class="line">dinnerMenu.Add(<span class="keyword">new</span> MenuItem(<span class="string">&quot;Soup of the day&quot;</span>, <span class="string">&quot;Soup of the day and salad&quot;</span>, <span class="literal">false</span>, <span class="number">3.29f</span>));</span><br><span class="line"></span><br><span class="line">menu.Debug();</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/ch_09_the_iterator_and_composite_pattern/2019-02-06-16-23-58.png" alt="组合模式运行结果"></p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>《Computer Networks and Internets》 Ch 10 调制与调制器</title>
    <url>/ch_10_modulation_and_modems/</url>
    <content><![CDATA[<h1 id="Introduction"><a class="header-anchor" href="#Introduction">#</a>Introduction</h1>
<p>这一章讨论数据通信中的调制与调制器相关的内容。</p>
<p>调制是利用高频的信息来携带原始数据，将分别讨论当原始数据是模拟信号和数字信号的情况。</p>
<h1 id="Carriers_Frequency_And_Propagation"><a class="header-anchor" href="#Carriers_Frequency_And_Propagation">#</a>Carriers,Frequency,And Propagation</h1>
<p>许多通信系统会利用一个持续震荡的电磁波来作为信息的载波（Carrier），通常这个信号都是一个高频信号。在第七章有提到，信号的频率会影响信号的传播特性，如穿透性，对噪声的敏感性等。</p>
<h1 id="Analog_Modulation_Schemes"><a class="header-anchor" href="#Analog_Modulation_Schemes">#</a>Analog Modulation Schemes</h1>
<p><code>调制（Modulation）</code>意为根据原始信号来改变载波的特性。调制有两个输入，一个是载波，一个是原信号，然后产生一个调制后的载波作为输出。调制的原理图如下：</p>
<p><img src="/ch_10_modulation_and_modems/2019-12-07-23-21-31.png" alt="调制原理图"></p>
<p>输入的原信号必须改变载波的一个特性，根据特性的不同可以分为<code>振幅调制（Amplitude modulation）</code>，<code>频移调制（Frequency modulation）</code>，<code>移相调制（Phase shift modulation）</code>。其中前两种最为普遍。</p>
<h1 id="Amplitude_Modulation"><a class="header-anchor" href="#Amplitude_Modulation">#</a>Amplitude Modulation</h1>
<p><code>振幅调制（Amplitude modulation）</code>是根据原信号改变载波的振幅。从时域图上看，调制后的波形的轮廓与原信号基本相同，如下图所示，（a）是高频载波，（b）是原信号，（c）是调制后的信号。</p>
<p><img src="/ch_10_modulation_and_modems/2019-12-07-23-28-45.png" alt="振幅调制"></p>
<h1 id="Frequency_Modulation"><a class="header-anchor" href="#Frequency_Modulation">#</a>Frequency Modulation</h1>
<p><code>频移调制（Frequency modulation）</code>是根据原信号改变载波的频率，当信号强是，载波的频率增加，反之减少。如下图即为频移调制后的样子：</p>
<p><img src="/ch_10_modulation_and_modems/2019-12-07-23-36-37.png" alt="频移调制"></p>
<h1 id="Phase_Shift_Modulation"><a class="header-anchor" href="#Phase_Shift_Modulation">#</a>Phase Shift Modulation</h1>
<p><code>移相调制（Phase shift modulation）</code>是根据原信号改变载波的相位。经过理论上可行，但对于模拟信号来说，很少用移相调制，因为模拟信号采样点的数据可能比较接近，导致移相的大小不明显，很容易被误认为是频率的改变。但对于数字信号来说移相调制因为可以一个码元传递多个 Bit 的字节，所以经常被使用。</p>
<h1 id="Amplitude_Modulation_And_Shannon’s_Theorem"><a class="header-anchor" href="#Amplitude_Modulation_And_Shannon’s_Theorem">#</a>Amplitude Modulation And Shannon’s Theorem</h1>
<p>在之前解释振幅调制的示意图中，调制后信号变化幅度较大，最低处的强度接近于 0。但实际运用时，基本上振幅调制的幅度变化很小。因为考虑到有噪声的存在，如果信号的变化幅度较大，在信号最弱时的信噪比会很低，则几乎无法传递有效信息。</p>
<h1 id="Modulation_Digital_Input_And_Shift_Keying"><a class="header-anchor" href="#Modulation_Digital_Input_And_Shift_Keying">#</a>Modulation,Digital Input,And Shift Keying</h1>
<p>为了区分模拟信号和数字信号的调制，使用属于<code>移位键控（Shift Keying）</code>来表示数字信号的调制。数字信号的调制与模拟信号调制基本原理类似，只不过作为原信号的模拟信号是连续的数值变化，而数字信号是离散的几个特定的数值。振幅与频率移位键控如下图，(a)是载波，(b)是原信号，©是振幅移位键控，(d)是频率移位键控</p>
<p><img src="/ch_10_modulation_and_modems/2019-12-08-00-05-53.png" alt="振幅，频率移位键控"></p>
<h1 id="Phase_Shift_Keying"><a class="header-anchor" href="#Phase_Shift_Keying">#</a>Phase Shift Keying</h1>
<p><code>相位移位键控(Phase Shift Keying)</code>是根据原信号突然的改变载波的相位，如下图所示，即为相位移位键控的示意图。</p>
<p><img src="/ch_10_modulation_and_modems/2019-12-08-00-11-28.png" alt="相位移位键控"></p>
<h1 id="Phase_Shift_And_A_Constellation_Diagram"><a class="header-anchor" href="#Phase_Shift_And_A_Constellation_Diagram">#</a>Phase Shift And A Constellation Diagram</h1>
<p>如之前所示，相位移位键控最大的优势在于可以用一个码元传递多个 bit。可通过$2^n$个相位来使一个码元可携带$n$ bit 数据。使用星座图来表示相位变化大小与该大小与对应数据的关系。星座图如下图所示，图（1）是只有两个相位变化，即表示 0 和 1，图（2）是有四个相位变化，可代表两个 bit,即 00,01,10,11。</p>
<p><img src="/ch_10_modulation_and_modems/2019-12-08-00-18-17.png" alt="两个相位的相位移位键控"></p>
<p><img src="/ch_10_modulation_and_modems/2019-12-08-00-18-54.png" alt="四个相位的相位移位键控"></p>
<h1 id="Quadrature_Amplitude_Modulation"><a class="header-anchor" href="#Quadrature_Amplitude_Modulation">#</a>Quadrature Amplitude Modulation</h1>
<p>如上节所述，可以在使用相位移位键控时采用多个相位间隔使一个码元传递多个 bit。但某些情况下，硬件无法检测过于精细的相位变化。这时候可以通过降相位移位键控和振幅移位键控结合在一起使一个码元可携带更多的数据，这方法称为<code>正交振幅调制（Quadrature Amplitude Modulation）</code>。如下图所示：</p>
<p><img src="/ch_10_modulation_and_modems/2019-12-08-10-04-32.png" alt="正交振幅调制"></p>
<p>如上图，一共有四个相位区分，每个点距离原点的距离代表振幅，一共有四个电压，因此一共有 16 种组合，一个码元可以携带 4 个 bit。</p>
<h1 id="Modem_Hardware_For_Modulation_And_Demodulation"><a class="header-anchor" href="#Modem_Hardware_For_Modulation_And_Demodulation">#</a>Modem Hardware For Modulation And Demodulation</h1>
<p>将一系列的数据 bit 作为输入，然后根据这些原数据对载波进行调制的设备称为<code>调制器（Modulator）</code>，反之根据调制后的载波重新解析出原信号的机器称为<code>解调器（Demodulator）</code>。在实际中，大部分的通信设备同时包含调制器和解调器，这种设备被称为<code>调制解调器（Modem）</code>。下图是两个计算机的通信简图，在两者将数据传给中间的电缆媒介前，都经过了调制解调器</p>
<p><img src="/ch_10_modulation_and_modems/2019-12-08-10-13-14.png" alt="调制解调器"></p>
<h1 id="Optical_And_Radio_Frequency_Modems"><a class="header-anchor" href="#Optical_And_Radio_Frequency_Modems">#</a>Optical And Radio Frequency Modems</h1>
<p>调制解调器不仅可用于电缆的传输，对于无线电波和光纤也同样适用，原理也一样，在发送端调制解调器对载波进行调制，在接收端，数据从被调制后的载波中会提取。</p>
<h1 id="Dialup_Modems"><a class="header-anchor" href="#Dialup_Modems">#</a>Dialup Modems</h1>
<p>在语音电话系统中，使用的调制解调器称为<code>拨号调制解调器（Dialup Modems）</code>，其与普通的调制解调器最大的区别在于，前者用的是语音信号，后者用的是电信号，而且拨号调制解调器占用的带宽更小。</p>
<p>因为电话系统接受的是模拟信号，所以拨号调制解调器也是一个对模拟信号进行调制的设备。但讽刺的是现代电话系统的中间传输部分是数字信号，于是发送端在调制后，需要将模拟信号转换为数字信号。而在接收端，在进行解调前也需要先将中间传输来的数字信号转换为模拟信号。</p>
<h1 id="QAM_Applied_To_Dialup"><a class="header-anchor" href="#QAM_Applied_To_Dialup">#</a>QAM Applied To Dialup</h1>
<p>正交振幅调制也同样可用于拨号调制解调器中。因为大部分语音频率本身是从$300HZ\sim 3300HZ$，但拨号调制解调器只能提供$600HZ\sim 3000HZ$，所以同样需要正交振幅调制来使一个码元能携带更多的数据。</p>
<h1 id="V_32_And_V_32bis_Dialup_Modems"><a class="header-anchor" href="#V_32_And_V_32bis_Dialup_Modems">#</a>V.32 And V.32bis Dialup Modems</h1>
<p>V.32 和 V.32bis 是两个拨号调制解调器用正交振幅调制的标准。</p>
<p>V.32 使用 32 个振幅和相位的组合来表示数据，可以达到单向每秒 9600 个 bit 的数据速率。</p>
<p><img src="/ch_10_modulation_and_modems/2019-12-08-10-28-37.png" alt="V.32"></p>
<p>V.32bis 使用 128 个振幅和相位的组合来表数据，可以达到单向每秒 14400 个 bit 的数据速率。</p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《Head First 设计模式》 Ch 11 代理模式</title>
    <url>/ch_11_the_proxy_pattern/</url>
    <content><![CDATA[<p>代理模式（Proxy Pattern）为对象提供一个代理进而控制对其的访问。</p>
<p>例如我们需要加载一张图片，但加载图片是个访问网络或 IO 的操作，我们不希望这个这个操作阻塞 UI 线程，于是我们可以定义一个代理来进行多线程的加载，并在加载完成后显示图片。</p>
<h1 id="代码示例"><a class="header-anchor" href="#代码示例">#</a>代码示例</h1>
<h2 id="抽象接口"><a class="header-anchor" href="#抽象接口">#</a>抽象接口</h2>
<figure class="highlight cs"><figcaption><span>图片接口</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Icon</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrintIconWidthAndHeight</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="抽象接口实现"><a class="header-anchor" href="#抽象接口实现">#</a>抽象接口实现</h2>
<figure class="highlight cs"><figcaption><span>真实图片类</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ImageIcon</span> : <span class="title">Icon</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> width, height;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImageIcon</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Thread.Sleep(<span class="number">5000</span>);<span class="comment">//Pretend there is some hard work to load the image</span></span><br><span class="line">        width = <span class="number">800</span>;</span><br><span class="line">        height = <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintIconWidthAndHeight</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(DateTime.Now.ToLongTimeString() + <span class="string">&quot;: Width is &quot;</span> + width + <span class="string">&quot;,height is &quot;</span> + height);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>代理图片类</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ImageProxyIcon</span> : <span class="title">Icon</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> ImageIcon icon = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> isLoading = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImageProxyIcon</span>()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintIconWidthAndHeight</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (icon != <span class="literal">null</span>)</span><br><span class="line">            icon.PrintIconWidthAndHeight();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!isLoading)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(DateTime.Now.ToLongTimeString() + <span class="string">&quot;: Is Loading Image...&quot;</span>);</span><br><span class="line">            isLoading = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">new</span> Thread(() =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                icon = <span class="keyword">new</span> ImageIcon();</span><br><span class="line">                icon.PrintIconWidthAndHeight();</span><br><span class="line">            &#125;).Start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="测试代码及结果"><a class="header-anchor" href="#测试代码及结果">#</a>测试代码及结果</h1>
<figure class="highlight cs"><figcaption><span>测试代码</span></figcaption><table><tr><td class="code"><pre><span class="line">ImageProxyIcon proxyIcon = <span class="keyword">new</span> ImageProxyIcon();</span><br><span class="line">proxyIcon.PrintIconWidthAndHeight();</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/ch_11_the_proxy_pattern/2019-02-07-14-10-11.png" alt="代理模式运行结果"></p>
<div class="note info simple"><p>代理模式与装饰模式很像，不同的是装饰模式的目的是在原先的类外扩展某些功能，而代理模式只是控制原先类中某些接口的访问。例如上例子中，<code>ImageProxyIcon</code>并没有为<code>ImageIcon</code>拓展什么功能，只是用了多线程来访问访问其中的函数。</p>
</div>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>《Head First 设计模式》 Ch 10 状态模式</title>
    <url>/ch_10_the_state_pattern/</url>
    <content><![CDATA[<p>状态模式(State Pattern)允许一个对象根据其内部状态的变化来选择需要执行的操作。这个对象会看起来像是改变了它的类。</p>
<p>状态模式定义听起来有些奇怪，实际上就是将不同状态的行为定义在不同的状态类中，然后根据状态的不同切换这些状态类，进而达到不同的行为。</p>
<p>例如我们需要做一个口香糖贩卖机需要处理，投钱、退钱、旋转出货按钮这三个操作，然后机器有未投钱、投钱、货物卖出、货物卖完四个状态。我们可以将不同状态下对三个操作的处理定义在各自的状态类中。</p>
<h1 id="代码示例"><a class="header-anchor" href="#代码示例">#</a>代码示例</h1>
<h2 id="状态类接口"><a class="header-anchor" href="#状态类接口">#</a>状态类接口</h2>
<figure class="highlight cs"><figcaption><span>状态类接口</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">State</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InsertQuarter</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">EjectQuarter</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TurnCrank</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Dispense</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="状态类实现"><a class="header-anchor" href="#状态类实现">#</a>状态类实现</h2>
<figure class="highlight cs"><figcaption><span>未投钱状态</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NoQuarterState</span> : <span class="title">State</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> GumballMachine gumballMachine = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NoQuarterState</span>(<span class="params">GumballMachine gumballMachine</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.gumballMachine = gumballMachine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispense</span>()</span> &#123; Console.WriteLine(<span class="string">&quot;You need to pay first&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">EjectQuarter</span>()</span> &#123; Console.WriteLine(<span class="string">&quot;You haven&#x27;t inserted a quarter&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InsertQuarter</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        gumballMachine.SetState(gumballMachine.HasQuarterState);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;You inserted a quarter&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TurnCrank</span>()</span> &#123; Console.WriteLine(<span class="string">&quot;You turned,but there&#x27;s no quarter&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>投钱状态</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HasQuarterState</span> : <span class="title">State</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> GumballMachine gumballMachine = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HasQuarterState</span>(<span class="params">GumballMachine gumballMachine</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.gumballMachine = gumballMachine;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispense</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;No gumball dispensed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">EjectQuarter</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Quarter returned&quot;</span>);</span><br><span class="line">        gumballMachine.SetState(gumballMachine.NoQuarterState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InsertQuarter</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;You can&#x27;t insert another quater&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TurnCrank</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;You turned&quot;</span>);</span><br><span class="line">        gumballMachine.SetState(gumballMachine.SoldState);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>货物卖出状态</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SoldState</span> : <span class="title">State</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> GumballMachine gumballMachine = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SoldState</span>(<span class="params">GumballMachine gumballMachine</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.gumballMachine = gumballMachine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispense</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        gumballMachine.ReleaseBall();</span><br><span class="line">        <span class="keyword">if</span> (gumballMachine.remainGumballsNum &gt; <span class="number">0</span>)</span><br><span class="line">            gumballMachine.SetState(gumballMachine.NoQuarterState);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Opps,out of gumballs&quot;</span>);</span><br><span class="line">            gumballMachine.SetState(gumballMachine.SoldOutState);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">EjectQuarter</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Sorry,you already turned the crank&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InsertQuarter</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Please wait,we are already giving you a gumball&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TurnCrank</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Turning twice dones&#x27;t get you another gumball&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>货物售完状态</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SoldOutState</span> : <span class="title">State</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> GumballMachine gumballMachine = <span class="literal">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SoldOutState</span>(<span class="params">GumballMachine gumballMachine</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.gumballMachine = gumballMachine;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispense</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;No gumball dispensed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">EjectQuarter</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;You can&#x27;t eject,you haven&#x27;t inserted a quarter yet&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InsertQuarter</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;You can&#x27;t insert a quarter,the machine is sold out&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TurnCrank</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;You turned,but there are no gumballs&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="测试代码及结果"><a class="header-anchor" href="#测试代码及结果">#</a>测试代码及结果</h1>
<figure class="highlight cs"><figcaption><span>测试代码</span></figcaption><table><tr><td class="code"><pre><span class="line">GumballMachine gumballMachine = <span class="keyword">new</span> GumballMachine(<span class="number">5</span>);</span><br><span class="line">gumballMachine.TurnCrank();</span><br><span class="line">gumballMachine.InsertQuarter();</span><br><span class="line">gumballMachine.EjectQuarter();</span><br><span class="line">gumballMachine.TurnCrank();</span><br><span class="line">gumballMachine.InsertQuarter();</span><br><span class="line">gumballMachine.TurnCrank();</span><br><span class="line">gumballMachine.TurnCrank();</span><br><span class="line">gumballMachine.EjectQuarter();</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/ch_10_the_state_pattern/2019-02-06-20-10-15.png" alt="状态模式运行结果"></p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>《Computer Networks and Internets》 Ch 11 复用与解复用</title>
    <url>/ch_11_multiplexing_and_demultiplexing/</url>
    <content><![CDATA[<h1 id="Introduction"><a class="header-anchor" href="#Introduction">#</a>Introduction</h1>
<p>这一部分将介绍将多个心愿的数据流合并在一起的复用，和将合并后数据流拆分的解复用。</p>
<h1 id="The_Concept_Of_Multiplexing"><a class="header-anchor" href="#The_Concept_Of_Multiplexing">#</a>The Concept Of Multiplexing</h1>
<p><code>复用(Multiplexing)</code>是将多个信源的数据流合并在一起，并通过一个共享的媒介进行传输。<code>复用器（Multiplexor）</code>是用来进行复用的设备。<code>解复用（Demultiplexing）</code>是将合并后的数据流拆分还原成一个个信源的信息，<code>解复用器（Demultiplexor）</code>是用来进行解复用的设备。下图是复用与解复用的使用简图：</p>
<p><img src="/ch_11_multiplexing_and_demultiplexing/2019-12-08-10-56-05.png" alt="复用与解复用"></p>
<p>复用与解复用在日常的计算机网络使用中一直在进行，如多台电脑使用同一根网线等。</p>
<h1 id="The_Basic_Types_Of_Multiplexing"><a class="header-anchor" href="#The_Basic_Types_Of_Multiplexing">#</a>The Basic Types Of Multiplexing</h1>
<p>在物理层，有四大类的复用方式：</p>
<ol>
<li>频分复用（Frequency Division Multiplexing）</li>
<li>波分复用（Wavelength Division Multiplexing）</li>
<li>时分复用（Time Division Multiplexing）</li>
<li>码分复用（Code Division Multiplexing）</li>
</ol>
<p>频分复用和波分复用使用比较广泛。波分复用可以看作是频分复用的一种特殊形式（波长与波的频率是相关的），波分复用用于光纤中。码分复用是没有使用物理特性，而是用数学原理，在一些电话系统中有运用。</p>
<h1 id="Frequency_Division_Multiplexing（FDM）"><a class="header-anchor" href="#Frequency_Division_Multiplexing（FDM）">#</a>Frequency Division Multiplexing（FDM）</h1>
<p><code>频分复用（Frequency Division Multiplexing）</code>是无线电广播的基础。在频分复用下，一个有大频率带宽的信道将拆分成许多小部分，每个信源都有一个自己单独的信道（占据一定频率的范围，相当于每个信源的载波频率都不同），每个信道间不会相互干扰，所有的信源都将使用一个共同的媒介进行传输。在频分复用下，每个信道都可以选择各自的方式进行调制。</p>
<p>频分复用最大的优点在于多个发送端和接收端都可以同时使用传输媒介。</p>
<p>为了避免在频分复用下，每个信源都有自己的信道，如果这些信道间的频率太过于接近则会产生干扰。为了避免干扰的的产生，信道之间需要由间隔（Gap），称为<code>防护频带（Guard band）</code>。</p>
<p>下图是频分复用的示意图，每个小块代表一个可供信源使用的单独信道，可以看到每个信道间都有一个小间隔作为防护频带。</p>
<p><img src="/ch_11_multiplexing_and_demultiplexing/2019-12-08-11-15-01.png" alt="频分复用"></p>
<h1 id="Using_A_Range_Of_Frequency_Per_Channel"><a class="header-anchor" href="#Using_A_Range_Of_Frequency_Per_Channel">#</a>Using A Range Of Frequency Per Channel</h1>
<p>在上节的例子中，每个信道都有一个频率范围，但载波是固定频率的，信道之所欲选择一个频率范围而非单一的频率，主要是考虑便捷性，因为划分出的信道可能会以各种方式被使用。大多数频分复用系统都给发送端和接收端一个频率范围，系统可以选择最适用的频率作为载波，选择的评判标准通常是数据速率和对噪音的敏感性。</p>
<p>因为频分复用通常的频率较高，对噪声敏感，因此通常使用同轴电缆来作为传输媒介。</p>
<p>有的时候为了进一步增加数据速率，被分配给一个信源的信道会被再次的分割成更小的信道，如一个信源将分配给它的信道再分割成$K$个小信道，则每个小信道只要传输$1/k$的数据即可，这技术称为<code>子信道（Subchannel）</code>。</p>
<p>有的时候为了进一步增加对噪声的抵抗性，会使用称为<code>展频(Spread Spectrum)</code>的技术。这个方法同样将信源的信道再切割成$k$个小信道，但每个信道都传输一样的数据，接收端收到信息后，从这$k$个小信道中找寻错误最少的数据作为接收数据。</p>
<h1 id="Hierarchical_FDM"><a class="header-anchor" href="#Hierarchical_FDM">#</a>Hierarchical FDM</h1>
<p><code>分层频分复用（Hierarchical FDM）</code>是将频分复用后的总数据再作为一个频率更高的频分复用的输入进行再次复用。如下图所示：</p>
<p><img src="/ch_11_multiplexing_and_demultiplexing/2019-12-08-12-06-55.png" alt="分层频分复用"></p>
<p>虽然上图中每一级的单一信道带宽是上一级所有信道带宽的总和。但在实际运用中，下一级的单一信道带宽是要略大于上一级所有信道带宽的总和的，因为还需要携带额外的同步帧。</p>
<h1 id="Wavelength_Division_Multiplexing（WDM）"><a class="header-anchor" href="#Wavelength_Division_Multiplexing（WDM）">#</a>Wavelength Division Multiplexing（WDM）</h1>
<p><code>波分复用（Wavelength Division Multiplexing，WDM）</code>是在使用光纤作为媒介时的频分复用。当波分复用使用了许多不同频率的光时，可称为<code>密集波分复用（Dense Wavelength Division Multiplexing）</code>。</p>
<p>波分复用的原理可以参考物理上的三棱镜实验，即白光可以拆分为不同颜色的光，而光的颜色是由光的频率决定的。棱柱为波分复用与解复用提供了基础。波分复用的复用器是接受一系列不同波长的光，然后通过一个棱柱将它们合并成一束光，然后接收端的解复用器再次通过棱镜将它们还原成不同波长的光。示意图如下：</p>
<p><img src="/ch_11_multiplexing_and_demultiplexing/2019-12-08-12-15-12.png" alt="波分复用"></p>
<h1 id="Time_Division_Multiplexing（TDM）"><a class="header-anchor" href="#Time_Division_Multiplexing（TDM）">#</a>Time Division Multiplexing（TDM）</h1>
<p><code>时分复用（Time Division Multiplexing，TDM）</code>的原理很简单，即每个信源使用共同的媒介一段时间，然后供下一个信源使用。示意图如下：</p>
<p><img src="/ch_11_multiplexing_and_demultiplexing/2019-12-08-12-18-29.png" alt="时分复用"></p>
<h1 id="Synchronous_TDM"><a class="header-anchor" href="#Synchronous_TDM">#</a>Synchronous TDM</h1>
<p>时分复用在计算机网络中是一个比较宽泛的概念。因此在实际运用中，上节中的概念图会在细节上有变化。例如有些时分复用系统并不是所有信源按顺序一个个发送。有些时分复用的系统中，每个信源发送间也并不像上图一样有时间间隔，一个信源发送后另一个信源会马上发送，这种系统称为<code>同步时间复用系统（Synchronous TDM）</code>。如下图所示：</p>
<p><img src="/ch_11_multiplexing_and_demultiplexing/2019-12-08-14-34-28.png" alt="同步TDM"></p>
<h1 id="Framing_Used_In_The_Telephone_System_Version_Of_TDM"><a class="header-anchor" href="#Framing_Used_In_The_Telephone_System_Version_Of_TDM">#</a>Framing Used In The Telephone System Version Of TDM</h1>
<p>如之前所述，电话系统的两端是模拟信号，中间传输的是数字信号。对于中间使用同一个媒介传输的数字信号是通过同步时间复用系统来进行复用的。在电话系统中在时间复用系统中用了一个特殊技术来保证接收端和发送端的时间是对齐的，因为一旦接收端的时间出现了偏差，则可能将错误的信号传递给错误的目的地。为了解决这个问题，电话系统中的时间复用系统需要额外传输一个<code>信道帧（Framing Channel）</code>来表示一轮传输的开始，如下图所示：</p>
<p><img src="/ch_11_multiplexing_and_demultiplexing/2019-12-08-14-42-09.png" alt="信道帧"></p>
<h1 id="Hierarchical_TDM"><a class="header-anchor" href="#Hierarchical_TDM">#</a>Hierarchical TDM</h1>
<p>如同频分复用，时间复用也可以是分层的。不同的是，在频分复用系统中，每一级增加的是频率，在时分复用系统中每一级增加的是数据速率（减少时间切分间隔）。另外每一级的数据速率略大于前一级所有数据速率的总和，这是因为要传输额外帧数据。分层时间复用如下图：</p>
<p><img src="/ch_11_multiplexing_and_demultiplexing/2019-12-08-14-46-19.png" alt=""></p>
<h1 id="The_Problem_With_Synchronous_TDM_Unfilled_Slots"><a class="header-anchor" href="#The_Problem_With_Synchronous_TDM_Unfilled_Slots">#</a>The Problem With Synchronous TDM: Unfilled Slots</h1>
<p>同步时间复用对与每个信源都平均的提供时间，即将整个信道的容量（容量可看作一秒能传输的数据量）平分。但如果一个信源在某一段是空白数据，那么当轮到这个信源发送数据时，只能往信道内填空白数据（通常填0），且额外增加一位表示该数据是无效的，而不是正好全是0。这样会造成信道容量的浪费。如下图所示：</p>
<p><img src="/ch_11_multiplexing_and_demultiplexing/2019-12-08-14-50-26.png" alt="未填充数据时间复用"></p>
<h1 id="Statistical_TDM"><a class="header-anchor" href="#Statistical_TDM">#</a>Statistical TDM</h1>
<p>为了解决同步TDM这个问题，有个称为<code>统计时间复用（Statistical TDM）</code>，或称为异步时间复用（Asynchronous）的技术。这个技术仍然是所有信源轮询的传输数据，但是当信源没有数据时，并非像同步时间同步那样装填空白数据，而是直接跳过。如下图所示：</p>
<p><img src="/ch_11_multiplexing_and_demultiplexing/2019-12-08-14-54-27.png" alt="统计时间复用"></p>
<p>尽管这个方法解决了空白数据造成的信道容量浪费，但需要引入额外的数据来表明每个数据块是哪个信源的。</p>
<h1 id="Inverse_Multiplexing"><a class="header-anchor" href="#Inverse_Multiplexing">#</a>Inverse Multiplexing</h1>
<p><code>逆复用（Inverse Multiplexing）</code>技术是用类似于复用的思维方式，但解决是只有两个信源，但其中有多个传输媒介，且两信源有大量的数据需要传输，但中间媒介没有一个有足够的足够的比特率。逆复用技术就是将原数据拆分成多份，然后通过中间的低容量媒介进行传输，最后在接收端再将数据合并在一起。示意图如下图所示：</p>
<p><img src="/ch_11_multiplexing_and_demultiplexing/2019-12-08-15-04-52.png" alt="逆复用"></p>
<p>虽然逆复用看着很像复用的反向使用，即将复用的输出端变成输入，输入端变成输出，但在实际使用时，不能简单的将复用器反向设计得到逆复用器。逆复用器在发射端必须考虑如何将数据拆分后分配给多个低速率媒介。在接收端也必须考虑多个媒介的传输速率不同，可能造成某些媒介中的数据到达特别缓慢，这时候该如何处理。</p>
<h1 id="Code_Division_Multiplexing"><a class="header-anchor" href="#Code_Division_Multiplexing">#</a>Code Division Multiplexing</h1>
<p><code>码分复用（Code Division Multiplexing）</code>是在蜂窝电话（Cellular telephone）和卫星通信中使用的复用方法。与频分复用和时分复用不同的是，码分复用并不依赖与物理特性，而是利用数学特性：两个正交的线段可以被结合在一起而不会互相干扰。</p>
<p>每个信源都有一个不同的二进制码$C_i$，每个信源的二进制码都必须与其他信源的二进制码正交。即将这些二进制码看作是线段（1保持1，0看成-1），这些线段间必须两两垂直。每个信源都将原数据与二进制码叉乘，然后传输结果，复用的过程即是将所有的结果都累加在一起，在接收端每个信源的目的地再相应的将接受到的复用数据再次与对应信源的二进制码点乘，结果即为该信源应该收到的数据。</p>
<p>下面以一个例子方便理解。</p>
<p>假设有两个信源，两个信源的$C_i$分别是$(1,0)和(1,1)$，需要传输的数据分别是$(1,0,1,0)$和$(0,1,1,0)$。传输过程如下：</p>
<p>将原数据和二进制码改为向量，即1为1，0变-1。<br>
信源1：$C_1=(1,-1)$，$V_1=(1,-1,1,-1)$<br>
信源2：$C_2=(1,1)$，$V_2=(-1,1,1,-1)$</p>
<p>可以看到$C_1$和$C_2$是正交的。</p>
<p>复用过程即为:<br>
$$<br>
(C_1 \times V_1) + (C_2\times V_2)= \\<br>
((1,-1),(-1,1),(1,-1),(-1,1))+((-1,-1),(1,1),(1,1),(-1,-1))\\<br>
=((0,-2),(0,2),(2,0),(-2,0))<br>
$$</p>
<p>((0,-2),(0,2),(2,0),(-2,0))即为复用后的结果。</p>
<p>对于信源1的接收端而言，解复用过程为：</p>
<p>$$(1,-1)\cdot((0,-2),(0,2),(2,0),(-2,0))\\<br>
=((0+2),(0-2),(2+0),(-2+0))\\<br>
=(2,-2,2,-2)<br>
$$</p>
<p>负数变为0，正数变为1，即接收端1收到数据为(1,-1,1,-1)，与信源1发送数据相同。</p>
<p>对于信源2的接收端来说，解复用过程如下：</p>
<p>$$(1,1)\cdot((0,-2),(0,2),(2,0),(-2,0))\\<br>
=((0-2),(0+2),(2+0),(-2+0))\\<br>
=(-2,2,2,-2)<br>
$$</p>
<p>负数变为0，正数变为1，即接收端2收到数据为(-1,1,1,-1)，与信源2发送数据相同。</p>
<p>上述例子中，每个信源的二进制码$c_i$都比较小，但在实际运用中$c_i$可能会很大，这就导致了计算量的上升。如果数据本身并不多，但是花费了大量时间计算，效率比较低，因此在数据量不高的网络中CDM并不适用，</p>
<p>但是高数据量网络中，码分复用非常常见，因为相对于时间复用，码分复用的延迟较低。因为码分复用可以将多个信源的数据一次性同时发送给发送端，而时分复用则必须等待轮询到自己才能发送一部分。</p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《Head First 设计模式》 Ch 12 复合模式</title>
    <url>/ch_12_the_compound_patterns/</url>
    <content><![CDATA[<p>复合模式（Compound Pattern）是通过两个或以上的设计模式形成一个可以解决一般性问题的通用框架。</p>
<p>MVC 框架就是一种组合模式，<code>Controller</code>和<code>View</code>之间使用了策略模式， <code>View</code>中只存<code>Controller</code>的接口，进而达到可以随时切换不同<code>Controller</code>的目的。<code>Model</code>和<code>View</code>之间使用了观察者模式，<code>View</code>作为观察者，<code>Model</code>作为被观察者，当<code>Model</code>的数据发生变化时，<code>View</code>相应改变。而<code>View</code>本身使用了组合模式，比如按钮中可能存在子按钮，窗口中存在子窗口等等。</p>
<p>我们以音量调节作为一个最简的 MVC 框架示例。</p>
<div class="note info simple"><p>关于 MVC 更多的减少，见 MVC</p>
</div>
<h1 id="代码示例"><a class="header-anchor" href="#代码示例">#</a>代码示例</h1>
<h2 id="框架接口"><a class="header-anchor" href="#框架接口">#</a>框架接口</h2>
<figure class="highlight cs"><figcaption><span>观察者接口</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IVolumeObserver</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">VolumeUpdated</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>Model接口</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IVolumeModel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> Volume &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RegisterObserver</span>(<span class="params">IVolumeObserver observer</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">UnRegisterObserver</span>(<span class="params">IVolumeObserver observer</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>Controller接口</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IViewController</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">VolumeUp</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">VolumeDown</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetVolume</span>(<span class="params"><span class="built_in">int</span> volume</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="接口实现"><a class="header-anchor" href="#接口实现">#</a>接口实现</h2>
<figure class="highlight cs"><figcaption><span>Model</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">VolumeModel</span> : <span class="title">IVolumeModel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> volume = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Volume</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> volume; &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            volume = <span class="keyword">value</span>;</span><br><span class="line">            observersList.ForEach(observer =&gt; observer.VolumeUpdated());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> List&lt;IVolumeObserver&gt; observersList = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VolumeModel</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        observersList = <span class="keyword">new</span> List&lt;IVolumeObserver&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RegisterObserver</span>(<span class="params">IVolumeObserver observer</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        observersList.Add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UnRegisterObserver</span>(<span class="params">IVolumeObserver observer</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        observersList.Remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>View</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">VolumeView</span> : <span class="title">IVolumeObserver</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IViewController controller = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> IVolumeModel model = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VolumeView</span>(<span class="params">IViewController controller, IVolumeModel model</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.controller = controller;</span><br><span class="line">        <span class="keyword">this</span>.model = model;</span><br><span class="line">        <span class="keyword">this</span>.model.RegisterObserver(<span class="keyword">this</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;View: volume init is &quot;</span> + model.Volume);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnVolumeUpButtonClick</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        controller.VolumeUp();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnVolumeDownButtonClick</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        controller.VolumeDown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">VolumeUpdated</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;View: volume updated &quot;</span> + model.Volume);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~VolumeView()</span><br><span class="line">    &#123;</span><br><span class="line">        model.UnRegisterObserver(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>Controller</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">VolumeController</span> : <span class="title">IViewController</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> VolumeModel model = <span class="literal">null</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">VolumeController</span>(<span class="params">VolumeModel model</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.model = model;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetVolume</span>(<span class="params"><span class="built_in">int</span> volume</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            model.Volume = volume;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">VolumeDown</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            --model.Volume;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">VolumeUp</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            ++model.Volume;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="测试代码及结果"><a class="header-anchor" href="#测试代码及结果">#</a>测试代码及结果</h1>
<figure class="highlight cs"><figcaption><span>测试代码</span></figcaption><table><tr><td class="code"><pre><span class="line">VolumeModel model = <span class="keyword">new</span> VolumeModel();</span><br><span class="line">VolumeView view = <span class="keyword">new</span> VolumeView(<span class="keyword">new</span> VolumeController(model), model);</span><br><span class="line">view.OnVolumeUpButtonClick();</span><br><span class="line">view.OnVolumeUpButtonClick();</span><br><span class="line">view.OnVolumeDownButtonClick();</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/ch_12_the_compound_patterns/2019-02-07-15-53-23.png" alt="复合模式运行结果"></p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>《Computer Networks and Internets》 Ch 13 局域网：数据包，帧 和拓扑结构</title>
    <url>/ch_13_local_area_networks_packets,_frames,_and_topologies/</url>
    <content><![CDATA[<h1 id="Introduction"><a class="header-anchor" href="#Introduction">#</a>Introduction</h1>
<p>这一部分将介绍分组交换技术，拓扑结构，硬件地址寻址，帧的概念。</p>
<h1 id="Circuit_Switching_And_Analog_Communication"><a class="header-anchor" href="#Circuit_Switching_And_Analog_Communication">#</a>Circuit Switching And Analog Communication</h1>
<p><code>电路交换（Circuit Switching）</code>概念是指使用时在发送端和接收端之间建立不受干扰的通路的通信方法。电路交换通常与模拟电话技术相关。下图是电路交换的示意图：</p>
<p><img src="/ch_13_local_area_networks_packets,_frames,_and_topologies/2019-12-09-08-28-27.png" alt="电路交换"></p>
<p>电路交换的主要特点是：</p>
<ol>
<li>是点对点的通信</li>
<li>有单独的步骤建立电路连接，使用电路，终止电路连接<br>
例如在电话通信中，实际上有三步。第一步在电话发起人和接受者之间建立电路，第二步双方使用电路进行通信，第三步在通话结束后，终止通路。<br>
这也是称为交换（Switched）电路的原因</li>
<li>与固定的物理通路有相同的性能。</li>
</ol>
<p>电路交换建立的电路最终使用频分复用或者时分复用使用同一个媒介进行传输。电路建立的过程包括在频分复用或时分复用中分配频率或时间段。</p>
<h1 id="Packet_Switching"><a class="header-anchor" href="#Packet_Switching">#</a>Packet Switching</h1>
<p>分组交换（Packet Switching）使用一种统计意义上的复用，即多个信源之间竞争共享媒介的使用。电路交换通常在传统的电话通信中使用，而分组交换构成了因特网的基础。分组交换示意图如下：</p>
<p><img src="/ch_13_local_area_networks_packets,_frames,_and_topologies/2019-12-09-08-37-20.png" alt="分组交换"></p>
<p>注意，在11章中提到的复用技术，如频分复用和时分复用是对于物理存在的信道或者像电路交换这样生成的信道使用的，与分组交换并没有关系。分组交换本身就有统计复用（Statistic Multiplexing）的概念。多个信源在媒介空闲时竞争使用，当媒介为空，且只有一个信源需要传输数据时，该信源就会独占媒介。如果同时有多个信源要传输数据，则基本每个信源占据媒介的时间是平均的，轮流使用。</p>
<p>分组交换的核心是将原数据切分成一个个小块方便传输，这些小块称作包（Packets），包中需要包括传送的目的地信息（在之后节会更详细说明）。分组交换传输的单位不是bit或者byte,而是包。不同的分组交换技术对于包的尺寸有不同的定义。</p>
<p>分组交换的主要特点是：</p>
<ol>
<li>任意大小的异步传输</li>
<li>在通信前没有建立通路的步骤</li>
<li>性能取决于各信源的包的统计复用</li>
</ol>
<p>分组交换的主要优点在于成本的控制。对于电路交换来说，如果有$N$个电脑，则需要$N/2$个独立的路径（虽然在连接时才创建）。但对于分组交换只要一个共享的电路就行。</p>
<h1 id="Local_And_Wide_Area_Packet_Networks"><a class="header-anchor" href="#Local_And_Wide_Area_Packet_Networks">#</a>Local And Wide Area Packet Networks</h1>
<p>分组交换技术通常根据传输距离的距离进行分类。通常分为三类：</p>
<ol>
<li>局域网（Local Area Network,LAN）：最便宜，通常范围在房间级或者一个大楼。</li>
<li>城域网（Metropolitan Area Network,MAN）中等开销，范围涵盖城市或者大都会。</li>
<li>广域网（Wide Area Network,WAN）：最贵。范围通常包含城市与城市之间。</li>
</ol>
<p>在实际使用中，虽然城域网的概念被提出，但在商业上并不成功。基本广泛使用的只有局域网和广域网，城域网的概念在逐步被纳入广域网中。</p>
<p>还有一些机构或者商家定义的类似的分类方式，如：</p>
<ol>
<li><code>个人局域网络（Personal Area Network，PAN）</code>，通常范围在几米内，如蓝牙通信等。</li>
<li><code>芯片局域网络（Chip Area Network）</code>，芯片厂商提出的概念，通常是超大型电路（Very-Large-Scale-Integration,VLSI）中多个核之间的通信。</li>
</ol>
<h1 id="Standards_For_Packet_Format_And_Identification"><a class="header-anchor" href="#Standards_For_Packet_Format_And_Identification">#</a>Standards For Packet Format And Identification</h1>
<p>每个在网络中传输的包都必须包含其目标收信人的标识。需要有规范来制定标识的格式以及添加的位置，在LAN领域最常用的标准是由IEEE（Institute Electrical And Electronics Engineers）创建的。</p>
<p>IEEE是由一群关注于协议栈最下两层（物理层（Physical）和数据链接层（Data Link））的工程师构成的。协议栈的不同层由不同的机构负责，如IEFT关注传输层和因特网协议，WWW组织关注应用层。机构与其关注的协议如下图所示：</p>
<p>在1980年，IEEE组织了<code>802项目局域网/城域网标准委员（Project 802 LAN/MAN Standards Commitee）</code>会为网络设定标准。</p>
<p><img src="/ch_13_local_area_networks_packets,_frames,_and_topologies/2019-12-09-09-12-05.png" alt="组织和协议"></p>
<h1 id="IEEE_802_Model_And_Standards"><a class="header-anchor" href="#IEEE_802_Model_And_Standards">#</a>IEEE 802 Model And Standards</h1>
<p>IEEE将数据链接层又在细分为了两层，<code>逻辑链接控制层（Logical Link Control,LLC）</code>(第15章中描述)和<code>媒介访问控制层（Media Access Control,MAC）</code>。</p>
<p>逻辑链接控制层设备的地址和在解复用中地址的使用。媒介访问控制层关注于多个计算机如何共享底层的媒介。</p>
<p>IEEE对于协议的命名是采用多部分标识符，如$XXX.YYY.ZZZ$，$XXX$表示协议的分类，$YYY$表示协议的子分类，$ZZZ$是当子分类也非常大是，额外添加的标识。</p>
<p>如局域网的规范在分类802中，这里的802并不是什么缩写或有实际的技术含义，仅仅是一个分类标识。IEEE不同的工作小组针对其细分的协议进行定义，如针对$802.1$或$802.2$。</p>
<p>IEEE中有许多不同的工作小组。当有新技术需要协议时，由工业代表和学术协会共同形成工作小组，他们会定期开会商定协议的细节等，当协议的所有细节都确定后，IEEE会发表协议的标准文件。</p>
<p>当协议最终发布后，工作小组可以选择解散或者如果协议非常重要或者仍需要后续工作，小组也可以继续活动。如果小组负责的部分协议不再有意义，如商业上不被接受，或者有更新更好的技术出现，小组也可以选择直接解散而不发表任何的规范。下图是802分类下的协议，有一些规范就已经被放弃（Disbanded）了。</p>
<p><img src="/ch_13_local_area_networks_packets,_frames,_and_topologies/2019-12-09-09-25-59.png" alt="802协议"></p>
<h2 id="LAN_Topologies"><a class="header-anchor" href="#LAN_Topologies">#</a>LAN Topologies</h2>
<p>因为有许多不同的LAN技术，通常使用拓扑型或者网络的基本形状来进行分类。LAN有四个基本的拓扑型，<code>总线型结构（Bus）</code>，<code>环状结构（Ring）</code>，<code>星状结构（Star）</code>，<code>网状结构（Mesh）</code>。</p>
<h2 id="Bus_Topology"><a class="header-anchor" href="#Bus_Topology">#</a>Bus Topology</h2>
<p><code>总线型结构（Bus Topology）</code>是如同以太网一样，用一根电缆连接所有电脑，任何电脑都可以将数据传输到电缆上，然后所有的计算机都可以接受到数据。</p>
<h2 id="Ring_Topology"><a class="header-anchor" href="#Ring_Topology">#</a>Ring Topology</h2>
<p><code>环状结构（Ring Topology）</code>是多个电脑首尾相接的连接，直至成为环形。环形结构的优点是对于相连的两台设备来说连接是安全的，即使别的设备出现问题仍然可以连接。</p>
<h2 id="Mesh_Topology"><a class="header-anchor" href="#Mesh_Topology">#</a>Mesh Topology</h2>
<p><code>网状结构（Mesh Topology）</code>为任意两两配对的电脑都提供了连接线路，这意味着如果有$N$台电脑，就需要$\frac{n^2-n}{2}$个连接。当增加电脑时，连接电缆的增加是平方级的，因此开销巨大，也因此网状结构在局域网中不常被使用</p>
<h2 id="Star_Topology"><a class="header-anchor" href="#Star_Topology">#</a>Star Topology</h2>
<p><code>星状结构（Star Topology）</code>是所有的电脑都连接在一个中心设备（Hub）上。注意星状结构并不严格要求中心设备真的在所有电脑的中心，与所有电脑的距离相同。</p>
<h2 id="The_Reason_For_Multiple_Topologies"><a class="header-anchor" href="#The_Reason_For_Multiple_Topologies">#</a>The Reason For Multiple Topologies</h2>
<p>每个结构都有各自的优点，如环状结构很适合各电脑间协调访问，但当其中一个设备出现问题时，通路就会出现问题。星状结构下单一设备出现了问题，其他设备都可以正常访问。总线结构有最少的连接需求，但与环状结构与相同的缺点。网状结构因为连接数量过多，通常不在局域网中使用。</p>
<h1 id="Packet_Identification，Demultiplexing，Mac_Addresses"><a class="header-anchor" href="#Packet_Identification，Demultiplexing，Mac_Addresses">#</a>Packet Identification，Demultiplexing，Mac Addresses</h1>
<p>IEEE为寻址（Addressing）创建了标准。在分组交换中，解复用是依赖于一个称为<code>地址（Address）</code>的标识。每个电脑都分配了一个独特的地址，每个传输的包中都包含其目标收件人（Intended Recipent）的地址。</p>
<p>在IEEE的寻址规范中，每个地址是由48-bit二进制数据组成的，IEEE将其称为媒介访问控制地址（Media Access Control address,MAC address）。因为48位地址来源于以太网技术，所以也有人将其称为以太网地址（Ethernet Address）。</p>
<p>IEEE为每块网卡（Network Interface Card，NIC）都分配了地址，因此当消费者购买了一张网卡时，其中就包含一个独一无二的地址。</p>
<p>但IEEE并不是单独的为每个网卡分配地址，它是将前24位（3 Bytes）分配给设备供应商，然后设备供应商再决定后24位的数据。因此前24位称为组织唯一标识符（Organizationally Unique Identifier，OUI），后24位称为网络接口控制标识符（Network Interface Controller Specific）。</p>
<p>组织唯一标识符的最高有效字节（Most Significant Byte，即大端模式下即最左端）的倒数两位有特殊含义。其最低位表示是单播（0）还是双播（1）。倒数第二位决定该设备是全球唯一（0）（Globally Unique）还是是本地分配（1）（Locally Assigned），全球唯一表明地址是IEEE分配，即世界上的每块网卡都有不同的表示，而本地分配是实验性网卡或者某组织自己地址空间等，即这张卡是在一个小范围内内部使用。</p>
<h1 id="Unicast，Broadcast，And_Multicast_Addresses"><a class="header-anchor" href="#Unicast，Broadcast，And_Multicast_Addresses">#</a>Unicast，Broadcast，And Multicast Addresses</h1>
<p>IEEE定义了三种对应包传递的方法：</p>
<ol>
<li>单播（Unicast）：目标地址是设定一个电脑，也仅这个电脑可收到包</li>
<li>广播（broadcast）：网络中的所有电脑都可收到包</li>
<li>多播（multicast）：目标地址是一系列的电脑，这些电脑都可以收到包。</li>
</ol>
<p>对于广播来说，因为是所有电脑都收到包，所以目标地址实际是没有意义的。将地址的48位全部设为1，则表示是广播模式。广播模式也可看作是多播模式的一个特殊情况。</p>
<h1 id="Broadcast_Multicast_And_Efficient_Multi_Point_Delivery"><a class="header-anchor" href="#Broadcast_Multicast_And_Efficient_Multi_Point_Delivery">#</a>Broadcast,Multicast,And Efficient Multi-Point Delivery</h1>
<p>广播和多播模式在局域网中特别有用，对于要传递给多台电脑的数据来说，用这两种方法进行传递特别的高效。</p>
<p>对于大多数的LAN技术，都是通过一个共享的媒介进行传输。当有数据在媒介中传输时，每台电脑都将从媒介中获取包的拷贝，然后再判断包中的地址情况是否与自己复合，来决定是处理包的内容还是丢弃包的内容。</p>
<p>因此局域网中的计算机在处理媒介中的包流程如下：</p>
<ol>
<li>从包中抽取出地址信息</li>
<li>判断地址是否满足自己的单播地址，如果是则接受并处理包</li>
<li>如果2失败，判断地址是否是广播模式，如果是则接受并处理包</li>
<li>如果3失败，判断地址是否是多播模式，且电脑是多播模式指定的电脑组的一员，如果是则接受并处理包</li>
<li>如果4失败，则丢弃包</li>
</ol>
<p>如在局域网情况下，如果多台电脑使用同一个媒介，且包需要传递给多态电脑，那么使用多播和广播模式，数据仅需要发送一次即可。</p>
<h1 id="Frames_And_Framing"><a class="header-anchor" href="#Frames_And_Framing">#</a>Frames And Framing</h1>
<p>在同步通信系统中，帧的概念是让接收者知道数据的开始和结束。但在更宽泛的概念下，帧是表示一系列bit或byte的特定结构，让接收方和发送方都能一致同意的特定格式。</p>
<p>在分组交换中，帧的概念就对应包。在分组交换中，每个包都需要一个数据头，数据头（header）中包含目标地址。数据头后是有效负载（payload），即真正需要传输的原数据。在大部分的网络技术中，有效负载是不透明的即网络设备只能检查数据头。</p>
<p>在整个包的前后还能加入可选的前置数据（Prelude）或后置数据（Postlude）。因此整个包的结构如下所示：</p>
<p><img src="/ch_13_local_area_networks_packets,_frames,_and_topologies/2019-12-09-10-47-15.png" alt="包的结构"></p>
<p>举一个例子，如果一个包有6个byte的数据头，然后任意长度的有效负载，在包的前后各有1byte表示包的开始和结束。且开始和结束标识用ASCII码中的SOH（Start Of Header）和EOT（End Of Transmission）表示，则整个包如下所示：</p>
<p><img src="/ch_13_local_area_networks_packets,_frames,_and_topologies/2019-12-09-10-49-20.png" alt="包的例子"></p>
<p>上述例子有一点点数据的浪费，因为如果包是一个接一个发的，那么后一个包的SOH会紧跟着前一个包的EOT。在实际中，只需要一个来区分两个包即可。</p>
<p>虽然包的前置数据和后置数据是可选的，但在实际使用中，他们可以一定程度上提升异步传输数据的处理速度和对错误的检测。在异步传输中，如果接收方收到了EOT，它就知道数据包传输完成了，可以直接开始处理数据而不需要等到下一个包的到来再根据新包确定上个包是否完成。当发送端发送数据到一般崩溃时，因为接收端始终收不到EOT，也就能知道错误的发生。</p>
<h1 id="Byte_And_Bit_Stuffing"><a class="header-anchor" href="#Byte_And_Bit_Stuffing">#</a>Byte And Bit Stuffing</h1>
<p>在ASCII码中，SOH用十六进制0x01表示，EOT用0x04表示。如果有效负载中也出现了0x01和0x04，接收端就无法判定到底是真实数据还是前置或后置标识。</p>
<p>一种称为字节填充（byte Stuffing）就是为了解决有效负载和特殊标记位有相同表示导致无法识别的问题。<br>
该技术有时也称为数据填充（Data Stuffing）或字符填充（Character Stuffing）。该技术主要是</p>
<p>字节装填是用另一个字符来替代特殊标识的出现。</p>
<p>如我们选择用ASCII码中的ESC字符（Ox1B）来作为替换字符。在发送端当有效负载中出现SOH，那么就替换为&quot;ESC A&quot;，如果出现EOT,就替换为&quot;ESC B&quot;，如果出现了ESC就替换为&quot;ESC C&quot;。注意这个计算是针对有效负载的，当整个发送的有效负载中就不会与EOT和SOH相同的数据。对接收端而言，去找寻背后跟着&quot;A,B,C&quot;的ESC字符，然后将其替换回SOH和EOT的数据。发送端的替换过程如下所示：</p>
<p><img src="/ch_13_local_area_networks_packets,_frames,_and_topologies/2019-12-09-11-22-32.png" alt="字节装填"></p>
<h1 id="Reference"><a class="header-anchor" href="#Reference">#</a>Reference</h1>
<p><a href="https://web.archive.org/web/20171217042848/http://www.cs.virginia.edu/~mngroup/projects/mpls/documents/thesis/node8.html">Switching technology</a><br>
<a href="https://www.cnblogs.com/penghuwan/p/7686059.html#_label3_1">【计算机网络】数据交换技术和多路复用技术的正（nao）确(can)打开方式</a></p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《Computer Networks and Internets》 Ch 14 MAC 层</title>
    <url>/ch_14_the_ieee_mac_sublayer/</url>
    <content><![CDATA[<ul>
<li>这一章原书中的Statiion一词，在笔记中翻译为<code>终端</code>。</li>
</ul>
<h1 id="Introduction"><a class="header-anchor" href="#Introduction">#</a>Introduction</h1>
<p>这一章将会深入讨论MAC层，包括多路访问协议（multi-access protocols）以及静态和动态信道分配。</p>
<h1 id="A_Taxonomy_Of_Mechanisms_For_Shared_Access"><a class="header-anchor" href="#A_Taxonomy_Of_Mechanisms_For_Shared_Access">#</a>A Taxonomy Of Mechanisms For Shared Access</h1>
<p>实现多个计算机通过一个共享媒介来访问数据主要有三种方法： （1）复用技术（Multiplexing Technique） （2）分布算法来控制访问（Distributed Algorithms For Controlled Access） （3）随机访问策略（Random Access Strategy）</p>
<ul>
<li>这里的复用技术与在11章中讨论的复用核心思想是相同的，但仍然有略微区别。11章中提到的是物理上的复用，通过复用器将信号合并在一起。这里的复用则是对于共享信道的逻辑划分，使不同的终端占用共享信道的部分资源，所以这里的复用技术也称为<code>信道协议（Channelization Protocols）</code>。</li>
</ul>
<p>下图展示了按照共享媒介所使用的方法的分类：</p>
<p><img src="/ch_14_the_ieee_mac_sublayer/2019-12-27-22-55-32.png" alt="共享媒介的分类方法"></p>
<h1 id="Static_And_Dynamic_Channel_Allocation"><a class="header-anchor" href="#Static_And_Dynamic_Channel_Allocation">#</a>Static And Dynamic Channel Allocation</h1>
<p>信道分配是与第11章中提到的复用技术相关联的。以频分复用为例子，在第11章中是每个终端都有它的载波频率，终端与载波频率是一对一的关系，这就是<code>信道的静态分配（Static Channel Allocation）</code>。</p>
<p>信道可以静态分配的前提是预先知道终端的存在，而且终端在传输过程中不会发生变化。而在许多的场景下，终端是会变化的，例如一个路由器负责房间内手机的信号，但是手机可以关闭或者离开房间，这就是终端的变化。</p>
<p>在这种情况下就需要<code>信道的动态分配（Dynamic Channel Allocation）</code>，即当终端出现时才分配信道的资源给终端。</p>
<h1 id="Channelization_Protocols"><a class="header-anchor" href="#Channelization_Protocols">#</a>Channelization Protocols</h1>
<p>与第11章中的复用技术相似，信道分配也存在频分多路复用（Frequency Division Multi-Access），时分多路复用（Time Division Multi—Access），码分多路复用（Code Division Multi-Access）三种类型。</p>
<h2 id="FDMA"><a class="header-anchor" href="#FDMA">#</a>FDMA</h2>
<p>频分多路复用下每个终端都可以选择一个载波频率，这个频率并不会影响到其他的终端。在有些系统下存在一个中央控制器进而支持动态的频分多路复用：当一个新的终端出现，中央控制器用一个预留的信道与终端通信，然后分配一个未使用的载波频率给这个终端，之后终端都使用这个载波频率传输数据。</p>
<h3 id="TDMA"><a class="header-anchor" href="#TDMA">#</a>TDMA</h3>
<p>时分多路复用下，所有终端按顺序编号，如$1,2,3,…N$，并且会按这个顺序占据信道进行传输。如同频分多路复用，在某些系统下支持动态分配，即终端出现时再分配给他信道的占用时间段。</p>
<h3 id="CDMA"><a class="header-anchor" href="#CDMA">#</a>CDMA</h3>
<p>码分多路复用如同码分复用，通过数学方法将多个终端的数据合并在一起，再同时通过信道进行传输。</p>
<h1 id="Controlled_Access_Protocols"><a class="header-anchor" href="#Controlled_Access_Protocols">#</a>Controlled Access Protocols</h1>
<p>访问控制协议（Controlled Access Protocols）为统计复用提供了方法，主要分为三个类型：</p>
<ol>
<li>轮询（Polling）：控制中央持续的询问每一个终端是否要发送数据。</li>
<li>预留（Reservation）：终端需要发送信息时，发出一个在下一次循环时发送数据的申请。</li>
<li>令牌传递（Token Passing）：终端间循环传递一个令牌，当终端持有令牌时可以发送数据。</li>
</ol>
<h2 id="Polling"><a class="header-anchor" href="#Polling">#</a>Polling</h2>
<p><code>轮询（Polling）</code>系统是存在一个中央控制器，这个控制器会询问其下的每个终端是否需要传递数据。轮询可以再细分为两种，<code>轮询调度顺序（Round Robin Order）</code>和<code>优先顺序（Priority Order）</code>。在轮询调度顺序下，每个终端都有相同的机会传递数据，而在优先顺序下，一些终端会有更多的机会去传递数据。</p>
<p>轮询的算法实现伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">For Centralized Controller:</span><br><span class="line">while(true)</span><br><span class="line">&#123;</span><br><span class="line">  Select a station S, and send a polling message to S;</span><br><span class="line">  Wait for S to respond by sending a packet or passing;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Reservation"><a class="header-anchor" href="#Reservation">#</a>Reservation</h2>
<p><code>预留（Reservation）</code>系统多用在航天系统中，系统分为两个步骤，在第一步中需要传输数据的终端申请，所有申请的终端构成一张表，在第二步中表中的终端开始传输数据。通常第一步与第二步使用的是不同的信道，即有一个信道专门用来接受申请信息，另一个信道作为主信道传递每个终端的数据。</p>
<p>预留的算法实现伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">For Centralized Controller:</span><br><span class="line">While(true)</span><br><span class="line">&#123;</span><br><span class="line">  Form a list of stations that have a packet to send;</span><br><span class="line">  Allow stations on the list to tranmit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Token_Passing"><a class="header-anchor" href="#Token_Passing">#</a>Token Passing</h2>
<p><code>令牌传递（Token Passing）</code>被用在多个局域网（LAN）技术中，被用的最多的就是环形拓步结构中。在一个网络中，某一台计算机持有着一个特殊的控制命令，这个命令被称作为令牌，持有令牌的计算机可以发送数据，在发送完毕后将令牌传递给下一个计算机。</p>
<p>令牌传递的算法实现伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">For each computer:</span><br><span class="line">While(true)</span><br><span class="line">&#123;</span><br><span class="line">  Wait for the token to arrive;</span><br><span class="line">  Transmit a packet if one is waiting to be send;</span><br><span class="line">  Send the token to he next station;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>环形拓补结构中，存在物理的环形链接，所以令牌可以直接传递给相邻的下一个电脑。在其他的拓步结构中，所有的计算机都被赋予了一个逻辑顺序，因此可以获知下一个要收取令牌的电脑是哪个。</p>
<h1 id="Random_Access_Protocols"><a class="header-anchor" href="#Random_Access_Protocols">#</a>Random Access Protocols</h1>
<p>许多网络，特别是局域网络中，并不使用访问控制协议，而使用<code>随机访问协议（Random Access Protocols）</code>。随机访问协议下只有当终端存在数据要发送时，才会被给予权限（在访问控制协议中，每个终端都要被持续检查）。这里的<em>随机</em>是在所有终端都有数据要发送时的处理方式。随机访问协议也可以被分为三类：</p>
<ol>
<li>ALOHA：早期夏威夷的无线电网络中被使用的协议。在教科书中比较流行，因为便于分析，但在实际网络中已不再使用。</li>
<li>CSMA/CD（Carrier Sense Multi-Access With Collision Detection）：原以太网的基础，现在也不再使用。</li>
<li>CSMA/CA（Carrier Sense Multi-Access With Collision Avoidance）：Wifi无线网络的基础。</li>
</ol>
<h2 id="ALOHA"><a class="header-anchor" href="#ALOHA">#</a>ALOHA</h2>
<p>在早期夏威夷的网络中使用，在这个系统下有一个强大的发送器被部署中在物理上的中心位置，其他的终端（通常对应一台计算机）在这个发送器周围部署，这些终端都没有足够的能量将数据直接传输给其他终端，因此需要通过中央的发送器。</p>
<p>中央发送器用两个载波频率与每个终端通信，一个被称为入站频率（In Frequency，407.305MHZ），一个被称为出站频率（Outbound Frequency，413.475MHZ）。终端通过入站频率将数据传递给中央发送器，中央发送器通过出站频率将数据发送给每个终端。</p>
<p>ALOHA的实现逻辑很直接：当终端有数据要发送时，使用入站频率将数据传递给中央数据站，中央数据站通过出站频率将数据传给所有的终端，终端检查数据是否是自己需要的。为了保证数据被正常发送，发送终端也需要监听出站频率，当发送的数据拷贝被传输回发送终端，发送终端确认数据被正常传递了，就会传输下一个数据。反之，则会在一段时间后尝试重新发送。</p>
<p>当两个终端同时使用各自的入站频率传输数据时，两个数据会发送混淆，进而导致信息错误，将这种情况称为信道冲突（Collision）。协议通过等待一段时间后重新发送数据来解决冲突，重新发送数据前的等待时间的设定尤为关键，如果两个终端等待的时间相同，那么再次发送数据时仍然是同时发送则会继续导致冲突。因此等待时间是随机的，但是网络繁忙时，冲突的概率仍然会增加，因为即使是随机时间仍然可能会与其他的终端发生冲突。</p>
<p>ALOHA示意图如下：</p>
<p><img src="/ch_14_the_ieee_mac_sublayer/2019-12-28-12-56-15.png" alt="ALOHA示意图"></p>
<h2 id="CSMA_CD"><a class="header-anchor" href="#CSMA_CD">#</a>CSMA/CD</h2>
<p>1978年，数字设备联盟（Digital Equipment Corporation），英特尔（Intel）和施乐（Xerox）共同指定了个标准（DIX标准），也就是后来的以太网。最早的以太网技术使用一根长电缆连接每个电脑，这根长电缆就是共享媒介，与ALOHA使用中央发送器来实现数据传输不同，在以太网中每个终端都可以通过这个共享的线缆传输数据。以太网同样需要解决冲突问题，以太网主要引入了三个解决冲突的方法，统称为<code>具有冲突检测功能的载波侦听多路访问（CSMA/CD，Carrier Sense Multi-Access With Collision Detection）</code>：</p>
<ol>
<li>载波侦听（Carrier Sense）：</li>
</ol>
<p>在每个终端发送数据前，先监听线缆确定是否有其他的终端正在传输数据。</p>
<ol start="2">
<li>冲突检测（Collision Detection）：</li>
</ol>
<p>虽然有载波侦听，但如果在线缆空闲时，两个需要发送数据的终端同时监听，此时他们都发现线缆空闲，因此都开始传输数据，这时候仍然会造成冲突。因此在传输过程中，发送终端也会持续的监听线缆，如果发现线缆中的数据与发送的数据不同，说明已经发生了冲突，数据被干扰了，于是停止数据的发送。</p>
<p>以太网的数据传输还有一些细节问题，如在检测到冲突时，发送端并不会立刻停止数据的发送，他仍然会传输数据一段时间，保证所有的其他终端都可以收到冲突信号。另外，当一个包被发送完后，发送终端需要等待一段时间，称为<code>包间间隙（Interpacket gap）</code>（在早期10Mbps的以太网中，包间间隙为9.6微秒），保证其他的终端可以检测到线缆的空闲并传递数据。</p>
<ol start="3">
<li>二进制指数补偿（Binary Exponential Backoff）</li>
</ol>
<p>如ALOHA一样，在发现了冲突后，发送端需要等待一段时间重新发送数据，这个等待时间是随机的，通常会设置一个最大延迟时间$d$，然后在$0\sim d$。如之前所述，在网络繁忙时，可能存在随机后终端仍然冲突的情况。二进制指数补偿是指在新一次冲突发生后，随机的范围变成$0\sim 2d$，如果再有冲突则变成$0\sim 4d$，依次类推。</p>
<p>CSMA/CD算法实现伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">For each Computer:</span><br><span class="line"></span><br><span class="line">Wait for a packet to be ready;</span><br><span class="line">Wait for the medium to be idle;</span><br><span class="line">Delay for the interpacket gap;</span><br><span class="line">Set x to be the standard backoff range d;</span><br><span class="line">Attempt to transmit the packet;</span><br><span class="line"></span><br><span class="line">While(Collision occured)</span><br><span class="line">&#123;</span><br><span class="line"> random a delay time q from 0 to x;</span><br><span class="line"> delay for q microseconds;</span><br><span class="line"> double x to be 2x</span><br><span class="line"> attempt to retransmit the packet</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CSMA_CA"><a class="header-anchor" href="#CSMA_CA">#</a>CSMA/CA</h2>
<p>CSMA/CD并不能被运用在无线网络中，因为无线网络中的设备存在一个最远距离$\delta$。即如果两个终端的距离大于$\delta$，则CSMA/DA中的载波监听就无法被应用，因为一个终端并不能知道另一个是否在发送信息。这种情况如下图所示，如果Computer1在发送信息，Computer3是无法得知的，因此冲突只有Computer2可以知晓，这种情况称为<code>隐藏终端问题(Hidden Station Problem)</code>。</p>
<p><img src="/ch_14_the_ieee_mac_sublayer/2019-12-28-15-00-02.png" alt="隐藏终端问题"></p>
<p>所以无线网络中使用<code>具有冲突规避的载波侦听多路访问（CSMA/CA，Carrier Sense Multi-Access With Collision Avoidance）</code>。以上图的例子，Computer3在发送数据前会先向所有它的$\delta$范围内的设备发出一个短信息表明自己需要发送数据了，接受到Computer3发出的短信息的设备会检查自己是否正在接受其他的数据，如果不是则回复可以发送的信号。如下图所示：</p>
<p><img src="/ch_14_the_ieee_mac_sublayer/2019-12-28-15-08-19.png" alt="CSMA/CA图解"></p>
<p>如果发送端没有收到接收方的回执，则会在随机时间后再次尝试发送。</p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《Computer Networks and Internets》 Ch 16 无线网络技术</title>
    <url>/ch_16_wireless_networking_technologies/</url>
    <content><![CDATA[<h1 id="Introduction"><a class="header-anchor" href="#Introduction">#</a>Introduction</h1>
<p>这一章主要介绍计算机网络无线部分的技术。</p>
<p>$16.2$节对无线技术依据网络的覆盖范围做了分类。<br>
$16.3$节介绍了个人局域网。<br>
$16.4$节介绍了ISM频域。<br>
$16.5\sim16.11$都是介绍局域网相关技术，主要关注对象是Wifi技术。<br>
$16.12$介绍了城域网中使用的WiMax技术。<br>
$16.13$给出了个人局域网的标准分类列表。<br>
$16.14$介绍了两个没有被包含在个人局域网中的短距离通信，红外线和射频识别通信。<br>
$16.15\sim16.18$介绍了广域网技术，主要关注蜂窝式网络。<br>
$16.19和16.20$介绍了卫星通信。<br>
$16.20$介绍了软件无线电系统。</p>
<h1 id="A_Taxonomy_Of_Wireless_Networks"><a class="header-anchor" href="#A_Taxonomy_Of_Wireless_Networks">#</a>A Taxonomy Of Wireless Networks</h1>
<p>计算机网络无线技术的变种非常多的原因之一在于因为政府的管理，电磁信号的频谱被切分为了许多不同的部分以供不同的目的使用，而这些不同频域的技术通常都不同。</p>
<p>无线技术通常通过其使用的范围来分类，主要可分为：<code>局域网（Local Area Networks,LANs）</code>，<code>城域网（Metropolitan Area Networks,MANs）</code>，<code>广域网（Wide Area Networks，WANs</code>）以及<code>个人局域网（ Personal Area Networks，PANs）</code>。如下图所示：</p>
<p><img src="/ch_16_wireless_networking_technologies/2019-12-30-15-51-47.png" alt="无线网络分类"></p>
<h1 id="Personal_Area_Networks（PANs）"><a class="header-anchor" href="#Personal_Area_Networks（PANs）">#</a>Personal Area Networks（PANs）</h1>
<p>上节中对于无线网络的分类与在第十三章中对于网络的分类十分类似，不同的是这里还引入了个人局域网（Personal Area Networks，PANs）的概念。个人局域网是提供非常短距离下的通信，通常是只供一个用户使用，如蓝牙耳机就属于个人局域网的应用。</p>
<p>个人局域网络可以再细分为以下几种：</p>
<ol>
<li>蓝牙（Bluetooth）：距离较短</li>
<li>红外线（Infrared）：视距通信（Line-Of-Sight Communication）即发射端和接收端之间需要无遮挡</li>
<li>紫峰（ZigBee）：距离可以支撑一个住宅的范围，在智能家居中被运用。</li>
<li>其他ISM无线技术：为工业，科学以及医药（Industrial，Scientific，Medical，ISM）预留的频率发展的技术。</li>
</ol>
<h1 id="ISM_Wireless_Bands_Used_By_LANs_And_PANs"><a class="header-anchor" href="#ISM_Wireless_Bands_Used_By_LANs_And_PANs">#</a>ISM Wireless Bands Used By LANs And PANs</h1>
<p>振幅为了工业，科学以及医药领域专门预留了一部分频域，被称为ISM无线。这部分的频域并没有再进一步细分，如科学只能用哪一段频域之类。这三个领域的产品都可以使用这部分频域，具体频域如下图所示：</p>
<p><img src="/ch_16_wireless_networking_technologies/2019-12-30-16-04-51.png" alt="ISM频域"></p>
<h1 id="Wireless_LAN_Technologies_And_Wi_Fi"><a class="header-anchor" href="#Wireless_LAN_Technologies_And_Wi_Fi">#</a>Wireless LAN Technologies And Wi-Fi</h1>
<p>IEEE将局域网下的无线网络协议分类在$802.11$下。1999年一些销售商建立了Wifi联盟，一个生产和验证使用802.11协议的无线设备的非盈利组织。因为这个联盟的产品在商业市场上反应很好，消费者将Wifi一词与无线局域网联系在了一起，Wifi原先是产品广告词中<code>Wireless Fidelity</code>的缩写。</p>
<p>下表为Wifi联盟所指定的协议：</p>
<p><img src="/ch_16_wireless_networking_technologies/2019-12-30-16-21-32.png" alt="Wifi联盟协议"></p>
<h1 id="Spread_Spectrum_Technology"><a class="header-anchor" href="#Spread_Spectrum_Technology">#</a>Spread Spectrum Technology</h1>
<p>在第十一章中提到的展频技术（Spread Spectrum Technology）在wifi技术中也有应用。</p>
<p>展频技术的原理是发送端将原先的信道频域再细分为多个部分，将数据通过不同的频率发送出去，接收端接受多个频率的数据，再还原出原信号。使用展频技术主要目的有两个，一是增加传输速率，另外是增加对噪声的抗干扰能力。</p>
<p>Wifi技术主要用了以下扩频技术，其主要目的还是帮助Wifi在有噪声环境下能更好的工作：</p>
<ol>
<li>
<p>直接扩频（Direct Sequence Spread Spectrum，DSSS）：</p>
<p>发送端使用一个序列码得到不同的频率，用这些频率来发送数据。</p>
</li>
<li>
<p>跳频扩频（Frequency Hopping Spread Spectrum，FHSS）：</p>
<p>载波的频率一直在设定的几个频率间切换。</p>
</li>
<li>
<p>正交频率复用（Orthogonal Frequency Division Multiplexing，OFDM）：</p>
<p>将原信道分为多个小信道，每个小信道传输一部分的数据。</p>
</li>
</ol>
<ul>
<li>书中并未对三个技术做详细的解释，上面的概括解释也可能存在错误。</li>
</ul>
<p>三个技术都有各自的优点，OFDM有最高的适用性，DSSS性能好，FHSS对于噪声的抗干扰能力强。</p>
<h1 id="Other_Wireless_LAN_Standards"><a class="header-anchor" href="#Other_Wireless_LAN_Standards">#</a>Other Wireless LAN Standards</h1>
<p>除了上述Wifi联盟所指定的协议，无线局域网还有其他许多的协议，都属于$802.11$协议分类下如下图所示：</p>
<p><img src="/ch_16_wireless_networking_technologies/2019-12-30-16-48-56.png" alt="其他802.11协议"></p>
<h1 id="Wireless_LAN_Architecture"><a class="header-anchor" href="#Wireless_LAN_Architecture">#</a>Wireless LAN Architecture</h1>
<p>局域网无线网络结构主要有三个因素：（1）<code>接入点（Access Point）</code>，有时也被称为<code>基站（Base Station）</code>。（2） <code>互联机制（Interconnection mechanism）</code>，例如路由器或者交换机，用来将接入点连接在一起。（3）一系列<code>终端（Hosts）</code>，如个人手机就是一个终端。</p>
<p>存在两种无线局域网，一是<code>自主网（Ad hoc）</code>，其中所有的终端都可以在没有接入点的情况下相互通信。另外一个是<code>基础设施结构（Infrastructure）</code>。</p>
<p>在实际运用中，自主网很少存在，基础设施结构如下图所示，图中的$AP$即为接入点（Access Point），一个接入点和连接它的一系列终端称为<code>基本服务集（Basic Service Set，BSS）</code>。</p>
<p><img src="/ch_16_wireless_networking_technologies/2019-12-30-16-59-39.png" alt="基础设施结构"></p>
<h1 id="Overlap，Association，And_802_11_Frame_Format"><a class="header-anchor" href="#Overlap，Association，And_802_11_Frame_Format">#</a>Overlap，Association，And 802.11 Frame Format</h1>
<p>在实际运用中，基础设施结构中的接入点如果距离太远，会出现<code>无服务区（Dead Zone）</code>，距离太仅的话，他们的覆盖的范围会出现重叠（Overlap），因此终端可能会同时存在于两个接入点的范围内。在这种情况下，终端需要指定他与哪个接入点进行通信，因此在$802.11$协议定义的网络帧格式下，帧数据必须包含其连接的接入点的MAC地址。</p>
<p>另外如果基础设施结构是要连接外网的，那么接入点的互联机制还需要另外一个有线连接至与外网连接的路由器，如下图所示，下图也同时展示了上述的接入点重叠情况</p>
<p><img src="/ch_16_wireless_networking_technologies/2019-12-30-17-06-11.png" alt="外网连接以及接入点重叠"></p>
<p>$802.11$的定义的数据帧，还需要指定连接外网的路由器的MAC地址，综上数据帧的结构如下：</p>
<p><img src="/ch_16_wireless_networking_technologies/2019-12-30-17-07-42.png" alt="802.11数据帧"></p>
<h1 id="Coordination_Among_Access_Points"><a class="header-anchor" href="#Coordination_Among_Access_Points">#</a>Coordination Among Access Points</h1>
<p>如上节所述，在接入点重叠的情况下，终端需要决定与哪个接入点进行通信。</p>
<p>主要有两种方法来实现接入点的切换，第一个是靠接入点本身，接入点能相互通信，当接入点发现有终端同时收到多个接入点信号时，接入点会判断信号强度然后帮助终端无缝切换，这种方法实现较为复杂且成本较高。第二种方法下，所有接入点都是独立的，切换是靠终端本身实现，这种方法的成本较低。</p>
<h1 id="Contention_And_Contention_Free_Access"><a class="header-anchor" href="#Contention_And_Contention_Free_Access">#</a>Contention And Contention-Free Access</h1>
<p>$802.11$定义了两种信道访问的方式：无竞争（Contention-Free）的点协调方式（Point Coordinated Function，PCF）和存在竞争的分布协调方式（Distributed Coordinated Function，DCF）。</p>
<p>PCF方式保证在一个基本服务集中的接入点保证下面的终端不会发生任何干扰，例如通过给每一个终端一个特定的频率来实现。但在实际中PCF从来都没有被使用过。</p>
<p>DCF则是让一个基本服务集中的终端都使用<code>随机访问协议（Random Access Protocols）</code>。并如同在十四章中的介绍，因为$802.11$是无线网络，所以通常使用的是CSMA/CA，终端需要发送准备完毕（Ready to Send，RTS）和信道空闲（Clear To Send，CTS）两种控制命令。</p>
<p>$802.11$中使用的CSMA/CA还包含一些在十四章未提及的细节，如定义了以下三个时间参数：</p>
<ol>
<li>
<p>短帧时间间隔（Short Inter-Frame Space,SIFS）为10微秒。</p>
<p>接收端在发送确认信息（Acknowledge，ACK）或其他控制命令前的等待时间。</p>
</li>
<li>
<p>帧间间隔（Distributed Inter-Frame Space）为50微秒。</p>
<p>在发送端发送数据前必须等待的时间，以保证其他的终端可以监听到信道的空闲。</p>
</li>
<li>
<p>时隙（Slot Time）为20微秒</p>
</li>
</ol>
<p>Wifi网络中所使用的CSMA/CA如下图所示：</p>
<p><img src="/ch_16_wireless_networking_technologies/2019-12-30-21-20-32.png" alt="Wifi网络中所使用的CSMA/CA"></p>
<p>因为各终端间的物理间隔以及环境噪声，微弱信号的检测是很困难的，因此Wifi网络并没有引入CSMA/CA中的冲突检测（Collision Detection）部分，即发送端并不会在数据发送过程中监听信道来判断是否有冲突。在Wifi网络中，发送端会等待ACK信号，如果没有收到ACK信号，发送端则认为数据发送失败。</p>
<h1 id="Wireless_MAN_Technology_And_WiMax"><a class="header-anchor" href="#Wireless_MAN_Technology_And_WiMax">#</a>Wireless MAN Technology And WiMax</h1>
<p>城域网技术的协议被反类在$802.16$中。如同在局域网中主要使用的是Wifi，在城域网中主要使用的事WiMax（World-wide Interoperability For Microwave Access）技术。</p>
<p>WiMax可以再被细分为固定WiMax和移动WiMax，前者是指服务提供方与连接者的位置是固定的，如大楼间的通信，后者则指接收方是可以移动的，如用户的手机和电脑等。</p>
<p>WiMax在城域网中的使用，如果是用在回传网络（服务提供方之间的连接，通常需要较高的数据速率）中则需要无阻碍（Line-Of-Sight，LOS）的连接，如果是在服务提供方与接入点直接的连接则也可以使用有阻碍的连接（Non-Line-Of-Sight，NLOS），如下图所示：</p>
<p><img src="/ch_16_wireless_networking_technologies/2019-12-30-22-02-35.png" alt="WiMax的使用"></p>
<h1 id="PAN_Technologies_And_Standards"><a class="header-anchor" href="#PAN_Technologies_And_Standards">#</a>PAN Technologies And Standards</h1>
<p>PAN技术被分类在$802.15$分类下，如下图所示：</p>
<p><img src="/ch_16_wireless_networking_technologies/2019-12-30-22-04-05.png" alt="PAN技术"></p>
<h1 id="Other_Short_Distantce_Communication_Technologies"><a class="header-anchor" href="#Other_Short_Distantce_Communication_Technologies">#</a>Other Short-Distantce Communication Technologies</h1>
<p>还有两种技术短距离的通信方式并没有被分类在PANs下，红外通信（Infrared Data Association，IrDA）以及射频识别（Radio Frequency Identification，RFID）通信。</p>
<p>红外通信是方向性的，大约有30°的范围，而且信号可以在障碍物表面反射，但是并不能传统障碍物。电视遥控器即是使用了红外通信。</p>
<p>射频识别通信，是一个芯片中包含有验证信息的Tag，接收方可以将信息从芯片中读取出来。酒店的门禁卡，大学食堂的饭卡等都是使用了这个技术。</p>
<h1 id="Wireless_WAN_Technologies"><a class="header-anchor" href="#Wireless_WAN_Technologies">#</a>Wireless WAN Technologies</h1>
<p>广域网通信有两大类，蜂窝式通信系统（Cellular communication systems）和卫星通信系统（Satellite communication system）。</p>
<p>蜂窝式通信系统最早是为了满足手机的电话服务设计的。在这个系统下，地区被风格为一个个小块称为<code>巣室（Cell）</code>，每个巣室都包含一个基站塔，一系列基站塔由一个移动交换中心控制。这个中心会追踪用户，并在用户从一个巣室进入另一个巣室时，提供巣室的切换服务。蜂窝式系统的结构如下图：</p>
<p><img src="/ch_16_wireless_networking_technologies/2019-12-30-22-18-47.png" alt="蜂窝式系统结构"></p>
<p>理论上每个巣室都是六边形的，那么就能无缝的分割区域，但在实际运用中，每个基站塔的覆盖范围大致是圆形的，因此就会出现重叠或者无服务区。且基站塔的覆盖范围由所处区域的用户数量决定，如果用户数量很多，则每个基站塔的覆盖范围会较小，且有更多的基站塔，反之每个基站塔覆盖很大一块区域。理论和实际的巣室图如下，（a）图为理想情况，（b）图为实际情况：</p>
<p><img src="/ch_16_wireless_networking_technologies/2019-12-30-22-21-33.png" alt="巣室情况"></p>
<h1 id="Micro_Cells"><a class="header-anchor" href="#Micro_Cells">#</a>Micro Cells</h1>
<p>如上节所述，用户密度越大，则设计时每个巣室的面积越小。在城市中，有时会出现一个巣室仅覆盖大楼的一层这种情况，这是称其为微巣室（Micro Cells）。因为巣室很小且很小块区域内有多个巣室，为了避免干扰，微巣室的功率都比较小。</p>
<h1 id="Cell_Clusters_And_Frequency_Reuse"><a class="header-anchor" href="#Cell_Clusters_And_Frequency_Reuse">#</a>Cell Clusters And Frequency Reuse</h1>
<p>蜂窝式通信有一个重要原则：相邻的巣室在不使用相同频率的载波情况下，干扰最小。</p>
<p>蜂窝式系统使用称为巣室簇的结构构成，每个巣室簇都由特定数目的巣室构成，其中的每个巣室频率都不同。通常而言，巣室簇由3，4，7或12个巣室构成，如下图所示：</p>
<p><img src="/ch_16_wireless_networking_technologies/2019-12-30-23-19-08.png" alt="巣室簇"></p>
<p>巣室簇中的每个巣室频率不同，将巣室簇拼接后就不会有相邻巣室频率相同的情况出现，如下图为7巣室簇拼接：</p>
<p><img src="/ch_16_wireless_networking_technologies/2019-12-30-23-20-04.png" alt="巣室簇拼接"></p>
<h1 id="Generations_Of_Cellular_Technologies"><a class="header-anchor" href="#Generations_Of_Cellular_Technologies">#</a>Generations Of Cellular Technologies</h1>
<p>目前通信技术的发展有四代，称为1G,2G,3G和4G：</p>
<ol>
<li>1G：出现在1970年代后期，通过模拟信号传递语音信息。</li>
<li>2G和2.5G：从1990年代早期开始发展，至今仍然在使用。与1G的主要区别在于，2G使用了数字信号传递语音信息。2.5G是2G的扩展，实现了部分3G的特性。</li>
<li>3G和2.5G：从2000年开始发展，主要关注高速数据服务。3G系统提供400Kbps到2Mbps的数据速度。</li>
<li>4G：从大约2008年开始使用，主要关注实时媒体的使用，如电视直播，高速视频下载等。4G手机通常包含多种数据连接方式，如Wifi和卫星通信。</li>
</ol>
<p>在2G技术发展过程中，许多组织都尝试定义标准，欧洲主要使用TDMA技术并制订了GSM标准（Global System For Mobile Communication），该标准逐渐称为了全球标准。在美国，摩托罗拉使用TDMA技术定义了iDEM标准。同时大部分其他的美国运营商和亚洲运营商都使用了CDMA技术来指定标准。</p>
<p>在3G时代，EVDO（Evolution Data Optimized/Evolution Data Only）和EVDV标准几乎同时出现，两者都是CDMA和FDM技术的混合。EVDO技术被运用的较为广泛。</p>
<p>在设计4G标准时，国际通信协会（ITU）指定了4G蜂窝式系统的标准，称为<code>IMT-Advanced（International Mobile Telecommunication Advaced）</code>。其指定终端在高速移动时（如在火车上）应该有100Mbps的数据速率，而在静止时应该有100Mbps的速率。</p>
<p>在早期，运营商指定的4G标准，如<code>HSPA+</code>，<code>HTC Evo 4G</code>，<code>WiMax</code>和<code>LTE（Long Term Evolution）</code>都未满足要求。但是ITU还是允许了他们使用4G作为自己的广告语，在后期，<code>LTE-Advanced</code>和<code>WiMax Advanced</code>满足了ITU的标准，被称为真4G。</p>
<p>3G和4G的主要区别在于，3G系统设计时仍然是基于语音通话系统考虑的，还是继承自原先的模拟电话系统，其他的数据是作为额外的要求。而在4G标准设计时主要考虑因特网协议，因此4G系统使用了帧交换而语音只是作为一个特殊应用。在实际应用中，许多蜂窝系统仍然通过3G来传输通话信息，而在其他数据时使用4G。</p>
<h1 id="VSAT_Satellite_Technology"><a class="header-anchor" href="#VSAT_Satellite_Technology">#</a>VSAT Satellite Technology</h1>
<p>卫星通信的关键是用一个曲面天线（Parabolic antenna/Dish）保证电磁信号被反射到一个单一点上，如下图所示：</p>
<p><img src="/ch_16_wireless_networking_technologies/2019-12-30-23-39-52.png" alt="曲面天线"></p>
<p>为了最大化收集到的信号，早期的卫星通信系统使用直径大于3米的曲面天线，但这种尺寸的天线并不适用于个人或小商家。于是称为<code>甚小口径天线终端（Very Small Aperture Terminal，VSAT）</code>的技术出现，它指代直径小于3米的曲面天线，通常直径在1米以下。</p>
<p>VSAT卫星通信选择的频率不同会影响信号强度，天气环境变化的敏感程度，和信号的覆盖范围（Satellite’s footprint）。如下表所示：</p>
<p><img src="/ch_16_wireless_networking_technologies/2019-12-30-23-45-24.png" alt="VSAT卫星频率"></p>
<h1 id="GPS_Satellites"><a class="header-anchor" href="#GPS_Satellites">#</a>GPS Satellites</h1>
<p>GPS（Global Positioning System）卫星提供实时的准确位置信息。GPS通信并非是计算机通信的一部分，但是越来越多的移动网络使用了位置信息。</p>
<p>GPS系统通过三颗卫星计算出终端的位置。首先要计算终端距离三颗卫星的距离，距离可以通过卫星与终端的传输时间乘上光速来确定。如果一个终端与卫星的距离为$d$，则终端出现在以卫星为球星，半径为$d$的球上任意位置。通过三个卫星，可以计算出三个球，三个球的交点为两个点（两个球的交点为一个圆形）。这两个交点，一个在太空中，一个在地球上，地球上的点即为终端的位置。</p>
<h1 id="Software_Defined_Radio_And_The_Future_Of_Wireless"><a class="header-anchor" href="#Software_Defined_Radio_And_The_Future_Of_Wireless">#</a>Software Defined Radio And The Future Of Wireless</h1>
<p>通常一个蜂窝网络手机需要指定天线，发射器和接收器的规格，这些数据都是需要预先指定的。如果同时支持GSM，Wifi和CDMA，则需要三套独立的无线电系统，使用时在其中切换。</p>
<p>现在传统的无线电系统被软件无线电取代，可以通过软件来指定的特性如下表所示：</p>
<p><img src="/ch_16_wireless_networking_technologies/2019-12-30-23-53-54.png" alt="软件无线电可以设定的特性"></p>
<p>软件无线电的一大特性是可以同时使用多个天线，称实现了多天线同时传输和接受的系统为<code>MIMO（Multiple-Input Multiple-Output）</code>系统。</p>
<p>通过软件来设定通信特性也有一定的危险性，如用户可以选择被政府限制的频率来发送数据或者占据为紧急服务预留的频道。因此这个技术也需要严格规范。</p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《Computer Networks and Internets》 Ch 17 中继器，网桥和交换机</title>
    <url>/ch_17_repeaters,_bridges,_and_switches/</url>
    <content><![CDATA[<h1 id="Introduction"><a class="header-anchor" href="#Introduction">#</a>Introduction</h1>
<p>这一章会介绍关于扩展 LAN 的方法，如中继器（Repeaters）和网桥（Bridges），也会介绍在网桥存在循环时解决死循环的<code>生成树算法(Spannning tree algorithms)</code>。最后会讨论交换机和网桥之间的关系。</p>
<h1 id="Distance_Limitation_And_LAN_Design"><a class="header-anchor" href="#Distance_Limitation_And_LAN_Design">#</a>Distance Limitation And LAN Design</h1>
<p>距离限制是 LAN 计算的核心，工程师们需要从最大延迟，信道容量和传输距离间做权衡。因为 LAN 中的硬件设备的发送功率是固定的，所以如果两个设备之间的电缆长度增加，其中的信号强度就会减弱，导致错误的发生。</p>
<h1 id="Fiber_Modem_Extensions"><a class="header-anchor" href="#Fiber_Modem_Extensions">#</a>Fiber Modem Extensions</h1>
<p>解决 LAN 距离的方法通常不是增加信号的强度也不是增加电缆，而是增加额外的硬件设备来转播信号。</p>
<p>最简单的 LAN 扩展方法是通过一根光纤和一堆光纤调制解调器，如下图所示：</p>
<p><img src="/ch_17_repeaters,_bridges,_and_switches/2020-01-03-08-27-17.png" alt="光纤调制解调器扩展"></p>
<p>一个光纤调制解调器与计算机设备连接，另一个光纤调制解调器与通向以太网的交换机或集线器连接，两个光纤调制解调器用光纤连接。这样计算机设备就能与以太网进行连接。</p>
<h1 id="Repeaters"><a class="header-anchor" href="#Repeaters">#</a>Repeaters</h1>
<p>中继器（Repeaters）是一个用来传播 LAN 信号的模拟设备，中继器并不理解包和 Bit 数据，它只是将接受到的信号放大再传播出去。</p>
<p>一个中继器的典型应用就是使用遥控器控制其他房间的设备，将中继器放置在另一个房间，在遥控器所在房间，将 Sensor 通过线缆与中继器相连。当本房间的 Sensor 搜到信号后，信号后传输给中继器，中继器放大后传播出去，另一个房间的设备就会收到，如下图所示：</p>
<p><img src="/ch_17_repeaters,_bridges,_and_switches/2020-01-03-08-35-01.png" alt=""></p>
<h1 id="Bridges_And_Bridging"><a class="header-anchor" href="#Bridges_And_Bridging">#</a>Bridges And Bridging</h1>
<p>网桥（Bridges）是连接两组 LAN 设备（如两个集线器）并且在它们之间传输包的方法。网桥是以混杂模式监听每组 LAN 设备，即数据发送给其下的任意一个设备，该数据都会被网桥检测到。因此，被网桥连接的两组设备表现如同是一组设备，即一组中的设备可以发送数据给另一组设备，且当一个设备广播时，两组设备中的所有设备都能接受到。而在网桥下的设备是无法区分自己是在一个单一的一组设备下（如只是在集线器下）还是在网桥下。</p>
<ul>
<li>这里将书中描述的 Segment 翻译为一组设备，如一个集线器下的设备。</li>
</ul>
<p>网桥连接的示意图如下：</p>
<p><img src="/ch_17_repeaters,_bridges,_and_switches/2020-01-03-09-14-18.png" alt=""></p>
<h1 id="Learning_Bridges_And_Frame_Filtering"><a class="header-anchor" href="#Learning_Bridges_And_Frame_Filtering">#</a>Learning Bridges And Frame Filtering</h1>
<p>虽然网桥是以混杂模式监听，且可以让两组设备表现的如同在同一组，但是网桥并不会盲目的将数据从一组设备传递给另一组。网桥监听到数据后会针对包的目标 MAC 地址过滤数据，仅将数据发送给需要的一组设备。当让，在广播或者多播模式下，网桥直接将数据发送给两个设备的，以保证广播或者多播的正常运行。</p>
<p>大多数网桥被称为自适应网桥（Adaptive/Learning Bridges），因为他们可以自动识别出每个设备是处于哪个分组下。当一个数据包经过网桥时，网桥会读取源地址，然后判断两组设备列表中是否有该发送设备，如果没有，则将发送设备放在符合的设备列表下。同时也会读取目标地址，决定数据需要发送给哪部分设备，如果目标地址在两组设备列表中都不存在，则两组设备都会收到网桥的转发的数据。</p>
<p>下表是发送网桥发送数据的例子。在第一行即网桥启动时，两组数据的列表都是空的。第二行即数据从 A 设备发送给 B 设备，此时先检测出将发送端 A 是在 Segment1 中，但此时 B 不在任何列表中，所以数据会发送给两个部分。第三行即数据从 B 设备发送给 A 设备，先检测出发送端 B 设备是再 Segment1 中，而 A 也在 Segment1 种，所以数据只要在 Segment1 中传输即可。同理可以分析其他的发送数据。</p>
<p><img src="/ch_17_repeaters,_bridges,_and_switches/2020-01-03-09-30-16.png" alt="网桥数据发送"></p>
<h1 id="Why_Bridging_Works_Well"><a class="header-anchor" href="#Why_Bridging_Works_Well">#</a>Why Bridging Works Well</h1>
<p>当网桥知道其下的所有设备处于哪个部分后，数据在网桥之间的传输效率要大于数据在真正的单一分组中的传输。</p>
<p>以上节中的示意图为例，当网桥知道所有的设备处于哪个部分后，如果数据从 A 发送给 B，那么数据只要在 Segment1 中传输，同理如果数据从 X 发送给 Y，数据只要在 Segment2 中传输。因此，这两个传输行为是可以同时进行的，因为它们都只是发生在各自的部分中。而如果所有设备都是在一个真正的单一分组下，即 A，B，X，Y 是共享一个媒介传输，两个传输行为也就不可能同时发生。</p>
<p>因此可以将设备分组后，用网桥连接来增加数据传输的效率。</p>
<h1 id="Distributed_Spanning_Tree"><a class="header-anchor" href="#Distributed_Spanning_Tree">#</a>Distributed Spanning Tree</h1>
<p>如果一系列设备如下图所示连接（每个 HUb 下有多个设备，图中未展现）：</p>
<p><img src="/ch_17_repeaters,_bridges,_and_switches/2020-01-03-09-37-20.png" alt=""></p>
<p>可以看到图中的设备形成了一个循环，在这种情况下广播的数据会发生死循环。因为网桥收到广播数据后会直接向前传递，而在网桥形成循环后，每个网桥的直接向前传递就会导致信息始终在循环中传输。</p>
<p>为了解决这个问题，电子设备协会（Digital Equipment Corporation）在 1985 年为以太网设计了一个称为<code>生成树协议（Spannning Tree Protocol,STP）</code>的方法。STP 方法是通过算法从一系列网桥 STP 计算出一个<code>分布生成树（Distributed Spanning Tree）</code>。协议规定如果将包的广播地址设为<code>01:80:C2:00:00:00</code>即表示使用 STP 方法。STP 方法的步骤如下：</p>
<ol>
<li>
<p>先找到一个网桥作为根。</p>
<p>每个网桥都有一个 ID 地址，算法将 ID 最小的网桥作为根。</p>
<p>每个网桥的 ID 地址都由两部分组成，第一部分是 16bit 长的可配置优先级数字，第二部分是 48bits 长的 MAC 地址。当比较 ID 地址时，会首先判断第一部分，在第一部分相同的情况下判断第二部分。因为第一部分是可配置的，所以管理员是可以指定某一个网桥作为根的。</p>
</li>
<li>
<p>最短路径计算</p>
<p>每个网桥都计算自己与根网桥的最短路径。</p>
</li>
<li>
<p>传递数据</p>
<p>网桥之间的数据传递，只能由最短路径传输。</p>
</li>
</ol>
<p>在上图展示的循环中，如果 Hub1 广播数据，那么 Hub4 收到数据的通路就是$Hub1-&gt;Hub4$，而更长的路径，如$Hub1-&gt;Hub2-&gt;Hub3-&gt;Hub4$就会被禁止，因此更长的循环路径也同样会被禁止。</p>
<h1 id="Switching_And_Layer_2_switchers"><a class="header-anchor" href="#Switching_And_Layer_2_switchers">#</a>Switching And Layer 2 switchers</h1>
<p><code>桥接（bridging）</code>的概念可以帮助理解现代以太网的基础：<code>交换（switching）</code>。一个以太网交换机（Ethernet switch）有时也被称为二层交换机（Layer-2 switch）。交换机如同集线器一样，有多个接口，每个接口都与一个计算机相连。交换机和集线器的不同在于，集线器如模拟设备一样，是将电脑传输的信号传递出去，而交换机是数字设备，传递的是电脑的数据包。可以将集线器想象成一个共享媒介，而把交换器想象成一个由网桥连接的网络，其中每个部分都只有一台电脑。</p>
<p>交换机可以想象成如下图的结构，可以看到交换机的左侧是三个网桥，每个网桥连接两个设备：</p>
<p><img src="/ch_17_repeaters,_bridges,_and_switches/2020-01-03-10-22-38.png" alt=""></p>
<p>但上图只是一个概念图，实际中的交换机中并没有网桥，而是每个端口都于一个<code>智能接口（Intelligent Interface）</code>相连，然后有个中央光纤将所有的接口连接在一起，而且这光纤支持两两配对的接口间的同时传输（如之前提到的网桥连接的两部分间的设备可同时传输一样）。</p>
<p>每个智能接口都有处理器和内存，因此可以判断需要传递的路线以及在目标端口繁忙时缓存数据，如电脑 1 和电脑 2 同时要向电脑 3 传输数据，则电脑 1 或电脑 2 中的一台会先将要传输的数据缓存起来。实际的交换机结构如下：</p>
<p><img src="/ch_17_repeaters,_bridges,_and_switches/2020-01-03-10-27-51.png" alt=""></p>
<p>交换机相对于集线器最大的优点在于并行。集线器在同一时间只能支持一个传输，而交换机可以同时进行多个独立的传输（这里的独立指不会有多个来自于不同地址的数据要发送给同一端口）。因此如果一个交换机有$N$个端口，最多可以有$N/2$个传输同时进行。</p>
<h1 id="VLAN_Switchers"><a class="header-anchor" href="#VLAN_Switchers">#</a>VLAN Switchers</h1>
<p>当一个交换机被扩展了虚拟功能，即称为虚拟局域网交换机（Virtual Local Area Network Switch,VLAN Switcher）。虚拟局域网交换机的功能就是让单一的交换机模拟成是多个独立的交换机，即管理者可以将一台交换机的其中某几个端口定义是在一个模拟局域网中，而另几个端口是在另外一个模拟局域网中，这样的话其中一个模拟局域网中的设备发送广播数据，另一个模拟局域网中的端口并不会接受到信息。</p>
<p>这种通过 VLAN 切分广播域的做法在公司环境下很关键，如一层楼只有一个交换机，但广播数据的发送并不希望整层楼都能收到。</p>
<h1 id="Multiple_Switchers_And_Shared_VLANs"><a class="header-anchor" href="#Multiple_Switchers_And_Shared_VLANs">#</a>Multiple Switchers And Shared VLANs</h1>
<p>交换机通常被部署在离计算机较近的地方，如每层楼都有一个交换机。在公司环境下有种情况是同一个部门可能处于不同的楼层，那么同一个部门的网络在不同的交换机下。在有多个交换机的情况下，上节中提到的 VLAN 会遇到问题。当只有一个交换机时，根据端口号分好 VLAN 后，数据的传输指定端口号就能判断出数据应该处于哪个 VLAN 中。但如果有两台交换机，两台交换机的同一端口，如端口 1，可能是在不同的 VLAN 下，因此光指定端口号是无法知道其到底在哪个 VLAN。</p>
<p>为了在多个交换机中使用 VLAN 技术，IEEE 扩展了以太网协议，记录在$802.1Q$中。该协议下，在以太网的数据包的头字段中，增加 16bit 长的数据表示 VLAN Tag，表示需要传递给 VLAN。在 802.1Q 协议下的以太网数据包如下图所示：</p>
<p><img src="/ch_17_repeaters,_bridges,_and_switches/2020-01-03-11-13-59.png" alt=""></p>
<p>即使是使用了多交换机的 VLAN，$802.1Q$协议下的以太网数据包仅在交换机之间传输，而在交换机与电脑间传输的包仍然是普通以太网数据包，因为只有交换机才能解析$802.1Q$数据。使用$802.1Q$实现 VLAN 的交换机如下图所示</p>
<p><img src="/ch_17_repeaters,_bridges,_and_switches/2020-01-03-11-15-56.png" alt=""></p>
<p>以上图为例，如果图中的 A，B，D，E 共处于 VLAN 17 中，当 A 广播数据后，B 会直接收到数据，然后交换机 1 会将$17$作为 VLAN Tag 插入到数据包头中，然后传递给交换机 2，交换机 2 在收到数据后，取出其中的 VLAN tag，并将包传递给 D 和 E。</p>
<h1 id="The_importance_Of_Bridging"><a class="header-anchor" href="#The_importance_Of_Bridging">#</a>The importance Of Bridging</h1>
<p>虽然现在很少会有厂商生产单独的网桥，但是桥接的概念已经被整合入网络设备中。如无线网络的路由器就整合了提供桥接功能的以太网的交换器，通常将其中交换机的端口称为<code>本地端口（Local Port）</code>，将连接网络调制解调器的端口称为<code>因特网端口（Internet Port）</code>。当两个本地的电脑传输数据时，无线路由器并不会将数据发送给网络服务商，而是直接将数据在本地进行传输（类似于桥接的分组功能）。</p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《Computer Networks and Internets》 笔记汇总</title>
    <url>/computer_networks_and_internets/</url>
    <content><![CDATA[<h1 id="Introduction_And_Internet_Applications"><a class="header-anchor" href="#Introduction_And_Internet_Applications">#</a>Introduction And Internet Applications</h1>
<p><a href="/ch_01_introduction_and_overview">Ch 01 Introduction And Overview</a></p>
<h1 id="Data_Communication_Basics"><a class="header-anchor" href="#Data_Communication_Basics">#</a>Data Communication Basics</h1>
<p><a href="/ch_05_overview_of_data_communications">Ch 05 Overview Of Data Communications</a></p>
<p><a href="/ch_06_information_sources_and_signals">Ch 06 Information Sources And Signals</a></p>
<p><a href="/ch_07_transmission_media">Ch 07 Transmission Media</a></p>
<p><a href="/ch_08_reliability_and_channel_coding">Ch 08 Reliability And Channel Coding</a></p>
<p><a href="/ch_10_modulation_and_modems">Ch 10 Modulation And Modems</a></p>
<p><a href="/ch_11_multiplexing_and_demultiplexing">Ch 11 Multiplexing And Demultiplexing (Channelization)</a></p>
<h1 id="Packet_Switching_And_Network_Technologies"><a class="header-anchor" href="#Packet_Switching_And_Network_Technologies">#</a>Packet Switching And Network Technologies</h1>
<p><a href="/ch_13_local_area_networks_packets,_frames,_and_topologies">Ch 13 Local Area Networks Packets, Frames, And Topologies</a></p>
<p><a href="/ch_14_the_ieee_mac_sublayer">Ch 14 The IEEE MAC Sublayer</a></p>
<p><a href="/ch_16_wireless_networking_technologies">Ch 16 Wireless Networking Technologies</a></p>
<p><a href="/ch_17_repeaters,_bridges,_and_switches">Ch 17 Repeaters, Bridges, And Switches</a></p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>耦合与内聚</title>
    <url>/coupling/</url>
    <content><![CDATA[<h1 id="耦合与内聚"><a class="header-anchor" href="#耦合与内聚">#</a>耦合与内聚</h1>
<p>当一个类与另一个类存在关系时，称这两个类存在<code>依赖(Dependency )</code>或`耦合(Coupling)``。如果两个类相互依赖，则修改其中的一个就可能会影响到另一个的执行逻辑。</p>
<p>当一个类的内部组件（如方法、属性等）彼此紧密关联，并共同完成某个功能时，称这个类具有<code>内聚(Cohesion)</code>。如果一个类内部的组件高度聚焦在明确的任务上，那么这个类更易于维护和理解。</p>
<p>在最理想的情况下，代码应该是低耦合高内聚的：</p>
<ul>
<li>耦合性表示的是对象间的交互（引用关系）。低耦合的表现是尽可能少的双向引用，循环引用。</li>
<li>内聚则是同类型代码是否在一起，高内聚的表现为模块化。</li>
</ul>
<p><img src="/coupling/image-20230611124256681.png" alt="耦合和内聚"></p>
]]></content>
      <tags>
        <tag>编码规范</tag>
      </tags>
  </entry>
  <entry>
    <title>《Unix 编程艺术》 第一章 哲学</title>
    <url>/di_1_zhang_zhe_xue/</url>
    <content><![CDATA[<h1 id="1_4_Unix_之失"><a class="header-anchor" href="#1_4_Unix_之失">#</a>1.4 Unix 之失</h1>
<p>最终的用户永远比操作系统设计人员更清楚他们究竟需要什么。</p>
<p>用错误的方法解决正确的问题，总比用正确的方法解决错误的问题好</p>
<h1 id="1_5_Unit_之得"><a class="header-anchor" href="#1_5_Unit_之得">#</a>1.5 Unit 之得</h1>
<h2 id="1_5_2_跨平台可移植性和开放标准"><a class="header-anchor" href="#1_5_2_跨平台可移植性和开放标准">#</a>1.5.2 跨平台可移植性和开放标准</h2>
<p>IEEE 早期定义的”可移植操作系统标准（Portable Operating System Standard, POS）“ 被社区为了读起来更像 Unix 而加了后缀变为 ”POSIX“。因为只有称之为 Unix API 等价物才能算是可移植操作系统标准比较可信的模型。</p>
<h2 id="1_5_5_从头到家的灵活性"><a class="header-anchor" href="#1_5_5_从头到家的灵活性">#</a>1.5.5 从头到家的灵活性</h2>
<p>许多操作系统自诩比 Unix 来的更”现代“，”友好“，它们漂亮外表的背后，却是以貌似精巧实则脆弱狭隘难用的编程接口，把用户和开发者禁锢在单一的界面方针下。在这样的操作系统中，完成系统任务很容易，而完成设计者没有预料到的需求，用户要么是无计可施，要么是痛苦不堪。</p>
<p>Unix 传统是让各个程序接口小巧，简洁和正交。整个 Unix 系统，容易的事还是那么容易，困难的事，至少是可能做到的。</p>
<h2 id="1_5_6_Unix_Hack_之趣"><a class="header-anchor" href="#1_5_6_Unix_Hack_之趣">#</a>1.5.6 Unix Hack 之趣</h2>
<p>充满痛苦的开发环境只会浪费劳动力和创造力；这样的环境会在无形之中耗费大量时间，资金，机会。</p>
<p>乐趣是一个符号，意味着效能，效率和高产。</p>
<h1 id="1_6_Unix_哲学基础"><a class="header-anchor" href="#1_6_Unix_哲学基础">#</a>1.6 Unix 哲学基础</h1>
<p>Doug Mcllroy （Unix 管道发明人，Unix 传统奠基人之一） 说：</p>
<ol>
<li>让每个程序做好一件事。如果有新任务，就重新开始，不要往原程序中加入新功能而搞得复杂</li>
<li>假定每个程序的输出都会成为另一个程序的输入，哪怕那个程序还是未知的。输出中不要有无关的信息干扰。</li>
<li>对拙劣的代码别犹豫，扔掉重写</li>
<li>优先使用工具而不是拙劣的帮助来减轻编程任务的负担。工欲善其事，必先利其器。</li>
</ol>
<div class="note info simple"><p>同样可以将 Doug Mcllroy 描述中的“程序”替换为“模块” 去理解。</p>
</div>
<p>Rob Pike（最伟大的 C 语言大师之一），在 《Notes on C Programming》从另一个不同的角度表述 Unix 的哲学：</p>
<ol>
<li>你无法判定程序会在什么地方耗费运行时间。瓶颈经常出现在想象不到的地方，所以别胡乱找个地方改代码，除非你已经证实那就是瓶颈所在。</li>
<li>在你没对代码进行估量，特别是没找到最耗时的那部分之前，别去优化速度。</li>
<li>花哨的算法在 n 很小时通常很慢，而 n 通常很小。除非你确定 n 总是很大，否则不要用花哨的算法（即使 n 很大，也优先考虑原则 2）。</li>
<li>花哨的算法比简单算法更容易出 Bug，更难实现。尽量使用简单的算法配合简单的数据结构。</li>
<li>编程的核心是数据结构，而不是算法。</li>
</ol>
<p><strong>Ken Thompson（Unix 最初版本的设计者和实现者，对 Pike 原则 4 做了强调）：拿不准就穷举</strong></p>
<p>Unix 的原则，可以概括为如下几点：</p>
<ol>
<li>模块原则：使用简洁的接口拼合简单的部件</li>
<li>清晰原则：清晰胜于机巧</li>
<li>组合原则：设计时考虑拼接组合</li>
<li>分离原则：策略同机制分离，接口同引擎分离</li>
<li>吝啬原则：除非确无它法，不要编写庞大的程序</li>
<li>透明性原则：设计要可见，以便审查和调试</li>
<li>健壮原则：健壮源于透明和简洁</li>
<li>表示原则：把知识叠入数据以求逻辑质朴而健壮。</li>
<li>通俗原则：接口设计避免标新立异。</li>
<li>缄默原则：如果一个程序没什么好说的，就沉默。</li>
<li>补救原则：出现异常时，马上退出并给出足够错误信息。</li>
<li>经济原则：宁花机器一分，不花程序员一秒。</li>
<li>生成原则：避免手工 hack，尽量编写程序去生成程序。</li>
<li>优化原则：雕琢前先要有原型，跑之前先学会走。</li>
<li>多样原则：绝不相信所谓的“不二法门”的断言。</li>
<li>扩展原则：设计着眼未来，未来总比预想来的块。</li>
</ol>
<h2 id="模块原则：使用简洁的接口拼合简单的部件"><a class="header-anchor" href="#模块原则：使用简洁的接口拼合简单的部件">#</a>模块原则：使用简洁的接口拼合简单的部件</h2>
<p>Brian Kernighan（Unix 小组的 3 号人物）曾经说过：“计算机编程的本质就是控制复杂度”。</p>
<p>排错占用了大部分的开发时间，弄出一个拿得出手的可用系统，通常与其说出自才华横溢的设计成果，还不如说是跌跌撞撞的结果。</p>
<p>要编制复杂软件而又不至于一败涂地的唯一方式就是降低其整体复杂度——用清晰的接口把若干简单的模块组合出一个复杂软件。如此一来，多数问题只会局限在某个局部，那么就还有希望对局部改进而不至于牵动全身。</p>
<h2 id="清晰原则：清晰胜于机巧"><a class="header-anchor" href="#清晰原则：清晰胜于机巧">#</a>清晰原则：清晰胜于机巧</h2>
<p>在写程序时，要想到你不是写给执行代码的计算机看的，而是给人——将来阅读维护源码的人，包括你自己——看的。</p>
<p>为了取得程序一丁点的性能提升就大幅度增加技术的复杂性和晦涩性，这个买卖做不得——这不仅仅是因为复杂的代码冗余滋生 bug，也因为它会使日后的阅读和维护工作更加艰难。</p>
<h2 id="组合原则：设计时考虑拼接组合"><a class="header-anchor" href="#组合原则：设计时考虑拼接组合">#</a>组合原则：设计时考虑拼接组合</h2>
<p>如果程序彼此之间不能有通信，那么软件就难免会陷入复杂度的泥淖。</p>
<p>Unix 传统极力提倡采用简单、文本化、面向流、设备无关的格式。…Unix 程序员偏爱这种做法并不是因为他们仇恨图形用户界面，而是因为如果程序不采用简单的文本输入输出流，他们就极难衔接。</p>
<h2 id="分离原则：策略同机制分离"><a class="header-anchor" href="#分离原则：策略同机制分离">#</a>分离原则：策略同机制分离</h2>
<p>策略和机制是按照不同你的时间尺度变化的，策略的变化要远远快于机制。</p>
<div class="note info simple"><p>可以将机制视作规则，策略则是在规则下实现目的的方式。</p>
<p>比如系统定义了消息机制，定义了消息的发送、接受、处理、返回</p>
<p>应用可依赖机制通过不同的策略实现不同的功能。</p>
</div>
<h2 id="简洁原则：设计要简洁，复杂度能低则低"><a class="header-anchor" href="#简洁原则：设计要简洁，复杂度能低则低">#</a>简洁原则：设计要简洁，复杂度能低则低</h2>
<p>程序员们都很聪明，常常以能玩转复杂东西和耍弄抽象概念的能力为傲，这一点无可厚非……但他们的设计能力大大超出他们的实现和排错能力，结果便是代价高昂的废品。</p>
<p>过度的复杂性往往来自于项目的要求，而这些要求常常基于当月的推销热点，而不是基于顾客的需求和软件实际能够提供的功能。许多优秀的设计被市场推销所需要的大堆大堆“特性清单”扼杀——实际上这些特性几乎从没用过。然后恶性循环开始了：比别人花哨的方法就是把自己变得更花哨。很快，庞大臃肿变成了业界标准，每个人都在使用臃肿不堪、bug 极多的软件，连软件开发人员也不敢敝帚自珍。</p>
<p>要避免这些陷阱，唯一的方法就是鼓励另一种软件文化，以简洁为美。</p>
<h2 id="吝啬原则：除非确无它法，不要编写庞大的程序"><a class="header-anchor" href="#吝啬原则：除非确无它法，不要编写庞大的程序">#</a>吝啬原则：除非确无它法，不要编写庞大的程序</h2>
<p>程序大了，维护起来就困难。由于人们对花费了大量精力才做出来的东西难以割舍，结果导致在庞大的程序中把投资浪费注定要失败或者并非最佳的方案上。</p>
<h2 id="健壮原则：健壮源于透明与简洁"><a class="header-anchor" href="#健壮原则：健壮源于透明与简洁">#</a>健壮原则：健壮源于透明与简洁</h2>
<p>让程序健壮的方法，就是让程序的内部逻辑更易于理解。要做到这一点主要靠 <code>透明化</code> 和 <code>简洁性</code>。</p>
<p>软件的透明性就是指一眼能看出是怎么回事。人们不需要绞尽脑汁就能够推断出所有可能的情况，那么这个程序透明的。</p>
<p>模块性是组织程序达到更简洁目的的一个方法。</p>
<h2 id="表示原则：把知识叠入数据以求逻辑质朴而健壮"><a class="header-anchor" href="#表示原则：把知识叠入数据以求逻辑质朴而健壮">#</a>表示原则：把知识叠入数据以求逻辑质朴而健壮</h2>
<p>数据要比编程逻辑更容易驾驭。如果要在复杂数据和复杂代码中选择一个，宁愿选择前者。在设计中，应该主动将代码的复杂度转移到数据之中去。</p>
<h2 id="通俗原则：接口设计避免标新立异"><a class="header-anchor" href="#通俗原则：接口设计避免标新立异">#</a>通俗原则：接口设计避免标新立异</h2>
<p>接口设计应该避免毫无来由的标新立异和自作聪明。</p>
<p>最小立异原则的另一面是避免表象相似而实际却略有不同。这会极端危险，因为表象相似往往导致人们产生错误的假定。所以最好让不同的事物有明显区别，而不要看起来几乎一模一样。 —— Henry Spencer</p>
<h2 id="缄默原则：如果一个程序没什么好说的，就保持沉默"><a class="header-anchor" href="#缄默原则：如果一个程序没什么好说的，就保持沉默">#</a>缄默原则：如果一个程序没什么好说的，就保持沉默</h2>
<p>行为良好的程序应该默默工作，决不唠唠叨叨，碍手碍脚。沉默是金。</p>
<p>设计良好的程序将用户的注意力视为有限的宝贵资源，只有在必要时才要求使用。</p>
<h2 id="补救原则：出现异常时，马上退出并给出足量错误信息"><a class="header-anchor" href="#补救原则：出现异常时，马上退出并给出足量错误信息">#</a>补救原则：出现异常时，马上退出并给出足量错误信息</h2>
<p>软件要尽可能从容地应付各种错误输入和自身的运行错误。但是，如果做不到这一点，就让程序尽可能以一种容易诊断错误的方式终止。</p>
<p>如果补救措施明明没有成功，却悄无声息地埋下崩溃的隐患，直到很久以后才显现出来，这就是最坏的一种情况。</p>
<p>“就算输入的数据很不规范，一个设计良好的程序也会尽量领会其中的意义，以尽量与别的程序协作；然后，要么响亮地倒塌，要么为工作链下一环的程序输出一个严谨干净正确的数据”—— Jonathan Postel（互联网主要架构者之一，第一个互联网 RFC 系列标准的编纂者）</p>
<h2 id="经济原则：宁花机器一分，不花程序员一秒"><a class="header-anchor" href="#经济原则：宁花机器一分，不花程序员一秒">#</a>经济原则：宁花机器一分，不花程序员一秒</h2>
<h2 id="生成原则：避免手工_hack，尽量编写程序去生成程序"><a class="header-anchor" href="#生成原则：避免手工_hack，尽量编写程序去生成程序">#</a>生成原则：避免手工 hack，尽量编写程序去生成程序</h2>
<h2 id="优化原则：雕琢前先得有原型，跑之前先学会走"><a class="header-anchor" href="#优化原则：雕琢前先得有原型，跑之前先学会走">#</a>优化原则：雕琢前先得有原型，跑之前先学会走</h2>
<p>”90% 的功能现在能实现，比 100% 的功能永远实现不了强“。</p>
<p>先给你的设计做个未优化，运行缓慢，很耗内存但正确的实现，然后进行系统的调整，寻找那些可能通过牺牲最小的局部简洁性而获得较大性能提升的地方。</p>
<p>借助原型化找出哪些功能不必实现，有助于对性能进行优化；那些不用写的代码显然无需优化。目前最强大的优化工具就是 delete 键。</p>
<p>我最有成效的一天，就是扔掉了 1000 行代码 —— Ken Thompson（图灵奖获得者，GO 发明者）。</p>
<h2 id="多样原则：决不相信所谓_”不二法门“_的断言"><a class="header-anchor" href="#多样原则：决不相信所谓_”不二法门“_的断言">#</a>多样原则：决不相信所谓 ”不二法门“ 的断言</h2>
<p>设计一个僵化、封闭、不愿与外界沟通的软件，简直是一种病态的傲慢。</p>
<p>Unix 奉行的是广泛采用多种语言、开放的可拓展系统和用户定制机制。</p>
<h2 id="扩展原则：设计着眼未来，未来总比预想快"><a class="header-anchor" href="#扩展原则：设计着眼未来，未来总比预想快">#</a>扩展原则：设计着眼未来，未来总比预想快</h2>
<h1 id="1_7_Unix_哲学之一言以蔽之"><a class="header-anchor" href="#1_7_Unix_哲学之一言以蔽之">#</a>1.7 Unix 哲学之一言以蔽之</h1>
<p>KISS 原则： Keep It Simple, Stupid!</p>
<h1 id="1_9_态度也要紧"><a class="header-anchor" href="#1_9_态度也要紧">#</a>1.9 态度也要紧</h1>
<p>你必须相信，软件设计是一门艺术，值得你付出所有的智慧、创造力和激情。…………否则你就会在应该思考的时候急急忙忙跑去编程，你就会在该无情删繁就简的时候反而把问题复杂化——然后你还会反过来奇怪你的代码怎么会那么臃肿，那么难以调试。</p>
<p>要良好地运用 Unix 哲学，你应该珍惜你的时间决不浪费。一旦某人己经解决了某个问题，就直接拿来利用，不要让骄傲或偏见拽住你又去重做一遍。</p>
<p>永远不要蛮干：要多用巧劲，省下力气到需要的时候再用，好钢用在刀刃上。善用工具，尽可能将一切都自动化。</p>
]]></content>
      <tags>
        <tag>编码规范</tag>
        <tag>系统设计</tag>
      </tags>
  </entry>
  <entry>
    <title>《Head First 设计模式》 笔记汇总</title>
    <url>/head_first_design_patterns/</url>
    <content><![CDATA[<p><a href="/ch_01_the_strategy_pattern">Ch 01 the Strategy Pattern</a></p>
<p><a href="/ch_02_the_observer_pattern">Ch 02 the Observer Pattern</a></p>
<p><a href="/ch_03_the_decorator_pattern">Ch 03 the Decorator Pattern</a></p>
<p><a href="/ch_04_the_factory_pattern">Ch 04 the Factory Pattern</a></p>
<p><a href="/ch_05_the_singleton_pattern">Ch 05 the Singleton Pattern</a></p>
<p><a href="/ch_06_the_command_pattern">Ch 06 the Command Pattern</a></p>
<p><a href="/ch_07_the_adapter_and_facade_patterns">Ch 07 the Adapter and Facade Patterns</a></p>
<p><a href="/ch_08_the_template_method_pattern">Ch 08 the Template Method Pattern</a></p>
<p><a href="/ch_09_the_iterator_and_composite_pattern">Ch 09 the Iterator and Composite Pattern</a></p>
<p><a href="/ch_10_the_state_pattern">Ch 10 the State Pattern</a></p>
<p><a href="/ch_11_the_proxy_pattern">Ch 11 the Proxy Pattern</a></p>
<p><a href="/ch_12_the_compound_patterns">Ch 12 the Compound Patterns</a></p>
<p><a href="/head_first_design_pattern_design_principles">Head First Design Pattern Design Principles</a></p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>C# Formattable String</title>
    <url>/formattable_string/</url>
    <content><![CDATA[<p><code>FormattableString</code>  是 C# 6.0 中引入的新类型之一，可以避免在非必要情况下执行了格式化字符串带来的性能开销。</p>
<p>使用如下示例如下，可以看出 <code>FormattableString</code> 将需要格式化的字符串创建和真正的格式化操作进行了拆分：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line"><span class="built_in">int</span> age = <span class="number">30</span>;</span><br><span class="line"><span class="built_in">decimal</span> weight = <span class="number">60.5</span>m;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 FormattableString</span></span><br><span class="line">FormattableString message = <span class="string">$&quot;<span class="subst">&#123;name&#125;</span> 年龄 <span class="subst">&#123;age&#125;</span>，体重 <span class="subst">&#123;weight&#125;</span> 公斤。&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 FormattableString 转换为 string 类型</span></span><br><span class="line"><span class="built_in">string</span> formattedMessage = message.ToString();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">Console.WriteLine(formattedMessage);</span><br></pre></td></tr></table></figure>
<h1 id="Performance"><a class="header-anchor" href="#Performance">#</a>Performance</h1>
<p>对于一些函数，需要在运行时判断是否需要输出 string，可以使用 <code>FormattableString</code> 保证格式化仅在真正需要使用 <code>string</code> 时才执行。这可以带来性能提升。</p>
<p>如下性能测试函数：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Test, Performance, Category(<span class="string">&quot;String&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">String_NotReallyOutput</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> unit = SampleUnit.Microsecond;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> outputStr = <span class="keyword">new</span> MeasurementSettings(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="string">&quot;Output using string&quot;</span>, unit);</span><br><span class="line">    <span class="keyword">var</span> outputFormattedStr = <span class="keyword">new</span> MeasurementSettings(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="string">&quot;Output using formatted string&quot;</span>, unit);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FakeOutput</span>(<span class="params"><span class="built_in">string</span> str</span>)</span> &#123; <span class="keyword">if</span> (<span class="literal">false</span>) Debug.Log(str); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FormattedFakeOutput</span>(<span class="params">FormattableString fStr</span>)</span> &#123; <span class="keyword">if</span> (<span class="literal">false</span>) Debug.Log(fStr.ToString()); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> age = <span class="number">23</span>, times = <span class="number">25</span>;</span><br><span class="line">    Measure.Method(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        FakeOutput(<span class="string">$&quot;Hello World with age <span class="subst">&#123;age&#125;</span> with times <span class="subst">&#123;times&#125;</span> &quot;</span>);</span><br><span class="line">    &#125;, outputStr).Run();</span><br><span class="line"></span><br><span class="line">    Measure.Method(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        FormattedFakeOutput(<span class="string">$&quot;Hello World with age <span class="subst">&#123;age&#125;</span> with times <span class="subst">&#123;times&#125;</span> &quot;</span>);</span><br><span class="line">    &#125;, outputFormattedStr).Run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>FormattableString</code> 的版本因为避免了格式化操作的进行，带来了约 5 倍的收益：<br>
<img src="/formattable_string/image-20230417094543917.png" alt=""></p>
<p>即使真正需要执行 String 格式化时，使用 <code>FormattableString</code> 也不会带来性能劣化，如下性能测试代码：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Test, Performance, Category(<span class="string">&quot;String&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">String_ReallyOutput</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> unit = SampleUnit.Microsecond;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> outputStr = <span class="keyword">new</span> MeasurementSettings(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="string">&quot;Output using string&quot;</span>, unit);</span><br><span class="line">    <span class="keyword">var</span> outputFormattedStr = <span class="keyword">new</span> MeasurementSettings(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="string">&quot;Output using formatted string&quot;</span>, unit);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FakeOutput</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">true</span>) Debug.Log(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FormattedFakeOutput</span>(<span class="params">FormattableString fStr</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">true</span>) Debug.Log(fStr.ToString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> age = <span class="number">23</span>, times = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line">    Measure.Method(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        FakeOutput(<span class="string">$&quot;Hello World with age <span class="subst">&#123;age&#125;</span> with times <span class="subst">&#123;times&#125;</span> &quot;</span>);</span><br><span class="line">    &#125;, outputStr).Run();</span><br><span class="line"></span><br><span class="line">    Measure.Method(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        FormattedFakeOutput(<span class="string">$&quot;Hello World with age <span class="subst">&#123;age&#125;</span> with times <span class="subst">&#123;times&#125;</span> &quot;</span>);</span><br><span class="line">    &#125;, outputFormattedStr).Run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>性能测试结果为：<br>
<img src="/formattable_string/image-20230417094729230.png" alt=""></p>
<p>但是如果在不需要进行格式化时，强制使用 <code>FormattableString</code> 则会带来性能劣化。</p>
<p>如下代码，可以看到针对字符串实际上并没有需要拼接的数据，但对于 <code>Formattted</code> 版本的函数，为了保证形参为 <code>FormattableString</code> 仍然加上了 <code>$</code> 符：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Test, Performance, Category(<span class="string">&quot;String&quot;</span>), TestCase(true), TestCase(false)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">String_UseZeroArgument</span>(<span class="params"><span class="built_in">bool</span> reallyOutput</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    MeasurementSettings outputStr = <span class="keyword">new</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="string">&quot;Output using string&quot;</span>, s_Unit);</span><br><span class="line">    MeasurementSettings outputFormattedStr = <span class="keyword">new</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="string">&quot;Output using formatted string&quot;</span>, s_Unit);</span><br><span class="line"></span><br><span class="line">    Measure.Method(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (reallyOutput)</span><br><span class="line">            ReallyOutput(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            FakeOutput(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;, outputStr).Run();</span><br><span class="line"></span><br><span class="line">    Measure.Method(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (reallyOutput)</span><br><span class="line">            ReallyFormattedOutput(<span class="string">$&quot;Hello World&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            FakeFormattedOutput(<span class="string">$&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;, outputFormattedStr).Run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，<code>FormattableString</code> 版本的函数在实际不需要输出时带来了约 10 倍的性能恶化：<br>
<img src="/formattable_string/image-20230417102028637.png" alt=""></p>
<h1 id="Override"><a class="header-anchor" href="#Override">#</a>Override</h1>
<p>尽可能的避免 <code>string</code> 和 <code>FormattableString</code> 的函数重载，因为编译器会优先选择 <code>string</code> 形参的版本，且在一些操作时可能会隐式的将 <code>FormattableString</code> 转换为 <code>string</code>，进而导致与预期违背的行为产生。</p>
<p>如下示例代码：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DO NOT</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sample</span>(<span class="params"><span class="built_in">string</span> <span class="keyword">value</span></span>)</span> =&gt; <span class="keyword">throw</span> <span class="literal">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sample</span>(<span class="params">FormattableString <span class="keyword">value</span></span>)</span> =&gt; <span class="keyword">throw</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">Sample(<span class="string">$&quot;Hello <span class="subst">&#123;name&#125;</span>&quot;</span>);</span><br><span class="line"><span class="comment">// ⚠ Call Sample(string)</span></span><br><span class="line"></span><br><span class="line">Sample((FormattableString)<span class="string">$&quot;Hello <span class="subst">&#123;name&#125;</span>&quot;</span>);</span><br><span class="line"><span class="comment">// Call Sample(FormattableString) because of the explicit cast</span></span><br><span class="line"></span><br><span class="line">Sample((FormattableString)<span class="string">$&quot;Hello <span class="subst">&#123;name&#125;</span>&quot;</span> + <span class="string">&quot;!&quot;</span>);</span><br><span class="line"><span class="comment">// Call Sample(string) because the operator FormattableString + string returns a string</span></span><br></pre></td></tr></table></figure>
<h1 id="Reference"><a class="header-anchor" href="#Reference">#</a>Reference</h1>
<p><a href="https://www.meziantou.net/interpolated-strings-advanced-usages.htm#interpolated-strings-a9996a-2">Interpolated strings: advanced usages - Meziantou’s blog</a></p>
]]></content>
      <tags>
        <tag>C#</tag>
        <tag>String</tag>
        <tag>Performance</tag>
      </tags>
  </entry>
  <entry>
    <title>《Head First 设计模式》 - 设计原则总结</title>
    <url>/head_first_design_pattern_design_principles/</url>
    <content><![CDATA[<ol>
<li>将变化的部分封装起来（Encapsulate what varies)</li>
<li>组合优于继承（Favor composition over inheritance）</li>
<li>面向接口编程而非实现（Program to interfaces, not implementations.）</li>
<li>减少需要交互的类之间的耦合（Strive for loosely coupled designs between objects that interact）</li>
<li>对拓展开放，对修改关闭（Classes should be open for extension but closed for modification.）</li>
<li>依赖于抽象而非具体的类（ Depend on abstraction. Do not depend on concrete classes）</li>
<li>暴露最少的信息给其他类（最少知识原则）（Talk only to your immediate friends）</li>
<li>高层有对底层的管理，而底层不需要关心高层何时会调用自己（好莱坞原则）（Don’t call us ,we’ll call you）</li>
<li>一个类应该有且只有一个被改变的理由（A class should have only one reason to change）</li>
</ol>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>《Render Hell》 笔记汇总</title>
    <url>/render_hell/</url>
    <content><![CDATA[<ul>
<li><a href="/book_1_overview">Book 1 Overview</a></li>
<li><a href="/book_2_pipeline">Book 2 Pipeline</a></li>
<li><a href="/book_3_problems">Book 3 Problems</a></li>
<li><a href="/book_4_solutions">Book 4 Solutions</a></li>
</ul>
<h1 id="Reference"><a class="header-anchor" href="#Reference">#</a>Reference</h1>
<p><a href="http://simonschreibt.de/gat/renderhell/">Render Hell 2.0 | Simon schreibt.</a></p>
]]></content>
      <tags>
        <tag>GPU</tag>
      </tags>
  </entry>
  <entry>
    <title>《LLM 对程序员的冲击和影响》摘抄</title>
    <url>/llm_dui_cheng_xu_yuan_de_chong_ji_he_ying_xiang/</url>
    <content><![CDATA[<h1 id="LLM_的局限"><a class="header-anchor" href="#LLM_的局限">#</a>LLM 的局限</h1>
<p>如果说 <strong>ChatGPT 实现了数字时代知识的平权，codex 类的代码语言大模型实现了基础编码能力的知识平权</strong>，进而带来软件研发的局部效率提升。 可以说，LLM 降低了软件开发的门槛，可以让更多对软件开发感兴趣的人更加轻松地参与到软件开发工作中，同时，LLM 提高了编程的效率和质量，使我们可以在更短的时间内完成更多的工作，因而能留出更多的时间让我们思考。</p>
<p>我们面对的是软件工程的问题，<strong>编程不等于软件工程，编程只是软件工程的一部分。软件工程的四大内在特性（复杂度、不一致性、可变性、不可见性）并没有因为 LLM 的出现而发生本质上的变化，这才是软件工程面临的主要矛盾</strong>。这四点再叠加上大型软件的规模效应，其中包含软件系统本身的规模和软件研发团队的规模，问题就更严重了，即会显著提升软件研发过程中的沟通成本、决策成本、认知成本和试错成本，而这些才是软件工程问题的本质，这些本质问题自始至终都没有变过，LLM 对此也基本无能为力。</p>
<h2 id="复杂性"><a class="header-anchor" href="#复杂性">#</a>复杂性</h2>
<p>LLM 让局部编码变简单，或者说更高效了，但是需求分析和软件设计并没有因为 LLM 而变得简单。</p>
<p>只有我们的需求足够的清楚，那么生成的代码才会准确。如何准确全面描述需求成为了关键。面向自然语言编程，首先你要有能力把话讲清楚。但是问题是：你能讲清楚吗？我们通过一些实践发现，<strong>要把需求描述到让它能正确写出来代码，需要的工作量似乎已经接近甚至超过编码了</strong>。为什么会这样，有两个方面的原因：</p>
<ol>
<li>
<p>因为大多数的代码实现是 imperative 的，而需求描述是 declarative 的，这两者对人的要求完全不一样。我们程序员群体接受的教育是编程，而不是需求描述，也就是说程序员本来更擅长写代码，而不是描述需求。</p>
</li>
<li>
<p>在当前的开发模式下，程序员直接用代码默认帮需求（产品经理）做了很多代偿。很多在需求中没有明确提及的内容被程序员用代码直接实现了（代偿）。而现在要倒过来先把需求的细节完全理清楚这个可能不是程序员当前的工作习惯。而且代码的信息熵其实要大于自然语言，程序员更善于用代码而非自然语言来描述事务。</p>
<ul>
<li>在当前的开发模式下，程序员直接用代码默认帮需求（产品经理）做了很多代偿。很多在需求中没有明确提及的内容被程序员用代码直接实现了（代偿）。而现在要倒过来先把需求的细节完全理清楚这个可能不是程序员当前的工作习惯。而且代码的信息熵其实要大于自然语言，程序员更善于用代码而非自然语言来描述事务。</li>
<li>一个软件的需求，不仅仅是功能性的，还有很多非功能的需求，这些都是需要描述清楚的。另外代码实现的时候，还要考虑为可测试而设计，为可扩展而设计，为可运维而设计，为可观测而设计等等。原本这些很多是开发代偿了，现在要从需求生成代码，你必须要提前讲清楚。</li>
</ul>
</li>
</ol>
<div class="note info simple"><p>软件从业者高估了编程的复杂度，但是却低估了功能和设计的深刻度。</p>
</div>
<h2 id="一致性"><a class="header-anchor" href="#一致性">#</a>一致性</h2>
<p>由于软件研发的本质依然是“<strong>知识手工业者的大规模协作</strong>”，所以我们非常需要一致性。如果系统是一致的，则意味着相似的事情以相似的方式完成，错并不可怕，怕的是错的千变万化。LLM 的出现并没有提升软件研发的一致性，甚至<strong>由于 LLM 本身的概率属性，使用 LLM 实现代码生成的不一致性问题反而是被放大了</strong></p>
<h2 id="可变性"><a class="header-anchor" href="#可变性">#</a>可变性</h2>
<p>软件会随着需求不断演进和变化，所以架构设计和模块抽象只能面向当下，它天然是短视的，或者说是有局限性的，这种局限性即使是最优秀的架构师也是不可逾越的。</p>
<p>当需求发生变动后，一般是会在原有代码基础上改动，而不是直接从头全量生成全部代码，这个时候，LLM 本质上做的是局部编程的辅助（pair programming）。局部编程辅助过程中，经常需要对代码做局部修改，而这个往往并不容易。代码的信息熵大于自然语言，用信息熵更低的自然语言去描述代码，尤其是准确描述大段代码中的若干个位置往往是困难的。</p>
<p>如果需要进一步描述如何修改就会更困难，因为大概率需要用到很多代码上下文的相关描述，所以对于 prompt 的表述要求以及长度要求都很高。要在原有代码基础上修改，就需要利用已有的代码上下文，而不是从 0 开始。要实现这一点，一个最朴素的做法就是把整个项目的代码都贴到 prompt 里，但这样并不现实。因为 GPT-3.5 限制最多只能 4096 个 tokens，GPT-4 最多 8192 个，除非项目非常小，否则根本放不下。这个问题可能需要用 LangChain 来解决了。</p>
<p>而且 LLM 本质上不是基于修改意见（prompt）进行改写，而是基于修改意见（prompt）重新写了一份，而且 LLM 的原理决定了其会“一本正经的胡说八道”的本质，会<strong>混合捏造</strong>一些不存在的东西，可以说人工智能的混合捏造是人工智能在无知情况下的“自信”反应，而这个点在代码生成上是灾难性的，比如会将不同类型的 SQL 语句混在一起使用，会分不清 Go 语言的 <code>os.Kill</code> 和 Python 语言的 <code>os.kill()</code>。输出的代码需要人重复的阅读和理解，使得认知成本变高了。</p>
<h2 id="不可见性"><a class="header-anchor" href="#不可见性">#</a>不可见性</h2>
<p>软件的客观存在不具有空间的形体特征，不同的关注点，会有不同的图。综合叠加这些图是困难的，而且<strong>强行可视化的效果会造成图的异常复杂，反而失去了可视化的价值</strong>。设计无法可视化就限制了有效的沟通和交流。</p>
<p>在实际中，很多需求和设计并不以文档的形式存在，往往会存在于程序员和架构师的脑子里，或者在讨论的过程中。就算有文档，文档和代码大概率不同步。就算文档同步，文档（需求和设计）背后经常有大量的方案对比和推敲，甚至有很多要在原有债务基础上的设计妥协，这些决策过程一般都不会明确地被记录下来。这些没有被文档化下来的知识，我们称其为<code>暗知识</code>。虽然我们说只要有足够的数据，大模型就可以学到需求和设计知识。但这些“暗知识”本身就很难被捕捉到，“足够的数据”这一前提在需求分析和软件设计可能难以满足。</p>
<p>在实际软件开发中，需求可能一次不能表达得很清楚，需要一边开发一边逐步写清楚需求。尤其是敏捷开发更是如此。所以一些通用的，不需要特定领域知识的问题，LLM 的表现会比较好，但是那些专用的，需要特定领域知识（私域知识）的问题，LLM 就可能不是很擅长。</p>
<div class="note info simple"><p>你能想到的多过你能说出来的，你能说出来的多过你能写下来的。所以这就天然限制了 LLM 能力的上限。</p>
</div>
<h1 id="工程师与_LLM_的共生"><a class="header-anchor" href="#工程师与_LLM_的共生">#</a>工程师与 LLM 的共生</h1>
<p>在软件开发过程中，当伪代码级别的设计完成后，最后一公里的编码实现会被 LLM 替代，因为基于记忆的简单重复编码不是人的优势，而是机器的优势。</p>
<p>这部分工作现在属于码农，也就是我们俗称的 CRUD 仔和 API Boy，所以很多不涉及设计的码农可能会被大模型替代。未来工程师需要关注业务理解、需求拆分、架构设计、设计取舍，并在此基础上通过 prompt 学会与 AI 合作，从而<strong>实现“工程师 + LLM”形成 1+1 &gt;2 的效果。这就是共生</strong>。需要注意的是，这种<strong>共生必须始终保持人的主观能动性</strong>，机器必须是 Copilot，也就是智能副驾驶，主驾驶位置必须是人，这样的人 - 机关系才能长期健康发展。这也就是为什么说微软现任 CEO 萨提亚强调 Copilot（智能副驾驶）是比 Autopilot（自动驾驶）还先进的根本原因。</p>
<p>软件项目参与的人越来越多，分工越来越细，人和人之间需要的沟通量，也指数增长。很快你会发现，沟通花费的时间，渐渐地就比分工省下来的时间还要多。说白了，过了一个临界点，人越多不是越帮忙，而是人越多越添乱。一个人 12 个月能完成的事，不见得上 12 个人 1 个月就能完成，甚至 12 个月也未必能完成。</p>
<ul>
<li>《人月神话》里建议了一种组织方式，叫“外科手术式的队伍”。就像一台外科手术一样，有一个主刀大夫，软件项目也应该有一个首席程序员，其他人都是给他提供支持的。这样，就既能获得由少数头脑产生的产品完整性，又能得到多位协助人员的总体生产率，还彻底地减少了沟通的工作量。<strong>LLM 的出现，让基础编程工作一定程度上实现了自动化，这样非常有利于控制研发团队规模，保持小团队的效率优势</strong>。</li>
</ul>
<h1 id="未来可能基于_Prompt_编程"><a class="header-anchor" href="#未来可能基于_Prompt_编程">#</a>未来可能基于 Prompt 编程</h1>
<p>让我们做个大胆的设想，如果当软件需求发生变化的时候，我们不再是去改代码，而是直接修改需求对应的 prompt，然后基于 prompt 直接生成完整的代码，这个将是软件开发范式的改变。在这种范式下，我们需要确保代码不能有人为修改，必须都是由 prompt 直接生成，此时我们还需要对 prompt 做版本管理，或许会出现类似今天 git 的 prompt 版本管理的新物种。</p>
<p>此时，从本质上来看 <strong>prompt 即是代码，而原本的代码不再是代码了</strong>，这就真正实现了基于自然语言（prompt）的编程，此时的编程范式将从 prompt to code 转变为 prompt as code。</p>
<p>但这个假设还是在以以往的逻辑在做分析，这个基础可能本来就是错误，全新的时代或许需要全新的思维模式。</p>
]]></content>
      <tags>
        <tag>摘抄</tag>
        <tag>AI</tag>
        <tag>LLM</tag>
        <tag>程序员</tag>
      </tags>
  </entry>
  <entry>
    <title>SOLID 原则</title>
    <url>/solid/</url>
    <content><![CDATA[<p><code>SOLID</code> 原则是面向对象编程中的五个重要设计原则，有助于增强软件的可维护性、可扩展性和可读性。</p>
<h1 id="S_Single_Responsibility_Principle_单一职责"><a class="header-anchor" href="#S_Single_Responsibility_Principle_单一职责">#</a>S- Single Responsibility Principle 单一职责</h1>
<p>单一原则要求一个类只能承担一个职责，并且只能有一个潜在的原因去更改这个类。</p>
<p><img src="/solid/image-20220703135544298.png" alt="单一职责"></p>
<div class="note warning simple"><p>不要刻意的追求单一原则，甚至于到了一个类只包含一个函数的程度。</p>
</div>
<h2 id="Example"><a class="header-anchor" href="#Example">#</a>Example</h2>
<p>如下是一个常见的 Unity <code>Monobehavior</code>：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UnrefactoredPlayer</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> <span class="built_in">string</span> inputAxisName;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> <span class="built_in">float</span> positionMultiplier;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> m_YPosition;</span><br><span class="line">    <span class="keyword">private</span> AudioSource m_BounceSfx;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span> &#123; m_BounceSfx = GetComponent&lt;AudioSource&gt;(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">float</span> delta = Input.GetAxis(inputAxisName) * Time.deltaTime;</span><br><span class="line">        m_YPosition = Mathf.Clamp(m_YPosition + delta, <span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">        transform.position = <span class="keyword">new</span> Vector3(transform.position.x, m_YPosition * positionMultiplier, transform.position.z);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerEnter</span>(<span class="params">Collider other</span>)</span> &#123; m_BounceSfx.Play(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个脚本中实际上耦合了音频，按键输入和对于玩家移动的控制，即：<br>
<img src="/solid/image-20230610105358001.png" alt="不符合单一原则的 Player"></p>
<p>为了符合单一职责的原则，可以将对于音频，按键输入和玩家控制的逻辑，分别拆分至 <code>PlayerAudio</code>，<code>PlayerInput</code> 和 <code>PlayerMovement</code> 三个类中， <code>Player</code> 去引用者三个类，如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">RequireComponent(typeof(PlayerAudio), typeof(PlayerInput), typeof(PlayerMovement))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Player</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> PlayerAudio playerAudio;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> PlayerInput playerInput;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> PlayerMovement playerMovement;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        playerAudio = GetComponent&lt;PlayerAudio&gt;();</span><br><span class="line">        playerInput = GetComponent&lt;PlayerInput&gt;();</span><br><span class="line">        playerMovement = GetComponent&lt;PlayerMovement&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerAudio</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerInput</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerMovement</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>关系图如下，此时如果要修改音频相关的逻辑，只需要修改 <code>PlayerAudio</code> 脚本，不会有影响到 Input 和 Movement 的风险：<br>
<img src="/solid/image-20230610134447341.png" alt="符合单一原则的 Player"></p>
<h1 id="O_Open_Closed_Principle_开闭原则"><a class="header-anchor" href="#O_Open_Closed_Principle_开闭原则">#</a>O-Open/Closed Principle 开闭原则</h1>
<p>实体应该对  <strong>扩展</strong>  开放，对  <strong>修改</strong>  关闭。允许扩展行为而无需修改源代码。</p>
<p><img src="/solid/image-20220703135627060.png" alt="开闭原则"></p>
<h2 id="Example-2"><a class="header-anchor" href="#Example-2">#</a>Example</h2>
<p>如存在 <code>AreaCalculator</code> 类，用以计算不同形状的面积：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AreaCalculator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">float</span> <span class="title">GetRectangleArea</span>(<span class="params">Rectangle rectangle</span>)</span> &#123; <span class="keyword">return</span> rectangle.width * rectangle.height; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">float</span> <span class="title">GetCircleArea</span>(<span class="params">Circle circle</span>)</span> &#123; <span class="keyword">return</span> circle.radius * circle.radius * Mathf.PI; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Rectangle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> width;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Circle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/solid/image-20230610135408696.png" alt="不符合开闭原则的 Area Calculator"></p>
<p>目前这个类的实现没有什么问题，但每增加一个形状，<code>AreaCalculator</code> 就需要修改一次。随着形状的种类的扩张， <code>AreaCaulculator</code> 会变得逐渐不可维护。</p>
<p>为了符合开闭原则，可以将所有形状抽象为 <code>Shape</code> 类，在派生类中定义每个形状计算面积的方式：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">float</span> <span class="title">CalculateArea</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Rectangle</span> : <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> width;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> height;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">float</span> <span class="title">CalculateArea</span>()</span> &#123; <span class="keyword">return</span> width * height; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Circle</span> : <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> radius;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">float</span> <span class="title">CalculateArea</span>()</span> &#123; <span class="keyword">return</span> radius * radius * Mathf.PI; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AreaCalculator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">float</span> <span class="title">GetArea</span>(<span class="params">Shape shape</span>)</span> &#123; <span class="keyword">return</span> shape.CalculateArea(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时 <code>AreaCalculator</code> 只需要关心调用 Shape 中的 <code>CalculateArea</code> 函数，而不需要关心具体的 Shape 类型。因此即使有了新的 Shape，也不会需要修改 <code>AreaCalculator</code> 类。此时类与类间的关系为：<br>
<img src="/solid/image-20230610161252390.png" alt="符合开闭原则的 AreaCalculator"></p>
<h1 id="L_Liskov_Substitution_Principle_里氏替换原则"><a class="header-anchor" href="#L_Liskov_Substitution_Principle_里氏替换原则">#</a>L - Liskov Substitution Principle 里氏替换原则</h1>
<p>程序中的对象应该可以被其子类实例替换掉，而不会影响程序的正确性。里氏替换原则指明了类的派生关系，要求派生类必须完全能承担基类的所有功能。</p>
<p><img src="/solid/image-20220703135721761.png" alt="里氏替换原则"></p>
<p>一些遵守里氏替换原则的技巧：</p>
<ul>
<li>如果在派生类中移除了某个函数的实现，则可能会破坏里氏替换原则。<code>NotImplementedException</code> 是一个绝对的信号，告知开发者里氏替换原则被破坏。如果子类中有空函数实现，则也标明了里氏替换原则的破坏。</li>
<li>保持基类尽可能的简单：在基类中的逻辑越多，则越可能破坏里氏替换原则。</li>
<li>更多的使用组合而非派生</li>
<li>在构造类的继承关系前，先思考类的 API。实现中的抽象关系，并不一定要来自于现实的抽象关系。并不是现实中所有的 <em>是</em> 关系，都需要设计为派生关系。如下例子中，<code>Train</code> 和 <code>Car</code> 可以派生自不同的基类，而非派生自 <code>Vehicle</code>。</li>
</ul>
<h2 id="Example-3"><a class="header-anchor" href="#Example-3">#</a>Example</h2>
<p>有一个 <code>Vehicle</code> 基类标识交通工具，并有 <code>Car</code> 和 <code>Trunk</code> 两个派生类：<br>
<img src="/solid/image-20230610162905254.png" alt="Vehicle 和派生类 "></p>
<p><code>Vehicle</code> 类如下</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Vehicle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> speed = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> Vector3 direction;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GoForward</span>()</span> &#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Reverse</span>()</span> &#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TurnRight</span>()</span> &#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TurnLeft</span>()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>交通工具，可能在马路上，也可能在铁路上行驶，如下图所示：<br>
<img src="/solid/image-20230610163001603.png" alt="铁路和马路"></p>
<p>可以通过类 <code>Navigator</code> 来控制交通工具的行驶：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Navigator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Move</span>(<span class="params">Vehicle vehicle</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        vehicle.GoForward();</span><br><span class="line">        vehicle.TurnLeft();</span><br><span class="line">        vehicle.GoForward();</span><br><span class="line">        vehicle.TurnRight();</span><br><span class="line">        vehicle.GoForward();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时如果将 <code>Train</code> 传递给 <code>Navigator</code> 就会发现，<code>Train</code> 在铁轨上是不能进行左右转弯的：<br>
<img src="/solid/image-20230610163250520.png" alt="Train 无法进行左右转弯"></p>
<p>此时即破坏了里氏替换原则，因为基类 <code>Vehicle</code> 要求交通工具要实现左右转弯，而 <code>Train</code> 并无法实现，即基类无法被派生类的替换。</p>
<p>为了修复这个问题，可以使用组合，将转向和移动拆分成两个接口，而不是集中在 <code>Vehicle</code> 基类中：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ITurnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TurnRight</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TurnLeft</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IMovable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GoForward</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Reverse</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建两个基类 <code>RoadVehicle</code> 和 <code>RailVehicle</code> 使用这两个接口，如下所示。此时每一个派生类都完美的实现了基类（<code>ITurnable</code> 和 <code>IMovable</code>）的功能，即满足了里氏替换原则：<br>
<img src="/solid/image-20230610165245750.png" alt="符合里氏替换原则的 Car / Train"></p>
<p>实现如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RoadVehicle</span> : <span class="title">IMovable</span>, <span class="title">ITurnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> speed = <span class="number">100f</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> turnSpeed = <span class="number">5f</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">GoForward</span>()</span> &#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Reverse</span>()</span> &#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">TurnLeft</span>()</span> &#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">TurnRight</span>()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RailVehicle</span> : <span class="title">IMovable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> speed = <span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">GoForward</span>()</span> &#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Reverse</span>()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Car</span> : <span class="title">RoadVehicle</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Train</span> : <span class="title">RailVehicle</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<h1 id="I_Interface_Segregation_Principle_接口隔离原则"><a class="header-anchor" href="#I_Interface_Segregation_Principle_接口隔离原则">#</a>I - Interface Segregation Principle 接口隔离原则</h1>
<p>使用多个特定细分的接口比单一的总接口要好，不能强迫用户去依赖他们用不到的接口。</p>
<p><img src="/solid/image-20220703135800770.png" alt="|400"></p>
<h2 id="Example-4"><a class="header-anchor" href="#Example-4">#</a>Example</h2>
<p>如在一个策略游戏中，有很多的单位。开发者可能会定义一个如下接口保证所有的对象都实现相似的功能：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IUnitStats</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> Health &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Defense &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Die</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TakeDamage</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RestoreHealth</span>()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> MoveSpeed &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> Acceleration &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GoForward</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Reverse</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TurnLeft</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TurnRight</span>()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Strength &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Dexterity &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Endurance &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个接口太过于复杂了，比如一个爆炸桶单位并不会移动，因此如果爆炸桶继承了该类，它必须要实现无意义的 <code>GoForward</code>，<code>TurnLeft</code> 等接口。</p>
<p>符合接口合理原则的方式，是将上述的接口进行拆分，如下所示。此时每一个派生类都能实现它真正需要的接口：<br>
<img src="/solid/image-20230610172229144.png" alt="符合接口隔离的接口定义"></p>
<p>定义的接口为：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IMovable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> MoveSpeed &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> Acceleration &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GoForward</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Reverse</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TurnLeft</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TurnRight</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IDamageable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> Health &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Defense &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Die</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TakeDamage</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RestoreHealth</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IUnitStats</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Strength &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Dexterity &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Endurance &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IExplodable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> Mass &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> ExplosiveForce &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> FuseDelay &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Explode</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ExplodingBarrel</span> : <span class="title">MonoBehaviour</span>, <span class="title">IDamageable</span>, <span class="title">IExplodable</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EnemyUnit</span> : <span class="title">MonoBehaviour</span>, <span class="title">IDamageable</span>, <span class="title">IMovable</span>, <span class="title">IUnitStats</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<h1 id="D_Dependency_Inversion_Principle_依赖倒置原则"><a class="header-anchor" href="#D_Dependency_Inversion_Principle_依赖倒置原则">#</a>D - Dependency Inversion Principle 依赖倒置原则</h1>
<p>程序要依赖于抽象接口，而不是具体实现。</p>
<ul>
<li>高层模块不应该依赖底层模块，二者都应该依赖于抽象</li>
<li>抽象不应该依赖具体实现，具体实现应该依赖抽象</li>
</ul>
<p><img src="/solid/image-20220703135905806.png" alt="依赖倒置原则"></p>
<div class="note info simple"><p>关于内聚耦合的定义和解释，见 <a href="/coupling/#%E9%AB%98%E5%86%85%E8%81%9A%E4%BD%8E%E8%80%A6%E5%90%88">高内聚低耦合</a></p>
</div>
<p>在编码时，自然的会产生 <code>High-Level</code> 的模块和 <code>Low-Level</code> 的模块。很自然的情况下，<code>High-Level</code> 模块会依赖 <code>Low-Level</code> 模块实现某些功能，但依赖导致原则则需要将整个依赖关系转为依赖抽象。</p>
<h2 id="Example-5"><a class="header-anchor" href="#Example-5">#</a>Example</h2>
<p>如需要实现<em>打开门</em> 这一功能，常见的会定义一个 <code>Switch</code> 类管理门的开启或关闭，并定义 <code>Door</code> 表示门。 <code>Switch</code> 是 <code>High-Level</code> 模块，<code>Door</code> 是 <code>Low-Level</code> 模块。</p>
<p>最常见的实现情况如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Switch</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Door door;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isActivated;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Toggle</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isActivated)</span><br><span class="line">        &#123;</span><br><span class="line">            isActivated = <span class="literal">false</span>;</span><br><span class="line">            door.Close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            isActivated = <span class="literal">true</span>;</span><br><span class="line">            door.Open();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Door</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Open</span>()</span> &#123; Debug.Log(<span class="string">&quot;The door is open.&quot;</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Close</span>()</span> &#123; Debug.Log(<span class="string">&quot;The door is closed.&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时依赖关系为：<br>
<img src="/solid/image-20230611125426387.png" alt="高等级的 Switch 依赖低等级的 Door "></p>
<p>这种实现可以正常运作，但 <code>Switch</code> 直接依赖了 <code>Door</code>，如果 <code>Switch</code> 要控制更多的物体，如灯泡，电风扇则需要再次修改。</p>
<p>解决方法是增加 <code>ISwitchable</code> 接口，<code>Switch</code> 依赖 <code>ISwitchable</code> 而不依赖 <code>Door</code>，如下：<br>
<img src="/solid/image-20230611144515909.png" alt="使用 ISwitchable 作为两个类的桥梁"></p>
<p>实现代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ISwitchable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isActive &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Activate</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Deactivate</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Switch</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> ISwitchable client;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Toggle</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (client.isActive)</span><br><span class="line">            client.Deactivate();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            client.Activate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Door</span> : <span class="title">MonoBehaviour</span>, <span class="title">ISwitchable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isActive &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Activate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        isActive = <span class="literal">true</span>;</span><br><span class="line">        Debug.Log(<span class="string">&quot;The door is open.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Deactivate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        isActive = <span class="literal">false</span>;</span><br><span class="line">        Debug.Log(<span class="string">&quot;The door is closed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时再需要定义新的可开关变量，只需要新增类而无需修改 <code>Switch</code> 脚本。这就是依赖倒置原则带来的好处：<br>
<img src="/solid/image-20230611151422409.png" alt=""></p>
<h1 id="Reference"><a class="header-anchor" href="#Reference">#</a>Reference</h1>
<p><a href="https://blog.unity.com/games/level-up-your-code-with-game-programming-patterns">Level up your code with game programming patterns | Unity Blog</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/130954951">图解你身边的 SOLID 原则 - 知乎 (zhihu.com)</a></p>
]]></content>
      <tags>
        <tag>设计模式</tag>
        <tag>编码规范</tag>
      </tags>
  </entry>
  <entry>
    <title>《贪婪的多巴胺》 读书笔记</title>
    <url>/tan_lan_de_duo_ba_an/</url>
    <content><![CDATA[<p>《贪婪的多巴胺》 笔记摘抄。该书主要从生物学角度介绍了多巴胺对人行为及心理的影响。主要的包括：</p>
<ul>
<li>多巴胺与当下因子：当下因子让人关注当下，多巴胺让人关注未来</li>
<li>多巴胺与自律的关系：毒品美食的吸引力来自于欲望多巴胺，抵抗这些诱惑的能力不仅可以依赖意志力，也可以依赖控制多巴胺。</li>
<li>多巴胺与创造力的关系：丰富的多巴胺，让人更多的关注抽象的概念，并压抑了对此刻的关注，这可能会带来更多的创造力。但过多的多巴胺，则可能带来如精神分裂症这样的疾病</li>
<li>多巴胺与保守的关系：多巴胺能的人倾向于自由主义，当下分子能的人倾向于保守主义。</li>
</ul>
<h1 id="第一章_爱情"><a class="header-anchor" href="#第一章_爱情">#</a>第一章 爱情</h1>
<p>二十万分之一的脑细胞可以产生多巴胺，但这些细胞却能对行为产生巨大的影响。</p>
<p>在特定的情况下，激活让人“感觉良好”的多巴胺是人们无法抗拒的诱惑。一些科学家给多巴胺取名为“快乐分子”，大脑中产生多巴胺的途径被称为“奖赏回路“。但实际上多巴胺跟快乐一点儿关系都没有，它的影响力比“快乐”要大得多</p>
<p>多巴胺不是快乐的制造者，而是对意外的反应，即对可能性和预期的反应。我们每时每刻都在预测将要发生的事，从什么时候可以下班，到在自动取款机上看到卡里有多少余额。实际发生的事好于我们的预期，就表明我们对未来的预言存在误差：可能我们可以提前下班了，或者查看余额时发现比预期多了 100 元。正是这种让人快乐的误差触发多巴胺行动起来。这种快乐不是源于额外的时间或钱本身，而是预期之外的好消息带来的兴奋感。</p>
<p>多巴胺能的兴奋（即预期带来的兴奋）并不持久，因为最终未来都会变成现在。</p>
<p>多巴胺的角度来说，拥有是无趣的，只有获得才有趣。</p>
<p>为了享受我们拥有的东西，而不是仅仅可能得到的东西，我们的大脑必须从面向未来的多巴胺过渡到面向现在的某种化学物质，这是一系列神经递质，我们称之为“<strong>当下分子</strong>“。事实上，尽管多巴胺和当下分子的回路能一起工作，但在大多数情况下它们是相互对抗的。在当下分子回路被激活时，我们更喜欢体验周围的真实世界，多巴胺就会被抑制；而当多巴胺回路被激活时，我们则进入一个充满可能性的未来，当下分子会被抑制。</p>
<p>基于当下神经递质，如<strong>催产素、血管升压素和内啡肽</strong>的作用，它会为你提供长期的幸福感。这就像我们心中总是有最喜欢的餐厅、商店、城市一样，我们之所以喜爱这些地方，是因为熟悉的环境总是能给我们带来快乐，这里所说的环境指那个地方真实的物理环境。我们喜欢熟悉的事物，不是因为它能变成什么，而是因为它本来的样子。</p>
<p>多巴胺代表着痴迷与渴望，而与长期关系最相关的化学物质则是催产素和血管升压素。催产素在女性中更活跃，而血管升压素在男性中更活跃。</p>
<p>性就是爱情的快进。性始于欲望，是由睾酮这种激素驱动的一种多巴胺能的现象。接下来是性兴奋，这也是一种期待性的多巴胺能的体验。当身体接触开始时，大脑就将控制权转移到当下分子以便提供感官体验的愉悦，这个过程主要涉及内啡肽的释放。这一行为的顶峰，即性高潮，几乎完全是一种此时此地的体验，内啡肽和其他当下神经递质一起工作，将多巴胺彻底关闭。除了少数例外，大脑对性高潮的反应是相同的：多巴胺被关闭，当下分子通行。但是，正如有些人很难从激情之爱过渡到陪伴之爱，由多巴胺驱动的人在性生活中也很难把主导权让给当下分子。也就是说，有着强烈多巴胺驱动力的女性和男性有时会发现，他们难以停止自己的想法，去纯粹地体验性爱中亲昵的感觉——少一些思考，多一些感觉对他们来说非常困难。</p>
<h1 id="第二章_毒品"><a class="header-anchor" href="#第二章_毒品">#</a>第二章 毒品</h1>
<p>欲望始于大脑中一个在进化上早就存在的区域，位于头骨深处，被称为腹侧被盖区。这一区域富含多巴胺，是多巴胺两个主要的产生区域之一。像大多数脑细胞一样，生长在那里的细胞长着长长的尾巴，穿过大脑到达伏隔核。这些长尾巴的细胞被激活时，会将多巴胺释放到伏隔核中，让我们产生做某事的动力。这个回路叫作中脑边缘通路，但我们通常更直白地称之为 <strong>多巴胺欲望回路</strong>。</p>
<p><img src="/tan_lan_de_duo_ba_an/image-20230212202055360.png" alt="欲望回路"></p>
<p>买家之所以会懊悔，就是因为当下体验无法弥补多巴胺能激励的损失。这是欲望回路描绘的美好前景被打破的一个体现。它告诉你，如果你购买了那辆昂贵的车，你会欣喜若狂，你的生活肯定也会改变。但是，在你买入之后，你却没有特别强烈的感觉，而且这种感觉也不会很持久。想要和喜欢是由大脑中的两个不同的系统产生的，所以我们想要的东西往往是我们不喜欢的。</p>
<p>一种避免购买后懊悔的方法是购买一些能触发更多多巴胺能预期的东西，例如，一种工具（如一台能大大提高工作效率的新电脑），或者一件让你出门时看起来更迷人的新夹克。</p>
<p>毒品会“劫持”欲望回路。它们与食物或性等自然奖赏一样会刺激大脑激励系统，但它们刺激大脑的强度远甚于自然奖赏。成瘾性药物像导弹一样，以猛烈的“化学爆炸”冲击着欲望回路。任何自然行为都比不上它，食物、性，什么都比不上。</p>
<p>多巴胺系统的目标是预测未来，当一个意想不到的奖赏出现时，它就会发送一个信号说：“注意！现在要学习一些新东西了。”这样，沉浸在多巴胺中的脑回路就产生了可塑性，它们变成了新的样式。新的记忆被储藏，新的连接也形成了。“记住发生了什么，”多巴胺回路说，“这在将来可能有用。”最终结果是什么？下次奖赏出现时，你就不会感到惊讶了。当你发现一个网站播放着你最喜欢的音乐时，你会感到兴奋，但下一次访问这个网站时就不会了，它不再有任何奖赏预测误差。多巴胺并不是一种持久的快乐储存体。毒品破坏了大脑正常运作所需的微妙平衡。无论吸毒者处于何种情况，毒品都会刺激多巴胺的释放。于是，大脑变得混乱不堪，开始将吸毒与一切事物联系起来</p>
<p>当你期望的奖赏没有实现时，多巴胺系统就会关闭。用科学术语来讲，当多巴胺系统处于静止状态时，它会以每秒 3 到 5 次的速度被激发。但当它兴奋时，它的激发速率会激增到每秒 20 到 30 次。当预期的奖赏没有实现时，多巴胺的激发速率会下降到零，而这种感觉很糟糕。就是为什么多巴胺的停止会让你感到愤恨和失落，一个正在恢复的毒瘾患者每天保持克制和冷静时也是这种感受。克服上瘾需要付出巨大的力量、决心和支持。不要轻易招惹多巴胺，它的反击会让人招架不住</p>
<p>多巴胺的增加会让人热情参与自己原本认为不重要的事务。例如，有报道称一些吸大麻的人会站在水池前，看着水龙头不断地滴水，这一平平无奇的景象让他们看得十分着迷。欲望多巴胺压制了大脑中更理性的部分。我们知道自己做出的选择并不符合我们的最大利益，但我们无力抗拒。这就好比我们的自由意志已经屈服于一种强烈的及时行乐的冲动——也许是我们在节食时吃的一袋薯片，也许是一夜挥霍。</p>
<p>上瘾不是性格软弱或意志力不足的表现，它只是欲望回路因过度刺激而进入病理状态时会发生的情况。</p>
<p>帕金森病是一种多巴胺缺乏症，患有这种病的人负责控制肌肉运动的一条通路中多巴胺不足。这条通路，简单地说，就是我们将内心世界转化为行动，以及将意志施加给世界的途径。当这条通路中没有足够的多巴胺时，人就会僵硬和颤抖，并且移动缓慢。治疗方法是吃一些能促进多巴胺增长的药物。</p>
<p>什么样的大脑回路强大到足以对抗多巴胺呢？答案是多巴胺，多巴胺可以对抗多巴胺。与欲望回路相反的回路可以被称为“多巴胺控制回路”。</p>
<h1 id="第三章_掌控的力量"><a class="header-anchor" href="#第三章_掌控的力量">#</a>第三章 掌控的力量</h1>
<p>多巴胺通过不同的大脑回路也会产生不同的功能，经过中脑边缘回路的多巴胺会产生冲动，我们称该回路为 <strong>多巴胺欲望回路</strong> 。计算和规划（控制各种情况的手段）来自中脑皮层回路，我们称之为 <strong>多巴胺控制回路</strong></p>
<p>控制多巴胺利用欲望多巴胺提供的兴奋和动力，评估选项、挑选工具，并制定策略来获得想要的东西</p>
<p>多巴胺的功能来自进化和生存的需要。多巴胺鼓励我们最大限度地利用资源，因此，当我们把一件事情做得更好，使我们的未来成为一个更好、更安全的地方时，多巴胺就会奖励我们，给我们一点儿“躁起来”的感觉。多巴胺驱动了努力。这种努力的特征可能受到其他很多因素的影响，但如果没有多巴胺，努力从一开始就根本不会存在。</p>
<p>当别人对成功抱有很高的期望时，我们就会给他们让路。我们会服从他们的意志——在控制多巴胺的驱动下，他们的自我效能得到了完全的表达。我们的大脑之所以进化成这样，有一个充分的理由：参加一场你无法取胜的比赛可不明智。如果你发现对手对成功抱有很高的期望，那么你想要获胜就不那么容易了。<br>
为什么控制性神经递质多巴胺会触发顺从行为？这不是矛盾吗？一点儿也不矛盾。在控制回路中，多巴胺驱动的是控制环境，而不一定是环境中的人。多巴胺想要更多，但它不在乎它是如何得到的。无论道德还是不道德，控制还是顺从，对多巴胺而言都是一样的，只要它能使未来更好。</p>
<p>欲望多巴胺会促进毒瘾，让人追求快感，但收获的多巴胺刺激越来越少，同样，有些人的控制多巴胺如此之多，这使他们对成就上瘾，因而无法体验当下的满足。<br>
这是聚焦未来的多巴胺和聚焦现在的当下神经递质之间的失衡。他们想要逃避当下的情感和感官体验。对他们来说，生活关乎未来，关乎进步，关乎创新。尽管他们的努力带来了金钱甚至名声，但他们总是不开心。不管做了多少，他们都觉得不够。</p>
<p>额叶负责控制多巴胺的活动，它是发育得最晚的脑区，直到一个人结束青春期进入成年期之后，它才与大脑的其他部分完成连接。控制回路的工作之一是限制欲望回路，因此冲动控制与 ADHD 相关。当控制多巴胺很弱时，人们会去追求他们想要的东西而不考虑长期的后果。多巴胺的生成不受良心的约束。相反，在欲望的滋养下，它是狡猾的源泉。它被激发时，会抑制内疚感这种当下的情绪。它能够激励人们做出不懈的努力，但在追求的过程中不能避免使用欺骗甚至暴力手段 。</p>
<p>由激情驱使的攻击是对挑衅的猛烈回击，但这并不是由多巴胺控制回路刻意安排的动作。恰恰相反，当激情驱使着我们攻击挑衅者时，当下分子回路会抑制多巴胺。</p>
<p>当下分子回路相抗衡的多巴胺可以关闭情绪的音量。在复杂的情况下，拥有“冷静头脑”的人，也就是多巴胺能更强的人，能够抑制这种反应，做出更深思熟虑的选择，这些选择通常会带来更好的结果。传统观点将他的脱险归因于“肾上腺素爆发”，事实则恰恰相反。他不是靠肾上腺素爆发，而是靠多巴胺爆发。在他拯救船只的紧张时刻，多巴胺开始掌控局面，肾上腺素（当它在大脑中时被称为去甲肾上腺素）被抑制。</p>
<p>但当我们需要抵制有害的欲望时，意志力是我们首先使用的工具。事实证明，这可能不是个好选择。意志力可以帮助酒鬼拒绝一次喝酒，但如果他要在几个月或几年的时间里一次次地拒绝的话，他很可能坚持不住。意志力就像一块肌肉，用过之后会疲劳，可能用不了多久，它就放弃了 。于是就有了通过多巴胺对抗多巴胺的疗法，包括：</p>
<ul>
<li>动机增强疗法：用欲望多巴胺对抗欲望多巴胺</li>
<li>认知行为疗法：用控制多巴胺对抗欲望多巴胺</li>
<li>十二步促进疗法：用当下分子对抗欲望多巴胺<br>
当下的内疚感是一种强大的动力（你母亲或许也经常利用这一点）。情感的支持和内疚的威胁相结合，帮助许多瘾君子长期保持不复饮</li>
</ul>
<h1 id="第四章_天才与疯子"><a class="header-anchor" href="#第四章_天才与疯子">#</a>第四章 天才与疯子</h1>
<p>有可能影响你未来的事情是突出的，能触发欲望多巴胺的事情也是突出的。突出的信息提醒你：“该醒醒了！”“当心点儿！”“兴奋起来！”“这很重要！ 如果大脑在突出性方面的功能失灵，即在没有发生对你真正重要的事情时，它也爆发了，那么会发生什么呢？想象你在看新闻，主持人正在谈论政府的一项间谍计划，突然你的突出性回路无缘无故地启动，你可能就会相信新闻上的这个故事和你有关。突出性过强或者在错误的时间出现，都会产生错觉，让触发事件从默默无闻上升到至关重要。</p>
<p>患有精神分裂症的人通过服用阻断多巴胺受体的药物来控制多巴胺的活动。阻断多巴胺通常不会使精神分裂症的所有症状消失，但可以消除妄想和幻觉。不幸的是，抗精神病药物会阻断整个大脑的多巴胺，而阻断额叶的控制回路会使某些方面变得更糟，例如难以集中注意力和难以用抽象概念推理。</p>
<p>精神分裂症的患者大脑处于短路状态，把原本熟悉而被忽视的普通事物变得更显著。这种状态也叫作“低潜在抑制“。“潜在抑制”中“潜在”的含义略有不同。不是说一件事从一开始就被隐藏起来，而是说我们把它隐藏起来，因为它对我们不重要。</p>
<p>我们会抑制自己关注不重要事物的能力，这样就不必把注意力浪费在它们上面。我们在街上走的时候，如果被干净透亮的窗户分散了注意力，可能就注意不到十字路口处“禁止通行”的标志。</p>
<p>有时我们的环境充满了新事物，使得潜在抑制能力无法挑选出最重要的东西。这种经历可能令人兴奋，也可能令人恐惧。如你身处异国他乡，没有什么可抑制的，它就能带来极大的愉悦，但也会让人混乱、迷失方向，这就是文化冲击。</p>
<p>模型是我们为了更好地理解世界而建立起的对世界的假想图示。在某些方面，模型就像潜在抑制。模型只包含模型建造者认为必不可少的环境元素，不包含其他细节。这使得这个世界更容易理解，后续我们还可以通过各种方式来操纵它以获得最大利益。模型不仅简化了我们对世界的理解，而且还让我们做抽象归纳，利用获取的特定经验来制定广泛、通用的规则，从而预测和处理从未遇到的情况。<br>
当我们需要在许多不同的选项中进行选择时，模型会很有帮助。它们让我们想象不同的场景，以便选出最佳的一个。</p>
<p>糟糕的现实模型可能是由许多因素造成的：没有足够的信息，难以进行抽象思考，或者执着于错误的假设。这些糟糕的假设可能会导致焦虑和抑郁等精神疾病。例如，如果一个孩子在父母的挑剔下长大，她可能会产生自己是一个无能的人的想法，这种想法将塑造她一生所创造的世界模型 。</p>
<p>模型是一种强大的工具，但也有缺点。它们会让我们陷入特定的思维方式中，导致我们错失一些改善世界的机会</p>
<p>美术和自然科学之间的共同点，比大多数人认为的要更多，因为两者都是由多巴胺驱动的。诗人写一首描写爱而不得的诗句和物理学家写出电子激发公式没有什么不同，都需要创作者具有超越感官世界，进入一个更深层、更深刻的抽象思想世界的能力。</p>
<p>高水平的多巴胺会抑制当下分子的功能，所以聪明的人在人际关系上往往很差。我们需要当下的同理心来理解别人的想法，这是社交互动的基本技能。极其聪明、成功和极富创造性的人，也就是那些典型的多巴胺丰富的人通常会表达一种奇怪的情绪：他们对人类充满激情，但对个人却没有耐心。</p>
<h1 id="第五章_自由与保守"><a class="header-anchor" href="#第五章_自由与保守">#</a>第五章 自由与保守</h1>
<p>多巴胺能的人倾向于支持自由主义政策。自由主义者经常把自己称为“进步的”，这个词意味着不断的提升。 硅谷的企业家以及为他们工作的人，往往极富多巴胺能。他们意志坚强、敢于冒险、追求刺激，与《美国政治科学杂志》修正版文章中的自由主义者的特征相符。 一项针对初创企业创始人的调查显示，83% 的人持进步主义的观点，认为教育可以解决社会上的所有或大部分问题。而在公众中，只有 44% 的人相信这是真的。《纽约时报》的一篇评论指出，只有 2% 的英语系教授是共和党人，而 18% 的社会学家则认为自己是马克思主义者。</p>
<div class="note info simple"><p>多巴胺能的人倾向于自由主义，当下分子能的人倾向于保守主义。</p>
</div>
<p>大多数专家都认为智商测试并不能衡量一般智力。它更着重于衡量根据不完整数据进行归纳和使用抽象规则找出新信息的能力。智商测试衡量了一个人根据过去的经验建立假想模型，然后利用这些模型预测未来会发生什么的能力。控制多巴胺在这些过程中起着很大的作用。</p>
<p>理性决定是不可靠的，总是随着新证据的出现而随时可能被修改。非理性则更持久，欲望多巴胺和当下分子通路都可以被用来引导人们做出非理性的决定。最有效的工具是恐惧、欲望和同情。 不论是哪种政治倾向的人，他们在感受到威胁时都会变得更加保守。一瓶洗手液能唤醒人对于病毒的恐惧。研究进化对人类行为影响的心理学家格伦·D. 威尔逊（Glenn D. Wilson）教授开玩笑说，在选举季节，厕所里张贴“员工必须洗手才能重返工作岗位”的标志就是在给共和党打广告。</p>
<p>保守主义者倾向于关注较小的群体，比如个人、家庭和国家，而自由主义者则更倾向于关注更大的群体：由所有人组成的全球社区。</p>
<p>把贫困移民拒之门外让人想起了爱因斯坦的那句话：“我对社会正义和社会责任充满热情，但我与其他人直接接触时却表现冷淡，这实在是一种奇怪的对比。”保守派似乎恰恰相反。他们想把非法移民排除在这个国家之外，以防止他们担心的事情发生，即他们的文化发生根本性转变。然而，伤害厌恶会促使他们愿意去照顾住在本国的人。</p>
<p>政治是一种多巴胺能的活动，因为政府是通过抽象的法律从远处管理人民的。由当下回路控制的暴力为法律树立威信。由于政府的本性就是多巴胺能的，自由主义者往往比专注于当下的保守主义者更热衷于此。相比之下，保守主义者更容易不信任政府，特别是距离较远的政府。保守派倾向于地方治理，权力在州或地方一级，而不是联邦一级。</p>
<h1 id="第六章_进步"><a class="header-anchor" href="#第六章_进步">#</a>第六章 进步</h1>
<p>多巴胺受体 D4 的一种编码基因。D4 基因的一个变体被称为 7R，拥有 7R 变体的人喜欢探求新奇事物。 他们喜欢追求新的体验，因为他们不大能容忍无聊。他们喜欢探索新的地方、想法、食物、毒品和性机会，他们是冒险家。全世界大约 1/5 的人有 7R 等位基因，但各地的差异很大。</p>
<p>经历了漫长征程的南美原住民中，长多巴胺等位基因的比例最高，达到 69%。在迁徙较短距离并定居北美的人中，只有 32% 的人拥有长等位基因。中美洲原住民的比例介于它们之间，为 42%。据估计，平均每迁移 1 000 英里，长等位基因的比例就会增加 4.3 个百分点。确定了 DRD4 基因的 7R 等位基因与种群迁移的距离有关以后，下一个问题就是为什么迁徙成员中的 7R 等位基因更多？答案是，也许 7R 等位基因并没有引发迁移，但一旦迁移开始，这一等位基因就会赋予携带者生存优势。7R 等位基因的一个优点是，它会让你不断探索新环境，以便寻找机会来使资源最大化。换句话说，它促进了对新事物的探索。不断前进的部落会一代又一代地经历陌生的环境。7R 的生殖优势将继续下去，7R 携带者将活得更长，生育更多的孩子。随着时间的推移，7R 等位基因在这些长途迁移者中会变得越来越普遍。</p>
<p>双相情感障碍中的双相又称两极（bipolar），是指两种极端的情绪。双相情感障碍患者会经历抑郁发作，即情绪异常低落，也会经历躁狂发作，即情绪过于高昂。后者与高水平的多巴胺有关，考虑到躁狂状态的症状，这一点儿也不奇怪。<br>
在舞蹈、表演、音乐和写作等创造性领域工作的人与没有从事创造性工作的人相比，患双相情感障碍的可能性高出 25%。在另一项研究中，格拉斯哥大学的科学家跟踪了 1 800 多名 8 岁到 20 岁出头的人。他们发现，8 岁时的智商分数越高，23 岁或之前患双相情感障碍的风险就越大。<br>
与普通大脑相比，聪明的大脑患多巴胺能精神疾病的风险更大。许多著名的有创造力的人都透露他们患有双相情感障碍。</p>
<p>多巴胺过度活动并不是双相情感障碍的唯一问题，但它起着重要的作用。它不是由高活性 DRD4 受体等位基因引起的。科学家认为这是由多巴胺转运体引起的。多巴胺转运体就像吸尘器，它可以限制多巴胺刺激周围细胞的时间。<br>
当一个能产生多巴胺的细胞被激活时，它会释放出它储存的多巴胺，后者与其他脑细胞的受体结合。之后，多巴胺转运体会将多巴胺吸回原来的细胞中，结束与受体的相互作用，以便后续再重复这一过程。这种转运体有时被称为“再摄取泵”，因为它将多巴胺重新泵入细胞。<br>
当转运体不能正常工作时会发生什么？我们可以通过研究滥用可卡因的人的行为来回答这个问题。可卡因会阻滞多巴胺转运体，就像把袜子塞进吸尘器吸嘴一样。这种阻滞作用使多巴胺能够一次又一次地与其受体相互作用。当这种情况发生时，人们会感受到更多的能量，也会有更多目标导向的活动和更强的性冲动。人的自尊和兴奋感得到提升，喜欢从一个话题跳到另一个话题。可卡因中毒与躁狂症十分相似，有时医生都难以区分。</p>
<p>高多巴胺能的科学家为高多巴胺能的统治者制造了末日武器。科学家无法阻止自己制造出更加致命的武器，独裁者也无法阻止自己对权力的贪欲。<br>
另一个容易想象到的世界末日场景是多巴胺驱使我们消耗越来越多的资源，直到我们毁灭地球<br>
着眼于未来的多巴胺让人不再生孩子，因为生活在发达国家的人在年老时不依赖孩子来抚养他们。</p>
<h1 id="第七章_和谐"><a class="header-anchor" href="#第七章_和谐">#</a>第七章 和谐</h1>
<p>现代世界驱使我们向着每时每刻全是多巴胺的状态发展。过多的多巴胺会导致精力旺盛的痛苦（如工作狂式的主管），而过多的当下神经递质则会导致快乐的懒惰（如躺在地下室抽大麻的人）。</p>
<p>从多巴胺的角度来看，精通是一件值得期待和追求的好事，但它不同于其他好事。它不仅仅是寻找食物和新的合作伙伴，或者击败竞争对手，它比这些更宏大、更普遍。它是我们成功提取奖励的过程：多巴胺达到了多巴胺的目标。实现了精通，多巴胺到达了它渴望的顶峰——挤压了所有可用资源的最后一滴。<br>
在尽其所能之后，多巴胺会暂停下来，允许当下分子在我们的快乐回路中发挥作用。在这一刻，多巴胺不再对抗满足感，它让它通行——即使只持续很短的一段时间。最好的享受就是沉浸在一份干得好的工作中。</p>
<p>关注现实，关注你此刻所做的事情，可以使进入你大脑的信息流最大化。它能最大限度地提高多巴胺制订新计划的能力，因为为了建立模型以准确地预测未来，多巴胺需要数据，以及来自感官的数据流。这时，多巴胺和当下分子就联手工作了。</p>
]]></content>
      <tags>
        <tag>心理</tag>
        <tag>自然科学</tag>
        <tag>科普</tag>
      </tags>
  </entry>
  <entry>
    <title>《Unix 编程艺术》</title>
    <url>/unix_bian_cheng_yi_shu/</url>
    <content><![CDATA[<h1 id="Part_1_Context"><a class="header-anchor" href="#Part_1_Context">#</a>Part 1 Context</h1>
<p><a href="/di_1_zhang_zhe_xue">第 1 章 哲学</a><br>
<a href="/di_2_zhang_li_shi%E2%80%94%E2%80%94shuang_liu_ji">第 2 章 历史——双流记</a><br>
<a href="/di_3_zhang_dui_bi%EF%BC%9Aunix_zhe_xue_tong_qi_ta_zhe_xue_de_bi_jiao">第 3 章 对比：Unix 哲学同其他哲学的比较</a></p>
<h1 id="Part_2_Design"><a class="header-anchor" href="#Part_2_Design">#</a>Part 2 Design</h1>
<p>第 4 章 模块性：保持清晰，保持简洁<br>
第 5 章 文本化：好协议产生好实践<br>
第 6 章 透明性：来点儿光<br>
第 7 章 多道程序设计：分离进程为独立的功能A<br>
第 8 章 微型语言：寻找歌唱的乐符<br>
第 9 章 生成：提升规格说明的层次<br>
第 10 章 配置：迈出正确的第一步<br>
第 11 章 接口：Unix 环境下的用户接口设计模式<br>
第 12 章 优化<br>
第 13 章 复杂度：尽可能简单，但别简单过了头</p>
<h1 id="Part_3_Implementation"><a class="header-anchor" href="#Part_3_Implementation">#</a>Part 3 Implementation</h1>
<p>第 14 章 语言：C 还是非 C<br>
第 15 章 工具：开发的战术<br>
第 16 章 重用：论不要重新发明轮子</p>
<h1 id="Part_3_Community"><a class="header-anchor" href="#Part_3_Community">#</a>Part 3 Community</h1>
<p>第 17 章 可移植性：软件可移植性与遵循标准<br>
第 18 章 文档：向网络世界阐释代码<br>
第 19 章 开放源码：在 Unix 新社区中编程<br>
第 20 章 未来：危机与机遇</p>
]]></content>
      <tags>
        <tag>编码规范</tag>
        <tag>系统设计</tag>
      </tags>
  </entry>
  <entry>
    <title>《You and Your Research》 摘抄</title>
    <url>/you_and_your_research/</url>
    <content><![CDATA[<p>这篇摘抄来源于对 <em>理查德·卫斯理·汉明（Richard Wesley Hamming）</em> 在 1986 年 3 月 7 日 的名为 <code>You and Your Research</code> 演讲的转录。</p>
<div class="note info simple"><p>Hamming，1968 年图灵机获得者，信息论中 <a href="https://en.wikipedia.org/wiki/hamming_distance">Hamming Distance</a> 理论主要贡献者</p>
</div>
<p>该演讲主要聚焦在 Hamming 对 “为什么只有极少数的科学家做出了伟大的贡献，而绝大部分科学家却在时间的长流中被遗忘” 这一问题的观察和研究。</p>
<div class="note info simple"><p>以下内容是对演讲转录的摘抄，完整的演讲内容见 <a href="https://www.cs.virginia.edu/~robins/youandyourresearch.html">You and Your Research</a></p>
</div>
<div class="note info simple"><p>摘抄的内容并非逐字的对原文进行翻译，为保证阅读流畅，可能会更改/增删一些表达，但尽可能的保证表达的含义相同。</p>
</div>
<div class="note info simple"><p>以下摘抄中为 Hamming 的第一人称。</p>
</div>
<h1 id="The_Talk"><a class="header-anchor" href="#The_Talk">#</a>The Talk</h1>
<blockquote>
<p>I saw I was a stooge. I saw that although physically I was the same, they were different. And to put the thing bluntly, I was envious.<br>
…<br>
I continued examining the questions, Why? and What is the difference?‘’ I continued subsequently by reading biographies, autobiographies, asking people questions such as: ``How did you come to do this?‘’ I tried to find out what are the differences. And that’s what this talk is about.</p>
</blockquote>
<p>我在刚加入贝尔实验室时，面对费曼，香农，汉斯等科学家时，深感到自己与他们的差异，并对他们的能力和高效感到羡慕。为了探索出他们与自己不同的原因，我阅读了传记，自传以及对他们进行了采访。这些探索过程和结果便是这个演讲的内容。</p>
<blockquote>
<p>Now, why is this talk important? I think it is important because, as far as I know, each of you has one life to live. Even if you believe in reincarnation it doesn’t do you any good from one life to the next! Why shouldn’t you do significant things in this one life<br>
…<br>
I will talk mainly about science because that is what I have studied.<br>
…<br>
Outstanding work is characterized very much the same way in most fields, but I will confine myself to science.</p>
</blockquote>
<p>为什么这个话题很重要，因为人只会活一次，即便你相信来世，也没关系，为何不在今生就做一些伟大的事呢？</p>
<p>我将会主要通过科学领域的观察来回答这个话题，但这个话题同样适用于其他的领域。</p>
<blockquote>
<p>I have to get you to drop modesty and say to yourself, ``Yes, I would like to do first-class work.‘’ Our society frowns on people who set out to do really good work. You’re not supposed to; luck is supposed to descend on you and you do great things by chance.</p>
</blockquote>
<h2 id="关于运气"><a class="header-anchor" href="#关于运气">#</a>关于运气</h2>
<blockquote>
<p>In order to get at you individually, I must talk in the first person. I have to get you to drop modesty and say to yourself, ``Yes, I would like to do first-class work.‘’ Our society frowns on people who set out to do really good work. You’re not supposed to; luck is supposed to descend on you and you do great things by chance.</p>
</blockquote>
<p>你应该放弃谦逊，并对自己说 “是的，我想做一流的工作”。我们的社会风气并不赞赏那些努力去做伟大事业的人，它期望的是某人做出了伟大的工作，是因为这个人踩了狗屎运。</p>
<blockquote>
<p>I find that the major objection is that people think great science is done by luck. It’s all a matter of luck. Well, consider Einstein. Note how many different things he did that were good. Was it all luck?</p>
</blockquote>
<p>我发现科学研究最大的阻碍在于人们认为伟大的科学是靠运气完成的，认为所有科学研究都是运气问题。但你想下爱因斯坦，想下他做了多少伟大的工作，难道所有这些伟大工作都是因为爱因斯坦运气好吗？</p>
<blockquote>
<p>You see again and again, that it is more than one thing from a good person<br>
…<br>
I claim that luck will not cover everything. And I will cite Pasteur who said, ``Luck favors the prepared mind.‘’<br>
…<br>
The prepared mind sooner or later finds something important and does it. So yes, it is luck. The particular thing you do is luck, but that you do something is not.</p>
</blockquote>
<p>你会一次又一次看到，一个优秀的人并不是仅仅有一个成就。Pasteur 说 “好运偏爱有准备的人”，那些有准备的人或早或晚都会发现一个重要的事情并去完成它。</p>
<blockquote>
<p>I want to dispose of this matter of luck as being the sole criterion whether you do great work or not. I claim you have some, but not total, control over it.<br>
…<br>
Newton said, ``If others would think as hard as I did, then they would get similar results.‘’</p>
</blockquote>
<p>我反对的是将运气作为你是否能做伟大工作的唯一标准。针对于“运气”，你对它是存在一些控制权的，就像牛顿所言“如果其他人像我一样思考，他们就会得到和我相似结果。”</p>
<h2 id="关于勇气"><a class="header-anchor" href="#关于勇气">#</a>关于勇气</h2>
<blockquote>
<p>Bill Pfann, the fellow who did zone melting, came into my office one day. He had this idea dimly in his mind about what he wanted and he had some equations. … but ultimately he has collected all the prizes in the field. Once he got well started, his shyness, his awkwardness, his inarticulateness, fell away and he became much more productive in many other ways. Certainly he became much more articulate.</p>
</blockquote>
<blockquote>
<p>A fellow named Clogston…I didn’t think he had much…Well I would have fired the fellow…Clogston finally did the Clogston cable. After that there was a steady stream of good ideas. One success brought him confidence and courage.</p>
</blockquote>
<p>Bill Pfann 一开始在他们部门的认可微乎其微，但他最后获得了他领域的所有奖项。他开始获奖后，他的害羞，他的尴尬，他的口吃都消失了。他在许多领域都变得更加高效，他也变得更加善于表达。</p>
<p>我的一个叫做 Clogston 的同事，我觉得他并没有太多的才华，甚至于我曾想要开除他。但他最终做出了以他命名的电缆，一次的成功给他带来了自信和勇气。</p>
<blockquote>
<p>One of the characteristics of successful scientists is having courage. Once you get your courage up and believe that you can do important problems, then you can. If you think you can’t, almost surely you are not going to.<br>
That is the characteristic of great scientists; they have courage. They will go forward under incredible circumstances; they think and continue to think.</p>
</blockquote>
<p>成功科学家的一大品质就是拥有勇气，一旦你鼓起勇气并相信你能解决重要的问题，那你就能成功。而如果你认为自己做不到，那大概率你确实无法做到。</p>
<p>伟大科学家的勇气，让他们即使在几乎不可能的情况下，仍然能思考，仍然能继续思考。</p>
<h2 id="关于年龄"><a class="header-anchor" href="#关于年龄">#</a>关于年龄</h2>
<blockquote>
<p>Age is another factor which the physicists particularly worry about. They always are saying that you have got to do it when you are young or you will never do it. Einstein did things very early, and all the quantum mechanic fellows were disgustingly young when they did their best work. Most mathematicians, theoretical physicists, and astrophysicists do what we consider their best work when they are young. It is not that they don’t do good work in their old age but what we value most is often what they did early. On the other hand, in music, politics and literature, often what we consider their best work was done late. I don’t know how whatever field you are in fits this scale, but age has some effect.</p>
</blockquote>
<p>年龄是物理学家常常担心的问题。物理学家总是说，伟大的成就要么在你年轻时得到，要么就永远得不到。爱因斯坦在他非常年轻的时候取得了成就，所有的量子力学研究员也都在他们非常年轻的时候完成了我们认为最好的工作。大多数数学家，理论物理学家，天体物理学家也是这样，这并不是说他们在晚年没有做好工作，而是大家觉得最有价值的往往是他们年轻时的工作。但另一方面，音乐，政治，文学方面的人，我们认为他们最好的作品却往往在他们晚年时产出。总之年龄确实会有一些影响。</p>
<blockquote>
<p>But let me say why age seems to have the effect it does. In the first place if you do some good work you will find yourself on all kinds of committees and unable to do any more work.<br>
The third one, Brattain, practically with tears in his eyes, said, I know about this Nobel-Prize effect and I am not going to let it affect me; I am going to remain good old Walter Brattain.‘’ Well I said to myself, That is nice.‘’ But in a few weeks I saw it was affecting him. Now he could only work on great problems.<br>
When you are famous it is hard to work on small problems. This is what did Shannon in. After information theory, what do you do for an encore? The great scientists often make this error. They fail to continue to plant the little acorns from which the mighty oak trees grow. They try to get the big thing right off. And that isn’t the way things go. So that is another reason why you find that when you get early recognition it seems to sterilize you.</p>
</blockquote>
<p>但我要解释下为何在科学领域，看起来伟大工作都发生在年轻时。这是因为，一旦你做了一些好的工作，你就会发现自己身处各种委员会中，你也就不再能做任何伟大工作了。</p>
<p>Brattain 在诺贝尔奖项宣布的那天，说他不会让诺贝尔奖影响它，但几周后，我看到了诺贝尔奖给他带来的影响，现在他只能解决 <strong>大</strong> 问题了。</p>
<p>当你有名后，你很难解决 <strong>小</strong> 的问题。伟大的科学家经常犯这样的错误，他们不再种植可能会长成<strong>大橡树</strong>的 <strong>小橡子</strong>，，他们试图直接获取<strong>大橡树</strong>，但事情的发展并不是这样的。这也是为什么你会发现，当你获得了早期认可，你就被“绝育”了。</p>
<h2 id="关于工作条件"><a class="header-anchor" href="#关于工作条件">#</a>关于工作条件</h2>
<blockquote>
<p>I think that if you look carefully you will see that often the great scientists, by turning the problem around a bit, changed a defect to an asset. For example, many scientists when they found they couldn’t do a problem finally began to study why not. They then turned it around the other way and said, ``But of course, this is what it is’’ and got an important result. So ideal working conditions are very strange. The ones you want aren’t always the best ones for you.</p>
</blockquote>
<p>如果你仔细观察，你会发现伟大的科学家经常会将缺陷变为资产。比如，许多科学奖当发现他们无法解决一个问题时，他们会开始思考 <em>为什么</em>，并最终以此得到了一个重要的解决方式。所以理想的工作条件很奇怪。你想要的并不总是最适合你的。</p>
<h2 id="关于驱动力"><a class="header-anchor" href="#关于驱动力">#</a>关于驱动力</h2>
<blockquote>
<p>You observe that most great scientists have tremendous drive. I worked for ten years with John Tukey at Bell Labs. He had tremendous drive. One day about three or four years after I joined, I discovered that John Tukey was slightly younger than I was. John was a genius and I clearly was not. Well I went storming into Bode’s office and said, How can anybody my age know as much as John Tukey does?‘’ He leaned back in his chair, put his hands behind his head, grinned slightly, and said, You would be surprised Hamming, how much you would know if you worked as hard as he did that many years.‘’ I simply slunk out of the office!</p>
</blockquote>
<p>大多数伟大的科学家都有巨大的动力。我在贝尔实验室与 John Tukey 一起工作了十年，在我加入贝尔的大约三四年后的一天，我发现约翰·图基甚至比我还年轻一点。约翰是个天才，而我显然不是。有一天我冲进 Bode 的办公室说，“像我这个年纪的人，怎样才能像 John Tukey 一样知道那么多呢？” Bode 靠在椅子上，双手放在脑后，微微一笑，说：“Hamming，如果你像他一样努力工作并坚持多年的话，你就会对你自己的知识积累而感到惊讶。”</p>
<blockquote>
<p>What Bode was saying was this: ``Knowledge and productivity are like compound interest.‘’ Given two people of approximately the same ability and one person who works ten percent more than the other, the latter will more than twice outproduce the former. The more you know, the more you learn; the more you learn, the more you can do; the more you can do, the more the opportunity - it is very much like compound interest. I don’t want to give you a rate, but it is a very high rate. Given two people with exactly the same ability, the one person who manages day in and day out to get in one more hour of thinking will be tremendously more productive over a lifetime. I took Bode’s remark to heart; I spent a good deal more of my time for some years trying to work a bit harder and I found, in fact, I could get more work done. I don’t like to say it in front of my wife, but I did sort of neglect her sometimes; I needed to study. You have to neglect things if you intend to get what you want done. There’s no question about this.</p>
</blockquote>
<p>Bode 说的是：“知识和生产力就像复利。假设两个能力大致相同的人，一个人比另一个人多工作 10%，后者的产量将超过前者的两倍以上。”</p>
<p>你知道的越多，你学到的就越多，你学得越多，你能做的就越多，你能做的越多，机会就越多——这很像复利。</p>
<p>我把 Bode 的话记在心里：几年来，我花了很多时间试图更加努力地工作，事实上，我发现我可以完成更多的工作。我不喜欢在我妻子面前说出来，但有时我确实有点忽视她。我需要学习。如果你打算完成你想要做的事情，你必须忽略一些东西，这没有办法。</p>
<blockquote>
<p>drive, misapplied, doesn’t get you anywhere. I’ve often wondered why so many of my good friends at Bell Labs who worked as hard or harder than I did, didn’t have so much to show for it. The misapplication of effort is a very serious matter. Just hard work is not enough - it must be applied sensibly.</p>
</blockquote>
<p>但误用的驱动力，不会带你走向任何的成功。我经常想，为什么我在贝尔实验室的那么多好朋友，他们和我一样努力或比我更加的努力工作，却没有那么多东西可以展示。滥用努力是一个非常严重的问题。仅仅努力工作是不够的，你必须在正确的方向上努力。</p>
<h2 id="关于接受模棱两可"><a class="header-anchor" href="#关于接受模棱两可">#</a>关于接受模棱两可</h2>
<blockquote>
<p>There’s another trait on the side which I want to talk about; that trait is ambiguity. It took me a while to discover its importance.。 Most people like to believe something is or is not true. Great scientists tolerate ambiguity very well. They believe the theory enough to go ahead; they doubt it enough to notice the errors and faults so they can step forward and create the new replacement theory. If you believe too much you’ll never notice the flaws; if you doubt too much you won’t get started. It requires a lovely balance. But most great scientists are well aware of why their theories are true and they are also well aware of some slight misfits which don’t quite fit and they don’t forget it.</p>
</blockquote>
<p>另一个我花了很长时间才意识到的重要特质是接受模棱两可。大多数人喜欢相信一件事是真的或是假的，但伟大的科学家能忍受模棱两可。一方面他们足够的相信一个理论，这样他们才能继续研究这个理论。另一方面他们又对这个理论存在足够的怀疑，以至于他们能注意到理论的错误，并发展出新的替代性理论。如果你太相信，那么你永远不会注意到缺陷，但如果你怀疑的太多，你就不会出发。相信和怀疑之间需要一个可爱的平衡。</p>
<p>大多数伟大的科学家都很清楚为什么他们的理论是正确的，同时他们也很清楚理论中存在的一些无法说通的点，科学家们也不会忘记这些点。</p>
<blockquote>
<p>Darwin writes in his autobiography that he found it necessary to write down every piece of evidence which appeared to contradict his beliefs because otherwise they would disappear from his mind. When you find apparent flaws you’ve got to be sensitive and keep track of those things, and keep an eye out for how they can be explained or how the theory can be changed to fit them.</p>
</blockquote>
<p>达尔文在他的自传中写道，他发现有必要写下每一个看起来与他的理论不相符合的证据，否则它们就会从他的脑海中消失。当你发现明显的缺陷时，你必须保持敏感并跟踪这些事情，并思考如何解释它们或如何改变理论以适应它们，这些往往会造就伟大的贡献。</p>
<h2 id="关于潜意识"><a class="header-anchor" href="#关于潜意识">#</a>关于潜意识</h2>
<blockquote>
<p>Everybody who has studied creativity is driven finally to saying, ``creativity comes out of your subconscious.‘’ Somehow, suddenly, there it is. It just appears. Well, we know very little about the subconscious; but one thing you are pretty well aware of is that your dreams also come out of your subconscious. And you’re aware your dreams are, to a fair extent, a reworking of the experiences of the day. If you are deeply immersed and committed to a topic, day after day after day, your subconscious has nothing to do but work on your problem.</p>
</blockquote>
<p>每一个研究过创造力的人最终都会说，“创造力来自你的潜意识。不知何故，突然间，它就在那里。它只是出现”。虽然我对潜意识研究甚少，但我知道宛如日有所思夜有所梦一般，如果你日复一日地深深地沉浸在一个话题上，你的潜意识除了解决你的问题之外别无他法。因此，当你遇到一个真正重要的问题时，你不要让其他任何事情成为你关注的焦点——你专注在这个问题上，让你的潜意识保持饥饿，这样它就必须解决你的问题。这样的话，你就可以安然入睡，并在某一个早上免费得到答案。</p>
<h2 id="关于目标"><a class="header-anchor" href="#关于目标">#</a>关于目标</h2>
<blockquote>
<p>If you do not work on an important problem, it’s unlikely you’ll do important work. It’s perfectly obvious. Great scientists have thought through, in a careful way, a number of important problems in their field, and they keep an eye on wondering how to attack them…The average scientist, so far as I can make out, spends almost all his time working on problems which he believes will not be important and he also doesn’t believe that they will lead to important problems.</p>
</blockquote>
<p>如果你不为一个重要的问题工作，你基本不可能做出伟大的成就，这是显而易见的。</p>
<p>我看到的普通科学家，几乎把所有的时间都花在了他们认为不重要的问题上，他也不相信这些问题会引领他们走向别的重要的问题。</p>
<blockquote>
<p>But the average scientist does routine safe work almost all the time and so he (or she) doesn’t produce much. It’s that simple. If you want to do great work, you clearly must work on important problems, and you should have an idea.</p>
</blockquote>
<p>普通的科学家，几乎一直在做例行的舒适区内的工作，所以他们不会有巨大的产出，就这么简单。如果你想要做伟大工作，你显然必须在重要的问题上工作，而且你应该有一个想法知道什么是重要的问题。</p>
<blockquote>
<p>Most great scientists know many important problems. They have something between 10 and 20 important problems for which they are looking for an attack. And when they see a new idea come up, one hears them say ``Well that bears on this problem.‘’ They drop all the other things and get after it.</p>
</blockquote>
<p>大多数科学家知道许多重要的问题，他们会关注着大约 10 到 20 个重要的问题。当他们有一个新想法或看到一个新契机，他们脑海中会出现一个声音“嗯，这个与问题 A 有关”。然后他们就会抛下其他一切，全力投入这个问题。</p>
<blockquote>
<p>The great scientists, when an opportunity opens up, get after it and they pursue it. They drop all other things. They get rid of other things and they get after an idea because they had already thought the thing through. Their minds are prepared; they see the opportunity and they go after it…One of the chief tricks is to live a long time!</p>
</blockquote>
<p>当机会出现时，伟大的科学家们会抓住它并追求它。他们会放弃了其他所有的东西。他们之所以能抛弃其他的一切，而专注于抓住这个机遇，是因为他们已经有过了深刻的思考。他们的思维已经准备好了，只要他们一看到了他们一直等待的机会，他们就会续追逐它。</p>
<p>另外等待机遇的一个窍门就是活得长。</p>
<h2 id="关于开放"><a class="header-anchor" href="#关于开放">#</a>关于开放</h2>
<blockquote>
<p>I notice that if you have the door to your office closed, you get more work done today and tomorrow, and you are more productive than most. But 10 years later somehow you don’t know quite know what problems are worth working on; all the hard work you do is sort of tangential in importance. He who works with the door open gets all kinds of interruptions, but he also occasionally gets clues as to what the world is and what might be important.</p>
</blockquote>
<p>如果你工作时把门关上，你在今天和明天可以更好的完成工作，且你会比大多数人更高效。但 10 年后你或许并不知道什么问题才是真正需要被解决的，所有你认真完成的工作可能与重要性并不相关。</p>
<p>把门打开工作的人，或许会收到各种干扰，但他也会时不时的得到“当前世界什么事情最重要”的线索。</p>
<h2 id="关于抽象工作"><a class="header-anchor" href="#关于抽象工作">#</a>关于抽象工作</h2>
<blockquote>
<p>In the same way, when using the machine up in the attic in the early days, I was solving one problem after another after another; a fair number were successful and there were a few failures. I went home one Friday after finishing a problem, and curiously enough I wasn’t happy; I was depressed. I could see life being a long sequence of one problem after another after another. After quite a while of thinking I decided, ``No, I should be in the mass production of a variable product. I should be concerned with <em>all</em> of next year’s problems, not just the one in front of my face.‘’</p>
</blockquote>
<p>早年间我攻克一个又一个难题，成功的多，失败的少。在一个周五，当我解决完一个问题回家时，我并没有感到快乐，相反我感到沮丧。我感觉的人生就是一个问题接着一个问题，再接着一个问题。在一段时间的思考后，我决定“我应该关心明年所有的问题，而不仅仅是我面前的问题。”</p>
<blockquote>
<p>You should do your job in such a fashion that others can build on top of it, so they will indeed say, ``Yes, I’ve stood on so and so’s shoulders and I saw further.‘’ The essence of science is cumulative. By changing a problem slightly you can often do great work rather than merely good work. Instead of attacking isolated problems, I made the resolution that I would never again solve an isolated problem except as characteristic of a class.</p>
</blockquote>
<p>你应该以“别人可以在我工作的基础上建立其他工作”的方式做的你的工作。科学的本质是积累，所以我下定决心不再解决孤立的问题。</p>
<blockquote>
<p>Now if you are much of a mathematician you know that the effort to generalize often means that the solution is simple. Often by stopping and saying, ``This is the problem he wants but this is characteristic of so and so. Yes, I can attack the whole class with a far superior method than the particular one because I was earlier embedded in needless detail.‘’ The business of abstraction frequently makes things simple. Furthermore, I filed away the methods and prepared for the future problems.</p>
</blockquote>
<p>如果你是一个数学家，你就知道泛化的解决方案往往意味着解决方案是简单的。在数学的工作中，你可能常常会停下工作并意识到“这就是要解决的问题，但这有个特殊点 blablabla。我其实可以以一种更简单的方式完整的解决这类型的所有问题，但因为我过早的陷入了不必要的细节，所以我只做出了一个解决特定问题的复杂答案。”抽象的过程常常让事物变得简单，此外，抽象意味着将方法进行了归档，并为之后的问题做准备。</p>
<blockquote>
<p>you can make a great deal of difference in your final productivity because you can either do it in such a fashion that people can indeed build on what you’ve done, or you can do it in such a fashion that the next person has to essentially duplicate again what you’ve done. It isn’t just a matter of the job, it’s the way you write the report, the way you write the paper, the whole attitude. It’s just as easy to do a broad, general job as one very special case. And it’s much more satisfying and rewarding!</p>
</blockquote>
<p>你选择以“别人可以在我的基础上再接再厉”的方式去工作，也可以以“别人基本上需要再次复制我所做的”的方式去工作，这两者会产生巨大的生产力差异。这不仅仅是你工作的方式，也包含你写报告的方式，写论文的方式。做一个广泛的，通用的解决方案通常比做一个特化问题的解决方案更简单，也通常更令人满意和有帮助。</p>
<h2 id="关于推销自己"><a class="header-anchor" href="#关于推销自己">#</a>关于推销自己</h2>
<blockquote>
<p>it is not sufficient to do a job, you have to sell it. Selling to a scientist is an awkward thing to do. It’s very ugly; you shouldn’t have to do it. The world is supposed to be waiting, and when you do something great, they should rush out and welcome it. But the fact is everyone is busy with their own work. You must present it so well that they will set aside what they are doing, look at what you’ve done, read it, and come back and say, ``Yes, that was good.‘’</p>
</blockquote>
<p>只完成工作是不够的，你还需要推销它。“推销” 对科学家而言是一个尴尬的事，它很烦，你不应该需要做它。当你做出了一些伟大的事情事，这个世界应该立刻欢迎它。但事实上，每个人都因为自己的工作而忙碌，所以只有你推销了你的工作，其他人才会将他们的工作放在一边，并看看你做了什么，然后说“嗯，不错”。</p>
<blockquote>
<p>There are three things you have to do in selling. You have to learn to write clearly and well so that people will read it, you must learn to give reasonably formal talks, and you also must learn to give informal talks. We had a lot of so-called <em>back room scientists.</em> In a conference, they would keep quiet. Three weeks later after a decision was made they filed a report saying why you should do so and so. Well, it was too late. They would not stand up right in the middle of a hot conference, in the middle of activity, and say, We should do this for these reasons. You need to master that form of communication as well as prepared speeches.</p>
</blockquote>
<p>在推销自己时，必须要做好三件事：</p>
<ul>
<li>学会清晰的写作，这样人们才会愿意阅读</li>
<li>学会正式的演讲</li>
<li>学会非正式环境的谈话</li>
</ul>
<p>我们有很多所谓的“幕后科学家”。在会议上，他们会保持沉默。当会议结束的三周后，他们会提交一份报告，说明为什么要这样做。但这样就太晚了，没人会关注到他们。他们不会在激烈的会议中间站起来说 “出于这些原因，我们应该 blablabla”。你必须要需要掌握这种沟通形式以及准备好随时演讲。</p>
<blockquote>
<p>The technical person wants to give a highly limited technical talk. Most of the time the audience wants a broad general talk and wants much more survey and background than the speaker is willing to give. As a result, many talks are ineffective. The speaker names a topic and suddenly plunges into the details he’s solved. Few people in the audience may follow. You should paint a general picture to say why it’s important, and then slowly give a sketch of what was done. Then a larger number of people will say, Yes, Joe has done that,‘’ or Mary has done that; I really see where it is; yes, Mary really gave a good talk; I understand what Mary has done.‘’</p>
</blockquote>
<p>技术人员通常想要做一个非常聚焦，专精的技术演讲，而大多数时候，听众则想要一个广泛的一般性演讲，并且想要更多的调查数据和问题背景。所以，大多数的技术演讲是无效的，演讲者说出一个话题，然后突然进入了细节，听众很难跟上演讲者的思路。你应该给出一个大框架，说明为什么这个问题很重要，然后慢慢勾勒出所作的内容。这样大部分的听众会给出 “是的，Joy 做了一个重要的事”，“Mary 做了一个很好的演讲，我能明白 Mary 做了什么” 这样的评价。</p>
<h2 id="关于聚焦方向"><a class="header-anchor" href="#关于聚焦方向">#</a>关于聚焦方向</h2>
<blockquote>
<p>I committed 10% of my time trying to understand the bigger problems in the field, i.e. what was and what was not important. I found in the early days I had believed *this’*and yet had spent all week marching in <em>that</em> direction. It was kind of foolish. If I really believe the action is over there, why do I march in this direction? I either had to change my goal or change what I did. So I changed something I did and I marched in the direction I thought was important. It’s that easy.</p>
</blockquote>
<p>我把 10% 的时间用来理解领域中更 <strong>大</strong> 的问题，也就是什么是重要的，什么不重要。我发现在早期，我相信了 A 是重要的，但我却花了一周的时间在 B 问题上。这有点蠢。如果我真的相信我应该在 A 方向行动，为什么我还要朝着 B 方向前进？我要么改变我的目标，要么改变我所做的事情。所以我改变了我所做的事情，我朝着我认为重要的方向前进。就这么简单。</p>
<blockquote>
<p>Now you might tell me you haven’t got control over what you have to work on. Well, when you first begin, you may not. But once you’re moderately successful, there are more people asking for results than you can deliver and you have some power of choice, but not completely.</p>
</blockquote>
<p>你可能会告诉我，你没有权力控制你所要做的事情。好吧，当你刚开始工作时，你可能确实没有。但一旦你有了一定的成功，就会有更多的人需要你的结果，而你却无法满足所有人的需求，这时你就有了一些选择的权力，但不是完全的。</p>
<blockquote>
<p>I am telling you how you can get what you want in spite of top management. You have to sell your ideas there also.</p>
</blockquote>
<p>你可以在不受高层管理的影响下，得到你想要的东西，但你必须在管理层推销你的想法。</p>
<h2 id="关于动力"><a class="header-anchor" href="#关于动力">#</a>关于动力</h2>
<blockquote>
<p><em>Is the effort to be a great scientist worth it?‘’</em> To answer this, you must ask people. When you get beyond their modesty, most people will say, Yes, doing really first-class work, and knowing it, is as good as wine, women and song put together,‘’ or if it’s a woman she says, It is as good as wine, men and song put together.‘’ And if you look at the bosses, they tend to come back or ask for reports, trying to participate in those moments of discovery. They’re always in the way. So evidently those who have done it, want to do it again. But it is a limited survey. I have never dared to go out and ask those who didn’t do great work how they felt about the matter. It’s a biased sample, but I still think it is worth the struggle. I think it is very definitely worth the struggle to try and do first-class work because the truth is, the value is in the struggle more than it is in the result. The struggle to make something of yourself seems to be worthwhile in itself. The success and fame are sort of dividends, in my opinion.</p>
</blockquote>
<p>“成为一位伟大的科学家的努力是否值得？”为了回答这个问题，你需要去询问人们。当你让他们抛下顾虑时，大多数人会说，“是的，做真正一流的工作，并理解它，就像把美酒、女人和歌曲结合在一起那样好。” 或者如果你问的是一个女人，她会说：“这就像把美酒、男人和歌曲结合在一起一样美好。” 当你观察那些老板时，他们似乎总是会来参与进一流的工作或要求给出一流工作的报告，他们总是试图参与那些重要的发现时刻，虽然这一定程度上会会妨碍我们的工作。所以显然，那些曾经做过一流工作的人，都会想再次去做一流的工作。但这是一个有限的调查。我从未敢问那些没有做出伟大工作的人他们对此事的感受。虽然这是一个有偏差的样本，但我仍然认为努力去做一流的工作绝对是值得的，因为事实上，价值更多地在于挣扎本身，而不是结果。努力让自己变得更好似乎本身就是有价值的。在我看来，成功和名声只是一种额外收益。</p>
<blockquote>
<p>one of the reasons is drive and commitment. The people who do great work with less ability but who are committed to it, get more done that those who have great skill and dabble in it, who work during the day and go home and do other things and come back and work the next day. They don’t have the deep commitment that is apparently necessary for really first-class work. They turn out lots of good work, but we were talking, remember, about first-class work. There is a difference. Good people, very talented people, almost always turn out good work. We’re talking about the outstanding work, the type of work that gets the Nobel Prize and gets recognition.</p>
</blockquote>
<p>那些能力较弱但致力于实现伟大成就的人，比那些有着非凡技能、却只是粗略的使用技能的人完成更多工作。那些有着非凡技能的人白天工作，晚上回家做其他事情，然后第二天回来继续工作，他们没有显现出真正做一流工作所必需的深入投入。他们的成果很多，但请记住，我们谈论的是一流的工作。这两者之间存在差异。表现出色的人，非常有才华的人几乎总是能完成好的工作。但我们讨论的是杰出的工作，那种能获得诺贝尔奖并得到认可的工作。</p>
<h2 id="关于穿着"><a class="header-anchor" href="#关于穿着">#</a>关于穿着</h2>
<blockquote>
<p>I came from Los Alamos and in the early days I was using a machine in New York at 590 Madison Avenue where we merely rented time. I was still dressing in western clothes, big slash pockets, a bolo and all those things. I vaguely noticed that I was not getting as good service as other people. So I set out to measure. You came in and you waited for your turn; I felt I was not getting a fair deal. I said to myself, ``Why? No Vice President at IBM said, <em>Give Hamming a bad time</em> It is the secretaries at the bottom who are doing this. When a slot appears, they’ll rush to find someone to slip in, but they go out and find somebody else. Now, why? I haven’t mistreated them.‘’ Answer, I wasn’t dressing the way they felt somebody in that situation should. It came down to just that - I wasn’t dressing properly. I had to make the decision - was I going to assert my ego and dress the way I wanted to and have it steadily drain my effort from my professional life, or was I going to appear to conform better? I decided I would make an effort to appear to conform properly. The moment I did, I got much better service. And now, as an old colorful character, I get better service than other people.</p>
</blockquote>
<p>我来自 Los Alamos，早期我在纽约的 590 麦迪逊大街使用一台机器，那时我们只能租用设备一段时间使用。那时我仍然穿着西部服装，大口袋，蝴蝶结等。我隐约注意到我得到服务并不如其他人。所以我开始衡量，当排队等待轮到我的时候，我觉得我没有得到公平的待遇。我问自己，为什么？IBM 的副总裁肯定没有说过要给 Hamming 难堪之类的话。当有机器有一个空闲时段出现时，工作人员会急忙去找某人去使用，但他们总会选择其他人。为什么？我并没有虐待那些工作人员。最后我发现答案是，我没有穿工作人员认为的那个场合应该穿的衣服。归根结底就是这个原因——我穿着不得体。</p>
<p>因此我必须做一个决定——我是要坚持我自己的风格，让它不断地削弱我在专业上的付出，还是我要表现得更为顺从？我决定竭力表现得更为合宜。当我这么做时，我得到了更好的服务。现在，作为一个有趣的老人，我得到的服务比其他人更好。</p>
<blockquote>
<p>You should dress according to the expectations of the audience spoken to. If I am going to give an address at the MIT computer center, I dress with a bolo and an old corduroy jacket or something else. I know enough not to let my clothes, my appearance, my manners get in the way of what I care about. An enormous number of scientists feel they must assert their ego and do their thing their way. They have got to be able to do this, that, or the other thing, and they pay a steady price.</p>
</blockquote>
<p>你应该根据你面对的观众的期望来着装。如果我要在麻省理工学院计算机中心发表演讲，我会穿一条蝴蝶领带和一件旧灯芯绒夹克之类的衣服。我知道不能让我的衣着、外表和礼仪妨碍我关心的事情。有许多科学家认为他们必须坚持自己的风格，用自己的方式做事。但他们必须改变自己来符合观众的期望，否则，他们会持续付出代价。</p>
<blockquote>
<p>John Tukey almost always dressed very casually. He would go into an important office and it would take a long time before the other fellow realized that this is a first-class man and he had better listen. For a long time John has had to overcome this kind of hostility. It’s wasted effort! I didn’t say you should conform; I said The <em>appearance of conforming</em> gets you a long way.‘’ If you chose to assert your ego in any number of ways, I am going to do it my way,‘’ you pay a small steady price throughout the whole of your professional career. And this, over a whole lifetime, adds up to an enormous amount of needless trouble.</p>
</blockquote>
<p>John Tukey 几乎总是穿着非常休闲的衣服。当他会走进一个重要的办公室，过很长时间，对方才会意识到这是一个一流的人，他最好要认真倾听。很长一段时间以来，John 一直不得不克服这种敌意。这是浪费力气！我并没有说你应该完全顺从，我说的是“看起来顺从会带给你很大的便利。”如果你选择以许多不同的方式来坚持你的自我，“我要用我的方式去做”，那么在整个职业生涯中，你会持续付出一些小的代价。而这在一生中累计起来，会导致大量不必要的麻烦。</p>
<blockquote>
<p>And I think John Tukey paid a terrible price needlessly. He was a genius anyhow, but I think it would have been far better, and far simpler, had he been willing to conform a little bit instead of ego asserting. He is going to dress the way he wants all of the time. It applies not only to dress but to a thousand other things; people will continue to fight the system. Not that you shouldn’t occasionally!</p>
</blockquote>
<p>我认为 John Tukey 付出了可怕的，且不必要的代价。无论如何，他是个天才，但我认为，如果他愿意更对这个社会顺从一点而不是一味的自我主张，事情会好得多，也简单得多。他一直按照他想要的方式穿着，而且不仅仅是在着装领域，在其他上千件事情上 John 也这样。人们如果持续的与社会的要求做斗争，会付出不少的代价。当然了，在一些时刻，坚持自己也是应该的。</p>
<h2 id="关于制度"><a class="header-anchor" href="#关于制度">#</a>关于制度</h2>
<blockquote>
<p>Many a second-rate fellow gets caught up in some little twitting of the system, and carries it through to warfare. He expends his energy in a foolish project. Now you are going to tell me that somebody has to change the system. I agree; somebody’s has to. Which do you want to be? The person who changes the system or the person who does first-class science? Which person is it that you want to be? Be clear, when you fight the system and struggle with it, what you are doing, how far to go out of amusement, and how much to waste your effort fighting the system. My advice is to let somebody else do it and you get on with becoming a first-class scientist. Very few of you have the ability to both reform the system <em>and</em> become a first-class scientist.</p>
</blockquote>
<p>许多二流的人都会陷入对制度系统的一些缺陷的关注，并大张旗鼓的要改变它，于是他把精力消耗在了一个愚蠢的项目上。或许你会说 “必须有人改变系统”。我同意，有人必须这样做，但你想成为哪种人？一个改变制度的人还是做出一流科学成就的人？你必须清楚地知道，当你与系统作斗争并与之斗争时，你究竟在做什么，你是不是在趁机休息或娱乐，你在与系统作斗争时浪费了多少精力。我的建议是让别人去做，然后你就可以成为一流的科学家。很少有人有能力既改革体制又成为一流的科学家。</p>
<blockquote>
<p>On the other hand, we can’t always give in. There are times when a certain amount of rebellion is sensible. I have observed almost all scientists enjoy a certain amount of twitting the system for the sheer love of it. What it comes down to basically is that you cannot be original in one area without having originality in others. Originality is being different. You can’t be an original scientist without having some other original characteristics. But many a scientist has let his quirks in other places make him pay a far higher price than is necessary for the ego satisfaction he or she gets. I’m not against all ego assertion; I’m against some.</p>
</blockquote>
<p>另一方面，我们不能总是屈服于制度。有时，一定程度的反抗是明智的。我观察到，几乎所有科学家都出于对制度系统的纯粹热爱而喜欢对系统进行一定程度的改进。归根结底是，如果你在某个领域没有原创性，那么在其他领域就不可能有原创性。原创就是与众不同。如果你无法在一个制度系统中发现待改进的点，你很难成为一名原创性的科学家。但许多科学家的一些自我主张，让他在获取自我满足外，付出了过高的代价，他们过度的关注了制度是否满足他们的需求。我并不反对所有的自我主张，我反对一些代价高昂的自我主张。</p>
<blockquote>
<p>Another fault is anger. Often a scientist becomes angry, and this is no way to handle things. Amusement, yes, anger, no. Anger is misdirected. You should follow and cooperate rather than struggle against the system all the time.</p>
</blockquote>
<p>另一个错误是愤怒。科学家常常会生气，但错误会让你没有办法处理事务。幽默是好的，但愤怒不是。愤怒是误导性的，你应该跟随和配合制度，而不是一直与制度作斗争。</p>
<h2 id="关于自我认知"><a class="header-anchor" href="#关于自我认知">#</a>关于自我认知</h2>
<blockquote>
<p>I am an egotistical person; there is no doubt about it. I knew that most people who took a sabbatical to write a book, didn’t finish it on time. So before I left, I told all my friends that when I come back, that book was going to be done! Yes, I would have it done - I’d have been ashamed to come back without it! I used my ego to make myself behave the way I wanted to. I bragged about something so I’d have to perform. I found out many times, like a cornered rat in a real trap, I was surprisingly capable.</p>
</blockquote>
<p>我无疑是一个自负的人。我知道大多数人会决定在休假的时候写一本书，但常常完不成。所以我会在去休假前，告知我所有的朋友“当我休假结束，这本书就基本写完了”。这样我就能完成这本书，因为我一想到我回来时这书没写完，我就会觉得在朋友面前会太丢脸。我利用了我的自尊来完成我想要做的事，我会向别人吹嘘一些我必须要做的事。很多时候，这会让我像一个落入陷阱的老鼠一样，表现出令人吃惊的能力.</p>
<blockquote>
<p>Now self-delusion in humans is very, very common. There are enumerable ways of you changing a thing and kidding yourself and making it look some other way. When you ask, Why didn’t you do such and such,‘’ the person has a thousand alibis. If you look at the history of science, usually these days there are 10 people right there ready, and we pay off for the person who is there first. The other nine fellows say, Well, I had the idea but I didn’t do it and so on and so on.‘’ There are so many alibis. Why weren’t you first? Why didn’t you do it right? Don’t try an alibi. Don’t try and kid yourself. You can tell other people all the alibis you want. I don’t mind. But to yourself try to be honest.</p>
</blockquote>
<p>自我欺骗非常，非常的普遍。有许多的方式，你可以改变一件事然后欺骗自己，让它看起来有不一样的表现。当被问起 “你为什么不 blablabla” 时，人们有一千个理由。当你回顾科学发展的历史，你会发现在一个时间点，可能有 10 个科学家都已经有了做出伟大成就的准备，但只有一个人会首先迈出最终一步，然后剩下的九个人会说“我也有了这个想法，但我没去做他，因为 blablabla。” 人能给自己找的借口太多了，但为何你不是第一个人？为什么你没法把事情做对？不要尝试找借口，不要尝试欺骗自己，你可以告诉别人所有你想要的接口。这无所谓，但你不要骗自己就好。</p>
<h1 id="Discussion"><a class="header-anchor" href="#Discussion">#</a>Discussion</h1>
<h2 id="关于勇气-2"><a class="header-anchor" href="#关于勇气-2">#</a>关于勇气</h2>
<blockquote>
<p><em>Question:</em> The remarks about having courage, no one could argue with; but those of us who have gray hairs or who are well established don’t have to worry too much. But what I sense among the young people these days is a real concern over the risk taking in a highly competitive environment. Do you have any words of wisdom on this?</p>
</blockquote>
<blockquote>
<p><em>Hamming:</em> I’ll quote Ed David more. Ed David was concerned about the general loss of nerve in our society. It does seem to me that we’ve gone through various periods. Coming out of the war, coming out of Los Alamos where we built the bomb, coming out of building the radars and so on, there came into the mathematics department, and the research area, a group of people with a lot of guts. They’ve just seen things done; they’ve just won a war which was fantastic. We had reasons for having courage and therefore we did a great deal. I can’t arrange that situation to do it again. I cannot blame the present generation for not having it, but I agree with what you say; I just cannot attach blame to it. It doesn’t seem to me they have the desire for greatness; they lack the courage to do it. But we had, because we were in a favorable circumstance to have it; we just came through a tremendously successful war. In the war we were looking very, very bad for a long while; it was a very desperate struggle as you well know. And our success, I think, gave us courage and self confidence; that’s why you see, beginning in the late forties through the fifties, a tremendous productivity at the labs which was stimulated from the earlier times. Because many of us were earlier forced to learn other things - we were forced to learn the things we didn’t want to learn, we were forced to have an open door - and then we could exploit those things we learned. It is true, and I can’t do anything about it; I cannot blame the present generation either. It’s just a fact.</p>
</blockquote>
<p>问题：你关于勇气的部分的阐述毋庸置疑。但对于我们这些老人或者说一些已经成家立业的人而言，我们有了后盾，所以我们能鼓起勇气。但对于现在的年轻人，他们处在一个高度的竞争环境下，他们需要承担过高的风险以至于很难鼓起勇气。对于这个情况，你有什么建议或看法？</p>
<p>Hamming：在我看来，我们和现在的年轻人确实经历了不同的时期。我们是从战争时期中走出来的，我们在 Los Alamos 制造了炸弹，我们创造了雷达，在数学系和其他科学领域，有许多充满勇气的人。他们刚刚完成了所有的事，他们刚刚赢得了一场非常伟大的战争。因为战争，我们有必要有勇气，因此我们做了很多事情。但在这个时刻，我无法重新创造出战争那样的范围，我也不能责怪当代人没有这样的氛围，所以同意你的说法。在我看来，现在的年轻人并没有追求伟大的愿望，他们缺乏这样做的勇气。但我们有，是因为我们处于有利的环境中，我们刚刚经历了一场非常成功的战争。在战争中，我们有很长一段时间看起来非常非常糟糕。正如你所知，这是一场非常绝望的斗争。我认为，战争中的成功给了我们勇气和自信；这就是为什么你会看到，从四十年代末到五十年代，实验室在早期的刺激下取得了巨大的成果。因为我们中的许多人早些时候被迫学习其他东西 - 我们被迫学习我们不想学习的东西，我们被迫打开一扇门 - 然后我们可以利用我们学到的那些东西。这是事实，但我对此无能为力；我也不能责怪当代人。这只是事实。</p>
<h2 id="关于头脑风暴"><a class="header-anchor" href="#关于头脑风暴">#</a>关于头脑风暴</h2>
<blockquote>
<p><em>Question:</em> Is brainstorming a daily process?</p>
</blockquote>
<blockquote>
<p><em>Hamming:</em> Once that was a very popular thing, but it seems not to have paid off. For myself I find it desirable to talk to other people; but a session of brainstorming is seldom worthwhile. I do go in to strictly talk to somebody and say, Look, I think there has to be something here. Here’s what I think I see …‘’ and then begin talking back and forth. But you want to pick capable people. To use another analogy, you know the idea called the <em>critical mass.</em> If you have enough stuff you have critical mass. There is also the idea I used to call <em>sound absorbers</em> .When you get too many sound absorbers, you give out an idea and they merely say, Yes, yes, yes.‘’ What you want to do is get that critical mass in action; Yes, that reminds me of so and so,‘’ or, Have you thought about that or this?‘’ When you talk to other people, you want to get rid of those sound absorbers who are nice people but merely say, ``Oh yes,‘’ and to find those who will stimulate you right back.</p>
</blockquote>
<p>问题：你是否觉得头脑风暴应该成为一个日常过程？</p>
<p>Hamming: 头脑风暴曾经是一个非常流行的活动，但它似乎没有产生太多的收益。对我自己而言，我觉得与某些人交谈是值得的，但一个头脑风暴活动却很少会产生结果。我会找到特定的人，然后说 “我发现…我觉得…”，然后开始与他讨论。有一个概念叫 “临界质量”，当你有足够的知识后，你就有了与别人交流的 “临界质量” 了，这时候交流才是有价值的。我有个自己定义的概念叫 “吸音器”。当你交流的对象，大多是 “吸音器” 时，你能得到的回答就都是 “是的，是的，是的，嗯，嗯，嗯”。你要做的，就是保证参与的对象，都到了 “临界质量”，然后就能得到 “是的，这让我想起了 xxx”，“你有没有考虑过 xxxx”。当你决定和别人交谈时，你要摆脱那些只会说 “哦，好的” 的人，然后找到那些能刺激你的人。</p>
<blockquote>
<p>I picked my people carefully with whom I did or whom I didn’t brainstorm because the sound absorbers are a curse. They are just nice guys; they fill the whole space and they contribute nothing except they absorb ideas and the new ideas just die away instead of echoing on. Yes, I find it necessary to talk to people. I think people with closed doors fail to do this so they fail to get their ideas sharpened, such as ``Did you ever notice something over here?‘’ I never knew anything about it - I can go over and look. Somebody points the way. On my visit here, I have already found several books that I must read when I get home. I talk to people and ask questions when I think they can answer me and give me clues that I do not know about. I go out and look!</p>
</blockquote>
<p>我会精心挑选那些我共事的人，我也会精心挑选我 <strong>不</strong> 一起进行头脑风暴的人，因为 “吸音器” 是诅咒。 他们是好人，但他们会充满整个空间但不提供任何的东西，他们只会吸收所有的想法，所有新的想法会直接消亡而不是在大家脑海中回荡。是的，与人交流是有必要的，我认为那些关起门工作的人没有机会磨砺自己的想法，他们听不到类似于 “你有没有意识到 xxxx” 这样的回复。如果别人提出了我从未想到过的想法，我就会去关注和学习下这想法，一些人就曾给过我这样的想法。在我来这访问的时候，我已经听到了一些当我回家后必须要读的书。我会与那些我觉得会给出我未曾想过的思路线索的人交谈和向他们提问题。</p>
<h2 id="关于阅读_写作_做研究_的时间平衡"><a class="header-anchor" href="#关于阅读_写作_做研究_的时间平衡">#</a>关于阅读 / 写作 / 做研究 的时间平衡</h2>
<blockquote>
<p>What kind of tradeoffs did you make in allocating your time for reading and writing and actually doing research?</p>
</blockquote>
<blockquote>
<p><em>Hamming:</em> I believed, in my early days, that you should spend at least as much time in the polish and presentation as you did in the original research. Now at least 50% of the time must go for the presentation. It’s a big, big number.</p>
</blockquote>
<p>问题： 你觉得在读书，写作和做研究间，时间该如何分配。</p>
<p>Hamming：在我早期工作时，我认为你应该至少花费与研究一样多的时间去润色和演示你的成果。而对于现在的我而言，至少需要 50 % 的时间需要用来展示成果，这是一个很大的占比。</p>
<h2 id="关于阅读的方式"><a class="header-anchor" href="#关于阅读的方式">#</a>关于阅读的方式</h2>
<blockquote>
<p><em>Question:</em> How much effort should go into library work?</p>
</blockquote>
<blockquote>
<p><em>Hamming:</em> It depends upon the field. I will say this about it. There was a fellow at Bell Labs, a very, very, smart guy. He was always in the library; he read everything. If you wanted references, you went to him and he gave you all kinds of references. But in the middle of forming these theories, I formed a proposition: there would be no effect named after him in the long run. He is now retired from Bell Labs and is an Adjunct Professor. He was very valuable; I’m not questioning that. He wrote some very good Physical Review articles; but there’s no effect named after him because he read too much. If you read all the time what other people have done you will think the way they thought. If you want to think new thoughts that are different, then do what a lot of creative people do - get the problem reasonably clear and then refuse to look at any answers until you’ve thought the problem through carefully how you would do it, how you could slightly change the problem to be the correct one. So yes, you need to keep up. You need to keep up more to find out what the problems are than to read to find the solutions. The reading is necessary to know what is going on and what is possible. But reading to get the solutions does not seem to be the way to do great research. So I’ll give you two answers. You read; but it is not the amount, it is the way you read that counts.</p>
</blockquote>
<p>问题：我应该将多少事件花费在图书馆进行阅读？</p>
<p>Hamming：这个答案和你研究的领域相关。我知道在贝尔实验室有个人，他非常非常聪明。他几乎每天都在图书馆，他读了所有的书籍。如果你需要参考资料，你就去找他，他会给你所有的参考资料。但在一系列理论产生的时期，我觉得不会有任何的理论会以他的名字来命名。他现在已经退休了，成为了一名兼职教授。他非常有价值，我不是在质疑这一点。他写了一些非常好的物理评论文章，但没有一个理论或效应以他的名字命名，因为他读的太多了。如果你一直在阅读别人的成果，你会以他们的方式去思考。如果你想要有不同的思考，那么你需要做一些创造性的事情，你需要清楚的定义问题，然后拒绝看任何答案，直到你真的仔细的思考过这个问题：你会如何做，你会如何稍微改变看问题的角度来使问题变得可以解决正确。所以是的，你需要保持阅读，你需要保持阅读来发现问题而不是找到答案。阅读是必要的，你需要靠阅读知道这个世界发生了什么，什么是可能的。但是通过阅读来找到答案，似乎不是做出伟大研究的方式。所以我答案是，你需要阅读，但要关注的不是阅读的量，而是阅读的方式。</p>
<h2 id="关于研究方向"><a class="header-anchor" href="#关于研究方向">#</a>关于研究方向</h2>
<blockquote>
<p>Question: You mentioned the problem of the Nobel Prize and the subsequent notoriety of what was done to some of the careers. Isn’t that kind of a much more broad problem of fame? What can one do?</p>
</blockquote>
<blockquote>
<p>Hamming: Some things you could do are the following. Somewhere around every seven years make a significant, if not complete, shift in your field. Thus, I shifted from numerical analysis, to hardware, to software, and so on, periodically, because you tend to use up your ideas. When you go to a new field, you have to start over as a baby. You are no longer the big mukity muk and you can start back there and you can start planting those acorns which will become the giant oaks. Shannon, I believe, ruined himself. In fact when he left Bell Labs, I said, That’s the end of Shannon’s scientific career.‘’ I received a lot of flak from my friends who said that Shannon was just as smart as ever. I said, Yes, he’ll be just as smart, but that’s the end of his scientific career,‘’ and I truly believe it was.</p>
</blockquote>
<blockquote>
<p>You have to change. You get tired after a while; you use up your originality in one field. You need to get something nearby. I’m not saying that you shift from music to theoretical physics to English literature; I mean within your field you should shift areas so that you don’t go stale. You couldn’t get away with forcing a change every seven years, but if you could, I would require a condition for doing research, being that you will change your field of research every seven years with a reasonable definition of what it means, or at the end of 10 years, management has the right to compel you to change. I would insist on a change because I’m serious. What happens to the old fellows is that they get a technique going; they keep on using it. They were marching in that direction which was right then, but the world changes. There’s the new direction; but the old fellows are still marching in their former direction.</p>
</blockquote>
<blockquote>
<p>You need to get into a new field to get new viewpoints, and before you use up all the old ones. You can do something about this, but it takes effort and energy. It takes courage to say, Yes, I will give up my great reputation.‘’ For example, when error correcting codes were well launched, having these theories, I said, Hamming, you are going to quit reading papers in the field; you are going to ignore it completely; you are going to try and do something else other than coast on that.‘’ I deliberately refused to go on in that field. I wouldn’t even read papers to try to force myself to have a chance to do something else. I managed myself, which is what I’m preaching in this whole talk. Knowing many of my own faults, I manage myself. I have a lot of faults, so I’ve got a lot of problems, i.e. a lot of possibilities of management.</p>
</blockquote>
<p>问题：你提到了诺贝尔奖的问题，以及随后的名声对一些人事业的影响。这不是名声的一个更广泛的问题吗？一个人能做什么？</p>
<p>Hamming: 你可以做的一些事情是以下几点。大约每七年，在你的领域做一个重大的，如果不是完全的，转变。因此，我从数值分析转向硬件，再到软件，等等。你需要定期的转变，因为你会逐渐用完你的想法。当你进入一个新的领域时，你必须像一个婴儿一样重新开始。你不再是大人物，你可以从那里开始，你可以开始种植那些将成为巨大橡树的橡子。我相信香农毁了自己。事实上，当他离开贝尔实验室时，我说，“这是香农科学生涯的终结。”我的朋友们对此表示了很多的抱怨，他们说香农和以前一样聪明。我说，“是的，他还是一样聪明，但这是他科学生涯的终结”，我真的相信是这样的。</p>
<p>你必须改变。过了一段时间，你就会累了；你在一个领域里用完了你的独创性。你需要得到一些附近的东西。我不是说你应该从音乐转向理论物理学，再转向英国文学；我的意思是，在你的领域内，你应该转向其他领域，这样你就不会变得陈腐。你不需要强迫自己每七年改变一次，但如果你能，我会要求你在研究中改变你的领域，那些腐朽的人人们会发生什么事情呢？他们得到了一个技术，他们继续使用它，在当时那个时刻，这技术是在正确的方向上前进。但世界在变化，有了新的方向后，腐朽的人们仍然在他们以前的方向上前进。</p>
<p>你需要进入一个新的领域，以获得新的观点，而不是用完所有的旧观点。这需要努力和精力，你也需要勇气说，“是的，我会放弃我的伟大声誉。”例如，当纠错码被广泛应用时，我说，“Hamming，你要停止阅读这个领域的论文；你要完全忽略它；你要尝试做一些其他的事情，而不是在这个领域里继续。”我故意拒绝在这个领域继续前进。我甚至不会阅读论文，以便强迫自己有机会做其他的事情。我管理自己，这就是我在这次演讲中所宣扬的。了解我自己的许多缺点，然后管理自己。我有很多缺点，所以我有很多问题，也就有了很多管理的可能性。</p>
<h2 id="关于管理"><a class="header-anchor" href="#关于管理">#</a>关于管理</h2>
<blockquote>
<p>Question: Would you compare research and management?</p>
</blockquote>
<blockquote>
<p>Hamming: If you want to be a great researcher, you won’t make it being president of the company. If you want to be president of the company, that’s another thing. I’m not against being president of the company. I just don’t want to be. I think Ian Ross does a good job as President of Bell Labs. I’m not against it; but you have to be clear on what you want. Furthermore, when you’re young, you may have picked wanting to be a great scientist, but as you live longer, you may change your mind. For instance, I went to my boss, Bode, one day and said, Why did you ever become department head? Why didn’t you just be a good scientist?‘’ He said, Hamming, I had a vision of what mathematics should be in Bell Laboratories. And I saw if that vision was going to be realized, I had to make it happen; I had to be department head.‘’ When your vision of what you want to do is what you can do single-handedly, then you should pursue it. The day your vision, what you think needs to be done, is bigger than what you can do single-handedly, then you have to move toward management. And the bigger the vision is, the farther in management you have to go. If you have a vision of what the whole laboratory should be, or the whole Bell System, you have to get there to make it happen. You can’t make it happen from the bottom very easily. It depends upon what goals and what desires you have. And as they change in life, you have to be prepared to change. I chose to avoid management because I preferred to do what I could do single-handedly. But that’s the choice that I made, and it is biased. Each person is entitled to their choice. Keep an open mind. But when you do choose a path, for heaven’s sake be aware of what you have done and the choice you have made. Don’t try to do both sides.</p>
</blockquote>
<p>问题：你能比较一下研究和管理的关系吗？</p>
<p>Hamming：如果你想成为一个伟大的研究者，你不会成为公司的总裁。如果你的目标是成为公司的总裁，那就完全是另一回事。我不反对成为公司的总裁，只不过我自己不想成为。我认为 Ian Ross 在贝尔实验室是一个很好的 Boss。我并不是反对人们去做管理，去做总裁，但你必须清楚你想要什么。此外，当你年轻的时候，你可能选择成为一个伟大的科学家，但随着你的年龄增长，你可能会改变主意。例如，有一天我去找我的老板 Bode，我问他：“你为什么要成为部门主管？你为什么不只是成为一个优秀的科学家？” 他说：“Hamming，我对贝尔实验室的数学有一个愿景。如果这个愿景有可能能够实现，那我就必须让它实现，所以我必须成为部门主管。”</p>
<p>当你对你想做的事情有一个愿景，而你可以独自完成，那么你应该去追求它。当你的愿景，你认为需要做的事情，比你一个人能做的事情更大的时候，你就必须向管理方向发展。愿景越大，你就必须走得越远。如果你有一个关于整个实验室或整个贝尔系统的愿景，你必须到管理层去实现它，你从一线员工的角度去实现它是非常困难的。所以管理和研究取决于你的目标和愿望。随着生活的变化，你必须做好准备去改变你的选择。我选择避免管理，因为我更喜欢独自做我能做的。</p>
<h2 id="关于别人的期许"><a class="header-anchor" href="#关于别人的期许">#</a>关于别人的期许</h2>
<blockquote>
<p>Question: How important is one’s own expectation or how important is it to be in a group or surrounded by people who expect great work from you?</p>
</blockquote>
<blockquote>
<p>Hamming: At Bell Labs everyone expected good work from me - it was a big help. Everybody expects you to do a good job, so you do, if you’ve got pride. I think it’s very valuable to have first-class people around. I sought out the best people. The moment that physics table lost the best people, I left. The moment I saw that the same was true of the chemistry table, I left. I tried to go with people who had great ability so I could learn from them and who would expect great results out of me. By deliberately managing myself, I think I did much better than laissez faire.</p>
</blockquote>
<p>问题：一个人的期望有多重要？或者说，被一个期望你能做出伟大工作的团队包围有多重要？</p>
<p>Hamming：在贝尔实验室，每个人都期望我能做出好的工作，这对我很有帮助。如果每个人都期望你能做出好的工作，你又有自尊心，那么你就会做出好的工作。我认为身边有一流的人是非常有价值的，所以我不断地在寻找最优秀的人。当物理学组失去最优秀的的人时，我离开了物理学组。当我看到化学组也是如此时，我也离开了。我试图和有很强能力的人在一起，这样我就可以向他们学习，他们也会期望我能做出伟大的成果。通过有意识地管理自己，我认为我做得比放任自流要好得多。</p>
<h2 id="关于运气-2"><a class="header-anchor" href="#关于运气-2">#</a>关于运气</h2>
<blockquote>
<p>Question: You, at the outset of your talk, minimized or played down luck; but you seemed also to gloss over the circumstances that got you to Los Alamos, that got you to Chicago, that got you to Bell Laboratories.</p>
</blockquote>
<blockquote>
<p>Hamming: There was some luck. On the other hand I don’t know the alternate branches. Until you can say that the other branches would not have been equally or more successful, I can’t say. Is it luck the particular thing you do? For example, when I met Feynman at Los Alamos, I knew he was going to get a Nobel Prize. I didn’t know what for. But I knew darn well he was going to do great work. No matter what directions came up in the future, this man would do great work. And sure enough, he did do great work. It isn’t that you only do a little great work at this circumstance and that was luck, there are many opportunities sooner or later. There are a whole pail full of opportunities, of which, if you’re in this situation, you seize one and you’re great over there instead of over here. There is an element of luck, yes and no. Luck favors a prepared mind; luck favors a prepared person. It is not guaranteed; I don’t guarantee success as being absolutely certain. I’d say luck changes the odds, but there is some definite control on the part of the individual.</p>
</blockquote>
<p>问题: 在你的演讲开始时，你淡化了运气的作用，你似乎也忽略了让你到 Log Alamos 的环境，让你到达 Chicago，让你到达贝尔实验室的环境。</p>
<p>Hamming：确实这些事有一些运气。但从另一方面，我也不知道如果这些事没发生，我会怎么样。除非我能说 “没这些事，我就不会同样成功或更成功”，不然我也没法将去这些地方定义为是 “好运” 的。例如，当我在 Los Alamos 遇到费曼时，我知道他将获得诺贝尔奖。我不知道具体是什么原因，但我就是很清楚地知道他会做出伟大的工作。无论未来出现什么样的方向，这个人都会做出伟大的工作，果然，他做出了伟大的工作。并不是说你只能在特定情况下做出伟大的工作，如果是那样的话，那确实是运气主导了一切。实际上你总会有很多机会。你会有一大堆机会。如果你处在某个情况下，你抓住了一个机会，你就会在那里取得伟大的成就。所以运气是有的，但它决定不了一切。运气青睐有准备的头脑，运气青睐有准备的人。当然我无法保证这一点，我不能保证成功是绝对的。我只能说运气改变了胜算，但个人也有一定的控制权。</p>
<h1 id="Reference"><a class="header-anchor" href="#Reference">#</a>Reference</h1>
<p><a href="https://www.cs.virginia.edu/~robins/youandyourresearch.html">You and Your Research (virginia.edu)</a></p>
]]></content>
      <tags>
        <tag>摘抄</tag>
      </tags>
  </entry>
  <entry>
    <title>《卓有成效的管理者》 摘抄</title>
    <url>/zhuo_you_cheng_xiao_de_guan_li_zhe/</url>
    <content><![CDATA[<h1 id="前言"><a class="header-anchor" href="#前言">#</a>前言</h1>
<p>本书的主题却是关于如何自我管理才能成为卓有成效的管理者的 ，实际上，让自身成效不高的管理者管好他们的同事与下属，那几乎是不可能的事。</p>
<h1 id="第一章_卓有成效是可以学会的"><a class="header-anchor" href="#第一章_卓有成效是可以学会的">#</a>第一章 卓有成效是可以学会的</h1>
<p>有才能的人往往最为无效，因为他们没有认识到才能本身并不是成果。他们也不知道，一个人的才能，只有通过有条理、有系统的工作，才有可能产生效益。</p>
<h2 id="为什么需要卓有成效的管理者"><a class="header-anchor" href="#为什么需要卓有成效的管理者">#</a>为什么需要卓有成效的管理者</h2>
<p>“有效性”只是“知识工作者”（knowledge worker）的一种特殊技能。</p>
<ul>
<li>对“体力工作”而言，我们所重视的只是“效率”。所谓效率，可以说是“把事情做对”（to do things right）的能力，而不是“做对的事情”（to get the right things done）的能力</li>
<li>唯有从事“对”的工作，才能使工作有效，而这一点，却是无法用衡量体力工作的方法来衡量的。</li>
</ul>
<p>我们无法对知识工作者进行严密和细致的督导，我们只能协助他们。知识工作者本人必须自己管理自己，自觉地完成任务，自觉地做出贡献，自觉地追求工作效益。</p>
<p>再伟大的智慧，如果不能应用在行动上，也将只是毫无意义的资料。因此，知识工作者必须做到一些体力工作者不需要做的事，他必须具有有效性。</p>
<h2 id="谁是管理者"><a class="header-anchor" href="#谁是管理者">#</a>谁是管理者</h2>
<div class="note info simple"><p>在一个现代的组织里，如果一位知识工作者能够凭借其职位和知识，对该组织负有贡献的责任，因而能对该组织的经营能力及达成的成果产生实质性的影响，那么他就是一位管理者。</p>
</div>
<p>美国报纸曾刊登一篇对于越南战场上一位青年步兵上尉的采访，最能清楚地说明这一点。记者问：“在战场混乱的情况下，你如何指挥你的下属？”那位青年步兵上尉回答说：“在那里，我是唯一的负责人。当我的下属在丛林中遭遇敌人却不知道该怎么行动时，我也因为距离太远无法告诉他们。我的任务，只是确保他们知道在这种情形下应该如何行动。至于实际上该怎么做，应由他们根据情况加以判断。责任虽然在我，但行动的决策却由战场上的每个人自己决定。”在游击战中，每一个人都是“管理者”。</p>
<p>在主管人员中，也有许多人并不是管理者。换言之，许多人只不过是别人的上司，甚至是许多人的上司，但他们的行为，并不能对组织的经营能力产生重大的影响。<br>
与此相反，一位知识工作者是不是一位管理者，我们不能以他有没有下属而定。</p>
<div class="note info simple"><p>在本书中，“管理者”一词，将泛指知识工作者、经理人员和专业人员。</p>
</div>
<h2 id="管理者必须面对的现实"><a class="header-anchor" href="#管理者必须面对的现实">#</a>管理者必须面对的现实</h2>
<ol>
<li>管理者的时间往往只属于别人，不属于自己。如果我们从工作的情形来替管理者下一个定义，我们简直可以说他是组织的囚徒。每一个人都可以随时来找他，而事实上每一个人也正是这么做的。</li>
<li>管理者往往被迫忙于“日常运作”，除非他们敢于采取行动来改变周围的一切。
<ul>
<li>如果管理者被迎面而来的一连串事务所左右，根据事情先后顺序来决定做什么、研究什么、重点对待哪项工作，那他不久就只能穷于应付了。也许他具有了不起的才干，足以应付得了，但实际上他却是在浪费自己的知识和能力，把原本可能达成的成效撇开了。管理者需要的是一套判断标准，使他能够针对真正重要的事项去工作。但是在日常事务中，常常找不到他所需的标准</li>
</ul>
</li>
<li>管理者本身处于一个“组织”之中。只有当别人能够利用管理者的贡献时，管理者才算有效
<ul>
<li>对管理者的有效性而言，最重要的人物，往往并不是管理者直接控制的下属，而是其他部门的人，即所谓“旁系人士”，或是管理者本人的上司。一位管理者如果不能与这些人主动接触，不能使这些人有效利用他的贡献，他本身就没有有效性可言。</li>
</ul>
</li>
<li>管理者身处一个组织的“内部”，受到组织的局限。
<ul>
<li>在组织的内部，根本不会有成果出现，一切成果都存在于组织之外。举例来说，企业机构的成果，是通过顾客产生的，企业付出的成本和努力，必须通过顾客购买其产品或服务，才能转变为收入和利润。也就是说，做决定的人在企业之外，不在企业之内。</li>
<li>这种外部环境是真正的现实，而这个现实却不能从组织内部有效控制，充其量也必须内外两方面共同作用才能产生成果。管理者能看得清清楚楚的只是组织的内部，组织内部才是他最密切接触的。内部的种种关系和联系、内部的种种问题和挑战以及种种错综的情况和意见，不停地由各个方向向他袭来。除非他能付出特殊的努力，使自己与外界保持直接的联系，否则他必将日益局限于组织内部。他在组织中的地位越高，他的注意力就越容易为内部的问题和挑战所困，而看不到外部的情况。</li>
<li>一个组织绝不能像生物一样，以自身的生存为目的，仅仅把能够延续后代视作成功。组织是社会的一种器官，只有能为外部环境做出自己的贡献，才能算有所成就。但是，当组织的规模日益扩大，并且看来日益成功时，其内部的种种事务也将变得更多，这些事务将占据管理者更多的兴趣、精力和能力，使其难以顾及自己的真正任务，无法为外界提供有效的服务。</li>
<li>通常只有组织内部的资料，才是可以量化的。真正的问题是，外部情况往往是质的性质，难以量化，它们还不能被称为事实。
<ul>
<li>福特公司的一款名为 Edsel 的汽车，也是一个类似的例子。在推出这种车型之前，福特公司搜集了一切能够得到的数据，证明这款新车必能畅销。没想到美国的汽车消费者发生了质的变化，从“收入决定购买”转变到“兴趣决定购买”了。而这种质的变化，却无法用统计数字来显示。等到后来这种质的变化可以用充分的数据来说明的时候，为时已晚，公司的新车已经推出，结果导致了失败。</li>
</ul>
</li>
<li>一位管理者，如果不能有意识地努力去觉察外部世界，则组织内部的事务必将蒙蔽他，使他看不见真正的现实。</li>
</ul>
</li>
</ol>
<h2 id="对有效性的认识"><a class="header-anchor" href="#对有效性的认识">#</a>对有效性的认识</h2>
<p>我们必须学会这么一种建立组织的方式：若某人在某一重要领域具有一技之长，就要让他充分发挥这一特长。</p>
<p>当然我说这些，并不表示一个人连各领域的一些基础知识都不需要掌握了。今天有许多年轻的受过高等教育的人士，不论是在企业机构、医院还是政府，他们的缺点之一，是往往以自己精通了某一狭窄领域的专门学问而自满，不屑于其他。一位会计当然不一定需要钻研人际关系，一位工程师当然也不一定需要钻研如何促销新产品；可是，他们至少应该知道那些是什么样的领域，为什么要设立那些领域，那些领域到底做些什么。</p>
<p>但是，这种精而后博的人与所谓通才不同。通才也和天才一样，可遇而不可求。我们应该努力的是，学会善用那些专精于某一领域的人。也就是说，我们必须提高有效性。我们既然不能增加资源的供应量，就应该设法增加资源的产出量。所谓有效性，就是使能力和知识资源能够产生更多、更好成果的一种手段。</p>
<h2 id="卓有成效可以学会吗"><a class="header-anchor" href="#卓有成效可以学会吗">#</a>卓有成效可以学会吗</h2>
<p>卓有成效的管理者有一个共同点，那就是他们在实践中都要经历一段训练，这一训练使他们工作起来能卓有成效。不管他们是在企业机构内、政府机构内、医院内，还是学校内，不管他们是干什么的，这些训练的内容都是一样的。</p>
<p>有效性是一种后天的习惯，是一种实践的综合。既然是一种习惯，便是可以学会的。</p>
<p>下列 5 项是要成为一个卓有成效的管理者，必须在思想上养成的习惯：</p>
<ol>
<li>有效的管理者知道应该将他们的时间用在什么地方。他们所能控制的时间非常有限，他们会通过系统地工作来善用这有限的时间。</li>
<li>有效的管理者重视对外界的贡献。他们并非为工作而工作，而是为成果而工作。他们不会一接到工作就一头钻进去，更不会一开头就探究工作的技术和手段，他们会首先自问：“别人期望我做出什么成果？”</li>
<li>有效的管理者善于利用长处，包括自己的长处、上司的长处、同事的长处和下属的长处。他们还善于抓住有利形势，做他们能做的事。他们不会把工作建立在自己的短处上，也绝不会去做自己做不了的事。</li>
<li>有效的管理者集中精力于少数重要的领域，在这少数重要的领域中，如果能有优秀的绩效就可以产生卓越的成果。他们会按照工作的轻重缓急设定优先次序，而且坚守优先次序。他们别无选择，只能要事第一。重要的事先做，不重要的事放一放，甚至不做，两种事都做，反倒会一事无成。</li>
<li>最后，有效的管理者必须善于做有效的决策。他们知道有效的决策事关处事的条理和秩序问题，也就是如何按正确的次序采取正确的步骤。他们知道一项有效的决策，总是在“不同意见讨论”的基础上做出的判断，它绝不会是“一致意见”的产物。他们知道快速的决策多为错误的决策，真正不可或缺的决策数量并不多，但一定是根本性的决策。他们需要的是正确的战略，而不是令人眼花缭乱的战术。</li>
</ol>
<h1 id="第二章_掌握自己的时间"><a class="header-anchor" href="#第二章_掌握自己的时间">#</a>第二章 掌握自己的时间</h1>
<p>管理者的工作计划，很少真正发生作用。计划通常只是纸上谈兵，或只是良好的意愿，很少能够真正实现。</p>
<p>有效的管理者并不是一开始就着手工作，他们往往会从时间安排上着手。他们并不以计划为起点，认识清楚自己的时间用在什么地方才是起点。然后他们管理自己的时间，减少非生产性工作所占用的时间。最后，再将“可自由运用的时间”，由零星而集中成大块连续性的时段。</p>
<p>有效的管理者知道，时间是一项限制因素。任何生产程序的产出量，都会受到最稀有资源的制约。而在我们称之为“工作成就”的生产程序里，最稀有的资源，就是时间。</p>
<p>人类像其他生物一样，生理上有自己的“生物钟”——任何人如果有乘飞机越洋飞行的经验，应该都能了解。但是心理学实验却证明，人的时间感觉是最不可靠的。所以，如果完全靠记忆，我们恐怕说不清楚自己的时间是怎样打发的。</p>
<ul>
<li>某公司的董事长，十分肯定地对我说他的时间大致分成三个部分：1/3 用于与公司高级管理人员研讨业务；1/3 用于接待重要客户；其余 1/3 则用于参加各种社会活动。但是，等实际记录了 6 个星期之后，跟他原来的估计比较，结果发现在上述三个方面，他几乎没花什么时间。原来，他所说的三类工作，只不过是他认为“应该”花时间的工作而已，因此他的记忆告诉他已将时间用在这三个方面了。6 个星期的实际记录，显示他的时间大部分都花在调度工作上了，例如处理他自己认识的顾客的订单，打电话给工厂催货。事实上，顾客的订单，本来可以顺利处理的，由于他的干预，反而弄得不能准时交货。</li>
</ul>
<h2 id="时间对管理者的压力"><a class="header-anchor" href="#时间对管理者的压力">#</a>时间对管理者的压力</h2>
<p>管理者经常受到种种压力，迫使他不得不花费一些时间在非生产性的和浪费时间的事务上。身为管理者，不管他是不是经理人，总有许多时间耗在毫无贡献的工作上。大量时间都不可避免地浪费了。而且管理者在组织中的地位越高，组织对他的时间要求往往越大。</p>
<p>每一位管理者的时间，都有很大部分是被浪费掉的。表面上看起来，每件事似乎都非办不可，实际上却毫无贡献或贡献太少。但是，即使是只想获得最低程度的有效性，管理者在绝大部分任务上也需要相当多的整块时间。如果每一次所花的时间少于这个极限，事情就做不好，所花的时间就是浪费，再做就得从头开始。</p>
<ul>
<li>举例来说，一份报告大概得花 6 ～ 8 小时才能完成初稿。如果说每次花 15 分钟，每天 2 次，一共花上 2 星期，虽然总时间也达到 7 小时，恐怕结果还是一张白卷，不过是在上面胡乱涂写了一些东西而已。但是如果能够关起门来，切断电话，连续做上五六个小时，一份相当不错的草稿就应该差不多了。</li>
</ul>
<p>每一位知识工作者，尤其是每一位管理者，要想有效就必须能将时间做整块的运用。如果将时间分割开来零星使用，纵然总时间相同，结果时间也肯定不够。</p>
<p>要想与他人做有效的沟通，总得花上足够的时间。一位经理人员如果以为他与下属讨论一项计划、一项方针或是一项工作表现，只需 15 分钟就够了，那他一定是自欺欺人。如果你真想影响别人，那至少需要一小时以上。如果你想和别人建立良好的人际关系，就需要更多的时间。</p>
<p>知识工作者只能自己制定工作方向，所以他必须了解别人期望他做出的贡献是什么，原因是什么，对必须使用其知识成果的人的工作情况，他也要有足够的了解。因此，知识工作者需要信息，需要讨论，还需要指导他人，这都是极为费时的。而且，他不但需要占用他上级的时间，也同样需要占用他周围同事的时间。</p>
<ul>
<li>知识工作者要想取得成果和绩效，就必须着眼于整个组织的成果和绩效。换句话说，他还得匀出时间来，将目光由自己的工作转到成果上；由他的专业转到外部世界，因为只有外部世界才有绩效可言。</li>
<li>在大型组织中，如果知识工作者的绩效表现不错，往往是因为该组织的高级主管能定期抽出时间来与他们进行交流，</li>
</ul>
<p>这样轻松交流，不管是在政府、企业、研究机构，还是在军事单位，都同样很有必要。如果没有这样的交流，知识工作者就容易丧失热情，成为得过且过的人，或者是只关注自己的专业领域，看不到整个组织的需要和机会。不过，进行这样的交流是很费时间的，特别是这种交流必须在不慌不忙、轻松自在的气氛下进行。只有这样，大家才会觉得“我们有足够的时间”，可以从容不迫地交流看法。这实际上意味着管理者要快速地做许多事，同时也意味着他必须腾出整块的时间来，而且中间不能有太多的中断和打扰。</p>
<ul>
<li>毫无疑问的是：一起工作的人数越多，工作者用于彼此协调关系的时间肯定越多，而真正用于工作的时间就越少了。因此大型组织只有在大量耗用其管理者的时间之后，才能变得强大有力。所以，组织规模越大，管理者实际可掌握的时间越少。身为管理者，因此更应该知道自己的时间应该用在什么地方，并且更应该妥善运用那剩下来可自由支配的少量时间了</li>
</ul>
<h2 id="如何诊断自己的时间"><a class="header-anchor" href="#如何诊断自己的时间">#</a>如何诊断自己的时间</h2>
<p>早在 20 世纪初期的科学管理时代，我们就已经知道了记录工作时间，</p>
<p>但是我们却一直将这套方法应用在时间因素并不太重要的工作上。在那些工作中，时间的利用和浪费，充其量只会对效率和成本稍有影响。而在某些越来越重要的工作领域，我们却没有应用这套方法，尤其是那些时间因素特别重要的知识工作，特别是管理者的工作。</p>
<p>所以，要提高管理者的有效性，第一步就是记录其时间耗用的实际情形。重要的是，必须在处理某一工作的“当时”立即加以记录，而不能事后凭记忆补记。有了时间耗用的记录样本，他们便能自行检讨了。半年之后，他们都会发现自己的时间耗用得很乱，浪费在种种无谓的小事上。经过练习，他们在时间的利用上必有进步。</p>
<p>第二个步骤就是要做有系统的时间管理。我们先要将非生产性的和浪费时间的活动找出来，尽可能将这类活动从时间表上排除出去。要做到这一步，可以试问自己以下几个问题。</p>
<ol>
<li>首先要找出什么事根本不必做，这些事做了也完全是浪费时间，于最终的成果无助。
<ul>
<li>许多大忙人，天天在做一些他们觉得难以割舍的事，比如应邀讲演、参加宴会、担任委员和列席指导之类，这些活动不知占去了他们多少时间。而这些工作，他们本身既不感兴趣，做得也根本不够精彩</li>
</ul>
</li>
<li>第二个该问的问题是：“时间记录上的哪些活动可以由别人代为参加而又不影响效果？”
<ul>
<li>几乎每一位主管人员都接到过上级有关做好授权的指示，而且他们本人也曾屡屡对其下属阐明授权的重要。但是这样的谆谆告诫是否产生了预期效果，实在令人怀疑。原因非常简单：没有完全明了授权的意义。</li>
<li>如果认为所谓授权，意思是说：“我的”工作应由别人来做，那就错了；因为你既然拿了薪水，就该做你自己的工作。又有人认为：充分授权之后，最闲散的经理人便应该是最好的经理人。这样的看法不但荒唐，而且也是不道德的。</li>
<li>管理者所做的工作，确实有许许多多可由别人去做，而且也应该由别人去做。“授权”这个名词，通常都被人误解，甚至是曲解了。这个名词的意义，应该是把可由别人做的事情交付给别人，这样才能做真正应由自己做的事。</li>
</ul>
</li>
<li>还有一项时间浪费的因素，是管理者自己可以控制并且可以消除的，这项因素是：管理者在浪费别人的时间。
<ul>
<li>去问问你的下属。有效的管理者懂得有系统及诚恳地问他的下属：“请你想想看，我常做哪些浪费你的时间而又不产生效果的事情？”问这样的问题，而且问得对方敢说真心话，才是有效管理者的特色。</li>
<li>某一大企业机构的财务经理，深感会议浪费了太多时间。通常不管讨论的是什么，他都通知财务部各单位主管全体前来开会，其结果是会议每次都拖得很长。出席会议的每一位主管，为了表示自己对问题的关切，都得提出自己的意见，而这些意见却大多与问题无关，会议时间自然拖长了。直到有一次这位财务经理诚恳地问了大家，才知道大家也都认为会议太浪费时间了。可是，他又想到：每一个人在组织中都至为重要，都应该了解情况，开会时如果少请几个人，他又担心会使未被邀请的人觉得他们被忽视。后来这位财务经理终于找到一个两全其美的办法了。开会前，他先分发一份开会通知：“兹订于星期三下午 3 时，于四楼会议室，邀请赵钱孙李四君开会讨论下年度资本预算问题。如哪位需了解这个问题或愿参与讨论，亦请届时出席。如果无法出席，我们将于会后立刻呈送记录，供各位参考并希望提供宝贵意见。”过去每次会议都要 12 人参加，花费整个下午，而现在只要 4 人出席，一小时就可以结束了，并且没有一个人有被忽视的感觉。</li>
<li>许多管理者都意识到了哪些事情会浪费他们的时间，然而他们却不敢面对这个问题。他们怕因小失大，造成错误。殊不知即使有了错误，也能很快弥补。能够大量削减不必要的和非生产性的工作，则工作就进行得快多了。事实上，一位管理者大刀阔斧地减少不必要的工作，绝不会有太大的风险。人常常会有高估自己地位的重要性的倾向，认为许多事非躬亲不可。纵然是最有效的管理者，仍然免不了有许多不必要的和非生产性的工作。</li>
</ul>
</li>
</ol>
<h2 id="消除浪费时间的活动"><a class="header-anchor" href="#消除浪费时间的活动">#</a>消除浪费时间的活动</h2>
<p>管理不善不仅会浪费大家的时间，更重要的是会浪费主管自己的时间。</p>
<p>（1）首先要做的是，找出由于缺乏制度或远见而产生时间浪费的因素。应注意的现象，是机构中一而再、再而三出现同样的“危机”。同样的危机如果出现了第二次，就绝不应该再让它出现第三次。</p>
<p>这类危机可以预先防止，或可以设计成一种例行工作，使每个人都能处理。所谓例行工作，是将本来要靠专家才能处理的事，设计成无须研究判断，人人均可处理的工作。例行的工作，可以说是专家们从过去的危机中，学会的一套有系统、有步骤的处理方式。</p>
<p>同一个危机如果重复出现，往往是疏忽和懒散造成的。</p>
<p>一个平静无波的工厂，必是管理上了轨道。如果一个工厂高潮迭现，在参观者看来大家忙得不可开交，就必是管理不善。管理好的工厂，总是单调无味，没有任何刺激动人的事件。那是因为凡是可能发生的危机都早已预见，且已将解决办法变成例行工作了。</p>
<p>（2）人员过多，也常造成时间的浪费。</p>
<p>判断人数是否过多，有一个靠得住的标准。如果一个高级管理人员，尤其是经理，不得不将他工作时间的 1/10 花在处理所谓“人际关系问题”上，花在处理纠纷和摩擦上，花在处理争执和合作等问题上，那么这个单位人数就过多了。</p>
<p>用一个人，应该是每天的工作都需要他。偶尔才有需要的专家，必要时才需向他请教的专家，就不该正式聘用。</p>
<p>（3）另一个常见的浪费时间的原因，是组织不健全。其表现就是会议太多。</p>
<p>所谓会议，顾名思义，是靠集会来商议，是组织缺陷的一种补救措施。我们开会时就不能工作，工作时就不能开会，谁也不能同时又开会又工作。一个结构设计臻于理想的组织，应该没有任何会议（在今天动态的世界中，这样的组织当然只是理想而已）。每个人应该都能了解他工作所必须了解的事，也应该都能随时获得他工作所必需的资源。我们之所以要开会，只是因为各有各的工作，要靠彼此合作才能完成某一特定任务。我们之所以要开会，只是因为某一情况所需的知识和经验，不能全部装在一个人的头脑里，需要集思广益。</p>
<p>一位管理者花费在会议上的时间如果过多，便是组织不健全的表现。要开会，就得有一定的计划，否则不但令人讨厌，而且是一种危险。会议应该是不得已的例外，不能视为常规。一个人人都随时开会的组织，必是一个谁都不能做事的组织。</p>
<p>原则上，一位管理者的时间，绝不能让开会占用太多。会议太多，表示职位结构不当，也表示单位设置不当。会议太多，表示本应由一个职位或一个单位做的工作，分散到几个职位或几个单位去了。同时表示职责混乱以及未能将信息传送给需要的人员。</p>
<p>（4）最后一项浪费时间的因素，是信息功能不健全。</p>
<ul>
<li>某一医院的院长，多年来一直为应付院内医生们的电话而苦恼。医生们打电话给他，要求他为病人安排一个床位。住院部都说是没有床位了，但这位院长几乎每次都可以找到空床位。原因是在病人出院时，住院部不能立刻接到通知。当然，有没有床位，各病房的护士长随时都很清楚，主办出院结账手续的出纳台也能随时知道。住院部的人，是在每天清早 5 点办理“床位调查”工作，而通常病人大多是在上午医生查房之后才办出院手续。其实像这样的问题，只要各病房护士长在填写出院通知单给出纳台时，多填一份副本送住院部就解决了。</li>
</ul>
<p>另一种同样常见的现象，是信息的表达方式不当，其后果有时更为严重。</p>
<ul>
<li>制造部门常遭遇的一项困扰，是生产数字无法直接供生产作业部门使用。例如产量，报表中往往只列出会计部门所需的“平均产量”。可是直接作业人员需要的却不是平均数字，而是范围和大小，包括产品的组合、产量的变动和每批生产的时间等。所以，他们需要这类资料时，不是每天都得花费几小时来推算，就是在本单位内设置一个自己的秘密统计组。当然这种资料在会计部门一定都有的，可是通常谁也不想去告诉会计部门，说自己需要的是怎样的信息。</li>
</ul>
<h2 id="统一安排可以自由支配的时间"><a class="header-anchor" href="#统一安排可以自由支配的时间">#</a>统一安排可以自由支配的时间</h2>
<p>一位管理者无论怎样无情地删掉了浪费的部分，其自由时间仍不会太多。一位管理者的职位越高，其不能自行支配的时间也一定越多。组织的规模越大，其用于维系组织运行，而非用于发挥组织功能及生产的时间也一定越多。</p>
<p>有效的管理者知道他必须集中他的自由时间。他知道他需要集中整块时间，时间分割成许多段，等于没有时间。时间如果能集中，即使只有一个工作日的 1/4，也足可办理几件大事。反之，零零碎碎的时间，纵然总数有 3/4 个工作日，也是毫无用处。</p>
<p>卡尔森教授在他的研究报告中，曾提到一位最有效的管理者。这位管理者每天上午上班前，总有 90 分钟时间留在家里，不接电话，专门从事研究工作。如果还要准时上班，那么早上在家里自然就得早早开始工作了。不过这种做法，总比每天下班后把重要事务带回家去，晚饭后再花 3 小时处理的方式好得多。现在喜欢把工作带回家来开夜车的人越来越多，这往往会造成一种不好的情况：人们以为可以晚上加班，因此反倒没有抓紧白天的工作时间。</p>
<p>许多人把次要的工作集中起来办理，因而匀出一段整块时间来。但这样的方法并无太大的作用。因为这样的方法，使人在心理或时间上，仍然放不下那些次要的事情，放不下那些很少贡献而又认为不能不做的事情。结果终究还会产生新的时间压力，来占用他的自由时间，牺牲他应该做的事。</p>
<p>一切卓有成效的管理者都懂得：对时间的控制与管理不能一劳永逸。他们要持续不断地做时间记录，定期对这些记录进行分析，还必须根据自己可以支配的时间的多少，给一些重要的活动定下必须完成的期限。</p>
<h1 id="第三章_我能贡献什么"><a class="header-anchor" href="#第三章_我能贡献什么">#</a>第三章 我能贡献什么</h1>
<p>重视贡献是有效性的关键。所谓有效性，表现在以下三个方面：</p>
<ol>
<li>自己的工作，包括工作内容、工作水准、工作标准及其影响</li>
<li>自己与他人的关系，包括对上司、同事和下属</li>
<li>各项管理手段的运用，例如会议或报告等。</li>
</ol>
<p>可是大多数管理者的视线都集中在下方。他们重视勤奋，但忽略成果。他们耿耿于怀的是：所服务的组织和上司是否亏待了他们，是否该为他们做些什么。他们最在意的是“应有”的权威，结果是做事没有成效。</p>
<p>一个人如果只知道埋头苦干，如果老是强调自己的职权，那不论其职位有多高，也只能算是别人的“下属”。反过来说，一个重视贡献的人，一个注意对成果负责的人，即使他位卑职小，也应该算是“高层管理人员”</p>
<h2 id="管理者的承诺"><a class="header-anchor" href="#管理者的承诺">#</a>管理者的承诺</h2>
<p>提出“我能做出什么贡献”的问题，是为了挖掘工作中尚未发挥的潜力，管理者如果不自问“我可以做出什么贡献”，他在工作中就不会有远大的目标，甚至可能把目标搞错而且特别容易对“贡献”一词只有狭义的理解。</p>
<p>一般机构对成效的要求往往表现在以下三个方面：</p>
<ul>
<li>直接成果</li>
<li>树立新的价值观及对这些价值观的重新确认</li>
<li>培养与开发明天所需要的人才</li>
</ul>
<p>因此，管理者若想做点贡献，就必须在这三方面下功夫。不过在这三者之中，哪个最重要，哪个其次，就要看管理者本人的情况以及他所处的地位及机构本身的需要了。</p>
<ul>
<li>直接成果应该是最重要的。组织的生存需要直接成果，犹如人需要营养食物一样。</li>
<li>除了直接成果，一个组织还必须有价值观的承诺与实现，这就像人体除了食物外还少不了维生素和矿物质。一个组织必须有自己的主张和想法，否则就难免解体、混乱和瘫痪</li>
<li>人都免不了一死，纵然他有再大的贡献，其贡献也因此有一定的限度。而一个组织，大体言之，正是克服这种限度的工具。组织如果不能持续存在，就是失败。所以，一个组织必须今天准备明天的接班人，其人力资源必须更新，必须经常提高水准。</li>
</ul>
<p>管理者的失败，原因有很多。常见的原因，应该是他本人在出任一项新职位时，不能或不愿为适应新职位的需要而改变自身。自以为过去做得成功了，因此满足于老一套的工作方法，结果必然遭到失败。</p>
<h2 id="如何使专业人员的工作卓有成效"><a class="header-anchor" href="#如何使专业人员的工作卓有成效">#</a>如何使专业人员的工作卓有成效</h2>
<p>知识工作者通常是一位专业人员。原则上，只有当他掌握了某种专门知识后，他的工作才能卓有成效。也就是说，他必须有所专长。但是，所谓专长，本身就是片面的、孤立的。一个专业人员的产出必须与其他人的产出结合在一起，才能产生成果。并不是说专业人员应变成“通才”，而是说专业人员必须使他本人有效，必须使他的专才有效。他必须考虑到他的产出供什么人使用，也必须了解用户应该知道些什么才能有效使用他的产出，从而产生成果。</p>
<p>知识分子有责任让别人了解自己。有些专业人员认为，普通人应该并且可以做出努力来理解他们，甚至认为他们只要能够和同行的少数专业人员沟通就够了，这真是傲慢的自大。一个人如果想成为管理者，换句话说，如果愿以贡献为目标，就必须使自己的“产品”——即他的知识能为别人所用。</p>
<p>卓有成效的管理者因为有想把工作干得更好的心理动力，所以总想了解别人需要什么、发现了什么以及能理解些什么。他们会向机构内部人员（包括他们的上司、下属，特别是其他部门的同事）提出这样的问题：“为便于你为机构做出贡献，你需要我做些什么贡献？需要我在什么时候，以哪种形式，用什么方式来提供这些贡献？”</p>
<p>所谓“通才”，应该也是一位专家，是一位能将其所专的一个小领域与其他广大知识领域联系的专家。有少数人也许可以精通几门知识，但这并不意味着他们便是通才，他们不过是精通几门知识的专家而已。仅通一门的专家固然可能偏执，精通几门的专家同样有可能偏执。</p>
<h2 id="正确的人际关系"><a class="header-anchor" href="#正确的人际关系">#</a>正确的人际关系</h2>
<p>在以工作或任务为主的环境下，如果我们不能有所成就，那就算我们能与人和谐相处，愉快交谈，又有什么意义呢？这种“和谐相处，愉快交谈”恰恰是恶劣态度的伪装。反过来说，如果能在工作上取得成绩，即使偶尔疾言厉色，也不至于影响人际关系的。</p>
<p>在个人的经验中，最具有良好人际关系的人士，我可以列举三个人：一位是第二次世界大战时美国的陆军参谋长马歇尔将军，一位是曾任通用汽车公司总裁达 30 余年的斯隆先生，还有一位是斯隆先生的高级主管之一杜瑞斯特。他们三人待人的方式虽各有不同，但都把人际关系建立在“贡献”的基础上。他们能与人密切合作，凡事都设身处地替别人着想。</p>
<p>有效的人际关系，有下列 4 项基本要求：</p>
<ul>
<li>互相沟通</li>
<li>团队合作</li>
<li>自我发展</li>
<li>培养他人。</li>
</ul>
<p>早在 20 年前，我们就已知道现代组织需要沟通，也缺乏沟通，可是今天的沟通工作仍然未见有多大改进。不过，至少我们已经开始了解沟通不易收效的原因了。原来是我们一直把沟通当成是上对下的事，是主管对下属的事。仅靠上对下的单向关系，沟通永远不可能成功。由下属自己设定的目标，往往会在主管的意料之外。换言之，主管和下属看问题的角度往往极不相同。下属越是能干，就越愿意自己承担责任，他们的所见所闻，所看到的客观现实、机会和需要，也就与他们的主管越不相同。此时下属的结论和主管的期望往往是明显对立的。</p>
<p>强调贡献有助于横向的沟通，因此能够促成团队合作。“谁需要我的产出，并使它产生效益？”这个问题能帮助我们看到与管理者责任范围无关的一些人（既不是他的上级或下级，也不是授权给他或他授权的人）的重要性。</p>
<h2 id="有效的会议"><a class="header-anchor" href="#有效的会议">#</a>有效的会议</h2>
<p>有效的管理者在会议开始时，会先说明会议的目的和要求达成的贡献。同时，他还要设法让会议紧紧围绕着主题。他绝不会使会议成为一次摆龙门阵的机会，任大家随便发言。当然，如果会议的目的是在激发大家的思想和创见，他也不会仅让某一个人滔滔不绝。他会刺激每一位与会人员的发言兴趣。但是在会议结束之前，他会回到开场所介绍的主题，使会议获得的结论与主题相符。</p>
<h1 id="第_4_章_如何发挥人的长处"><a class="header-anchor" href="#第_4_章_如何发挥人的长处">#</a>第 4 章 如何发挥人的长处</h1>
<p>用其同事之所长、用其上级之所长和用其本身之所长。利用好这些长处可以给你带来真正的机会。充分发挥人的长处，才是组织存在的唯一目的。要知道任何人都必定有很多缺点和短处，而缺点和短处几乎是不可能改变的，但是我们却可以设法使其不发生作用。管理者的任务，就是要充分运用每一个人的长处，共同完成任务。</p>
<h2 id="要用人所长"><a class="header-anchor" href="#要用人所长">#</a>要用人所长</h2>
<p>有效的管理者择人任事和升迁，都以一个人能做些什么为基础。所以，他的用人决策，不在于如何克服人的短处，而在于如何发挥人的长处。</p>
<p>美国南北战争时，林肯总统任命格兰特将军为北方军的总司令。当时有人告诉他格兰特嗜酒贪杯，难当大任。林肯却说：“如果我知道他喜欢什么酒，我倒应该送他几桶，让大家共享。”林肯总统并不是不知道酗酒可能误事，但他更知道在北军诸将领中，只有格兰特能够运筹帷幄，决胜千里。后来的事实证明了格兰特将军的受命，正是南北战争的转折点。这是一个有效的任命，因为林肯以“取得战役胜利的能力”为标准来选择将军，而不求其没有缺点，是个完人。</p>
<p>不管是谁，如果他在任用一个人时只想避免短处，那他所领导的组织最终必然是平平庸庸的。所谓“样样皆通”者，即只有长处没有短处的人（也可用其他词来描述这类人，如“完人”“个性成熟”“个性完美”或“通才”），实际上可能一无是处。才干越高的人，其缺点也往往越多</p>
<p>一位管理者如果仅能见人之短而不能识人之长，因而刻意避其所短，而非着眼于发挥其所长，则这位管理者本身就是一位弱者。他会觉得别人的才干可能构成对他本身的威胁。有效的管理者知道他们之所以用人，是用人来做事，而不是用人来投主管之所好。剧团经理知道，如果女明星常发脾气而有助于票房，也许他之所以受聘为经理，就是为了承受她的脾气。</p>
<p>有效的管理者从来不问：“他能跟我合得来吗？”他们问的是：“他贡献了什么？”他们从来不问：“他不能做什么？”他们问的是：“他能把什么做好？换言之，类似“完美的人”的说法是忽视了人的卓越性。因为卓越通常只能表现在某一个方面，最多也只能表现在个别的几个方面。</p>
<p>真正能在多方面都有杰出造诣的人，至今还没有出现。达·芬奇算是多才多艺了，但他最突出的成就只是在绘画上。歌德的诗如果没有流传下来，那即使他对光学和哲学有研究，也不见得能在百科全书上找到他的赫赫大名。几位世人皆知的伟人尚且如此，更何况我们这些凡人。</p>
<p>重视一个人的长处，也就是要对他的工作绩效提出要求。如果管理者不在用人之前先问自己“他能做些什么”，那可以肯定他的下属绝难有贡献，这就等于他已经事先对下属的不称职采取了宽容的态度。这样的管理者成事不足，败事有余。真正“苛求的上司”（实际上懂得用人的上司大部分都是“苛求”的上司），总是先发掘一个人最擅长做些什么，再来“苛求”他做些什么。</p>
<p>有效的管理者并不是不知道人有缺点。他了解他自己的任务在于如何使某人充分发挥其税务会计的才干，而不斤斤计较他不善于与人打交道。这层道理谁都清楚。可是，为什么做起来又是另一回事呢？为什么世间的管理者很多，而真能发挥他人长处者却不多。</p>
<p>原因很简单。主要是因为管理者往往以为他们首要的任务不在于因人设事，而在于因事用人。所以，通常是先有了某一个职位，再物色人选来出任该职位。这样的步骤，往往引人走入歧途，物色的对象，往往只是一位“最不至于出差错”的人选——也就是“仅合乎最低要求”的人选。其结果，自然难免都是平平庸庸的人选了。</p>
<ul>
<li>避免出现这一错误，最常见的解决办法是“因人设事”。然而这哪是什么解决办法，这也许比原有的错误还糟，除非是规模极小、事务极简的组织。要知道职位应该是根据客观需要而设定的，应由任务而定，而不应因人而定。</li>
<li>为什么“因人设事”不能解决问题，是因为组织中任何一个职位的变更，都会造成一连串的连锁反应。组织中的职位都是相互联系、相互依存的，牵一发而动全身。我们不能为了替某人安插一个职位，而使组织中的每一个人都受到牵连。</li>
<li>只有因事用人，才能为组织提供所需的各种人才，也只有这样，我们才能容忍各色人等的脾气和个性。能容忍这些差异，内部关系也才能保持以任务为重心，而非以人为重心。衡量成就的高低，应该按照贡献和绩效的客观标准。只有在职位的设计和划分不以人为中心时，这种衡量才有可能。不然的话，我们就会只注意“谁好谁坏”，而忽略了“什么好什么坏”</li>
<li>才能为组织提供所需的各种人才，也只有这样，我们才能容忍各色人等的脾气和个性。能容忍这些差异，内部关系也才能保持以任务为重心，而非以人为重心。人事的决策，要凭公平和公正，否则就会赶走了好人，或破坏好人的干劲。同时，组织也需要各方面的人才，否则将缺乏改变的能力，也将难于得到做出正确的决策所需的不同意见。</li>
</ul>
<p>能建立起第一流经营体制的管理者，通常不会与周围的同事及下属保持过分亲密的关系。不能根据个人的好恶来挑选人才，而应当看他们能干些什么，看他们的工作表现，绝不能看他们是否顺从自己。为了确保能够选用适当的人选，管理者应该与直接的同事或下属保持适当的距离。卓有成效的管理者究竟该怎样用人，才能既发挥他人的长处，又不致陷入因人设事的陷阱呢？大致来说，不外乎下面 4 个原则：</p>
<ol>
<li>卓有成效的管理者不会认为职位是上天或上帝创造的。职位是由人设计，是人都可能犯错</li>
</ol>
<ul>
<li>一个职位，如果先后由两人或三人担任都失败了，这就肯定是一个常人无法胜任的职位，这个职位就必须重新设计。</li>
<li>有效的管理者，第一项任务就是要将自己管辖下的职位都设置得合情合理。一旦发现某职位设计不当，他会立刻重新设计，而不会去设法寻找天才来担任</li>
</ul>
<ol start="2">
<li>职位的要求要严格，而涵盖要广。这是说，合理的职位，是对具有才干的人的挑战。同时因为职位的涵盖很广，所以人们可以把与任务有关的优势转化为切实的成果。</li>
</ol>
<ul>
<li>许多大型组织的政策却与此背道而驰。它们的职位设计过于具体，看起来似乎非要经过“特殊设计”和“特殊加工”的人选，才能达成职位的要求，以便在某一特定时刻做出特定绩效。</li>
<li>而且，职位的要求往往会随情况而变动，甚至变动得非常剧烈。于是，一位本来“绝对适合”的人选，可能忽然间完全不适合这一职位了。</li>
<li>只有把职位设计得涵盖较广且要求较严，才能使人在情况有所变化时能适应新的需要。</li>
<li>一位新人的能力不高，但他出任一项职位后，应该使他能有充分展现其长处的机会。一位知识工作者在初任某一职位时，其职位的标准，应能作为他日后发展的引导，应能成为他衡量自己、评估贡献的依据。</li>
<li>知识工作者职位的设计，还应该能够使人及早发现自己是否适合该职位，甚至是否适合此类工作。</li>
<li>凡是最能充分发挥其长处，而且最受到挑战的人，他的工作肯定最起劲，也肯定最能有所成就。而对工作不满的人，大都是异口同声地埋怨：“他们没有让我充分发挥所长！”</li>
<li>年轻的知识工作者的职位涵盖范围太窄，不足以向他的能力挑战，其结果不是他自请离职，便是很快变成“老油条”</li>
</ul>
<ol start="3">
<li>卓有成效的管理者在用人时，会先考虑某人能做些什么，而不是先考虑职位的要求是什么</li>
</ol>
<ul>
<li>今天大多数组织制定的考评办法，其实最初是由临床与变态心理学家出于自己的目的而设计的。医生的目的在于治病，医生重视的是病人的毛病，而不是病人的优点。</li>
<li>日本有一种“终身雇用”的制度。一个人进了一家公司，他就会逐年升迁，平均每 15 年薪水增加一倍。他不会随便辞职，公司也不能把他开除。除非年龄到了 45 岁，或者位置升到了顶点，才显出事业生涯的分歧：其中少数能力特别强的人，可以继续升到高级主管的位置。日本这套制度，与日本今天取得的巨大发展有什么关联呢？答案很简单：由于日本有这套制度，所以他们可以闭上眼睛，不看人的缺点。尤其是因为日本的管理者不能开除人，所以他们就只有从下属中去发掘能做事的人了。他们看人，只看人之所长。</li>
<li>有效的管理者，通常总有他自己的一套与众不同的考评方式。这套方式，第一步是列出对某人过去职务和现任职务所期望的贡献，再把某人的实际绩效记录与这项期望贡献相对照，然后检讨下面的 4 个问题：
<ol>
<li>哪方面的工作他确实做得很好？</li>
<li>因此，哪方面的工作他可能会做得更好？</li>
<li>为了充分发挥他的长处，他还应该再学习或获得哪些知识？</li>
<li>如果我有个儿子或女儿，我愿意让我的子女在他的指导下工作吗？如果愿意，理由是什么？如果不愿意，理由是什么？</li>
</ol>
</li>
</ul>
<ol start="4">
<li>卓有成效的管理者知道在用人之所长的同时，必须容忍人之所短。</li>
</ol>
<p>西方谚语说：“仆从眼中无英雄。”与英雄接近的人，总能发现英雄的缺点。当然，令人发笑的一方肯定是仆从。仆从眼中所见英雄的缺点，无害其为英雄，更无害于他们在历史舞台上呼风唤雨。</p>
<p>有效的管理者会问：“这个人在某方面是否确有长处？他的长处，是否确为某一任务所需？这个人如果担当这项任务，是否确能表现得与众不同？”如果答案为“是”，那就不必犹豫，而继续聘用此人。</p>
<p>有效的管理者对一位得力的人才，绝不会说：“我少不了他，少了他，我的事就办不成了。”通常我们说“少不了某人”，其原因不外三点：</p>
<ol>
<li>某人其实并不行，不过是管理者没有对他苛求而已，他本人也只能在这种保护下生存；</li>
<li>管理者本人的能力太差，实际上是误用了某人的才干来勉强支持一个自己很难站得住脚的上司；</li>
<li>本来就潜伏着某项严重问题，因为误用某人的才干而将该项问题掩盖住了。</li>
</ol>
<p>对一个没有突出表现的人，尤其是一个没有突出表现的主管，应该无情地调职，这是管理者的责任。任他留下来，必将影响全体人员，而且对于整个组织也是不公平的。对他的下属，则尤为不公平，因为主管无能，则不啻剥夺了下属发挥长处的机会。</p>
<p>马歇尔将军认为，将一位不称职人员调职，与其说是反映了对这个人的看法，倒不如说是对任命他的人有看法。他说：“某人不称职，只是不称‘此’职，并不是说他也肯定不能胜任别的职务。所以，选派某人出任这个职务，是我的错误，我应该负责再给他找到适合的工作。”</p>
<p>马歇尔将军也并非完全不顾一个人的弱点。在弱点可能影响这个人充分发挥长处时，他就要考虑这个人的弱点了。但他所考虑的，是如何运用工作和职业机会来帮助这个人克服这些弱点。</p>
<p>任何一项人事任命都是一个赌注。但是，只要能抓住某人的长处，这至少是合理的赌注。尽量发挥下属的长处，不但是管理者必须对机构承担的义务，更重要的是，这也是为人处世的道理：他应该协助下属得到应有的发展。组织必须为每一位成员服务，使每一位成员都能凭其才干达成成就，而不必顾念其所短。</p>
<h2 id="如何管理上司"><a class="header-anchor" href="#如何管理上司">#</a>如何管理上司</h2>
<p>卓有成效的管理者还要设法充分发挥上司的长处，这也是非常重要的。</p>
<p>如果上级主管的能力不够，下属通常是无法爬升上去的。上司如果没有升迁，下属只好永远屈居其下。如果有一天上司因成绩不佳调职了，继任者也往往都是来自别的部门，很少在本单位中选人提升。</p>
<p>运用上司的长处，也是下属工作卓有成效的关键。只有如此，身为下属者才能将精力集中在自身的贡献上，完成自己想做的工作，取得希望取得的成就。要使上司能发挥其所长，不能靠唯命是从，应该从正确的事情着手，并以上司能够接受的方式向其提出建议。</p>
<p>上司既然是人，所以肯定有其长处，也肯定有其短处。若能在上司的长处上下功夫，协助他做好能做的工作，便能使上司有效，下属也才能有效。反之，如果下属总强调上司的短处，那就像上司强调下属的短处一样，结果将一无所成。</p>
<p>人大致可以分为两种类型：“读者型”和“听者型”。</p>
<ul>
<li>我们面对“读者型”的人侃侃而谈，那是徒费口舌，因为他只能在读过之后才能“听”得进去。</li>
<li>同样，我们面对听者型的人递送一册厚厚的报告书，那是徒费笔墨，因为他只能“听”了之后才能掌握要点</li>
</ul>
<p>向上司提出建议时，应关注“建议”中的各相关方。与事情的轻重是非相比，陈述的先后顺序才是更应考虑的。如果说上司长于政治能力，而这项工作又有关政治，那么我们提出的报告就应以政治方面的问题居先，这样才能使上司易于掌握问题的重心，从而易于发挥其所长，使新政策得以成功。</p>
<h2 id="充分发挥自己的长处"><a class="header-anchor" href="#充分发挥自己的长处">#</a>充分发挥自己的长处</h2>
<p>有效的管理者对于本身的工作，也同样要从长处出发，使自己的长处得以充分发挥。</p>
<p>有效的管理者肯定关心自己所面临的局限性，但他们也应该了解自己能做的和该做的其实还有很多。尽管有人觉得委屈，不能做事，但有效的管理者却能勇往直前。由于他们能勇往直前，所以别人感到非常严重的限制，在他们面前都烟消云散了。</p>
<p>重要的是，有效的管理者会顺应自己的个性特点，不会勉强自己。他注意的是自己的绩效、自己的成果，从而发展出自己的工作方式来。他会问：“哪一类工作别人做起来要费九牛二虎之力，我做起来却是轻而易举？”</p>
<p>在讨论一个人的长处和短处时，他们想到的通常只是针对一门学问的知识，或一种艺术才能。但是，人的性情却往往是事情成败的关键。成年人一般都能了解自己的性情。我们要求有效，就要以了解自己能做些什么为基础，然后以最适合自己的方式做下去。</p>
<p>本章所讨论的如何用人之长，不仅有个态度问题，而且有一个敢不敢去实践的问题。用人之长，可以从实践中获得改进。我们只要注意认识我们的下属，观察我们的上司，多问“此人能做些什么”，而不必问“此人不能做些什么”，最后我们肯定能养成重视人之所长及善用人之所长的态度。久而久之，我们也能以同样的问题来问自己了。</p>
<p>领导人和一般人之间总有一段差距。领导人的绩效高了，一般人也竞相争高。有效的管理者一定明白这层道理：提高领导人的水平容易，但提高全体人员的水平很难。所以，他一定要找出有条件做出突出贡献，并能起带头作用的人才，赋予他们领导人的地位，把他们安置到能“制定标准”并能创造成绩的位置上。</p>
<h1 id="第五章_要事优先"><a class="header-anchor" href="#第五章_要事优先">#</a>第五章 要事优先</h1>
<p>卓有成效如果有什么秘诀的话，那就是善于集中精力。卓有成效的管理者总是把重要的事情放在前面先做（first things first），而且一次只做好一件事</p>
<p>管理者越是想做出重大的贡献，越是需要有更长的“整块时间”。管理者越是想将繁忙纷杂转化为成就，越是需要持续不断的努力，越是需要较长的连续性的时间。然而，即使只想“偷得浮生半日闲”来处理真正有生产性的工作，也要自律和具备非常大的决心对某些事说“不”。</p>
<p>世上确实有人能在同一时间内交替地做两件事，因此两项工作有先后错落的变化。但这只是表示他们能够对两件事，交替分配一段“最低的整块时间”而已。要说一个人能同时处理三件事，恐怕就绝无仅有了。</p>
<p>正因为管理者面对的事务太多太杂，才特别需要专心。一次只做好一件工作，恰恰就是加快工作速度的最佳方法。越能集中我们的时间、努力和资源，我们所能完成的工作也就越多。</p>
<p>有些人一事无成，而实际上他们却做得很吃力。第一，他们低估了完成一件任务所需的时间。他们总以为万事顺利，却总不免有出乎意料的情况发生。然而每个管理者都知道，没有任何事情会是一帆风顺。其实，所谓意料之外者，正应该在我们意料之中。而所谓意料之中，往往从来没有令人愉快的意外。所以，有效的管理者对时间需求的估计宁可有余，而不可不足。第二，一般的管理者（往往也是不大有效的管理者）总喜欢赶工——而赶工的结果，总不免使进度更加落后。有效的管理者不愿赛跑，他们按部就班，稳定前进。第三，一般的管理者喜欢同时着手几件要事，结果对每一件事，他们都无法获得足够的最少整块时间。只要任何一件事情受阻，全部事情也都会跟着受阻了。</p>
<h2 id="摆脱昨天"><a class="header-anchor" href="#摆脱昨天">#</a>摆脱昨天</h2>
<p>管理者专心一志，第一项原则是要摆脱已经不再有价值的过去。有效的管理者必须经常检讨他们和同事的工作计划，他们会问：“如果我们还没有进行这项工作，现在我们该不该开始这项工作？”如果不是非办不可，他们就会放弃这项工作，或者会将它搁置起来。至少他们不会再将资源投入不再产生价值的过去。而对于已经投入的最佳资源，尤其是非常匮乏的人力资源，他们会立即抽调出来，转而投入未来的新机会。</p>
<p>昨天的决策和行动，不论当时看起来如何勇敢、如何睿智，都有可能形成今天的困难和危机，甚至被证明是愚蠢的选择。但是我们至少可以把昨天遗留下来的、不能再产生成果的工作尽量减少。</p>
<p>人若遭遇了重大的失败，改正并不太难，他们能检讨自己。可是昨天的成功，却能留下无尽的影响，远超出成功的有效期。</p>
<ul>
<li>这些过去的成功和活动最需要无情的检讨，否则组织的血液都流失到这种自我之中了。而且这种“经营管理上的自我主义的资产”，往往占用了组织中最能干的人才，却还说那是“值得的”。</li>
<li>任何计划如果无法证明其确属有效及需要，便该立即放弃。否则，现代的政府会用其种种法令规章不断地窒息整个社会，到最后政府本身也将因自己的臃肿而窒息。</li>
</ul>
<p>奉劝各大公司的企业家在抱怨政府官僚习气的同时，也检讨自己的公司是否充满了形形色色的“控制机制”，其实却什么也控制不了。自己的公司是否在进行种种研究，其实只是用来掩饰自己缺乏果断？</p>
<p>有效的管理者打算做一项新的业务时，一定要先删除一项原有的业务。这对控制组织的“膨胀”是非常必要的。“膨胀”如不加以控制，组织就会变得涣散、难以管理。社会组织恰如生物有机体，必须保持“瘦且有肌肉”的状态。</p>
<p>要准备克服重大困难的手段，唯一靠得住的办法只有靠最有才干的人来主持。但是最有才干的人，通常总是太忙了。如果不把他原有的负荷减轻，怎能期望他再承担新的工作？</p>
<ul>
<li>有人会想到另聘新人来负责新工作，但这太冒险了。我们增添新人，大部分是增添在已有成规可循的工作上。而对于新工作，我们应责成确能证明有能力的人来负责。老实说，做一项新工作，本身就是一场赌博即便其他人已经多次做过的工作也是如此；倘若再另聘新人来做，就更是赌上加赌了。</li>
<li>任用新人，可用在“比高层略低”的职位上，用在已有成规或目标明确的职位上。</li>
</ul>
<p>任何一个组织，都不缺乏新的创意。所以，严格说来，我们的问题不是缺乏“创意”，所缺乏的只是创意的执行。人人都在为昨天的任务而忙碌。只要能定期审视当前的计划或活动，并抛弃那些不再有产出的事情，即使是最暮气沉沉的机构，也能获得生机。</p>
<h2 id="先后次序的考虑"><a class="header-anchor" href="#先后次序的考虑">#</a>先后次序的考虑</h2>
<p>我们要做的并不只是弄清楚哪些事情必须优先去做，那是很容易做到的，每个人都可以做得到。很多管理者不能做到集中精力于某项工作，其主要困难在于他们确定不了哪些事情可以缓一缓，就是说要能确定哪些事情可以暂时不去做，并且能把这一决定坚持到底。</p>
<p>由于被搁置实际上等于被取消，所以管理者都不敢轻易地延缓任何工作。他们明白，被延缓的工作虽不是他们最优先要做的事情，不过一旦被延缓，也是有风险的。自己缓办的结果，说不定是竞争同业赶在前头了。决定延缓一项工作，并不是一件愉快的事情。因为我们的“置后”，往往是别人的“优先”。列举一份第一优先的工作单，事事都办，但均浅尝辄止，显然容易得多。这样经常能使人人皆大欢喜，结果却是一事无成。</p>
<p>在决定哪些应该优先、哪些可以延缓这个问题上，最重要的并不是分析，而是拿出应有的勇气来。以下是几条可帮助确定优先次序的重要原则，每条都与勇气密切相关：</p>
<ul>
<li>重将来而不重过去</li>
<li>重视机会，不能只看到困难</li>
<li>选择自己的方向，而不盲从</li>
<li>目标要高，要有新意，不能只求安全和容易。</li>
</ul>
<h1 id="第六章_决策的要素"><a class="header-anchor" href="#第六章_决策的要素">#</a>第六章 决策的要素</h1>
<p>管理者在做出决策时通常并不需要花很多时间，但决策却是身为管理者特有的任务。所以，决策问题值得做特别的讨论。</p>
<p>管理者之所以为管理者，正是由于他拥有特殊的地位和知识，所以人们期望他能做出对整个组织、绩效和成果具有特殊影响的决策。因此，卓有成效的管理者，做的是有效的决策。</p>
<p>有效的管理者不做太多的决策。他们所做的，都是重大的决策。他们重视的，是分辨什么问题为例行性的，什么问题为战略性的，而不重视“解决问题”。</p>
<p>他们知道最棘手的决策，是正反两面折中的决策，他们能分辨正反两面的差异。他们知道在整个决策过程中，最费时的不是决策的本身，而是决策的推行。一项决策如果不能付诸行动，就称不上是真正的决策，最多只是一种良好的意愿。也就是说，有效的决策虽然是以高层次的理性认识为基础，但决策的推行却必须尽可能地接近工作层面，必须力求简单。</p>
<h2 id="有关决策的案例研究"><a class="header-anchor" href="#有关决策的案例研究">#</a>有关决策的案例研究</h2>
<p>他们解决问题，都着眼于最高层次的观念性的认识。他们先透彻地思考该决定的是什么，然后研究制定决策时应采用的原则。换句话说，他们的决策，不是为了适应当时的临时需要，而是战略性的考虑。所以，他们做了创新性的重大决策。</p>
<h2 id="决策的五个要素"><a class="header-anchor" href="#决策的五个要素">#</a>决策的五个要素</h2>
<p>决策的以下五点特征：</p>
<ol>
<li>要确实了解问题的性质，如果问题是经常性的，那就只能通过一项建立规则或原则的决策才能解决。</li>
<li>要确实找出解决问题时必须满足的界限，换言之，应找出问题的“边界条件”。</li>
<li>仔细思考解决问题的正确方案是什么以及这些方案必须满足哪些条件，然后再考虑必要的妥协、适应及让步事项，以期该决策能被接受。</li>
<li>决策方案要同时兼顾执行措施，让决策变成可以被贯彻的行动。</li>
<li>在执行的过程中重视反馈，以印证决策的正确性及有效性。</li>
</ol>
<h3 id="问题的经常性"><a class="header-anchor" href="#问题的经常性">#</a>问题的经常性</h3>
<p>有效的决策人常需花费不少时间来确定问题的属性。如果问题的属性判断错了，其决策必为错误的决策。我们常犯的错误，便是误将“经常问题”视为一连串的“偶发问题”。换言之，没有了解问题症结所在的基础，对问题缺乏经常性的认识与原则，其结果自然是失败与无效。</p>
<p>另一种常犯的错误，是误将真正的新问题视为旧病复发，因而仍旧应用旧原则。</p>
<p>第三种常见的错误，是对某些根本性问题的界定似是而非。</p>
<ul>
<li>自从第二次世界大战结束以来，美国军方常感到他们留不住高素质的医务人员。军方曾屡次研究这一问题，提出了不知多少建议。但是，所有的研究工作，都是以一项听来头头是道的假定为基础的——认为问题在于待遇不够，殊不知真正的原因在于军医的传统制度。美国的军医组织一向重视普通医师，然而今天的潮流已经是分科精细，重视专科医师了。照军方的系统，军医在人事晋升的阶梯上，只能转向行政方面，最后导致与医学研究相脱节。</li>
</ul>
<p>最后一种错误，是只看到问题的部分，而没有看清全貌。</p>
<ul>
<li>在所有肇事事件中，酒醉驾驶或极少数有“行车肇事倾向”的驾驶人员所引发的车祸，往往占车祸数的 3/4 左右；而这种车祸，确实不是驾驶学校所能负责，也不是公路不良所造成的。很久以来我们也知道，努力的重点，其实在于应针对那些非交通安全法规和训练所能控制的车祸。就是说，除了公路安全和驾驶训练，还得同时在技术方面设法，使得万一发生车祸，伤亡情况可以减轻。汽车制造业应该做的，是在技术方面不但使车辆在“正常驾驶”下能确保安全，而且在“不正常驾驶”下也能够提高车辆的安全性。但美国汽车制造业竟没有看到这一层。由上面这个例子，我们可以知道“一知半解”有时比“全然不知”更为可怕。凡属与交通安全有关的机构，包括汽车制造商、公路安全委员会、驾驶员协会以及保险公司等，都有一种误解，不敢承认车祸绝对不能避免，而以为凡有车祸即是因为忽略了安全。</li>
</ul>
<p>一位有效的决策者碰到问题，总是先假定该问题为“经常性质”。他总是先假定该问题是一种表面现象，另有根本性的问题存在。他要找出真正的问题，不会只满足于解决表面现象。</p>
<p>社会生活及政治生活中最显著的一项事实是：暂时性的事物往往具有永久性。这类的例子很多，比如英国的旅馆登记制、法国的房屋租赁管制以及美国政府中的许多“临时建筑”，都是在第一次世界大战时草草创设的。当时都以为最多三五个月就会取消，可是经过几十年，这些临时措施还是屹然不动。</p>
<ul>
<li>当然，这并不是说有效的管理者永远不会采用临时措施。不过，他会问自己：“如果这个临时办法被长期执行下去，我会愿意吗？”如果他的回答是否定的，他就会从更基本、更理性及更广泛的观念上去谋求解决之道。换言之，他会建立一项正确的原则。</li>
</ul>
<p>一位管理者如果天天要做决策，时时要做决策，那恰恰说明他是个疏懒和无效的人。</p>
<p>决策者也常常要留意是否有非常事件出现。他一定经常自问：“这一解释能说明某些事件吗？能说明所有同类的事件吗？”他一定经常想，这个问题的解答，可能引发什么结果？例如能否消除车祸？然后观察是否果然消除了车祸。最后，当出现了别的非常事件时，当出现了他的解答所不能解释的事件时，或者当发生的结果竟与预期不符时，他又回过头来重新检讨原来的问题。</p>
<h3 id="决策的边界"><a class="header-anchor" href="#决策的边界">#</a>决策的边界</h3>
<p>找出问题的“边界条件”，在于确实了解决策应遵循的规范。决策的目标是什么？换言之，最低限度应该达成什么目的？应该满足什么条件？用科学的术语来说，这就是所谓“边界条件”。一项有效的决策必须符合边界条件，必须足以达成目的。边界条件不够明确，则所做的决策不论看起来如何了不起，都肯定是一项无效的决策。探求边界条件的方法，是探求“解决某一问题应有什么最低需要”</p>
<p>有效的管理者明白，一项不符合边界条件的决策，肯定是无效和不适当的决策。不符合边界条件的决策，有时比一项符合“错误的边界条件”的决策更加误事。当然，不符合边界条件与符合错误的边界条件，两者都是错误的决策。不过，边界条件错了，还可能有修正的余地，决策仍可能成为有效的决策。如果根本与规范相反，那就难于补救了。</p>
<p>在各种不同的可能决策中要识别出哪项决策最危险（所谓最危险的决策，就是勉强可行的决策，即唯有在一切顺利的情况下，才可能达成的决策），也必须了解边界条件。几乎每一项这种决策都有其意义，但是当我们进一步探究其必须满足的规范时，便可能发现各项规范之间存在互相冲突的情况。这样的决策纵然不能说是不可能成功的，最多也只能说成功机会很小而已。若成功需寄望于奇迹，则问题不是奇迹出现的机会太小，而是我们不能依赖奇迹。</p>
<h3 id="正确的解决方案"><a class="header-anchor" href="#正确的解决方案">#</a>正确的解决方案</h3>
<p>决策是研究“正确”的决策是什么，而不是研究“能为人接受”的决策是什么。人总有采取折中办法的倾向，如果我们不知道符合规范及边界条件的“正确”决策是什么，就无法辨别正确的折中和错误的折中之间的区别，最终不免走到错误的折中的方向去。</p>
<p>所谓“折中”，实际上有两种。第一种“折中”，即俗语所谓“半片面包总比没有面包好”。第二种“折中”，则可用古代所罗门王审判两位妇人争夺婴儿的故事来说明：“与其要回半个死孩子，不如保全婴儿性命，将婴儿送与对方好。”第一种“折中”，仍能符合边界条件，因为面包本是为了充饥，半片面包仍然是面包。但是第二种“折中”，却完全不符合边界条件了：婴儿是一条生命，半个婴儿就没有生命可言，只是半个尸体了。</p>
<p>关于决策是否容易被他人接受的问题，如果老是要考虑决策如何才能被他人接受，又怕他人会反对，那就完全是浪费时间，不会有任何结果。世界上的事，你所担心的往往永不出现；而你从来没有担心的，却可能忽然间变成极大的阻碍。这就是说，如果你一开头就问：“什么是能让人接受的决策？”那你永远不会有结果。因为在你这样考虑时，通常总是不敢提出最重要的结论，所以你也得不到有效和正确的答案。</p>
<h3 id="决策的行动"><a class="header-anchor" href="#决策的行动">#</a>决策的行动</h3>
<p>决策的第四个要素，是化决策为行动。考虑边界条件，是决策过程中最难的一步；化决策为行动，则是最费时的一步。然而打从决策开始，我们就应该将行动的承诺纳入决策中，否则便是纸上谈兵。</p>
<p>事实上，一项决策如果没有列举详细具体的行动步骤，并指派为某人的工作和责任，那便不能算是一项决策，最多只是一种意愿。</p>
<p>过多的政策说明令人困扰，尤其是在企业机构里更是如此：决策中没有行动的承诺，没有指定何人负责执行。所以，组织的成员看到颁布的政策时，总不免是你看看我、我看看你，以为上级只不过是说说罢了。</p>
<p>若要化决策为行动，首先必须明确无误地回答下面几个问题：</p>
<ol>
<li>谁应该了解这项决策？</li>
<li>应该采取什么行动？</li>
<li>谁采取行动？</li>
<li>这些行动应如何进行，才能使执行的人能够执行？<br>
特别是第一个和最后一个问题，通常最容易被人忽略，以至于即使有了结果，也是灾难性的。</li>
</ol>
<p>为推行某一决策执行人员必须改变其行为习惯和态度时，化决策为行动更是最重要的考虑。在这种情况下，不但行动责任必须明确指定，执行人员必须确有能力，而且绩效的衡量及标准和有关激励的制度，也都需要配合改变。否则，工作人员就会困于情绪的冲突之中。</p>
<h2 id="决策的反馈"><a class="header-anchor" href="#决策的反馈">#</a>决策的反馈</h2>
<p>决策是人做的，人难免会犯错误。再了不起的决策，也不可能永远正确；即使是最有效的决策，总有一天也是会被淘汰的。</p>
<p>有了电脑，决策者和执行者之间的关系可能更加疏远。所以，如果管理者老坐在办公室，不到工作现场，他和实际情形必将越来越脱节。</p>
<h1 id="第七章_有效的决策"><a class="header-anchor" href="#第七章_有效的决策">#</a>第七章 有效的决策</h1>
<p>所谓选择，通常不是“对”与“错”间的选择，最多只是“大概是对的”与“也许是错的”之间的选择。而绝大多数的选择，都是任何一项方案均不一定优于其他方案时的选择。</p>
<p>有效的管理者都知道一项决策不是从搜集事实开始，而是先有自己的见解。这样做是正确的。因为凡在某一领域具有经验者，都应该有他的见解。假如说一个人在某一方面经验丰富，而竟然没有见解，那就说明此人没有敏锐的观察力，头脑迟钝。</p>
<p>人总是从自己的见解开始，所以要求决策者从搜集事实开始，是不符合实际的。其结果是，他像所有人一样，往往很容易不假思索地去寻找符合他自己心中结论的事实；他既然先有了结论，必能搜集到许多事实。干过统计工作的人都能体会到这一点，所以往往最不相信统计数字。统计工作人员也许知道提供数字者的立场，也许不知道提供数字者的立场，但是他知道数字的可疑。</p>
<p>因此唯一严谨的方法，唯一可以印证某一见解是否符合实际的方法，应该以明确承认“见解为先”作为基础——这是必要的做法。有了这样的认识，才能知道我们是以“尚待证实的假设”为起点——决策程序如此，科学研究也如此。我们都知道：假设是不必辩论的，却必须经得起验证。经得起验证的假设才值得我们重视，经不起验证者，就只有放弃了。</p>
<p>有效的决策人通常必先假定传统的衡量方法并非适当的衡量方法。否则，他就用不着做决策了，他只略做简单的调整就可以了。传统的衡量方法反映的是昨天的决策。我们之所以需要一项新决策，正表示过去的衡量方法已不适于今天了。</p>
<blockquote>
<p>自从朝鲜战争以来，美国军用物资的采购和库存政策一直不理想。军方也曾为这个问题绞尽脑汁，做过许多研究，但情况不但没有好转，反而每况愈下。直到麦克纳马拉出任国防部长，才向军需库存的传统衡量方法发起了挑战。在过去，军需物资的采购和库存，一直以物资项目的总项数和总金额为衡量的基础。麦克纳马拉一反此项传统，改用另一种衡量方法。他发现在所有军需物资中，有极少数的项目（也许只占总项数的 4%）是高价物资，它们的采购金额占采购总金额的 90%以上。同样地，他又发现有极少数的项目（大约也只占总项数的 4%）是重要物资，足以维持 90%的战备。在这两项物资（高价物资和战备物资）中，尚有部分重复者，所以合并起来，全部重要物资只不过占总项数的 5%或 6%而已。麦克纳马拉极力主张这类物资应予分别管理，严加管制。至于其余的 95%的物资，论金额不大，论重要性也不致对战备产生重大影响，他主张按照所谓“例外原则”来管理。麦克纳马拉这种一反过去传统的新衡量方法，立刻成为军需物资采购和库存的高度有效决策，也使整个后勤制度为之改观。<br>
汽车行业一向采用惯用的衡量方法，如“平均每行车公里交通事故件数”。如果他们能亲身查看，就会发现交通事故应该改以“人体伤残情况”来衡量。如果能这样做，他们就能知道这项“安全运动”的重点，该放在“一旦发生事故时如何使损伤减至最低”方面，也就是说，应该改良车辆的设计。</p>
</blockquote>
<p>说到判断，必须先有两项以上的方案，从其中选择一项。而且，如果说一项判断可以斩钉截铁地定其“对”与“错”，那也不称其为判断了。唯有在多项方案中，我们需凭借深入研究判断才能有所决定时，才称之为判断。因此，有效的管理者一定要求先有若干种不同的衡量方案，再自其中选取最适当的一种。</p>
<p>如果没有考虑每一个可能方案，就是偏颇。这也正说明了有效的决策者，为什么故意不遵循教科书原则。教科书上说，决策需寻求“意见的一致”，但是他们却有意“制造”互相冲突的不同意见。换句话说，管理者的决策不是从“众口一词”中得来的。好的决策，应以互相冲突的意见为基础，从不同的观点和不同的判断中选择。所以，除非有不同的见解，否则就不可能有决策。</p>
<h2 id="反对意见的运用"><a class="header-anchor" href="#反对意见的运用">#</a>反对意见的运用</h2>
<p>为什么该有反面意见，主要有三项理由：</p>
<ol>
<li>唯有反面意见，才能保护决策者不致沦为组织的俘虏。在一个组织中，所有人都必有求于决策者，每个人都各有所求，都希望主管的决策能对自己有利。唯一能突破这一陷阱，使决策者不致成为某方面的俘虏的办法，就在于引起争辩、掌握实据和经过深思熟虑的反面意见。</li>
<li>反面意见本身，正是决策所需的“另一方案”。决策时只有一种方案，别无其他选择，无论多么深思熟虑，那与赌博何异？如果在决策过程中原有若干方案可供选择，则决策者进可攻、退可守，有多方思考和比较的余地。反之，舍此以外别无他途，决策人在遇到该决策行不通的时候，就只有背水一战了。</li>
<li>反面意见可以激发想象力。不同意见，特别是那些经过缜密推断和反复思考的、论据充分的不同意见，便是激发想象力的最为有效的因素。</li>
</ol>
<p>有效的管理者会运用反面意见。只有这样，他才能避免为“似是而非”的看法所征服；他才能得到“替代方案”，以供他选择和决定；他也才能在万一决策行不通时不至于迷惘。同时，鼓励反面意见，可以启发他本人的想象力，启发与他共事者的想象力。</p>
<p>反面意见能把“言之有理”者转化为“正确”，再把“正确”转化为“良好的决策”。</p>
<p>有效的管理者知道世上有蠢才，也有恶作剧的人。但是，他绝不会将持不同意见者轻易地视为蠢才或捣蛋者，他总是假定任何人提出不同的意见，必是出于至诚。某人的意见纵然错了，也是由于此人所看到的现实不同，或他所关切的是另一个不同的问题。因此，有效的管理者会问：“如果此人的立场果真正当、果真合理、果真有见地的话，此人的看法又将如何呢？”有效的管理者关切的是“理解”。只有在有了确切的理解之后，他才研究谁是谁非。</p>
<p>身为管理者，不论他本身刻意求好之心如何迫切，也不论他如何自信看出了别人的错误，只要他打算做一项正确的决策，就会将了解“对方”作为他探求“另一方案”的方法。见解的冲突正是他的“工具”，运用这项“工具”，他才能保证自己看清问题的每一面。</p>
<p>做一项决策像动一次外科手术。任何新的决策都不免影响既有的制度，因此多少得冒风险。外科医师不到非动手术不可的时候绝不轻言开刀；同样地，不到非做决策的时候，也不宜轻易做出决策。什么时候需要决策？如果继续保守成规，情况就会恶化，那就必须做出新的决策。遇有新的机会来临，而且这个新的机会至关重要、稍纵即逝的时候，也必须立刻做出新的决策。</p>
<p>决策的反面是不做任何决策。有时候不做任何改变，事情也不会出问题。我们问：“保持现状，会有什么后果？”如果答案是：“不会有变化。”那我们又何必横生枝节？即使问题颇为恼人，但问题并不重要，也不致有什么严重后果，那我们也没有改变的必要。2000 年前罗马律法就曾说过：“行政长官不宜考虑鸡毛蒜皮之类的事情。”直到今天，我们的决策者还是需要好好学习这句话。</p>
<p>有效的管理者会做比较：做了新决策，可能有什么收获和风险；不做又可能有什么损失。至于如何比较，通常没有一定的公式。但是，实际上只要遵循下面两项原则就够了：</p>
<ul>
<li>如果利益远大于成本及风险，就该行动；</li>
<li>行动或不行动，切忌只做一半或折中。</li>
</ul>
<p>一切条件具备，现在就只等着决策了。规范已经清楚了，不同方案已经想到了，得失也衡量了。一切都已经一目了然，应该采取什么行动，也已经清清楚楚。该采取什么决策，已是明摆着的了。不幸的是，绝大多数决策是在此时流产的。决策者这才“恍然大悟”，原来决策那么难受，那么不受欢迎，那么不容易。到了这一步，不但需要判断，更需要勇气。到了这一步，有效的管理者绝不会说：“让我们再研究研究！”那只证明这位管理者缺乏胆识。没有胆识的人可能失败一千次，有胆识的人则只失败一次。面对“再研究研究”的呼声，卓有成效的管理者会问：“是不是再做一次研究就能讨论出新方案来？即使研究出新的方案，它是不是一定比现有的方案好？”如果答案是否定的，那么管理者就不需要再去做任何研究，他绝不会因为自己的优柔寡断再去浪费别人的时间。</p>
<p>组织雇用管理者并不是要他去做他自己喜欢做的事。管理者的责任是要把该做的事做好，具体地说，就是要进行有效的决策。</p>
]]></content>
      <tags>
        <tag>摘抄</tag>
        <tag>管理</tag>
      </tags>
  </entry>
  <entry>
    <title>《Unix 编程艺术》 第二章 历史</title>
    <url>/di_2_zhang_li_shi%E2%80%94%E2%80%94shuang_liu_ji/</url>
    <content><![CDATA[<h1 id="2_1_Unix_起源于历史，1969_1995"><a class="header-anchor" href="#2_1_Unix_起源于历史，1969_1995">#</a>2.1 Unix 起源于历史，1969-1995</h1>
<p>小型实验原型系统的后继产品往往备受令人讨厌的“第二版效应”折磨。由于迫切希望把所有首次开发时遗漏的功能都添加进去，往往导致设计十分庞大、过于复杂。其实，还有一个因不常遇到而鲜为人知的“第三版效应”：有时候，在第二系统不堪自身重负而崩溃之后，有可能返璞归真，走上正道。</p>
]]></content>
      <tags>
        <tag>编码规范</tag>
        <tag>系统设计</tag>
      </tags>
  </entry>
  <entry>
    <title>《Unix 编程艺术》 第三章 对比</title>
    <url>/di_3_zhang_dui_bi%EF%BC%9Aunix_zhe_xue_tong_qi_ta_zhe_xue_de_bi_jiao/</url>
    <content><![CDATA[<h1 id="3_1_操作系统的风格元素"><a class="header-anchor" href="#3_1_操作系统的风格元素">#</a>3.1 操作系统的风格元素</h1>
<h2 id="3_1_1_什么是操作系统的统一性理念"><a class="header-anchor" href="#3_1_1_什么是操作系统的统一性理念">#</a>3.1.1 什么是操作系统的统一性理念</h2>
<p>Unix 有几个统一性的理念或象征，并塑造了它的 API 及由此形成的开发风格。其中最重要的一点应当是“一切皆文件”模型及在此基础上建立的管道概念”。</p>
<p>彻头彻尾的反 Unix 系统，就是没有任何统一性理念，胡乱堆砌起的一些唬人特性而已。</p>
<h2 id="3_1_2_多任务能力"><a class="header-anchor" href="#3_1_2_多任务能力">#</a>3.1.2 多任务能力</h2>
<p>Unix 系统拥有抢先式多任务（preemptive multitasking）能力。在 Unix 中，时间片由调度程序来分配，这个调度程序定期中断或抢断正在运行的进程而把控制权交给下一个进程。几乎所有的现代操作系统都支持抢占式调度。</p>
<p>彻头彻尾的反 Unix 系统，就是绝无多任务处理能力一一或者通过对进程管理增设诸多的规定、限制和特殊情况来削弱多任务能力的一个废物。</p>
<h2 id="3_1_3_协作进程"><a class="header-anchor" href="#3_1_3_协作进程">#</a>3.1.3 协作进程</h2>
<p>在 Unix 中，低价的进程生成和简便的 <code>进程间通讯（IPC,Inter-Process Communication）</code> 使众多小工具、管道和过滤器组成一个均衡系统成为可能。</p>
<p>如果操作系统的进程生成代价昂贵，且/或进程控制非常困难、不灵活，后果通常是：</p>
<ul>
<li>编写怪物般巨大的单个程序成为更自然的编程方式。</li>
<li>很多策略必须在这些庞大程序中表述。</li>
<li>当进程间不得不进行通讯时，要么只能采用笨拙、低效、不安全的机制（比如临时文件），要么就得依赖太多彼此的实现细节，要么彼此需了解对方的太多实现细节。</li>
<li>广泛使用多线程来完成某些任务，而这些任务 Uiⅸ 只需用互通的多进程就能处理。</li>
<li>必须学习和使用异步 IO。</li>
</ul>
<p>一个操作系统，如果没有灵活的 IPC 和使用 IPC 的强大传统，程序间就得通过共享结构复杂的数据实现通讯。由于一旦有新的程序加入通讯圈，圈子里所有程序的通讯问题都必须重新解决，所以解决方案的复杂度与协作程序数量的平方成正比。更糟糕的是，其中任何一个程序的数据结构发生变化，都说不定会给其它程序带来什么隐蔽的 bug。</p>
<p>彻头彻尾的反 Unix 系统，就是让进程的生成代价高昂，让进程的控制因难而死板，让 IPC 可有可无，对它不予支持或支持很少。</p>
<h2 id="3_1_4_内部边界"><a class="header-anchor" href="#3_1_4_内部边界">#</a>3.1.4 内部边界</h2>
<p>Unix 至少设立了三层内部边界来防范恶意用户或有缺陷的程序：</p>
<ol>
<li>第一层是内存管理：Unix 用硬件自身的 <code>内存管理单元(MMU)</code> 来保证各自的进程不会侵入到其它进程的内存地址空间。</li>
<li>第二层是为多用户设置的真正权限组——普通用户（非 Root 用户）的进程未经允许，就不能更改或者读取其他用户的文件。</li>
<li>第三层是把涉及关键安全性的功能限制在尽可能小的可信代码块上 。在 Unix 中，即使是 shell（系统命令解释器）也不是什么特权程序。</li>
</ol>
<h2 id="3_1_5_文件属性和记录结构"><a class="header-anchor" href="#3_1_5_文件属性和记录结构">#</a>3.1.5 文件属性和记录结构</h2>
<p>Unix 文件既没有记录结构也没有文件属性。</p>
<p>对文件属性的操作系统支持会诱导程序员使用不透明的文件格式，让他们依靠文件属性将文件格式对应的解读程序绑在一起。</p>
<h2 id="3_1_6_二进制文件格式"><a class="header-anchor" href="#3_1_6_二进制文件格式">#</a>3.1.6 二进制文件格式</h2>
<p>彻头彻尾的反 Unix 系统，让所有文件格式都采用不透明的二进制格式，后者要用重量级的工具才能读取和编辑。</p>
<h2 id="3_1_7_首选用户界面风格"><a class="header-anchor" href="#3_1_7_首选用户界面风格">#</a>3.1.7 首选用户界面风格</h2>
<p>如果操作系统的 CLI 功能很弱或根本不存在，其后果会是：</p>
<ul>
<li>程序设计不会考虑以未预料到的方式相互协作——因为无法这样设计。输出不能用作输入。</li>
<li>远程系统管理更难于实现，更难以使用，更强调网络。</li>
<li>即便简单的非交互程序也将招致 GUI 开销或复杂的脚本接口。</li>
<li>服务器、守护程序和后台进程几乎无法写出，至少很难以优雅的方式写出。</li>
</ul>
<p>彻头彻尾的反 Unix 系统，就是没有 CLI，没有脚本编程能力或者，存在 CLI 不能驱动的重要功能。</p>
<h2 id="3_1_8_目标受众"><a class="header-anchor" href="#3_1_8_目标受众">#</a>3.1.8 目标受众</h2>
<p>“客户端”可以理解为：轻量，只支持单个用户，能够在小型机器上运行，随需开关机器，没有抢先式多任务处理，为低延迟作了优化，大量资源都用在花哨的用户界面上。</p>
<p>“服务器”可以解释为：重量，能够连续运行，为吞吐量优化，完全抢占式多任务处理以处理多重会话。所有的操作系统最初都是服务器操作系统。</p>
<p>客户端操作系统更关注用户的视觉体验，而不是 7*24 小时的连续正常运行。</p>
<p>彻头彻尾的反 Unix 系统，就是一个自认为比你自己更懂你在干什么的操作系统，然后雪上加霜的是，它还做错了。</p>
<h2 id="3_1_9_开发的门坎"><a class="header-anchor" href="#3_1_9_开发的门坎">#</a>3.1.9 开发的门坎</h2>
<p>区分操作系统的另一个重要尺度就是纯用户转变为开发者的门坎高度。这里有两个重要的成本：一是开发工具的金钱成本，另一个是成为一个熟练开发者的时间成本。</p>
<h1 id="3_2_操作系统的比较"><a class="header-anchor" href="#3_2_操作系统的比较">#</a>3.2 操作系统的比较</h1>
<h2 id="3_2_2_MacOS"><a class="header-anchor" href="#3_2_2_MacOS">#</a>3.2.2 MacOS</h2>
<p>MacOS 有一个不同于 Unix 的坚定统一性理念：Mac 界面方针（the Mac InterfaceGuidelines）。</p>
<p>这些方针非常详细地说明了应用程序 GUI 的表现形式和行为模式。这些原则的一致性在很多重要方面影响了 Mac 用户的文化。</p>
<p>这些方针的主旨是：东西永远呆在你摆的地方。文档、目录和其它东西在桌面上都有固定的、系统不会弄乱的位置，重启后桌面依然保持原样。</p>
<h2 id="3_2_4_Windows_NT"><a class="header-anchor" href="#3_2_4_Windows_NT">#</a>3.2.4 Windows NT</h2>
<p>Windows NT(New Technology) 是微软为高端个人用户和服务器设计的操作系统；Windows XP 是 5.1.</p>
<p>NT 是逐步堆积而成的，缺乏对应于 Unix “一切皆文件” 或 MacOS 左面的统一性理念。</p>
<p>Unix 的系统配置和用户配置数据分散存放在众多的 dotfiles (名字以“.”开头的文件) 和系统数据文件中，而 NT 则集中存放在注册表中。以下后果贯穿于设计中：</p>
<ul>
<li>注册表使得整个系统完全不具备正交性。应用程序的单点故障就会损毁注册表，经常使得整个操作系统无法使用、必须重装。</li>
<li>注册表蠕变 (registry creep) 现象：随着注册表的膨胀，越来越大的存取开销拖慢了所有程序的运行。</li>
</ul>
<h2 id="3_2_8_Linux"><a class="header-anchor" href="#3_2_8_Linux">#</a>3.2.8 Linux</h2>
<p>Linux 并不含任何来自原始 Unix 源码树的代码，但却是一个按照 Unix 标准设计、行为像 Unix 的操作系统。</p>
<p>包容竞争者的目标加上贴近终端用户的动力，促使 Linux 开发者广泛吸收非 Unix 操作系统的设计理念，甚至到了使传统 Unix 显得十分孤立的地步。</p>
]]></content>
      <tags>
        <tag>编码规范</tag>
        <tag>系统设计</tag>
      </tags>
  </entry>
</search>
