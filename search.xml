<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>《3D数学基础：图形和游戏开发》第三章笔记</title>
    <url>/3DMathPrimerForGraphicsAGameDevelopment-Chapter3-Notes/</url>
    <content><![CDATA[<p>《3D数学基础：图形和游戏开发》第三章笔记</p>
<p>3.1节没什么关键信息。<br>3.2节介绍了世界坐标系，物体坐标系，摄像机坐标系，以及作者自己引入的直立坐标系。<br>3.3节介绍了坐标系转换时从移动物体出发和从移动坐标系出发的两种思考角度，还讨论了基本向量的选择问题。<br>3.4节讨论了嵌套坐标系存在的目的。<br>3.5节讨论了作者引入直立坐标系的初衷。</p>
<span id="more"></span>
<h1 id="Chapter3-Multiple-Coordinate-Spaces"><a href="#Chapter3-Multiple-Coordinate-Spaces" class="headerlink" title="Chapter3 Multiple Coordinate Spaces"></a>Chapter3 Multiple Coordinate Spaces</h1><h2 id="Why-Bother-with-Multiple-Coordinate-Spaces"><a href="#Why-Bother-with-Multiple-Coordinate-Spaces" class="headerlink" title="Why Bother with Multiple Coordinate Spaces?"></a>Why Bother with Multiple Coordinate Spaces?</h2><p>没什么关键信息</p>
<h2 id="Some-Useful-Coordinate-Spaces"><a href="#Some-Useful-Coordinate-Spaces" class="headerlink" title="Some Useful Coordinate Spaces"></a>Some Useful Coordinate Spaces</h2><p>之所以需要不同的坐标系，是因为一些信息仅在某些坐标系下是有意义的，或者只能在某坐标系下获得（或更容易得到）。</p>
<h3 id="World-Spaces"><a href="#World-Spaces" class="headerlink" title="World Spaces"></a>World Spaces</h3><p>世界坐标系（World Spaces）是作为一个全局的存在，所有的其他坐标系都属于这个坐标系下。世界坐标系是需要关系的最大坐标系（类似于全集的概念）。</p>
<p>在不同的情况下，会有不同的世界坐标。</p>
<p>世界坐标系也被称为全局坐标系(Global coordinate space)或者统一坐标系（Universal coordinate space）。</p>
<h3 id="Object-Space"><a href="#Object-Space" class="headerlink" title="Object Space"></a>Object Space</h3><p>物体坐标系（Object Space）是属于每一个物体的，即每个物体都有自己的物体坐标系，当这个物体移动时，物体坐标系也相应移动。</p>
<p>“向右转”就是物体坐标系的概念，而“向东走”就是全局坐标系的概念。</p>
<p>在图形学中，物体坐标系也被称为模型坐标系（Model Space），模型的顶点信息就描述在该物体的模型坐标系下。</p>
<h3 id="Camera-Space"><a href="#Camera-Space" class="headerlink" title="Camera Space"></a>Camera Space</h3><p>物体坐标系的一个重要特例就是摄像机坐标系（Camera Space），摄像机坐标系是关于用于渲染的视角的坐标系。</p>
<p>在摄像机坐标系下，$+X$轴指向右侧，$+Z$轴指向前方，$+Y$指向上方（注意本书采用的是左手坐标系，OpenGL采用的是右手坐标系）。</p>
<p>摄像机坐标系如下图所示：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter3-Notes/2020-02-29-16-32-03.png" alt="摄像机坐标系"></p>
<h3 id="Upright-Space"><a href="#Upright-Space" class="headerlink" title="Upright Space"></a>Upright Space</h3><p>直立坐标系（Upright space）是这本书中提出的概念，是作为世界坐标和物体坐标转化过程中的中间变量存在，如下图所示：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter3-Notes/2020-02-29-16-33-49.png" alt="直立坐标系"></p>
<p>直立坐标系的原点与物体坐标系相同，直立坐标系的方向与世界坐标系相同。下图为物体坐标系与世界坐标系经过直立坐标系转换的步骤：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter3-Notes/2020-02-29-16-36-39.png" alt="坐标系转换"></p>
<h2 id="Basis-Vectors-and-Coordinate-Space-Transformations"><a href="#Basis-Vectors-and-Coordinate-Space-Transformations" class="headerlink" title="Basis Vectors and Coordinate Space Transformations"></a>Basis Vectors and Coordinate Space Transformations</h2><p>将一个坐标系下的坐标转换为另一个坐标系下的坐标称为坐标系转换（coordinate space transformation）。</p>
<h3 id="Dual-Perspectives"><a href="#Dual-Perspectives" class="headerlink" title="Dual Perspectives"></a>Dual Perspectives</h3><p>坐标系转换可以从两个角度来考虑：</p>
<ol>
<li>主动转换（Active Transformation）：两个坐标系保持不动，物体的坐标进行转换</li>
<li>被动转换（Pasison Transformation）：物体保持不动，坐标系进行转换</li>
</ol>
<p>只需要注意的是，在从两个角度思考时，位移的方向是不同的。如上图从世界坐标转换到直立坐标系的过程，如果思考角度是移动物体，那么物体是向左下移动，到了原点；如果是从移动坐标系角度考虑，坐标系是向右上移动，到了原点。</p>
<p>另一点是，在进行旋转操作时，要保证物体处于当前坐标系的原点，因为一个坐标系下的旋转操作都是基于该坐标系的原点的。</p>
<p>所以在上图中，当从世界坐标系转换到本地坐标系时，会先移动转换到直立坐标系，因为前者坐标系物体不在原点，而后者在。同理在从本地坐标系转换到世界坐标系时，会先进行旋转，因为此时物体已经在原点了。</p>
<h3 id="Specifying-Coordinate-Spaces"><a href="#Specifying-Coordinate-Spaces" class="headerlink" title="Specifying Coordinate Spaces"></a>Specifying Coordinate Spaces</h3><p>坐标系是由原点和坐标轴两部分决定的，坐标轴是相对与自己原点而言的“上”，“右”，“前”。</p>
<p>一个坐标系的原点和坐标轴是相对于另一个坐标系的。</p>
<p>如在展示三个坐标系的上图中，如果说机器人的高度是5.5。那么直立坐标系的原点在世界坐标系中的位置大约在$(4.5,1.5)$，而物体坐标系中的$(1,0)$点，在直立坐标系下大约是$(0.87,0.5)$，物体坐标系中的$(0,1)$点，在直立坐标系下大约是$(-0.5,0.87)$。在直立坐标系中，向量$(0.87,0.5)$的角度大约是30°，因此两个坐标系的原点位置差距为$(4.5,1.5)$，角度差距在30°。</p>
<h3 id="Basis-Vectors"><a href="#Basis-Vectors" class="headerlink" title="Basis Vectors"></a>Basis Vectors</h3><p>如果在物体坐标系下一个点的位置是$(-1,5)$，那么它在世界坐标系下的位置可以按以下公式进行计算：</p>
<script type="math/tex; mode=display">
w=o+b_xp+b_yq</script><p>其中$b$为点在物体坐标系下的位置，即$(-1,5)$，$w$为点在世界坐标系下的位置，$o$为物体坐标系的原点在世界坐标系中的位置，在上例中为$(4.5,1.5)$，$p$为物体坐标系X轴在世界坐标系中的表示，在上例中为$(0.87,0.5)$，$q$为物体坐标系Y轴在世界坐标系中的表示，在上例中为$(-0.5,0.87)$。</p>
<p>将所有数据带入上式，可以算出该点在世界坐标系下的坐标为$(-1.13,5.35)$。计算如下：</p>
<script type="math/tex; mode=display">
w=(4.5,1.5)+(-1)*(0.87,0.5)+5*(-0.5,0.87)=(-1.13,5.35)</script><p>可以将上述公式简化，即不再将“点”作为考虑的对象，而是描述向量。因为是向量所以也就不需要考虑位移。如果上述公式不考虑位移（可以假象为两个坐标系的原点是重叠的），且推广至三维空间，可表示为：</p>
<script type="math/tex; mode=display">
v=xp+yq+zr</script><p>式中的$v$是目标坐标系下的坐标，$x,y,z$是当前坐标系下的选取的三条基本向量上的分量，$p,q,r$为三条基本向量在目标坐标系$v$上的表示。</p>
<p>如上例中，因为是二维空间，只有两条基本向量，选取的分别是X轴和Y轴，对应的P为$(0.87,0.5)$，对应的q为$(-0.5，0.87)$。</p>
<p>如有物体坐标系下的向量$b=[b_x,b_y,b_z]$，对应世界坐标系下的向量$u=[u_x,u_y,u_z]$，$p,q,r$为物体坐标系下选取的三条基本向量在世界坐标系下的表示。套用上述的公式，可表示为</p>
<script type="math/tex; mode=display">
u=b_xp+b_yq+b_zr \text{ 或者表达为 } \begin{aligned}
    u_x=b_xp_x+b_yq_x+b_zr_x\\\\
    u_y=b_xp_y+b_yq_y+b_zr_y\\\\
    u_z=b_xp_z+b_yq_z+b_zr_z\\\\
\end{aligned}</script><blockquote>
<p>注意$p,q,r$三个向量实际上都是在世界坐标系下的表示，即$u,p,q,r$是属于一个坐标系下。</p>
</blockquote>
<p>如果知道了向量$b$，求向量$u$只需要套用公式即可。但如果知道了向量$u$想求向量$b$，则需要解一个三元方程（$b_x,b_y,b_z$都是未知量）。</p>
<p>如果一系列向量满足，<code>向量互相垂直，即正交（orthogonal）</code>和<code>向量的长度都为1</code>，则称这些向量为标准正交基（orthonormal），如果基本向量是标准正交基，则求$b$的过程可以从解三元方程简化为以下公式：</p>
<script type="math/tex; mode=display">
b_x=u\cdot p
\\\\
b_y=u\cdot q
\\\\
b_z = u\cdot r</script><p>之所以可以这样简化，是因为：</p>
<ol>
<li>点乘的物理意义有求在某个分量上的长度，所以可以通过点乘来计算。</li>
<li>如果三条基本向量不是相互垂直的，那么在一条基本向量上值增加，会导致另一条基本向量上的值也增加。<br>如基本向量选取为$(1,0)$和$(1,1)$，如果点从$(1,1)$位移到$(2,2)$点上，虽然是在基本向量$(1,1)$上移动的，但同样会增加在$(1,0)$上的值。<br>这样的话在上述公式中，则会出现$b_x$的值不仅与$p$有关，还可能与$q$有关。</li>
<li>$a\cdot b$的结果还与$b$的长度有关，为了避免这个影响，所以取$p,q,r$都为1</li>
</ol>
<blockquote>
<p>选取的基本向量通常都需要是线性无关的（Linearly Independent），即任意一个向量不能通过其他向量的线性组合表示出来。否则的话，n个向量无法描述n维空间中的所有向量，在线性代数中，将通过基本向量能表述的空间维度称为<code>秩(rank)</code></p>
</blockquote>
<p>对于基本向量不是标准正交基的情况，将在第六章中说明。</p>
<p>通常而言，对于三维空间而言，基本向量的选取都是X,Y,Z轴。</p>
<h2 id="Nested-Coordinate-Spaces"><a href="#Nested-Coordinate-Spaces" class="headerlink" title="Nested Coordinate Spaces"></a>Nested Coordinate Spaces</h2><p>因为通常而言，物体坐标系最后都要基于世界坐标系进行计算，如把不同的物体放在世界中的过程。</p>
<p>因此可以称世界坐标系是父空间，物体坐标系是子空间。</p>
<p>而物体坐标系可以进一步划分，如将一只羊作为物体坐标系，可以再进一步将其头作为物体坐标系的子坐标系，称为头坐标系。同理头坐标系下还可以耳朵坐标系等。</p>
<p>这种将不同部分层层划分的模型称为关节模型（articulated model）。</p>
<p>一些运动在各自的坐标系下计算是很简单的，但是放在世界坐标系下将会很复杂。如羊一边走，一边摇头，一边上下翻动耳朵。对于耳朵坐标系而言，这只是Y轴的变化，但是对于世界坐标系而言，就是耳朵的运动轨迹就非常复杂了。</p>
<p>当知道了物体在一个子坐标系下的位置，可以通过坐标系之间的相对位置来进行转换。这部分会在之后章节详细说明。</p>
<h2 id="In-Defense-of-Upright-Space"><a href="#In-Defense-of-Upright-Space" class="headerlink" title="In Defense of Upright Space"></a>In Defense of Upright Space</h2><p>当将点从物体坐标系转换到世界坐标系时，不仅需要进行旋转操作，还需要进行位移操作。</p>
<p>当将向量从物体坐标系转换到世界坐标系时，仅需要旋转操作。</p>
<p>但物体和点在代码中通常都是用同一个类型来表示的，如<code>flaot3</code>。因此需要一个方法来区分操作究竟是针对点还是向量，有的人将<code>flaot3</code>取别名，如变成<code>point</code>和<code>vector</code>，有的人则是通过计算过程，如将旋转操作和位移操作分开，在处理点的时候，使用位移操作。</p>
<p>作者在这里提出的直立坐标系（Upright Space）则是另一种表达，设想是，当使用世界坐标系时，则表示这个操作是需要进行位移的，而使用直立坐标系时，则是不需要位移。</p>
<div class="note info simple"><p>引用：</p>
<ol>
<li><em>3D Math Primer for Graphics and Game Development</em> 2nd 2011 </li>
</ol>
</div>
<hr>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>3D数学</tag>
      </tags>
  </entry>
  <entry>
    <title>《3D数学基础：图形和游戏开发》第二章笔记</title>
    <url>/3DMathPrimerForGraphicsAGameDevelopment-Chapter2-Notes/</url>
    <content><![CDATA[<p>《3D数学基础：图形和游戏开发》第二章笔记。</p>
<p>介绍了向量的数学计算以及对应的几何意义，在每一节的第一部分是数学计算，第二部分是几何意义。</p>
<span id="more"></span>
<h1 id="Chapter-2"><a href="#Chapter-2" class="headerlink" title="Chapter 2"></a>Chapter 2</h1><h2 id="Mathematical-Definition-of-Vector-and-Other-Boring-Stuff"><a href="#Mathematical-Definition-of-Vector-and-Other-Boring-Stuff" class="headerlink" title="Mathematical Definition of Vector, and Other Boring Stuff"></a>Mathematical Definition of Vector, and Other Boring Stuff</h2><p>从数学角度看，向量（Vector）只是一个数字的数组。<br>数学上会区分向量和标量，带有方向的为向量，不带方向的为标量，如速度（有朝着某方向的含义在）是向量，位移是向量，而速率（仅仅是一个数字）是标量，距离是标量。</p>
<p>向量的维度表示一个向量中含有多少个数字。</p>
<p>向量通常通过方括号包裹，如果向量是水平方向的写，称其为行向量，否则为列向量，如：</p>
<p>行向量：</p>
<script type="math/tex; mode=display">
[1,2,3]</script><p>列向量：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
1 \\\\
2 \\\\
3
\end{bmatrix}</script><div class="note info simple"><p>在这本书中：</p>
<ol>
<li>标量用小写斜体表示：<em>a,b,x,y</em></li>
<li>向量用小写粗体表示：<strong>a,b,u,v</strong></li>
<li>矩阵用大写粗体表示：<strong>A,B,M,R</strong></li>
</ol>
</div>
<p>研究向量和矩阵的数学称为线性代数（linear algebra）。在线性代数中，$n$维度的向量和矩阵是用来求解有$n$个未知数的方程的。而在这本书中解释了向量和与矩阵的几何与几何意义。</p>
<h2 id="Geometric-Definition-of-Vector"><a href="#Geometric-Definition-of-Vector" class="headerlink" title="Geometric Definition of Vector"></a>Geometric Definition of Vector</h2><p>从几何角度来说，向量是一条既有大小又有方向的线（有向线）。</p>
<p>向量并没有位置信息，大小和方向一致的向量出现在图中的什么位置并没有区别。</p>
<h2 id="Specifying-Vectors-with-Cartesian-Coordinates"><a href="#Specifying-Vectors-with-Cartesian-Coordinates" class="headerlink" title="Specifying Vectors with Cartesian Coordinates"></a>Specifying Vectors with Cartesian Coordinates</h2><h3 id="Vector-as-a-Sequence-of-Displacements"><a href="#Vector-as-a-Sequence-of-Displacements" class="headerlink" title="Vector as a Sequence of Displacements"></a>Vector as a Sequence of Displacements</h3><p>当向量出现在笛卡尔坐标系中，向量中的每个元素表示对应的坐标的位移。</p>
<p>如$[2,3]$表示X轴方向移动了2，y轴方向移动了3，位移的顺序并没有关系。</p>
<h3 id="The-Zero-Vector"><a href="#The-Zero-Vector" class="headerlink" title="The Zero Vector"></a>The Zero Vector</h3><p>零向量是唯一一个没有方向的向量，在坐标系中，零向量不是一根线，而是一个点。</p>
<p>零向量是作为加法单位元（additive identity，加到别的元素上也不会造成区别的数字）。</p>
<h2 id="Vectors-versus-Points"><a href="#Vectors-versus-Points" class="headerlink" title="Vectors versus Points"></a>Vectors versus Points</h2><p>点（Points）表示位置，向量（Vectos）表示位移。</p>
<h3 id="Relative-Position"><a href="#Relative-Position" class="headerlink" title="Relative Position"></a>Relative Position</h3><p>没什么关键信息。</p>
<h3 id="The-Relationship-between-Points-and-Vectors"><a href="#The-Relationship-between-Points-and-Vectors" class="headerlink" title="The Relationship between Points and Vectors"></a>The Relationship between Points and Vectors</h3><ul>
<li>所有关于位置的方法，都是相对的</li>
</ul>
<p>向量$[x,y]$表示从原点到点$(x，y)$的位移。</p>
<p>点是位置，图像上表示为一个点。向量是位移，图像上表示为一个箭头。</p>
<h3 id="It’s-All-Relative"><a href="#It’s-All-Relative" class="headerlink" title="It’s All Relative"></a>It’s All Relative</h3><p>非图形学相关内容，作者描述了世上其他的相对物体。</p>
<h2 id="Negating-a-Vector"><a href="#Negating-a-Vector" class="headerlink" title="Negating a Vector"></a>Negating a Vector</h2><p>向量求反（Vector negating）：对于每个向量，都有一个相同维度的反向量，满足$v+(-v)=0$。</p>
<h3 id="Offical-Linear-Algebra-Rules"><a href="#Offical-Linear-Algebra-Rules" class="headerlink" title="Offical Linear Algebra Rules"></a>Offical Linear Algebra Rules</h3><p>向量求反：</p>
<script type="math/tex; mode=display">
-\begin{bmatrix}
    a_1 \\\\
    a_2 \\\\
    \vdots \\\\
    a_{n-1} \\\\
    a_n \\\\
\end{bmatrix}=
\begin{bmatrix}
    -a_1 \\\\
    -a_2 \\\\
    \vdots \\\\
    -a_{n-1} \\\\
    -a_n \\\\
\end{bmatrix}</script><h3 id="Geometric-Interpretation"><a href="#Geometric-Interpretation" class="headerlink" title="Geometric Interpretation"></a>Geometric Interpretation</h3><p>向量求反几何意义：保持向量的大小，但是方向变反方向</p>
<h3 id="Vector-Multiplication-by-a-Scalar"><a href="#Vector-Multiplication-by-a-Scalar" class="headerlink" title="Vector Multiplication by a Scalar"></a>Vector Multiplication by a Scalar</h3><p>向量与标量相乘：</p>
<script type="math/tex; mode=display">
k\begin{bmatrix}
    a_1 \\\\
    a_2 \\\\
    \vdots \\\\
    a_{n-1} \\\\
    a_n \\\\
\end{bmatrix}=
\begin{bmatrix}
    a_1 \\\\
    a_2 \\\\
    \vdots \\\\
    a_{n-1} \\\\
    a_n \\\\
\end{bmatrix}k=
\begin{bmatrix}
    ka_1 \\\\
    ka_2 \\\\
    \vdots \\\\
    ka_{n-1} \\\\
    ka_n \\\\
\end{bmatrix}</script><ul>
<li>向量与标量相乘，标量可以写在向量的左侧也可以写在右侧，但通常而言习惯性写在右侧</li>
<li>向量与标量相乘时不需要写乘号</li>
<li>标量不能被相乘除，向量不能除以另一个向量。</li>
</ul>
<h3 id="Geometric-Interpretation-1"><a href="#Geometric-Interpretation-1" class="headerlink" title="Geometric Interpretation"></a>Geometric Interpretation</h3><p>向量与标量相乘几何意义：大小乘以$|k|$，如果$k$是负数，则向量的方向取反，否则不变。</p>
<h2 id="Vector-Addition-and-Subtraction"><a href="#Vector-Addition-and-Subtraction" class="headerlink" title="Vector Addition and Subtraction"></a>Vector Addition and Subtraction</h2><h3 id="Official-Linear-Algebra-Rules"><a href="#Official-Linear-Algebra-Rules" class="headerlink" title="Official Linear Algebra Rules"></a>Official Linear Algebra Rules</h3><p>向量相加：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
    a_1 \\\\
    a_2 \\\\
    \vdots \\\\
    a_{n-1} \\\\
    a_n \\\\
\end{bmatrix}+
\begin{bmatrix}
    b_1 \\\\
    b_2 \\\\
    \vdots \\\\
    b_{n-1} \\\\
    b_n \\\\
\end{bmatrix}=
\begin{bmatrix}
    a_1+b_1 \\\\
    a_2+b_2 \\\\
    \vdots \\\\
    a_{n-1}+b_{n-1} \\\\
    a_n+b_n \\\\
\end{bmatrix}</script><p>向量相减：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
    a_1 \\\\
    a_2 \\\\
    \vdots \\\\
    a_{n-1} \\\\
    a_n \\\\
\end{bmatrix}-
\begin{bmatrix}
    b_1 \\\\
    b_2 \\\\
    \vdots \\\\
    b_{n-1} \\\\
    b_n \\\\
\end{bmatrix}=
\begin{bmatrix}
    a_1-b_1 \\\\
    a_2-b_2 \\\\
    \vdots \\\\
    a_{n-1}-b_{n-1} \\\\
    a_n-b_n \\\\
\end{bmatrix}</script><ul>
<li>向量不能与标量相加或相减，也不能与维度不同的向量相加或相减</li>
</ul>
<h3 id="Geometric-Interpretation-2"><a href="#Geometric-Interpretation-2" class="headerlink" title="Geometric Interpretation"></a>Geometric Interpretation</h3><p>向量相加几何意义：如果是向量$a+b$，可以将a的头部与b的尾部向量，从a的尾部指向b的头部的向量即为加法结果，如下图所示：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter2-Notes/2020-02-24-21-57-56.png" alt="向量加法"></p>
<p>向量相减几何意义：如果向量$d-c$，则将两个向量的尾部向量，从c头部指向d头部的向量即为减法结果，如下图所示：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter2-Notes/2020-02-24-22-04-20.png" alt="向量减法"></p>
<h3 id="Displacement-Vector-from-One-Point-to-Another"><a href="#Displacement-Vector-from-One-Point-to-Another" class="headerlink" title="Displacement Vector from One Point to Another"></a>Displacement Vector from One Point to Another</h3><p>当要计算从点a到点b的位移向量，可以通过$b-a$获得，如下图所示：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter2-Notes/2020-02-24-22-05-56.png" alt="向量位移"></p>
<h2 id="Vector-Magnitude-Length"><a href="#Vector-Magnitude-Length" class="headerlink" title="Vector Magnitude(Length)"></a>Vector Magnitude(Length)</h2><p>向量的大小也常称为向量的长度（Length）或向量的模（Norm）。</p>
<h3 id="Official-Linear-Algebra-Rules-1"><a href="#Official-Linear-Algebra-Rules-1" class="headerlink" title="Official Linear Algebra Rules"></a>Official Linear Algebra Rules</h3><p>求向量的大小：</p>
<script type="math/tex; mode=display">
\Vert V \Vert = \sqrt{\sum_{i=1}^{n}{v_i}^2}</script><p>其中每个$v_i$表示向量$V$的一个维度，如x轴，y轴等</p>
<ul>
<li>一些书用单条形符号表示，如$|v|$</li>
</ul>
<p>如果有向量a和b，则a,b满足：</p>
<script type="math/tex; mode=display">
\Vert a \Vert^2 + \Vert b \Vert^2 = \Vert a+b \Vert^2 \\\\
\Vert a \Vert + \Vert b \Vert\geq \Vert a+b \Vert</script><h3 id="Geometric-Interpretation-3"><a href="#Geometric-Interpretation-3" class="headerlink" title="Geometric Interpretation"></a>Geometric Interpretation</h3><p>求向量大小物理解释：求向量$V$的大小，类似于求直角三角形的第三条边长度，因此用类似于勾股定理的每条边平方相加，再开方。</p>
<p>对于任意正数值，有无数条向量的大小是该值。</p>
<h2 id="Unit-Vectors"><a href="#Unit-Vectors" class="headerlink" title="Unit Vectors"></a>Unit Vectors</h2><p>单位向量（Unit vector）是长度为1的向量（并没有限定方向），单位向量也被称为归一化向量（normalized vectors）。</p>
<ul>
<li>normalized vector表示是归一化向量即单位向量，长度为1的向量</li>
<li>normal vector表示法向量，是垂直于某个面的向量</li>
</ul>
<h3 id="Official-Linear-Algebra-Rules-2"><a href="#Official-Linear-Algebra-Rules-2" class="headerlink" title="Official Linear Algebra Rules"></a>Official Linear Algebra Rules</h3><p>某个方向的单位向量可以通过这个方向的某向量除以它的大小得到，如</p>
<script type="math/tex; mode=display">
\hat = \frac{v}{\Vert v \Vert}</script><ul>
<li>零向量不能被归一化</li>
</ul>
<h3 id="Geometric-Interpretation-4"><a href="#Geometric-Interpretation-4" class="headerlink" title="Geometric Interpretation"></a>Geometric Interpretation</h3><p>单位向量几何意义：在二维坐标系中，如果将无数的单位向量的尾部放在原点，则其顶点可以构成半径为1的圆。在三维坐标系中，如果将无数的单位向量的尾部放在原点，则其顶点可以构成半径为1的球。</p>
<h2 id="The-Distance-Formula"><a href="#The-Distance-Formula" class="headerlink" title="The Distance Formula"></a>The Distance Formula</h2><p>求两向量的距离：</p>
<script type="math/tex; mode=display">
distance(u,v)=\Vert v-u \Vert=\sqrt{\sum_{i=1}^{n}{v_i-u_i}}</script><p>其中$v_i$和$u_i$为向量$v$和$u$每个维度的值。</p>
<h2 id="Vector-Dot-Product"><a href="#Vector-Dot-Product" class="headerlink" title="Vector Dot Product"></a>Vector Dot Product</h2><p>向量点乘（dot product）又称为向量内积（inner product）。</p>
<h3 id="Official-Linear-Algebra-Rules-3"><a href="#Official-Linear-Algebra-Rules-3" class="headerlink" title="Official Linear Algebra Rules"></a>Official Linear Algebra Rules</h3><p>向量点乘时必须用一个使用点符号，如$a\cdot b$。如果两个向量之间没有点符号，则会认为这两个向量要进行矩阵的乘法。</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
    a_1 \\\\
    a_2 \\\\
    \vdots \\\\
    a_{n-1} \\\\
    a_n \\\\
\end{bmatrix}\cdot
\begin{bmatrix}
    b_1 \\\\
    b_2 \\\\
    \vdots \\\\
    b_{n-1} \\\\
    b_n \\\\
\end{bmatrix}=\sum_{i=1}^{n}{a_ib_i}</script><p>向量的点乘是相互的，$a\cdot b=a \cdot b$</p>
<h3 id="Geometric-Interpretation-5"><a href="#Geometric-Interpretation-5" class="headerlink" title="Geometric Interpretation"></a>Geometric Interpretation</h3><h4 id="Projection"><a href="#Projection" class="headerlink" title="Projection"></a>Projection</h4><p><strong>点乘的第一个几何意义：投影</strong></p>
<p>假设a是单位向量，则a与b的点乘,$\hat{a}\cdot b$表示为$b$在$a$上的投影的有向长度（因为点乘的结果是标量，所以这里的有向指的是正负，而不是方向）。如下图所示：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter2-Notes/2020-02-24-22-57-15.png" alt="向量投影角度与大小"></p>
<p>向量的点乘可以与标量的乘法相结合：</p>
<script type="math/tex; mode=display">
(ka)\cdot b =k(a\cdot b)=a\cdot(kb)</script><p>因此，上述关于单位向量的点乘可以推广到普通向量，即</p>
<blockquote>
<p>向量a与向量b的点乘，结果为向量b在向量a上的有向投影长度(b的长度会影响该投影长度)乘以向量a的大小。</p>
</blockquote>
<p>点乘满足加法与减法分配律即：</p>
<script type="math/tex; mode=display">
a\cdot(b+c)=a\cdot b+a\cdot c</script><p><strong>点乘的第二个几何意义：计算分量</strong></p>
<p>b在a上的投影实际上可以看作是b在a方向上的分量。因此还可以通过投影来将b拆分为两部分，平行于a的分量和垂直与a的分量，即</p>
<script type="math/tex; mode=display">
b_\Vert=(\hat{a}\cdot b)\hat{a} \\\\
b_\perp=b-(\hat{a}\cdot b)\hat{a}</script><p><strong>点乘的第三个几何意义：计算角度</strong></p>
<p>将投影的结果表示为三角形，如下所示：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter2-Notes/2020-02-25-14-01-08.png" alt="向量表示三角角度"></p>
<p>单位向量$\hat{a}$和单位向量$\hat{b}$的点积为在a上的投影，即三角形的临边，所以角度$\theta$可表示为：</p>
<script type="math/tex; mode=display">
cos\theta=\frac{\hat{a}\cdot\hat{b}}{1}=\hat{a}\cdot\hat{b}</script><p>可以将其推广到普通的向量a和b，即</p>
<blockquote>
<p>两个向量的点积等于这两个向量之间夹角的cos乘上两个向量的大小</p>
<script type="math/tex; mode=display">
a\cdot b= \Vert a\Vert \Vert b\Vert cos\theta \\\\
\theta=arccos(\frac{a\cdot b}{\Vert a\Vert \Vert b\Vert})</script></blockquote>
<p>因此，如果点乘的两个向量夹角范围在$-90^\circ \sim 90^\circ$,结果为正数。如果夹角为90°，结果为0。如果范围在$90^\circ \sim 270^\circ$，结果为负数。如果是正数，则b和a是在指向同一个方向（比如都往前），而负数则表示指向不同方向（一个向前，一个向后）。</p>
<h2 id="Vector-Cross-Product"><a href="#Vector-Cross-Product" class="headerlink" title="Vector Cross Product"></a>Vector Cross Product</h2><p>向量与向量还有个计算称为叉乘（Cross product）。</p>
<h3 id="Official-Linear-Algebra-Rules-4"><a href="#Official-Linear-Algebra-Rules-4" class="headerlink" title="Official Linear Algebra Rules"></a>Official Linear Algebra Rules</h3><p>以三维向量的叉乘为例，表达式及计算如下：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
    x_1 \\\\
    y_1 \\\\
    z_1 \\\\
\end{bmatrix} \times
\begin{bmatrix}
    x_2 \\\\
    y_2 \\\\
    z_2 \\\\
\end{bmatrix}=
\begin{bmatrix}
    y_1z_2-z_1y_2 \\\\
    z_1x_2-x_1z_2\\\\
    x_1y_2-y_1x_2
\end{bmatrix}</script><p>当向量和点乘一起发生时，先计算叉乘，再计算点乘，即</p>
<script type="math/tex; mode=display">
a\cdot b \times c = a\cdot (b\times c)</script><p>形如$a\cdot (b\times c)$的表达式称为三重积。</p>
<ul>
<li>叉乘是反交换的，即$a\times b = -(b\times a)$</li>
<li>叉乘满足分配律，即$a\times(b+c)=a\times b + a\times c$</li>
<li>叉乘没有结合性，即$(a \times b)\times c \neq a\times(b\times c)$</li>
<li>标量与叉乘结合：即$k(a\times b)=(ka)\times b = a\times(kb)$</li>
</ul>
<h3 id="Geometric-Interpretation-6"><a href="#Geometric-Interpretation-6" class="headerlink" title="Geometric Interpretation"></a>Geometric Interpretation</h3><p>叉乘返回的结果是垂直于两个叉乘向量的另一个向量，如下图所示：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter2-Notes/2020-02-25-14-19-01.png" alt="向量叉乘结果"></p>
<p>其大小等于两个向量的大小乘上两个向量之间夹角的sin,该大小也等于由两个向量构成的平行四边形的面积。即</p>
<script type="math/tex; mode=display">
\Vert a\times b \Vert = \Vert a\Vert \Vert b\Vert \sin \theta</script><p>叉乘结果的方向与左右手坐标系相关，如果表达式为$a \times b$，将b的尾部与a的头部相连。在左手坐标系下，如果在形成的方向是顺时针的，则结果方向指向外侧，如果是逆时针，则指向内侧。在右手坐标系下，结果相反。如下图所示：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter2-Notes/2020-02-25-14-26-14.png" alt="向量叉乘结果方向"></p>
<p>也可以用手来求叉乘结果方向，如果表达式为$a \times b$，将大拇指指向a的方向，将食指指向b的方向，让中指与食指和大拇指垂直（像展示左右手坐标系那样），食指的方向即为叉乘结果方向。</p>
<h2 id="Linear-Algebra-Identities"><a href="#Linear-Algebra-Identities" class="headerlink" title="Linear Algebra Identities"></a>Linear Algebra Identities</h2><p>下表为向量计算定律，基本都在上面解释过了：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter2-Notes/2020-02-25-14-37-40.png" alt="向量计算定律"></p>
<div class="note info simple"><p>引用：</p>
<ol>
<li><em>3D Math Primer for Graphics and Game Development</em> 2nd 2011 </li>
</ol>
</div>
<hr>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>3D数学</tag>
      </tags>
  </entry>
  <entry>
    <title>《3D数学基础：图形和游戏开发》第四章笔记</title>
    <url>/3DMathPrimerForGraphicsAGameDevelopment-Chapter4-Notes/</url>
    <content><![CDATA[<p>《3D数学基础：图形和游戏开发》第四章笔记</p>
<p>这一节简单的介绍了矩阵的一些基础性质：<br>4.1 关于矩阵的一些数学特性<br>4.2 关于矩阵是用来表达线性变换的几何意义<br>4.3 介绍了矩阵在线性代数中还可以用于解方程组</p>
<span id="more"></span>
<h1 id="Introduction-to-Matrices"><a href="#Introduction-to-Matrices" class="headerlink" title="Introduction to Matrices"></a>Introduction to Matrices</h1><p>矩阵是3D数学的重要部分，它主要被使用在不同的坐标系之间的转换。</p>
<h2 id="Mathematical-Definition-of-Matrix"><a href="#Mathematical-Definition-of-Matrix" class="headerlink" title="Mathematical Definition of Matrix"></a>Mathematical Definition of Matrix</h2><p>在线性代数中，矩阵是由一系列数字按行和列排布组成。可以将向量看作是标量的集合，把矩阵看作是向量的集合。</p>
<h3 id="Matrix-Dimensions-and-Notation"><a href="#Matrix-Dimensions-and-Notation" class="headerlink" title="Matrix Dimensions and Notation"></a>Matrix Dimensions and Notation</h3><p>将一个有$r$行，$c$列的矩阵称为是$r\times c$矩阵，矩阵中的数字由方括号包围，如下为一个$3 \times 3$的矩阵，</p>
<script type="math/tex; mode=display">
M=\begin{bmatrix}
m_{11}&m_{12}&m_{13}\\\\
m_{21}&m_{22}&m_{23}\\\\
m_{31}&m_{32}&m_{33}\\\\
\end{bmatrix}</script><p>在这本书中，所有的矩阵都用大写粗体表示，如$\mathbf{M}$，用$m_{ij}$表示$\mathbf{M}$中第i行，第j列的元素。</p>
<h3 id="Square-Matrices"><a href="#Square-Matrices" class="headerlink" title="Square Matrices"></a>Square Matrices</h3><p>将行数和列数相同的矩阵，称为<code>方阵（Square Matrices）</code>。</p>
<p>将下标的行数和列数相同的元素，称为<code>对角元素（Diagonal elements）</code>，如上矩阵中的$m<em>{11}$,$m</em>{22}$,$m_{33}$为对角元素。</p>
<p>如果一个矩阵（并不一定是方阵）中，所有的非对角元素都是0，那么整个矩阵称为对角矩阵（diagonal matrix）。如下</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
3&0&0&0\\\\
0&1&0&0\\\\
0&0&-5&0\\\\
0&0&0&2\\\\
\end{bmatrix}</script><p>在对角矩阵中，如果所有的元素都为1，那么就变成了<code>单位矩阵（Identity Matrix）</code>，单位矩阵通常用$\mathbf{I}$表示，如下</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
1&0&0&0\\\\
0&1&0&0\\\\
0&0&1&0\\\\
0&0&0&1\\\\
\end{bmatrix}</script><p>如果一个矩阵与单位矩阵相乘，那么得到的还是该矩阵本身。</p>
<h3 id="Vectors-as-Matrices"><a href="#Vectors-as-Matrices" class="headerlink" title="Vectors as Matrices"></a>Vectors as Matrices</h3><p>向量可以看作是一个$1\times n$或者$n \times 1$的矩阵，即$1\times n$的矩阵可以称为行向量，$n\times 1$可以称为列向量。</p>
<h3 id="Matrix-Transposition"><a href="#Matrix-Transposition" class="headerlink" title="Matrix Transposition"></a>Matrix Transposition</h3><p>给定一个$r\times c$矩阵$\mathbf{M}$，其转置写为$\mathbf{M^T}$，转置矩阵是一个$c\times r$的矩阵。其中$\mathbf{M}$中的行变为$\mathbf{M^T}$中的列，即$\mathbf{M^T<em>{ij}}=\mathbf{M</em>{ji}}$。如下：</p>
<script type="math/tex; mode=display">
{\begin{bmatrix}
a&b&c\\\\
d&e&f\\\\
g&h&i\\\\
\end{bmatrix}}^T=
\begin{bmatrix}
a&d&g\\\\
b&e&h\\\\
c&f&i\\\\
\end{bmatrix}</script><script type="math/tex; mode=display">
{\begin{bmatrix}
x & y &z
\end{bmatrix}}^T=\begin{bmatrix}
x\\\\
y\\\\
z\\\\
\end{bmatrix}</script><p>转置矩阵有如下性质：</p>
<ol>
<li>矩阵转置的转置等于本身，$(\mathbf{M^T})^T=\mathbf{M}$</li>
<li>如果一个矩阵的转置等于矩阵本身，那么$\mathbf{D^T}=\mathbf{D}$，那么这个矩阵就是是单位矩阵。</li>
</ol>
<h3 id="Multiplying-a-Matrix-with-a-Scalar"><a href="#Multiplying-a-Matrix-with-a-Scalar" class="headerlink" title="Multiplying a Matrix with a Scalar"></a>Multiplying a Matrix with a Scalar</h3><script type="math/tex; mode=display">
kM=k\begin{bmatrix}
m_{11}&m_{12}&m_{13}\\\\
m_{21}&m_{22}&m_{23}\\\\
m_{31}&m_{32}&m_{33}\\\\
\end{bmatrix}=
\begin{bmatrix}
km_{11}&km_{12}&km_{13}\\\\
km_{21}&km_{22}&km_{23}\\\\
km_{31}&km_{32}&km_{33}\\\\
\end{bmatrix}</script><h3 id="Multiplying-Two-Matrices"><a href="#Multiplying-Two-Matrices" class="headerlink" title="Multiplying Two Matrices"></a>Multiplying Two Matrices</h3><p>对于$r\times n$的矩阵$\mathbf{A}$，如果与$n\times c$的矩阵$\mathbf{B}$相乘，结果为$r\times c$的矩阵$\mathbf{AB}$</p>
<p>对于两个矩阵相乘，前者的列数必须与后者的行数匹配，如下：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter4-Notes/2020-03-04-17-18-32.png" alt="矩阵相乘计算1"></p>
<p>假设将相乘结果中的每个元素称为$c_{ij}$，其值为前者的第$i$行中所有元素与后者的第$j$列中的元素一一相乘并累加，即</p>
<script type="math/tex; mode=display">
c_{ij}=\sum_{k=1}^{n}a_{ik}b_{kj}</script><p>如下：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter4-Notes/2020-03-04-17-21-41.png" alt="矩阵相乘计算2"></p>
<p>矩阵相乘有如下性质：</p>
<ol>
<li>$\mathbf{MI=IM=M}$</li>
<li>矩阵的相乘不是可交换的，$\mathbf{AB\neq BA}$</li>
<li>矩阵的相乘满足结合律，$\mathbf{(AB)C=A(BC)}$。矩阵与标量和向量同样满足结合性，即<script type="math/tex; mode=display">
\mathbf{(kA)B=k(AB)=A(kB)}，\\\\
\mathbf{(vA)B=v(AB)}</script></li>
<li>乘积的转置，等于乘数与被乘数的转置以相反的顺序相乘，$\mathbf{(AB)^T=B^TA^T}$</li>
</ol>
<h3 id="Multiplying-a-Vector-and-a-Matrix"><a href="#Multiplying-a-Vector-and-a-Matrix" class="headerlink" title="Multiplying a Vector and a Matrix"></a>Multiplying a Vector and a Matrix</h3><p>如有向量和矩阵的乘法如下：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
x & y &z
\end{bmatrix}\begin{bmatrix}
  m_{11}&m_{12}&m_{13}\\\\
m_{21}&m_{22}&m_{23}\\\\
m_{31}&m_{32}&m_{33}\\\\
\end{bmatrix}= \\\\
\begin{bmatrix}
xm_{11}+ym_{21}+zm_{31} & xm_{12}+ym_{22}+zm_{32} &xm_{13}+ym_{23}+zm_{33}
\end{bmatrix}</script><script type="math/tex; mode=display">
\begin{bmatrix}
  m_{11}&m_{12}&m_{13}\\\\
m_{21}&m_{22}&m_{23}\\\\
m_{31}&m_{32}&m_{33}\\\\
\end{bmatrix}
\begin{bmatrix}
x\\\\
y\\\\
z\\\\
\end{bmatrix}=
\begin{bmatrix}
  xm_{11}+ym_{12}+zm_{13}\\\\
  xm_{21}+ym_{22}+zm_{23}\\\\
  xm_{31}+ym_{22}+zm_{33}\\\\
\end{bmatrix}</script><p>向量和矩阵的乘法有以下特性：</p>
<ol>
<li>结果的每个元素，相当于原向量与矩阵不同列的点积（如果是矩阵与列向量相乘，则是与矩阵不同行的点积）</li>
<li>矩阵中的每个元素相当于是控制输入向量的某个元素在输出某个元素上的占比。如$m_{12}$就是控制输入的$x$元素，在输出的$y$元素上的占比。所以对输入的向量而言，所有控制输入向量X分量的元素都在第一行，所有控制Y分量的元素都在第二行，所有控制Z分量的元素都在第三行，即矩阵的每一行都代表一个基础向量（类似于X轴，Y轴）。</li>
<li>元素和向量的成绩满足分配律，如$\mathbf{(v+w)M=vM+wM}$</li>
</ol>
<h3 id="Row-versus-Column-Vectors"><a href="#Row-versus-Column-Vectors" class="headerlink" title="Row versus Column Vectors"></a>Row versus Column Vectors</h3><p>行向量与列向量本质上并没有区别，但需要注意使用行列向量与矩阵相乘时的顺序是不同的。假设向量$\mathbf{v}$需要与矩阵$\mathbf{A,B,C}$依次相乘。如果$\mathbf{v}$是列向量，那么向量应该出现在右侧，即写为$\mathbf{vABC}$。如果$\mathbf{v}$是行向量，那么向量应该出现在右侧，即写为$\mathbf{CBAv}$。</p>
<p>且行向量与列向量与同一个矩阵相乘后，对应的元素是不同的（如行向量计算结果的第一个元素与列向量计算结果的第一个元素不同）。因此如果想要使用行向量进行计算和使用列向量进行计算的结果向量元素一一对应相等的话，则它们各自使用的矩阵必须是不同的，且为转置关系。</p>
<p>行向量的优点在于，阅读的顺序和相乘的顺序是一致的，即从左到右，而列向量乘积的相乘顺序则是从右到左，但行向量的主要缺点在于，当向量的维度增加时，会让表达式变得非常的长，造成书写的不便，而使用列向量就不会有这个问题。</p>
<p>对于数学家而言，因为需要用到推到，所以他们更喜欢用写起来较短的列向量表达式。而对于计算机而言，因为没有书写的问题，所以更喜欢阅读和相乘顺序相同的行向量，<strong>本书也是使用行向量作为与矩阵相乘的向量</strong>，之后章节计算出的各种变换矩阵都是基于行向量的，如果要使用在列向量的计算环境下，需要进行转置。</p>
<p>DirectX使用行向量，OpenGL使用列向量。当使用别人的表达式或者代码时，需要特别注意它使用的是行向量还是列向量。</p>
<h2 id="Geometric-Interpretation-of-Matrix"><a href="#Geometric-Interpretation-of-Matrix" class="headerlink" title="Geometric Interpretation of Matrix"></a>Geometric Interpretation of Matrix</h2><p>从几何意义角度来说，方阵可以描述任何的<code>线性变化（Linear transformation）</code>。</p>
<p>线性变化保证了图形中的线条不会被弯曲，且线条们的平行性质不会给改变，但其他的几何性质，如角度，面积，体积，长度都可能发现变化。线性变化包括：</p>
<ol>
<li>旋转(Rotation)</li>
<li>缩放(Scale)</li>
<li>正交投影(Orthographic projection)</li>
<li>反射(Reflection)</li>
<li>切边（shearing）</li>
</ol>
<h3 id="Multiplying-a-Vector-and-a-Matrix-1"><a href="#Multiplying-a-Vector-and-a-Matrix-1" class="headerlink" title="Multiplying a Vector and a Matrix"></a>Multiplying a Vector and a Matrix</h3><p>假设$\mathbf{i}=[1,0,0],\mathbf{j}=[0,1,0],\mathbf{k}=[0,0,1]$，矩阵$\mathbf{M}$为</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
m_{11}&m_{12}&m_{13}\\\\
m_{21}&m_{22}&m_{23}\\\\
m_{31}&m_{32}&m_{33}\\\\
\end{bmatrix}</script><p>则向量$\mathbf{v}=v_x\mathbf{i}+v_y\mathbf{j}+v_z\mathbf{k}$。且矩阵和向量的乘法可以看作为：</p>
<script type="math/tex; mode=display">
\mathbf{vM}=(v_x\mathbf{i}+v_y\mathbf{j}+v_z\mathbf{k})M \\\\
=(v_x\mathbf{i})\mathbf{M}+(v_y\mathbf{j})\mathbf{M}+(v_z\mathbf{k})\mathbf{M}\\\\
=v_x(\mathbf{i}\mathbf{M})+v_y(\mathbf{j}\mathbf{M})+v_z(\mathbf{k}\mathbf{M})\\\\
=v_x\begin{bmatrix}m_{11} & m_{12} &m_{13} \end{bmatrix}+v_y\begin{bmatrix}m_{21} & m_{22} &m_{23} \end{bmatrix}\\\\
+v_z\begin{bmatrix}m_{31} & m_{32} &m_{33} \end{bmatrix}</script><p><strong>可以将矩阵的每一行看作是一个基本向量</strong>，即$\begin{bmatrix}m<em>{11} &amp; m</em>{12} &amp;m<em>{13} \end{bmatrix}$，$\begin{bmatrix}m</em>{21} &amp; m<em>{22} &amp;m</em>{23} \end{bmatrix}$和$\begin{bmatrix}m<em>{31} &amp; m</em>{32} &amp;m_{33} \end{bmatrix}$都是基本向量，将其命名为$\mathbf{p,q,r}$，则上式结果可以改写为</p>
<script type="math/tex; mode=display">
\mathbf{vM}=v_x\mathbf{p}+v_y\mathbf{q}+v_z\mathbf{r}</script><p>与原式$\mathbf{v}=v_x\mathbf{i}+v_y\mathbf{j}+v_z\mathbf{k}$比较，可以得出，原来的基本向量$\mathbf{i,j,k}$经过了线性变化，变成了新的基本向量$\mathbf{p,q,r}$，不同的的基本向量就构成了不同的坐标系。</p>
<p>可以通过上述的方法来直接判断一个方阵所代表的线性变化，<strong>方阵的每一行都是变换后的基本向量</strong>，如有方阵</p>
<script type="math/tex; mode=display">
\mathbf{M}=
\begin{bmatrix}
2 & 1 \\\\
-1 & 2
\end{bmatrix}</script><p>其中，$\mathbf{p}=\begin{bmatrix}2 &amp;1 \end{bmatrix},\mathbf{q}=\begin{bmatrix}-1 &amp;2 \end{bmatrix}$。即原坐标$(0,1)$变成了$(2,1)$，原坐标$(1,0)$变成了坐标$(-1,2)$，如下图所示：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter4-Notes/2020-03-04-19-40-39.png" alt="方阵几何意义"></p>
<p>如果对一个二维图片使用该矩阵进行变化，则如下图所示：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter4-Notes/2020-03-04-19-41-28.png" alt="二维矩阵线性变化"></p>
<p>对于三维矩阵同样如此，如有三维矩阵</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
  0.707 & -0.707 & 0 \\\\
  1.25 & 1.25 & 0 \\\\
  0 & 0 & 1 \\\\
\end{bmatrix}</script><p>将其用于三维模型的坐标变化，则结果如下图所示：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter4-Notes/2020-03-04-19-48-10.png" alt="三维模型线性变化"></p>
<p>如同可以通过矩阵来直接判断出基本向量的变换，也可以直接通过基本向量的变换来构建出矩阵，只要将对应的基本向量填入每一行即可。</p>
<blockquote>
<p>$n$维方阵在$n$维度下只能描述线性变化。因为$n$维的零向量与$n$维矩阵相乘的结果为零向量，即没有任何的位移变换发生。</p>
</blockquote>
<h2 id="The-Bigger-Picture-of-Linear-Algebra"><a href="#The-Bigger-Picture-of-Linear-Algebra" class="headerlink" title="The Bigger Picture of Linear Algebra"></a>The Bigger Picture of Linear Algebra</h2><p>矩阵在线性代数中，主要用于解决方程组问题，如有方程</p>
<script type="math/tex; mode=display">
-5x_1+x_2+x_3=-10, \\\\
2x_1+x_2+4x_3=12, \\\\
x_1-3x_3=9, \\\\</script><p>可以用矩阵表达为：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
-5 & 1 &1 \\\\
2& 2&4 \\\\
1& 0&-3 \\\\
\end{bmatrix}
\begin{bmatrix}
  x_1 \\\\
  x_2 \\\\
  x_3
\end{bmatrix}=
\begin{bmatrix}
-10 \\\\
12\\\\
9
\end{bmatrix}</script><p>即可以通过矩阵的变换求出方程组的解。</p>
<p>线性代数在解方程组方面的应用在这本书中不多，但在一些更深入的主题，如物理引擎和渲染方面则有很多应用。</p>
<div class="note info simple"><p>引用：</p>
<ol>
<li><em>3D Math Primer for Graphics and Game Development</em> 2nd 2011 </li>
</ol>
</div>
<hr>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>3D数学</tag>
      </tags>
  </entry>
  <entry>
    <title>《3D数学基础：图形和游戏开发》第五章笔记</title>
    <url>/3DMathPrimerForGraphicsAGameDevelopment-Chapter5-Notes/</url>
    <content><![CDATA[<p>《3D数学基础：图形和游戏开发》第五章笔记</p>
<p>5.1-5.5 介绍了五种线性变换，旋转，缩放，正交投影，反射，切变。<br>5.6 介绍了线性变化的结合。<br>5.7 介绍了变换的种类，包括线性变换和仿射变换。还有各种其他的分类方式，如可逆变换，保角变换等。</p>
<span id="more"></span>
<h1 id="Chapter-5-Matrices-and-Linear-Transformations"><a href="#Chapter-5-Matrices-and-Linear-Transformations" class="headerlink" title="Chapter 5 Matrices and Linear Transformations"></a>Chapter 5 Matrices and Linear Transformations</h1><p>这一章将主要介绍使用$3\times 3$矩阵进行三维孔径啊下的线性变化（Linear Transformations）。线性变化是不包含位移的，包含了位移的变换称为仿射变换（Affine Transformation）。对于一个$N$维的方阵，是不可能你表达出$N$维的仿射变换的。</p>
<p>这一章中推到出变换矩阵的方法还是通过先计算出基础向量经过变换后的向量，然后将变换后向量依次填入矩阵的每一行，形成变换矩阵。</p>
<h2 id="Rotation"><a href="#Rotation" class="headerlink" title="Rotation"></a>Rotation</h2><h3 id="Rotation-in-2D"><a href="#Rotation-in-2D" class="headerlink" title="Rotation in 2D"></a>Rotation in 2D</h3><p>在二维空间中的旋转是基于一个点的。对于基于原点的二维旋转，只有一个变量即旋转角度$\theta$，而且通常而言顺时针旋转为正方向，逆时针旋转为反方向。</p>
<p>旋转矩阵如下：</p>
<script type="math/tex; mode=display">
\mathbf{R}(\theta)=\begin{bmatrix}
\cos\theta & \sin\theta \\\\
-\sin\theta & \cos\theta \\\\
\end{bmatrix}</script><p>其中的每一行都是变换后的标准向量，即将$(1,0)$，变为了$(\cos\theta , \sin\theta)$，将$(0,1)$变成了$( -\sin\theta , \cos\theta )$，如下图所示：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter5-Notes/2020-03-05-12-29-37.png" alt="二维空间旋转"></p>
<h3 id="3D-Rotation-about-Cardinal-Axes"><a href="#3D-Rotation-about-Cardinal-Axes" class="headerlink" title="3D Rotation about Cardinal Axes"></a>3D Rotation about Cardinal Axes</h3><p>这里讨论的三维旋转矩阵也同样是基于原点旋转的，但在三维空间中，可以围绕不同的轴进行旋转，这里首先给出基于三个向量轴的旋转：</p>
<p>绕着X轴的计算矩阵如下：</p>
<script type="math/tex; mode=display">
R_x(\theta)=\begin{bmatrix}
1&0          &0\\\\
0& \cos\theta&\sin\theta\\\\
0& -sin\theta&\cos\theta\\\\
\end{bmatrix}</script><p>绕着Y轴的计算矩阵如下：</p>
<script type="math/tex; mode=display">
R_y(\theta)=\begin{bmatrix}
\cos\theta&0 &-\sin\theta\\\\
0& 1&0\\\\
\sin\theta&0 &\cos\theta\\\\
\end{bmatrix}</script><p>绕着Z轴的计算矩阵如下：</p>
<script type="math/tex; mode=display">
R_z(\theta)=\begin{bmatrix}
\cos\theta& \sin\theta&0\\\\    
-\sin\theta& \cos\theta&0\\\\
0&0 &1\\\\    
\end{bmatrix}</script><p>三个矩阵的推导同样是通过基本向量的变换。如果某个轴作为旋转轴，那么这个轴在旋转过程中是不会发生变化的，而剩下的两个轴就可以看作是一个二维空间的旋转，如下图是当旋转轴是Y轴的示意图：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter5-Notes/2020-03-05-12-41-42.png" alt="基于Y轴旋转"></p>
<h3 id="3D-Rotation-about-an-Arbitrary-Axis"><a href="#3D-Rotation-about-an-Arbitrary-Axis" class="headerlink" title="3D Rotation about an Arbitrary Axis"></a>3D Rotation about an Arbitrary Axis</h3><p>向量绕着任意轴$n$(穿过原点的轴)旋转$\theta$角度的计算表达式如下：</p>
<script type="math/tex; mode=display">
R({\hat{n},\theta})=
\begin{bmatrix}
{n_x}^2(1-\cos \theta) + \cos\theta &
n_xn_y(1-\cos \theta)+n_z\sin\theta &
n_xn_z(1-\cos \theta) -n_y\sin\theta
\\\\
n_xn_y(1-\cos \theta) -n_z\sin\theta  &
{n_y}^2(1-\cos \theta)+\cos\theta &
n_yn_z(1-\cos \theta) +n_x\sin\theta
\\\\
n_xn_z(1-\cos \theta) +n_y\sin\theta &
n_yn_z(1-\cos \theta)-n_x\sin\theta &
{n_z}^2(1-\cos \theta) +\cos \theta
\end{bmatrix}</script><p>推导过程如下：</p>
<p>针对对于任意轴的旋转矩阵，思路同样是求基本向量在旋转后的结果。向量$\mathbf{v}$在绕任意轴$n$旋转$\theta$角度后变为$\mathbf{v^{‘}}$，表达式为：</p>
<script type="math/tex; mode=display">
\mathbf{v^{'}}=\mathbf{v}\mathbf{R}(\hat{\mathbf{n}},\theta)</script><p>求解过程如下：</p>
<ol>
<li>为了方便计算，将向量$v$拆成两部分$v<em>{\parallel}$和$v</em>{\perp}$，分别表示平行于和垂直于旋转轴$n$的分量。在旋转过程中，平行于旋转轴$n$的分量$v<em>{\parallel}$是不会发生变化的，因此要求的只是旋转后的$v^{‘}</em>{\perp}$<br>整个旋转的示意图如下：<br><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter5-Notes/2020-03-05-12-52-30.png" alt="旋转示意图"></li>
<li>$v<em>{\parallel}$可以通过点积求得，即$\mathbf{ v</em>{\parallel}=(v\cdot\hat{n})\hat{n}}$</li>
<li>$v<em>{\perp}$可以通过$v$减去$v</em>{\parallel}$得到，即$\mathbf{v<em>{\perp}=v-v</em>{\parallel}}$</li>
<li>图中的$w$向量是为了与向量$v<em>{\perp}$构成一个平面，$w$向量的长度与$v</em>{\perp}$相同，且垂直于$\hat{n}$和$v<em>{\perp}$，所以可得$\mathbf{w=\hat{n}\times v</em>{\perp}}$</li>
<li>此时,$w$和$v<em>{\perp}$构成了一个二维平面，根据二维平面的旋转可得，$v</em>{\perp}^{‘}=\cos \theta v_{\perp} + \sin\theta w$</li>
<li>结合上面所有的式子，可推导出$v^{‘}$的公式，即<script type="math/tex; mode=display">
\mathbf{v^{'}=V_{\perp}^{'}+v_{\parallel}}\\\\
=\mathbf{\cos \theta v_{\perp} + \sin\theta w+(v\cdot\hat{n})\hat{n}} \\\\
=\cos\theta(v-(v\cdot\hat{n})\hat{n})+\sin\theta (\hat{n}\times v_{\perp})+(v\cdot\hat{n})\hat{n} \\\\
=\cos\theta(v-(v\cdot\hat{n})\hat{n})+\sin\theta (\hat{n}\times(v-v_{\parallel}))+(v\cdot\hat{n})\hat{n} \\\\
=\cos\theta(v-(v\cdot\hat{n})\hat{n})+\sin\theta (\hat{n}\times v-\hat{n} \times v_{\parallel})+(v\cdot\hat{n})\hat{n} \\\\
=\cos\theta(v-(v\cdot\hat{n})\hat{n})+\sin\theta (\hat{n}\times v-0)+(v\cdot\hat{n})\hat{n} \\\\
=\cos\theta(v-(v\cdot\hat{n})\hat{n})+\sin\theta (\hat{n}\times v)+(v\cdot\hat{n})\hat{n}</script></li>
</ol>
<p>即最终用$\hat{n}，\theta，v$表达$v^{‘}$的式子为：</p>
<script type="math/tex; mode=display">
v^{'}=\cos\theta(v-(v\cdot\hat{n})\hat{n})+\sin\theta (\hat{n}\times v)+(v\cdot\hat{n})\hat{n}</script><p>将$p=\begin{bmatrix} 1 &amp; 0&amp; 0\end{bmatrix}$作为$v$代数上式，得:</p>
<script type="math/tex; mode=display">
v^{'}=p^{'}=\cos\theta({\begin{bmatrix} 1\\\\0\\\\0 \end{bmatrix}}^T-n^x{\begin{bmatrix} n^x\\\\n^y\\\\n^z \end{bmatrix}}^T)+
sin\theta {\begin{bmatrix} 0\\\\n_z\\\\-n_y \end{bmatrix}}^T+n^x{\begin{bmatrix} n^x\\\\n^y\\\\n^z \end{bmatrix}}^T</script><p>其中：$\hat{n}={\begin{bmatrix} n^x\\n^y\\n^z \end{bmatrix}}^T$，且$\hat{n}\times v={\begin{bmatrix} 0\\n^z\\-n^y \end{bmatrix}}^T$</p>
<p>原式可继续化简：</p>
<script type="math/tex; mode=display">
p^{'}=v^{'}=\cos\theta({\begin{bmatrix} 1\\\\0\\\\0 \end{bmatrix}}^T-n^x{\begin{bmatrix} n^x\\\\n^y\\\\n^z \end{bmatrix}}^T)+
sin\theta {\begin{bmatrix} 0\\\\n_z\\\\-n_y \end{bmatrix}}^T+n^x{\begin{bmatrix} n^x\\\\n^y\\\\n^z \end{bmatrix}}^T \\\\
={\begin{bmatrix}
\cos\theta(1-{n_x}^2)+0+{n_x}^2\\\\
\cos\theta(0-n_xn_y)+\sin\theta n_z+n_xn_y\\\\
\cos\theta(0-n_xn_z)-\sin\theta n_y +n_xn_z
\end{bmatrix}}^T \\\\
={\begin{bmatrix}
{n_x}^2(1-\cos \theta) + \cos\theta \\\\
n_xn_y(1-\cos \theta)+n_z\sin\theta \\\\
n_xn_z(1-\cos \theta) -n_y\sin\theta
\end{bmatrix}}^T</script><p>使用相同的步骤，可以计算出当输入$v=q=\begin{bmatrix} 0 &amp; 1&amp; 0\end{bmatrix}$时，结果$q^{‘}$值为：</p>
<script type="math/tex; mode=display">
q^{'}={\begin{bmatrix}
n_xn_y(1-\cos \theta) -n_z\sin\theta  \\\\
{n_y}^2(1-\cos \theta)+\cos\theta \\\\
n_yn_z(1-\cos \theta) +n_x\sin\theta
\end{bmatrix}}^T</script><p>当输入为$r=q=\begin{bmatrix} 0 &amp; 0&amp; 1\end{bmatrix}$，结果$r^{‘}$值为：</p>
<script type="math/tex; mode=display">
r^{'}={\begin{bmatrix}
n_xn_z(1-\cos \theta) +n_y\sin\theta  \\\\
n_yn_z(1-\cos \theta)-n_x\sin\theta \\\\
{n_z}^2(1-\cos \theta) +\cos \theta
\end{bmatrix}}^T</script><p>将每个变换后的基本矩阵，即$p^{‘},q^{‘},r^{‘}$放入变换矩阵的每一行，即为所需要求的绕着任意轴旋转的变换矩阵，即：</p>
<script type="math/tex; mode=display">
R({\hat{n},\theta})=
\begin{bmatrix}
{n_x}^2(1-\cos \theta) + \cos\theta &
n_xn_y(1-\cos \theta)+n_z\sin\theta &
n_xn_z(1-\cos \theta) -n_y\sin\theta
\\\\
n_xn_y(1-\cos \theta) -n_z\sin\theta  &
{n_y}^2(1-\cos \theta)+\cos\theta &
n_yn_z(1-\cos \theta) +n_x\sin\theta
\\\\
n_xn_z(1-\cos \theta) +n_y\sin\theta &
n_yn_z(1-\cos \theta)-n_x\sin\theta &
{n_z}^2(1-\cos \theta) +\cos \theta
\end{bmatrix}</script><h2 id="Scale"><a href="#Scale" class="headerlink" title="Scale"></a>Scale</h2><h3 id="Scaling-along-the-Cardinal-Axes"><a href="#Scaling-along-the-Cardinal-Axes" class="headerlink" title="Scaling along the Cardinal Axes"></a>Scaling along the Cardinal Axes</h3><p>缩放效果如下图所示：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter5-Notes/2020-03-05-16-04-17.png" alt="缩放效果"></p>
<p>对于基本向量而言，在进行了缩放操作后，其变为：</p>
<script type="math/tex; mode=display">
p^{'}=k_xp=kx\begin{bmatrix}1& 0 &0\end{bmatrix}
=\begin{bmatrix} k_x&0&0\end{bmatrix}，\\\\
q^{'}=k_yq=ky\begin{bmatrix}0& 1&0\end{bmatrix}
=\begin{bmatrix} 0&k_y&0\end{bmatrix}，\\\\
r^{'}=k_zr=kz\begin{bmatrix}0& 0&1\end{bmatrix}
=\begin{bmatrix} 0&0&k_z\end{bmatrix}，\\\\</script><p>将其带入缩放矩阵的每一行，可得，如果缩放的方向是基本向量的话，那么缩放矩阵为：</p>
<script type="math/tex; mode=display">
S(k_x,k_y,k_z)=\begin{bmatrix}
k_x&0 &0 \\\\
0&k_y &0 \\\\
0&0 &k_z \\\\
\end{bmatrix}</script><p>如果使用一个向量与该矩阵相乘，得</p>
<script type="math/tex; mode=display">
\begin{bmatrix}x&y&z \end{bmatrix}
\begin{bmatrix}
k_x&0 &0 \\\\
0&k_y &0 \\\\
0&0 &k_z \\\\
\end{bmatrix} =
\begin{bmatrix}k_xx&k_yy&k_zz \end{bmatrix}</script><p>如果沿着各个轴的缩放大小是一样的，则称这个缩放为均匀缩放（Uniform Scaling），否则为非均匀缩放（Nonuniform Scaling）。</p>
<h3 id="Scaling-in-an-Arbitary-Direction"><a href="#Scaling-in-an-Arbitary-Direction" class="headerlink" title="Scaling in an Arbitary Direction"></a>Scaling in an Arbitary Direction</h3><p>向量$v$沿着任意穿过原点的轴$n$缩放得到向量$v^{‘}$，示意图如下：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter5-Notes/2020-03-05-16-10-06.png" alt="沿着任意轴缩放"></p>
<p>计算过程如下：</p>
<ol>
<li>如求沿着任意轴旋转一样，将$v$拆成两部分$v<em>{\parallel}$和$v</em>{\perp}$，其中$\mathbf{ v<em>{\parallel}=(v\cdot\hat{n})\hat{n}}$，$\mathbf{v</em>{\perp}=v-v_{\parallel}}$</li>
<li>如果沿着轴$n$进行缩放，$v<em>{\parallel}$将发生相应缩放，而$v</em>{\perp}$不会产生任何变化，即:</li>
</ol>
<script type="math/tex; mode=display">
v_{\parallel}^{'}=kv_{\parallel}=k(v\cdot\hat{n})\hat{n} \\\\
v_{\perp}^{'}=v_{\perp}=v-v_{\parallel}=v-(v\cdot\hat{n})\hat{n}</script><ol>
<li>因此可求得$v^{‘}$：</li>
</ol>
<script type="math/tex; mode=display">
v^{'}=v_{\perp}^{'}+v_{\parallel}^{'} \\\\
=v-(v\cdot\hat{n})\hat{n} + k(v\cdot\hat{n})\hat{n} \\\\
=v+(k-1)(v\cdot\hat{n})\hat{n}</script><p>如同计算绕着任意轴旋转一样，如果输入的向量$v$是基本向量$p=\begin{bmatrix}1,0,0 \end{bmatrix}$，代数上式，可求得$p^{‘}$：</p>
<script type="math/tex; mode=display">
p^{'}=p+(k-1)(p\cdot\hat{n})\hat{n} \\\\
={\begin{bmatrix}1 \\\\ 0 \\\\ 0\end{bmatrix}}^T + (k-1)n_x{\begin{bmatrix} n_x \\\\ n_y \\\\ n_z\end{bmatrix}}^T \\\\
={\begin{bmatrix}1 \\\\ 0 \\\\ 0\end{bmatrix}}^T + {\begin{bmatrix}(k-1) {n_x}^2 \\\\(k-1)n_xn_y \\\\ (k-1)n_xn_z\end{bmatrix}}^T \\\\
={\begin{bmatrix}1+(k-1) {n_x}^2\\\\ (k-1)n_xn_y \\\\ (k-1)n_xn_z\end{bmatrix}}^T</script><p>使用相同的步骤，可以计算出当输入$v=q=\begin{bmatrix} 0 &amp; 1&amp; 0\end{bmatrix}$时，结果$q^{‘}$值为：</p>
<script type="math/tex; mode=display">
q^{'}={\begin{bmatrix}(k-1) {n_xn_y}\\\\ 1+(k-1){n_y}^2 \\\\ (k-1)n_yn_z\end{bmatrix}}^T</script><p>当输入为$r=q=\begin{bmatrix} 0 &amp; 0&amp; 1\end{bmatrix}$，结果$r^{‘}$值为：</p>
<script type="math/tex; mode=display">
r^{'}={\begin{bmatrix}(k-1) {n_xn_z}\\\\ (k-1){n_yn_z} \\\\ 1+(k-1){n_z}^2\end{bmatrix}}^T</script><p>将其放入缩放矩阵对应的行中，可得沿着任意穿过原点的轴进行缩放的矩阵为：</p>
<script type="math/tex; mode=display">
S(\hat{n},k)=\begin{bmatrix}
1+(k-1) {n_x}^2&(k-1)n_xn_y &(k-1)n_xn_z \\\\
(k-1) {n_xn_y}& 1+(k-1){n_y}^2 & (k-1)n_yn_z \\\\
(k-1) {n_xn_z} & (k-1){n_yn_z} & 1+(k-1){n_z}^2 \\\\
\end{bmatrix}</script><h2 id="Orthographic-Projection"><a href="#Orthographic-Projection" class="headerlink" title="Orthographic Projection"></a>Orthographic Projection</h2><p>正射投影（Orthographic Projection）保证所有原始点和投影点的连线时平行的，如下图所示：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter5-Notes/2020-03-05-16-38-23.png" alt="正射投影"></p>
<h3 id="Projecting-onto-a-Cardinal-Axis-or-Plane"><a href="#Projecting-onto-a-Cardinal-Axis-or-Plane" class="headerlink" title="Projecting onto a Cardinal Axis or Plane"></a>Projecting onto a Cardinal Axis or Plane</h3><p>如果投影到$xy$平面上，那么即沿着$z$轴缩放到0。即将$\hat{n}=\begin{bmatrix}0&amp;0&amp;1\end{bmatrix}$，$k=0$，代入</p>
<script type="math/tex; mode=display">
S(\hat{n},k)=\begin{bmatrix}
1+(k-1) {n_x}^2&(k-1)n_xn_y &(k-1)n_xn_z \\\\
(k-1) {n_xn_y}& 1+(k-1){n_y}^2 & (k-1)n_yn_z \\\\
(k-1) {n_xn_z} & (k-1){n_yn_z} & 1+(k-1){n_z}^2 \\\\
\end{bmatrix}</script><p>得</p>
<script type="math/tex; mode=display">
P_{xy}=S(\begin{bmatrix}0&0&1\end{bmatrix},0)=\begin{bmatrix}
1 & 0 &0 \\\\
0 & 1 &0 \\\\
0 & 0 &0 \\\\
\end{bmatrix}</script><p>同理，可得</p>
<script type="math/tex; mode=display">
P_{xy}=S(\begin{bmatrix}0&1&0\end{bmatrix},0)=\begin{bmatrix}
1 & 0 &0 \\\\
0 & 0 &0 \\\\
0 & 0 &1 \\\\
\end{bmatrix}</script><script type="math/tex; mode=display">
P_{yz}=S(\begin{bmatrix}1&0&0\end{bmatrix},0)=\begin{bmatrix}
0 & 0 &0 \\\\
0 & 1 &0 \\\\
0 & 0 &1 \\\\
\end{bmatrix}</script><h3 id="Projecting-onto-an-Arbitrary-Line-or-Plane"><a href="#Projecting-onto-an-Arbitrary-Line-or-Plane" class="headerlink" title="Projecting onto an Arbitrary Line or Plane"></a>Projecting onto an Arbitrary Line or Plane</h3><p>如果投影到任意平面上，且向量$\hat{n}$垂直于该平面。那么投影实际上是相当于沿着向量$\hat{n}$进行缩放，且缩放系数$k=0$。将其代入沿着任意角度进行缩放的矩阵，即</p>
<script type="math/tex; mode=display">
R(\hat{n})=S(\hat{n},0)=\begin{bmatrix}
1+(0-1) {n_x}^2&(0-1)n_xn_y &(0-1)n_xn_z \\\\
(0-1) {n_xn_y}& 1+(0-1){n_y}^2 & (0-1)n_yn_z \\\\
(0-1) {n_xn_z} & (0-1){n_yn_z} & 1+(0-1){n_z}^2 \\\\
\end{bmatrix} \\\\
=\begin{bmatrix}
1-{n_x}^2&-n_xn_y &-n_xn_z \\\\
-{n_xn_y}& 1-{n_y}^2 & -n_yn_z \\\\
-{n_xn_z} &-{n_yn_z} & 1-{n_z}^2 \\\\
\end{bmatrix}</script><h2 id="Reflection"><a href="#Reflection" class="headerlink" title="Reflection"></a>Reflection</h2><p>反射（Reflection）也称为镜像（Mirroring）是针对一个轴（2D空间）或者一个平面（3D空间）进行反转的操作。</p>
<p>反射操作如下图所示：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter5-Notes/2020-03-05-20-40-40.png" alt="反射操作"></p>
<p>针对于一个平面或一个轴的反射变换，相当于沿着垂直该平面或轴的向量$\hat{n}$进行$k$大小为$-1$的缩放操作。即：</p>
<script type="math/tex; mode=display">
R(\hat{n})=S(\hat{n},0)=\begin{bmatrix}
1+(-1-1) {n_x}^2&(-1-1)n_xn_y &(-1-1)n_xn_z \\\\
(-1-1) {n_xn_y}& 1+(-1-1){n_y}^2 & (-1-1)n_yn_z \\\\
(-1-1) {n_xn_z} & (-1-1){n_yn_z} & 1+(-1-1){n_z}^2 \\\\
\end{bmatrix} \\\\
=\begin{bmatrix}
1-2{n_x}^2&-2n_xn_y &-2n_xn_z \\\\
-2{n_xn_y}& 1-2{n_y}^2 & -2n_yn_z \\\\
-2{n_xn_z} &-2{n_yn_z} & 1-2{n_z}^2 \\\\
\end{bmatrix}</script><h2 id="Shearing"><a href="#Shearing" class="headerlink" title="Shearing"></a>Shearing</h2><p>切变（Shearing）是歪斜（skews）坐标轴的变化，因此有时也会被称为斜变变换（skew transform）。基本思想是把一个方向轴上的元素乘以系数后加到另一个方向轴上。</p>
<p>如$x^{‘}=x+sy$，对应的矩阵为：</p>
<script type="math/tex; mode=display">
H_x(s)=\begin{bmatrix}
    1 & 0 \\\\
    s & 1
\end{bmatrix}</script><p>矩阵中的$s$即对应计算过程$0+s*1$。从矩阵可以看出基本向量$\begin{bmatrix}1 &amp;0 \end{bmatrix}$并没有发生变化，基本向量$\begin{bmatrix}0 &amp;1 \end{bmatrix}$变为了$\begin{bmatrix}s &amp;1 \end{bmatrix}$。</p>
<p>$H_x(s)$表示$x$被$y$轴切变，即$x$轴的值受$y$轴的影响<br>如下图中所示，：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter5-Notes/2020-03-05-21-01-30.png" alt="切变变换"></p>
<p>同理，如果在三维坐标中，$H_{xy}$表示$xy$平面被$z$轴坐标影响。所有的三维空间切变矩阵如下所示：</p>
<script type="math/tex; mode=display">
\mathbf{H_{xy}}(s, t)=\begin{bmatrix}
1 & 0 & 0 \\\\
0 & 1 & 0 \\\\
s & t & 1
\end{bmatrix}</script><script type="math/tex; mode=display">
\mathbf{H_{xz}}(s, t)=\begin{bmatrix}
1 & 0 & 0 \\\\
s & 1 & t \\\\
0 & 0 & 1
\end{bmatrix}</script><script type="math/tex; mode=display">
\mathbf{H_{yz}}(s, t)=\begin{bmatrix}
1 & s & t \\\\
0 & 1 & 0 \\\\
0 & 0 & 1
\end{bmatrix}</script><p>切边是一个比较少用到的变换，因为使用切变变换和缩放变换（无论是均匀还是非均匀）后的图形完全可以通过旋转和非均匀缩放来达成。</p>
<h2 id="Combining-Transformations"><a href="#Combining-Transformations" class="headerlink" title="Combining Transformations"></a>Combining Transformations</h2><p>因为几个变换矩阵的大小是相同的，所以多个变换矩阵可以被结合在一起。如在物体坐标系中的物体，需要转换到世界坐标系中，此时需要用矩阵$\mathbf{M<em>{obj\rightarrow wld}}$，将物体从世界坐标系中转换到摄像机坐标系，需要用到矩阵$\mathbf{M</em>{wld\rightarrow cam}}$</p>
<p>则将物体从物体坐标系转换到摄像机坐标系的表达式如下：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\mathbf{P_{\mathrm{cam}}} &=\mathbf{p_{\mathrm{wld}}} \mathbf{M_{\mathrm{wld} \rightarrow \mathrm{cam}}}\\\\
&=\left(\mathbf{p_{\mathrm{obj}}} \mathbf{M_{\mathrm{obj} \rightarrow \mathrm{wld}}}\right) \mathbf{M_{\mathrm{wld} \rightarrow \mathrm{cam}}}
\end{aligned}</script><p>注意矩阵的相乘是满足结合律的，即上式可以进一步简化为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\mathbf{P_{\mathrm{cam}}} &=\left(\mathbf{p_{\mathrm{obj}}} \mathbf{M_{\mathrm{obj} \rightarrow \mathrm{wld}}}\right) \mathbf{M_{\mathrm{wld} \rightarrow \mathrm{cam}}} \\\\
&=\mathbf{p_{\mathrm{obj}}}\left(\mathbf{M_{\mathrm{obj} \rightarrow \mathrm{wld}}} \mathbf{M_{\mathrm{wld} \rightarrow \mathrm{cam}}}\right)\\\\
&=\mathbf{p_{\mathrm{cam}}}=\mathbf{p_{\mathrm{obj}} }\mathbf{M_{\mathrm{obj} \rightarrow \mathrm{cam}}}
\end{aligned} \\\\</script><h2 id="Classes-of-Transformations"><a href="#Classes-of-Transformations" class="headerlink" title="Classes of Transformations"></a>Classes of Transformations</h2><p>首先需要说明映射和函数的关系。映射指的是输入按照一定的规则变成特定的输出，而函数是用来描述映射关系的。</p>
<p>如将$F$将$a$映射至$b$，可以表示为$F(a)=b$</p>
<h3 id="Linear-Transformations"><a href="#Linear-Transformations" class="headerlink" title="Linear Transformations"></a>Linear Transformations</h3><p>如果$F(a)$是线性变化，那么$F(a)$满足以下特性：</p>
<script type="math/tex; mode=display">\begin{aligned}
F(\mathbf{a}+\mathbf{b}) &=F(\mathbf{a})+F(\mathbf{b})
\\\\
F(k \mathbf{a}) &=k F(\mathbf{a})
\end{aligned}</script><p>线性变换还有两个重要推论：</p>
<ol>
<li><p>如果满足，$F(a)=\mathbf{aM}$，其中$\mathbf{M}$是一个方阵。那么$F(a)$是线性变换。</p>
<p>证明如下：</p>
<script type="math/tex; mode=display">
F(\mathbf{a}+\mathbf{b})=(\mathbf{a}+\mathbf{b}) \mathbf{M}=\mathbf{a} \mathbf{M}+\mathbf{b} \mathbf{M}=F(\mathbf{a})+F(\mathbf{b})\\\\
\text{且，}\\\\
F(k \mathbf{a})=(k \mathbf{a}) \mathbf{M}=k(\mathbf{a} \mathbf{M})=k F(\mathbf{a})</script><p>即满足线性变换的定义</p>
</li>
<li>对于一个线性变换而言，如果输入是零向量，那么输出必然是零向量。<br>证明如下：<br>如果$F(0)=a$,<br>那么$F(K0)=F(0)=a$，且$KF(0)=Ka$<br>如果$a\neq 0$，则$F(k0)\neq KF(0)$，即不满足线性代数的性质二。</li>
</ol>
<blockquote>
<p>在本章的5.1-5.5节所有描述的变换都可以通过一个矩阵完成，所以它们都是线性变换。</p>
</blockquote>
<h3 id="Affine-Transformations"><a href="#Affine-Transformations" class="headerlink" title="Affine Transformations"></a>Affine Transformations</h3><p>仿射变换（Affine Transformation）是在线性变换后加上位移变换，因此仿射变换是线性变换的超集，任何的线性变换都是仿射变换（只不过后面的位移为零）。</p>
<p>任何形式为$\mathbf{v’=vM+b}$的变换都是仿射变换。</p>
<h3 id="Invertible-Transformations"><a href="#Invertible-Transformations" class="headerlink" title="Invertible Transformations"></a>Invertible Transformations</h3><p>如果一个变换是可逆的，即存在一个相反的变换可以重置之前的变换，表达式如下：</p>
<script type="math/tex; mode=display">
F^{-1}(F(\mathbf{a}))=F\left(F^{-1}(\mathbf{a})\right)=\mathbf{a}</script><p>因为位移操作必然是可逆的，所以仿射变换是否可逆的关键在于线性变换是否可逆。主要的线性变换，除了投影外都是可逆的，因为投影变换将一个维度的数值变为了零，即一个维度的数据消失了。</p>
<p>找出一个变换的相反操作，相当于找出这个变换矩阵的逆矩阵。如果一个矩阵没有逆矩阵，称这个矩阵为奇异矩阵（或退化矩阵，singular matrix）。一个奇异矩阵的行列式为零。</p>
<p>在非奇异矩阵中（存在逆矩阵的矩阵），当且仅当输入为零向量时，输出才会是零向量。而在奇异矩阵中，有一系列的输入向量都会导致输出为零向量，这些输入向量称为矩阵的零空间（Null Space）。在投影矩阵中，垂直于投影平面的所有向量都在零空间中，因为这些向量在投影后会变成一个点。</p>
<p>对于一个方阵，如果它的基础向量（因为本书用的是行向量，所以相当于每一行，如果用的是列向量则相当于每一列）是线性相关的，则这个矩阵是歧义矩阵，即不存在逆矩阵。</p>
<h3 id="Angle-Preserving-Transformations"><a href="#Angle-Preserving-Transformations" class="headerlink" title="Angle-Preserving Transformations"></a>Angle-Preserving Transformations</h3><p>如果一个变换是保角变换（Angle-Preserving Transformation），那么在变换前后图形中的两个向量的夹角是不会发生变换的。</p>
<p>只有位移，旋转，和均匀缩放是保角变换。对于反射变换，虽然角度的绝对值不会发生改变，但是角度的方向发生了改变，因此也不能算是保角变换。</p>
<p>所有的保角变换都是仿射变换且都是可逆的。</p>
<h3 id="Orthogonal-Transformations"><a href="#Orthogonal-Transformations" class="headerlink" title="Orthogonal Transformations"></a>Orthogonal Transformations</h3><p>正交变换（Orthogonal Transformation）可以很容易的求出反变换，所以被使用的频率很高。</p>
<p>正交变换保证变换前后，图像的长度，角度的绝对值，面积和体积不会发生改变。</p>
<p>只有位移，旋转和反射是正交变换。</p>
<p>所有的正交变换都是可逆的，且是仿射变换。</p>
<h3 id="Rigid-Body-Transformations"><a href="#Rigid-Body-Transformations" class="headerlink" title="Rigid Body Transformations"></a>Rigid Body Transformations</h3><p>刚体变换（Rigidbody Transformation，proper transformations）只改变图像的位置和角度，但不会改变其形状。位移和旋转是唯二的刚体变换，反射变换因为改变了图形的角度方向所以不是刚体变换。</p>
<p>刚体变换几乎是最严格的变换。所有的刚体变换，都是正交的，保角的，可逆的和仿射的。</p>
<p>刚体变换的行列式大小为1。</p>
<h3 id="Summary-of-Types-of-Transformations"><a href="#Summary-of-Types-of-Transformations" class="headerlink" title="Summary of Types of Transformations"></a>Summary of Types of Transformations</h3><p>所有变换的总截图如下，Y表示必然满足，空白处表示不一定满足。</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter5-Notes/image-20200306141537944.png" alt="变换总结"></p>
<div class="note info simple"><p>引用：</p>
<ol>
<li><em>3D Math Primer for Graphics and Game Development</em> 2nd 2011 </li>
</ol>
</div>
<hr>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>3D数学</tag>
      </tags>
  </entry>
  <entry>
    <title>《3D数学基础：图形和游戏开发》第一章笔记</title>
    <url>/3DMathPrimerForGraphicsAGameDevelopment-Chapter1-Notes/</url>
    <content><![CDATA[<hr>
<p>《3D数学基础：图形和游戏开发》第一章笔记</p>
<p>关于笛卡尔坐标系的介绍，如三维坐标种的左右手坐标系。</p>
<p>一些三角函数的介绍。</p>
<span id="more"></span>
<h1 id="Chapter-1"><a href="#Chapter-1" class="headerlink" title="Chapter 1"></a>Chapter 1</h1><p>在计算机三维数学和三维坐标的计算中，用的最频繁的框架就是笛卡尔坐标系（Cartesian coordinate system）。</p>
<h2 id="1D-Mathematics"><a href="#1D-Mathematics" class="headerlink" title="1D Mathematics"></a>1D Mathematics</h2><p>有理数（Rational numbers）定义：可以表示为两个整数的比<br>实数定义：包括有理数和无理数（例如$\pi$）</p>
<p>对于自然数和整数的研究称作为离散数学（Discrete Mathematics），对于实数的学习称为连续数学（Continuous Mathematics）。</p>
<div class="note info simple"><p>图形学第一定理：如果看起来结果是对的，那么就是对的</p>
<p>If it looks right, it is right.</p>
</div>
<h2 id="2D-Cartesian-Space"><a href="#2D-Cartesian-Space" class="headerlink" title="2D Cartesian Space"></a>2D Cartesian Space</h2><p>坐标轴的长度是无限的。</p>
<p>对于二维坐标而言，无论X轴和Y轴选取的方向如何，都能通过旋转（包括翻转）将其互相转换。如下图是二维坐标的一共8种可能（当X轴选定一个方向（X轴的选择有六种可能）时，Y轴因为必须与X轴垂直，所以只有两种可能，正向或反向）：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter1-Notes/2020-02-24-19-18-36.png" alt="二维坐标8种可能性"></p>
<p>所以从某种角度而言，所有的二维坐标都是等效的。</p>
<h2 id="3D-Cartesian-Space"><a href="#3D-Cartesian-Space" class="headerlink" title="3D Cartesian Space"></a>3D Cartesian Space</h2><p>所有的二维坐标是等效的，但所有的三维坐标并不是等效的。可以通过旋转或反转将三维坐标中的两个匹配，但在这种情况下第三个坐标的方向可能是反的。</p>
<blockquote>
<p>三维坐标一共有48种可能（Z轴一共有6种可能，X和Y构成二维坐标，有8种可能，6*8 = 48）。</p>
</blockquote>
<p>因此所有的三维坐标被分为两组，一组被称为左手坐标系（Left-handed coordinate spaces），另一组被称为右手坐标系（Right-handed coordinate spaces）。左右手坐标系只是不同的选择，两者其他方面的差异。</p>
<p>如下图所示，左边为左手坐标系，右边为右手坐标系。</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter1-Notes/2020-02-24-19-28-49.png" alt="左手，右手坐标系"></p>
<p>在每个坐标系下，如图所示，食指，中指，大拇指相互垂直，大拇指指向X轴正方向，食指指向Y轴正方向，中指指向Z轴正方向。</p>
<p>左右手坐标系还会影响<code>旋转的正方向</code>。在每个坐标系下，如果要绕着某个轴旋转，用大拇指指向该轴的正方向，四指环绕方向即为旋转的正方向。</p>
<div class="note warning simple"><p>这本书下的例子都是以左手坐标系为准的。</p>
</div>
<h2 id="Odds-and-Ends"><a href="#Odds-and-Ends" class="headerlink" title="Odds and Ends"></a>Odds and Ends</h2><h3 id="Summation-and-Product-Notation"><a href="#Summation-and-Product-Notation" class="headerlink" title="Summation and Product Notation"></a>Summation and Product Notation</h3><p>累加符号：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{n}a_i</script><p>累乘符号:</p>
<script type="math/tex; mode=display">
\prod_{i=1}^{n}a_i</script><h3 id="间隔符号"><a href="#间隔符号" class="headerlink" title="间隔符号"></a>间隔符号</h3><p>$[a,b]$表示$a\leq x\leq b$</p>
<p>$(a,b)$表示$a&lt;x&lt;b$</p>
<p>$[a,b)$表示$a\leq x &lt;b$</p>
<p>$(a,b]$表示$a&lt;x\leq b$</p>
<h3 id="Angles-Degrees-and-Radians"><a href="#Angles-Degrees-and-Radians" class="headerlink" title="Angles,Degrees, and Radians"></a>Angles,Degrees, and Radians</h3><p>角度（Angles）在日常生活中用的比较多，但是在数学上弧度（Radians）用的更多。</p>
<p>当提及弧度，实际上是计算某角度在半径为1的圆上所占的长度。因为半径为1的圆周长为$2\pi$，所以$360^\circ = 2\pi 弧度$。</p>
<p>弧度与角度的转换关系如下：</p>
<script type="math/tex; mode=display">
1\text{ rad} = (180/\pi)^\circ \approx 57.29578^\circ \\\\
1 ^ \circ = (\pi /180) \text{ rad} \approx 0.01745329 \text{ rad}</script><h3 id="Trig-Functions"><a href="#Trig-Functions" class="headerlink" title="Trig Functions"></a>Trig Functions</h3><p>对于在半径为1的圆上的点$（x,y）$，$\theta$为该点与原点形成的向量与X轴正方向的夹角，则</p>
<script type="math/tex; mode=display">
x = \cos(\theta) \\\\
y = \sin(\theta) \\\\</script><h3 id="Trig-Identities"><a href="#Trig-Identities" class="headerlink" title="Trig Identities"></a>Trig Identities</h3><ol>
<li>基本转换</li>
</ol>
<script type="math/tex; mode=display">
\sin(-\theta)=-\sin\theta\\\\
\cos(-\theta)=\cos\theta\\\\
\tan(-\theta)=-\tan\theta \\\\
\sin(\frac{\pi}{2}-\theta) = \cos\theta\\\\
\cos(\frac{\pi}{2}-\theta) = \sin\theta\\\\
\tan(\frac{\pi}{2}-\theta) = \cot\theta\\\\
\cos \theta = -\cos(180-\theta)\\\\
\sin \theta = \sin (180-\theta)</script><ol>
<li><p>勾股定理</p>
<script type="math/tex; mode=display">
\sin^2\theta+cos^2\theta=1 \\\\
1 + \tan^2\theta = \sec^2\theta \\\\
1 + \cot^2\theta = csc^2 \theta</script></li>
<li></li>
</ol>
<script type="math/tex; mode=display">
\sin(a+b) = \sin a \cos b + \cos a\sin b \\\\
\sin(a-b) = \sin a \cos b - \ cos a \sin b \\\\
\cos(a+b) = \cos a \cos b -\sin a \sin b \\\\
\cos(a-b) = \cos a \cos b + \sin a \sin b \\\\
\tan(a+b) = \frac{tan a+ tan b}{1- \tan a\tan b } \\\\
\tan(a-b) = \frac{tan a - tan b }{1+ \tan a \tan b} \\\\</script><ol>
<li>两倍角定理<script type="math/tex; mode=display">
\sin 2\theta = 2\sin \theta \cos \theta \\\\
\cos 2\theta = \cos ^2 \theta-\sin^2\theta=2cos^2\theta-1=1-2sin^2\theta \\\\
\tan 2 \theta=\frac{2\tan \theta}{1- \tan^2\theta}</script></li>
</ol>
<ol>
<li><p>正弦定理</p>
<p>对于如下的三角形，有：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter1-Notes/2020-02-24-20-37-18.png" alt="正弦三角形"></p>
<script type="math/tex; mode=display">
\frac{\sin A}{a} = \frac{\sin B}{b}=\frac{\sin C}{c}</script></li>
<li><p>余弦定理<br>对于上面的三角形，有</p>
<script type="math/tex; mode=display">
a^2=b^2+c^2-2bc\cos A, \\\\
b^2 = a^2 +c^2 - 2ac \cos B, \\\\
c^2 = a^2 +b^2 -2ab \cos C.</script></li>
</ol>
<div class="note info simple"><p>引用：</p>
<ol>
<li><em>3D Math Primer for Graphics and Game Development</em> 2nd 2011 </li>
</ol>
</div>
<hr>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>3D数学</tag>
      </tags>
  </entry>
  <entry>
    <title>《3D数学基础：图形和游戏开发》第七章笔记</title>
    <url>/3DMathPrimerForGraphicsAGameDevelopment-Chapter7-Notes/</url>
    <content><![CDATA[<p>《3D数学基础：图形和游戏开发》第七章笔记</p>
<p>7.1节 介绍2D极坐标</p>
<p>7.2节 介绍哪些问题下极坐标比笛卡尔坐标更有用</p>
<p>7.3节 介绍极坐标如何在3D中工作，并介绍圆柱坐标系和球坐标系</p>
<p>7.4节 介绍在极坐标系中点和线段的关系</p>
<span id="more"></span>
<h1 id="Chapter-7-Polar-Coordinate-Systems"><a href="#Chapter-7-Polar-Coordinate-Systems" class="headerlink" title="Chapter 7 Polar Coordinate Systems"></a>Chapter 7 Polar Coordinate Systems</h1><h2 id="2D-Polar-Space"><a href="#2D-Polar-Space" class="headerlink" title="2D Polar Space"></a>2D Polar Space</h2><h3 id="Locating-Points-by-Using-2D-Polar-Coordinates"><a href="#Locating-Points-by-Using-2D-Polar-Coordinates" class="headerlink" title="Locating Points by Using 2D Polar Coordinates"></a>Locating Points by Using 2D Polar Coordinates</h3><p>在笛卡尔坐标系下，有两个轴分别表示$x,y$，但在极坐标系下只有一个轴，成为极轴（Polar axis），表示从原点发出的一条射线。在数学中，极轴是指向右侧的，即笛卡尔坐标系下$+x$轴的方向。如下图所示：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter7-Notes/2020-04-01-06-40-37.png" alt="极坐标系"></p>
<p>极坐标系通过一个标量$r$距离原点的距离，一个角度$\theta$表示与初始极轴的夹角，其中角度的正方向是逆时针。通过$(r,\theta)$来表示二维极坐标中的一个点，位置为极轴先逆时针转动$\theta$角度，然后再在极轴上移动$r$，如下所示：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter7-Notes/2020-04-01-06-43-01.png" alt="极坐标表示"></p>
<p>上图极坐标系图中的同心圆，表示$r$相同的点的集合，图中的直线则表示$\theta$相同的点的集合。</p>
<p>极坐标系中的单位可以是弧度，也可以是角度，只要保证使用时统一一个单位即可。在本书中使用角度。</p>
<h3 id="Aliasing"><a href="#Aliasing" class="headerlink" title="Aliasing"></a>Aliasing</h3><p>在笛卡尔坐标系下，一个点只有一个表示。但是在极坐标系下，一个点有无数个表示。如过两个表示实际上是指同一个点，那么称这两个表示互为对方的别名（Aliases）。</p>
<p>如果有点表示为$(r,\theta)$，那么所有它的别名可以表示为$\left((-1)^{k} r, \theta+k 180^{\circ}\right)$，其中$k$为任何整数。</p>
<p>极坐标中还有歧义性（singularity），即当$r=0$时，无论$\theta$取何值，结果都没有区别。</p>
<p>别名和歧义性本身并不会引发任何问题，只不过表达起来存在困难而已。但就如$13/26$通常表示为$1/2$一样，在极坐标系中也有一个通常的表示法，成为正则坐标（canonical coordinate）。一个正则表达是$r$为非负，且$\theta$的范围在$\left(-180^{\circ}, 180^{\circ}\right]$中。如果表达$(r,\theta)$满足以下的三个条件，那么这个表达就是正则坐标：</p>
<script type="math/tex; mode=display">
\begin{cases}
  r \geq 0 & \\
  -180^{\circ} < \theta \leq 180 ^{\circ} & 如果极轴指向左侧，则\theta=180^{\circ} \\
  r=0 \Rightarrow \theta=0 & 
\end{cases}</script><p>以下的方法可以将一个非正则坐标转换为正则坐标：</p>
<ol>
<li>当$r=0$时，$\theta =0$</li>
<li>当$r&lt;0$时，$r=-r, \theta=\theta +180^{\circ}$</li>
<li>当$\theta \leq -180^{\circ}$，$\theta =\theta +k360 ^{\circ}$，$k$为第一个让$\theta &gt; -180^{\circ}$的值</li>
<li>当$\theta &gt; -180^{\circ}$，$\theta =\theta -k360 ^{\circ}$，$k$为第一个让$\theta \leq -180^{\circ}$的值</li>
</ol>
<h3 id="Converting-between-Cartesian-and-Polar-Coordinates-in-2D"><a href="#Converting-between-Cartesian-and-Polar-Coordinates-in-2D" class="headerlink" title="Converting between Cartesian and Polar Coordinates in 2D"></a>Converting between Cartesian and Polar Coordinates in 2D</h3><p>二维极坐标系和笛卡尔坐标系的转换可以参考下图：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter7-Notes/2020-04-01-07-10-57.png" alt="坐标系转换"></p>
<p>极坐标系转换为笛卡尔坐标系表达式如下：</p>
<script type="math/tex; mode=display">x=r \cos \theta \quad y=r \sin \theta</script><p>笛卡尔坐标系转换为极坐标系表达式如下：</p>
<script type="math/tex; mode=display">r=\sqrt{x^{2}+y^{2}} \quad  \theta=\arctan (y / x)</script><p>其中，$\theta=\arctan (y / x)$是由$\frac{y}{x}=\frac{r\sin \theta}{r \cos \theta}$化简得来。</p>
<p>但$\arctan (y / x)$的表达式存在两个问题，第一是当$x=0$时，表达式的除法是未定义的。第二是$\arctan$的范围为$\left[-90^{\circ},+90^{\circ}\right]$。这个原因是$\frac{y}{x}$隐藏了一部分信息：$x和y$分别存在正负，所以一共有4种组合，但是$\frac{y}{x}$却只有两个结果。</p>
<p>在书中，作者定义了函数$atan2$，其定义为：</p>
<script type="math/tex; mode=display">\operatorname{atan} 2(y, x)=\left\{\begin{array}{ll}
0, & x=0, y=0 \\
+90^{\circ}, & x=0, y>0 \\
-90^{\circ}, & x=0, y<0 \\
\arctan (y / x), & x>0 \\
\arctan (y / x)+180^{\circ}, & x<0, y \geq 0 \\
\arctan (y / x)-180^{\circ}, & x<0, y<0
\end{array}\right.</script><p>此时，笛卡尔转换为极坐标系可以表示为：</p>
<script type="math/tex; mode=display">r=\sqrt{x^{2}+y^{2}} ; \quad \quad \theta=\operatorname{atan} 2(y, x)</script><h2 id="Why-Would-Anybody-Use-Polar-Coordinates"><a href="#Why-Would-Anybody-Use-Polar-Coordinates" class="headerlink" title="Why Would Anybody Use Polar Coordinates"></a>Why Would Anybody Use Polar Coordinates</h2><p>人们本能上会觉得笛卡尔坐标系更熟悉，但是日常生活中实际上使用更多的是极坐标系，如“往西走50米”，这个描述就是极坐标系（方位+距离）。但是在电脑的计算中，使用较多的是笛卡尔坐标系。</p>
<p>在游戏和物理中，如果一个变换只关注角度和距离，那么极坐标系是比较好的选择。<br>另外在球表面上的计算，也通常使用极坐标系，如经度、维度，实际上就是球坐标系下的表示。</p>
<h2 id="3D-Polar-Space"><a href="#3D-Polar-Space" class="headerlink" title="3D Polar Space"></a>3D Polar Space</h2><p>在2D极坐标系下，两个变量分别是距离$r$和角度$\theta$，当扩展为3D极坐标时，第三个变量可以是距离$z$，此时变为了圆柱坐标系，也可以是$\phi$，此时变为了球坐标系。</p>
<h3 id="Cylindrical-Coordinates"><a href="#Cylindrical-Coordinates" class="headerlink" title="Cylindrical Coordinates"></a>Cylindrical Coordinates</h3><p>圆柱坐标系以及点$(r,\theta,\phi)$的表示如下图所示：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter7-Notes/2020-04-01-07-32-32.png" alt="圆柱坐标系"></p>
<p>可以看到，第三个变量$z$是垂直于2D极坐标平面的，当$z=0$时，即为2D极坐标平面。</p>
<h3 id="Spherical-Coordinates"><a href="#Spherical-Coordinates" class="headerlink" title="Spherical Coordinates"></a>Spherical Coordinates</h3><p>球坐标系在使用中更为常见。球坐标系下第三个变量仍然表示角度且命名为$\phi$。$phi$的初始方向为垂直向上，旋转正方向为绕着极轴顺时针向下，如下图所示：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter7-Notes/2020-04-01-07-41-14.png" alt="球坐标系"></p>
<p>$\theta$被称为方位角（Azimuth），$\phi$被称为天顶角（Zenith）。在地球仪中经度（Longitude）对应的为$\theta$，维度（Latitude）对应的为$90^{\circ}-\phi$，海拔（Altitude）对应$r$。</p>
<h3 id="Some-Polar-Conventions-Useful-in-3D-Virtual-Worlds"><a href="#Some-Polar-Conventions-Useful-in-3D-Virtual-Worlds" class="headerlink" title="Some Polar Conventions Useful in 3D Virtual Worlds"></a>Some Polar Conventions Useful in 3D Virtual Worlds</h3><p>之前章节描述的是数学层面上的极坐标系，但在3D游戏的使用中，数学层面的极坐标系存在以下问题：</p>
<ol>
<li>$\theta =0$的位置，对应的是$+x$方向，但希望对应的方向是$+z$方向。</li>
<li>$\phi =0$的位置，对应的是$+y$方向，但这样的话当$\phi=0$时，并不等于二维的极坐标系。而在$(r,\theta,90^{\circ})$时才等同于二维坐标系。</li>
<li>$\theta$和$\phi$不方便记忆。</li>
</ol>
<p>为此，3D游戏中的极坐标系做了如下改变</p>
<ol>
<li>水平角$\theta$命名为$h$(heading)，且当$h=0$时指向$+z$方向。旋转正方向从Y轴正方向看为顺时针</li>
<li>垂直角$\phi$命名为$p$(pitch)，当$p=0$时，为水平角度，旋转正方向为向下。</li>
</ol>
<p>3D游戏中的极坐标系如下图所示：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter7-Notes/2020-04-01-08-29-48.png" alt="3D游戏极坐标系"></p>
<h3 id="Aliasing-of-Spherical-Coordinates"><a href="#Aliasing-of-Spherical-Coordinates" class="headerlink" title="Aliasing of Spherical Coordinates"></a>Aliasing of Spherical Coordinates</h3><p>三维坐标中同样存在别名和歧义性。</p>
<ol>
<li>当r取反时，$h+k180^{\circ}$，并且$p=-p$即能获得一样的值（别名）</li>
<li>当$r=0$时，$h$和$p$取任意值都没有区别。（歧义性）</li>
<li>$(h,p)$可以表示为$\left(h \pm 180^{\circ}, 180^{\circ}-p\right)$（别名）<br>如h向右转90°，p向下转45°，等同于h向左转90°，p向下转135°。</li>
<li>当$p=\pm 90^{\circ}$时，$h$取任意值没有区别（歧义性）（万向锁，gimbal lock）。</li>
</ol>
<p>同样如在二维极坐标中一样，可以通过正则坐标来消除歧义和别名，三维极坐标系的正则坐标满足以下条件：</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{l}
r \geq 0 \\
-180^{\circ}<h \leq 180^{\circ}  & 指向后侧时，h=180^{circ} \\
-90^{\circ} \leq p \leq 90^{\circ} \\
r=0 \Rightarrow h=p=0 \\
|p|=90^{\circ} \Rightarrow h=0
\end{array}\right.</script><p>可以通过以下方法，将普通三维极坐标转换为正则坐标</p>
<ol>
<li>当$r=0$,$h=p=0$</li>
<li>当$r &lt;0$，$h=h+180^{\circ},p=-p$</li>
<li>当$p&lt;-90^{\circ}$,$p=p+k360^{\circ}$，直到$p\geq -90^{\circ}$</li>
<li>当$p&gt;270^{\circ}$,$p=p-k360^{\circ}$，直到$p\leq 270^{\circ}$</li>
<li>当$p&gt;90^{\circ}$,$h=h+180^{\circ}$,$p=180^{\circ}-p$</li>
<li>当$h \leq -180^{\circ}$,$h=h+k360^{\circ}$，直到$h &gt; -180^{\circ}$</li>
<li>当$h &gt; 180^{\circ}$,$h=h-k360^{\circ}$，直到$h \leq 180^{\circ}$</li>
</ol>
<h3 id="Converting-between-Spherical-and-Cartesian-Coordinates"><a href="#Converting-between-Spherical-and-Cartesian-Coordinates" class="headerlink" title="Converting between Spherical and Cartesian Coordinates"></a>Converting between Spherical and Cartesian Coordinates</h3><p>球坐标系与笛卡尔坐标系的转换图如下所示（数学层面）：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter7-Notes/2020-04-01-09-09-30.png" alt="球坐标与笛卡尔坐标转换"></p>
<p>其中</p>
<script type="math/tex; mode=display">
x=r \sin \phi \cos \theta, \quad y=r \sin \phi \sin \theta, \quad z=r \cos \phi</script><p>求解过程如下：</p>
<p>$z=r \cos \phi$很容易从图中看出，关键是求得$x和y$的表达式。当$\phi=90^{\circ}$时，即为二维的球坐标系，有</p>
<script type="math/tex; mode=display">x^{\prime}=r \cos \theta, \quad y^{\prime}=r \sin \theta</script><p>根据，相似三角形性质，可得</p>
<script type="math/tex; mode=display">x / x^{\prime}=y / y^{\prime}=d / r</script><p>又有$d / r=\sin \phi$</p>
<p>所以可以求得</p>
<script type="math/tex; mode=display">
x=r \sin \phi \cos \theta, \quad y=r \sin \phi \sin \theta, \quad</script><p>如果是求3D游戏转换的球坐标系，可得</p>
<script type="math/tex; mode=display">x=r \cos p \sin h, \quad y=-r \sin p, \quad z=r \cos p \cos h</script><p>笛卡尔坐标系转换为球坐标系如下：</p>
<script type="math/tex; mode=display">
r=\sqrt{x^{2}+y^{2}+z^{2}} \\
h=\operatorname{atan} 2(x, z) \\
p=\arcsin (-y / r)</script><h2 id="Using-Polar-Coordinates-to-Specify-Vectors"><a href="#Using-Polar-Coordinates-to-Specify-Vectors" class="headerlink" title="Using Polar Coordinates to Specify Vectors"></a>Using Polar Coordinates to Specify Vectors</h2><p>实际上，极坐标系的描述就线段的描述（方向+距离）。</p>
<p>一切上述的极坐标的点的描述，都可以直接转换为对线段的描述。</p>
<div class="note info simple"><p>引用：</p>
<ol>
<li><em>3D Math Primer for Graphics and Game Development</em> 2nd 2011 </li>
</ol>
</div>
<hr>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>3D数学</tag>
      </tags>
  </entry>
  <entry>
    <title>《3D数学基础：图形和游戏开发》第九章笔记</title>
    <url>/3DMathPrimerForGraphicsAGameDevelopment-Chapter9-Notes/</url>
    <content><![CDATA[<p>《3D数学基础：图形和游戏开发》第九章笔记</p>
<p>9.1节 关于图形的表示法分类</p>
<p>9.2节 介绍了射线</p>
<p>9.3节 介绍了球和圆</p>
<p>9.4节 介绍了边界盒</p>
<p>9.5节 介绍了平面</p>
<p>9.6节 介绍了三角形</p>
<p>9.7节 介绍了多边形</p>
<span id="more"></span>
<h1 id="Chapter-9-Geometric-Primitives"><a href="#Chapter-9-Geometric-Primitives" class="headerlink" title="Chapter 9 Geometric Primitives"></a>Chapter 9 Geometric Primitives</h1><h2 id="Representation-Techniques"><a href="#Representation-Techniques" class="headerlink" title="Representation Techniques"></a>Representation Techniques</h2><p>这一节介绍不同的用来表达基本图形的方法：</p>
<p>第一种是隐式表达（Implicit form），即用一个等式或不等式来描述关系，如下式是描述球的，当为等号时，说明点在球面上，如果小于则说明点在球内，大于说明点在球外。</p>
<script type="math/tex; mode=display">x^{2}+y^{2}+z^{2}=1</script><p>第二种表达式为参数化表达（Parametric form），如下式为参数化表达圆，其中$t$为的参数，通常来说参数的数值为$[0,1]$</p>
<script type="math/tex; mode=display">x(t)=\cos 2 \pi t, \quad y(t)=\sin 2 \pi t</script><p>参数化表达圆的示意图如下：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter9-Notes/2020-04-07-15-50-37.png" alt="参数化圆"></p>
<p>参数化表达可以进一步细分为一元表达（univariate）， 即只有一个参数，和二元表达（bivariate），即有两个参数。一元表达描述的是一个曲线，二元表达描述的是一个曲面。</p>
<p>第三种表达方式是直接表达，但这种表达没有统一的形式。如使用两个点来描述一条直线，用半径和圆心来描述一个圆。</p>
<h2 id="Lines-and-Rays"><a href="#Lines-and-Rays" class="headerlink" title="Lines and Rays"></a>Lines and Rays</h2><p>从数学角度来说，关于线条有三个定义：</p>
<ol>
<li>直线是用来描述一个朝正反方向都无限延伸的线</li>
<li>线段是用来描述由确切两个点构成的有限长度的线。这两个点并没有起点和终点之分，即不存在方向。</li>
<li>射线是用来描述有一个起点，和朝一个方向无限延伸的线。</li>
</ol>
<p>从几何角度来说</p>
<ol>
<li>直线描述与数学角度相同</li>
<li>线段描述与数学角度相同</li>
<li>射线是用来描述一个有方向的线段，即存在起点和终点的概念。</li>
</ol>
<p>在电子游戏中，通常只使用射线，直线和线段的概念很少出现。</p>
<h3 id="Rays"><a href="#Rays" class="headerlink" title="Rays"></a>Rays</h3><ol>
<li>如果用直接方法定义射线，直接给定终点和起点即可，$\mathbf{P}<em>{org}$和$\mathbf{P}</em>{end}$</li>
<li><p>用参数化表达射线，表达式如下</p>
<script type="math/tex; mode=display">\mathbf{p}(t)=\mathbf{p}_{0}+t \mathbf{d}</script><p>其中，$\mathbf{P}_0$为起点，$\mathbf{d}$为射线的有向长度，参数$t$的取值范围是$[0,1]$</p>
<p>射线的参数化表达也可以进一步拆分为两部分，即分别描述x分量和y分量</p>
<script type="math/tex; mode=display">x(t)=x_{0}+t \Delta x, \quad y(t)=y_{0}+t \Delta y</script><p>可以看出这个表达存在四个自由度，分别是$x_0$和$y_0$表示起点和$\Delta x$和$\Delta y$表示一个分量上的有向长度。</p>
</li>
</ol>
<h3 id="Special-2D-Representation-of-Lines"><a href="#Special-2D-Representation-of-Lines" class="headerlink" title="Special 2D Representation of Lines"></a>Special 2D Representation of Lines</h3><p>这一节介绍一些二维射线的特殊表达</p>
<ol>
<li><p>截距形式（Slope-interpret form）</p>
<script type="math/tex; mode=display">y=m x+y_{0}</script><p>其中$m$表示射线的斜率(rise/run)，$y_0$表示截距（y-intercept），如下图所示</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter9-Notes/2020-04-07-16-11-00.png" alt="截距形式" style="zoom:67%;" /></p>
<p>截距形式的问题在于，它无法表达沿着Y轴向上的射线。</p>
</li>
<li><p>隐式表达（Implicit definition）</p>
<p>射线的隐式表达实际上相当于截距形式的变形</p>
<script type="math/tex; mode=display">a x+b y=d</script><p>而且隐式表达可以进一步使用向量的点乘表达，</p>
<script type="math/tex; mode=display">\mathbf{p} \cdot \mathbf{n}=d</script><p>其中$\mathbf{n}=[a, b]$表示射线的法线方向，且是一个单位向量。</p>
<p>$\mathbf{p}=[x,y]$表示射线上的点。</p>
<p>$d$表示射线沿着$\mathbf{n}$方向上离原点的距离。</p>
<p>如下所示：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter9-Notes/2020-04-07-16-27-22.png" alt="隐式表达"></p>
</li>
<li><p>垂直线等分法：<br>该方法定义两个点$\mathbf{q,r}$，射线用来描述距离这两个点距离相等的点的几何。如下图所示：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter9-Notes/2020-04-07-16-31-22.png" alt="垂直线等分法"></p>
</li>
</ol>
<h3 id="Converting-between-Representations"><a href="#Converting-between-Representations" class="headerlink" title="Converting between Representations"></a>Converting between Representations</h3><p>直接表达法：</p>
<script type="math/tex; mode=display">\mathbf{P}_{end}和\mathbf{P}_{org}</script><p>截距法：</p>
<script type="math/tex; mode=display">y=m x+y_{0}</script><p>隐式表达法：</p>
<script type="math/tex; mode=display">a x+b y=d</script><p>向量表达法：</p>
<script type="math/tex; mode=display">\mathbf{p} \cdot \mathbf{n}=d</script><p>垂直线等分法法：</p>
<script type="math/tex; mode=display">与点\mathbf{q}和点\mathbf{r}距离相同的点的合集</script><p>上述相互之间的转换方法为：</p>
<ol>
<li><p>直接表达法与隐式表达法的转换</p>
<p>直接表达即为通过两个点$\mathbf{P}<em>{end}$和$\mathbf{P}</em>{org}$来描述一条射线，为了将其转换为隐式表达法首先需要计算出两点之间的有向距离</p>
<script type="math/tex; mode=display">\mathbf{d}=\mathbf{p}_{\text {end }}-\mathbf{p}_{\text {org }}</script><p>$\mathbf{d}$不仅表示两点间的距离还表示两点间的方向</p>
<p>因此如果表示为截距法，那么射线的斜率为$m=d<em>y/d_x$，将点$\mathbf{P}_org$代入式子中，可以求得$y_0=y</em>{org}-\frac{d<em>y}{d_x}x</em>{org}$</p>
<p>转换为隐式表达法则有：</p>
<script type="math/tex; mode=display">a=d_{y}, \quad b=-d_{x}, \quad d=x_{\text {org }} d_{y}-y_{\text {org }} d_{x}</script></li>
<li><p>隐式表达法和截距法的转换</p>
<p>使用隐式表达法中的$a,b,d$来描述截距法，则有<br>$y=-\frac{a}{b}x+\frac{d}{b}$</p>
</li>
<li><p>隐式表达法求射线的法线和距离</p>
<p>隐式表达法可以直接转换为向量形式的表达，即</p>
<script type="math/tex; mode=display">a x+b y=\mathbf{p} \cdot \mathbf{n}=[x \quad y]\cdot[a \quad b]=d</script><p>即$\mathbf{n}t[a \quad b]$，如果将其转换为单位向量，即</p>
<script type="math/tex; mode=display">\hat{\mathbf{n}}=[a \quad b]/\sqrt{a^2+b^2}</script><p>如果用$\hat{\mathbf{n}}$作为表达式，则原表达式两边都要等除$\sqrt{a^2+b^2}$，即</p>
<script type="math/tex; mode=display">
[x \quad y]\cdot \frac{[a \quad b]}{\sqrt{a^2+b^2}}=\frac{d}{\sqrt{a^2+b^2}}</script><script type="math/tex; mode=display">
[x \quad y]\cdot \hat{\mathbf{n}}=distance</script><p>其中$\hat{\mathbf{n}}$为射线的法线，$distance$为射线沿着法线方向与原点的距离。</p>
</li>
<li><p>垂直线等分法转换为隐式表达法</p>
<p>有两个点$\mathbf{q}和点\mathbf{r}$，其中$\mathbf{r}$是x轴分量更大的点。</p>
<p>可以得到由这两个点构成的线段的斜率为$r<em>{y}-q</em>{r}/r<em>{x}-q</em>{x}$，因为所求的射线，即这两个点中间的垂直线斜率相反，所以可以得到所求射线的斜率$m=q<em>{r}-r</em>{y}/r<em>{x}-q</em>{x}$</p>
<p>转换为隐形表达式，则可得：</p>
<script type="math/tex; mode=display">\begin{aligned}
&a=q_{y}-r_{y}\\
&b=r_{x}-q_{x}
\end{aligned}</script><p>点$\mathbf{q}和点\mathbf{r}$的中点在所求射线上，且该中点为$\mathbf{q}+\frac{\mathbf{r-q}}{2}=\frac{\mathbf{q+r}}{2}$，将该点带入隐形表达式，可得</p>
<script type="math/tex; mode=display">d=\frac{\mathbf{q}+\mathbf{r}}{2} \cdot\left[\begin{array}{ll}
a & b
\end{array}\right]</script><p>进一步化简得：</p>
<script type="math/tex; mode=display">\begin{aligned}
d &=\frac{\mathbf{q}+\mathbf{r}}{2}    \cdot\left[\begin{array}{cc}
a & b
\end{array}\right]=\frac{\mathbf{q} +\mathbf{r}}{2} \cdot\left[\begin{array}   {cc}
q_{y}-r_{y} & r_{x}-q_{x}
\end{array}\right] \\
&=\frac{\left(q_{x}+r_{x}\right)\left(q_  {y}-r_{y}\right)+\left(q_{y}+r_{y}\right)   \left(r_{x}-q_{x}\right)}{2} \\
&=\frac{\left(q_{x} q_{y}-q_{x} r_{y}+r_  {x} q_{y}-r_{x} r_{y}\right)+\left(q_{y}    r_{x}-q_{y} q_{x}+r_{y} r_{x}-r_{y} q_{x} \right)}{2} \\
&=r_{x} q_{y}-q_{x} r_{y}
\end{aligned}</script></li>
</ol>
<h2 id="Sphere-and-Circles"><a href="#Sphere-and-Circles" class="headerlink" title="Sphere and Circles"></a>Sphere and Circles</h2><p>球常用来作为物体的边框，一是用球作为边框比较简单，二是因为当用球来作为边框时，物体的旋转并不会造成任何的影响，因此物体旋转后的再次计算边框。</p>
<p>球的隐式定义如下：</p>
<script type="math/tex; mode=display">\|\mathbf{p}-\mathbf{c}\|=r</script><p>其中$\mathbf{p}$表示球上的点,$\mathbf{c}$表示球心，两者都是向量。非向量形式的隐式表达如下：</p>
<script type="math/tex; mode=display">\begin{aligned}
\left(x-c_{x}\right)^{2}+\left(y-c_{y}\right)^{2} &=r^{2} \\
\left(x-c_{x}\right)^{2}+\left(y-c_{y}\right)^{2}+\left(z-c_{z}\right)^{2} &=r^{2}
\end{aligned}</script><p>球的其他计算数学计算如下：</p>
<ol>
<li>直径<script type="math/tex; mode=display">D=2 r</script></li>
<li>周长<script type="math/tex; mode=display">C=2 \pi r=\pi D</script></li>
<li>圆的面积<script type="math/tex; mode=display">A=\pi r^{2}</script></li>
<li>球的表面积<script type="math/tex; mode=display">S=4 \pi r^{2}</script></li>
<li>球的体积<script type="math/tex; mode=display">V=\frac{4}{3} \pi r^{3}</script></li>
</ol>
<h2 id="Bounding-Boxes"><a href="#Bounding-Boxes" class="headerlink" title="Bounding Boxes"></a>Bounding Boxes</h2><p><code>AABB（Axially aligned bounding box）</code>通常用来表示立方体形状的边框，而且立方体的边必须与当前坐标系下坐标轴相平行。</p>
<p>另一种不太常用的立方体边框为OBB（Oriented bounding box），这里立方体的边与坐标系的轴没有任何约束。相对来说，AABB更容易创建，而且OBB仅仅是AABB在一个坐标系下旋转，所以这一节只会讨论AABB。</p>
<p>OBB和AABB的区别并不在于边框本身，而是在于坐标系。如果一个边框用于在世界坐标中旋转了的物体，那么这个边框从物体坐标系角度看是AABB，但是从世界坐标系角度看是OBB</p>
<h3 id="Representing-AABBs"><a href="#Representing-AABBs" class="headerlink" title="Representing AABBs"></a>Representing AABBs</h3><p>一种表达方式是限定三个坐标系的范围，即</p>
<script type="math/tex; mode=display">x_{\min } \leq x \leq x_{\max }, \quad y_{\min } \leq y \leq y_{\max }, \quad z_{\min } \leq z \leq z_{\max }</script><p>也可以通过两个对角线的点来进行表达，即</p>
<script type="math/tex; mode=display">\mathbf{p}_{\min }=\left[\begin{array}{lll}
x_{\min } & y_{\min } & z_{\min }
\end{array}\right], \quad \mathbf{p}_{\max }=\left[\begin{array}{ccc}
x_{\max } & y_{\max } & z_{\max }
\end{array}\right]</script><p>其中边框的中点可以表示为：</p>
<script type="math/tex; mode=display">\mathbf{c}=\left(\mathbf{p}_{\min }+\mathbf{p}_{\max }\right) / 2</script><p>边框的尺寸向量（Size vector）用$\mathbf{s}$表示，值为对角线两个点间的有向距离：</p>
<script type="math/tex; mode=display">\mathbf{s}=\mathbf{p}_{\max }-\mathbf{p}_{\min }</script><p>同样也可以计算半径向量，如下所示：</p>
<script type="math/tex; mode=display">\mathbf{r}=\mathbf{p}_{\max }-\mathbf{c}=\mathbf{s} / 2</script><p>关于边框的值$P<em>{min}, P</em>{\max }, \mathbf{c}, \mathbf{s}, \text {和} \mathbf{r}$，除了$\mathbf{s}和\mathbf{r}$这两个值的搭配，通过其他任意搭配都可以求出边框的其他值。</p>
<h3 id="Computing-AABBs"><a href="#Computing-AABBs" class="headerlink" title="Computing AABBs"></a>Computing AABBs</h3><p>//TODO</p>
<p>// 书中给出了关于AABB的类</p>
<h3 id="AABBs-versus-Bounding-Spheres"><a href="#AABBs-versus-Bounding-Spheres" class="headerlink" title="AABBs versus Bounding Spheres"></a>AABBs versus Bounding Spheres</h3><p>AABB对于球边框的优势：</p>
<ol>
<li>计算由一系列的点构成的AABB面只需要线性时间（比较出最小的点和最大的点即可），而计算出由一系列的点构成的球相对复杂。</li>
<li>通常来说，对于同一个物体AABB边框会更小，最坏的情况下，AABB也只比球边框大不到两倍（当物体本身是一个球时），而最坏情况下球边框可能会比AABB大很多。<br>如下所示，蓝色为球边框，红色为AABB<br><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter9-Notes/2020-04-09-09-51-39.png" alt="立方体边框与球边框比较"></li>
</ol>
<p>球边框对于AABB边框的优势：</p>
<ol>
<li>物体的变换不会造成球边框的变化，如下图所示：<br><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter9-Notes/2020-04-09-09-55-40.png" alt="物体变换对边框的变化"></li>
</ol>
<h4 id="Transforming-AABBs"><a href="#Transforming-AABBs" class="headerlink" title="Transforming AABBs"></a>Transforming AABBs</h4><p>如之前所述，AABB边框在物体变换后也会发生变化，这一节介绍如何计算变换后的AABB边框。</p>
<p>通常有两种思路，一种是对变换后的物体再次求解AABB边框，第二种是直接对AABB边框进行同样的变换。通常第二种方法比第一种计算更快，因为无论物体本身多复杂，计算AABB的变换只需要计算8个顶点，所以通常第二种方法用的较多。</p>
<p>第二种方法中直接将AABB变换后的结果作为新的AABB是不行的，因为可能旋转会导致原先的$\mathbf{P}<em>{max}$变得比$\mathbf{P}</em>{min}$更小。所以直接对AABB边框进行同样的变换后，根据变换后的8个顶点，得出新AABB框，如下图所示：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter9-Notes/2020-04-09-10-01-55.png" alt="AABB变换"></p>
<p>上图的右半部分是旋转后的物体和ABBB，图中蓝色的部分是直接对AABB进行了旋转，此时在世界坐标系下，它已经变成了OBB。<br>内部的红色边框为第一种方法，是根据旋转后的图形再次求解AABB。该方法准确但效率较低。<br>外部的红色边框为第二种方法，它是由旋转后的原AABB（蓝色部分）计算得到的，它比理想上的AABB框要更大。该方法迅速，只需要计算AABB的顶点，但通常会造成计算出的边框更大。</p>
<p>第二种方法的计算如下，假设$[x \quad y \quad z]$是原先AABB的顶点，变换后的顶点为$[x^{\prime} \quad y^{\prime} \quad z^{\prime}]$，则转换果然如下：</p>
<script type="math/tex; mode=display">\begin{aligned}
\left[\begin{array}{ll}
x^{\prime} & y^{\prime} & z^{\prime}
\end{array}\right] &=\left[\begin{array}{lll}
x & y & z
\end{array}\right]\left[\begin{array}{lll}
m_{11} & m_{12} & m_{13} \\
m_{21} & m_{22} & m_{23} \\
m_{31} & m_{32} & m_{33}
\end{array}\right] \\
x^{\prime} &=m_{11} x+m_{21} y+m_{31} z \\
y^{\prime} &=m_{12} x+m_{22} y+m_{32} z \\
z^{\prime} &=m_{13} x+m_{23} y+m_{33} z
\end{aligned}</script><p>其中矩阵表示进行的变换。</p>
<p>通常的的方式是将八个顶点分别通过上式进行计算，然后找出最小点和最大点。</p>
<p>但是观察后发现，可以直接通过矩阵中的元素正负号来直接求出最大点和最小点，下面以二维平面的变换作为例子，即变换为：</p>
<script type="math/tex; mode=display">\begin{aligned}
\left[\begin{array}{ll}
x^{\prime} & y^{\prime} 
\end{array}\right] &=\left[\begin{array}{lll}
x & y
\end{array}\right]\left[\begin{array}{lll}
m_{11} & m_{12} \\
m_{21} & m_{22}
\end{array}\right] \\
x^{\prime} &=m_{11} x+m_{21} y\\
y^{\prime} &=m_{12} x+m_{22} y \\
\end{aligned}</script><p>在二维平面下中，AABB有四个顶点，$[x<em>{min},y</em>{min}],[x<em>{min},y</em>{max}],[x<em>{max},y</em>{min}],[x<em>{max},y</em>{max}]$</p>
<p>所以$x^{\prime}$也相对有四种可能，即$m<em>{11} x</em>{min}+m<em>{21} y</em>{min}$，$m<em>{11} x</em>{min}+m<em>{21} y</em>{max}$，$m<em>{11} x</em>{max}+m<em>{21} y</em>{min}$，$m<em>{11} x</em>{max}+m<em>{21} y</em>{max}$，</p>
<p>如果将$x^{\prime}$拆分成两部分来看，即$m<em>{11}x$和$m</em>{21}y$，如果$m<em>{11}$是正数，那么要求得更小的$x^{\prime}$，x是$x</em>{min}$时更合适，反之$x<em>{max}$更合适。对于$m</em>{21}$也是同理，$y<em>{min}$适合$m</em>{21}$是正数的情况，$y<em>{max}$适合$m</em>{21}$是负数的情况</p>
<p>因此求$x<em>{min}^{\prime}$，只需要判断$m</em>{11}$和$m_{21}$的大小，然后直接选取对应的x和y分量，进行累加就行，不需要求出所有的$x^{\prime}$可能进行比较。</p>
<p>//TODO<br>//书中有对应的求新AABB算法</p>
<h2 id="Planes"><a href="#Planes" class="headerlink" title="Planes"></a>Planes</h2><p>3D中的平面对应2D中的射线，其定义也与在2D中的射线类似：与给定的两个点距离相同的所有的点的集合。</p>
<h3 id="The-Plane-Equation：An-Implicit-Definnition-of-a-plane"><a href="#The-Plane-Equation：An-Implicit-Definnition-of-a-plane" class="headerlink" title="The Plane Equation：An Implicit Definnition of a plane"></a>The Plane Equation：An Implicit Definnition of a plane</h3><p>隐式表达法：</p>
<ol>
<li>用标量<script type="math/tex; mode=display">a x+b y+c z=d</script></li>
<li><p>用向量</p>
<script type="math/tex; mode=display">\mathbf{p} \cdot \mathbf{n}=d</script><p>其中$\mathbf{p}$为在平面上的点，$\mathbf{n}=[a \quad b \quad c]$为垂直平面的线。<br>证明如下，假设平面上还有一个点$\mathbf{q}$：</p>
<script type="math/tex; mode=display">\begin{aligned}
\mathbf{n} \cdot \mathbf{p} &=d \\
\mathbf{n} \cdot \mathbf{q} &=d \\
\mathbf{n} \cdot \mathbf{p} &=\mathbf{n}  \cdot \mathbf{q} \\
\mathbf{n} \cdot \mathbf{p}-\mathbf{n}    \cdot \mathbf{q} &=0 \\
\mathbf{n} \cdot(\mathbf{p}-\mathbf{q}) & =0
\end{aligned}</script><p>如果要求平面的法线，对$n$进行归一化即可</p>
<script type="math/tex; mode=display">
\hat{\mathbf{n}}=\frac{[a \quad b \quad c]}{\sqrt{a^2+b^2+c^2}}</script><p>用法线表示平面为：</p>
<script type="math/tex; mode=display">
\mathbf{p}\cdot \hat{\mathbf{n}}=\frac{d}{\sqrt{a^2+b^2+c^2}}=distance</script><p>其中distance为平面距离原点的距离</p>
</li>
</ol>
<p>平面分正反面，沿着法线方向看，看到的是背面，法线指向的方向是正面，如下图所示：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter9-Notes/2020-04-09-10-52-21.png" alt="平面的正反面"></p>
<h3 id="Defining-a-Plane-by-Using-Three-Points"><a href="#Defining-a-Plane-by-Using-Three-Points" class="headerlink" title="Defining a Plane by Using Three Points"></a>Defining a Plane by Using Three Points</h3><p>假设有三个在平面上的点$\mathbf{p}<em>{1}, \mathbf{p}</em>{2}$和$\mathbf{p}_{3}$，且他们按顺时针方向排列，如下图所示：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter9-Notes/2020-04-09-10-54-02.png" alt="平面上三个点"></p>
<p>可以按照下式，求出法线：</p>
<script type="math/tex; mode=display">\mathbf{e}_{3}=\mathbf{p}_{2}-\mathbf{p}_{1}, \quad \mathbf{e}_{1}=\mathbf{p}_{3}-\mathbf{p}_{2}, \quad \hat{\mathbf{n}}=\frac{\mathbf{e}_{3} \times \mathbf{e}_{1}}{\left\|\mathbf{e}_{3} \times \mathbf{e}_{1}\right\|}</script><p>将任意一个点带入法线表达式，既能求出distance<br>，如$distance=\hat{\mathbf{n}}\cdot \mathbf{p}_1$</p>
<p>即最终表达式为</p>
<script type="math/tex; mode=display">\mathbf{P}\cdot \hat{\mathbf{n}}=\hat{\mathbf{n}}\cdot \mathbf{p}_1</script><h3 id="“Best-Fit”-Plane-for-More-than-Three-Points"><a href="#“Best-Fit”-Plane-for-More-than-Three-Points" class="headerlink" title="“Best Fit” Plane for More than Three Points"></a>“Best Fit” Plane for More than Three Points</h3><p>当给定了多个点，要根据多个点求平面时，不能简单的从多个点中任意选取出三个点，因为：</p>
<ol>
<li>选取的三个点可能在一条线上</li>
<li>多个点构成的多边形可能是凹的，即虽然按顺时针在多边形上取了三个点，但实际上它们是逆时针的</li>
<li>由于精度或各种原因，三个点可能实际上并不在一个平面上。</li>
</ol>
<p>所以解法是用所有的点来计算，如有以下点：</p>
<script type="math/tex; mode=display">\begin{aligned}
&\mathbf{p}_{1}=\left[\begin{array}{lll}
x_{1} & y_{1} & z_{1}
\end{array}\right]\\
&\mathbf{p}_{2}=\left[\begin{array}{lll}
x_{2} & y_{2} & z_{2}
\end{array}\right]\\
&\vdots\\
&\mathbf{p}_{n-1}=\left[\begin{array}{lll}
x_{n-1} & y_{n-1} & z_{n-1}
\end{array}\right] \\
&\mathbf{p}_{n} =\left[\begin{array}{lll}
x_{n} & y_{n} & z_{n}\end{array}\right]
\end{aligned}</script><p>则法线为：</p>
<script type="math/tex; mode=display">\begin{aligned}
n_{x}=&\left(z_{1}+z_{2}\right)\left(y_{1}-y_{2}\right)+\left(z_{2}+z_{3}\right)\left(y_{2}-y_{3}\right)+\cdots \\
& \cdots+\left(z_{n-1}+z_{n}\right)\left(y_{n-1}-y_{n}\right)+\left(z_{n}+z_{1}\right)\left(y_{n}-y_{1}\right) \\
n_{y}=&\left(x_{1}+x_{2}\right)\left(z_{1}-z_{2}\right)+\left(x_{2}+x_{3}\right)\left(z_{2}-z_{3}\right)+\cdots \\
& \cdots+\left(x_{n-1}+x_{n}\right)\left(z_{n-1}-z_{n}\right)+\left(x_{n}+x_{1}\right)\left(z_{n}-z_{1}\right) \\
n_{z}=&\left(y_{1}+y_{2}\right)\left(x_{1}-x_{2}\right)+\left(y_{2}+y_{3}\right)\left(x_{2}-x_{3}\right)+\cdots \\
& \cdots+\left(y_{n-1}+y_{n}\right)\left(x_{n-1}-x_{n}\right)+\left(y_{n}+y_{1}\right)\left(x_{n}-x_{1}\right)
\end{aligned}</script><p>即</p>
<script type="math/tex; mode=display">\begin{aligned}
&n_{x}=\sum_{i=1}^{n}\left(z_{i}+z_{i+1}\right)\left(y_{i}-y_{i+1}\right)\\
&n_{y}=\sum_{i=1}^{n}\left(x_{i}+x_{i+1}\right)\left(z_{i}-z_{i+1}\right)\\
&n_{z}=\sum_{i=1}^{n}\left(y_{i}+y_{i+1}\right)\left(x_{i}-x_{i+1}\right)
\end{aligned}</script><p>//TODO: 推导该公式</p>
<p>在求出了$n$后，将所有的点都带入公式，然后求出平均的$d$，如下：</p>
<script type="math/tex; mode=display">d=\frac{1}{n} \sum_{i=1}^{n}\left(\mathbf{p}_{i} \cdot \mathbf{n}\right)=\frac{1}{n}\left(\sum_{i=1}^{n} \mathbf{p}_{i}\right) \cdot \mathbf{n}</script><h3 id="Distance-from-Point-to-Plane"><a href="#Distance-from-Point-to-Plane" class="headerlink" title="Distance from Point to Plane"></a>Distance from Point to Plane</h3><p>要求平面外点$\mathbf{q}$距离平面的距离，可找出平面上离该点最近的点$\mathbf{p}$，有向距离$\mathbf{pq}$即为距离，当$\mathbf{q}$处于平面的正方向，则距离为正数，否则为负数，如下图所示：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter9-Notes/2020-04-09-11-21-53.png" alt="求点距离"></p>
<p>如果$\mathbf{n}$是单位向量法线，即$\hat{\mathbf{n}}$，那么$a$即是有向距离。</p>
<p>在实际求解的过程中，实际上并不需要算出$\mathbf{p}$的位置，如下所示：</p>
<script type="math/tex; mode=display">\begin{aligned}
\mathbf{p}+a \hat{\mathbf{n}} &=\mathbf{q} \\
(\mathbf{p}+a \hat{\mathbf{n}}) \cdot \hat{\mathbf{n}} &=\mathbf{q} \cdot \hat{\mathbf{n}} \\
\mathbf{p} \cdot \hat{\mathbf{n}}+(a \hat{\mathbf{n}}) \cdot \hat{\mathbf{n}} &=\mathbf{q} \cdot \hat{\mathbf{n}} \\
d+a &=\mathbf{q} \cdot \hat{\mathbf{n}} \\
a &=\mathbf{q} \cdot \hat{\mathbf{n}}-d
\end{aligned}</script><h2 id="Triangles"><a href="#Triangles" class="headerlink" title="Triangles"></a>Triangles</h2><h3 id="Notation"><a href="#Notation" class="headerlink" title="Notation"></a>Notation</h3><p>三角形是通过三个顶点定义的。通常在左手坐标系下，三个顶点的顺序为顺时针。</p>
<p>三角形的边和顶点的定义如下图所示：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter9-Notes/2020-04-13-11-33-11.png" alt="三角形三边和顶点"></p>
<script type="math/tex; mode=display">\begin{aligned}
&\mathbf{e}_{1}=\mathbf{v}_{3}-\mathbf{v}_{2}, \quad \mathbf{e}_{2}=\mathbf{v}_{1}-\mathbf{v}_{3}, \quad \mathbf{e}_{3}=\mathbf{v}_{2}-\mathbf{v}_{1}\\
&l_{1}=\left\|\mathbf{e}_{1}\right\|, \quad l_{2}=\left\|\mathbf{e}_{2}\right\|, \quad l_{3}=\left\|\mathbf{e}_{3}\right\|
\end{aligned}</script><p>根据顶点，边，角的关系，有正弦和余弦定理，如下所示：</p>
<p>正弦定理为：</p>
<script type="math/tex; mode=display">\frac{\sin \theta_{1}}{l_{1}}=\frac{\sin \theta_{2}}{l_{2}}=\frac{\sin \theta_{3}}{l_{3}}</script><p>余弦定理为：</p>
<script type="math/tex; mode=display">\begin{array}{l}
l_{1}^{2}=l_{2}^{2}+l_{3}^{2}-2 l_{2} l_{3} \cos \theta_{1} \\
l_{2}^{2}=l_{1}^{2}+l_{3}^{2}-2 l_{1} l_{3} \cos \theta_{2} \\
l_{3}^{2}=l_{1}^{2}+l_{2}^{2}-2 l_{1} l_{2} \cos \theta_{3}
\end{array}</script><h3 id="Area-of-a-Triangle"><a href="#Area-of-a-Triangle" class="headerlink" title="Area of a Triangle"></a>Area of a Triangle</h3><p>最普通的求三角形面积为通过底和高，即</p>
<script type="math/tex; mode=display">A=b h / 2</script><p>海拉公式，可以通过三角形的三边长度来求得三角形面积：</p>
<script type="math/tex; mode=display">\begin{aligned}
&s=\frac{l_{1}+l_{2}+l_{3}}{2}=\frac{p}{2}\\
&A=\sqrt{s\left(s-l_{1}\right)\left(s-l_{2}\right)\left(s-l_{3}\right)}
\end{aligned}</script><p>还可以通过三角形的顶点本身来求得三角形面积，首先需要对三个顶点相减，获得三条边的向量$e_1,e_2,e_3$，然后再任意取其中两条求面积如下所示：</p>
<script type="math/tex; mode=display">A=\frac{\left\|\mathbf{e}_{1} \times \mathbf{e}_{2}\right\|}{2}</script><p>该公式推导如下：</p>
<p>首先三角形的三条边都与X轴形成了一个梯形，如下图所示：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter9-Notes/2020-04-13-11-46-08.png" alt="三角形边构成梯形"></p>
<p>对该梯形的面积定义正负，如果边的顶点是由左到右，则梯形面积为正，否则面积为负，三边构成的梯形面积如下：</p>
<script type="math/tex; mode=display">\begin{aligned}
&A\left(\mathbf{e}_{1}\right)=\frac{\left(y_{3}+y_{2}\right)\left(x_{3}-x_{2}\right)}{2}\\
&A\left(\mathbf{e}_{2}\right)=\frac{\left(y_{1}+y_{3}\right)\left(x_{1}-x_{3}\right)}{2}\\
&A\left(\mathbf{e}_{3}\right)=\frac{\left(y_{2}+y_{1}\right)\left(x_{2}-x_{1}\right)}{2}
\end{aligned}</script><p>三角形的面积为三个梯形的累加，如下所示：</p>
<script type="math/tex; mode=display">\begin{aligned}
A &=A\left(\mathbf{e}_{1}\right)+A\left(\mathbf{e}_{2}\right)+A\left(\mathbf{e}_{3}\right) \\
&=\frac{\left(y_{3}+y_{2}\right)\left(x_{3}-x_{2}\right)+\left(y_{1}+y_{3}\right)\left(x_{1}-x_{3}\right)+\left(y_{2}+y_{1}\right)\left(x_{2}-x_{1}\right)}{2} \\
&=\frac{\left(\begin{array}{c}
\left(y_{3} x_{3}-y_{3} x_{2}+y_{2} x_{3}-y_{2} x_{2}\right) \\
+\left(y_{1} x_{1}-y_{1} x_{3}+y_{3} x_{1}-y_{3} x_{3}\right) \\
+\left(y_{2} x_{2}-y_{2} x_{1}+y_{1} x_{2}-y_{1} x_{1}\right)
\end{array}\right)}{2} \\
&=\frac{-y_{3} x_{2}+y_{2} x_{3}-y_{1} x_{3}+y_{3} x_{1}-y_{2} x_{1}+y_{1} x_{2}}{2} \\
&=\frac{y_{1}\left(x_{2}-x_{3}\right)+y_{2}\left(x_{3}-x_{1}\right)+y_{3}\left(x_{1}-x_{2}\right)}{2}
\end{aligned}</script><p>将上式中的$y_1,y_2,y_3$都减去$y_3$，相当于三角形向下平移了一部分，所以结果不会变，即如下所示：</p>
<script type="math/tex; mode=display">\begin{aligned}
&\begin{aligned}
A &=\frac{y_{1}\left(x_{2}-x_{3}\right)+y_{2}\left(x_{3}-x_{1}\right)+y_{3}\left(x_{1}-x_{2}\right)}{2} \\
&=\frac{\left(y_{1}-y_{3}\right)\left(x_{2}-x_{3}\right)+\left(y_{2}-y_{3}\right)\left(x_{3}-x_{1}\right)+\left(y_{3}-y_{3}\right)\left(x_{1}-x_{2}\right)}{2}
\end{aligned}\\
&=\frac{\left(y_{1}-y_{3}\right)\left(x_{2}-x_{3}\right)+\left(y_{2}-y_{3}\right)\left(x_{3}-x_{1}\right)}{2}
\end{aligned}</script><p>上述结果即为点乘，即</p>
<script type="math/tex; mode=display">A=\frac{\left\|\mathbf{e}_{1} \times \mathbf{e}_{2}\right\|}{2}</script><h3 id="Barycentric-Space"><a href="#Barycentric-Space" class="headerlink" title="Barycentric Space"></a>Barycentric Space</h3><p><code>重心系统（Barycentric Space）</code>是用三角形的三个顶点来描述三角形的位置，表达式为：</p>
<script type="math/tex; mode=display">\left(b_{1}, b_{2}, b_{3}\right) \equiv b_{1} \mathbf{v}_{1}+b_{2} \mathbf{v}_{2}+b_{3} \mathbf{v}_{3}</script><p>其中</p>
<script type="math/tex; mode=display">b_{1}+b_{2}+b_{3}=1</script><p>重心系统实例如下：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter9-Notes/2020-04-13-12-11-31.png" alt="重心系统"></p>
<p>注意其中三个顶点的数值，即</p>
<script type="math/tex; mode=display">(1,0,0) \equiv \mathbf{v}_{1}, \quad(0,1,0) \equiv \mathbf{v}_{2}, \quad(0,0,1) \equiv \mathbf{v}_{3}</script><p>三角形内的点，数值会在$[0,1]$之间，三角形外的点最少会有一个负数。</p>
<p>下图是重心系统的镶嵌，可以看出重心系统中值的运算规律：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter9-Notes/2020-04-13-12-19-04.png" alt="重心系统"></p>
<p>如第一个数值表示顶点$\mathbf{V}_1$对面的边所平行的部分，即$\mathbf{V}_2$和$\mathbf{V}_3$构成的边。因此可以看到该边上的点，值都为$(0,x,x)$，而平行于该边且经过$\mathbf{v}_1$的边上面的点都为$(1,x,x)$，$\mathbf{v}_1$点为$(1,0,0)$。同理顶点$\mathbf{v}_2$对面，由$\mathbf{v}_1$和$\mathbf{v}_3$构成的边，表示第二个参数，即$(x,0,x)$。第三个参数的数值也同理可得。</p>
<p>重心系统的维度不是由参考点的维度决定的，而是由参考点的数量决定的。如三角形的重心系统，无论三角形的点是二维还是三维的，只要是三角形就需要三个参考点，所以该重心系统是二维的。</p>
<p>在图形学中，重心系统常应用在在计算顶点插值时，如计算片段的颜色。还被应用在计算相交问题时，一根射线可以根据与各个三角形片元的重心值判断是与哪个片元相交。</p>
<h3 id="Calculating-Barycentric-Coordinates"><a href="#Calculating-Barycentric-Coordinates" class="headerlink" title="Calculating Barycentric Coordinates"></a>Calculating Barycentric Coordinates</h3><p>如果通过重心系统计算笛卡尔坐标系，可以通过上述公式：</p>
<script type="math/tex; mode=display">\left(b_{1}, b_{2}, b_{3}\right) \equiv b_{1} \mathbf{v}_{1}+b_{2} \mathbf{v}_{2}+b_{3} \mathbf{v}_{3}</script><p>由笛卡尔坐标系计算重心表达如下：</p>
<p>已知三个点和所求点的笛卡尔坐标系，如下图所示：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter9-Notes/2020-04-13-12-33-31.png" alt="顶点与所求点"></p>
<p>对于二维空间中的三角形，根据三角形重心的定义，可得：</p>
<script type="math/tex; mode=display">\begin{aligned}
b_{1} x_{1}+b_{2} x_{2}+b_{3} x_{3} &=p_{x} \\
b_{1} y_{1}+b_{2} y_{2}+b_{3} y_{3} &=p_{y} \\
b_{1}+b_{2}+b_{3} &=1
\end{aligned}</script><p>三个表达式对应三个未知数$b_1,b_2,b_3$，因此这是一个三元一次方程的求解，结果为：</p>
<script type="math/tex; mode=display">\begin{array}{l}
b_{1}=\frac{\left(p_{y}-y_{3}\right)\left(x_{2}-x_{3}\right)+\left(y_{2}-y_{3}\right)\left(x_{3}-p_{x}\right)}{\left(y_{1}-y_{3}\right)\left(x_{2}-x_{3}\right)+\left(y_{2}-y_{3}\right)\left(x_{3}-x_{1}\right)} \\
b_{2}=\frac{\left(p_{y}-y_{1}\right)\left(x_{3}-x_{1}\right)+\left(y_{3}-y_{1}\right)\left(x_{1}-p_{x}\right)}{\left(y_{1}-y_{3}\right)\left(x_{2}-x_{3}\right)+\left(y_{2}-y_{3}\right)\left(x_{3}-x_{1}\right)} \\
b_{3}=\frac{\left(p_{y}-y_{2}\right)\left(x_{1}-x_{2}\right)+\left(y_{1}-y_{2}\right)\left(x_{2}-p_{x}\right)}{\left(y_{1}-y_{3}\right)\left(x_{2}-x_{3}\right)+\left(y_{2}-y_{3}\right)\left(x_{3}-x_{1}\right)}
\end{array}</script><p>根据上节中，通过顶点求三角形面积的方法，可以看出上式的分子和分母都是面积公式的两倍，因此也可以化简为：</p>
<script type="math/tex; mode=display">b_{1}=A\left(T_{1}\right) / A(T), \quad b_{2}=A\left(T_{2}\right) / A(T), \quad b_{3}=A\left(T_{3}\right) / A(T)</script><p>对于三维空间中的三角形，也可以通过类似的方法求得结果。但是因为是三维空间，所以可以列出四个表达式（x,y,z三个表达式+一个和为1的限制），但是未知数还是三个（$b_1,b_2,b_3$）。因此需要删除一个表达式。</p>
<p>但是不能随便删除一个表达式，因为删去一个表达式的操作相当于将三维空间中的三角形投影至一个平面上，而如果三角形是垂直或者接近垂直于该平面，那么就会有问题。因此要选择投影面积最大的平面。</p>
<p>可以根据法线判断出投影面积最大的平面，如果法线为$[0,1,0]$，那么法线垂直于$xz$平面，即$xz$平面最大，即删除$y$，也因此法线上哪个分量最大，删除哪个表达式。</p>
<p>上述已经求得重心可以通过三角形的面积得到：</p>
<script type="math/tex; mode=display">b_{1}=A\left(T_{1}\right) / A(T), \quad b_{2}=A\left(T_{2}\right) / A(T), \quad b_{3}=A\left(T_{3}\right) / A(T)</script><p>同时由之前公式可知，面积可以通过叉乘求得，即：</p>
<script type="math/tex; mode=display">A=\frac{\left\|\mathbf{e}_{1} \times \mathbf{e}_{2}\right\|}{2}</script><p>因此理论上可以通过用顶点获取三角形的各边，再通过边的叉乘的得到结果。但存在的问题是，上述公式中的求模永远返回的是正数，因此这样就无法计算三角形外的点。</p>
<p>解决方法是再通过一个点积，如下所示：</p>
<script type="math/tex; mode=display">\begin{aligned}
\mathbf{c} \cdot \hat{\mathbf{n}} &=\|\mathbf{c}\|\|\hat{\mathbf{n}}\| \cos \theta \\
&=\|\mathbf{c}\|(1)(\pm 1) \\
&=\pm\|\mathbf{c}\|
\end{aligned}</script><p>其中$\mathbf{c}$为叉乘的结果，$\hat{\mathbf{n}}$为法线，因此$\mathbf{c}$必然平行于$\hat{\mathbf{n}}$。如果两者同向则返回正数，否则返回负数。</p>
<p>整个计算如下图所示：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter9-Notes/2020-04-13-17-41-55.png" alt="叉乘求重心空间"></p>
<p>其中：</p>
<script type="math/tex; mode=display">\begin{aligned}
&\mathbf{e}_{1}=\mathbf{v}_{3}-\mathbf{v}_{2}, \quad \mathbf{e}_{2}=\mathbf{v}_{1}-\mathbf{v}_{3}, \quad \mathbf{e}_{3}=\mathbf{v}_{2}-\mathbf{v}_{1}\\
&\mathbf{d}_{1}=\mathbf{p}-\mathbf{v}_{1}, \quad \mathbf{d}_{2}=\mathbf{p}-\mathbf{v}_{2}, \quad \mathbf{d}_{3}=\mathbf{p}-\mathbf{v}_{3}
\end{aligned}</script><script type="math/tex; mode=display">\hat{\mathbf{n}}=\frac{\mathbf{e}_{1} \times \mathbf{e}_{2}}{\left\|\mathbf{e}_{1} \times \mathbf{e}_{2}\right\|}</script><script type="math/tex; mode=display">\begin{aligned}
&b_{1}=A\left(T_{1}\right) / A(T)=\frac{\left(\mathbf{e}_{1} \times \mathbf{d}_{3}\right) \cdot \hat{\mathbf{n}}}{\left(\mathbf{e}_{1} \times \mathbf{e}_{2}\right) \cdot \hat{\mathbf{n}}}\\
&b_{2}=A\left(T_{2}\right) / A(T)=\frac{\left(\mathbf{e}_{2} \times \mathbf{d}_{1}\right) \cdot \hat{\mathbf{n}}}{\left(\mathbf{e}_{1} \times \mathbf{e}_{2}\right) \cdot \hat{\mathbf{n}}}\\
&b_{3}=A\left(T_{3}\right) / A(T)=\frac{\left(\mathbf{e}_{3} \times \mathbf{d}_{2}\right) \cdot \hat{\mathbf{n}}}{\left(\mathbf{e}_{1} \times \mathbf{e}_{2}\right) \cdot \hat{\mathbf{n}}}
\end{aligned}</script><h3 id="Special-Points"><a href="#Special-Points" class="headerlink" title="Special Points"></a>Special Points</h3><ol>
<li><p>质心（center of gravity）<br>质心为三角形三个顶点位置的平均值，即：</p>
<script type="math/tex; mode=display">\mathbf{c}_{\mathrm{Grav}}=\frac{\mathbf{v}_{1}+\mathbf{v}_{2}+\mathbf{v}_{3}}{3}</script><p>其重心坐标值为：</p>
<script type="math/tex; mode=display">\left(\frac{1}{3}, \frac{1}{3}, \frac{1}{3}\right)</script></li>
<li><p>内心（incenter）<br>内心距离三角形三条边的距离相等，也因此是三角形内切圆的圆心，如下图所示：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter9-Notes/2020-04-13-17-48-35.png" alt="三角形内心"></p>
<p>计算方法如下：</p>
<script type="math/tex; mode=display">\mathbf{c}_{\mathrm{In}}=\frac{l_{1} \mathbf{v}_{1}+l_{2} \mathbf{v}_{2}+l_{3} \mathbf{v}_{3}}{p}</script><p>其重心坐标值为：</p>
<script type="math/tex; mode=display">\left(\frac{l_{1}}{p}, \frac{l_{2}}{p}, \frac{l_{3}}{p}\right)</script><p>内心与三角形边的距离为：</p>
<script type="math/tex; mode=display">r_{\mathrm{In}}=\frac{2 A}{p}</script></li>
</ol>
<ol>
<li><p>外心（circumcenter）<br>外心是距离三角形三个顶点距离相同的点，如下图所示：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter9-Notes/2020-04-13-17-53-04.png" alt="外心"></p>
</li>
</ol>
<p>   计算过程如下：</p>
<p>   先根据上图中的标识算出如下的中间变量：</p>
<script type="math/tex; mode=display">\begin{aligned}
   &\begin{array}{l}
   d_{1}=-\mathbf{e}_{2} \cdot   \mathbf{e}_{3} \\
   d_{2}=-\mathbf{e}_{3} \cdot   \mathbf{e}_{1} \\
   d_{3}=-\mathbf{e}_{1} \cdot   \mathbf{e}_{2}
   \end{array}\\
   &c_{1}=d_{2} d_{3}\\
   &c_{2}=d_{3} d_{1}\\
   &c_{3}=d_{1} d_{2}\\
   &c=c_{1}+c_{2}+c_{3}
   \end{aligned}</script><p>   其中外心的点为：</p>
<script type="math/tex; mode=display">\mathbf{c}_{\mathrm{Circ}}=\frac{\left(c_{2}+c_{3}\right) \mathbf{v}_{1}+\left(c_{3}+c_{1}\right) \mathbf{v}_{2}+\left(c_{1}+c_{2}\right) \mathbf{v}_{3}}{2 c}</script><p>   重心坐标值为：</p>
<script type="math/tex; mode=display">\left(\frac{c_{2}+c_{3}}{2 c}, \frac{c_{3}+c_{1}}{2 c}, \frac{c_{1}+c_{2}}{2 c}\right)</script><p>   距离三角形三个顶点的值为：</p>
<script type="math/tex; mode=display">r_{\mathrm{Circ}}=\frac{\sqrt{\left(d_{1}+d_{2}\right)\left(d_{2}+d_{3}\right)\left(d_{3}+d_{1}\right) / c}}{2}</script><h2 id="Polygons"><a href="#Polygons" class="headerlink" title="Polygons"></a>Polygons</h2><p>通常来说，多边形是一个由顶点和边组成的平面图形。</p>
<h3 id="Simple-versus-Complex-Polygons"><a href="#Simple-versus-Complex-Polygons" class="headerlink" title="Simple versus Complex Polygons"></a>Simple versus Complex Polygons</h3><p>简单多边形不存在洞，复杂多边形存在洞，如下所示：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter9-Notes/2020-04-13-17-57-07.png" alt="简单复杂多边形"></p>
<p>可以通过加上一对缝合边将简单多边形转换为复杂多边形，如下所示：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter9-Notes/2020-04-13-17-57-57.png" alt="简单多边形转换为复杂多边形"></p>
<p>还有一种自相交多边形（Self-intersecting polygon），如下所示：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter9-Notes/2020-04-13-17-58-58.png" alt="自相交多边形"></p>
<h3 id="Convex-versus-Concava-Polygons"><a href="#Convex-versus-Concava-Polygons" class="headerlink" title="Convex versus Concava Polygons"></a>Convex versus Concava Polygons</h3><p>关于凹多边形(Concave)和凸多边形(Convex)有多种区分方法：</p>
<ol>
<li><p>凹多边形至少有一个凹点（concavity），如下所示：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter9-Notes/2020-04-13-18-04-45.png" alt="凹点"></p>
</li>
<li><p>凹多边形至少有一对顶点的连线是在多边形外的。</p>
</li>
<li>凹多边形沿着所有顶点走，顶点的旋转顺序会发生变化（顺逆时针）。<br>这个可以通过对每两边进行叉乘来判断，如果叉乘的结果与法线方向不一致，说明顺序为逆时针，否则为顺时针。如果按顺时针顺序来取两边进行叉乘，突然出现了结果与法线相反的情况，则该两边中间为凹点。</li>
<li>无论是凸多边形还是凹多边形，其内角和都是$(n-2)360^{\circ}$。但是通过点积求得的是较小角的角度。如果对凸多边形的每两边都点积，则结果和为$(n-2)360^{\circ}$，而凹多边形不是。<br>如下图所示：<br><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter9-Notes/2020-04-13-21-59-19.png" alt="内角判断凹凸"></li>
</ol>
<h3 id="Triangulation-and-Fanning"><a href="#Triangulation-and-Fanning" class="headerlink" title="Triangulation and Fanning"></a>Triangulation and Fanning</h3><p>每一个$n$条边的凸多边形都能分为$n-2$个三角形。如下图所示：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter9-Notes/2020-04-13-22-05-57.png" alt="分割三角形"></p>
<p>但这样切分的问题在于，可能会切出一条非常细的三角形。</p>
<p>解决方法为每次切分前，先找出能使内角最大的切割方法，然后切一刀，将图形分为两部分。再对每一个部分迭代使用上述方法，直到只剩下三角形。这样可以一定程度避免出现细长三角形，但效率不如直接切分高。</p>
<div class="note info simple"><p>引用：</p>
<ol>
<li><em>3D Math Primer for Graphics and Game Development</em> 2nd 2011 </li>
</ol>
</div>
<hr>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>3D数学</tag>
      </tags>
  </entry>
  <entry>
    <title>《3D数学基础：图形和游戏开发》第六章笔记</title>
    <url>/3DMathPrimerForGraphicsAGameDevelopment-Chapter6-Notes/</url>
    <content><![CDATA[<p>《3D数学基础：图形和游戏开发》第六章笔记</p>
<p>6.1 介绍了矩阵的行列式</p>
<p>6.2 介绍了矩阵的逆</p>
<p>6.3 介绍了正交矩阵</p>
<p>6.4 介绍了齐次矩阵</p>
<p>6.5 介绍了齐次矩阵与透视投影的关系</p>
<span id="more"></span>
<h1 id="Chapter-6-More-on-Matrices"><a href="#Chapter-6-More-on-Matrices" class="headerlink" title="Chapter 6 More on Matrices"></a>Chapter 6 More on Matrices</h1><p>在第四章中介绍了矩阵的基本数学性质和几何意义。</p>
<p>在第五章中着重介绍了矩阵的几何意义，列举了一系列矩阵能表示的各种图形变换。</p>
<p>在这一章中将扩展前两章的知识，介绍矩阵的另一些数学特性和深入讨论图形变换。</p>
<h2 id="Determinant-of-a-Matrix"><a href="#Determinant-of-a-Matrix" class="headerlink" title="Determinant of a Matrix"></a>Determinant of a Matrix</h2><p>对于方阵而言，有一个重要的标量成为矩阵的行列式（Determinant of the matrix）。</p>
<h3 id="Determinants-of-2-times-2-and-3-times-3-matrices"><a href="#Determinants-of-2-times-2-and-3-times-3-matrices" class="headerlink" title="Determinants of  $2\times 2$ and $3\times 3$  matrices"></a>Determinants of  $2\times 2$ and $3\times 3$  matrices</h3><p>方阵$\mathbf{M}$的行列式写为$|\mathbf{M}|$或者写为”$def \mathbf{M}$”，非方阵的矩阵并没有行列式。</p>
<p>二维行列式的计算过程如下：</p>
<script type="math/tex; mode=display">|\mathbf{M}|=\left|\begin{array}{ll}
m_{11} & m_{12} \\\\
m_{21} & m_{22}
\end{array}\right|=m_{11} m_{22}-m_{12} m_{21}</script><p>三维行列式的计算过程如下：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\left|\begin{array}{lll}
m_{11} & m_{12} & m_{13} \\
m_{21} & m_{22} & m_{23} \\
m_{31} & m_{32} & m_{33}
\end{array}\right|\\
&=\begin{array}{l}
&m_{11} m_{22} m_{33}+m_{12} m_{23} m_{31}+m_{13} m_{21} m_{32} \\
&-m_{13} m_{22} m_{31}-m_{12} m_{21} m_{33}-m_{11} m_{23} m_{32}
\end{array} \\\\
&=\begin{array}{l}
& m_{11}\left(m_{22} m_{33}-m_{23} m_{32}\right) \\
&+m_{12}\left(m_{23} m_{31}-m_{21} m_{33}\right) \\
&+m_{13}\left(m_{21} m_{32}-m_{22} m_{31}\right)
\end{array}
\end{aligned}</script><h3 id="Minros-and-Cofactors"><a href="#Minros-and-Cofactors" class="headerlink" title="Minros and Cofactors"></a>Minros and Cofactors</h3><p>余子式（Minors）和代数余子式（Cofactors）之后求任意维度的行列式时会用到。</p>
<p>对于矩阵$\mathbf{M}$来，$\mathbf{M}^$表示删除了第$i$行和第$j$的子矩阵，而子矩阵的行列式称为余子式。如下所示：</p>
<script type="math/tex; mode=display">\mathbf{M}=\left[\begin{array}{ccc}
-4 & -3 & 3 \\\\
0 & 2 & -2 \\\\
1 & 4 & -1
\end{array}\right] \quad \Longrightarrow \quad M^{\{12\}}=\left|\begin{array}{cc}
0 & -2 \\\\
1 & -1
\end{array}\right|=2</script><p>而代数余子式，是为余子式再加上一个系数，该系数由子矩阵所删除的行列决定，即</p>
<h3 id="Determinants-of-Arbitary-n-times-n-Matrices"><a href="#Determinants-of-Arbitary-n-times-n-Matrices" class="headerlink" title="Determinants of Arbitary $n\times n$ Matrices"></a>Determinants of Arbitary $n\times n$ Matrices</h3><p>任意$n\times n$矩阵的行列式计算过程如下：</p>
<ol>
<li>任意选取一行或一列</li>
<li>对这行或这列中的每一个元素，将它和它所在行列的代数余子式相乘。</li>
<li>将第二步中的所有结果累加</li>
</ol>
<p>即：</p>
<p>如果一个三维矩阵通过上述方法计算：</p>
<script type="math/tex; mode=display">\begin{aligned}
\left|\begin{array}{lll}
m_{11} & m_{12} & m_{13} \\
m_{21} & m_{22} & m_{23}
\end{array}\right|=m_{11}\left|\begin{array}{cc}
m_{22} & m_{23} \\
m_{31} & m_{32} & m_{33}
\end{array}\right| &-m_{12}\left|\begin{array}{cc}
m_{21} & m_{23} \\
m_{31} & m_{33}
\end{array}\right| \\
&+m_{13}\left|\begin{array}{cc}
m_{21} & m_{22} \\
m_{31} & m_{32}
\end{array}\right|
\end{aligned}</script><p>以下为行列式的一些重要特性：</p>
<ol>
<li><p>如果矩阵是单位矩阵，那么行列式为1</p>
<script type="math/tex; mode=display">|\mathbf{I}|=1</script></li>
<li><p>矩阵乘积的行列式等于矩阵行列式的乘积</p>
<script type="math/tex; mode=display">|\mathbf{A B}|=|\mathbf{A} \| \mathbf{B}|</script></li>
<li><p>矩阵转置的行列式等于矩阵的行列式</p>
<script type="math/tex; mode=display">\left|\mathbf{M}^{\mathrm{T}}\right|=|\mathbf{M}|</script></li>
<li><p>有任意行或列全为0，则该矩阵行列式为0</p>
<script type="math/tex; mode=display">\left|\begin{array}{cccc}
? & ? & \cdots & ? \\
? & ? & \cdots & ? \\
\vdots & \vdots & & \vdots \\
0 & 0 & \cdots & 0 \\
\vdots & \vdots & & \vdots \\
\vdots & ? & \cdots & ?
\end{array}\right|=\left|\begin{array}{cccccc}
? & ? & \cdots & 0 & \cdots & ? \\
? & ? & \cdots & 0 & \cdots & ? \\
\vdots & \vdots & & \vdots & & \vdots \\
? & ? & \cdots & 0 & \cdots & ?
\end{array}\right|=0</script></li>
<li><p>交换矩阵的任意两行或两列，行列式取反</p>
<script type="math/tex; mode=display">\left|\begin{array}{cccc}
m_{11} & m_{12} & \cdots & m_{1 n} \\
m_{21} & m_{22} & \cdots & m_{2 n} \\
\vdots & \vdots & & \vdots \\
m_{i 1} & m_{i 2} & \cdots & m_{i n} \\
\vdots & \vdots & & \vdots \\
m_{j 1} & m_{j 2} & \cdots & m_{j n} \\
\vdots & \vdots & & \vdots \\
m_{n 1} & m_{n 2} & \cdots & m_{n n}
\end{array}\right|=-\left|\begin{array}{cccc}
m_{11} & m_{12} & \cdots & m_{1 n} \\
m_{21} & m_{22} & \cdots & m_{2 n} \\
\vdots & \vdots & & \vdots \\
m_{j 1} & m_{j 2} & \cdots & m_{j n} \\
\vdots & \vdots & & \vdots \\
m_{i 1} & m_{i 2} & \cdots & m_{i n} \\
\vdots & \vdots & & \vdots \\
m_{n 1} & m_{n 2} & \cdots & m_{n n}
\end{array}\right|</script></li>
<li><p>将矩阵的一行或一列乘以系数后加到零一行或列上不改变行列式的值（因此切变的行列式为1）</p>
<script type="math/tex; mode=display">\left|\begin{array}{cccc}
m_{11} & m_{12} & \cdots & m_{1 n} \\
m_{21} & m_{22} & \cdots & m_{2 n} \\
\vdots & \vdots & & \vdots \\
m_{i 1} & m_{i 2} & \cdots & m_{i n} \\
\vdots & \vdots & & \vdots \\
m_{j 1} & m_{j 2} & \cdots & m_{j n} \\
\vdots & \vdots & & \vdots \\
m_{n 1} & m_{n 2} & \cdots & m_{n n}
\end{array}\right|=\left|\begin{array}{cccc}
m_{11} & m_{12} & \cdots & m_{1 n} \\
m_{21} & m_{22} & \cdots & m_{2 n} \\
\vdots & \vdots & & \vdots \\
m_{i 1}+k m_{j 1} & m_{i 2}+k m_{j 2} & \cdots & m_{i n}+k m_{j n} \\
\vdots & \vdots & & \vdots \\
m_{j 1} & m_{j 2} & \cdots & m_{j n} \\
\vdots & \vdots & & \vdots \\
m_{n 1} & m_{n 2} & \cdots & m_{n n}
\end{array}\right|</script></li>
</ol>
<h3 id="Geometric-Interpretation-of-Determinant"><a href="#Geometric-Interpretation-of-Determinant" class="headerlink" title="Geometric Interpretation of Determinant"></a>Geometric Interpretation of Determinant</h3><p>在2D中，行列式实际上是表达了两个向量（每一行表示一个向量）所构成的平行四边形的有向面积，如：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter6-Notes/image-20200307221134452.png" alt="行列式表示面积" style="zoom:50%;" /></p>
<p>同理，在3D中即表示由三条向量构成的平行六面体体积。</p>
<p>行列式的大小表示了一个变换是否改变了多个向量所构成物体的面积或体积，行列式的正负表示了变换是否存在反转，如果行列式为0，那么说明这个变换存在投影。</p>
<h2 id="Inverse-of-a-Matrix"><a href="#Inverse-of-a-Matrix" class="headerlink" title="Inverse of a Matrix"></a>Inverse of a Matrix</h2><p>矩阵$\mathbf{M}$的逆矩阵为$\mathbf{M^{-1}}$，矩阵与逆矩阵的乘积为单位矩阵，即：</p>
<script type="math/tex; mode=display">\mathbf{M}\left(\mathbf{M}^{-1}\right)=\mathbf{M}^{-1} \mathbf{M}=\mathbf{I}</script><p>并不是所有的矩阵都有逆矩阵，如零矩阵无论与哪个矩阵相乘都不会成为单位矩阵。如果一个矩阵有逆矩阵，就称该矩阵为可逆矩阵或非奇异矩阵（Invertible or nonsingular）。</p>
<p>对于可逆矩阵有如下性质：</p>
<ol>
<li><p>对于任何可逆矩阵，当前仅当$\mathbf{v=0}$时有$\mathbf{vM=0}$。</p>
</li>
<li><p>任何可逆矩阵的行和列都是线性不相关的。</p>
</li>
<li><p>可逆矩阵的行列式不为0。因此检查一个矩阵的行列式是否为零是最通用且最快的检查矩阵是否可逆的方法。</p>
</li>
</ol>
<h3 id="The-Classical-Adjoint"><a href="#The-Classical-Adjoint" class="headerlink" title="The Classical Adjoint"></a>The Classical Adjoint</h3><p>伴随矩阵（Classical Adjoint）是计算逆矩阵的方法，将矩阵$\mathbf{M}$的伴随矩阵称为“adj $\mathbf{M}$”。</p>
<p>伴随矩阵是原矩阵所有代数余子式构成的矩阵的转置。如下以一个$3\times 3$矩阵作为例子：</p>
<script type="math/tex; mode=display">\mathbf{M}=\left[\begin{array}{ccc}
-4 & -3 & 3 \\
0 & 2 & -2 \\
1 & 4 & -1
\end{array}\right]</script><p>要求伴随矩阵，首先要求出所有的代数余子式，即：</p>
<script type="math/tex; mode=display">\begin{aligned}
&C^{\{11\}}=+\left|\begin{array}{cc}
2 & -2 \\
4 & -1
\end{array}\right|=6, \quad C^{\{12\}}=-\left|\begin{array}{cc}
0 & -2 \\
1 & -1
\end{array}\right|=-2, \quad C^{\{13\}}=+\left|\begin{array}{cc}
0 & 2 \\
1 & 4
\end{array}\right|=-2\\
&C^{\{21\}}=-\left|\begin{array}{cc}
-3 & 3 \\
4 & -1
\end{array}\right|=9, \quad C^{\{22\}}=+\left|\begin{array}{cc}
-4 & 3 \\
1 & -1
\end{array}\right|=1, \quad C^{\{23\}}=-\left|\begin{array}{cc}
-4 & -3 \\
1 & 4
\end{array}\right|=13\\
&C^{\{31\}}=+\left|\begin{array}{cc}
-3 & 3 \\
2 & -2
\end{array}\right|=0, \quad C^{\{32\}}=-\left|\begin{array}{cc}
-4 & 3 \\
0 & -2
\end{array}\right|=-8, \quad C^{\{33\}}=+\left|\begin{array}{cc}
-4 & -3 \\
0 & 2
\end{array}\right|=-8
\end{aligned}</script><p>矩阵的伴随矩阵如下：</p>
<script type="math/tex; mode=display">\begin{aligned}
\operatorname{adj} \mathbf{M} &=\left[\begin{array}{ccc}
C^{\{11\}} & C^{\{12\}} & C^{\{13\}} \\
C^{\{21\}} & C^{\{22\}} & C^{\{23\}} \\
C^{\{31\}} & C^{\{32\}} & C^{\{33\}}
\end{array}\right]^{\mathrm{T}} \\
&=\left[\begin{array}{ccc}
6 & -2 & -2 \\
9 & 1 & 13 \\
0 & -8 & -8
\end{array}\right]^{\mathrm{T}}=\left[\begin{array}{ccc}
6 & 9 & 0 \\
-2 & 1 & -8 \\
-2 & 13 & -8
\end{array}\right]
\end{aligned}</script><h3 id="Matrix-Inverse-Official-Linear-Algebra-Rules"><a href="#Matrix-Inverse-Official-Linear-Algebra-Rules" class="headerlink" title="Matrix Inverse-Official Linear Algebra Rules"></a>Matrix Inverse-Official Linear Algebra Rules</h3><p>用矩阵的伴随矩阵除以矩阵的行列式，即为矩阵的逆矩阵。因为计算逆矩阵时要除以矩阵的行列式，所以行列式为0的矩阵是不存在逆矩阵的。公式如下：</p>
<script type="math/tex; mode=display">\mathbf{M}^{-1}=\frac{\operatorname{adj} \mathbf{M}}{|\mathbf{M}|}</script><p>除了用伴随矩阵的方法来计算逆矩阵，还有如高斯消除（Gaussian elimination）等其他方法。高斯消除法的运算量会更小，但针对图形学最常用的$3\times 3$和$4 \times 4$大小的矩阵，用伴随矩阵的方法就已经足够。</p>
<p>逆矩阵有如下性质：</p>
<ol>
<li><p>逆矩阵的逆矩阵等于原矩阵</p>
<script type="math/tex; mode=display">\left(\mathbf{M}^{-1}\right)^{-1}=\mathbf{M}</script></li>
<li><p>单位矩阵的逆矩阵为本身。</p>
<script type="math/tex; mode=display">\mathbf{I^{-1}=I}</script><ul>
<li>单位矩阵并不是唯一的逆矩阵为本身的矩阵，反射矩阵和旋转180°的矩阵通用也满足。</li>
</ul>
</li>
<li><p>转置的逆矩阵等于逆矩阵的转置</p>
<script type="math/tex; mode=display">\left(\mathbf{M}^{\mathrm{T}}\right)^{-1}=\left(\mathbf{M}^{-1}\right)^{\mathrm{T}}</script></li>
<li><p>乘积的逆矩阵等于相反顺序的逆矩阵的乘积</p>
<script type="math/tex; mode=display">(\mathbf{A B})^{-1}=\mathbf{B}^{-1} \mathbf{A}^{-1}</script></li>
<li><p>逆矩阵的行列式等于原矩阵行列式的倒数</p>
<script type="math/tex; mode=display">\left|\mathbf{M}^{-1}\right|=1 /|\mathbf{M}|</script></li>
</ol>
<h3 id="Matrix-Inverse-Geometric-Interpretation"><a href="#Matrix-Inverse-Geometric-Interpretation" class="headerlink" title="Matrix Inverse-Geometric Interpretation"></a>Matrix Inverse-Geometric Interpretation</h3><p>逆矩阵的几何意义即是相反的变换，相当于一个变换的undo。</p>
<script type="math/tex; mode=display">(\mathbf{v M}) \mathbf{M}^{-1}=\mathbf{v}\left(\mathbf{M M}^{-1}\right)=\mathbf{v} \mathbf{I}=\mathbf{v}</script><h2 id="Orthogonal-Matrices"><a href="#Orthogonal-Matrices" class="headerlink" title="Orthogonal Matrices"></a>Orthogonal Matrices</h2><h3 id="Orthogonal-Matrices-Official-Linear-Algebra-Rules"><a href="#Orthogonal-Matrices-Official-Linear-Algebra-Rules" class="headerlink" title="Orthogonal Matrices-Official Linear Algebra Rules"></a>Orthogonal Matrices-Official Linear Algebra Rules</h3><p>一个方阵当且仅当它和它的转置乘积为单位矩阵时，这个矩阵为正交矩阵（Orthogonal Matrix）：</p>
<script type="math/tex; mode=display">\mathbf{M} \text { is orthogonal } \Longleftrightarrow \quad \mathbf{M M}^{\mathrm{T}}=\mathbf{I}</script><p>同时因为$\mathbf{M}^{-1} \mathbf{M}=\mathbf{I}$，所以正交矩阵还满足：</p>
<script type="math/tex; mode=display">\mathbf{M} \text { is orthogonal } \Longleftrightarrow \mathbf{M}^{\mathrm{T}}=\mathbf{M}^{-1}</script><p>如果知道一个矩阵是正交的（如旋转和反射变换），那么可以很快的通过求其转置矩阵来获得逆矩阵。</p>
<h3 id="Orthogonal-Matrices-Geometric-Interpretation"><a href="#Orthogonal-Matrices-Geometric-Interpretation" class="headerlink" title="Orthogonal Matrices-Geometric Interpretation"></a>Orthogonal Matrices-Geometric Interpretation</h3><p>正交矩阵的意义在于其逆矩阵非常容易求得（转置矩阵即为逆矩阵）。</p>
<p>如果一个变换仅包含位移，旋转和反射，那么它为正交矩阵。</p>
<p>如果一个矩阵的每一行（或每一列）构成的基本向量长度为1，且相互垂直，那么它也是正交矩阵。</p>
<p>证明如下：</p>
<p>首先根据正交矩阵的定义，矩阵与矩阵的转置乘积为单位矩阵：</p>
<p>假设</p>
<script type="math/tex; mode=display">
\mathbf{M}=\left[\begin{array}{lll}
m_{11} & m_{12} & m_{13} \\
m_{21} & m_{22} & m_{23} \\
m_{31} & m_{32} & m_{33}
\end{array}\right]</script><p>且$\mathbf{M}$为正交矩阵，则有</p>
<script type="math/tex; mode=display">
\left[\begin{array}{lll}
m_{11} & m_{12} & m_{13} \\
m_{21} & m_{22} & m_{23} \\
m_{31} & m_{32} & m_{33}
\end{array}\right]\left[\begin{array}{lll}
m_{11} & m_{21} & m_{31} \\
m_{12} & m_{22} & m_{32} \\
m_{13} & m_{23} & m_{33}
\end{array}\right]=\left[\begin{array}{lll}
1 & 0 & 0 \\
0 & 1 & 0 \\
0 & 0 & 1
\end{array}\right]</script><p>用$\mathbf{r_1,r_2,r_3}$代表矩阵$\mathbf{M}$的每个基本向量（每一行），即</p>
<script type="math/tex; mode=display">\begin{aligned}
&\mathbf{r}_{1}=\left[\begin{array}{lll}
m_{11} & m_{12} & m_{13}
\end{array}\right]\\
&\mathbf{r}_{2}=\left[\begin{array}{lll}
m_{21} & m_{22} & m_{23}
\end{array}\right]\\
&\mathbf{r}_{3}=\left[\begin{array}{lll}
m_{31} & m_{32} & m_{33}
\end{array}\right]
\end{aligned}</script><script type="math/tex; mode=display">\mathbf{M}=\left[\begin{array}{l}
-\mathbf{r}_{1}- \\
-\mathbf{r}_{2}- \\
-\mathbf{r}_{3}-
\end{array}\right]</script><p>可得：</p>
<script type="math/tex; mode=display">\begin{array}{lll}
\mathbf{r}_{1} \cdot \mathbf{r}_{1}=1, & \mathbf{r}_{1} \cdot \mathbf{r}_{2}=0, & \mathbf{r}_{1} \cdot \mathbf{r}_{3}=0 \\
\mathbf{r}_{2} \cdot \mathbf{r}_{1}=0, & \mathbf{r}_{2} \cdot \mathbf{r}_{2}=1, & \mathbf{r}_{2} \cdot \mathbf{r}_{3}=0 \\
\mathbf{r}_{3} \cdot \mathbf{r}_{1}=0, & \mathbf{r}_{3} \cdot \mathbf{r}_{2}=0, & \mathbf{r}_{3} \cdot \mathbf{r}_{3}=1
\end{array}</script><p>即每个基本向量与自己的点乘值为1，去别的基本向量点乘值为0。即表明每个基本向量的长度为1，且与其他的基本向量相互垂直。</p>
<p>如果一个矩阵是正交矩阵，它的转置也必然是正交矩阵。因此无论矩阵的每一行还是每一列满足上述条件，都能证明它是正交矩阵。</p>
<div class="note warning simple"><p>在英语中有些术语会造成困扰。<code>orthogonal basis vectors</code>是描述一系列相互垂直的向量，但并没有限定它们的长度。如果它们满足长度为1，则称为<code>orthnormal basis verctors</code>。但是<code>orthogonal matrices</code>需要基本向量不仅相互垂直，而且长度为1。即<code>orthogonal basis vectores</code>不能构成<code>orthogonal matrices</code>，必须是<code>orthonormal basis vectores</code>才行。</p>
</div>
<h3 id="Orthogonalizing-a-Matrix"><a href="#Orthogonalizing-a-Matrix" class="headerlink" title="Orthogonalizing a Matrix"></a>Orthogonalizing a Matrix</h3><p>有时遇到一些矩阵因为数据的错误或者浮点误差（Floating point error）。</p>
<p>在这些情况下，需要通过一些变换将矩阵的基本向量变为互相垂直和长度为一。通常使用的方法为<code>Gram-Schmidt 正交化</code>。</p>
<p>首先将矩阵的标准向量（每一行）定义为$\mathbf{r}<em>{1}, \mathbf{r}</em>{2},$ 和 $\mathbf{r}<em>{3}$，并将转换后的满足相互垂直的基本向量定义为$\mathbf{r}</em>{1}^{\prime}, \mathbf{r}<em>{2}^{\prime},$ 和 $\mathbf{r}</em>{3}^{\prime}$。</p>
<p>其转换方法如下：</p>
<script type="math/tex; mode=display">\begin{aligned}
&\mathbf{r}_{1}^{\prime} \Leftarrow \mathbf{r}_{1}\\
&\begin{array}{l}
\mathbf{r}_{2}^{\prime} \Leftarrow \mathbf{r}_{2}-\frac{\mathbf{r}_{2} \cdot \mathbf{r}_{1}^{\prime}}{\mathbf{r}_{1}^{\prime} \cdot \mathbf{r}_{1}^{\prime}} \mathbf{r}_{1}^{\prime} \\
\mathbf{r}_{3}^{\prime} \Leftarrow \mathbf{r}_{3}-\frac{\mathbf{r}_{3} \cdot \mathbf{r}_{1}^{\prime}}{\mathbf{r}_{1}^{\prime} \cdot \mathbf{r}_{1}^{\prime}} \mathbf{r}_{1}^{\prime}-\frac{\mathbf{r}_{3} \cdot \mathbf{r}_{2}^{\prime}}{\mathbf{r}_{2}^{\prime} \cdot \mathbf{r}_{2}^{\prime}} \mathbf{r}_{2}^{\prime}
\end{array}
\end{aligned}</script><p>其中$\mathbf{r}<em>{2}^{\prime}$只所以这么定义，是为了从$\mathbf{r2}$中减去平行于$\mathbf{r1}$的部分，这样剩余部分$\mathbf{r}</em>{2}^{\prime}$即为垂直于$\mathbf{r1}$的部分。</p>
<p>且根据利用点乘求向量分量的定义可得，</p>
<script type="math/tex; mode=display">\begin{aligned}
r_{2}^{\prime} &=r_{2}-\left(r_{2} \cdot \hat{r}_{1}\right) \cdot \hat{r}_{1} \\
&=r_{2}-\left(r_{2} \cdot \frac{r_{1}^{\prime}}{\left|r_{1}\right|}\right) \cdot \frac{r_{1}^{\prime}}{\left|r_{1}\right|} \\
&=r_{2}-\frac{r_{2} \cdot r_{1}^{\prime}}{\left|r_{1}\right|^{2}} \cdot r_{1}^{\prime} \\
&=r_{2}-\frac{r_{2} \cdot r_{1}^{\prime}}{r_{1}^{\prime} \cdot r_{1}^{\prime}} \cdot r_{1}^{\prime}
\end{aligned}</script><p>求$\mathbf{r}_{3}^{\prime}$的过程同理。</p>
<p>对于$\mathbf{r}<em>{3}^{\prime}$还可以直接通过求得的$\mathbf{r}</em>{1}^{\prime}$和$\mathbf{r}_{2}^{\prime}$获得，即</p>
<script type="math/tex; mode=display">\mathbf{r}_{3}^{\prime} \Leftarrow \mathbf{r}_{1}^{\prime} \times \mathbf{r}_{2}^{\prime}</script><p>在求得相互垂直的向量$\mathbf{r}<em>{1}^{\prime}, \mathbf{r}</em>{2}^{\prime},$ 和 $\mathbf{r}_{3}^{\prime}$后，通过归一化基本求得长度为1的矩阵，如下：</p>
<script type="math/tex; mode=display">\begin{aligned}
&r_{1}^{\prime \prime}=\frac{r_{1}^{\prime}}{\left|r_{1}^{\prime}\right|}\\
&r_{2}^{\prime \prime}=\frac{r_{2}^{\prime}}{\left|r_{2}^{\prime}\right|}\\
&r_{3}^{\prime \prime}=\frac{r_{3}^{\prime}}{\left|r_{3}^{\prime}\right|}
\end{aligned}</script><p>还有一种方法是利用迭代来求得相互垂直的向量，称为<code>Nonbiased incremental 正交化</code>。如下：</p>
<script type="math/tex; mode=display">\begin{aligned}
&\mathbf{r}_{1}^{\prime} \Leftarrow \mathbf{r}_{1}-k \frac{\mathbf{r}_{1} \cdot \mathbf{r}_{2}}{\mathbf{r}_{2} \cdot \mathbf{r}_{2}} \mathbf{r}_{2}-k \frac{\mathbf{r}_{1} \cdot \mathbf{r}_{3}}{\mathbf{r}_{3} \cdot \mathbf{r}_{3}} \mathbf{r}_{3}\\
&\mathbf{r}_{2}^{\prime} \Leftarrow \mathbf{r}_{2}-k \frac{\mathbf{r}_{2} \cdot \mathbf{r}_{1}}{\mathbf{r}_{1} \cdot \mathbf{r}_{1}} \mathbf{r}_{1}-k \frac{\mathbf{r}_{2} \cdot \mathbf{r}_{3}}{\mathbf{r}_{3} \cdot \mathbf{r}_{3}} \mathbf{r}_{3}\\
&\mathbf{r}_{3}^{\prime} \Leftarrow \mathbf{r}_{3}-k \frac{\mathbf{r}_{3} \cdot \mathbf{r}_{1}}{\mathbf{r}_{1} \cdot \mathbf{r}_{1}} \mathbf{r}_{1}-k \frac{\mathbf{r}_{3} \cdot \mathbf{r}_{2}}{\mathbf{r}_{2} \cdot \mathbf{r}_{2}} \mathbf{r}_{2}
\end{aligned}</script><p>该方法时通过选取一个适当的k，进行反复迭代获取一个很近似正交的类型。</p>
<h2 id="4-times-4-Homogeneous-Matrices"><a href="#4-times-4-Homogeneous-Matrices" class="headerlink" title="$4\times 4$ Homogeneous Matrices"></a>$4\times 4$ Homogeneous Matrices</h2><p>这部分第一次提及了四维向量，称为齐次坐标（Homogeneous coordinate）。</p>
<h3 id="4D-Homogeneous-Space"><a href="#4D-Homogeneous-Space" class="headerlink" title="4D Homogeneous Space"></a>4D Homogeneous Space</h3><p>在四维向量中，第四个元素为$w$。</p>
<p>为了更好的理解物理的三维空间是如何扩展到四维空间的。先以二维空间为例，想象二维空间是存在于三维齐次空间中的一个平面，且第三个元素值为1，即$w=1$，所有在该平面上的点都可表示为$(x,y,1)$。所有不在$w=1$平面上的齐次坐标点$(x,y,w)$，都可以通过$(x/w,y/w,1)$转换到二维物理平面上。如下：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter6-Notes/image-20200308224234417.png" alt="二维齐次坐标" style="zoom:50%;" /></p>
<p>同样的，对于任何在二维平面上的点$(x,y)$都有无限多个相应的在齐次坐标中的点$(kx,ky,k)$。这些点构成一条穿越原点的直线。</p>
<p>当$w=0$时，除法是未定义的，所以没有相对应的在二维物理平面上的点。因此将$w=0$的坐标定义为是在无限远处的点，这些点是用来表示方向而不是位置，即$w=0$的坐标实际上是作为向量来进行处理，而$w\neq 0$的点才是作为表示位置的点。</p>
<p>将二维空间的概念推广到三维空间中，三维空间中的点也同样可以看作是在四维齐次空间中，只不过第四个元素值$w=1$。同样的，任意在四维齐次空间中的点，都可以通过$(x/w,y/w,z/w,1)$转换到三维空间中。当$w=0$时，坐标同样是用来表示向量而不是点。</p>
<p>在三维空间中引入四维齐次坐标主要有两个原因：</p>
<ol>
<li>为了计算上的便捷，因为位移需要用到四维矩阵，而将其他所有的变形都用四维矩阵表示可以方便计算。</li>
<li>第四个参数$w$可以用于表示透视投影（perspective projection）。</li>
</ol>
<h3 id="4-times-4-Translation-Matrices"><a href="#4-times-4-Translation-Matrices" class="headerlink" title="$4\times 4$ Translation Matrices"></a>$4\times 4$ Translation Matrices</h3><p>因为$n$维零向量与任何的$n\times n$矩阵相乘结果都是$n$维零向量，所以通过一个$3 \times 3$的矩阵是永远无法将一个点从原点移动出去的，即$n$维的矩阵无法在$n$维空间中表示位移。</p>
<p>但是可以通过一个$4 \times 4$的矩阵在三维空间中表示位移。如下所示：</p>
<script type="math/tex; mode=display">\left[\begin{array}{llll}
x & y & z & 1
\end{array}\right]\left[\begin{array}{cccc}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & 1 & 0 \\
\Delta x & \Delta y & \Delta z & 1
\end{array}\right]=\left[\begin{array}{lllll}
x+\Delta x & y+\Delta y & z+\Delta z & 1
\end{array}\right]</script><ul>
<li>注意这个变换在四维空间中，仍然是一个线性变换（具体来说是切变），但从三维空间角度来看，就是一个仿射变换，对三维向量进行了位移。</li>
</ul>
<p>另外三维矩阵可以扩展成四维矩阵来表示普通的三维向量的变换，如下所示：</p>
<script type="math/tex; mode=display">\begin{aligned}
&\left[\begin{array}{llll}
x & y & z & 1
\end{array}\right]\left[\begin{array}{cccc}
m_{11} & m_{12} & m_{13} & 0 \\
m_{21} & m_{22} & m_{23} & 0 \\
m_{31} & m_{32} & m_{33} & 0 \\
0 & 0 & 0 & 1
\end{array}\right]\\
&=\left[\begin{array}{llll}
x m_{11}+y m_{21}+z m_{31} & x m_{12}+y m_{22}+z m_{32} & x m_{13}+y m_{23}+z m_{33} & 1
\end{array}\right]
\end{aligned}</script><p>因此，如果一个三维向量需要先进行旋转变换（变换矩阵为$\mathbf{R}$），再进行位移变换（变换矩阵为$\mathbf{T}$），则矩阵及表达式如下：</p>
<script type="math/tex; mode=display">\mathbf{R}=\left[\begin{array}{cccc}
r_{11} & r_{12} & r_{13} & 0 \\
r_{21} & r_{22} & r_{23} & 0 \\
r_{31} & r_{32} & r_{33} & 0 \\
0 & 0 & 0 & 1
\end{array}\right], \quad \mathbf{T}=\left[\begin{array}{cccc}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & 1 & 0 \\
\Delta x & \Delta y & \Delta z & 1
\end{array}\right]</script><script type="math/tex; mode=display">\mathbf{v}^{\prime}=\mathbf{v R T}=\mathbf{v}(\mathbf{R T})=\mathbf{v M}</script><p>其中$\mathbf{M}$为两个变换结合的变换矩阵，表示如下：</p>
<script type="math/tex; mode=display">\begin{aligned}
\mathbf{M}=\mathbf{R} \mathbf{T} &=\left[\begin{array}{cccc}
r_{11} & r_{12} & r_{13} & 0 \\
r_{21} & r_{22} & r_{23} & 0 \\
r_{31} & r_{32} & r_{33} & 0 \\
0 & 0 & 0 & 1
\end{array}\right]\left[\begin{array}{cccc}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & 1 & 0 \\
\Delta x & \Delta y & \Delta z & 1
\end{array}\right] \\
&=\left[\begin{array}{cccc}
r_{11} & r_{12} & r_{13} & 0 \\
r_{21} & r_{22} & r_{23} & 0 \\
r_{31} & r_{32} & r_{33} & 0 \\
\Delta x & \Delta y & \Delta z & 1
\end{array}\right]
\end{aligned}</script><p>可以看出，矩阵$\mathbf{M}$是将$\mathbf{R}$和$\mathbf{T}$中的变换部分和在了一起，即</p>
<script type="math/tex; mode=display">\mathbf{M}=\left[\begin{array}{ll}
\mathbf{R} & \mathbf{0} \\
\mathbf{t} & 1
\end{array}\right]</script><p>另外如前所述，当一个齐次空间中的向量坐标的第四个元素$w=0$时，这个坐标表示的是位置而不是位移，如下所示，取向量的坐标为$\left[\begin{array}{llll}x &amp; y &amp; z &amp; 0\end{array}\right]$，与$\mathbf{M}$相乘的结果将不包含位移信息，如：</p>
<script type="math/tex; mode=display">\begin{array}{ll}
\left[\begin{array}{llllllll}
x & y & z & 0
\end{array}\right]\left[\begin{array}{llll}
r_{11} & r_{12} & r_{13} & 0 \\
r_{21} & r_{22} & r_{23} & 0 \\
r_{31} & r_{32} & r_{33} & 0 \\
\Delta x & \Delta y & \Delta z & 1
\end{array}\right] \\
& =\left[\begin{array}{llll}
x r_{11}+y r_{21}+z r_{31} & x r_{12}+y r_{22}+z r_{32} & x r_{13}+y r_{23}+z r_{33} & 0
\end{array}\right]
\end{array}</script><h3 id="General-Affine-Transformations"><a href="#General-Affine-Transformations" class="headerlink" title="General Affine Transformations"></a>General Affine Transformations</h3><p>在四维齐次空间中，就能实现仿射变换而不仅仅是线性变换，经常使用的仿射变换包括：</p>
<ol>
<li>绕着不经过原点的任意轴旋转</li>
<li>沿着不经过原点的任意轴缩放</li>
<li>沿着不经过原点的任意平面反射</li>
<li>投影至任意不包括原点的平面</li>
</ol>
<p>这些变换的基本思路都是，先将线性变换的中心（如旋转轴，缩放轴，投影平面等）移动到原点，再进行线性变换，最后位移回原点。将位移的矩阵命名为$\mathbf{T}$，将线性变换的矩阵命名为$\mathbf{R}$，即：</p>
<script type="math/tex; mode=display">\mathbf{T}=\left[\begin{array}{cccc}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & 1 & 0 \\
-p_{x} & -p_{y} & -p_{z} & 1
\end{array}\right]=\left[\begin{array}{cc}
\mathbf{I} & \mathbf{0} \\
-\mathbf{p} & 1
\end{array}\right]</script><script type="math/tex; mode=display">\mathbf{R}_{4 \times 4}=\left[\begin{array}{cccc}
r_{11} & r_{12} & r_{13} & 0 \\
r_{21} & r_{22} & r_{23} & 0 \\
r_{31} & r_{32} & r_{33} & 0 \\
0 & 0 & 0 & 1
\end{array}\right]=\left[\begin{array}{cc}
\mathbf{R}_{3 \times 3} & \mathbf{0} \\
\mathbf{0} & 1
\end{array}\right]</script><script type="math/tex; mode=display">\mathbf{T}^{-1}=\left[\begin{array}{cccc}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & 1 & 0 \\
p_{x} & p_{y} & p_{z} & 1
\end{array}\right]=\left[\begin{array}{ll}
\mathbf{I} & 0 \\
\mathbf{p} & 1
\end{array}\right]</script><p>按上述的，先位移再线性变换再位移回去的操作方法，实际变换过程为：</p>
<script type="math/tex; mode=display">\begin{aligned}
T R_{4 \times 4} T^{-1} &=\left[\begin{array}{ll}
I & 0 \\
-p & 1
\end{array}\right]\left[\begin{array}{ll}
R_{3\times 3} & 0 \\
0 & 1
\end{array}\right]\left[\begin{array}{ll}
I & 0 \\
p & 1
\end{array}\right] \\
&=\left[\begin{array}{ll}
R_{3\times 3} & 0 \\
-p \left(R_{3\times 3}\right) & 1
\end{array}\right]\left[\begin{array}{ll}
I & 0 \\
p & 1
\end{array}\right] \\
&=\left[\begin{array}{ll}
R_{3 \times 3} & 0 \\
-p\left(R_{3 \times 3}\right)+p & 1
\end{array}\right]
\end{aligned}</script><h2 id="4-times-4-Matrices-and-Perspective-Projection"><a href="#4-times-4-Matrices-and-Perspective-Projection" class="headerlink" title="$4 \times 4$ Matrices and Perspective Projection"></a>$4 \times 4$ Matrices and Perspective Projection</h2><p>在第五章中提到了正交投影，正交投影是一种平行投影，每条顶点和其投影点的连线是平行的，如下：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter6-Notes/image-20200309005931269.png" alt="正交投影" style="zoom:50%;" /></p>
<p>在3D中的透视投影（Perspective projection）投影同样也是投影到二维平面上，不同的是所有的顶点与投影点的连线会相会在投影中心（Center of projection）上，且在投影平面后这些连线的延伸会在投影平面上构成一个倒转的图形，如下所示：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter6-Notes/image-20200309010328675.png" alt="透视投影" style="zoom:50%;" /></p>
<p>对于一个透视投影来说，投影平面是固定的，投影中心距离投影平面的距离也是固定的，因此物体离投影中心越近，其在投影平面上的构成的图像大小就越大，这个现象称为透视收缩（perspective forshortening）。</p>
<h3 id="A-pinhole-Camera"><a href="#A-pinhole-Camera" class="headerlink" title="A pinhole Camera"></a>A pinhole Camera</h3><p>透视投影之所以在图形学中很重要，是因为它就是人类视觉系统工作的方式。人眼可以简化为是一个小孔成像系统，如下所示：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter6-Notes/image-20200309010825155.png" alt="小孔成像" style="zoom:50%;" /></p>
<p>盒子上的小孔即是投影中心，盒子的后表面就是投影平面。</p>
<p>小口成像可以用坐标来表示，将投影看作是原点，将物体的顶点看作是$p$点，将物体在投影平面上的成像看作是$p^{\prime}$，如下图所示：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter6-Notes/image-20200309011052254.png" alt="小孔成像坐标" style="zoom:50%;" /></p>
<p>根据三角形相似定理，可得：</p>
<script type="math/tex; mode=display">\frac{-p_{y}^{\prime}}{d}=\frac{p_{y}}{z} \quad \Longrightarrow \quad p_{y}^{\prime}=\frac{-d p_{y}}{z}</script><p>同理可得：</p>
<script type="math/tex; mode=display">p_{x}^{\prime}=\frac{-d p_{x}}{z}</script><p>因此，整个变换可以表达为：</p>
<script type="math/tex; mode=display">\mathbf{p}=\left[\begin{array}{lll}
x & y & z
\end{array}\right] \quad \Longrightarrow \quad \mathbf{p}^{\prime}=\left[\begin{array}{lll}
x^{\prime} & y^{\prime} & z^{\prime}
\end{array}\right]=\left[\begin{array}{ccc}
-d x / z & -d y / z & -d
\end{array}\right]</script><p>在计算机的实际运用中，上述结果中的负号是完全没意义的，因此可以等同于将投影平面移动到投影中心前面（这样的作法在真实物理世界中是不可行的），如下图：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter6-Notes/image-20200309011528877.png" alt="小孔成像坐标变形" style="zoom:50%;" /></p>
<p>则变换变为：</p>
<script type="math/tex; mode=display">\mathbf{p}^{\prime}=\left[\begin{array}{lll}
x^{\prime} & y^{\prime} & z^{\prime}
\end{array}\right]=\left[\begin{array}{lll}
d x / z & d y / z & d]
\end{array}\right.</script><h3 id="Perspective-Projection-Matrices"><a href="#Perspective-Projection-Matrices" class="headerlink" title="Perspective Projection Matrices"></a>Perspective Projection Matrices</h3><p>为了将上述的$p^{\prime}$转换到四维齐次空间中，需要为$xyz$三个分量找出一个公因数作为$w$，即</p>
<script type="math/tex; mode=display">\mathbf{p}^{\prime}=\left[\begin{array}{lll}
d x / z & d y / z & d
\end{array}\right]=\left[\begin{array}{lll}
d x / z & d y / z & d z / z
\end{array}\right]=\frac{\left[\begin{array}{lll}
x & y & z
\end{array}\right]}{z / d}</script><p>公因数为$z/d$，因此可以转换为齐次坐标：</p>
<script type="math/tex; mode=display">\left[\begin{array}{llll}
x & y & z & z / d
\end{array}\right]</script><p>对于齐次向量$[x,y,z,1]$如果想要转换到上述的齐次坐标，需要用下列矩阵，该矩阵称为投影矩阵：</p>
<script type="math/tex; mode=display">\left[\begin{array}{llll}
x & y & z & 1
\end{array}\right]\left[\begin{array}{llll}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & 1 & 1 / d \\
0 & 0 & 0 & 0
\end{array}\right]=\left[\begin{array}{llll}
x & y & z & z / d
\end{array}\right]</script><blockquote>
<p>通过矩阵，求出$\left[\begin{array}{llll}<br>x &amp; y &amp; z &amp; z / d<br>\end{array}\right]$的过程并不是透视投影，将$\left[\begin{array}{llll}<br>x &amp; y &amp; z &amp; z / d<br>\end{array}\right]$转换为$\left[\begin{array}{llll}<br>d x / z &amp; d y / z &amp; d &amp; 1<br>\end{array}\right]$的过程才是。</p>
</blockquote>
<p>在真实运用中，投影矩阵会比这里更加复杂（同样也会称为裁剪矩阵），主要的区别在于：</p>
<ol>
<li>在远剪切平面会保证$w=1$。这样做保证了深度检测的精确性（//TODO why？）。</li>
<li>还需要对$x，y$进行缩放来满足摄像机的视野（Field of view）要求。</li>
</ol>
<div class="note info simple"><p>引用：</p>
<ol>
<li><em>3D Math Primer for Graphics and Game Development</em> 2nd 2011 </li>
</ol>
</div>
<hr>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>3D数学</tag>
      </tags>
  </entry>
  <entry>
    <title>《MDA： A Formal Approach to Game Design and Game Research》 笔记</title>
    <url>/AFormalApproachToGameDesignAndGameResearch-Notes/</url>
    <content><![CDATA[<p>《MDA： A Formal Approach to Game Design and Game Research》 笔记</p>
<p>这篇论文中，作者提出了一个名为MDA的形式上的框架，A指玩家游戏的感受，D指游戏运行时的行为，M指游戏的基本规则元素。</p>
<p>作者认为可以通过框架帮助设计师分析游戏，如从A推导出M，或从M预测会导致的A。</p>
<span id="more"></span>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>在这篇论文中，作者提出了MDA框架（Mechanics，Dynamics,Aesthetics的缩写），这一种形式上的理解游戏的方法。该方法尝试将游戏设计与游戏开发联系在一起，将游戏评论和技术上的游戏研究联系在一起。</p>
<h2 id="Towards-a-Comprehensive-Framework"><a href="#Towards-a-Comprehensive-Framework" class="headerlink" title="Towards a Comprehensive Framework"></a>Towards a Comprehensive Framework</h2><p>目前的游戏研究很多是针对一个游戏领域，这篇文章是从整个游戏的角度去思考：从游戏系统的基本方法，到游戏设计的总体目标，到最终玩家的体验。</p>
<p>一个系统性的连贯性是从解决和满足系统中各个部分的限制和要求中创造的。对于游戏而言，连贯性需要从游戏的各个层面中获得，可以通过自底向上的思考，即思考如何通过游戏代码实现游戏概念，概念又如何最终体现在玩家体验，也可以从自顶向下的思考，即从玩家体验开始分析，体验是如何从游戏概念中获得的，游戏概念又是怎么通过游戏代码实现的。</p>
<p>MDA框架就是帮助游戏从业者进行上述的思考，无论是自底向上还是自顶向下。</p>
<h2 id="MDA"><a href="#MDA" class="headerlink" title="MDA"></a>MDA</h2><p>游戏设计师和玩家的关系是，游戏设计师创造了游戏，玩家消费游戏，如下图所示：</p>
<p><img src="AFormalApproachToGameDesignAndGameResearch-Notes/2020-03-19-23-16-11.png" alt="游戏设计师与玩家"></p>
<p>玩家消费设计师创造的游戏的过程，可以看作为是“设计师定义了游戏的规则，游戏的规则构成了游戏系统，游戏系统决定了玩家的游戏体验”，如下所示：</p>
<p><img src="AFormalApproachToGameDesignAndGameResearch-Notes/2020-03-19-23-20-44.png" alt="游戏消费过程"></p>
<p>可以将整个过程抽象为如下：</p>
<p><img src="AFormalApproachToGameDesignAndGameResearch-Notes/2020-03-19-23-21-02.png" alt="抽象游戏消费过程"></p>
<p>Mechancis：下简称为M，表示游戏的算法和数据结构<br>Dynamics：下简称为D，表示游戏运行时的行为，包括玩家的输入和游戏系统的输出<br>Aesthetics：下简称为A，描述了玩家在游戏时的情绪上的反应</p>
<p>这个框架的基本思想是，游戏是相对于媒体而言，更像是一个手工制品，它的内容很大一部分来自于玩家的行为。而不是像电影这样的媒介，所有的内容都是直接传递给观众的。</p>
<h2 id="MDA-in-Detail"><a href="#MDA-in-Detail" class="headerlink" title="MDA in Detail"></a>MDA in Detail</h2><h3 id="MDAs-as-Lens"><a href="#MDAs-as-Lens" class="headerlink" title="MDAs as Lens"></a>MDAs as Lens</h3><p>可以将MDA作为一个观察游戏的方法。设计师的角度使用MDA来看游戏，游戏的M在运行时形成了D，最后反应为玩家的A。从玩家角度来看，A是来自于观察D，而D是来自也运行的M。如下所示：</p>
<p><img src="AFormalApproachToGameDesignAndGameResearch-Notes/2020-03-19-23-29-55.png" alt="MDA在设计师与玩家之间的关系"></p>
<p>可以看出，无论是修改M还是A，都会最终都会反映在MDA的另一端。</p>
<h3 id="Aesthetics"><a href="#Aesthetics" class="headerlink" title="Aesthetics"></a>Aesthetics</h3><p>A表示玩家游戏时的体验，设计师的目的是让玩家在游戏时感到有趣，有趣可以体现在如下方面：</p>
<ol>
<li>Sensation：来自于感官愉悦</li>
<li>Fantasy：来自于幻想</li>
<li>Narrative：来自于故事情节</li>
<li>Challenge：来自于克服困难</li>
<li>Fellowship：来自于社交</li>
<li>Discovery：来自于发现的过程</li>
<li>Expression：来自于自我情感的发现</li>
<li>Submission：来自于消磨时光</li>
</ol>
<p>大部分的游戏的有趣都是上述多个点的结合，如<em>最终幻想</em>是Fantasy, Narrative, Expression, Discovery, Challenge, Submission，<em>模拟人生</em>是 Discovery, Fantasy, Expression, Narrative。但是每个游戏中这些不同的点不是平均的，都有各自的着重点。</p>
<h3 id="Aesthetic-Models"><a href="#Aesthetic-Models" class="headerlink" title="Aesthetic Models"></a>Aesthetic Models</h3><p>A模型是作为一个指南针的存在，指导D和M该如何去设计实现。</p>
<p>如在竞技游戏中，玩家的情绪上的参与感（A）是来自于击败对手的渴望，所以在设计游戏时，D和M的关键就在于如何提供快速清晰的反馈和对抗性的游戏方式。</p>
<h3 id="Dynamic-Models"><a href="#Dynamic-Models" class="headerlink" title="Dynamic Models"></a>Dynamic Models</h3><p>D模型直接影戏了玩家对于游戏的体验（即D构成了A）。比如，A中的Challenge来自游戏时的时间限制或者对手的竞争，Fellowship来自于游戏时同一个队伍的信息交流，或者游戏时玩家发现组队合作比自己单打独斗更有利。</p>
<p>在设计时，应该先构建一个模型，用这个模型来预测游戏运行时会发生的事情（D）。如<em>大富翁</em>中每次玩家有两个六面筛子，那么投筛子出现的点数概率分布如下：</p>
<p><img src="AFormalApproachToGameDesignAndGameResearch-Notes/2020-03-19-23-54-15.png" alt="筛子点数分布"></p>
<p>可以根据这个模型来预测游戏时，玩家走完一圈需要花费多少时间。</p>
<p>同样的，可以进一步通过游戏运行时发生的事（D），来预测玩家的情绪（A）。</p>
<p>如大富翁中，富有的玩家拥有更多的土地，拥有土地多的玩家有更高的概率收到租金，于是就会变得更加的富有，而贫穷的玩家会愈发贫穷，且富有的玩家始终是少数，毕竟资源是有限的。那么在游戏中，只有小部分的富有玩家会有参与感。</p>
<p>这个问题可以通过引入负反馈解决，如在游戏中更多的奖励贫困玩家，或给富有玩家增加限制，通过这些规则（M）来改变运行时的情况（D）进而改变玩家的情绪（A）。</p>
<h3 id="Mechanics"><a href="#Mechanics" class="headerlink" title="Mechanics"></a>Mechanics</h3><p>M包括玩家在游戏中可以进行的操作和行为，以及玩家可以看到的各种游戏元素等等。如对于射击游戏而言，武器，弹药和玩家的出生点就是M。</p>
<p>修改M可以最终影响到运行时的D，如在大富翁中为富有的玩家引入税，为贫困的玩家引入保证金。税和保证金就是M，但他们构成了负反馈，即会影响了运行时的D。而这些D的变换，会改变只有极少数的玩家有参与感的问题，即又进一步影响了玩家的A。</p>
<h3 id="Tuning"><a href="#Tuning" class="headerlink" title="Tuning"></a>Tuning</h3><p>在分析游戏时，需要反反复复的进行迭代，去修改M。该如何修改M的想法可以来自于对D和A的分析。</p>
<h2 id="MDA-at-Work"><a href="#MDA-at-Work" class="headerlink" title="MDA at Work"></a>MDA at Work</h2><p>这里作者以设计一款针对不同年龄段的游戏作为例子，展示如何从上层的A推导出M该如何创建。这里的例子是些非常笼统的概念，需要展示的仅仅是A到M的推导。</p>
<h3 id="First-Pass"><a href="#First-Pass" class="headerlink" title="First Pass"></a>First Pass</h3><p>如果一个游戏是针对3到7岁的孩子，那么游戏的A应该专注于Exploration和Discovery，这样要需要游戏时的行为（D）不是竞赛性的，所以游戏中的规则和元素（M）可以是轻松愉快的，如有趣的内置语音与玩家交流，与孩子大闹的小物件等等。</p>
<h3 id="Second-Pass"><a href="#Second-Pass" class="headerlink" title="Second Pass"></a>Second Pass</h3><p>如果是针对7-12岁的孩子，那么游戏的A应该是有更多的Challenge，或许也应该包含一些narrative。在运行时（D）,玩家应该可以与别的玩家进行交流，共同发展关系，也可以增加一些时间限制（M）来实现Challenge。</p>
<h3 id="Third-Pass"><a href="#Third-Pass" class="headerlink" title="Third Pass"></a>Third Pass</h3><p>如果针对14-35岁的玩家，游戏的A可以是关于Fantasy的，有更多的Challenge等。这时候运行时就可以有更多策略方面的玩法，比如选择适当的技能，进行适当的战斗，对应的M可以是技能树之类的元素。</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>综上，MDA是一个形式化的，帮助设计与开发的迭代框架。即游戏设计师通过从玩家的A出发，来推导出该如何设计M，或者从M出发，预测会导致怎么样的A。</p>
<div class="note info simple"><p>引用：</p>
<ol>
<li>Hunicke, R., LeBlanc, M. and Zubek, R., 2004, July. MDA: A formal approach to game design and game research. In Proceedings of the AAAI Workshop on Challenges in Game AI (Vol. 4, No. 1, p. 1722).</li>
</ol>
</div>
<hr>
]]></content>
      <categories>
        <category>论文笔记</category>
      </categories>
      <tags>
        <tag>论文笔记</tag>
        <tag>游戏设计</tag>
      </tags>
  </entry>
  <entry>
    <title>《计算机网络与因特网》 第一章笔记</title>
    <url>/CNI-Chapter1-Notes/</url>
    <content><![CDATA[<p>《计算机网络与因特网》 第一章笔记</p>
<p>笼统的介绍了网络的五个关键领域，一些网络基本概念，TCP/IP分组模型，OSI模型等。</p>
<span id="more"></span>
<h1 id="Chapter1-Introduction-And-Overview"><a href="#Chapter1-Introduction-And-Overview" class="headerlink" title="Chapter1 Introduction And Overview"></a>Chapter1 Introduction And Overview</h1><h2 id="Growth-Of-Computer-Networking"><a href="#Growth-Of-Computer-Networking" class="headerlink" title="Growth Of Computer Networking"></a>Growth Of Computer Networking</h2><p>计算机网络正在持续的爆炸性成长。在1970年代它只是一个非常小范围的研究课题，在1980年也只有几个网站，但到现在计算机网络已经成为了生活中的一部分。</p>
<h2 id="Why-Networking-Seems-Complex"><a href="#Why-Networking-Seems-Complex" class="headerlink" title="Why Networking Seems Complex"></a>Why Networking Seems Complex</h2><p>计算机网络是一个高速发展的领域。</p>
<p>对于初学者而言，他可能让人觉得很困惑，因为并没有一个最基础的理论来将计算机网络的所有部分联系在一起。有许多组织都定义了计算机网络的标准，而有时这些标准相互之间并不兼容。</p>
<p>计算机网络用语也并没有一个统一的标准，许多组织都定义过自己一套用语规范，这又很容易让初学者们感到困惑。</p>
<h2 id="The-Five-Key-ASpects-of-Networking"><a href="#The-Five-Key-ASpects-of-Networking" class="headerlink" title="The Five Key ASpects of Networking"></a>The Five Key ASpects of Networking</h2><p>计算机网络包括五个关键领域：</p>
<ol>
<li>网络应用与网络编程</li>
<li>数据通信</li>
<li>分组交换与网络技术</li>
<li>TCP/IP的网络互联</li>
<li>附加的网络概念和技术</li>
</ol>
<h3 id="Network-Applications-and-network-programming"><a href="#Network-Applications-and-network-programming" class="headerlink" title="Network Applications and network programming"></a>Network Applications and network programming</h3><p>用户使用网络服务和设施是基于一个安装在电脑上的应用程序，这个程序可以与其他电脑上的程序通过网络进行交流。网络程序有很多种类，包括邮件，下载器，游览器等。</p>
<p>所有这些程序都是构建在一个单一的、共享的网络上，因此开发者可以使用同一套接口来进行开发。</p>
<p>计算机网络的只是可以帮助开发者更好的开发网络应用。</p>
<h3 id="Data-Communications"><a href="#Data-Communications" class="headerlink" title="Data Communications"></a>Data Communications</h3><p>数据通信是电子工程的主要领域，它基于一些物理现象来传输数据，是一个较底层的方法。</p>
<p>因为数据通信是基于物理概念，所以乍看起来它与计算机网络的学习并没有太深的关系，但数据通信中的一些关键概念影响了通信规范的制定。例如调制中带宽的概念直接影响了网络的吞吐量。</p>
<p>数据通信也引入了复用的概念，即多个来源的数据可以被组合在一起通过一个共享的媒介进行传输，然后再分开传递给不同的目的地。</p>
<p>数据通信包含了许多底层的细节，他为计算机网络构建了基础。</p>
<h3 id="Packet-Switching-And-Networking-Technologies"><a href="#Packet-Switching-And-Networking-Technologies" class="headerlink" title="Packet Switching And Networking Technologies"></a>Packet Switching And Networking Technologies</h3><p>通信网络已经从早期的依赖于物理点线进行的点对点电报或电话系统转换为一个通信电路。早期的通过线连接已经转换为通过电交换。</p>
<p><code>分组交换（Packet switching）</code>从最底层的方式改变了网络，是现代网络的基础。多个信息发送者不再需要依赖于专用网络，通过分组交换他们可以通过一个共享的网络来传输数据。</p>
<p>分组交换将数据分为许多小块，称为包<code>Packets</code>，包中都包含一个目的地的信息。网络中的设备都包含了如何抵达其他地址的信息，当设备接收到一个包后他会解析包中的数据，并选择一个通路将其送给正确的目的地。</p>
<p>因为计算机网络在设计时有许多不同的需求，例如速度，距离，经济成本等，有许多分组交换技术被发明出来，他们针对不同的需求在细节上存在着一些差异。</p>
<h3 id="Internetworking-with-TCP-IP"><a href="#Internetworking-with-TCP-IP" class="headerlink" title="Internetworking with TCP/IP"></a>Internetworking with TCP/IP</h3><p>在一段时间内，许多研究者都致力于找到一个可以满足所有需求的分组交换技术。在1973年，Vinton Cerf 和 Pobert Kahn认为不存在一种分组交换技术可以满足所有的需求，因此他们致力于将不同的技术融合在一起。他们发展了一系列的标准，并最终成为了<code>TCP/IP协议族(TCP/IP Internet Protocol)</code>(简称为TCP/IP)。这最终成为了全球网络的基础，并称为计算机网络的一个重要组成部分。</p>
<p>TCP/IP标准成功的一个重要原因是它宽容的异质性。TCP/IP使用了一个虚拟的方法来定义网络不相关的包好网络不相关的检测方法。因此即使分组技术在持续的发展，因为TCP/IP始终可以与新的分组技术共存。</p>
<h3 id="Additional-Networking-Concepts-And-Technologies"><a href="#Additional-Networking-Concepts-And-Technologies" class="headerlink" title="Additional Networking Concepts And Technologies"></a>Additional Networking Concepts And Technologies</h3><p>除了构造网络的硬件和协议，还有大量的其他技术为网络提供了不同偶给你能。</p>
<p>例如<code>软件定义网络(Software Defined Networking(SDN))</code>允许管理者定义和控制网络，<code>物联网(Internet to Thing)</code>让嵌入式系统可以通过网络进行交流。</p>
<h2 id="Public-and-Private-Parts-Of-The-Internet"><a href="#Public-and-Private-Parts-Of-The-Internet" class="headerlink" title="Public and Private Parts Of The Internet"></a>Public and Private Parts Of The Internet</h2><p>计算机网络是由<code>公共网络(Public network)</code>和<code>私人网络(Private network)</code>构成的。</p>
<h3 id="Public-Network"><a href="#Public-Network" class="headerlink" title="Public Network"></a>Public Network</h3><p>公共网络是<code>服务提供商(Service Provider)</code>所拥有的服务，服务商会将服务提供给任何订阅了的个人或组织。这里的公共指的是大众都可以订阅这个服务，并不意味着公共网络传输的数据是被暴露在外，所有人都可以获取的。</p>
<h3 id="Private-Network"><a href="#Private-Network" class="headerlink" title="Private Network"></a>Private Network</h3><p>私人网络是指网络的使用权被限制在一个组间。如果服务商将服务租赁给了个人或公司，个人或公司仅在自己的范围内使用这个网络，那么它就是私人网络。</p>
<p>私人网络按其大小可以被分类为以下四种：</p>
<ol>
<li>消费者(Consumer)</li>
<li>小型办公室/家庭办公室(Small Office/Home Office,SOHO)</li>
<li>中小型商用(small-medium Business，SMB)</li>
<li>大型企业(Large enterprise)</li>
</ol>
<h2 id="Networks-Interoperability-And-Standards"><a href="#Networks-Interoperability-And-Standards" class="headerlink" title="Networks,Interoperability,And Standards"></a>Networks,Interoperability,And Standards</h2><p>通信至少包含两个实体，信息发送者和信息接受者。为了保证网络中的所有实体都能正确的交流，需要有一个共同的标准。</p>
<p>使用<code>互操作性(Interoperability)</code>来表示两个实体是否可以无误的彼此通信。</p>
<p>为了保证实体可以正确的彼此交流，他们需要遵守一系列共同的规则，这些规则被称为<code>通信协议(Communication protocol/Network protocol/Protocol)</code>。</p>
<ol>
<li>在通信发生错误的时候需要采取的行动也是由通信协议来指定。</li>
<li>通信协议可以是底层的，例如电压或信号的制定，也可以高层的，如软件传输的数据类型。</li>
</ol>
<h2 id="Protocol-Suites-And-Layering-Models"><a href="#Protocol-Suites-And-Layering-Models" class="headerlink" title="Protocol Suites And Layering Models"></a>Protocol Suites And Layering Models</h2><p>为了避免重复工作，每个协议应该只负责其他协议未包含的部分，因此协议的制定并非是相互独立的。将一系列合作的协议称为<code>族(Suites/Families)</code>。族中的每个协议都只关注通信中的一部分，族中的所有协议组合起来就覆盖了整个通信的所有方面。</p>
<p>一个用来将协议分组的基本抽象是<code>分组模型(Layering model)</code>，分组模型将所有通信问题分为几个部分，每个部分称为<code>一层(Layer)</code>。将所有协议按层分组帮助协议的设计者和实现者有效的控制了问题的复杂度，因为他们只需要关注与网络的一个方面即可。</p>
<p>下图展示了因特网的分组模型，也成为TCP/IP分组模型：</p>
<p><img src="CNI-Chapter1-Notes/2019-11-22-20-21-21.png" alt="TCP/IP分组模型"></p>
<h3 id="Layer-1-Physical"><a href="#Layer-1-Physical" class="headerlink" title="Layer 1:Physical"></a>Layer 1:Physical</h3><p>物理层的协议指定了传输媒介和相关硬件的细节。电子相关的属性，频率，信号等都属于物理层。</p>
<h3 id="Layer-2-Network-Interface-MAC"><a href="#Layer-2-Network-Interface-MAC" class="headerlink" title="Layer 2: Network Interface(MAC)"></a>Layer 2: Network Interface(MAC)</h3><p>网络接口层的协议指定了对网络通信的细节以及网络硬件与Layer3（Internet层）的通信细节。硬件地址，网络地址，网络可支持的最大包数据以及传输媒介的协议等信息都属于网络接口层。</p>
<p>TCP/IP的设计者将这一层命名为<code>网络接口层（Network Interface）</code>，但一些协会更喜欢称为<code>数据链路层（Data Link）</code>，工业界又喜欢称为<code>媒介访问控制层（Media Access Control,MAC）</code></p>
<h3 id="Layer-3：Internet"><a href="#Layer-3：Internet" class="headerlink" title="Layer 3：Internet"></a>Layer 3：Internet</h3><p>因特网层是因特网的基础。因特网地址结构，因特网包的结构，大包拆分成小包的方式，报告错误的方式都属于因特网层。</p>
<h3 id="Layer-4：Transport"><a href="#Layer-4：Transport" class="headerlink" title="Layer 4：Transport"></a>Layer 4：Transport</h3><p>传输层协议提供了计算机上的一个应用与另一台机器上的应用交流的方法。如接收端接收数据的最大速率，避免网络堵塞的方法，和保证接收端按顺序接收数据的技术都属于传输层。</p>
<h3 id="Layer-5-Application"><a href="#Layer-5-Application" class="headerlink" title="Layer 5: Application"></a>Layer 5: Application</h3><p>应用层的协议指定了通过网络交流的应用传输的数据信息的格式和意义，以及需要执行的步骤。如邮件，文件传输，语音电话等的实现都属于应用层。</p>
<h2 id="How-Data-passes-Through-Layers"><a href="#How-Data-passes-Through-Layers" class="headerlink" title="How Data passes Through Layers"></a>How Data passes Through Layers</h2><p>分组模型并不只是为了帮助理解协议，协议的实现满足某一层协议的输出需要匹配相邻层协议的输入。</p>
<p>如下图展示了两台电脑通过网络传输数据的过程：</p>
<p><img src="CNI-Chapter1-Notes/2019-11-22-20-59-21.png" alt="网络数据传输过程"></p>
<p>一号电脑是数据的发送方，二号电脑是数据的接收方。数据从一号电脑的应用层逐渐向下传递，通过接口层进入网络，在进入网络并传输后，通过二号电脑的接口层传入，再向上逐渐传递到应用层。</p>
<h2 id="Headers-And-Layers"><a href="#Headers-And-Layers" class="headerlink" title="Headers And Layers"></a>Headers And Layers</h2><p>每一层的协议为了保证数据被正确的传递都进行了一些计算。在发送端的每一层中都将一些额外的信息加到了数据包中，对应的，在接受段的每一层中都将解析并移除这些额外的信息。</p>
<p>这些被协议额外加入的数据称为<code>数据头(header)</code>。以发送端为例，数据头是在数据逐层向下的过程中一步步被加入的，即传输层增加一些数据头，网络层增加一些数据头，接口层增加一些数据头。因此最终的数据会如下图所示，最靠近原始数据的数据头是最早被添加的：</p>
<p><img src="CNI-Chapter1-Notes/2019-11-22-21-08-20.png" alt="网络数据头添加"></p>
<ul>
<li>虽然图中每个被添加的数据头大小看起来相同，但实际上都不是一个固定的大小。</li>
</ul>
<h2 id="ISO-And-The-OSI-Seven-Layer-Reference-Model"><a href="#ISO-And-The-OSI-Seven-Layer-Reference-Model" class="headerlink" title="ISO And The OSI Seven Layer Reference Model"></a>ISO And The OSI Seven Layer Reference Model</h2><p>在因特网模型发展的过程中，有两个组织定义了一个替代的参考模型，称为<code>开放式系统互联参考七层模型(Open Systems Interconnection Seven-Layer Reference Model)</code>，简称为<code>OSI模型</code>。</p>
<p>这两个组织分别是<code>国际标准化组织（International Organization for Standardization）</code>，简称为<code>ISO</code>和<code>国际电信联盟（International Telecommunications Union）(ITU)</code>中的电信标准部门。</p>
<p><code>OSI</code>协议图如下：</p>
<p><img src="CNI-Chapter1-Notes/2019-11-22-23-01-16.png" alt="OSI协议"></p>
<p>TCP/IP协议比OSI协议更为高效合理，发展和部署OSI协议的工作已经被停滞。许多工作者目前在扩展OSI协议的定义来让其符合TCP/IP，基本是让Network层匹配Internet层，然后再在Session层和Presentation层增加一些支持协议。</p>
<p>虽然许多工程师和商业部门知道<code>OSI协议</code>不如<code>TCP/IP协议</code>高效，但他们依然处于某些原因在坚持使用。</p>
<h2 id="Remainder-Of-The-Text"><a href="#Remainder-Of-The-Text" class="headerlink" title="Remainder Of The Text"></a>Remainder Of The Text</h2><p>书的剩下部分将分为五个部分，基本对应与1.3节中提到的五个重要领域。</p>
<p>第一部分介绍网络应用和网络编程</p>
<p>第二部分介绍数据通信和信息传输</p>
<p>第三部分介绍分组交换以及包数据，另外也会介绍一些网络的基本分类，如局域网和广域网</p>
<p>第四部分将介绍TCP/IP协议族</p>
<p>第五部分介绍剩下的一些网络相关的技术</p>
<div class="note info simple"><p>引用：</p>
<ol>
<li><em>Computer Networks and Internets</em> 6th</li>
</ol>
</div>
<hr>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《3D数学基础：图形和游戏开发》第八章笔记</title>
    <url>/3DMathPrimerForGraphicsAGameDevelopment-Chapter8-Notes/</url>
    <content><![CDATA[<p>《3D 数学基础：图形和游戏开发》第八章笔记</p>
<p>8.1 节 介绍了朝向（Orientation）的概念。</p>
<p>8.2 节 介绍了如何用矩阵表示朝向。</p>
<p>8.3 节 介绍如何使用欧拉角表示朝向。</p>
<p>8.4 节 介绍如何使用轴角法和指数映射表示朝向。</p>
<p>8.5 节 介绍如何使用四元数表示朝向</p>
<p>8.6 节 比较了各个表示方法的利弊</p>
<p>8.7 节 介绍了各个表示方法如何相互转换。</p>
<span id="more"></span>
<h1 id="Chapter-8-Rotation-in-Three-Dimensions"><a href="#Chapter-8-Rotation-in-Three-Dimensions" class="headerlink" title="Chapter 8 Rotation in Three Dimensions"></a>Chapter 8 Rotation in Three Dimensions</h1><h2 id="What-Exactly-is-“Orientation”"><a href="#What-Exactly-is-“Orientation”" class="headerlink" title="What Exactly is “Orientation”"></a>What Exactly is “Orientation”</h2><p><code>方向（direction）</code>只需要两个参数表示，而<code>朝向（orientation）</code>需要三个参数表示。如下图中确认飞机的朝向需要两个参数，而朝向还需要图中的绿圈方向来决定其旋转角度。</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter8-Notes/2020-04-01-12-32-22.png" alt="绿色的光圈"></p>
<p><code>朝向（orientation）</code>，<code>旋转（rotation）</code>和<code>角位移（angular displacement）</code>三者的关系为，<code>旋转</code>将物体从一个<code>朝向</code>转换为另一个<code>朝向</code>，这个转换的数值为<code>角位移</code>。</p>
<p>角位移与朝向的关系与线段和点的关系有点类似，前者都是表示一个变换，后者都是表示一个状态。</p>
<h2 id="Matrix-Form"><a href="#Matrix-Form" class="headerlink" title="Matrix Form"></a>Matrix Form</h2><p>这一节是描述用$3 \times 3$的矩阵来描述旋转。</p>
<h3 id="Which-Matrix？"><a href="#Which-Matrix？" class="headerlink" title="Which Matrix？"></a>Which Matrix？</h3><p>矩阵很常用的操作是坐标系的转换，其中两个用的比较多的是</p>
<ol>
<li>从物体坐标系转换为直立坐标系——乘以变换矩阵</li>
<li>从直立坐标系转换为物体坐标系——乘以变换矩阵的逆矩阵</li>
</ol>
<p>在这里，每个对象都含有一个$3 \times 3$的矩阵表示朝向，进行变换的矩阵只包含旋转信息，即它是一个正交矩阵（虽然反转矩阵也是正交矩阵，但这里只包含旋转信息）。</p>
<h3 id="Direction-Consines-Matrix"><a href="#Direction-Consines-Matrix" class="headerlink" title="Direction Consines Matrix"></a>Direction Consines Matrix</h3><p>通过矩阵来进行旋转实际上是从方向余弦（Direction cosines）这个概念中得到的。一个方向预先矩阵就是一个旋转矩阵。</p>
<p>假设变换前的三个坐标轴分别为$\hat{\mathbf{x}}<em>{1}, \hat{\mathbf{x}}</em>{2}, \hat{\mathbf{x}}<em>{3}$，变换后的三个坐标轴分别为$\hat{\mathbf{e}}</em>{1}, \hat{\mathbf{e}}<em>{2}, \hat{\mathbf{e}}</em>{3}$。</p>
<p>那么$\hat{\mathbf{e}}<em>{i}$和$\hat{\mathbf{x}}</em>{j}$之间的方向余弦$a_{ij}$定义为：</p>
<script type="math/tex; mode=display">a_{i j} \stackrel{\text {def}}{=} \cos \left(\theta_{i j}\right)=\frac{\hat{\mathbf{e}}_{i} \cdot \hat{\mathbf{x}}_{j}}{|\hat{\mathbf{e}}_{i}||\hat{\mathbf{x}}_{j}|}= \hat{\mathbf{e}}_{i} \cdot \hat{\mathbf{x}}_{j}</script><p>而且坐标轴$\hat{e<em>{i}}$可以通过其在$\hat{x</em>{i}}$上的分量累加进行表示。又$\hat{e_{i}}$在原坐标轴上的分量可以通过$cos$求得。于是可得：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\hat{\mathbf{e}}_{1}=\cos \left(\theta_{11}\right) \hat{\mathbf{x}}_{1}+\cos \left(\theta_{12}\right) \hat{\mathbf{x}}_{2}+\cos \left(\theta_{13}\right) \hat{\mathbf{x}}_{3}=a_{11} \hat{\mathbf{x}}_{1}+a_{12} \hat{\mathbf{x}}_{2}+a_{13} \hat{\mathbf{x}}_{3}\\
&\hat{\mathbf{e}}_{2}=\cos \left(\theta_{21}\right) \hat{\mathbf{x}}_{1}+\cos \left(\theta_{22}\right) \hat{\mathbf{x}}_{2}+\cos \left(\theta_{23}\right) \hat{\mathbf{x}}_{3}=a_{21} \hat{\mathbf{x}}_{1}+a_{22} \hat{\mathbf{x}}_{2}+a_{23} \hat{\mathbf{x}}_{3}\\
&\hat{\mathbf{e}}_{3}=\cos \left(\theta_{31}\right) \hat{\mathbf{x}}_{1}+\cos \left(\theta_{32}\right) \hat{\mathbf{x}}_{2}+\cos \left(\theta_{33}\right) \hat{\mathbf{x}}_{3}=a_{31} \hat{\mathbf{x}}_{1}+a_{32} \hat{\mathbf{x}}_{2}+a_{33} \hat{\mathbf{x}}_{3}
\end{aligned}</script><p>如果将这个变换用矩阵表示，即为：</p>
<script type="math/tex; mode=display">
A=\left[\begin{array}{lll}
\cos \left(\theta_{11}\right)& \cos \left(\theta_{12}\right)& \cos \left(\theta_{13}\right) \\
\cos \left(\theta_{21}\right)& \cos \left(\theta_{22}\right)& \cos \left(\theta_{23}\right) \\
\cos \left(\theta_{31}\right)& \cos \left(\theta_{32}\right)& \cos \left(\theta_{33}\right)
\end{array}\right] \\
=\left[\begin{array}{lll}
\hat{\mathbf{e}}_{1} \cdot \hat{\mathbf{x}}_{1}& \hat{\mathbf{e}}_{1} \cdot \hat{\mathbf{x}}_{2}& \hat{\mathbf{e}}_{1} \cdot \hat{\mathbf{x}}_{3} \\
\hat{\mathbf{e}}_{2} \cdot \hat{\mathbf{x}}_{1}& \hat{\mathbf{e}}_{2} \cdot \hat{\mathbf{x}}_{2}& \hat{\mathbf{e}}_{2} \cdot \hat{\mathbf{x}}_{3}\\
\hat{\mathbf{e}}_{3} \cdot \hat{\mathbf{x}}_{1}& \hat{\mathbf{e}}_{3} \cdot \hat{\mathbf{x}}_{2}& \hat{\mathbf{e}}_{3} \cdot \hat{\mathbf{x}}_{3}
\end{array}\right]</script><p>书中用$\mathbf{p}, \mathbf{q}$ 和 $\mathbf{r}$表示原先的坐标轴，用$\mathbf{p}^{\prime}, \mathbf{q}^{\prime}$ 和 $\mathbf{r}^{\prime}$表示变换后的坐标轴，将其带入上矩阵，可得</p>
<script type="math/tex; mode=display">
A=\left[\begin{array}{lll}
\mathbf{p} \cdot \mathbf{p}^{\prime} & \mathbf{q} \cdot \mathbf{p}^{\prime} & \mathbf{r} \cdot \mathbf{p}^{\prime} \\
\mathbf{p} \cdot \mathbf{q}^{\prime} & \mathbf{q} \cdot \mathbf{q}^{\prime} & \mathbf{r} \cdot \mathbf{q}^{\prime} \\
\mathbf{p} \cdot \mathbf{r}^{\prime} & \mathbf{q} \cdot \mathbf{r}^{\prime} & \mathbf{r} \cdot \mathbf{r}^{\prime}
\end{array}\right]</script><p>注意这个变换矩阵是用来将用$\mathbf{p}, \mathbf{q}, \mathbf{r}$表达的向量转换为用$\mathbf{p}^{\prime}, \mathbf{q}^{\prime}, \mathbf{r}^{\prime}$表达的向量，即</p>
<script type="math/tex; mode=display">
\mathbf{v}A=\mathbf{v^{\prime}}</script><p>如果用$[1,0,0], [0,1,0], [0,0,1]$来表示$\mathbf{p}, \mathbf{q}, \mathbf{r}$并带入上矩阵，可得</p>
<script type="math/tex; mode=display">
\left[\begin{array}{lll}
{[1,0,0] \cdot \mathbf{p}^{\prime}} & {[0,1,0] \cdot \mathbf{p}^{\prime}} & {[0,0,1] \cdot \mathbf{p}^{\prime}} \\
{[1,0,0] \cdot \mathbf{q}^{\prime}} & {[0,1,0] \cdot \mathbf{q}^{\prime}} & {[0,0,1] \cdot \mathbf{q}^{\prime}} \\
{[1,0,0] \cdot \mathbf{r}^{\prime}} & {[0,1,0] \cdot \mathbf{r}^{\prime}} & {[0,0,1] \cdot \mathbf{r}^{\prime}}
\end{array}\right]=\left[\begin{array}{lll}
p_{x}^{\prime} & p_{y}^{\prime} & p_{z}^{\prime} \\
q_{x}^{\prime} & q_{y}^{\prime} & q_{z}^{\prime} \\
r_{x}^{\prime} & r_{y}^{\prime} & r_{z}^{\prime}
\end{array}\right]=\left[\begin{array}{l}
-\mathbf{p}^{\prime}- \\
-\mathbf{q}^{\prime}- \\
-\mathbf{r}^{\prime}-
\end{array}\right]</script><p>即矩阵的每一行是用原坐标轴表示的变换后的坐标轴（这一点在前面的推导过程中也能看出$\hat{\mathbf{e}}<em>{i}$，是由$\hat{\mathbf{x}}</em>{i}$表示的）。</p>
<p>同理，如果用$[1,0,0], [0,1,0], [0,0,1]$表示$\mathbf{p}^{\prime}, \mathbf{q}^{\prime}, \mathbf{r}^{\prime}$带入上矩阵，可得：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{ccc}
\mathbf{p} \cdot[1,0,0] & \mathbf{q} \cdot[1,0,0] & \mathbf{r} \cdot[1,0,0] \\
\mathbf{p} \cdot[0,1,0] & \mathbf{q} \cdot[0,1,0] & \mathbf{r} \cdot[0,1,0] \\
\mathbf{p} \cdot[0,0,1] & \mathbf{q} \cdot[0,0,1] & \mathbf{r} \cdot[0,0,1]
\end{array}\right]=\left[\begin{array}{ccc}
p_{x} & q_{x} & r_{x} \\
p_{y} & q_{y} & r_{y} \\
p_{z} & q_{z} & r_{z}
\end{array}\right]=\left[\begin{array}{ccc}
| & | & | \\
\mathbf{p}^{\mathrm{T}} & \mathbf{q}^{\mathrm{T}} & \mathbf{r}^{\mathrm{T}} \\
| & | & |
\end{array}\right]</script><p>即矩阵的每一列，是由变换后的坐标轴表示的原坐标轴。</p>
<h3 id="Advantages-of-Matrix-Form"><a href="#Advantages-of-Matrix-Form" class="headerlink" title="Advantages of Matrix Form"></a>Advantages of Matrix Form</h3><p>用矩阵表示旋转的优点如下：</p>
<ol>
<li>向量的旋转可以很快的实现，包括坐标系的变换等</li>
<li>绝大部分图形 API 都是通过矩阵来进行变换的。</li>
<li>多个变换矩阵可以级联，即矩阵相乘</li>
<li>当要进行逆操作时，矩阵取反即可</li>
</ol>
<h3 id="Disadvantages-of-Matrix-Form"><a href="#Disadvantages-of-Matrix-Form" class="headerlink" title="Disadvantages of Matrix Form"></a>Disadvantages of Matrix Form</h3><p>用矩阵表示旋转的缺点如下：</p>
<ol>
<li>矩阵花费更多的内存。用来表示三维空间旋转的矩阵为$3\times 3$的矩阵，要 9 个数字，而通过欧拉角只要三个数字。</li>
<li>人无法直观理解。虽然可以通过每一行进行判断，但是矩阵用来表示旋转仍不够直观。而且所有的数字都会被归一到$-1\sim 1$的范围内（为了表示长度位为一的单位向量）。</li>
<li>矩阵可能存在格式错误。<br>a. 并不是随手写一个矩阵都能表示旋转的，旋转矩阵必须是正交矩阵，同时还不能是反转变换。所以矩阵中的数据必须要额外小心，必须满足旋转的表达格式。<br>b. 可能由进度不够造成数据错误。因为旋转矩阵中的元素数值通常范围为$-1\sim 1$，当表示一些变换时，精度可能会不够。因此在变换过程中，当小数点后数据进行了舍弃，可能导致无法满足旋转矩阵的性质，这种现象称为矩阵蠕变（Matrix creep）。可以通过矩阵的正交化解决（在第六章有提到）。</li>
</ol>
<h2 id="Eular-Angles"><a href="#Eular-Angles" class="headerlink" title="Eular Angles"></a>Eular Angles</h2><p>欧拉角表示旋转的基本思路是通过连续的绕着三个相互垂直的轴的角位移来表示旋转。</p>
<p>理论上来说，这三个相互垂直的轴可以是任意的，但通常来说，都选择一个坐标系的三个基轴（cardinal axes）。在这本书中，称为<code>heading-pitch-bank</code>，绕着这三个轴的旋转如下图所示：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter8-Notes/2020-04-02-08-34-50.png" alt="heading-pitch-bank旋转"></p>
<p>第一张图显示的是原始状态，第二张图是绕着 heading 轴（直立坐标系下的 y 轴）旋转，第三张图是绕着 pitch 轴旋转（物体坐标系下的 x 轴），第四章图是绕着 bank 轴旋转（物体坐标系下的 z 轴）。</p>
<h3 id="Other-Euler-Angle-Conventions"><a href="#Other-Euler-Angle-Conventions" class="headerlink" title="Other Euler Angle Conventions"></a>Other Euler Angle Conventions</h3><p>还存在很多其他的欧拉角旋转表达方式，如很常见的<code>yaw-pitch-roll</code>。这种表达方式下，通常<code>roll</code>与<code>bank</code>的含义一模一样，但<code>heading</code>和<code>yaw</code>有细微差别，<code>heading</code>是直立坐标系的 y 轴，<code>yaw</code>是物体坐标系的 y 轴。</p>
<p>如果所有的旋转轴都是直立坐标系的轴，则称为固定轴（Fixed-Axis）旋转。而传统的欧拉角旋转都是绕着物体自己的坐标系的轴。两种方式实际上是等效的，只要用相反的顺序执行旋转即可（传统欧拉：yaw-pitch-roll,固定轴：roll-pitch-yaw）。因为传统欧拉角旋转顺序中，前一个轴的旋转会影响后面的轴的位置，而固定轴欧拉角的旋转顺序则不会。</p>
<p>在最原始的欧拉角定义，实际上第一个轴和第三个轴是相同的，这种定义又被命名为<code>proper Euler angles</code>。而现在常用的欧拉角，实际上称为<code>Tait-Bryan angles</code>。</p>
<ul>
<li>这一节中提到个各种命名，并不是绝对的，即可能现在命名名字相同但是含义却不同的情况。</li>
<li>在这里提及各种命名，实际上是为了让读者在接触其他的系统时，首先确认下其中的欧拉角定义方式是否不同，如旋转正方向，绕什么轴旋转，绕不同轴旋转的顺序等。</li>
<li>不同定义的欧拉角进行转换过程，通常是先原始欧拉角转换为矩阵，再从矩阵<br>转换为目标欧拉角</li>
</ul>
<h3 id="Advantages-of-Euler-Angles"><a href="#Advantages-of-Euler-Angles" class="headerlink" title="Advantages of Euler Angles"></a>Advantages of Euler Angles</h3><p>欧拉角表达的优点在于：</p>
<ol>
<li>人可以直观理解。当需要人来输入旋转角度时，通常欧拉角表达是唯一的选择。</li>
<li>欧拉角用了最少的数字来表达旋转。另外因为欧拉角中的数字是用来表达角度的，所以不会像在矩阵中的数字一样，局限在范围$-1\sim 1$之中，也因此浮点数的精度误差也不会像在矩阵中严重。</li>
<li>任意三个数值的组合都是合法的。</li>
</ol>
<h3 id="Disadvantages-of-Euler-Angles"><a href="#Disadvantages-of-Euler-Angles" class="headerlink" title="Disadvantages of Euler Angles"></a>Disadvantages of Euler Angles</h3><ol>
<li>对于一个旋转角度的表达不唯一，即存在别名。</li>
<li>在不同角度之间的线性差值变换可能存在问题。</li>
<li>万向锁</li>
</ol>
<p>第一个别名问题，一是因为所有的角度都可以加上 360° 保持不变，第二个原因是因为绕着三个轴的旋转并非完全相互独立，如 pitch 向下 135°，和先 heading 转 180 再 pitch 向下 45° 效果一样。</p>
<p>而这个问题可以通过标准坐标（canonical）解决。限制 heading 和 bank 的范围为$\left(-180^{\circ},+180^{\circ}\right]$，pitch 的范围是$\left[-90^{\circ},+90^{\circ}\right]$。但这样还存在一个歧义性，当 pitch 角度是$\pm 90^{\circ}$时，heading 和 bank 旋转是一样的效果，这个现象称为万向锁（Gimbal Lock）。在这种情况下，定义变换的轴是 heading，bank 轴始终为 0。</p>
<p>因此欧拉角的标准坐标规则为：</p>
<script type="math/tex; mode=display">
\left\{\begin{aligned}
-180^{\circ}<& h \leq 180^{\circ} \\
-90^{\circ} \leq & p \leq 90^{\circ} \\
-180^{\circ}<b & \leq 180^{\circ} \\
p=\pm 90^{\circ} & \Rightarrow \quad b=0
\end{aligned}\right.</script><p>当通过代码实现欧拉角时，最好保证返回的数值时标准坐标。</p>
<p>第二个问题是关于角度变换插值的。<br>插值变换是指，有两个角度$\mathbf{R}<em>{0}$ 和 $\mathbf{R}</em>{1}$，希望通过参数$0 \leq t \leq 1$，实现$\mathbf{R}(t)$在$\mathbf{R}<em>{0}$ 和 $\mathbf{R}</em>{1}$间线性变化。类似于：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\Delta \theta &=\theta_{1}-\theta_{0} \\
\theta_{t} &=\theta_{0}+t \Delta \theta
\end{aligned}</script><p>欧拉角的插值变换问题第一种可能是由别名造成的，如下所示：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter8-Notes/2020-04-02-09-13-03.png" alt="别名插值错误"></p>
<p>在其中两个角度实际上相差为$45^{\circ}$，但因为用了别名表示，路径多走了将近两圈。这种可能可以通过使用标准坐标表示解决。</p>
<p>第二个问题如下：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter8-Notes/2020-04-02-09-19-43.png" alt="非别名插值错误"></p>
<p>其中$-170^{\circ}和170^{\circ}$都是在范围$(-180^{\circ},+180^{\circ}]$内，因此满足标准规范。但实际上两者相差 20°，却要插值 340°。</p>
<p>解决方法是通过<code>wrapPi</code>进行计算，计算式子如下：</p>
<script type="math/tex; mode=display">\operatorname{wrap} \operatorname{Pi}(x)=x-360^{\circ}\left\lfloor\left(x+180^{\circ}\right) / 360^{\circ}\right\rfloor</script><p>其中的 x 即为两个角度相减后的插值，在此例中为 340。</p>
<p>因此线性插值表达式应该为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\Delta \theta &=\operatorname{wrap} \mathrm{Pi}\left(\theta_{1}-\theta_{0}\right) \\
\theta_{t} &=\theta_{0}+t \Delta \theta
\end{aligned}</script><p>第三个问题万向锁无法被解决。只要使用了三个数值来表达旋转，那么当第二个轴旋转至 90° 时，第一个轴与第三个轴的旋转效果都会变得相同。</p>
<h2 id="Axis-Angle-and-Exponential-Map-Representations"><a href="#Axis-Angle-and-Exponential-Map-Representations" class="headerlink" title="Axis-Angle and Exponential Map Representations"></a>Axis-Angle and Exponential Map Representations</h2><p>欧拉还提出了欧拉旋转理论（Euler‘s rotation theorem）：任何的 3D 旋转，都可以通过绕着某一个轴的单一旋转实现。如给定了两个旋转$\mathbf{R}_1和\mathbf{R}_2$，存在一个轴$\hat{\mathbf{n}}$，使得$\mathbf{R}_1和\mathbf{R}_2$两个旋转的结合可以通过绕着$\hat{\mathbf{n}}$轴的一次旋转搞定。</p>
<p>这种通过轴$\hat{\mathbf{n}}$和一个旋转角度$\theta$来表示的方法称为轴角法（Axis-Angle）。</p>
<p>而指数映射法(exponential map)是更进一步，通过$\mathbf{e}=\theta \hat{\mathbf{n}}$将轴和角结合在一起表示。如果想获取角度，可以通过$\theta=|\mathbf{e}|$。如果想获取旋转轴，可以对$\mathbf{e}$进行归一化，即$\hat{\mathbf{n}}=\bar{\mathbf{e}}$。</p>
<p>当$\theta=0$时，轴角法会出现歧义性，但是指数映射法不会（因为最终值已经变为了 0）.同样，因为角度和轴的正负号造成的别名问题，指数映射法中也不会发生，因为正负号被相乘的操作抵消了。</p>
<p>但是因为加减$360^{\circ}$造成的别名问题，无论是轴角法还是指数映射法中都会出现。</p>
<p>同时，在使用指数映射法的时候，多个角度的旋转不能通过加法来获得。因为加法操作是支持交换律的，而旋转操作不支持。</p>
<p>如有两个旋转$\mathbf{e}<em>{1}=\left[90^{\circ}, 0,0\right]$ 和$\mathbf{e}</em>{2}=\left[0,90^{\circ}, 0\right]$，先执行$\mathbf{e}<em>{1}$和先执行$\mathbf{e}</em>{2}$的结果是不同的。因为旋转轴都是针对于物体坐标的，后者的旋转轴位置会受前一个旋转的影响。</p>
<p>但是这个结果的差距会随着角度的缩小而缩小，如旋转的角度是 2° 的话，那么结果的差异相对来说没有那么明显。因此一定意义上如果旋转的角度足够小，那么可以通过指数映射法的加法来结合角度的旋转。</p>
<p>轴角法更多的是一个概念上的方法，在实际上中运用的比较少。四元数实际上是通过轴角法演变来的。</p>
<p>指数映射法运用的相对较多。在计算角速度的时候，通常使用指数映射法。一是因为指数映射法受加减 360° 别名的影响，因此可以保留速度的变换。二是因为虽然指数映射法的加法无法完美结合多个变换，但是可以结合多个变换的变换角度的大小。</p>
<h2 id="Quaternions"><a href="#Quaternions" class="headerlink" title="Quaternions"></a>Quaternions</h2><p>从数学上可以证明为什么用欧拉角来表示三维空间旋转必然会引起万向锁，所用方法为“manifolds”，但这个论证超出了本书的范围。</p>
<h3 id="Quaternion-Notation"><a href="#Quaternion-Notation" class="headerlink" title="Quaternion Notation"></a>Quaternion Notation</h3><p>四元数通常包含一个标量部分（$\mathbf{w}$），和一个三维向量部分（$\mathbf{v}$），即四元数标记为：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{ll}
w & \mathbf{v}
\end{array}\right], \quad\left[\begin{array}{llll}
w & (x & y & z)
\end{array}\right]</script><p>四元数也可以通过纵向表示，如：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{c}
w \\
\left(\begin{array}{l}
x \\
y \\
z
\end{array}\right)
\end{array}\right]</script><p>但不像向量中的横向量与纵向量会影响计算，四元数的横向与纵向表示没有任何区别，仅仅是写法的不同。</p>
<h3 id="What-Do-Those-Four-Numers-Mean？"><a href="#What-Do-Those-Four-Numers-Mean？" class="headerlink" title="What Do Those Four Numers Mean？"></a>What Do Those Four Numers Mean？</h3><p>之前提到了轴角法表示旋转，即通过$(\theta, \hat{\mathbf{n}})$表达旋转。可以将其表示为四元数，将其中的旋转角度和旋转轴的信息进行编码放入四个数中，如下所示：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\left[\begin{array}{ll}
w & \mathbf{v}
\end{array}\right]=[\cos (\theta / 2) \quad \sin (\theta / 2) \hat{\mathbf{n}}]\\
&\left.\left[\begin{array}{llll}
w & (x & y & z
\end{array}\right)\right]=\left[\cos (\theta / 2) \quad\left(\sin (\theta / 2) n_{x} \quad \sin (\theta / 2) n_{y} \quad \sin (\theta / 2) n_{z}\right)\right]
\end{aligned}</script><p>这样的四元数是关于角度旋转的，其中的$\mathbf{v}$和旋转轴$\hat{\mathbf{n}}$相关，$\omega$和旋转角度$\theta$相关。</p>
<p>这样是几何意义上的四元数，但是从复数层面或者其他学科中，四元数还有其他用处，只不过超出了本书的范围。</p>
<h3 id="Quaternion-Negation"><a href="#Quaternion-Negation" class="headerlink" title="Quaternion Negation"></a>Quaternion Negation</h3><blockquote>
<p>从第三节到第 11 节都是关于四元数的操作</p>
</blockquote>
<p>四元数的取反操作如下：</p>
<script type="math/tex; mode=display">
\begin{aligned}
-\mathbf{q} &\left.=-\left[w \quad\left(\begin{array}{lll}
w & y & z
\end{array}\right)\right]=\left[\begin{array}{llll}
-w & (-x & -y & -z
\end{array}\right)\right] \\
&=-[w \quad \mathbf{v}]=\left[\begin{array}{ll}
-w & -\mathbf{v}
\end{array}\right]
\end{aligned}</script><p>从几何意义上来说，$\mathbf{q}$和$\mathbf{-q}$没有任何区别。因为根据上一节中四元数数据的定义，因为每个操作符都是对于$\theta/2$，给$\theta$加上 360°，其数值就会取反，但是旋转的角度仍然相同。</p>
<h3 id="Identity-Quaternion-s"><a href="#Identity-Quaternion-s" class="headerlink" title="Identity Quaternion(s)"></a>Identity Quaternion(s)</h3><p>从几何意义角度上说，存在两个单位四元数，表示没有任何的旋转，它们为：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{ll}
1 & 0
\end{array}\right] \text { 和 }\left[\begin{array}{ll}
-1 & 0
\end{array}\right]</script><p>当$\theta$为偶数倍的 360° 时，$\cos(\theta /2) =1$，对应上式中第一个单位四元数。当$\theta$为奇数倍的 360° 时，$\cos(\theta /2) =-1$，对应上式中第二个单位四元数。在两种情况下，$\sin(\theta/2)$都为 0，所以$\hat{\mathbf{n}}的取值也是没关系的$。</p>
<p>但从代数角度上说，实际上只有$\left[\begin{array}{ll}1 &amp; 0\end{array}\right]$一个四元数。</p>
<h3 id="Quaternion-Magnitude"><a href="#Quaternion-Magnitude" class="headerlink" title="Quaternion Magnitude"></a>Quaternion Magnitude</h3><p>对于任意的四元数，求模的公式如下：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\|\mathbf{q}\| &=\left\|\left[w \quad\left(\begin{array}{ll}
x & y
\end{array} \quad z\right)\right]\right\|=\sqrt{w^{2}+x^{2}+y^{2}+z^{2}} \\
&=\|[w \quad \mathbf{v}]\|=\sqrt{w^{2}+\|\mathbf{v}\|^{2}}
\end{aligned}</script><p>对于表示旋转的几何意义上的四元数，其求模过程如下：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\|\mathbf{q}\| &=\|[w \quad \mathbf{v}]\|=\sqrt{w^{2}+\|\mathbf{v}\|^{2}} \\
&=\sqrt{\cos ^{2}(\theta / 2)+(\sin (\theta / 2)\|\hat{\mathbf{n}}\|)^{2}} \\
&=\sqrt{\cos ^{2}(\theta / 2)+\sin ^{2}(\theta / 2)\|\hat{\mathbf{n}}\|^{2}} \\
&=\sqrt{\cos ^{2}(\theta / 2)+\sin ^{2}(\theta / 2)(1)} \\
&=\sqrt{1} \\
&=1
\end{aligned}</script><p>即用于表达旋转的四元数，其模为 1。</p>
<p>在几何中，通常<code>unit quaternions</code>用来描述这些模为 1 的四元数，并且同样翻译为单位四元数。</p>
<h3 id="Quaternion-Conjugate-and-Inverse"><a href="#Quaternion-Conjugate-and-Inverse" class="headerlink" title="Quaternion Conjugate and Inverse"></a>Quaternion Conjugate and Inverse</h3><p>四元数有共轭操作，表示为$\mathbf{q}*$，计算过程如下：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\mathbf{q}^{*} &=\left[\begin{array}{ll}
w & \mathbf{v}
\end{array}\right]^{*}=\left[\begin{array}{ll}
w & -\mathbf{v}
\end{array}\right] \\
&\left.\left.=\left[\begin{array}{lll}
w & (x & y & z
\end{array}\right)\right]^{*}=\left[\begin{array}{llll}
w & (-x & -y & -z
\end{array}\right)\right]
\end{aligned}</script><p>四元数也有取反操作，表示为$\mathbf{q}^{-1}$，计算过程如下：</p>
<script type="math/tex; mode=display">\mathbf{q}^{-1}=\frac{\mathbf{q}^{*}}{\|\mathbf{q}\|}</script><p>且类似于矩阵，同样有性质：</p>
<script type="math/tex; mode=display">
\mathbf{q}\mathbf{q}^{-1}=\left[\begin{array}{ll}
1 & \mathbf{0}
\end{array}\right]</script><p>从几何意义上来说，用于旋转的四元数，因为模为 1，所以$\mathbf{q}^{*}=\mathbf{q}^{-1}$。它们都表示为绕着相反的轴（因为$\mathbf{v}$取反了）进行旋转。</p>
<h3 id="Quaternion-Multiplication"><a href="#Quaternion-Multiplication" class="headerlink" title="Quaternion Multiplication"></a>Quaternion Multiplication</h3><p>四元数的相乘和矩阵的叉乘类似，叉乘返回的是向量，四元数相乘返回的是四元数。如下所示：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\mathbf{q}_{1} \mathbf{q}_{2} &\left.=\left[w_{1} \quad\left(\begin{array}{ccc}
x_{1} & y_{1} & z_{1}
\end{array}\right)\right]\left[\begin{array}{ccc}
w_{2} & \left(x_{2}\right. & y_{2} & z_{2}
\end{array}\right)\right] \\
&=\left[\begin{array}{c}
w_{1} w_{2}-x_{1} x_{2}-y_{1} y_{2}-z_{1} z_{2} \\
\left(\begin{array}{l}
w_{1} x_{2}+x_{1} w_{2}+y_{1} z_{2}-z_{1} y_{2} \\
w_{1} y_{2}+y_{1} w_{2}+z_{1} x_{2}-x_{1} z_{2} \\
w_{1} z_{2}+z_{1} w_{2}+x_{1} y_{2}-y_{1} x_{2}
\end{array}\right)
\end{array}\right] \\
&=\left[\begin{array}{lll}
w_{1} & \mathbf{v}_{1}
\end{array}\right]\left[\begin{array}{ll}
w_{2} & \mathbf{v}_{2}
\end{array}\right] \\
&=\left[w_{1} w_{2}-\mathbf{v}_{1} \cdot \mathbf{v}_{2} \quad w_{1} \mathbf{v}_{2}+w_{2} \mathbf{v}_{1}+\mathbf{v}_{1} \times \mathbf{v}_{2}\right]
\end{aligned}</script><p>四元数的乘法，满足结合律，不满足交换律</p>
<script type="math/tex; mode=display">
\begin{aligned}
(\mathbf{a b}) \mathbf{c} &=\mathbf{a}(\mathbf{b} \mathbf{c}) \\
\mathbf{a b} & \neq \mathbf{b a}
\end{aligned}</script><p>乘积的模等于模的乘积</p>
<script type="math/tex; mode=display">\left\|\mathbf{q}_{1} \mathbf{q}_{2}\right\|=\left\|\mathbf{q}_{1}\right\|\left\|\mathbf{q}_{2}\right\|</script><p>乘积的逆，等于逆按相反顺序的乘积</p>
<script type="math/tex; mode=display">
\begin{aligned}
(\mathbf{a b})^{-1} &=\mathbf{b}^{-1} \mathbf{a}^{-1} \\
\left(\mathbf{q}_{1} \mathbf{q}_{2} \cdots \mathbf{q}_{n-1} \mathbf{q}_{n}\right)^{-1} &=\mathbf{q}_{n}^{-1} \mathbf{q}_{n-1}^{-1} \cdots \mathbf{q}_{2}^{-1} \mathbf{q}_{1}^{-1}
\end{aligned}</script><p>如果$\mathbf{q}$是一个表示旋转的四元数，那么下式可以表示旋转操作：</p>
<script type="math/tex; mode=display">\mathbf{p}^{\prime}=\mathbf{q p q}^{-1}</script><p>式子中的$\mathbf{p}$是描述一个点的四元数，如果在三维空间中的点$(x,y,z)$，用四元数表示则为$[0 \quad(x \quad y \quad z)]$。</p>
<p>使用该式子的例子如下：</p>
<p>如果存在点$\mathbf{P}=(1,0,0)$，希望其绕着+z 轴旋转 90°，则旋转四元数为$\left[\frac{\sqrt{2}}{2} \quad ( 0 \quad 0 \quad  \frac{\sqrt{2}}{2} ) \right]$，需要求得旋转的点$\mathbf{P^{‘}}$，计算过程如下：</p>
<script type="math/tex; mode=display">
p^{\prime}=q p q^{-1}</script><script type="math/tex; mode=display">
\begin{array}{l}
q p =\left[\frac{\sqrt{2}}{2} \quad\left(0 \quad 0 \quad\frac{\sqrt{2}}{2} \right)\right] \quad \left[0 \quad\left(1 \quad 0 \quad 0\right)\right] \\
=\left[0-0 \quad\left(\frac{\sqrt{2}}{2} \quad 0 \quad 0\right)+(0 \quad 0 \quad 0)+\left(0 \quad \frac{\sqrt{2}}{2} \quad  0\right)\right] \\
=\left[0 \quad\left(\frac{\sqrt{2}}{2} \quad \frac{\sqrt{2}}{2} \quad 0\right)\right]
\end{array}</script><script type="math/tex; mode=display">
\begin{array}{l}
q p q^{-1} =\left[0 \quad\left(\frac{\sqrt{2}}{2}\quad  \frac{\sqrt{2}}{2}\quad  0\right)\right]\left[\frac{\sqrt{2}}{2} \quad \left(0\quad 0\quad -\frac{\sqrt{2}}{2}\right)\right] \\
=\left[0-0 \quad \left(0 \quad 0 \quad 0\right)+\left(\frac{1}{2} \quad  \frac{1}{2} \quad  0\right) +\left(-\frac{1}{2} \quad \frac{1}{2} \quad 0\right)\right] \\
=\left[0 \quad\left(0 \quad 1 \quad 0\right)\right]
\end{array}</script><p>即求得变换后的四元数$\mathbf{p^{‘}}$为$\left[0 \quad\left(0 \quad 1 \quad 0\right)\right]$，因此变换后的点为$(0,1,0)$。</p>
<p>但这个式子只是理论上使用，实际操作中并不会使用这个式子进行旋转操作。可以通过这个式子做理论上的分析，如下式:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\mathbf{p}^{\prime} &=\mathbf{b}\left(\mathbf{a p a}^{-1}\right) \mathbf{b}^{-1} \\
&=(\mathbf{b} \mathbf{a}) \mathbf{p}\left(\mathbf{a}^{-1} \mathbf{b}^{-1}\right) \\
&=(\mathbf{b} \mathbf{a}) \mathbf{p}(\mathbf{b} \mathbf{a})^{-1}
\end{aligned}</script><p>该式子表示四元数的旋转可以级联，也表示了两个旋转操作（由$\mathbf{a}$和$\mathbf{b}$表示），可以结合为同一个旋转$\mathbf{ba}$</p>
<ul>
<li>当多个四元数表示多次相连的旋转时，其计算顺序是由内向外的（上式中先计算$\mathbf{a}$再计算$\mathbf{b}$）</li>
</ul>
<h3 id="Quaternion-“Difference”"><a href="#Quaternion-“Difference”" class="headerlink" title="Quaternion “Difference”"></a>Quaternion “Difference”</h3><p>四元数的差值（Difference）是用来表示两个朝向的角度相互变换时差距。</p>
<p>注意这里的差值并不是几何意义上的两个角度大小之间的差，和上一节中用于变换的旋转四元数也不相同。这里的差值指的是从一个角度变换为另一个角度需要进行的操作，将这个操作用四元数表示出来。</p>
<p>如给定了两个朝向$\mathbf{a}和\mathbf{b}$，需要求得差值$\mathbf{d}$满足：</p>
<script type="math/tex; mode=display">\mathbf{d a}=\mathbf{b}</script><p>可以根据下式求得$\mathbf{d}$,</p>
<script type="math/tex; mode=display">
\begin{aligned}
(\mathbf{d a}) \mathbf{a}^{-1} &=\mathbf{b a}^{-1} \\
\mathbf{d}\left(\mathbf{a a}^{-1}\right) &=\mathbf{b a}^{-1} \\
\mathbf{d}[1 \quad \mathbf{0}] &=\mathbf{b a}^{-1} \\
\mathbf{d} &=\mathbf{b a}^{-1}
\end{aligned}</script><p>例如有变换前的点$\mathbf{p}=\left[0 \quad\left(1 \quad 0 \quad 0\right)\right]$和变换后的点$\mathbf{p}^{\prime}=\left[0 \quad\left(0 \quad 1 \quad 0\right)\right]$，需要求得差值$d$</p>
<script type="math/tex; mode=display">d=p^{\prime}p^{-1}</script><script type="math/tex; mode=display">
\begin{array}{l}
d=\left[\begin{array}{cc}
0 & (0\quad 1\quad 0)
\end{array}\right]\left[\begin{array}{cc}
0 & (-1\quad 0\quad 0)
\end{array}\right] \\
=[0-0 \quad(0\quad 0\quad 0)+(0\quad 0\quad 0)+(0\quad 0\quad 1)] \\
= {[0 \quad(0\quad 0\quad 1)]}
\end{array}</script><p>如之前所述，这里求得的$\mathbf{d}$虽然形式上满足旋转四元数的定义，但是它并不是一个旋转四元数，而是表示两个点之间的差值。</p>
<p>这差值也同样不是几何意义上的两个点之间的角度差。如例子中的$\mathbf{p}=[0 (\quad 1 \quad 0 \quad 0)]$和$\mathbf{p^{\prime}}=[0 (\quad 0 \quad 1 \quad 0)]$，两者实际上的角度差值是 90°（绕着+z）轴。但是这里求出的$\mathbf{d}=[0 \quad(0\quad 0\quad 1)]$，如果按旋转四元数来解释$\mathbf{d}$，那么$\cos(\theta/2)=0$，$\theta=180^{\circ}$，明显与实际情况不同。</p>
<h3 id="Quaternion-Dot-Product"><a href="#Quaternion-Dot-Product" class="headerlink" title="Quaternion Dot Product"></a>Quaternion Dot Product</h3><p>四元数的点乘与矩阵的点乘类似，如下所示：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\mathbf{q}_{1} \cdot \mathbf{q}_{2} &=\left[\begin{array}{ll}
w_{1} & \mathbf{v}_{1}
\end{array}\right] \cdot\left[\begin{array}{ll}
w_{2} & \mathbf{v}_{2}
\end{array}\right] \\
&=w_{1} w_{2}+\mathbf{v}_{1} \cdot \mathbf{v}_{2} \\
&\left.=\left[w_{1} \quad\left(\begin{array}{lll}
x_{1} & y_{1} & z_{1}
\end{array}\right)\right] \cdot\left[\begin{array}{llll}
w_{2} & \left(x_{2}\right. & y_{2} & z_{2}
\end{array}\right)\right] \\
&=w_{1} w_{2}+x_{1} x_{2}+y_{1} y_{2}+z_{1} z_{2}
\end{aligned}</script><p>在上一节求四元数差值的部分中，如果设$\mathbf{a}=[\omega<em>{1} \quad \mathbf{v_1}]$和$\mathbf{b}=[\omega</em>{2} \quad \mathbf{v<em>2} ]$，那么$\mathbf{d}$中的$\omega$部分即为$w</em>{1} w<em>{2}+\mathbf{v}</em>{1} \cdot \mathbf{v}_{2}$，即和$\mathbf{a} \cdot \mathbf{b}$的结果相同。</p>
<p>而$\mathbf{d}$的形式上满足旋转四元数的定义（虽然$\theta$和$\hat{\mathbf{n}}$和真实的旋转四元数并不相等），所以其中的$\omega$也能反应差值的角度大小，因此可以通过点乘来求得差值的角度大小。</p>
<h3 id="Quaternion-log，exp-and-Multiplication-by-a-Scaler"><a href="#Quaternion-log，exp-and-Multiplication-by-a-Scaler" class="headerlink" title="Quaternion log，exp, and Multiplication by a Scaler"></a>Quaternion log，exp, and Multiplication by a Scaler</h3><p>为了书写方便，四元数可表示为，$\alpha=\theta / 2，\mathbf{q}=[\cos \alpha \quad \hat{\mathbf{n}} \sin \alpha]$</p>
<p>四元数的 log（logarithm）定义为：</p>
<script type="math/tex; mode=display">
\log \mathbf{q}=\log ([\cos \alpha \quad \hat{\mathbf{n}} \sin \alpha]) \equiv\left[\begin{array}{ll}
0 & \alpha \hat{\mathbf{n}}
\end{array}\right]</script><p>四元数的自然指数函数（Exponential function）定义为：</p>
<script type="math/tex; mode=display">
\exp \mathbf{p}=\exp \left(\left[\begin{array}{ll}
0 & \alpha \hat{\mathbf{n}}
\end{array}\right]\right) \equiv[\cos \alpha \quad \hat{\mathbf{n}} \sin \alpha]</script><p>可以得出：</p>
<script type="math/tex; mode=display">\exp (\log \mathbf{q})=\mathbf{q}</script><p>这与一般数学中的操作是对应的，即：</p>
<script type="math/tex; mode=display">e^{\ln a}=a</script><p>四元数与标量相乘的定义如下：</p>
<script type="math/tex; mode=display">
k \mathbf{q}=k[w \quad \mathbf{v}]=\left[\begin{array}{ll}
k w & k \mathbf{v}
\end{array}\right]</script><h3 id="Quaternion-Exponentiation"><a href="#Quaternion-Exponentiation" class="headerlink" title="Quaternion Exponentiation"></a>Quaternion Exponentiation</h3><p>四元数的指数形式（Exponentiation），写为$\mathbf{q}^{t}$</p>
<p>在自然数中，$a^0=1,a^1=a$，即指数从$0\sim1$变化的过程中，结果从$1\sim a$逐渐变换。在四元数中类似，即指数从$0\sim 1$的过程中，结果从$[1 \quad \mathbf{0}]$逐渐变换为$\mathbf{q}$</p>
<p>四元数指数操作的几何意义在于，它可以截取或倍化差值，因为：</p>
<script type="math/tex; mode=display">\mathbf{q}^{t}=\exp (t \log \mathbf{q})</script><p>上式中，先进行了 log 操作，由上节可知，log 操作的结果是将角度抽离出来（从$\sin \alpha \hat{\mathbf{n}}$变为了$\alpha \hat{\mathbf{n}}$）。这时候乘以$t$就是直接对角度进行截取或倍化。然后进行的 exp 操作，则又是将角度变化回了四元数。</p>
<p>所以如果$\mathbf{q}$表示绕着 x 轴旋转 30°，那么$\mathbf{q}^2$表示绕着 x 轴旋转 60°，$\mathbf{q}^{-1/3}$表示绕着反方向旋转了 10°。</p>
<p>但是指数操作的旋转的结果是最短路径，即$\mathbf{q}^8$的结果并不是旋转 240°，而是 120°。</p>
<p>另外四元数的几何操作不满足实数的指数操作的一些性质，如$\left(a^{s}\right)^{t}=a^{s t}$无法在四元数中实现。</p>
<p>//TODO:</p>
<p>书中给出了实现四元数指数操作的代码</p>
<h3 id="Quaternion-Interpolation-a-k-a-Slerp"><a href="#Quaternion-Interpolation-a-k-a-Slerp" class="headerlink" title="Quaternion Interpolation, a.k.a Slerp"></a>Quaternion Interpolation, a.k.a Slerp</h3><p>球面线性插值（Slerp，Spherical Linera interpolation，下简称插值）是用来在两个角度间逐渐变换的方法。Slerp 方法需要三个参数，$\mathbf{q}_0,\mathbf{q}_1和t$，分别表示插值的起始点，终点和目前的进度。</p>
<p>插值的基本步骤为：</p>
<ol>
<li>算出起始点和重点之间的差距</li>
<li>使用 t 得出一部分差距</li>
<li>将这一部分差距加到起始点上</li>
</ol>
<p>这三个步骤可表示为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\Delta a &=a_{1}-a_{0} \\
\operatorname{lerp}\left(a_{0}, a_{1}, t\right) &=a_{0}+t \Delta a
\end{aligned}</script><p>而对于四元数的插值来说，步骤基本类似，具体为：</p>
<ol>
<li>算出两个朝向的差值<script type="math/tex; mode=display">\Delta \mathbf{q}=\mathbf{q}_{1} \mathbf{q}_{0}^{-1}</script></li>
<li>使用指数操作，求出一部分差值<script type="math/tex; mode=display">(\Delta \mathbf{q})^{t}</script></li>
<li>通过乘法，对起始位置加上差值<script type="math/tex; mode=display">(\Delta \mathbf{q})^{t} \mathbf{q}_{0}</script></li>
</ol>
<p>结合起来，四元数的插值运算为：</p>
<script type="math/tex; mode=display">\text { slerp }\left(\mathbf{q}_{0}, \mathbf{q}_{1}, t\right)=\left(\mathbf{q}_{1} \mathbf{q}_{0}^{-1}\right)^{t} \mathbf{q}_{0}</script><p>但在实际运用中，通常使用另一个方法进行四元数的插值运算。</p>
<p>因为所有形式为旋转四元数的四元数，其模都为 1，所以可以看作是在长度为 1 的四维球体表面。那么插值运算可以看作是在这个四维的球体表面的弧线上运动（所以插值运算全程是球面线性插值）。</p>
<p>如下图所示：</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter8-Notes/2020-04-03-12-08-20.png" alt="球体表面插值"></p>
<p>而可以进一步，将$v_t$看作是$v_0$和$v_1$的线性组合。</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter8-Notes/2020-04-03-12-16-01.png" alt="线性组合求插值"></p>
<p>根据下图，可以求得$k_1$</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sin \omega &=\frac{\sin t \omega}{k_{1}} \\
k_{1} &=\frac{\sin t \omega}{\sin \omega}
\end{aligned}</script><p>注意因为$v_1$的模为 1，所以在分母中省略了。</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter8-Notes/2020-04-03-12-32-58.png" alt="求k1"></p>
<p>同理，根据下图，可以求出$k_0$</p>
<p><img src="3DMathPrimerForGraphicsAGameDevelopment-Chapter8-Notes/2020-04-03-12-32-37.png" alt="求k0"></p>
<p>因此可得：</p>
<script type="math/tex; mode=display">\mathbf{v}_{t}=k_{0} \mathbf{v}_{0}+k_{1} \mathbf{v}_{1}=\frac{\sin (1-t) \omega}{\sin \omega} \mathbf{v}_{0}+\frac{\sin t \omega}{\sin \omega} \mathbf{v}_{1}</script><p>即</p>
<script type="math/tex; mode=display">\operatorname{slerp}\left(\mathbf{q}_{0}, \mathbf{q}_{1}, t\right)=\frac{\sin (1-t) \omega}{\sin \omega} \mathbf{q}_{0}+\frac{\sin t \omega}{\sin \omega} \mathbf{q}_{1}</script><p>现在还遗留的问题是如何求出插值的角度$\omega$。根据之前对于四元数点乘的定义，可以使用点积求得四元数中得标量部分$\omega$(这里的$\omega$不是指角度)，即可通过$\mathbf{q}_0 \cdot \mathbf{q}_1$得到$\cos\omega$ （这里的$\omega$是指要求得角度差值，不是标量）。</p>
<p>//TODO</p>
<p>书中有给出关于差值的算法</p>
<h3 id="Advantages-and-Disadvantage-of-Quaternions"><a href="#Advantages-and-Disadvantage-of-Quaternions" class="headerlink" title="Advantages and Disadvantage of Quaternions"></a>Advantages and Disadvantage of Quaternions</h3><p>优点：</p>
<ol>
<li>可以实现平滑的插值运算</li>
<li>可以级联和使用四元数的逆进行逆转换</li>
<li>可以快速的转换至矩阵形式，和从矩阵形式转换回来</li>
<li>只需要四个数字</li>
</ol>
<p>缺点：</p>
<ol>
<li>需要的数字仍然比欧拉角多（欧拉角只需要 3 个数字）</li>
<li>并不是所有的四元数都能表示旋转<br>旋转四元数的模是 1</li>
<li>人无法直观理解</li>
</ol>
<h3 id="Quaternions-as-Complex-Number"><a href="#Quaternions-as-Complex-Number" class="headerlink" title="Quaternions as Complex Number"></a>Quaternions as Complex Number</h3><p>这一节是用从复数的角度来描述四元数，从这个角度可以解释两个问题，一是为什么从旋转角度来看，四元数代表的是$\theta/2$而不是$\theta$，二是为什么用于旋转的表达式是$\mathbf{qvq_{-1}}$</p>
<p>首先实数可以通过矩阵形式进行表达，如实数$a$，可按如下方式表示：</p>
<script type="math/tex; mode=display">
a \equiv\left[\begin{array}{ll}
a & 0 \\
0 & a
\end{array}\right]</script><p>复数同样可以通过矩阵形式表达，如复数$a+bi$，可以表达为：</p>
<script type="math/tex; mode=display">
a+b i \equiv\left[\begin{array}{cc}
a & -b \\
b & a
\end{array}\right]</script><p>而且这样表达复数，仍然可以满足$i^2=-1$的性质，如下</p>
<script type="math/tex; mode=display">
i^{2} \equiv\left[\begin{array}{cc}
0 & -1 \\
1 & 0
\end{array}\right]^{2}=\left[\begin{array}{cc}
0 & -1 \\
1 & 0
\end{array}\right]\left[\begin{array}{cc}
0 & -1 \\
1 & 0
\end{array}\right]=\left[\begin{array}{cc}
-1 & 0 \\
0 & -1
\end{array}\right] \equiv-1</script><p>因为四元数的乘法是从右向左的，相当于是矩阵中的右手坐标系，所以矩阵中的每一列代表坐标轴，从上式可以看到，在$i$乘以$i$后，列从$[0,1]$变为了$[-1,0]$，从$[-1,0]$变为了$[0,-1]$，即旋转了 90°。</p>
<p>即可以将复数看作是一种旋转的表达，如果旋转$\theta^{\circ}$，即表达为：</p>
<script type="math/tex; mode=display">
\cos \theta+i \sin \theta \equiv\left[\begin{array}{cc}
\cos \theta & -\sin \theta \\
\sin \theta & \cos \theta
\end{array}\right]</script><p>这个矩阵即为之前在二维旋转中推导出的，旋转$\theta^{\delta}$的矩阵，只不过之前推导的是左手坐标系中的，这里是右手坐标系中的（两个坐标系的结果互为转置）。</p>
<p>如果将复数$x+yi$用矩阵表示为矩阵$[x,y]$，可以看到实数的乘法与矩阵的乘法同样可以对应起来。进一步证明可以通过实数来进行旋转操作。</p>
<p>同时复数的共轭，也可以与矩阵的求逆对应起来，两者都是进行逆变换。</p>
<script type="math/tex; mode=display">
\begin{aligned}
(\cos \theta+i \sin \theta)(x+i y) &=x \cos \theta+i y \cos \theta+i x \sin \theta+i^{2} y \sin \theta \\
&=(x \cos \theta-y \sin \theta)+i(x \sin \theta+y \cos \theta)
\end{aligned}</script><script type="math/tex; mode=display">
\left[\begin{array}{cc}
\cos \theta & -\sin \theta \\
\sin \theta & \cos \theta
\end{array}\right]\left[\begin{array}{l}
x \\
y
\end{array}\right]=\left[\begin{array}{l}
x \cos \theta-y \sin \theta \\
x \sin \theta+y \cos \theta
\end{array}\right]</script><p>当这个结论无法推导至三维空间中。在二维空间中，用实数和虚数$i$对应两个维度，但是在三维空间中无法用实数和两个虚数$i,j$来对应三个维度（无法用$3\times3$的矩阵表示）。</p>
<p>如果可以对应，那么三维的单位矩阵$I_3$，应该对应数字 1，三维的负单位矩阵$I_3$，应该对应-1。因为$i^2=-1$，所以表示虚数$i$的矩阵的平方应该等于$-I_3$。</p>
<p>但是$-I_3$的行列式值为-1，根据行列式性质“乘积的行列式等于行列式的乘积”，那么表示虚数$i$的矩阵的行列式的平方，应该等于-1，即该矩阵的行列式值为 i，这显然无法满足。</p>
<p>因此无法通过$3\times 3$的矩阵来表示三维三维的虚数。</p>
<p>数学家$William Hamilton$提出，可以通过四维的虚数来表示四维空间，即通过实数，和三个虚数$i,j,k$来表示。其中三个虚数满足：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&i^{2}=j^{2}=k^{2}=-1\\
&i j=k, \quad j i=-k\\
&j k=i, \quad k j=-i\\
&k i=j, \quad i k=-j
\end{aligned}</script><p>而四元数就是一种形式的四维矩阵，即$[w,(x, y, z)]$可用来对应$w+x i+y j+z k$。</p>
<p>将四维的虚数用$4\times4$的矩阵表示有多个方法，以下为其中一种：</p>
<script type="math/tex; mode=display">
a \equiv\left[\begin{array}{llll}
a & 0 & 0 & 0 \\
0 & a & 0 & 0 \\
0 & 0 & a & 0 \\
0 & 0 & 0 & a
\end{array}\right]</script><script type="math/tex; mode=display">
i \equiv\left[\begin{array}{cccc}
0 & 0 & 0 & 1 \\
0 & 0 & -1 & 0 \\
0 & 1 & 0 & 0 \\
-1 & 0 & 0 & 0
\end{array}\right], \quad j \equiv\left[\begin{array}{cccc}
0 & 0 & 1 & 0 \\
0 & 0 & 0 & 1 \\
-1 & 0 & 0 & 0 \\
0 & -1 & 0 & 0
\end{array}\right], \quad k \equiv\left[\begin{array}{cccc}
0 & -1 & 0 & 0 \\
1 & 0 & 0 & 0 \\
0 & 0 & 0 & 1 \\
0 & 0 & -1 & 0
\end{array}\right]</script><p>结合可得：</p>
<script type="math/tex; mode=display">
w+x i+y j+z k \equiv\left[\begin{array}{cccc}
w & -z & y & x \\
z & w & -x & y \\
-y & x & w & z \\
-x & -y & -z & w
\end{array}\right]</script><p>可以发现，$k$矩阵的左上部分与二维空间中$i$的表达一模一样，于是猜测$k$矩阵也可以用来表达旋转，且是绕着$z$的旋转。使用三维向量$[1,0,1]$来测试。该向量如果用四元数表达，则为$[0 \quad (1,0,1)]$，即用实数表达为$i+k$。因为是绕着$z$轴旋转，所以$z$的变量不会变，$xy$变量的结果与二维空间旋转结果相同，即最后的正确结果应该是$(\cos \theta,\sin\theta,1)$，即$\cos\theta i +\sin\theta j+k$<br>那么相乘过程可以表示为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
(\cos \theta+k \sin \theta)(i+k) &=i \cos \theta+k \cos \theta+k i \sin \theta+k^{2} \sin \theta \\
&=i \cos \theta+j \sin \theta+k \cos \theta-\sin \theta
\end{aligned}</script><p>可以看到结果根本就不是一个三维空间中的向量，因为$w$参数并不为 0。这个结果中，$x,y$平面的答案是我们想要的，而$z,w$平面则不是。</p>
<p>如果对实数取共轭，即表达为$\cos\theta - k\sin \theta$，并且进行右乘，那么结果为：</p>
<script type="math/tex; mode=display">(i+k)(\cos \theta-k \sin \theta)=i \cos \theta+j \sin \theta-k \cos \theta+\sin \theta</script><p>结果仍然不是一个三维空间中你的向量，$x,y$平面的结果不变，$z,w$平面的结果虽然不同，但是与之前的结果正好相反，所以尝试将两个表达式结合在一起，即</p>
<script type="math/tex; mode=display">
\begin{aligned}
&(\cos \theta+k \sin \theta)(i+k)(\cos \theta-k \sin \theta) \\
=&(i \cos \theta+j \sin \theta+k \cos \theta-\sin \theta)(\cos \theta-k \sin \theta) \\
=& i \cos ^{2} \theta-i k \cos \theta \sin \theta+j \sin \theta \cos \theta-j k \sin ^{2} \theta+k \cos ^{2} \theta-k^{2} \cos \theta \sin \theta-\sin \theta \cos \theta+k \sin ^{2} \theta \\
=& i \cos ^{2} \theta+j \cos \theta \sin \theta+j \sin \theta \cos \theta-i \sin ^{2} \theta+k \cos ^{2} \theta+\cos \theta \sin \theta-\sin \theta \cos \theta+k \sin ^{2} \theta \\
=& i \cos ^{2} \theta-i \sin ^{2} \theta+2 j \sin \theta \cos \theta+k \\
=& i \cos 2 \theta+j \sin 2 \theta+k
\end{aligned}</script><p>与正确结果$\cos\theta i +\sin\theta j+k$相比，$\theta$变为了$2\theta$。因此如果要用复数来表达旋转的话，式子应该改为$(\cos \theta /2+k \sin \theta /2)(i+k)(\cos \theta /2-k \sin \theta /2)$，即四元数应该表达为$\mathbf{q}=[\cos \theta /2 \quad \mathbf{\sin \theta/2k}]$，且上述式子对应的乘法表达式为$\mathbf{qpq^-1}$。</p>
<p>而这就是前几节中定义的用四元数来表示乘法的方法。</p>
<h3 id="Summary-of-Quaternions"><a href="#Summary-of-Quaternions" class="headerlink" title="Summary of Quaternions"></a>Summary of Quaternions</h3><p>这一节是总结上述描述中比较重要的概念。</p>
<ol>
<li>概念上来说，四元数可以用来表达绕着一个轴的旋转一定角度。<br>其中四元数中的标量部分$w=\cos (\theta / 2)$，向量部分$\mathbf{v}=\hat{\mathbf{n}} \sin (\theta / 2)$。<br>这种四元数称为旋转四元数，其模为 1</li>
<li>从几何角度来说，每个三维点的旋转，都有两种表达方式，且这两个表达方式互为对方的相反（不是逆），即$\mathbf{q}=\mathbf{-q}$</li>
<li>单位四元数$[1 \quad \mathbf{0}]$和$[-1 \quad \mathbf{0}]$都表达没有旋转</li>
<li><p>旋转四元数可以级联表示多个旋转（从右向做级联），表达式为$\mathbf{qpq^-1}$且可以通过求旋转四元数的逆来表示逆变换，且因为旋转四元数的模为 1，所以旋转四元数的逆等于旋转四元数的共轭。</p>
<p> 但实际运用中，很少通过$\mathbf{qpq^-1}$计算旋转，更多的是使用矩阵。</p>
</li>
<li><p>四元数的指数运算可以用来截取或者倍化四元数表示的旋转，但只能表示最短路径。<br>旋转四元数常用来计算插值。</p>
</li>
</ol>
<h2 id="Comparision-of-Methods"><a href="#Comparision-of-Methods" class="headerlink" title="Comparision of Methods"></a>Comparision of Methods</h2><ol>
<li>欧拉角是最适合人直接理解的方法</li>
<li>当需要进行空间转换时，必须是使用矩阵</li>
<li>如果要大量的存储旋转信息，欧拉角，指数映射和四元数是比较理想的存储方式</li>
<li>要实现可靠的插值运算，只能通过四元数</li>
<li>只有四元数和矩阵运算可以实现旋转级联</li>
<li>矩阵，指数映射，四元数都可以快速的求出逆运算</li>
<li>如果要求角速度，或者其他要保留额外的旋转（有几次 360° 的旋转），只有轴角法或者指数映射表达可以实现。</li>
</ol>
<h2 id="Converting-between-Representations"><a href="#Converting-between-Representations" class="headerlink" title="Converting between Representations"></a>Converting between Representations</h2><h3 id="Converting-Euler-Angles-to-Matrix"><a href="#Converting-Euler-Angles-to-Matrix" class="headerlink" title="Converting Euler Angles to Matrix"></a>Converting Euler Angles to Matrix</h3><p>从欧拉角表达转到矩阵表达，存在不同情况下的不同矩阵。如一个场景中有普通物体和摄像机，用于表达普通物体旋转的矩阵与摄像机是不同的，普通物体是用<code>物体-直立坐标系的</code>矩阵表达，而摄像机为<code>直立到物体坐标系</code>的矩阵。</p>
<p>两个矩阵互为逆矩阵，所以在这里重点说明物体-直立坐标系的矩阵表达，直立到物体坐标系的矩阵可以通过取反快速得到。</p>
<p>欧拉角转换成矩阵表达的基本思想就是，将绕着三个轴的旋转拆分，各自表达为一个旋转矩阵，然后再级联，即得到了结果。</p>
<p>这里还存在的问题是，级联的顺序该如何定。如之前所述，关于欧拉角的表达分为传统欧拉旋转顺序（heading-pitch-row）和固定轴旋转顺序（row-pitch-heading）。这里用固定轴的旋转顺序进行旋转，否则的话在之前的轴旋转后，后续的轴就发生了变换。</p>
<p>又因为在左手坐标系下，乘法顺序是从左至右的，所以欧拉角在物体-直立坐标系矩阵中的表达式为：</p>
<script type="math/tex; mode=display">\mathbf{M}_{\text {object} \rightarrow \text {upright}}=\mathbf{B P H}</script><p>根据第五章中的内容，可以很容易的得到绕着每个轴旋转的矩阵</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\mathbf{B}=\mathbf{R}_{z}(b)=\left[\begin{array}{ccc}
\cos b & \sin b & 0 \\
-\sin b & \cos b & 0 \\
0 & 0 & 1
\end{array}\right]\\
&\begin{array}{l}
\mathbf{P}=\mathbf{R}_{x}(p)=\left[\begin{array}{ccc}
1 & 0 & 0 \\
0 & \cos p & \sin p \\
0 & -\sin p & \cos p
\end{array}\right] \\
\mathbf{H}=\mathbf{R}_{y}(h)=\left[\begin{array}{ccc}
\cos h & 0 & -\sin h \\
0 & 1 & 0 \\
\sin h & 0 & \cos h
\end{array}\right]
\end{array}
\end{aligned}</script><p>结合得：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\mathbf{M}_{o b j e c t \rightarrow u p r i g h t} &=\mathbf{B P H} \\
&=\left[\begin{array}{ccc}
\cos h \cos b+\sin h \sin p \sin b & \sin b \cos p & -\sin h \cos b+\cos h \sin p \sin b \\
-\cos h \sin b+\sin h \sin p \cos b & \cos b \cos p & \sin b \sin h+\cos h \sin p \cos b \\
\sin h \cos p & -\sin p & \cos h \cos p
\end{array}\right]
\end{aligned}</script><p>直立-物体坐标系的表达取逆即可：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\mathbf{M}_{u p r i g h t \rightarrow o b j e c t} &=\mathbf{H}^{-1} \mathbf{P}^{-1} \mathbf{B}^{-1}=\mathbf{R}_{y}(-h) \mathbf{R}_{x}(-p) \mathbf{R}_{z}(-b) \\
&=\left[\begin{array}{ccc}
\cos h \cos b+\sin h \sin p \sin b & -\cos h \sin b+\sin h \sin p \cos b &\sin h \cos p \\
\sin b \cos p & \cos b \cos p &-\sin p\\
 -\sin h \cos b+\cos h \sin p \sin b &  \sin b \sin h+\cos h \sin p \cos b  &\cos h \cos p
\end{array}\right]
\end{aligned}</script><h3 id="Converting-a-Matrix-to-Euler-angles"><a href="#Converting-a-Matrix-to-Euler-angles" class="headerlink" title="Converting a Matrix to Euler angles"></a>Converting a Matrix to Euler angles</h3><ol>
<li>从矩阵转换到欧拉角，首先要确认矩阵表达的是什么形式的旋转，物体-直立坐标系，还是直立-物体坐标系。</li>
<li>矩阵转换到到欧拉角后返回的结果是标准坐标，即 heading 和 bank 的范围为$\left(-180^{\circ},+180^{\circ}\right]$，pitch 的范围是$\left[-90^{\circ},+90^{\circ}\right]$</li>
<li>这节中方法默认给的矩阵是合法的旋转矩阵。</li>
</ol>
<p>首先是将物体-直立坐标系的矩阵转换为欧拉角，矩阵如下所示：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{ccc}
\cos h \cos b+\sin h \sin p \sin b & \sin b \cos p & -\sin h \cos b+\cos h \sin p \sin b \\
-\cos h \sin b+\sin h \sin p \cos b & \cos b \cos p & \sin b \sin h+\cos h \sin p \cos b \\
\sin h \cos p & -\sin p & \cos h \cos p
\end{array}\right]</script><p>从元素$m<em>{32}=-\sin p$中可以直接求出 pitch 角度,$\arcsin \left(-m</em>{32}\right)=p$。<br>C 标准库中的$asin()$函数返回的数值范围为$[-\pi / 2,+\pi / 2]$，正好符合标准坐标对于 pitch 角度的范围要求。所以为：</p>
<script type="math/tex; mode=display">
p=\operatorname{asin}(-m_{32})</script><p>求 heading 和 roll 角度时，要考虑万向锁的问题，即当 pitch 角度为正负 90° 的情况。</p>
<p>首先如果不是万向锁的情况，那么可以根据元素$m<em>{31}=\sin h \cos p$和元素$m</em>{33}=\cos h \cos p$求出，</p>
<p>即</p>
<script type="math/tex; mode=display">h=\operatorname{atan2} (\sin h, \cos h)=\operatorname{atan2} \left(m_{31} / \cos p, m_{33} / \cos p\right)</script><p>因为 pitch 角度不为$\pm 90 ^{\circ}$，所以$\cos p$不为 0，且可以约分，即</p>
<script type="math/tex; mode=display">h=\operatorname{atan2} \left(m_{31}, m_{33}\right)</script><p>C 标准库中的$atan2()$函数表示进行$\arctan$c 操作（2 为函数名的一部分，并不是乘 2），范围是<script type="math/tex">[-\pi,+\pi]</script>，同样符合标准坐标的范围。</p>
<p>类似的在非万向锁情况下，可以通过元素$m<em>{12}=\sin b \cos p$和元素$m</em>{22}=\cos b \cos p$求出 roll 角度，即</p>
<script type="math/tex; mode=display">
\begin{aligned}
b &=\operatorname{atan2} (\sin b, \cos b)=\operatorname{atan2} \left(m_{12} / \cos p, m_{22} / \cos p\right) \\
&=\operatorname{atan2} \left(m_{12}, m_{22}\right)
\end{aligned}</script><p>而在万向锁的情况下，因为$p=\pm 90^{\circ}，即$$\cos p=0$，所以无法将$\cos p$作为分母。而且此时，heading 角度和 roll 角度的旋转是相同效果的。</p>
<p>在万向锁情况下，限定 roll 角度为 0，即$b=0, \sin b =0 \cos b=1$，此时通过元素$m<em>{11}=\cos h \cos b+\sin h \sin p \sin b$和元素$m</em>{13}=-\sin h \cos b+\cos h \sin p \sin b$来求得 heading 角度。</p>
<p>将$\cos b=1, \sin p=1, \sin b=0$，带入得</p>
<script type="math/tex; mode=display">
m_{11}=\cos h \quad m_{13}=-\sin h</script><p>即</p>
<script type="math/tex; mode=display">h=\operatorname{atan2} \left(-m_{13}, m_{11}\right)</script><p>直立-物体坐标系的矩阵到欧拉角的转换雷同，矩阵为：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{ccc}
\cos h \cos b+\sin h \sin p \sin b & -\cos h \sin b+\sin h \sin p \cos b &\sin h \cos p \\
\sin b \cos p & \cos b \cos p &-\sin p\\
 -\sin h \cos b+\cos h \sin p \sin b &  \sin b \sin h+\cos h \sin p \cos b  &\cos h \cos p
\end{array}\right]</script><p>欧拉角计算方法为</p>
<script type="math/tex; mode=display">
p=\operatorname{asin}(-m_{23})</script><p>当非万向锁时，即$p\neq \pm 90^{\circ}$时，有：</p>
<script type="math/tex; mode=display">
h=\operatorname{atan2} \left(m_{13}, m_{33}\right) \\
b=\operatorname{atan2} \left(m_{21}, m_{22}\right)</script><p>当万向锁时，即$p= \pm 90^{\circ}$时，有：</p>
<script type="math/tex; mode=display">
b=0 \\
h=\operatorname{atan2} \left(m_{31}, m_{11}\right)</script><p>//TODO</p>
<p>书中给出从欧拉角转换为物体-直立坐标系矩阵的代码</p>
<h3 id="Converting-a-Quaternion-to-a-Matrix"><a href="#Converting-a-Quaternion-to-a-Matrix" class="headerlink" title="Converting a Quaternion to a Matrix"></a>Converting a Quaternion to a Matrix</h3><p>因为旋转四元数表达的是绕着任意轴$\hat{n}$旋转$\theta$，而这个同样可以通过矩阵表达，即第五章中得出的：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{ccc}
n_{x}^{2}(1-\cos \theta)+\cos \theta & n_{x} n_{y}(1-\cos \theta)+n_{z} \sin \theta & n_{x} n_{z}(1-\cos \theta)-n_{y} \sin \theta \\
n_{x} n_{y}(1-\cos \theta)-n_{z} \sin \theta & n_{y}^{2}(1-\cos \theta)+\cos \theta & n_{y} n_{z}(1-\cos \theta)+n_{x} \sin \theta \\
n_{x} n_{z}(1-\cos \theta)+n_{y} \sin \theta & n_{y} n_{z}(1-\cos \theta)-n_{x} \sin \theta & n_{z}^{2}(1-\cos \theta)+\cos \theta
\end{array}\right]</script><p>而转换四元数到矩阵的思路，就是用四元数的四个元素来取代上面矩阵中的元素，四元数的四个元素分别表示为：</p>
<script type="math/tex; mode=display">
\begin{array}{l}
w=\cos (\theta / 2) \\
x=n_{x} \sin (\theta / 2) \\
y=n_{y} \sin (\theta / 2) \\
z=n_{z} \sin (\theta / 2)
\end{array}</script><p>通过观察绕任意轴旋转的矩阵可以发现，对角线元素的表达方式是一种类型，非对角线元素的表达方式是另一种类型。因此，只要分别求出一个对角线元素的转换和一个非对角线元素的转换，其他的元素都可以类比得到。</p>
<p>首先求对角线元素$m_{11}$，通过等式代换可以转换为四元数中的元素，如下：</p>
<script type="math/tex; mode=display">
\begin{aligned}
m_{11} &=n_{x}^{2}(1-\cos \theta)+\cos \theta \\
&=n_{x}^{2}-n_{x}^{2} \cos \theta+\cos \theta \\
&=1-1+n_{x}^{2}-n_{x}^{2} \cos \theta+\cos \theta \\
&=1-\left(1-n_{x}^{2}+n_{x}^{2} \cos \theta-\cos \theta\right) \\
&=1-\left(1-\cos \theta-n_{x}^{2}+n_{x}^{2} \cos \theta\right) \\
&=1-\left(1-n_{x}^{2}\right)(1-\cos \theta)
\end{aligned}</script><p>根据倍角公式，可以进一步拆分$\cos \theta$：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\cos 2 \alpha &=1-2 \sin ^{2} \alpha \\
\cos \theta &=1-2 \sin ^{2}(\theta / 2)
\end{aligned}</script><p>带入上述得：</p>
<script type="math/tex; mode=display">
\begin{aligned}
m_{11} &=1-\left(1-n_{x}^{2}\right)(1-\cos \theta) \\
&=1-\left(1-n_{x}^{2}\right)\left(1-\left(1-2 \sin ^{2}(\theta / 2)\right)\right) \\
&=1-\left(1-n_{x}^{2}\right)\left(2 \sin ^{2}(\theta / 2)\right)
\end{aligned}</script><p>因为$\hat{\mathbf{n}}$是一个单位向量，所以有$n<em>{x}^{2}+n</em>{y}^{2}+n_{z}^{2}=1$，带入上式可继续代换得：</p>
<script type="math/tex; mode=display">
\begin{aligned}
m_{11} &=1-\left(1-n_{x}^{2}\right)\left(2 \sin ^{2}(\theta / 2)\right) \\
&=1-\left(n_{y}^{2}+n_{z}^{2}\right)\left(2 \sin ^{2}(\theta / 2)\right) \\
&=1-2 n_{y}^{2} \sin ^{2}(\theta / 2)-2 n_{z}^{2} \sin ^{2}(\theta / 2) \\
&=1-2 y^{2}-2 z^{2}
\end{aligned}</script><p>可类比得到其他得对角线元素</p>
<script type="math/tex; mode=display">
m_{22}=1-2x^2-2z^2 \\
m_{33}=1-2x^2-2y^2</script><p>在求非对角线元素$m_{12}$，同样是通过等式代换，首先根据倍角公式可得：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\sin 2 \alpha=2 \sin \alpha \cos \alpha\\
&\sin \theta=2 \sin (\theta / 2) \cos (\theta / 2)
\end{aligned}</script><p>与之前的$\cos$的倍角公式结果一起带入$m_{12}$，得</p>
<script type="math/tex; mode=display">
\begin{aligned}
m_{12} &=n_{x} n_{y}(1-\cos \theta)+n_{z} \sin \theta \\
&=n_{x} n_{y}\left(1-\left(1-2 \sin ^{2}(\theta / 2)\right)\right)+n_{z}(2 \sin (\theta / 2) \cos (\theta / 2)) \\
&=n_{x} n_{y}\left(2 \sin ^{2}(\theta / 2)\right)+2 n_{z} \sin (\theta / 2) \cos (\theta / 2) \\
&=2\left(n_{x} \sin (\theta / 2)\right)\left(n_{y} \sin (\theta / 2)\right)+2 \cos (\theta / 2)\left(n_{z} \sin (\theta / 2)\right) \\
&=2 x y+2 w z
\end{aligned}</script><p>类比可得其他的非对角元素，如：</p>
<p>$m_{13}=2xz-2wy$</p>
<p>最终转换为的矩阵为:</p>
<script type="math/tex; mode=display">
\left[\begin{array}{ccc}
1-2 y^{2}-2 z^{2} & 2 x y+2 w z & 2 x z-2 w y \\
2 x y-2 w z & 1-2 x^{2}-2 z^{2} & 2 y z+2 w x \\
2 x z+2 w y & 2 y z-2 w x & 1-2 x^{2}-2 y^{2}
\end{array}\right]</script><h3 id="Converting-a-Matrix-to-a-Quaternion"><a href="#Converting-a-Matrix-to-a-Quaternion" class="headerlink" title="Converting a Matrix to a Quaternion"></a>Converting a Matrix to a Quaternion</h3><p>矩阵转换为四元数的主要思路是通过组合矩阵中的元素来获得四元数四个元素的表达。而矩阵中的对角线元素，不包含两个不同四元数元素的乘积，所以通过矩阵的对角线元素来计算：</p>
<p>如累加三个对角元素，得：</p>
<script type="math/tex; mode=display">
\begin{aligned}
m_{11}+m_{22}+m_{33}
&=\left(1-2 y^{2}-2 z^{2}\right)+\left(1-2 x^{2}-2 z^{2}\right)+\left(1-2 x^{2}-2 y^{2}\right) \\
&=3-4\left(x^{2}+y^{2}+z^{2}\right) \\
&=3-4\left(1-w^{2}\right) \\
&=4 w^{2}-1
\end{aligned}</script><p>同样可得：</p>
<script type="math/tex; mode=display">
\begin{aligned}
m_{11}-m_{22}-m_{33} &=\left(1-2 y^{2}-2 z^{2}\right)-\left(1-2 x^{2}-2 z^{2}\right)-\left(1-2 x^{2}-2 y^{2}\right) \\
&=4 x^{2}-1 \\
-m_{11}+m_{22}-m_{33} &=-\left(1-2 y^{2}-2 z^{2}\right)+\left(1-2 x^{2}-2 z^{2}\right)-\left(1-2 x^{2}-2 y^{2}\right) \\
&=4 y^{2}-1 \\
-m_{11}-m_{22}+m_{33} &=-\left(1-2 y^{2}-2 z^{2}\right)-\left(1-2 x^{2}-2 z^{2}\right)+\left(1-2 x^{2}-2 y^{2}\right) \\
&=4 z^{2}-1
\end{aligned}</script><p>因此：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&w=\frac{\sqrt{m_{11}+m_{22}+m_{33}+1}}{2}\\
&x=\frac{\sqrt{m_{11}-m_{22}-m_{33}+1}}{2}\\
&y=\frac{\sqrt{-m_{11}+m_{22}-m_{33}+1}}{2}\\
&z=\frac{\sqrt{-m_{11}-m_{22}+m_{33}+1}}{2}
\end{aligned}</script><p>但这个计算方式的问题在于，因为是通过根号求得结果，所以四个元素的结果都是正数。在四元数中，$\mathbf{q}$和$\mathbf{-q}$表达的是相同的元素，所以单一的元素到底是正数还是负数没有关系，只要其他的元素相应变化就可以，但是所有的元素都一定是正数会造成问题。</p>
<p>根据非对角元素的组合可得：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&m_{12}+m_{21}=(2 x y+2 w z)+(2 x y-2 w z)=4 x y\\
&\begin{array}{l}
m_{12}-m_{21}=(2 x y+2 w z)-(2 x y-2 w z)=4 w z \\
m_{31}+m_{13}=(2 x z+2 w y)+(2 x z-2 w y)=4 x z \\
m_{31}-m_{13}=(2 x z+2 w y)-(2 x z-2 w y)=4 w y \\
m_{23}+m_{32}=(2 y z+2 w x)+(2 y z-2 w x)=4 y z \\
m_{23}-m_{32}=(2 y z+2 w x)-(2 y z-2 w x)=4 w x
\end{array}
\end{aligned}</script><p>用之前的根号求解出一个元素数值，然后通过这些表达式，就可以求出正确的答案，即如下表达式的四选一：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&w=\frac{\sqrt{m_{11}+m_{22}+m_{33}+1}}{2} \Longrightarrow x=\frac{m_{23}-m_{32}}{4 w} \quad y=\frac{m_{31}-m_{13}}{4 w} \quad z=\frac{m_{12}-m_{21}}{4 w}\\
&x=\frac{\sqrt{m_{11}-m_{22}-m_{33}+1}}{2} \Longrightarrow w=\frac{m_{23}-m_{32}}{4 x} \quad y=\frac{m_{12}+m_{21}}{4 x} \quad z=\frac{m_{31}+m_{13}}{4 x}\\
&y=\frac{\sqrt{-m_{11}+m_{22}-m_{33}+1}}{2} \Longrightarrow w=\frac{m_{31}-m_{13}}{4 y} \quad x=\frac{m_{12}+m_{21}}{4 y} \quad z=\frac{m_{23}+m_{32}}{4 y}\\
&z=\frac{\sqrt{-m_{11}-m_{22}+m_{33}+1}}{2} \Longrightarrow w=\frac{m_{12}-m_{21}}{4 z} \quad x=\frac{m_{31}+m_{13}}{4 z} \quad y=\frac{m_{23}+m_{32}}{4 z}
\end{aligned}</script><p>新问题是，如何决定取哪一个元素用根号求解？</p>
<p>通常的做法是先计算出每个元素的平方值，然后用平方值最大的元素开根，再通过结果求解其他值。</p>
<p>//TODO</p>
<p>书中给出从矩阵转换到欧拉角的代码</p>
<h3 id="Converting-Euler-Angles-to-a-Quaternion"><a href="#Converting-Euler-Angles-to-a-Quaternion" class="headerlink" title="Converting Euler Angles to a Quaternion"></a>Converting Euler Angles to a Quaternion</h3><p>如同欧拉角转换为矩阵一样，欧拉角转换到四元数也一样要考虑两种情况，<code>物体-直立四元数</code>和<code>直立-物体四元数</code>。因为两者相互取共轭就能转换，所以这里主要讨论<code>物体-直立四元数</code>。</p>
<p>四元数的转换，如矩阵的转换类似，同样是通过求每个轴的四元数表达，然后级联得到。其中每个每个轴的旋转四元数为：</p>
<script type="math/tex; mode=display">
\mathbf{h}=\left[\begin{array}{c}\cos (h / 2) \\
\left(\begin{array}{c}
0 \\
\sin (h / 2) \\
0 \end{array}\right) \end{array}\right],  \quad \mathbf{p}= \left[\begin{array}{c} \cos (p / 2) \\
\left(\begin{array}{c} \sin (p / 2) \\
0 \\ 0 \end{array}\right) \end{array}\right],
\quad \mathbf{b}= \left[\begin{array}{c} \cos (b / 2) \\
\left(\begin{array}{c} 0 \\
0 \\ \sin (p / 2)  \end{array}\right) \end{array}\right]</script><p>而且同样是通过固定轴，即计算顺序为$roll-pitch-heading$。但不同的是四元数的乘法结合顺序是从右到左的。因此结合的结果如下：</p>
<script type="math/tex; mode=display">
\begin{array}{l} \mathbf{q}_{object \rightarrow upright}(h, p, b)=\mathbf{hpb} \\
=\left[\begin{array}{c} \cos (h / 2) \\
\left(\begin{array}{c}0 \\ \sin (h / 2) \\
0 \end{array}\right) \end{array}\right]
\left[\begin{array}{c} \cos (p / 2) \\
\left(\begin{array}{c}\sin (p / 2) \\0 \\ 0
\end{array}\right) \end{array}\right]
\left[\begin{array}{c} \cos (b / 2) \\
\left(\begin{array}{c}0 \\0 \\ \sin (b / 2)
\end{array}\right) \end{array}\right] \\
=\left[\begin{array}{c} \cos (h / 2) \cos (p / 2) \\
\left(\begin{array}{c} \cos (h / 2) \sin (p / 2) \\
\sin (h / 2) \cos (p / 2) \\
-\sin (h / 2) \sin (p / 2) \end{array}\right) \end{array}\right]
\left[\begin{array}{c} \cos (b / 2) \\
\left(\begin{array}{c} 0 \\
0 \\
\sin (b / 2) \end{array}\right) \end{array}\right] \\
=\left[\begin{array}{c} \cos (h / 2) \cos (p / 2) \cos (b / 2)+\sin (h / 2) \sin (p / 2) \sin (b / 2) \\
\left(\begin{array}{c} \cos (h / 2) \sin (p / 2) \cos (b / 2)+\sin (h / 2) \cos (p / 2) \sin (b / 2) \\
\sin (h / 2) \cos (p / 2) \cos (b / 2)-\cos (h / 2) \sin (p / 2) \sin (b / 2) \\
\cos (h / 2) \cos (p / 2) \sin (b / 2)-\sin (h / 2) \sin (p / 2) \cos (b / 2) \end{array}\right) \end{array}\right]
\end{array}</script><p>直立坐标系到空间坐标系的四元数为：</p>
<script type="math/tex; mode=display">
\begin{array}{l}
\mathbf{q}_{upright \rightarrow object}(h, p, b)
= \mathbf{q}_{object \rightarrow upright }(h, p, b)^{*} \\
=\left[\begin{array}{c}
\cos (h / 2) \cos (p / 2) \cos (b / 2)+\sin (h / 2) \sin (p / 2) \sin (b / 2) \\
\left(\begin{array}{c} -\cos (h / 2) \sin (p / 2) \cos (b / 2)-\sin (h / 2) \cos (p / 2) \sin (b / 2) \\
\cos (h / 2) \sin (p / 2) \sin (b / 2)-\sin (h / 2) \cos (p / 2) \cos (b / 2) \\
\sin (h / 2) \sin (p / 2) \cos (b / 2)-\cos (h / 2) \cos (p / 2) \sin (b / 2)
\end{array}\right)
\end{array}\right]
\end{array}</script><h3 id="Converting-a-Quaternion-to-Euler-Angles"><a href="#Converting-a-Quaternion-to-Euler-Angles" class="headerlink" title="Converting a Quaternion to Euler Angles"></a>Converting a Quaternion to Euler Angles</h3><p>首先讨论从物体-直立四元数转换为欧拉角的方法。</p>
<p>之前已经求出了如何从矩阵转换为欧拉角，如下所示：</p>
<script type="math/tex; mode=display">
\begin{array}{lll}
p & =\arcsin \left(-m_{32}\right) \\
h & =\left\{\begin{array}{ll}
\operatorname{atan2}\left(m_{31}, m_{33}\right) & \text { if } \cos p \neq 0 \\
\operatorname{atan2}\left(-m_{13}, m_{11}\right) & \text { otherwise }
\end{array}\right. \\
b & =\left\{\begin{array}{ll}
\operatorname{atan2}\left(m_{12}, m_{22}\right) & \text { if } \cos p \neq 0 \\
0 & \text { otherwise }
\end{array}\right.
\end{array}</script><p>同样求出了矩阵中的元素，如何用四元数中的元素表达，如下：</p>
<script type="math/tex; mode=display">
\begin{aligned}
m_{11}=1-2 y^{2}-2 z^{2}, \quad & m_{12}=2 x y+2 w z, \quad m_{13}=2 x z-2 w y, \\
& m_{22}=1-2 x^{2}-2 z^{2} \\
m_{31}=2 x z+2 w y, \quad & m_{32}=2 y z-2 w x, \quad m_{33}=1-2 x^{2}-2 y^{2}
\end{aligned}</script><p>将两者结合就能得到四元数转换为欧拉角的方法：</p>
<script type="math/tex; mode=display">
\begin{aligned}
p &=\arcsin \left(-m_{32}\right) \\
&=\arcsin (-2(y z-w x))
\end{aligned}</script><script type="math/tex; mode=display">
h=\left\{\begin{array}{ll}
\operatorname{atan2} \left(m_{31}, m_{33}\right) \\
=\operatorname{atan2} \left(2 x z+2 w y, 1-2 x^{2}-2 y^{2}\right) & \text { if } \cos p \neq 0 \\
=\operatorname{atan2} \left(x z+w y, 1 / 2-x^{2}-y^{2}\right) \\
\operatorname{atan2}\left(-m_{13}, m_{11}\right) \\
=\operatorname{atan2}\left(-2 x z+2 w y, 1-2 y^{2}-2 z^{2}\right) & \text { otherwise } \\
=\operatorname{atan2}\left(-x z+w y, 1 / 2-y^{2}-z^{2}\right)
\end{array}\right.</script><script type="math/tex; mode=display">
b=\left\{\begin{array}{ll}
\operatorname{atan} 2\left(m_{12}, m_{22}\right) & \text { if } \cos p \neq 0 \\
=\operatorname{atan} 2\left(2 x y+2 w z, 1-2 x^{2}-2 z^{2}\right) & \\
=\operatorname{atan} 2\left(x y+w z, 1 / 2-x^{2}-z^{2}\right)
\\
0 & otherwise
\end{array}\right.</script><p>从直立-物体四元数转换为欧拉角，只需要将$x,y,z$三个元素取反即可，因为直立-物体四元数是物体-直立四元数的共轭，即</p>
<script type="math/tex; mode=display">
\begin{aligned}
p &=\arcsin \left(-m_{32}\right) \\
&=\arcsin (-2(y z+w x))
\end{aligned}</script><script type="math/tex; mode=display">
h=\left\{\begin{array}{ll}
\operatorname{atan2} \left(m_{31}, m_{33}\right) \\
=\operatorname{atan2} \left(2 x z-2 w y, 1-2 x^{2}-2 y^{2}\right) & \text { if } \cos p \neq 0 \\
=\operatorname{atan2} \left(x z-w y, 1 / 2-x^{2}-y^{2}\right) \\
\operatorname{atan2}\left(-m_{13}, m_{11}\right) \\
=\operatorname{atan2}\left(-2 x z-2 w y, 1-2 y^{2}-2 z^{2}\right) & \text { otherwise } \\
=\operatorname{atan2}\left(-x z-w y, 1 / 2-y^{2}-z^{2}\right)
\end{array}\right.</script><script type="math/tex; mode=display">
b=\left\{\begin{array}{ll}
\operatorname{atan} 2\left(m_{12}, m_{22}\right) & \text { if } \cos p \neq 0 \\
=\operatorname{atan} 2\left(2 x y-2 w z, 1-2 x^{2}-2 z^{2}\right) & \\
=\operatorname{atan} 2\left(x y-w z, 1 / 2-x^{2}-z^{2}\right)
\\
0 & otherwise
\end{array}\right.</script><p>//TODO</p>
<p>书中给出了四元数到欧拉角的转换的代码</p>
<div class="note info simple"><p>引用：</p>
<ol>
<li><em>3D Math Primer for Graphics and Game Development</em> 2nd 2011</li>
</ol>
</div>
<hr>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>3D数学</tag>
      </tags>
  </entry>
  <entry>
    <title>《计算机网络与因特网》 第十章笔记</title>
    <url>/CNI-Chapter10-Notes/</url>
    <content><![CDATA[<p>《计算机网络与因特网》 第十章笔记</p>
<p>调制与调制器相关内容。</p>
<span id="more"></span>
<h1 id="Chapter-10-Modulation-And-Modems"><a href="#Chapter-10-Modulation-And-Modems" class="headerlink" title="Chapter 10 Modulation And Modems"></a>Chapter 10 Modulation And Modems</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>这一章讨论数据通信中的调制与调制器相关的内容。</p>
<p>调制是利用高频的信息来携带原始数据，将分别讨论当原始数据是模拟信号和数字信号的情况。</p>
<h2 id="Carriers-Frequency-And-Propagation"><a href="#Carriers-Frequency-And-Propagation" class="headerlink" title="Carriers,Frequency,And Propagation"></a>Carriers,Frequency,And Propagation</h2><p>许多通信系统会利用一个持续震荡的电磁波来作为信息的载波（Carrier），通常这个信号都是一个高频信号。在第七章有提到，信号的频率会影响信号的传播特性，如穿透性，对噪声的敏感性等。</p>
<h2 id="Analog-Modulation-Schemes"><a href="#Analog-Modulation-Schemes" class="headerlink" title="Analog Modulation Schemes"></a>Analog Modulation Schemes</h2><p><code>调制（Modulation）</code>意为根据原始信号来改变载波的特性。调制有两个输入，一个是载波，一个是原信号，然后产生一个调制后的载波作为输出。调制的原理图如下：</p>
<p><img src="CNI-Chapter10-Notes/2019-12-07-23-21-31.png" alt="调制原理图"></p>
<p>输入的原信号必须改变载波的一个特性，根据特性的不同可以分为<code>振幅调制（Amplitude modulation）</code>，<code>频移调制（Frequency modulation）</code>，<code>移相调制（Phase shift modulation）</code>。其中前两种最为普遍。</p>
<h2 id="Amplitude-Modulation"><a href="#Amplitude-Modulation" class="headerlink" title="Amplitude Modulation"></a>Amplitude Modulation</h2><p><code>振幅调制（Amplitude modulation）</code>是根据原信号改变载波的振幅。从时域图上看，调制后的波形的轮廓与原信号基本相同，如下图所示，（a）是高频载波，（b）是原信号，（c）是调制后的信号。</p>
<p><img src="CNI-Chapter10-Notes/2019-12-07-23-28-45.png" alt="振幅调制"></p>
<h2 id="Frequency-Modulation"><a href="#Frequency-Modulation" class="headerlink" title="Frequency Modulation"></a>Frequency Modulation</h2><p><code>频移调制（Frequency modulation）</code>是根据原信号改变载波的频率，当信号强是，载波的频率增加，反之减少。如下图即为频移调制后的样子：</p>
<p><img src="CNI-Chapter10-Notes/2019-12-07-23-36-37.png" alt="频移调制"></p>
<h2 id="Phase-Shift-Modulation"><a href="#Phase-Shift-Modulation" class="headerlink" title="Phase Shift Modulation"></a>Phase Shift Modulation</h2><p><code>移相调制（Phase shift modulation）</code>是根据原信号改变载波的相位。经过理论上可行，但对于模拟信号来说，很少用移相调制，因为模拟信号采样点的数据可能比较接近，导致移相的大小不明显，很容易被误认为是频率的改变。但对于数字信号来说移相调制因为可以一个码元传递多个Bit的字节，所以经常被使用。</p>
<h2 id="Amplitude-Modulation-And-Shannon’s-Theorem"><a href="#Amplitude-Modulation-And-Shannon’s-Theorem" class="headerlink" title="Amplitude Modulation And Shannon’s Theorem"></a>Amplitude Modulation And Shannon’s Theorem</h2><p>在之前解释振幅调制的示意图中，调制后信号变化幅度较大，最低处的强度接近于0。但实际运用时，基本上振幅调制的幅度变化很小。因为考虑到有噪声的存在，如果信号的变化幅度较大，在信号最弱时的信噪比会很低，则几乎无法传递有效信息。</p>
<h2 id="Modulation-Digital-Input-And-Shift-Keying"><a href="#Modulation-Digital-Input-And-Shift-Keying" class="headerlink" title="Modulation,Digital Input,And Shift Keying"></a>Modulation,Digital Input,And Shift Keying</h2><p>为了区分模拟信号和数字信号的调制，使用属于<code>移位键控（Shift Keying）</code>来表示数字信号的调制。数字信号的调制与模拟信号调制基本原理类似，只不过作为原信号的模拟信号是连续的数值变化，而数字信号是离散的几个特定的数值。振幅与频率移位键控如下图，(a)是载波，(b)是原信号，(c)是振幅移位键控，(d)是频率移位键控</p>
<p><img src="CNI-Chapter10-Notes/2019-12-08-00-05-53.png" alt="振幅，频率移位键控"></p>
<h2 id="Phase-Shift-Keying"><a href="#Phase-Shift-Keying" class="headerlink" title="Phase Shift Keying"></a>Phase Shift Keying</h2><p><code>相位移位键控(Phase Shift Keying)</code>是根据原信号突然的改变载波的相位，如下图所示，即为相位移位键控的示意图。</p>
<p><img src="CNI-Chapter10-Notes/2019-12-08-00-11-28.png" alt="相位移位键控"></p>
<h2 id="Phase-Shift-And-A-Constellation-Diagram"><a href="#Phase-Shift-And-A-Constellation-Diagram" class="headerlink" title="Phase Shift And A Constellation Diagram"></a>Phase Shift And A Constellation Diagram</h2><p>如之前所示，相位移位键控最大的优势在于可以用一个码元传递多个bit。可通过$2^n$个相位来使一个码元可携带$n$ bit数据。使用星座图来表示相位变化大小与该大小与对应数据的关系。星座图如下图所示，图（1）是只有两个相位变化，即表示0和1，图（2）是有四个相位变化，可代表两个bit,即00,01,10,11。</p>
<p><img src="CNI-Chapter10-Notes/2019-12-08-00-18-17.png" alt="两个相位的相位移位键控"></p>
<p><img src="CNI-Chapter10-Notes/2019-12-08-00-18-54.png" alt="四个相位的相位移位键控"></p>
<h2 id="Quadrature-Amplitude-Modulation"><a href="#Quadrature-Amplitude-Modulation" class="headerlink" title="Quadrature Amplitude Modulation"></a>Quadrature Amplitude Modulation</h2><p>如上节所述，可以在使用相位移位键控时采用多个相位间隔使一个码元传递多个bit。但某些情况下，硬件无法检测过于精细的相位变化。这时候可以通过降相位移位键控和振幅移位键控结合在一起使一个码元可携带更多的数据，这方法称为<code>正交振幅调制（Quadrature Amplitude Modulation）</code>。如下图所示：</p>
<p><img src="CNI-Chapter10-Notes/2019-12-08-10-04-32.png" alt="正交振幅调制"></p>
<p>如上图，一共有四个相位区分，每个点距离原点的距离代表振幅，一共有四个电压，因此一共有16种组合，一个码元可以携带4个bit。</p>
<h2 id="Modem-Hardware-For-Modulation-And-Demodulation"><a href="#Modem-Hardware-For-Modulation-And-Demodulation" class="headerlink" title="Modem Hardware For Modulation And Demodulation"></a>Modem Hardware For Modulation And Demodulation</h2><p>将一系列的数据bit作为输入，然后根据这些原数据对载波进行调制的设备称为<code>调制器（Modulator）</code>，反之根据调制后的载波重新解析出原信号的机器称为<code>解调器（Demodulator）</code>。在实际中，大部分的通信设备同时包含调制器和解调器，这种设备被称为<code>调制解调器（Modem）</code>。下图是两个计算机的通信简图，在两者将数据传给中间的电缆媒介前，都经过了调制解调器</p>
<p><img src="CNI-Chapter10-Notes/2019-12-08-10-13-14.png" alt="调制解调器"></p>
<h2 id="Optical-And-Radio-Frequency-Modems"><a href="#Optical-And-Radio-Frequency-Modems" class="headerlink" title="Optical And Radio Frequency Modems"></a>Optical And Radio Frequency Modems</h2><p>调制解调器不仅可用于电缆的传输，对于无线电波和光纤也同样适用，原理也一样，在发送端调制解调器对载波进行调制，在接收端，数据从被调制后的载波中会提取。</p>
<h2 id="Dialup-Modems"><a href="#Dialup-Modems" class="headerlink" title="Dialup Modems"></a>Dialup Modems</h2><p>在语音电话系统中，使用的调制解调器称为<code>拨号调制解调器（Dialup Modems）</code>，其与普通的调制解调器最大的区别在于，前者用的是语音信号，后者用的是电信号，而且拨号调制解调器占用的带宽更小。</p>
<p>因为电话系统接受的是模拟信号，所以拨号调制解调器也是一个对模拟信号进行调制的设备。但讽刺的是现代电话系统的中间传输部分是数字信号，于是发送端在调制后，需要将模拟信号转换为数字信号。而在接收端，在进行解调前也需要先将中间传输来的数字信号转换为模拟信号。</p>
<h2 id="QAM-Applied-To-Dialup"><a href="#QAM-Applied-To-Dialup" class="headerlink" title="QAM Applied To Dialup"></a>QAM Applied To Dialup</h2><p>正交振幅调制也同样可用于拨号调制解调器中。因为大部分语音频率本身是从$300HZ\sim 3300HZ$，但拨号调制解调器只能提供$600HZ\sim 3000HZ$，所以同样需要正交振幅调制来使一个码元能携带更多的数据。</p>
<h2 id="V-32-And-V-32bis-Dialup-Modems"><a href="#V-32-And-V-32bis-Dialup-Modems" class="headerlink" title="V.32 And V.32bis Dialup Modems"></a>V.32 And V.32bis Dialup Modems</h2><p>V.32和V.32bis是两个拨号调制解调器用正交振幅调制的标准。</p>
<p>V.32使用32个振幅和相位的组合来表示数据，可以达到单向每秒9600个bit的数据速率。</p>
<p><img src="CNI-Chapter10-Notes/2019-12-08-10-28-37.png" alt="V.32"></p>
<p>V.32bis使用128个振幅和相位的组合来表数据，可以达到单向每秒14400个bit的数据速率。</p>
<div class="note info simple"><ol>
<li><em>Computer Networks and Internets</em> 6th</li>
</ol>
</div>
<hr>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《计算机网络与因特网》 第十一章笔记</title>
    <url>/CNI-Chapter11-Notes/</url>
    <content><![CDATA[<p>《计算机网络与因特网》 第十一章笔记</p>
<p>这一章主要是关于复用的概念。</p>
<span id="more"></span>
<h1 id="Multiplexing-And-Demultiplexing（Channelization）"><a href="#Multiplexing-And-Demultiplexing（Channelization）" class="headerlink" title="Multiplexing And Demultiplexing（Channelization）"></a>Multiplexing And Demultiplexing（Channelization）</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>这一章介绍复用的概念，包括为什么要复用，复用的类型等。</p>
<h2 id="The-Comcept-Of-Multiplexing"><a href="#The-Comcept-Of-Multiplexing" class="headerlink" title="The Comcept Of Multiplexing"></a>The Comcept Of Multiplexing</h2><p><code>复用(Multiplexing)</code>是将多个信源的数据流合并在一起，并通过一个共享的媒介进行传输。<code>复用器（Multiplexor）</code>是用来进行复用的设备。<code>解复用（Demultiplexing）</code>是将合并后的数据流拆分还原成一个个信源的信息，<code>解复用器（Demultiplexor）</code>是用来进行解复用的设备。下图是复用与解复用的使用简图：</p>
<p><img src="CNI-Chapter11-Notes/2019-12-08-10-56-05.png" alt="复用与解复用"></p>
<p>复用与解复用在日常的计算机网络使用中一直在进行，如多台电脑使用同一根网线等。</p>
<h2 id="The-Basic-Types-Of-Multiplexing"><a href="#The-Basic-Types-Of-Multiplexing" class="headerlink" title="The Basic Types Of Multiplexing"></a>The Basic Types Of Multiplexing</h2><p>在物理层，有四大类的复用方式：</p>
<ol>
<li>频分复用（Frequency Division Multiplexing）</li>
<li>波分复用（Wavelength Division Multiplexing）</li>
<li>时分复用（Time Division Multiplexing）</li>
<li>码分复用（Code Division Multiplexing）</li>
</ol>
<p>频分复用和波分复用使用比较广泛。波分复用可以看作是频分复用的一种特殊形式（波长与波的频率是相关的），波分复用用于光纤中。码分复用是没有使用物理特性，而是用数学原理，在一些电话系统中有运用。</p>
<h2 id="Frequency-Division-Multiplexing（FDM）"><a href="#Frequency-Division-Multiplexing（FDM）" class="headerlink" title="Frequency Division Multiplexing（FDM）"></a>Frequency Division Multiplexing（FDM）</h2><p><code>频分复用（Frequency Division Multiplexing）</code>是无线电广播的基础。在频分复用下，一个有大频率带宽的信道将拆分成许多小部分，每个信源都有一个自己单独的信道（占据一定频率的范围，相当于每个信源的载波频率都不同），每个信道间不会相互干扰，所有的信源都将使用一个共同的媒介进行传输。在频分复用下，每个信道都可以选择各自的方式进行调制。</p>
<p>频分复用最大的优点在于多个发送端和接收端都可以同时使用传输媒介。</p>
<p>为了避免在频分复用下，每个信源都有自己的信道，如果这些信道间的频率太过于接近则会产生干扰。为了避免干扰的的产生，信道之间需要由间隔（Gap），称为<code>防护频带（Guard band）</code>。</p>
<p>下图是频分复用的示意图，每个小块代表一个可供信源使用的单独信道，可以看到每个信道间都有一个小间隔作为防护频带。</p>
<p><img src="CNI-Chapter11-Notes/2019-12-08-11-15-01.png" alt="频分复用"></p>
<h2 id="Using-A-Range-Of-Frequency-Per-Channel"><a href="#Using-A-Range-Of-Frequency-Per-Channel" class="headerlink" title="Using A Range Of Frequency Per Channel"></a>Using A Range Of Frequency Per Channel</h2><p>在上节的例子中，每个信道都有一个频率范围，但载波是固定频率的，信道之所欲选择一个频率范围而非单一的频率，主要是考虑便捷性，因为划分出的信道可能会以各种方式被使用。大多数频分复用系统都给发送端和接收端一个频率范围，系统可以选择最适用的频率作为载波，选择的评判标准通常是数据速率和对噪音的敏感性。</p>
<p>因为频分复用通常的频率较高，对噪声敏感，因此通常使用同轴电缆来作为传输媒介。</p>
<p>有的时候为了进一步增加数据速率，被分配给一个信源的信道会被再次的分割成更小的信道，如一个信源将分配给它的信道再分割成$K$个小信道，则每个小信道只要传输$1/k$的数据即可，这技术称为<code>子信道（Subchannel）</code>。</p>
<p>有的时候为了进一步增加对噪声的抵抗性，会使用称为<code>展频(Spread Spectrum)</code>的技术。这个方法同样将信源的信道再切割成$k$个小信道，但每个信道都传输一样的数据，接收端收到信息后，从这$k$个小信道中找寻错误最少的数据作为接收数据。</p>
<h2 id="Hierarchical-FDM"><a href="#Hierarchical-FDM" class="headerlink" title="Hierarchical FDM"></a>Hierarchical FDM</h2><p><code>分层频分复用（Hierarchical FDM）</code>是将频分复用后的总数据再作为一个频率更高的频分复用的输入进行再次复用。如下图所示：</p>
<p><img src="CNI-Chapter11-Notes/2019-12-08-12-06-55.png" alt="分层频分复用"></p>
<p>虽然上图中每一级的单一信道带宽是上一级所有信道带宽的总和。但在实际运用中，下一级的单一信道带宽是要略大于上一级所有信道带宽的总和的，因为还需要携带额外的同步帧。</p>
<h2 id="Wavelength-Division-Multiplexing（WDM）"><a href="#Wavelength-Division-Multiplexing（WDM）" class="headerlink" title="Wavelength Division Multiplexing（WDM）"></a>Wavelength Division Multiplexing（WDM）</h2><p><code>波分复用（Wavelength Division Multiplexing，WDM）</code>是在使用光纤作为媒介时的频分复用。当波分复用使用了许多不同频率的光时，可称为<code>密集波分复用（Dense Wavelength Division Multiplexing）</code>。</p>
<p>波分复用的原理可以参考物理上的三棱镜实验，即白光可以拆分为不同颜色的光，而光的颜色是由光的频率决定的。棱柱为波分复用与解复用提供了基础。波分复用的复用器是接受一系列不同波长的光，然后通过一个棱柱将它们合并成一束光，然后接收端的解复用器再次通过棱镜将它们还原成不同波长的光。示意图如下：</p>
<p><img src="CNI-Chapter11-Notes/2019-12-08-12-15-12.png" alt="波分复用"></p>
<h2 id="Time-Division-Multiplexing（TDM）"><a href="#Time-Division-Multiplexing（TDM）" class="headerlink" title="Time Division Multiplexing（TDM）"></a>Time Division Multiplexing（TDM）</h2><p><code>时分复用（Time Division Multiplexing，TDM）</code>的原理很简单，即每个信源使用共同的媒介一段时间，然后供下一个信源使用。示意图如下：</p>
<p><img src="CNI-Chapter11-Notes/2019-12-08-12-18-29.png" alt="时分复用"></p>
<h2 id="Synchronous-TDM"><a href="#Synchronous-TDM" class="headerlink" title="Synchronous TDM"></a>Synchronous TDM</h2><p>时分复用在计算机网络中是一个比较宽泛的概念。因此在实际运用中，上节中的概念图会在细节上有变化。例如有些时分复用系统并不是所有信源按顺序一个个发送。有些时分复用的系统中，每个信源发送间也并不像上图一样有时间间隔，一个信源发送后另一个信源会马上发送，这种系统称为<code>同步时间复用系统（Synchronous TDM）</code>。如下图所示：</p>
<p><img src="CNI-Chapter11-Notes/2019-12-08-14-34-28.png" alt="同步TDM"></p>
<h2 id="Framing-Used-In-The-Telephone-System-Version-Of-TDM"><a href="#Framing-Used-In-The-Telephone-System-Version-Of-TDM" class="headerlink" title="Framing Used In The Telephone System Version Of TDM"></a>Framing Used In The Telephone System Version Of TDM</h2><p>如之前所述，电话系统的两端是模拟信号，中间传输的是数字信号。对于中间使用同一个媒介传输的数字信号是通过同步时间复用系统来进行复用的。在电话系统中在时间复用系统中用了一个特殊技术来保证接收端和发送端的时间是对齐的，因为一旦接收端的时间出现了偏差，则可能将错误的信号传递给错误的目的地。为了解决这个问题，电话系统中的时间复用系统需要额外传输一个<code>信道帧（Framing Channel）</code>来表示一轮传输的开始，如下图所示：</p>
<p><img src="CNI-Chapter11-Notes/2019-12-08-14-42-09.png" alt="信道帧"></p>
<h2 id="Hierarchical-TDM"><a href="#Hierarchical-TDM" class="headerlink" title="Hierarchical TDM"></a>Hierarchical TDM</h2><p>如同频分复用，时间复用也可以是分层的。不同的是，在频分复用系统中，每一级增加的是频率，在时分复用系统中每一级增加的是数据速率（减少时间切分间隔）。另外每一级的数据速率略大于前一级所有数据速率的总和，这是因为要传输额外帧数据。分层时间复用如下图：</p>
<p><img src="CNI-Chapter11-Notes/2019-12-08-14-46-19.png" alt=""></p>
<h2 id="The-Problem-With-Synchronous-TDM-Unfilled-Slots"><a href="#The-Problem-With-Synchronous-TDM-Unfilled-Slots" class="headerlink" title="The Problem With Synchronous TDM: Unfilled Slots"></a>The Problem With Synchronous TDM: Unfilled Slots</h2><p>同步时间复用对与每个信源都平均的提供时间，即将整个信道的容量（容量可看作一秒能传输的数据量）平分。但如果一个信源在某一段是空白数据，那么当轮到这个信源发送数据时，只能往信道内填空白数据（通常填0），且额外增加一位表示该数据是无效的，而不是正好全是0。这样会造成信道容量的浪费。如下图所示：</p>
<p><img src="CNI-Chapter11-Notes/2019-12-08-14-50-26.png" alt="未填充数据时间复用"></p>
<h2 id="Statistical-TDM"><a href="#Statistical-TDM" class="headerlink" title="Statistical TDM"></a>Statistical TDM</h2><p>为了解决同步TDM这个问题，有个称为<code>统计时间复用（Statistical TDM）</code>，或称为异步时间复用（Asynchronous）的技术。这个技术仍然是所有信源轮询的传输数据，但是当信源没有数据时，并非像同步时间同步那样装填空白数据，而是直接跳过。如下图所示：</p>
<p><img src="CNI-Chapter11-Notes/2019-12-08-14-54-27.png" alt="统计时间复用"></p>
<p>尽管这个方法解决了空白数据造成的信道容量浪费，但需要引入额外的数据来表明每个数据块是哪个信源的。</p>
<h2 id="Inverse-Multiplexing"><a href="#Inverse-Multiplexing" class="headerlink" title="Inverse Multiplexing"></a>Inverse Multiplexing</h2><p><code>逆复用（Inverse Multiplexing）</code>技术是用类似于复用的思维方式，但解决是只有两个信源，但其中有多个传输媒介，且两信源有大量的数据需要传输，但中间媒介没有一个有足够的足够的比特率。逆复用技术就是将原数据拆分成多份，然后通过中间的低容量媒介进行传输，最后在接收端再将数据合并在一起。示意图如下图所示：</p>
<p><img src="CNI-Chapter11-Notes/2019-12-08-15-04-52.png" alt="逆复用"></p>
<p>虽然逆复用看着很像复用的反向使用，即将复用的输出端变成输入，输入端变成输出，但在实际使用时，不能简单的将复用器反向设计得到逆复用器。逆复用器在发射端必须考虑如何将数据拆分后分配给多个低速率媒介。在接收端也必须考虑多个媒介的传输速率不同，可能造成某些媒介中的数据到达特别缓慢，这时候该如何处理。</p>
<h2 id="Code-Division-Multiplexing"><a href="#Code-Division-Multiplexing" class="headerlink" title="Code Division Multiplexing"></a>Code Division Multiplexing</h2><p><code>码分复用（Code Division Multiplexing）</code>是在蜂窝电话（Cellular telephone）和卫星通信中使用的复用方法。与频分复用和时分复用不同的是，码分复用并不依赖与物理特性，而是利用数学特性：两个正交的线段可以被结合在一起而不会互相干扰。</p>
<p>每个信源都有一个不同的二进制码$C_i$，每个信源的二进制码都必须与其他信源的二进制码正交。即将这些二进制码看作是线段（1保持1，0看成-1），这些线段间必须两两垂直。每个信源都将原数据与二进制码叉乘，然后传输结果，复用的过程即是将所有的结果都累加在一起，在接收端每个信源的目的地再相应的将接受到的复用数据再次与对应信源的二进制码点乘，结果即为该信源应该收到的数据。</p>
<p>下面以一个例子方便理解。</p>
<p>假设有两个信源，两个信源的$C_i$分别是$(1,0)和(1,1)$，需要传输的数据分别是$(1,0,1,0)$和$(0,1,1,0)$。传输过程如下：</p>
<p>将原数据和二进制码改为向量，即1为1，0变-1。<br>信源1：$C_1=(1,-1)$，$V_1=(1,-1,1,-1)$<br>信源2：$C_2=(1,1)$，$V_2=(-1,1,1,-1)$</p>
<p>可以看到$C_1$和$C_2$是正交的。</p>
<p>复用过程即为:</p>
<script type="math/tex; mode=display">
(C_1 \times V_1) + (C_2\times V_2)= \\\\
((1,-1),(-1,1),(1,-1),(-1,1))+((-1,-1),(1,1),(1,1),(-1,-1))\\\\
=((0,-2),(0,2),(2,0),(-2,0))</script><p>((0,-2),(0,2),(2,0),(-2,0))即为复用后的结果。</p>
<p>对于信源1的接收端而言，解复用过程为：</p>
<script type="math/tex; mode=display">(1,-1)\cdot((0,-2),(0,2),(2,0),(-2,0))\\\\
=((0+2),(0-2),(2+0),(-2+0))\\\\
=(2,-2,2,-2)</script><p>负数变为0，正数变为1，即接收端1收到数据为(1,-1,1,-1)，与信源1发送数据相同。</p>
<p>对于信源2的接收端来说，解复用过程如下：</p>
<script type="math/tex; mode=display">(1,1)\cdot((0,-2),(0,2),(2,0),(-2,0))\\\\
=((0-2),(0+2),(2+0),(-2+0))\\\\
=(-2,2,2,-2)</script><p>负数变为0，正数变为1，即接收端2收到数据为(-1,1,1,-1)，与信源2发送数据相同。</p>
<p>上述例子中，每个信源的二进制码$c_i$都比较小，但在实际运用中$c_i$可能会很大，这就导致了计算量的上升。如果数据本身并不多，但是花费了大量时间计算，效率比较低，因此在数据量不高的网络中CDM并不适用，</p>
<p>但是高数据量网络中，码分复用非常常见，因为相对于时间复用，码分复用的延迟较低。因为码分复用可以将多个信源的数据一次性同时发送给发送端，而时分复用则必须等待轮询到自己才能发送一部分。</p>
<div class="note info simple"><ol>
<li><em>Computer Networks and Internets</em> 6th</li>
</ol>
</div>
<hr>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《计算机网络与因特网》 第十三章笔记</title>
    <url>/CNI-Chapter13-Notes/</url>
    <content><![CDATA[<p>《计算机网络与因特网》 第十三章笔记</p>
<p>主要讨论了分组交换，包的概念，局域网中的拓扑等。</p>
<span id="more"></span>
<h1 id="Chapter-13-Local-Area-Networks-Packets-Frames-And-Topologies"><a href="#Chapter-13-Local-Area-Networks-Packets-Frames-And-Topologies" class="headerlink" title="Chapter 13 Local Area Networks: Packets,Frames,And Topologies"></a>Chapter 13 Local Area Networks: Packets,Frames,And Topologies</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>这一章主要会介绍分组交换，计算机网络技术，硬件地址，帧识别等概念。</p>
<h2 id="Circuit-Switching-And-Analog-Communication"><a href="#Circuit-Switching-And-Analog-Communication" class="headerlink" title="Circuit Switching And Analog Communication"></a>Circuit Switching And Analog Communication</h2><p><code>电路交换（Circuit Switching）</code>概念是指使用时在发送端和接收端之间建立不受干扰的通路的通信方法。电路交换通常与模拟电话技术相关。下图是电路交换的示意图：</p>
<p><img src="CNI-Chapter13-Notes/2019-12-09-08-28-27.png" alt="电路交换"></p>
<p>电路交换的主要特点是：</p>
<ol>
<li>是点对点的通信</li>
<li>有单独的步骤建立电路连接，使用电路，终止电路连接<br>例如在电话通信中，实际上有三步。第一步在电话发起人和接受者之间建立电路，第二步双方使用电路进行通信，第三步在通话结束后，终止通路。<br>这也是称为交换（Switched）电路的原因</li>
<li>与固定的物理通路有相同的性能。</li>
</ol>
<p>电路交换建立的电路最终使用频分复用或者时分复用使用同一个媒介进行传输。电路建立的过程包括在频分复用或时分复用中分配频率或时间段。</p>
<h2 id="Packet-Switching"><a href="#Packet-Switching" class="headerlink" title="Packet Switching"></a>Packet Switching</h2><p>分组交换（Packet Switching）使用一种统计意义上的复用，即多个信源之间竞争共享媒介的使用。电路交换通常在传统的电话通信中使用，而分组交换构成了因特网的基础。分组交换示意图如下：</p>
<p><img src="CNI-Chapter13-Notes/2019-12-09-08-37-20.png" alt="分组交换"></p>
<p>注意，在11章中提到的复用技术，如频分复用和时分复用是对于物理存在的信道或者像电路交换这样生成的信道使用的，与分组交换并没有关系。分组交换本身就有统计复用（Statistic Multiplexing）的概念。多个信源在媒介空闲时竞争使用，当媒介为空，且只有一个信源需要传输数据时，该信源就会独占媒介。如果同时有多个信源要传输数据，则基本每个信源占据媒介的时间是平均的，轮流使用。</p>
<p>分组交换的核心是将原数据切分成一个个小块方便传输，这些小块称作包（Packets），包中需要包括传送的目的地信息（在之后节会更详细说明）。分组交换传输的单位不是bit或者byte,而是包。不同的分组交换技术对于包的尺寸有不同的定义。</p>
<p>分组交换的主要特点是：</p>
<ol>
<li>任意大小的异步传输</li>
<li>在通信前没有建立通路的步骤</li>
<li>性能取决于各信源的包的统计复用</li>
</ol>
<p>分组交换的主要优点在于成本的控制。对于电路交换来说，如果有$N$个电脑，则需要$N/2$个独立的路径（虽然在连接时才创建）。但对于分组交换只要一个共享的电路就行。</p>
<h2 id="Local-And-Wide-Area-Packet-Networks"><a href="#Local-And-Wide-Area-Packet-Networks" class="headerlink" title="Local And Wide Area Packet Networks"></a>Local And Wide Area Packet Networks</h2><p>分组交换技术通常根据传输距离的距离进行分类。通常分为三类：</p>
<ol>
<li>局域网（Local Area Network,LAN）：最便宜，通常范围在房间级或者一个大楼。</li>
<li>城域网（Metropolitan Area Network,MAN）中等开销，范围涵盖城市或者大都会。</li>
<li>广域网（Wide Area Network,WAN）：最贵。范围通常包含城市与城市之间。</li>
</ol>
<p>在实际使用中，虽然城域网的概念被提出，但在商业上并不成功。基本广泛使用的只有局域网和广域网，城域网的概念在逐步被纳入广域网中。</p>
<p>还有一些机构或者商家定义的类似的分类方式，如：</p>
<ol>
<li><code>个人局域网络（Personal Area Network，PAN）</code>，通常范围在几米内，如蓝牙通信等。</li>
<li><code>芯片局域网络（Chip Area Network）</code>，芯片厂商提出的概念，通常是超大型电路（Very-Large-Scale-Integration,VLSI）中多个核之间的通信。</li>
</ol>
<h2 id="Standards-For-Packet-Format-And-Identification"><a href="#Standards-For-Packet-Format-And-Identification" class="headerlink" title="Standards For Packet Format And Identification"></a>Standards For Packet Format And Identification</h2><p>每个在网络中传输的包都必须包含其目标收信人的标识。需要有规范来制定标识的格式以及添加的位置，在LAN领域最常用的标准是由IEEE（Institute Electrical And Electronics Engineers）创建的。</p>
<p>IEEE是由一群关注于协议栈最下两层（物理层（Physical）和数据链接层（Data Link））的工程师构成的。协议栈的不同层由不同的机构负责，如IEFT关注传输层和因特网协议，WWW组织关注应用层。机构与其关注的协议如下图所示：</p>
<p>在1980年，IEEE组织了<code>802项目局域网/城域网标准委员（Project 802 LAN/MAN Standards Commitee）</code>会为网络设定标准。</p>
<p><img src="CNI-Chapter13-Notes/2019-12-09-09-12-05.png" alt="组织和协议"></p>
<h2 id="IEEE-802-Model-And-Standards"><a href="#IEEE-802-Model-And-Standards" class="headerlink" title="IEEE 802 Model And Standards"></a>IEEE 802 Model And Standards</h2><p>IEEE将数据链接层又在细分为了两层，<code>逻辑链接控制层（Logical Link Control,LLC）</code>(第15章中描述)和<code>媒介访问控制层（Media Access Control,MAC）</code>。</p>
<p>逻辑链接控制层设备的地址和在解复用中地址的使用。媒介访问控制层关注于多个计算机如何共享底层的媒介。</p>
<p>IEEE对于协议的命名是采用多部分标识符，如$XXX.YYY.ZZZ$，$XXX$表示协议的分类，$YYY$表示协议的子分类，$ZZZ$是当子分类也非常大是，额外添加的标识。</p>
<p>如局域网的规范在分类802中，这里的802并不是什么缩写或有实际的技术含义，仅仅是一个分类标识。IEEE不同的工作小组针对其细分的协议进行定义，如针对$802.1$或$802.2$。</p>
<p>IEEE中有许多不同的工作小组。当有新技术需要协议时，由工业代表和学术协会共同形成工作小组，他们会定期开会商定协议的细节等，当协议的所有细节都确定后，IEEE会发表协议的标准文件。</p>
<p>当协议最终发布后，工作小组可以选择解散或者如果协议非常重要或者仍需要后续工作，小组也可以继续活动。如果小组负责的部分协议不再有意义，如商业上不被接受，或者有更新更好的技术出现，小组也可以选择直接解散而不发表任何的规范。下图是802分类下的协议，有一些规范就已经被放弃（Disbanded）了。</p>
<p><img src="CNI-Chapter13-Notes/2019-12-09-09-25-59.png" alt="802协议"></p>
<h3 id="LAN-Topologies"><a href="#LAN-Topologies" class="headerlink" title="LAN Topologies"></a>LAN Topologies</h3><p>因为有许多不同的LAN技术，通常使用拓扑型或者网络的基本形状来进行分类。LAN有四个基本的拓扑型，<code>总线型结构（Bus）</code>，<code>环状结构（Ring）</code>，<code>星状结构（Star）</code>，<code>网状结构（Mesh）</code>。</p>
<h3 id="Bus-Topology"><a href="#Bus-Topology" class="headerlink" title="Bus Topology"></a>Bus Topology</h3><p><code>总线型结构（Bus Topology）</code>是如同以太网一样，用一根电缆连接所有电脑，任何电脑都可以将数据传输到电缆上，然后所有的计算机都可以接受到数据。</p>
<h3 id="Ring-Topology"><a href="#Ring-Topology" class="headerlink" title="Ring Topology"></a>Ring Topology</h3><p><code>环状结构（Ring Topology）</code>是多个电脑首尾相接的连接，直至成为环形。环形结构的优点是对于相连的两台设备来说连接是安全的，即使别的设备出现问题仍然可以连接。</p>
<h3 id="Mesh-Topology"><a href="#Mesh-Topology" class="headerlink" title="Mesh Topology"></a>Mesh Topology</h3><p><code>网状结构（Mesh Topology）</code>为任意两两配对的电脑都提供了连接线路，这意味着如果有$N$台电脑，就需要$\frac{n^2-n}{2}$个连接。当增加电脑时，连接电缆的增加是平方级的，因此开销巨大，也因此网状结构在局域网中不常被使用</p>
<h3 id="Star-Topology"><a href="#Star-Topology" class="headerlink" title="Star Topology"></a>Star Topology</h3><p><code>星状结构（Star Topology）</code>是所有的电脑都连接在一个中心设备（Hub）上。注意星状结构并不严格要求中心设备真的在所有电脑的中心，与所有电脑的距离相同。</p>
<h3 id="The-Reason-For-Multiple-Topologies"><a href="#The-Reason-For-Multiple-Topologies" class="headerlink" title="The Reason For Multiple Topologies"></a>The Reason For Multiple Topologies</h3><p>每个结构都有各自的优点，如环状结构很适合各电脑间协调访问，但当其中一个设备出现问题时，通路就会出现问题。星状结构下单一设备出现了问题，其他设备都可以正常访问。总线结构有最少的连接需求，但与环状结构与相同的缺点。网状结构因为连接数量过多，通常不在局域网中使用。</p>
<h2 id="Packet-Identification，Demultiplexing，Mac-Addresses"><a href="#Packet-Identification，Demultiplexing，Mac-Addresses" class="headerlink" title="Packet Identification，Demultiplexing，Mac Addresses"></a>Packet Identification，Demultiplexing，Mac Addresses</h2><p>IEEE为寻址（Addressing）创建了标准。在分组交换中，解复用是依赖于一个称为<code>地址（Address）</code>的标识。每个电脑都分配了一个独特的地址，每个传输的包中都包含其目标收件人（Intended Recipent）的地址。</p>
<p>在IEEE的寻址规范中，每个地址是由48-bit二进制数据组成的，IEEE将其称为媒介访问控制地址（Media Access Control address,MAC address）。因为48位地址来源于以太网技术，所以也有人将其称为以太网地址（Ethernet Address）。</p>
<p>IEEE为每块网卡（Network Interface Card，NIC）都分配了地址，因此当消费者购买了一张网卡时，其中就包含一个独一无二的地址。</p>
<p>但IEEE并不是单独的为每个网卡分配地址，它是将前24位（3 Bytes）分配给设备供应商，然后设备供应商再决定后24位的数据。因此前24位称为组织唯一标识符（Organizationally Unique Identifier，OUI），后24位称为网络接口控制标识符（Network Interface Controller Specific）。</p>
<p>组织唯一标识符的最高有效字节（Most Significant Byte，即大端模式下即最左端）的倒数两位有特殊含义。其最低位表示是单播（0）还是双播（1）。倒数第二位决定该设备是全球唯一（0）（Globally Unique）还是是本地分配（1）（Locally Assigned），全球唯一表明地址是IEEE分配，即世界上的每块网卡都有不同的表示，而本地分配是实验性网卡或者某组织自己地址空间等，即这张卡是在一个小范围内内部使用。</p>
<h2 id="Unicast，Broadcast，And-Multicast-Addresses"><a href="#Unicast，Broadcast，And-Multicast-Addresses" class="headerlink" title="Unicast，Broadcast，And Multicast Addresses"></a>Unicast，Broadcast，And Multicast Addresses</h2><p>IEEE定义了三种对应包传递的方法：</p>
<ol>
<li>单播（Unicast）：目标地址是设定一个电脑，也仅这个电脑可收到包</li>
<li>广播（broadcast）：网络中的所有电脑都可收到包</li>
<li>多播（multicast）：目标地址是一系列的电脑，这些电脑都可以收到包。</li>
</ol>
<p>对于广播来说，因为是所有电脑都收到包，所以目标地址实际是没有意义的。将地址的48位全部设为1，则表示是广播模式。广播模式也可看作是多播模式的一个特殊情况。</p>
<h2 id="Broadcast-Multicast-And-Efficient-Multi-Point-Delivery"><a href="#Broadcast-Multicast-And-Efficient-Multi-Point-Delivery" class="headerlink" title="Broadcast,Multicast,And Efficient Multi-Point Delivery"></a>Broadcast,Multicast,And Efficient Multi-Point Delivery</h2><p>广播和多播模式在局域网中特别有用，对于要传递给多台电脑的数据来说，用这两种方法进行传递特别的高效。</p>
<p>对于大多数的LAN技术，都是通过一个共享的媒介进行传输。当有数据在媒介中传输时，每台电脑都将从媒介中获取包的拷贝，然后再判断包中的地址情况是否与自己复合，来决定是处理包的内容还是丢弃包的内容。</p>
<p>因此局域网中的计算机在处理媒介中的包流程如下：</p>
<ol>
<li>从包中抽取出地址信息</li>
<li>判断地址是否满足自己的单播地址，如果是则接受并处理包</li>
<li>如果2失败，判断地址是否是广播模式，如果是则接受并处理包</li>
<li>如果3失败，判断地址是否是多播模式，且电脑是多播模式指定的电脑组的一员，如果是则接受并处理包</li>
<li>如果4失败，则丢弃包</li>
</ol>
<p>如在局域网情况下，如果多台电脑使用同一个媒介，且包需要传递给多态电脑，那么使用多播和广播模式，数据仅需要发送一次即可。</p>
<h2 id="Frames-And-Framing"><a href="#Frames-And-Framing" class="headerlink" title="Frames And Framing"></a>Frames And Framing</h2><p>在同步通信系统中，帧的概念是让接收者知道数据的开始和结束。但在更宽泛的概念下，帧是表示一系列bit或byte的特定结构，让接收方和发送方都能一致同意的特定格式。</p>
<p>在分组交换中，帧的概念就对应包。在分组交换中，每个包都需要一个数据头，数据头（header）中包含目标地址。数据头后是有效负载（payload），即真正需要传输的原数据。在大部分的网络技术中，有效负载是不透明的即网络设备只能检查数据头。</p>
<p>在整个包的前后还能加入可选的前置数据（Prelude）或后置数据（Postlude）。因此整个包的结构如下所示：</p>
<p><img src="CNI-Chapter13-Notes/2019-12-09-10-47-15.png" alt="包的结构"></p>
<p>举一个例子，如果一个包有6个byte的数据头，然后任意长度的有效负载，在包的前后各有1byte表示包的开始和结束。且开始和结束标识用ASCII码中的SOH（Start Of Header）和EOT（End Of Transmission）表示，则整个包如下所示：</p>
<p><img src="CNI-Chapter13-Notes/2019-12-09-10-49-20.png" alt="包的例子"></p>
<p>上述例子有一点点数据的浪费，因为如果包是一个接一个发的，那么后一个包的SOH会紧跟着前一个包的EOT。在实际中，只需要一个来区分两个包即可。</p>
<p>虽然包的前置数据和后置数据是可选的，但在实际使用中，他们可以一定程度上提升异步传输数据的处理速度和对错误的检测。在异步传输中，如果接收方收到了EOT，它就知道数据包传输完成了，可以直接开始处理数据而不需要等到下一个包的到来再根据新包确定上个包是否完成。当发送端发送数据到一般崩溃时，因为接收端始终收不到EOT，也就能知道错误的发生。</p>
<h2 id="Byte-And-Bit-Stuffing"><a href="#Byte-And-Bit-Stuffing" class="headerlink" title="Byte And Bit Stuffing"></a>Byte And Bit Stuffing</h2><p>在ASCII码中，SOH用十六进制0x01表示，EOT用0x04表示。如果有效负载中也出现了0x01和0x04，接收端就无法判定到底是真实数据还是前置或后置标识。</p>
<p>一种称为字节填充（byte Stuffing）就是为了解决有效负载和特殊标记位有相同表示导致无法识别的问题。<br>该技术有时也称为数据填充（Data Stuffing）或字符填充（Character Stuffing）。该技术主要是</p>
<p>字节装填是用另一个字符来替代特殊标识的出现。</p>
<p>如我们选择用ASCII码中的ESC字符（Ox1B）来作为替换字符。在发送端当有效负载中出现SOH，那么就替换为”ESC A”，如果出现EOT,就替换为”ESC B”，如果出现了ESC就替换为”ESC C”。注意这个计算是针对有效负载的，当整个发送的有效负载中就不会与EOT和SOH相同的数据。对接收端而言，去找寻背后跟着”A,B,C”的ESC字符，然后将其替换回SOH和EOT的数据。发送端的替换过程如下所示：</p>
<p><img src="CNI-Chapter13-Notes/2019-12-09-11-22-32.png" alt="字节装填"></p>
<div class="note info simple"><ol>
<li><em>Computer Networks and Internets</em> 6th</li>
<li><a href="https://web.archive.org/web/20171217042848/http://www.cs.virginia.edu/~mngroup/projects/mpls/documents/thesis/node8.html">Switching technology</a></li>
<li><a href="https://www.cnblogs.com/penghuwan/p/7686059.html#_label3_1">【计算机网络】数据交换技术和多路复用技术的正（nao）确(can)打开方式</a></li>
</ol>
</div>
<hr>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《计算机网络与因特网》 第十四章笔记</title>
    <url>/CNI-Chapter14-Notes/</url>
    <content><![CDATA[<p>《计算机网络与因特网》 第十四章笔记。</p>
<span id="more"></span>
<h1 id="Chapter-14-The-IEEE-MAC-Sublayer"><a href="#Chapter-14-The-IEEE-MAC-Sublayer" class="headerlink" title="Chapter 14 The IEEE MAC Sublayer"></a>Chapter 14 The IEEE MAC Sublayer</h1><ul>
<li>这一章原书中的Statiion一词，在笔记中翻译为<code>终端</code>。</li>
</ul>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>这一章将会深入讨论MAC层，包括多路访问协议（multi-access protocols）以及静态和动态信道分配。</p>
<h2 id="A-Taxonomy-Of-Manchanisms-For-Shared-Access"><a href="#A-Taxonomy-Of-Manchanisms-For-Shared-Access" class="headerlink" title="A Taxonomy Of Manchanisms For Shared Access"></a>A Taxonomy Of Manchanisms For Shared Access</h2><p>实现多个计算机通过一个共享媒介来访问数据主要有三种方法： （1）复用技术（Multiplexing Technique） （2）分布算法来控制访问（Distributed Algorithms For Controlled Access） （3）随机访问策略（Random Access Strategy）</p>
<ul>
<li>这里的复用技术与在11章中讨论的复用核心思想是相同的，但仍然有略微区别。11章中提到的是物理上的复用，通过复用器将信号合并在一起。这里的复用则是对于共享信道的逻辑划分，使不同的终端占用共享信道的部分资源，所以这里的复用技术也称为<code>信道协议（Channelization Protocols）</code>。</li>
</ul>
<p>下图展示了按照共享媒介所使用的方法的分类：</p>
<p><img src="CNI-Chapter14-Notes/2019-12-27-22-55-32.png" alt="共享媒介的分类方法"></p>
<h2 id="Static-And-Dynamic-Channel-Allocation"><a href="#Static-And-Dynamic-Channel-Allocation" class="headerlink" title="Static And Dynamic Channel Allocation"></a>Static And Dynamic Channel Allocation</h2><p>信道分配是与第11章中提到的复用技术相关联的。以频分复用为例子，在第11章中是每个终端都有它的载波频率，终端与载波频率是一对一的关系，这就是<code>信道的静态分配（Static Channel Allocation）</code>。</p>
<p>信道可以静态分配的前提是预先知道终端的存在，而且终端在传输过程中不会发生变化。而在许多的场景下，终端是会变化的，例如一个路由器负责房间内手机的信号，但是手机可以关闭或者离开房间，这就是终端的变化。</p>
<p>在这种情况下就需要<code>信道的动态分配（Dynamic Channel Allocation）</code>，即当终端出现时才分配信道的资源给终端。</p>
<h2 id="Channelization-Protocols"><a href="#Channelization-Protocols" class="headerlink" title="Channelization Protocols"></a>Channelization Protocols</h2><p>与第11章中的复用技术相似，信道分配也存在频分多路复用（Frequency Division Multi-Access），时分多路复用（Time Division Multi—Access），码分多路复用（Code Division Multi-Access）三种类型。</p>
<h3 id="FDMA"><a href="#FDMA" class="headerlink" title="FDMA"></a>FDMA</h3><p>频分多路复用下每个终端都可以选择一个载波频率，这个频率并不会影响到其他的终端。在有些系统下存在一个中央控制器进而支持动态的频分多路复用：当一个新的终端出现，中央控制器用一个预留的信道与终端通信，然后分配一个未使用的载波频率给这个终端，之后终端都使用这个载波频率传输数据。</p>
<h4 id="TDMA"><a href="#TDMA" class="headerlink" title="TDMA"></a>TDMA</h4><p>时分多路复用下，所有终端按顺序编号，如$1,2,3,…N$，并且会按这个顺序占据信道进行传输。如同频分多路复用，在某些系统下支持动态分配，即终端出现时再分配给他信道的占用时间段。</p>
<h4 id="CDMA"><a href="#CDMA" class="headerlink" title="CDMA"></a>CDMA</h4><p>码分多路复用如同码分复用，通过数学方法将多个终端的数据合并在一起，再同时通过信道进行传输。</p>
<h2 id="Controlled-Access-Protocols"><a href="#Controlled-Access-Protocols" class="headerlink" title="Controlled Access Protocols"></a>Controlled Access Protocols</h2><p>访问控制协议（Controlled Access Protocols）为统计复用提供了方法，主要分为三个类型：</p>
<ol>
<li>轮询（Polling）：控制中央持续的询问每一个终端是否要发送数据。</li>
<li>预留（Reservation）：终端需要发送信息时，发出一个在下一次循环时发送数据的申请。</li>
<li>令牌传递（Token Passing）：终端间循环传递一个令牌，当终端持有令牌时可以发送数据。</li>
</ol>
<h3 id="Polling"><a href="#Polling" class="headerlink" title="Polling"></a>Polling</h3><p><code>轮询（Polling）</code>系统是存在一个中央控制器，这个控制器会询问其下的每个终端是否需要传递数据。轮询可以再细分为两种，<code>轮询调度顺序（Round Robin Order）</code>和<code>优先顺序（Priority Order）</code>。在轮询调度顺序下，每个终端都有相同的机会传递数据，而在优先顺序下，一些终端会有更多的机会去传递数据。</p>
<p>轮询的算法实现伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">For Centralized Controller:</span><br><span class="line">while(true)</span><br><span class="line">&#123;</span><br><span class="line">  Select a station S, and send a polling message to S;</span><br><span class="line">  Wait for S to respond by sending a packet or passing;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Reservation"><a href="#Reservation" class="headerlink" title="Reservation"></a>Reservation</h3><p><code>预留（Reservation）</code>系统多用在航天系统中，系统分为两个步骤，在第一步中需要传输数据的终端申请，所有申请的终端构成一张表，在第二步中表中的终端开始传输数据。通常第一步与第二步使用的是不同的信道，即有一个信道专门用来接受申请信息，另一个信道作为主信道传递每个终端的数据。</p>
<p>预留的算法实现伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">For Centralized Controller:</span><br><span class="line">While(true)</span><br><span class="line">&#123;</span><br><span class="line">  Form a list of stations that have a packet to send;</span><br><span class="line">  Allow stations on the list to tranmit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Token-Passing"><a href="#Token-Passing" class="headerlink" title="Token Passing"></a>Token Passing</h3><p><code>令牌传递（Token Passing）</code>被用在多个局域网（LAN）技术中，被用的最多的就是环形拓步结构中。在一个网络中，某一台计算机持有着一个特殊的控制命令，这个命令被称作为令牌，持有令牌的计算机可以发送数据，在发送完毕后将令牌传递给下一个计算机。</p>
<p>令牌传递的算法实现伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">For each computer:</span><br><span class="line">While(true)</span><br><span class="line">&#123;</span><br><span class="line">  Wait for the token to arrive;</span><br><span class="line">  Transmit a packet if one is waiting to be send;</span><br><span class="line">  Send the token to he next station;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>环形拓补结构中，存在物理的环形链接，所以令牌可以直接传递给相邻的下一个电脑。在其他的拓步结构中，所有的计算机都被赋予了一个逻辑顺序，因此可以获知下一个要收取令牌的电脑是哪个。</p>
<h2 id="Random-Access-Protocols"><a href="#Random-Access-Protocols" class="headerlink" title="Random Access Protocols"></a>Random Access Protocols</h2><p>许多网络，特别是局域网络中，并不使用访问控制协议，而使用<code>随机访问协议（Random Access Protocols）</code>。随机访问协议下只有当终端存在数据要发送时，才会被给予权限（在访问控制协议中，每个终端都要被持续检查）。这里的<em>随机</em>是在所有终端都有数据要发送时的处理方式。随机访问协议也可以被分为三类：</p>
<ol>
<li>ALOHA：早期夏威夷的无线电网络中被使用的协议。在教科书中比较流行，因为便于分析，但在实际网络中已不再使用。</li>
<li>CSMA/CD（Carrier Sense Multi-Access With Collision Detection）：原以太网的基础，现在也不再使用。</li>
<li>CSMA/CA（Carrier Sense Multi-Access With Collision Avoidance）：Wifi无线网络的基础。</li>
</ol>
<h3 id="ALOHA"><a href="#ALOHA" class="headerlink" title="ALOHA"></a>ALOHA</h3><p>在早期夏威夷的网络中使用，在这个系统下有一个强大的发送器被部署中在物理上的中心位置，其他的终端（通常对应一台计算机）在这个发送器周围部署，这些终端都没有足够的能量将数据直接传输给其他终端，因此需要通过中央的发送器。</p>
<p>中央发送器用两个载波频率与每个终端通信，一个被称为入站频率（In Frequency，407.305MHZ），一个被称为出站频率（Outbound Frequency，413.475MHZ）。终端通过入站频率将数据传递给中央发送器，中央发送器通过出站频率将数据发送给每个终端。</p>
<p>ALOHA的实现逻辑很直接：当终端有数据要发送时，使用入站频率将数据传递给中央数据站，中央数据站通过出站频率将数据传给所有的终端，终端检查数据是否是自己需要的。为了保证数据被正常发送，发送终端也需要监听出站频率，当发送的数据拷贝被传输回发送终端，发送终端确认数据被正常传递了，就会传输下一个数据。反之，则会在一段时间后尝试重新发送。</p>
<p>当两个终端同时使用各自的入站频率传输数据时，两个数据会发送混淆，进而导致信息错误，将这种情况称为信道冲突（Collision）。协议通过等待一段时间后重新发送数据来解决冲突，重新发送数据前的等待时间的设定尤为关键，如果两个终端等待的时间相同，那么再次发送数据时仍然是同时发送则会继续导致冲突。因此等待时间是随机的，但是网络繁忙时，冲突的概率仍然会增加，因为即使是随机时间仍然可能会与其他的终端发生冲突。</p>
<p>ALOHA示意图如下：</p>
<p><img src="CNI-Chapter14-Notes/2019-12-28-12-56-15.png" alt="ALOHA示意图"></p>
<h3 id="CSMA-CD"><a href="#CSMA-CD" class="headerlink" title="CSMA/CD"></a>CSMA/CD</h3><p>1978年，数字设备联盟（Digital Equipment Corporation），英特尔（Intel）和施乐（Xerox）共同指定了个标准（DIX标准），也就是后来的以太网。最早的以太网技术使用一根长电缆连接每个电脑，这根长电缆就是共享媒介，与ALOHA使用中央发送器来实现数据传输不同，在以太网中每个终端都可以通过这个共享的线缆传输数据。以太网同样需要解决冲突问题，以太网主要引入了三个解决冲突的方法，统称为<code>具有冲突检测功能的载波侦听多路访问（CSMA/CD，Carrier Sense Multi-Access With Collision Detection）</code>：</p>
<ol>
<li>载波侦听（Carrier Sense）：</li>
</ol>
<p>在每个终端发送数据前，先监听线缆确定是否有其他的终端正在传输数据。</p>
<ol>
<li>冲突检测（Collision Detection）：</li>
</ol>
<p>虽然有载波侦听，但如果在线缆空闲时，两个需要发送数据的终端同时监听，此时他们都发现线缆空闲，因此都开始传输数据，这时候仍然会造成冲突。因此在传输过程中，发送终端也会持续的监听线缆，如果发现线缆中的数据与发送的数据不同，说明已经发生了冲突，数据被干扰了，于是停止数据的发送。</p>
<p>以太网的数据传输还有一些细节问题，如在检测到冲突时，发送端并不会立刻停止数据的发送，他仍然会传输数据一段时间，保证所有的其他终端都可以收到冲突信号。另外，当一个包被发送完后，发送终端需要等待一段时间，称为<code>包间间隙（Interpacket gap）</code>（在早期10Mbps的以太网中，包间间隙为9.6微秒），保证其他的终端可以检测到线缆的空闲并传递数据。</p>
<ol>
<li>二进制指数补偿（Binary Exponential Backoff）</li>
</ol>
<p>如ALOHA一样，在发现了冲突后，发送端需要等待一段时间重新发送数据，这个等待时间是随机的，通常会设置一个最大延迟时间$d$，然后在$0\sim d$。如之前所述，在网络繁忙时，可能存在随机后终端仍然冲突的情况。二进制指数补偿是指在新一次冲突发生后，随机的范围变成$0\sim 2d$，如果再有冲突则变成$0\sim 4d$，依次类推。</p>
<p>CSMA/CD算法实现伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">For each Computer:</span><br><span class="line"></span><br><span class="line">Wait for a packet to be ready;</span><br><span class="line">Wait for the medium to be idle;</span><br><span class="line">Delay for the interpacket gap;</span><br><span class="line">Set x to be the standard backoff range d;</span><br><span class="line">Attempt to transmit the packet;</span><br><span class="line"></span><br><span class="line">While(Collision occured)</span><br><span class="line">&#123;</span><br><span class="line"> random a delay time q from 0 to x;</span><br><span class="line"> delay for q microseconds;</span><br><span class="line"> double x to be 2x</span><br><span class="line"> attempt to retransmit the packet</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CSMA-CA"><a href="#CSMA-CA" class="headerlink" title="CSMA/CA"></a>CSMA/CA</h3><p>CSMA/CD并不能被运用在无线网络中，因为无线网络中的设备存在一个最远距离$\delta$。即如果两个终端的距离大于$\delta$，则CSMA/DA中的载波监听就无法被应用，因为一个终端并不能知道另一个是否在发送信息。这种情况如下图所示，如果Computer1在发送信息，Computer3是无法得知的，因此冲突只有Computer2可以知晓，这种情况称为<code>隐藏终端问题(Hidden Station Problem)</code>。</p>
<p><img src="CNI-Chapter14-Notes/2019-12-28-15-00-02.png" alt="隐藏终端问题"></p>
<p>所以无线网络中使用<code>具有冲突规避的载波侦听多路访问（CSMA/CA，Carrier Sense Multi-Access With Collision Avoidance）</code>。以上图的例子，Computer3在发送数据前会先向所有它的$\delta$范围内的设备发出一个短信息表明自己需要发送数据了，接受到Computer3发出的短信息的设备会检查自己是否正在接受其他的数据，如果不是则回复可以发送的信号。如下图所示：</p>
<p><img src="CNI-Chapter14-Notes/2019-12-28-15-08-19.png" alt="CSMA/CA图解"></p>
<p>如果发送端没有收到接收方的回执，则会在随机时间后再次尝试发送。</p>
<div class="note info simple"><ol>
<li><em>Computer Networks and Internets</em> 6th</li>
</ol>
</div>
<hr>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《计算机网络与因特网》 第十六章笔记</title>
    <url>/CNI-Chapter16-Notes/</url>
    <content><![CDATA[<p>《计算机网络与因特网》 第十六章笔记</p>
<span id="more"></span>
<h1 id="Chapter-16-Wireless-Networking-Technologies"><a href="#Chapter-16-Wireless-Networking-Technologies" class="headerlink" title="Chapter 16 Wireless Networking Technologies"></a>Chapter 16 Wireless Networking Technologies</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>这一章主要介绍计算机网络无线部分的技术。</p>
<p>$16.2$节对无线技术依据网络的覆盖范围做了分类。<br>$16.3$节介绍了个人局域网。<br>$16.4$节介绍了ISM频域。<br>$16.5\sim16.11$都是介绍局域网相关技术，主要关注对象是Wifi技术。<br>$16.12$介绍了城域网中使用的WiMax技术。<br>$16.13$给出了个人局域网的标准分类列表。<br>$16.14$介绍了两个没有被包含在个人局域网中的短距离通信，红外线和射频识别通信。<br>$16.15\sim16.18$介绍了广域网技术，主要关注蜂窝式网络。<br>$16.19和16.20$介绍了卫星通信。<br>$16.20$介绍了软件无线电系统。</p>
<h2 id="A-Taxonomy-Of-Wireless-Networks"><a href="#A-Taxonomy-Of-Wireless-Networks" class="headerlink" title="A Taxonomy Of Wireless Networks"></a>A Taxonomy Of Wireless Networks</h2><p>计算机网络无线技术的变种非常多的原因之一在于因为政府的管理，电磁信号的频谱被切分为了许多不同的部分以供不同的目的使用，而这些不同频域的技术通常都不同。</p>
<p>无线技术通常通过其使用的范围来分类，主要可分为：<code>局域网（Local Area Networks,LANs）</code>，<code>城域网（Metropolitan Area Networks,MANs）</code>，<code>广域网（Wide Area Networks，WANs</code>）以及<code>个人局域网（ Personal Area Networks，PANs）</code>。如下图所示：</p>
<p><img src="CNI-Chapter16-Notes/2019-12-30-15-51-47.png" alt="无线网络分类"></p>
<h2 id="Personal-Area-Networks（PANs）"><a href="#Personal-Area-Networks（PANs）" class="headerlink" title="Personal Area Networks（PANs）"></a>Personal Area Networks（PANs）</h2><p>上节中对于无线网络的分类与在第十三章中对于网络的分类十分类似，不同的是这里还引入了个人局域网（Personal Area Networks，PANs）的概念。个人局域网是提供非常短距离下的通信，通常是只供一个用户使用，如蓝牙耳机就属于个人局域网的应用。</p>
<p>个人局域网络可以再细分为以下几种：</p>
<ol>
<li>蓝牙（Bluetooth）：距离较短</li>
<li>红外线（Infrared）：视距通信（Line-Of-Sight Communication）即发射端和接收端之间需要无遮挡</li>
<li>紫峰（ZigBee）：距离可以支撑一个住宅的范围，在智能家居中被运用。</li>
<li>其他ISM无线技术：为工业，科学以及医药（Industrial，Scientific，Medical，ISM）预留的频率发展的技术。</li>
</ol>
<h2 id="ISM-Wireless-Bands-Used-By-LANs-And-PANs"><a href="#ISM-Wireless-Bands-Used-By-LANs-And-PANs" class="headerlink" title="ISM Wireless Bands Used By LANs And PANs"></a>ISM Wireless Bands Used By LANs And PANs</h2><p>振幅为了工业，科学以及医药领域专门预留了一部分频域，被称为ISM无线。这部分的频域并没有再进一步细分，如科学只能用哪一段频域之类。这三个领域的产品都可以使用这部分频域，具体频域如下图所示：</p>
<p><img src="CNI-Chapter16-Notes/2019-12-30-16-04-51.png" alt="ISM频域"></p>
<h2 id="Wireless-LAN-Technologies-And-Wi-Fi"><a href="#Wireless-LAN-Technologies-And-Wi-Fi" class="headerlink" title="Wireless LAN Technologies And Wi-Fi"></a>Wireless LAN Technologies And Wi-Fi</h2><p>IEEE将局域网下的无线网络协议分类在$802.11$下。1999年一些销售商建立了Wifi联盟，一个生产和验证使用802.11协议的无线设备的非盈利组织。因为这个联盟的产品在商业市场上反应很好，消费者将Wifi一词与无线局域网联系在了一起，Wifi原先是产品广告词中<code>Wireless Fidelity</code>的缩写。</p>
<p>下表为Wifi联盟所指定的协议：</p>
<p><img src="CNI-Chapter16-Notes/2019-12-30-16-21-32.png" alt="Wifi联盟协议"></p>
<h2 id="Spread-Spectrum-Technology"><a href="#Spread-Spectrum-Technology" class="headerlink" title="Spread Spectrum Technology"></a>Spread Spectrum Technology</h2><p>在第十一章中提到的展频技术（Spread Spectrum Technology）在wifi技术中也有应用。</p>
<p>展频技术的原理是发送端将原先的信道频域再细分为多个部分，将数据通过不同的频率发送出去，接收端接受多个频率的数据，再还原出原信号。使用展频技术主要目的有两个，一是增加传输速率，另外是增加对噪声的抗干扰能力。</p>
<p>Wifi技术主要用了以下扩频技术，其主要目的还是帮助Wifi在有噪声环境下能更好的工作：</p>
<ol>
<li><p>直接扩频（Direct Sequence Spread Spectrum，DSSS）：</p>
<p>发送端使用一个序列码得到不同的频率，用这些频率来发送数据。</p>
</li>
<li><p>跳频扩频（Frequency Hopping Spread Spectrum，FHSS）：</p>
<p>载波的频率一直在设定的几个频率间切换。</p>
</li>
<li><p>正交频率复用（Orthogonal Frequency Division Multiplexing，OFDM）：</p>
<p>将原信道分为多个小信道，每个小信道传输一部分的数据。</p>
</li>
</ol>
<ul>
<li>书中并未对三个技术做详细的解释，上面的概括解释也可能存在错误。</li>
</ul>
<p>三个技术都有各自的优点，OFDM有最高的适用性，DSSS性能好，FHSS对于噪声的抗干扰能力强。</p>
<h2 id="Other-Wireless-LAN-Standards"><a href="#Other-Wireless-LAN-Standards" class="headerlink" title="Other Wireless LAN Standards"></a>Other Wireless LAN Standards</h2><p>除了上述Wifi联盟所指定的协议，无线局域网还有其他许多的协议，都属于$802.11$协议分类下如下图所示：</p>
<p><img src="CNI-Chapter16-Notes/2019-12-30-16-48-56.png" alt="其他802.11协议"></p>
<h2 id="Wireless-LAN-Architecture"><a href="#Wireless-LAN-Architecture" class="headerlink" title="Wireless LAN Architecture"></a>Wireless LAN Architecture</h2><p>局域网无线网络结构主要有三个因素：（1）<code>接入点（Access Point）</code>，有时也被称为<code>基站（Base Station）</code>。（2） <code>互联机制（Interconnection mechanism）</code>，例如路由器或者交换机，用来将接入点连接在一起。（3）一系列<code>终端（Hosts）</code>，如个人手机就是一个终端。</p>
<p>存在两种无线局域网，一是<code>自主网（Ad hoc）</code>，其中所有的终端都可以在没有接入点的情况下相互通信。另外一个是<code>基础设施结构（Infrastructure）</code>。</p>
<p>在实际运用中，自主网很少存在，基础设施结构如下图所示，图中的$AP$即为接入点（Access Point），一个接入点和连接它的一系列终端称为<code>基本服务集（Basic Service Set，BSS）</code>。</p>
<p><img src="CNI-Chapter16-Notes/2019-12-30-16-59-39.png" alt="基础设施结构"></p>
<h2 id="Overlap，Association，And-802-11-Frame-Format"><a href="#Overlap，Association，And-802-11-Frame-Format" class="headerlink" title="Overlap，Association，And 802.11 Frame Format"></a>Overlap，Association，And 802.11 Frame Format</h2><p>在实际运用中，基础设施结构中的接入点如果距离太远，会出现<code>无服务区（Dead Zone）</code>，距离太仅的话，他们的覆盖的范围会出现重叠（Overlap），因此终端可能会同时存在于两个接入点的范围内。在这种情况下，终端需要指定他与哪个接入点进行通信，因此在$802.11$协议定义的网络帧格式下，帧数据必须包含其连接的接入点的MAC地址。</p>
<p>另外如果基础设施结构是要连接外网的，那么接入点的互联机制还需要另外一个有线连接至与外网连接的路由器，如下图所示，下图也同时展示了上述的接入点重叠情况</p>
<p><img src="CNI-Chapter16-Notes/2019-12-30-17-06-11.png" alt="外网连接以及接入点重叠"></p>
<p>$802.11$的定义的数据帧，还需要指定连接外网的路由器的MAC地址，综上数据帧的结构如下：</p>
<p><img src="CNI-Chapter16-Notes/2019-12-30-17-07-42.png" alt="802.11数据帧"></p>
<h2 id="Coordination-Among-Access-Points"><a href="#Coordination-Among-Access-Points" class="headerlink" title="Coordination Among Access Points"></a>Coordination Among Access Points</h2><p>如上节所述，在接入点重叠的情况下，终端需要决定与哪个接入点进行通信。</p>
<p>主要有两种方法来实现接入点的切换，第一个是靠接入点本身，接入点能相互通信，当接入点发现有终端同时收到多个接入点信号时，接入点会判断信号强度然后帮助终端无缝切换，这种方法实现较为复杂且成本较高。第二种方法下，所有接入点都是独立的，切换是靠终端本身实现，这种方法的成本较低。</p>
<h2 id="Contention-And-Contention-Free-Access"><a href="#Contention-And-Contention-Free-Access" class="headerlink" title="Contention And Contention-Free Access"></a>Contention And Contention-Free Access</h2><p>$802.11$定义了两种信道访问的方式：无竞争（Contention-Free）的点协调方式（Point Coordinated Function，PCF）和存在竞争的分布协调方式（Distributed Coordinated Function，DCF）。</p>
<p>PCF方式保证在一个基本服务集中的接入点保证下面的终端不会发生任何干扰，例如通过给每一个终端一个特定的频率来实现。但在实际中PCF从来都没有被使用过。</p>
<p>DCF则是让一个基本服务集中的终端都使用<code>随机访问协议（Random Access Protocols）</code>。并如同在十四章中的介绍，因为$802.11$是无线网络，所以通常使用的是CSMA/CA，终端需要发送准备完毕（Ready to Send，RTS）和信道空闲（Clear To Send，CTS）两种控制命令。</p>
<p>$802.11$中使用的CSMA/CA还包含一些在十四章未提及的细节，如定义了以下三个时间参数：</p>
<ol>
<li><p>短帧时间间隔（Short Inter-Frame Space,SIFS）为10微秒。</p>
<p>接收端在发送确认信息（Acknowledge，ACK）或其他控制命令前的等待时间。</p>
</li>
<li><p>帧间间隔（Distributed Inter-Frame Space）为50微秒。</p>
<p>在发送端发送数据前必须等待的时间，以保证其他的终端可以监听到信道的空闲。</p>
</li>
<li><p>时隙（Slot Time）为20微秒</p>
</li>
</ol>
<p>Wifi网络中所使用的CSMA/CA如下图所示：</p>
<p><img src="CNI-Chapter16-Notes/2019-12-30-21-20-32.png" alt="Wifi网络中所使用的CSMA/CA"></p>
<p>因为各终端间的物理间隔以及环境噪声，微弱信号的检测是很困难的，因此Wifi网络并没有引入CSMA/CA中的冲突检测（Collision Detection）部分，即发送端并不会在数据发送过程中监听信道来判断是否有冲突。在Wifi网络中，发送端会等待ACK信号，如果没有收到ACK信号，发送端则认为数据发送失败。</p>
<h2 id="Wireless-MAN-Technology-And-WiMax"><a href="#Wireless-MAN-Technology-And-WiMax" class="headerlink" title="Wireless MAN Technology And WiMax"></a>Wireless MAN Technology And WiMax</h2><p>城域网技术的协议被反类在$802.16$中。如同在局域网中主要使用的是Wifi，在城域网中主要使用的事WiMax（World-wide Interoperability For Microwave Access）技术。</p>
<p>WiMax可以再被细分为固定WiMax和移动WiMax，前者是指服务提供方与连接者的位置是固定的，如大楼间的通信，后者则指接收方是可以移动的，如用户的手机和电脑等。</p>
<p>WiMax在城域网中的使用，如果是用在回传网络（服务提供方之间的连接，通常需要较高的数据速率）中则需要无阻碍（Line-Of-Sight，LOS）的连接，如果是在服务提供方与接入点直接的连接则也可以使用有阻碍的连接（Non-Line-Of-Sight，NLOS），如下图所示：</p>
<p><img src="CNI-Chapter16-Notes/2019-12-30-22-02-35.png" alt="WiMax的使用"></p>
<h2 id="PAN-Technologies-And-Standards"><a href="#PAN-Technologies-And-Standards" class="headerlink" title="PAN Technologies And Standards"></a>PAN Technologies And Standards</h2><p>PAN技术被分类在$802.15$分类下，如下图所示：</p>
<p><img src="CNI-Chapter16-Notes/2019-12-30-22-04-05.png" alt="PAN技术"></p>
<h2 id="Other-Short-Distantce-Communication-Technologies"><a href="#Other-Short-Distantce-Communication-Technologies" class="headerlink" title="Other Short-Distantce Communication Technologies"></a>Other Short-Distantce Communication Technologies</h2><p>还有两种技术短距离的通信方式并没有被分类在PANs下，红外通信（Infrared Data Association，IrDA）以及射频识别（Radio Frequency Identification，RFID）通信。</p>
<p>红外通信是方向性的，大约有30°的范围，而且信号可以在障碍物表面反射，但是并不能传统障碍物。电视遥控器即是使用了红外通信。</p>
<p>射频识别通信，是一个芯片中包含有验证信息的Tag，接收方可以将信息从芯片中读取出来。酒店的门禁卡，大学食堂的饭卡等都是使用了这个技术。</p>
<h2 id="Wireless-WAN-Technologies"><a href="#Wireless-WAN-Technologies" class="headerlink" title="Wireless WAN Technologies"></a>Wireless WAN Technologies</h2><p>广域网通信有两大类，蜂窝式通信系统（Cellular communication systems）和卫星通信系统（Satellite communication system）。</p>
<p>蜂窝式通信系统最早是为了满足手机的电话服务设计的。在这个系统下，地区被风格为一个个小块称为<code>巣室（Cell）</code>，每个巣室都包含一个基站塔，一系列基站塔由一个移动交换中心控制。这个中心会追踪用户，并在用户从一个巣室进入另一个巣室时，提供巣室的切换服务。蜂窝式系统的结构如下图：</p>
<p><img src="CNI-Chapter16-Notes/2019-12-30-22-18-47.png" alt="蜂窝式系统结构"></p>
<p>理论上每个巣室都是六边形的，那么就能无缝的分割区域，但在实际运用中，每个基站塔的覆盖范围大致是圆形的，因此就会出现重叠或者无服务区。且基站塔的覆盖范围由所处区域的用户数量决定，如果用户数量很多，则每个基站塔的覆盖范围会较小，且有更多的基站塔，反之每个基站塔覆盖很大一块区域。理论和实际的巣室图如下，（a）图为理想情况，（b）图为实际情况：</p>
<p><img src="CNI-Chapter16-Notes/2019-12-30-22-21-33.png" alt="巣室情况"></p>
<h2 id="Micro-Cells"><a href="#Micro-Cells" class="headerlink" title="Micro Cells"></a>Micro Cells</h2><p>如上节所述，用户密度越大，则设计时每个巣室的面积越小。在城市中，有时会出现一个巣室仅覆盖大楼的一层这种情况，这是称其为微巣室（Micro Cells）。因为巣室很小且很小块区域内有多个巣室，为了避免干扰，微巣室的功率都比较小。</p>
<h2 id="Cell-Clusters-And-Frequency-Reuse"><a href="#Cell-Clusters-And-Frequency-Reuse" class="headerlink" title="Cell Clusters And Frequency Reuse"></a>Cell Clusters And Frequency Reuse</h2><p>蜂窝式通信有一个重要原则：相邻的巣室在不使用相同频率的载波情况下，干扰最小。</p>
<p>蜂窝式系统使用称为巣室簇的结构构成，每个巣室簇都由特定数目的巣室构成，其中的每个巣室频率都不同。通常而言，巣室簇由3，4，7或12个巣室构成，如下图所示：</p>
<p><img src="CNI-Chapter16-Notes/2019-12-30-23-19-08.png" alt="巣室簇"></p>
<p>巣室簇中的每个巣室频率不同，将巣室簇拼接后就不会有相邻巣室频率相同的情况出现，如下图为7巣室簇拼接：</p>
<p><img src="CNI-Chapter16-Notes/2019-12-30-23-20-04.png" alt="巣室簇拼接"></p>
<h2 id="Generations-Of-Cellular-Technologies"><a href="#Generations-Of-Cellular-Technologies" class="headerlink" title="Generations Of Cellular Technologies"></a>Generations Of Cellular Technologies</h2><p>目前通信技术的发展有四代，称为1G,2G,3G和4G：</p>
<ol>
<li>1G：出现在1970年代后期，通过模拟信号传递语音信息。</li>
<li>2G和2.5G：从1990年代早期开始发展，至今仍然在使用。与1G的主要区别在于，2G使用了数字信号传递语音信息。2.5G是2G的扩展，实现了部分3G的特性。</li>
<li>3G和2.5G：从2000年开始发展，主要关注高速数据服务。3G系统提供400Kbps到2Mbps的数据速度。</li>
<li>4G：从大约2008年开始使用，主要关注实时媒体的使用，如电视直播，高速视频下载等。4G手机通常包含多种数据连接方式，如Wifi和卫星通信。</li>
</ol>
<p>在2G技术发展过程中，许多组织都尝试定义标准，欧洲主要使用TDMA技术并制订了GSM标准（Global System For Mobile Communication），该标准逐渐称为了全球标准。在美国，摩托罗拉使用TDMA技术定义了iDEM标准。同时大部分其他的美国运营商和亚洲运营商都使用了CDMA技术来指定标准。</p>
<p>在3G时代，EVDO（Evolution Data Optimized/Evolution Data Only）和EVDV标准几乎同时出现，两者都是CDMA和FDM技术的混合。EVDO技术被运用的较为广泛。</p>
<p>在设计4G标准时，国际通信协会（ITU）指定了4G蜂窝式系统的标准，称为<code>IMT-Advanced（International Mobile Telecommunication Advaced）</code>。其指定终端在高速移动时（如在火车上）应该有100Mbps的数据速率，而在静止时应该有100Mbps的速率。</p>
<p>在早期，运营商指定的4G标准，如<code>HSPA+</code>，<code>HTC Evo 4G</code>，<code>WiMax</code>和<code>LTE（Long Term Evolution）</code>都未满足要求。但是ITU还是允许了他们使用4G作为自己的广告语，在后期，<code>LTE-Advanced</code>和<code>WiMax Advanced</code>满足了ITU的标准，被称为真4G。</p>
<p>3G和4G的主要区别在于，3G系统设计时仍然是基于语音通话系统考虑的，还是继承自原先的模拟电话系统，其他的数据是作为额外的要求。而在4G标准设计时主要考虑因特网协议，因此4G系统使用了帧交换而语音只是作为一个特殊应用。在实际应用中，许多蜂窝系统仍然通过3G来传输通话信息，而在其他数据时使用4G。</p>
<h2 id="VSAT-Satellite-Technology"><a href="#VSAT-Satellite-Technology" class="headerlink" title="VSAT Satellite Technology"></a>VSAT Satellite Technology</h2><p>卫星通信的关键是用一个曲面天线（Parabolic antenna/Dish）保证电磁信号被反射到一个单一点上，如下图所示：</p>
<p><img src="CNI-Chapter16-Notes/2019-12-30-23-39-52.png" alt="曲面天线"></p>
<p>为了最大化收集到的信号，早期的卫星通信系统使用直径大于3米的曲面天线，但这种尺寸的天线并不适用于个人或小商家。于是称为<code>甚小口径天线终端（Very Small Aperture Terminal，VSAT）</code>的技术出现，它指代直径小于3米的曲面天线，通常直径在1米以下。</p>
<p>VSAT卫星通信选择的频率不同会影响信号强度，天气环境变化的敏感程度，和信号的覆盖范围（Satellite’s footprint）。如下表所示：</p>
<p><img src="CNI-Chapter16-Notes/2019-12-30-23-45-24.png" alt="VSAT卫星频率"></p>
<h2 id="GPS-Satellites"><a href="#GPS-Satellites" class="headerlink" title="GPS Satellites"></a>GPS Satellites</h2><p>GPS（Global Positioning System）卫星提供实时的准确位置信息。GPS通信并非是计算机通信的一部分，但是越来越多的移动网络使用了位置信息。</p>
<p>GPS系统通过三颗卫星计算出终端的位置。首先要计算终端距离三颗卫星的距离，距离可以通过卫星与终端的传输时间乘上光速来确定。如果一个终端与卫星的距离为$d$，则终端出现在以卫星为球星，半径为$d$的球上任意位置。通过三个卫星，可以计算出三个球，三个球的交点为两个点（两个球的交点为一个圆形）。这两个交点，一个在太空中，一个在地球上，地球上的点即为终端的位置。</p>
<h2 id="Software-Defined-Radio-And-The-Future-Of-Wireless"><a href="#Software-Defined-Radio-And-The-Future-Of-Wireless" class="headerlink" title="Software Defined Radio And The Future Of Wireless"></a>Software Defined Radio And The Future Of Wireless</h2><p>通常一个蜂窝网络手机需要指定天线，发射器和接收器的规格，这些数据都是需要预先指定的。如果同时支持GSM，Wifi和CDMA，则需要三套独立的无线电系统，使用时在其中切换。</p>
<p>现在传统的无线电系统被软件无线电取代，可以通过软件来指定的特性如下表所示：</p>
<p><img src="CNI-Chapter16-Notes/2019-12-30-23-53-54.png" alt="软件无线电可以设定的特性"></p>
<p>软件无线电的一大特性是可以同时使用多个天线，称实现了多天线同时传输和接受的系统为<code>MIMO（Multiple-Input Multiple-Output）</code>系统。</p>
<p>通过软件来设定通信特性也有一定的危险性，如用户可以选择被政府限制的频率来发送数据或者占据为紧急服务预留的频道。因此这个技术也需要严格规范。</p>
<div class="note info simple"><ol>
<li><em>Computer Networks and Internets</em> 6th</li>
</ol>
</div>
<hr>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《计算机网络与因特网》 第十七章笔记</title>
    <url>/CNI-Chapter17-Notes/</url>
    <content><![CDATA[<p>《计算机网络与因特网》 第十七章笔记</p>
<span id="more"></span>
<h1 id="Chapter-17"><a href="#Chapter-17" class="headerlink" title="Chapter 17"></a>Chapter 17</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>这一章会介绍关于扩展LAN的方法，如中继器（Repeaters）和网桥（Bridges），也会介绍在网桥存在循环时解决死循环的<code>生成树算法(Spannning tree algorithms)</code>。最后会讨论交换机和网桥之间的关系。</p>
<h2 id="Distance-Limitation-And-LAN-Design"><a href="#Distance-Limitation-And-LAN-Design" class="headerlink" title="Distance Limitation And LAN Design"></a>Distance Limitation And LAN Design</h2><p>距离限制是LAN计算的核心，工程师们需要从最大延迟，信道容量和传输距离间做权衡。因为LAN中的硬件设备的发送功率是固定的，所以如果两个设备之间的电缆长度增加，其中的信号强度就会减弱，导致错误的发生。</p>
<h2 id="Fiber-Modem-Extensions"><a href="#Fiber-Modem-Extensions" class="headerlink" title="Fiber Modem Extensions"></a>Fiber Modem Extensions</h2><p>解决LAN距离的方法通常不是增加信号的强度也不是增加电缆，而是增加额外的硬件设备来转播信号。</p>
<p>最简单的LAN扩展方法是通过一根光纤和一堆光纤调制解调器，如下图所示：</p>
<p><img src="CNI-Chapter17-Notes/2020-01-03-08-27-17.png" alt="光纤调制解调器扩展"></p>
<p>一个光纤调制解调器与计算机设备连接，另一个光纤调制解调器与通向以太网的交换机或集线器连接，两个光纤调制解调器用光纤连接。这样计算机设备就能与以太网进行连接。</p>
<h2 id="Repeaters"><a href="#Repeaters" class="headerlink" title="Repeaters"></a>Repeaters</h2><p>中继器（Repeaters）是一个用来传播LAN信号的模拟设备，中继器并不理解包和Bit数据，它只是将接受到的信号放大再传播出去。</p>
<p>一个中继器的典型应用就是使用遥控器控制其他房间的设备，将中继器放置在另一个房间，在遥控器所在房间，将Sensor通过线缆与中继器相连。当本房间的Sensor搜到信号后，信号后传输给中继器，中继器放大后传播出去，另一个房间的设备就会收到，如下图所示：</p>
<p><img src="CNI-Chapter17-Notes/2020-01-03-08-35-01.png" alt=""></p>
<h2 id="Bridges-And-Bridging"><a href="#Bridges-And-Bridging" class="headerlink" title="Bridges And Bridging"></a>Bridges And Bridging</h2><p>网桥（Bridges）是连接两组LAN设备（如两个集线器）并且在它们之间传输包的方法。网桥是以混杂模式监听每组LAN设备，即数据发送给其下的任意一个设备，该数据都会被网桥检测到。因此，被网桥连接的两组设备表现如同是一组设备，即一组中的设备可以发送数据给另一组设备，且当一个设备广播时，两组设备中的所有设备都能接受到。而在网桥下的设备是无法区分自己是在一个单一的一组设备下（如只是在集线器下）还是在网桥下。</p>
<ul>
<li>这里将书中描述的Segment翻译为一组设备，如一个集线器下的设备。</li>
</ul>
<p>网桥连接的示意图如下：</p>
<p><img src="CNI-Chapter17-Notes/2020-01-03-09-14-18.png" alt=""></p>
<h2 id="Learning-Bridges-And-Frame-Filtering"><a href="#Learning-Bridges-And-Frame-Filtering" class="headerlink" title="Learning Bridges And Frame Filtering"></a>Learning Bridges And Frame Filtering</h2><p>虽然网桥是以混杂模式监听，且可以让两组设备表现的如同在同一组，但是网桥并不会盲目的将数据从一组设备传递给另一组。网桥监听到数据后会针对包的目标MAC地址过滤数据，仅将数据发送给需要的一组设备。当让，在广播或者多播模式下，网桥直接将数据发送给两个设备的，以保证广播或者多播的正常运行。</p>
<p>大多数网桥被称为自适应网桥（Adaptive/Learning Bridges），因为他们可以自动识别出每个设备是处于哪个分组下。当一个数据包经过网桥时，网桥会读取源地址，然后判断两组设备列表中是否有该发送设备，如果没有，则将发送设备放在符合的设备列表下。同时也会读取目标地址，决定数据需要发送给哪部分设备，如果目标地址在两组设备列表中都不存在，则两组设备都会收到网桥的转发的数据。</p>
<p>下表是发送网桥发送数据的例子。在第一行即网桥启动时，两组数据的列表都是空的。第二行即数据从A设备发送给B设备，此时先检测出将发送端A是在Segment1中，但此时B不在任何列表中，所以数据会发送给两个部分。第三行即数据从B设备发送给A设备，先检测出发送端B设备是再Segment1中，而A也在Segment1种，所以数据只要在Segment1中传输即可。同理可以分析其他的发送数据。</p>
<p><img src="CNI-Chapter17-Notes/2020-01-03-09-30-16.png" alt="网桥数据发送"></p>
<h2 id="Why-Bridging-Works-Well"><a href="#Why-Bridging-Works-Well" class="headerlink" title="Why Bridging Works Well"></a>Why Bridging Works Well</h2><p>当网桥知道其下的所有设备处于哪个部分后，数据在网桥之间的传输效率要大于数据在真正的单一分组中的传输。</p>
<p>以上节中的示意图为例，当网桥知道所有的设备处于哪个部分后，如果数据从A发送给B，那么数据只要在Segment1中传输，同理如果数据从X发送给Y，数据只要在Segment2中传输。因此，这两个传输行为是可以同时进行的，因为它们都只是发生在各自的部分中。而如果所有设备都是在一个真正的单一分组下，即A，B，X，Y是共享一个媒介传输，两个传输行为也就不可能同时发生。</p>
<p>因此可以将设备分组后，用网桥连接来增加数据传输的效率。</p>
<h2 id="Distributed-Spanning-Tree"><a href="#Distributed-Spanning-Tree" class="headerlink" title="Distributed Spanning Tree"></a>Distributed Spanning Tree</h2><p>如果一系列设备如下图所示连接（每个HUb下有多个设备，图中未展现）：</p>
<p><img src="CNI-Chapter17-Notes/2020-01-03-09-37-20.png" alt=""></p>
<p>可以看到图中的设备形成了一个循环，在这种情况下广播的数据会发生死循环。因为网桥收到广播数据后会直接向前传递，而在网桥形成循环后，每个网桥的直接向前传递就会导致信息始终在循环中传输。</p>
<p>为了解决这个问题，电子设备协会（Digital Equipment Corporation）在1985年为以太网设计了一个称为<code>生成树协议（Spannning Tree Protocol,STP）</code>的方法。STP方法是通过算法从一系列网桥STP计算出一个<code>分布生成树（Distributed Spanning Tree）</code>。协议规定如果将包的广播地址设为<code>01:80:C2:00:00:00</code>即表示使用STP方法。STP方法的步骤如下：</p>
<ol>
<li><p>先找到一个网桥作为根。</p>
<p>每个网桥都有一个ID地址，算法将ID最小的网桥作为根。</p>
<p>每个网桥的ID地址都由两部分组成，第一部分是16bit长的可配置优先级数字，第二部分是48bits长的MAC地址。当比较ID地址时，会首先判断第一部分，在第一部分相同的情况下判断第二部分。因为第一部分是可配置的，所以管理员是可以指定某一个网桥作为根的。</p>
</li>
<li><p>最短路径计算</p>
<p>每个网桥都计算自己与根网桥的最短路径。</p>
</li>
<li><p>传递数据</p>
<p>网桥之间的数据传递，只能由最短路径传输。</p>
</li>
</ol>
<p>在上图展示的循环中，如果Hub1广播数据，那么Hub4收到数据的通路就是$Hub1-&gt;Hub4$，而更长的路径，如$Hub1-&gt;Hub2-&gt;Hub3-&gt;Hub4$就会被禁止，因此更长的循环路径也同样会被禁止。</p>
<h2 id="Switching-And-Layer-2-switchers"><a href="#Switching-And-Layer-2-switchers" class="headerlink" title="Switching And Layer 2 switchers"></a>Switching And Layer 2 switchers</h2><p><code>桥接（bridging）</code>的概念可以帮助理解现代以太网的基础：<code>交换（switching）</code>。一个以太网交换机（Ethernet switch）有时也被称为二层交换机（Layer-2 switch）。交换机如同集线器一样，有多个接口，每个接口都与一个计算机相连。交换机和集线器的不同在于，集线器如模拟设备一样，是将电脑传输的信号传递出去，而交换机是数字设备，传递的是电脑的数据包。可以将集线器想象成一个共享媒介，而把交换器想象成一个由网桥连接的网络，其中每个部分都只有一台电脑。</p>
<p>交换机可以想象成如下图的结构，可以看到交换机的左侧是三个网桥，每个网桥连接两个设备：</p>
<p><img src="CNI-Chapter17-Notes/2020-01-03-10-22-38.png" alt=""></p>
<p>但上图只是一个概念图，实际中的交换机中并没有网桥，而是每个端口都于一个<code>智能接口（Intelligent Interface）</code>相连，然后有个中央光纤将所有的接口连接在一起，而且这光纤支持两两配对的接口间的同时传输（如之前提到的网桥连接的两部分间的设备可同时传输一样）。</p>
<p>每个智能接口都有处理器和内存，因此可以判断需要传递的路线以及在目标端口繁忙时缓存数据，如电脑1和电脑2同时要向电脑3传输数据，则电脑1或电脑2中的一台会先将要传输的数据缓存起来。实际的交换机结构如下：</p>
<p><img src="CNI-Chapter17-Notes/2020-01-03-10-27-51.png" alt=""></p>
<p>交换机相对于集线器最大的优点在于并行。集线器在同一时间只能支持一个传输，而交换机可以同时进行多个独立的传输（这里的独立指不会有多个来自于不同地址的数据要发送给同一端口）。因此如果一个交换机有$N$个端口，最多可以有$N/2$个传输同时进行。</p>
<h2 id="VLAN-Switchers"><a href="#VLAN-Switchers" class="headerlink" title="VLAN Switchers"></a>VLAN Switchers</h2><p>当一个交换机被扩展了虚拟功能，即称为虚拟局域网交换机（Virtual Local Area Network Switch,VLAN Switcher）。虚拟局域网交换机的功能就是让单一的交换机模拟成是多个独立的交换机，即管理者可以将一台交换机的其中某几个端口定义是在一个模拟局域网中，而另几个端口是在另外一个模拟局域网中，这样的话其中一个模拟局域网中的设备发送广播数据，另一个模拟局域网中的端口并不会接受到信息。</p>
<p>这种通过VLAN切分广播域的做法在公司环境下很关键，如一层楼只有一个交换机，但广播数据的发送并不希望整层楼都能收到。</p>
<h2 id="Multiple-Switchers-And-Shared-VLANs"><a href="#Multiple-Switchers-And-Shared-VLANs" class="headerlink" title="Multiple Switchers And Shared VLANs"></a>Multiple Switchers And Shared VLANs</h2><p>交换机通常被部署在离计算机较近的地方，如每层楼都有一个交换机。在公司环境下有种情况是同一个部门可能处于不同的楼层，那么同一个部门的网络在不同的交换机下。在有多个交换机的情况下，上节中提到的VLAN会遇到问题。当只有一个交换机时，根据端口号分好VLAN后，数据的传输指定端口号就能判断出数据应该处于哪个VLAN中。但如果有两台交换机，两台交换机的同一端口，如端口1，可能是在不同的VLAN下，因此光指定端口号是无法知道其到底在哪个VLAN。</p>
<p>为了在多个交换机中使用VLAN技术，IEEE扩展了以太网协议，记录在$802.1Q$中。该协议下，在以太网的数据包的头字段中，增加16bit长的数据表示VLAN Tag，表示需要传递给VLAN。在802.1Q协议下的以太网数据包如下图所示：</p>
<p><img src="CNI-Chapter17-Notes/2020-01-03-11-13-59.png" alt=""></p>
<p>即使是使用了多交换机的VLAN，$802.1Q$协议下的以太网数据包仅在交换机之间传输，而在交换机与电脑间传输的包仍然是普通以太网数据包，因为只有交换机才能解析$802.1Q$数据。使用$802.1Q$实现VLAN的交换机如下图所示</p>
<p><img src="CNI-Chapter17-Notes/2020-01-03-11-15-56.png" alt=""></p>
<p>以上图为例，如果图中的A，B，D，E共处于VLAN 17中，当A广播数据后，B会直接收到数据，然后交换机1会将$17$作为VLAN Tag插入到数据包头中，然后传递给交换机2，交换机2在收到数据后，取出其中的VLAN tag，并将包传递给D和E。</p>
<h2 id="The-importance-Of-Bridging"><a href="#The-importance-Of-Bridging" class="headerlink" title="The importance Of Bridging"></a>The importance Of Bridging</h2><p>虽然现在很少会有厂商生产单独的网桥，但是桥接的概念已经被整合入网络设备中。如无线网络的路由器就整合了提供桥接功能的以太网的交换器，通常将其中交换机的端口称为<code>本地端口（Local Port）</code>，将连接网络调制解调器的端口称为<code>因特网端口（Internet Port）</code>。当两个本地的电脑传输数据时，无线路由器并不会将数据发送给网络服务商，而是直接将数据在本地进行传输（类似于桥接的分组功能）。</p>
<div class="note info simple"><p>引用：</p>
<ol>
<li><em>Computer Networks and Internets</em> 6th</li>
</ol>
</div>
<hr>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《计算机网络与因特网》 第五章笔记</title>
    <url>/CNI-Chapter5-Notes/</url>
    <content><![CDATA[<p>《计算机网络与因特网》 第五章笔记。</p>
<p>这一章简单定义了数据通信的概念，给出了数据通信的概念模型，并简单介绍了其中的一些关键领域的概念。</p>
<span id="more"></span>
<h1 id="Chapter-5-Overview-Of-Data-Communications"><a href="#Chapter-5-Overview-Of-Data-Communications" class="headerlink" title="Chapter 5 Overview Of Data Communications"></a>Chapter 5 Overview Of Data Communications</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>这一章主要是分析通过物理媒介进行信息传递的方法，例如线，光和无线电波等。这些方式在一些细节上不同，但所有方法的基本原理是相通的。</p>
<p>这一章同样会阐述一些在理论上可行，但在实际中因为现实世界的物理限制无法实现的方法。</p>
<h2 id="The-Essence-Of-Data-Communications"><a href="#The-Essence-Of-Data-Communications" class="headerlink" title="The Essence Of Data Communications"></a>The Essence Of Data Communications</h2><p>数据通信是物理，数学和电气工程三个学科的混合领域。</p>
<ol>
<li>物理：信息的传输依赖于物理媒介</li>
<li>数学：信息需要数字化</li>
<li>电气工程：数据传输需要构建现实中的通信系统</li>
</ol>
<h2 id="Motivation-And-Scope-Of-The-Subject"><a href="#Motivation-And-Scope-Of-The-Subject" class="headerlink" title="Motivation And Scope Of The Subject"></a>Motivation And Scope Of The Subject</h2><p>在数据通信领域有三个重要的点，他们定义了数据通信的一些领域</p>
<ol>
<li><p>传输的数据可以是任意类型的</p>
<p>传输的数据并不一定是存储在计算机中的<code>bit</code>数据，也可以是从现实世界中获取的信息，如音频和视频。</p>
</li>
<li><p>数据的传输依赖于物理系统</p>
<p>数据是基于物理现象来传输的，例如电，电磁波。了解为什么这些物理现象可以被用来传输数据是很重要的。另外也需要理解物理系统的限制，因为这些限制引发的问题和这些问题如何被检测并解决。</p>
</li>
<li><p>多个来源的信息可以共享基础媒介来传输</p>
<p>媒介共享在计算机网络中是一个重要角色。了解哪些基础设施是可以被共享的，共享他们的优缺点，以及基于共享而设计的通信模型是很重要的。</p>
</li>
</ol>
<h2 id="The-Conceptual-Pieces-Of-A-Communications-System"><a href="#The-Conceptual-Pieces-Of-A-Communications-System" class="headerlink" title="The Conceptual Pieces Of A Communications System"></a>The Conceptual Pieces Of A Communications System</h2><p>每一个来源都需要一些方法来获取信息，调整信息为用于传播的模式，使用共享的物理媒介来传输信息。同时也需要一些方法从物理媒介中抽取出每条信息的目的地地址，并将信息传送给目标地址。整个过程如下图所示：</p>
<p><img src="CNI-Chapter5-Notes/2019-11-25-23-24-24.png" alt="数据通信简单模型"></p>
<p>上图是一个非常简化的模型，在实际操作中，在传输数据前，必须对数据进行数字化，也需要加入一些额外的信息防止错误发生。如果考虑到隐私，可能还需要进行加密。在使用共享媒介时，还要保证有方法可以分辨出每条信息且他们不会相互干扰。</p>
<p>为了解释数据通信的每个部分，工程师们制订了一个概念框架来说明通信系统中的每个小主题是如何联系在一起的，概念框架如下图所示：</p>
<p><img src="CNI-Chapter5-Notes/2019-11-25-23-28-26.png" alt="概念框架"></p>
<h2 id="The-Subtopics-Of-Data-Communications"><a href="#The-Subtopics-Of-Data-Communications" class="headerlink" title="The Subtopics Of Data Communications"></a>The Subtopics Of Data Communications</h2><p>上一节中的概念框架图中的每一部分都代表了数据通信中的一个小主题。这一节中简单介绍了图中的一些术语，之后的几章中会在对每一部分进行详细说。</p>
<ol>
<li><p><code>数据来源(Information Sources)</code>可以是模拟数据或者数字电路。这一部分的关键内容包括信号的特征（<code>振幅(Amplitude)</code>，<code>频率(Frequency)</code>，<code>相位(Phase)</code>），周期性与非周期性，以及模拟信息和数字信息的转换。</p>
</li>
<li><p><code>信源编码与解码(Source Encoder and Decoder)</code>。一旦信息被数字化后，信息就可以被转换，这一部分的关键内容包括数据压缩以及压缩后对于传输的影响</p>
</li>
<li><p><code>加密与解密(Encryptor and Decryptor)</code>。为了保护信息和保证其可信度，在信息传送前需要进行加密，在接收后需要解密。这一部分的关键内容包括密码学技术与算法。</p>
</li>
<li><p><code>信道编码与解码(Channel Encoder and Decoder)</code>。信道编码是用来检测也纠正传输错误。这一部分的关键内容包括检测和限制错误，以及实际应用的技术，如奇偶校验(parity checking)等。</p>
</li>
<li><p><code>复用与解复用(Multiplexor and Demultiplexor)</code>。复用是指让多个来源的信息结合在一起并保证可以使用同一个媒介传输的方式。这一部分的关键内容包括介绍同时复用以及分时复用的技术。</p>
</li>
<li><p><code>调制与解调(Modulator and Demodulator)</code>。调制是指让用电磁波传递信息的方式。这一部分的关键内容包括模拟信息与数字信息的调制方式，用来进行调制与解调的设备。</p>
</li>
<li></li>
<li><code>物理通道与传输(Physical Channel and Transmission)</code>。 这一部分的关键内容包括传输媒介与传输方式（如并行，串行），带宽，噪声，干扰，信道容量，</li>
</ol>
<div class="note info simple"><p>引用：</p>
<ol>
<li><em>Computer Networks and Internets</em> 6th</li>
</ol>
</div>
<hr>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《计算机网络与因特网》 第六章笔记</title>
    <url>/CNI-Chapter6-Notes/</url>
    <content><![CDATA[<p>《计算机网络与因特网》 第六章笔记。关于信源和信号的知识，包括信源的特征，模拟信号和数字信号的转换等</p>
<span id="more"></span>
<h1 id="Chapter-6-Information-Sources-And-Signals"><a href="#Chapter-6-Information-Sources-And-Signals" class="headerlink" title="Chapter 6 Information Sources And Signals"></a>Chapter 6 Information Sources And Signals</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>这一章讲解释<code>信源（Information Sources）</code>和携带信息的信号的特征。</p>
<h2 id="Information-Sources"><a href="#Information-Sources" class="headerlink" title="Information Sources"></a>Information Sources</h2><p>数据通信理论更关注于较低层次的通信系统，因此信源可以是任意来源，不仅仅是包括计算机上层的键盘，鼠标，摄像机，传感器等等也是信源。</p>
<h2 id="Analog-And-Digital-Signals"><a href="#Analog-And-Digital-Signals" class="headerlink" title="Analog And Digital Signals"></a>Analog And Digital Signals</h2><p>数据通信由两种信息组成，模拟信息或数字信息。模拟信号是由一个连续变化的函数构成，而数字信号则是跳跃变换的，在某个时间点会从一个强度突然跳跃至另一个强度。下图为模拟信号和数字信号的图解，左为模拟信号，右为数字信号：</p>
<p><img src="CNI-Chapter6-Notes/2019-11-28-09-30-33.png" alt="模拟信号与数字信号"></p>
<h2 id="Periodic-And-APeriodic-Signals"><a href="#Periodic-And-APeriodic-Signals" class="headerlink" title="Periodic And APeriodic Signals"></a>Periodic And APeriodic Signals</h2><p>信号也可分类为周期信号与非周期信号。周期信号顾名思义表示信号会重复出现，反之为非周期信号。下图为周期信号：</p>
<p><img src="CNI-Chapter6-Notes/2019-11-28-09-33-10.png" alt="周期信号"></p>
<h2 id="Sine-Waves-And-Signal-Characteristics"><a href="#Sine-Waves-And-Signal-Characteristics" class="headerlink" title="Sine Waves And Signal Characteristics"></a>Sine Waves And Signal Characteristics</h2><p>数据通信通常使用<code>Sin函数</code>来表示信号。之所以选择Sin函数，是因为许多自然界产生的信号强度与时间的函数都是Sin，如麦克风获取声音后的输出信号，电磁波的信号等。</p>
<p>Sin函数波的信号特性由四个部分组成：</p>
<ol>
<li>频率（Frequency）：单位时间（通常是秒）内震动出现的个数。单位为赫兹（Hertz,Hz）</li>
<li>波幅（Amplitude）：信号最强和最弱两处的差</li>
<li>相位（Phase）：Sin拨开始的地方与参考时间（一般是时间0）的偏移</li>
<li>波长（Wavelength）：一个周期的波在传播媒介中要传播的距离。</li>
</ol>
<p>其中波长是一个媒介相关的特性，与波在媒介中传播的速度相关。剩下的三个特性都可以用数学公式表示，如波$A\sin (\omega t+\phi)$，其中$A$表示波幅，$\phi$表示相位，$\omega$表示频率，当$\omega=2\pi$时表示频率为1。</p>
<p>数据通信用的波一般都是高频的，一秒内出现百万个循环，对于这种频率的波，通常用兆赫兹（Megahertz,MHz）来表示。高频率波的单位如下表显示：</p>
<p><img src="CNI-Chapter6-Notes/2019-11-28-09-53-47.png" alt="频率单位"></p>
<h2 id="Composite-Signals"><a href="#Composite-Signals" class="headerlink" title="Composite Signals"></a>Composite Signals</h2><p>之前图中的波称为<code>简单信号(Simple Signal)</code>，因为只是以单一的Sin波组成。但在实际中，多数信号都是以<code>组合信号（Composite Signal）</code>的形式出现。如下图所示，就是两个不同频率及振幅的波组合成一个新的波。</p>
<p><img src="CNI-Chapter6-Notes/2019-11-28-09-57-46.png" alt="组合波"></p>
<h2 id="The-Importance-of-Composite-Signals-And-Sine-Functions"><a href="#The-Importance-of-Composite-Signals-And-Sine-Functions" class="headerlink" title="The Importance of Composite Signals And Sine Functions"></a>The Importance of Composite Signals And Sine Functions</h2><p><code>调制（Modulation）</code>出来的信号通常是组合信号。数学家<code>傅里叶(Fourier)</code>发现可以从组合信号中解析出他的组成部分，即简单信号。大部分的通信系统都是用组合信号来携带信息，在接收端再将信息拆分成简单信号。</p>
<h2 id="Time-And-Frequency-Domain-Representations"><a href="#Time-And-Frequency-Domain-Representations" class="headerlink" title="Time And Frequency Domain Representations"></a>Time And Frequency Domain Representations</h2><p>之前的所有信号波的图片的$X轴$都是时间，称为信号在<code>时域(Time Domain)</code>内表示。</p>
<p>还有一种表现方式是信号在<code>频域(Frequency Domain)</code>内的表示，如之前$\sin (2\pi t)$和$0.5\times \sin(2\pi 2 t)$组成的复合信号，也用下图在频域中表示：</p>
<p><img src="CNI-Chapter6-Notes/2019-11-28-10-29-27.png" alt="频域表示"></p>
<p>图中的$x轴$为频率，$y$轴仍为波幅。可以看到在频率为$1$和$2$的地方有波形出现，正好对应函数$\sin (2\pi t)$和$0.5\times \sin(2\pi 2 t)$的频率，波形的振幅也与函数所表现的振幅相同。</p>
<p>因为每个简单波在频域图的$x$轴上只占据一点，所以频域图用来表示复合波形是简单易读的。</p>
<h2 id="Bandwidth-Of-An-Analog-Signal"><a href="#Bandwidth-Of-An-Analog-Signal" class="headerlink" title="Bandwidth Of An Analog Signal"></a>Bandwidth Of An Analog Signal</h2><p>在计算机网络中经常听到<code>网络带宽(Network Bandwidth)</code>一词，关于网络带宽会在之后的章节中解释，这里先介绍一个相关概念，<code>模拟带宽(Analog Bandwidth)</code>。一个模拟信号的带宽是这个信号最高频率与最低频率之间的差，单位为$Hz$。如一个信号的频域图如下图所示，那么这个信号的贷款为$4KHz$，因为这个信号的最高频率为$5KHz$，最低频率为$1KHz$。</p>
<p><img src="CNI-Chapter6-Notes/2019-11-28-10-39-12.png" alt="模拟带宽"></p>
<p>如果一个信号是用频域图来表示的，那么可以很快的看出这个信号的带宽。</p>
<h2 id="Digital-Signals-And-Signal-Levels"><a href="#Digital-Signals-And-Signal-Levels" class="headerlink" title="Digital Signals And Signal Levels"></a>Digital Signals And Signal Levels</h2><p>数字信号是由一系列的固定的<code>有效电平（Valid Level）</code>组成且在任意的时间点信号都处于这些有效电平之一。</p>
<p>一些系统用电压来表示数字信号，如电压为$5V$表示信号1，电压为$0V$表示信号0，如下图所示：</p>
<p><img src="CNI-Chapter6-Notes/2019-11-28-10-55-33.png" alt="电压信号1"></p>
<p>如果将电压划分更细，如电压$5V$表示信号$11$，电压$2V$表示$10$，电压$-2V$表示$01$，电压$-5V$表示$00$，如下图所示：</p>
<p><img src="CNI-Chapter6-Notes/2019-11-28-10-57-06.png" alt="电压信号2"></p>
<p>可以看到传输相同数据(8 bit)的情况下，第二种方法花费的时间少了一半，称第二种方法的<code>数据速率（Data Rate）</code>翻倍。因为第一种方法一次只能表示1bit的数据（1或0），而第二种方法表示了2bit的数据。如果电压细分为$2^n$种，则一次性能表达$n$ bit的数据。</p>
<p>理论上可以将电压切分到非常小（如分割成一百万个电平等级）达到每次都能传递许多信息的目的，但是实际中因为电力系统并不能区分过小的电压间隔，所以只将电压分割为几个电平等级。</p>
<h2 id="Baud-And-Bits-Per-Second"><a href="#Baud-And-Bits-Per-Second" class="headerlink" title="Baud And Bits Per Second"></a>Baud And Bits Per Second</h2><p>数据速率有两方面决定，一方面是上一节中提到的信号有效电平数量（决定每次可以携带多少数据），另一方面是每个有效电平持续的时间。</p>
<p>如上一节中的例子，假设将1秒切分为8部分（即一秒电平可以变换8次）传递数据，一共有2个电平等级。那么一秒传递8 bit的数据。如果改为有4个电平等级，则每次能传递2个bit,一秒传递16 bit的数据。如果仍然保持两个电平等级，但将一秒切分为16个部分，则同样一秒传递16 bit的数据。</p>
<p>将一秒电平可以变换的次数用波特表示(Baud)，波特数越高则一个电平持续的时间越短，如给每个电平0.001的持续时间，那么这个系统工作在1000 Baud。理论上来说波特可以非常高，让每秒传递的数据增多，但是实际上当一个信号持续时间过短系统是无法检测到该信号的。每秒传递的数据量可用以下公式表示:</p>
<script type="math/tex; mode=display">
\text{bits per second} = baud \times \lfloor \log_2{(levels)} \rfloor</script><h2 id="Converting-A-Digital-Signal-To-Analog"><a href="#Converting-A-Digital-Signal-To-Analog" class="headerlink" title="Converting A Digital Signal To Analog"></a>Converting A Digital Signal To Analog</h2><p>根据傅里叶定理，任意的波形都可以由一系列Sin波组成，其中每个Sin波都有各自的振幅，相位与频率。</p>
<p>数字信号也可以看作是一个跃变的波形，但是这样的跃变波形需要由无数个Sin波才能构成，所以从工程角度来说不可能实现，毕竟不可能找出无数个信源。</p>
<p>所以在实际运用中只能妥协，运用越多的Sin波形，最终的复合波形就越接近跃变波形。下图展示了用模拟信号来表示数字信号的过程，图（a）是数字信号，显示为跃变波形，图（b）是用一个Sin波来表示，图（C）是两个Sin波，图（d）是用三个Sin波。可以看到Sin波的数量越多，波形越接近跃变信号，而且新增的波的频率越来越高。</p>
<p>一般而言，用三个Sin波模拟即可。</p>
<p><img src="CNI-Chapter6-Notes/2019-11-28-13-45-45.png" alt="数字电路转模拟电路"></p>
<h2 id="The-Bandwidth-Of-A-Digital-Signal"><a href="#The-Bandwidth-Of-A-Digital-Signal" class="headerlink" title="The Bandwidth Of A Digital Signal"></a>The Bandwidth Of A Digital Signal</h2><p>如之前所述，求一个信号的带宽是求其最大频率和最小频率的差值。对于数字信号来说可以先将他转换为模拟信号（多个Sin信号），然后找出最高频率的Sin以及最低频率的Sin。但是如上节所述，数字信号的跃变波形是由无数的Sin组成，且Sin的频率越来越高，即数字信号的最高频率是无限，因此数字信号的带宽为无限。</p>
<h2 id="Synchronization-And-Agreement-About-Signals"><a href="#Synchronization-And-Agreement-About-Signals" class="headerlink" title="Synchronization And Agreement About Signals"></a>Synchronization And Agreement About Signals</h2><p>在实际运用中，发送端和接收端必须保证信号的每次变换间隔是一样的（可看作采样频率），这个问题称为<code>同步问题（Synchronization）</code>，下图展示了发送端和接收端以不同的频率采样会引发的问题，接收端的采样频率（10次每秒）高于发送端（8次每秒）。</p>
<p><img src="CNI-Chapter6-Notes/2019-11-28-13-57-49.png" alt="采样错误"></p>
<p>在实际运用中，这种频率的差异可能非常小，如误差为$10_{-8}$秒，那可能出现了几百万个Bit后才发生一次错误。但在传输速率在亿个Bit每秒时，这种细微的差距也会引发大量的错误数据。</p>
<h2 id="Line-Coding"><a href="#Line-Coding" class="headerlink" title="Line Coding"></a>Line Coding</h2><p>如上节所述，在数据传递的过程中可能会因为同步问题导致一些错误的发生，有一些方法来帮助避免这些错误的发生。一种是真正发送信号前，先发送一系列的特定模式的字节，如重复的0或者重复的1，通过这些字节来帮助接收端校准，另一种方法称为<code>信道编码（Line Coding）</code>，在这种方式下会添加一些额外的字符来保证接收端能确切的解析出真实的数据。</p>
<p>如一个电路能产生5V，0，-5V的电压，可以将-5V定义为一个数据的开始。因此0信号表示为$-5V,0V$，1信号表示为$-5V,5V$。接收端知道在-5V信号后才是真正的数据。这种方式的图解如下：</p>
<p><img src="CNI-Chapter6-Notes/2019-11-28-14-26-48.png" alt="信道编码例子"></p>
<p>因为信道编码引入了额外的数据来保证真实数据的准确性，所以信道编码降低了真实数据的传输速率。</p>
<h2 id="Manchester-Encoding-Used-In-Computer-Networks"><a href="#Manchester-Encoding-Used-In-Computer-Networks" class="headerlink" title="Manchester Encoding Used In Computer Networks"></a>Manchester Encoding Used In Computer Networks</h2><p><code>曼彻斯特编码(Manchester Encoding)</code>是一种信道编码，在计算机网络中曼彻斯特编码主要用于以太网中，所以十分重要。</p>
<p>对电路来说，检测信号的变化比检测信号的强度要简单。因此曼彻斯特编码将1信号定义为从零电压跳转为正电压，将0信号定义为从正电压跳转为零电压。而且曼彻斯特采样的时间为时间周期的中间，因此可以对于连续0或者连续1的情况，信号有时间可以回到之前的电压水平，保证下一次的检测正常。曼彻斯特编码的图示如下：</p>
<p><img src="CNI-Chapter6-Notes/2019-11-28-14-44-39.png" alt="曼彻斯特编码"></p>
<p>曼彻斯特编码还有一个变化，叫做<code>差分曼彻斯特编码（Differential Manchester Encoding）</code>，这种方法用相对变化来表示信号，0信号表示信号发生了变化，1信号表示信号没有变化。采样时间为时间周期点。差分曼彻斯特编码如下图所示：</p>
<p><img src="CNI-Chapter6-Notes/2019-11-28-14-48-53.png" alt="差分曼彻斯特编码"></p>
<p>差分曼彻斯特编码的好处在于，即使信号的大小意外的翻转了也不会发生错误（如5V变为-5V之类）。</p>
<h2 id="Converting-An-Analog-Signal-To-Digital"><a href="#Converting-An-Analog-Signal-To-Digital" class="headerlink" title="Converting An Analog Signal To Digital"></a>Converting An Analog Signal To Digital</h2><p>模拟信号为了进一步的被处理，必须转换为数字信号。一般转换为数字信号有两种方式,一是<code>脉冲编码调制(Pulse Code Modulation，PCM)</code>，另一种是<code>差分调制(Delta modulation)</code></p>
<p>脉冲编码调制是以相同时间间隔去测量模拟信号，并根据模拟信号的强度，将其转换为数字信号，整个流程分为三步，如下图框出的部分所示：</p>
<p><img src="CNI-Chapter6-Notes/2019-11-30-21-29-15.png" alt="脉冲编码调制"></p>
<p>以相同时间间隔去测量模拟信号，即为采样，所以上图中的第一部分称为采样。有的时候为了避免采样时间点的信号突变导致的采样失真，会在相关时间点附近多采样几次，然后取平均值作为最后采样值。第二部分称为量化（Quantization），量化是根据模拟信号的强度，将其转换为一个Int值，如下图所示，第一个采样的数值，会被量化为2，第二个采样的数值会被量化为3，第三个采样的数值会被量化为6。</p>
<p><img src="CNI-Chapter6-Notes/2019-11-30-21-34-25.png" alt="量化"></p>
<p>量化后的数据会被进一步编码为之后需要的数据格式（根据需求而定）。</p>
<p>差分调制的主题思想与脉冲编码调制类似，不同的是在量化阶段他不是对每个采样值进行量化，而是对当前采样值与上一个采样值的差距进行量化。这样节省了许多用来表示数据的Bit数，但是缺点在于一旦之前的数据出现了误差，后面的所有数据都会收到影响。</p>
<h2 id="The-Nyquist-Theorem-And-Sampling-Rate"><a href="#The-Nyquist-Theorem-And-Sampling-Rate" class="headerlink" title="The Nyquist Theorem And Sampling Rate"></a>The Nyquist Theorem And Sampling Rate</h2><p>应该以怎样的采样频率进行采样是数据通信中需要考虑的问题，如果采样频率过低，那么采样出来的信号与原信号可能有较大差异，如果采样频率过高，则会产生大量的数据。</p>
<p>奈奎斯特（Nyquist Theorem）定理提出：为了避免采样失真，采样的最低频率应该是原信号最高频率的两倍。</p>
<h2 id="Nyquist-Theorem-And-Telephone-System-Transmission"><a href="#Nyquist-Theorem-And-Telephone-System-Transmission" class="headerlink" title="Nyquist Theorem And Telephone System Transmission"></a>Nyquist Theorem And Telephone System Transmission</h2><p>经过实验，0到4000HZ的频率基本就能提供人所能接受的音频质量。因此根据奈奎斯特频率，语音信号的采样频率应该是8000HZ，既一秒有8000个采样点。通话系统所用的PCM标准规定，每个采样信号用8-bit数据表示，所以每秒通话产生的数据量为：</p>
<script type="math/tex; mode=display">
8000 \frac{samples}{second} \times 8 \frac{bits}{sample} = 64000 \frac{bits}{second}</script><p>因此电话系统每秒传递64000-bits数据（64Kbps），也可见采样频率越高，可携带的数据也就越多。</p>
<h2 id="Nonlinear-Encoding"><a href="#Nonlinear-Encoding" class="headerlink" title="Nonlinear Encoding"></a>Nonlinear Encoding</h2><p>当每个采样点只能用8个比特来表示时，线性的PCM编码无法很好的体现声音，因为8个Bit只能表现256个值，且线性表示的话，无论是非常低频或高频的部分还是人身大部分集中的部分都用了一样的采样间隔，这造成了浪费。而非线性编码，解决了这个问题，他更关注与人耳最敏感的频率。数字电话标准中有两种非线性编码：</p>
<ol>
<li>$\alpha-law$，主要是欧洲及中国采用的编码方式</li>
<li>$\mu-law$，主要是北美和日韩采用的编码方式</li>
</ol>
<p>$\mu-law$算法的主要优势在于它覆盖了更广的频率范围（例如可以更好的还原特别高的声音），缺点在于对于一些弱信号有更多的失真。$\alpha-law$在弱信号的失真上有优势，但动态范围更小。</p>
<p>对于国际电话，需要有$\alpha-law$和$\mu-law$之间的转化。</p>
<h2 id="Encoding-And-Data-Compression"><a href="#Encoding-And-Data-Compression" class="headerlink" title="Encoding And Data Compression"></a>Encoding And Data Compression</h2><p><code>数据压缩(Data Compression)</code>是用来减少用来表达数据的bit数的方法。对于数据通信来说，通常在传输前对数据进行压缩。压缩分为两种类型：<code>有损压缩(Lossy)</code>和<code>无损压缩(Lossless)</code>。</p>
<p>有损压缩则通常用来压缩一些人相关的文件，如图片，视频，音频，这种压缩方式会忽视掉一些人无法精确识别的数据，<code>JPEG</code>和<code>MPEG-3(MP3)</code>都是典型的有损压缩。</p>
<p>无损压缩保证压缩后的数据在解压后与原数据相同，一般用于压缩文档之类的文件。大部分的无损压缩都用了字典技术，即如果一个字符串在文件中重复的出现，将这个字符串存放在字典中，之后的出现只要取字典中的索引值即可。</p>
<div class="note info simple"><p>引用：</p>
<ol>
<li><em>Computer Networks and Internets</em> 6th</li>
</ol>
</div>
<hr>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《计算机网络与因特网》 第八章笔记</title>
    <url>/CNI-Chapter8-Notes/</url>
    <content><![CDATA[<p>《计算机网络与因特网》 第八章笔记。</p>
<p>给出了可能出现的错误，以及控制错误的信道编码方法，包括检测错误和修复错误。</p>
<span id="more"></span>
<h1 id="Chapter-8-Reliability-And-Channel-Coding"><a href="#Chapter-8-Reliability-And-Channel-Coding" class="headerlink" title="Chapter 8 Reliability And Channel Coding"></a>Chapter 8 Reliability And Channel Coding</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>这一章介绍在通信过程中会出现的错误，以及控制错误的技术。</p>
<p>其中的一部分也被纳入了因特网的协议中，这也会在本章中介绍。</p>
<h2 id="The-Three-Main-Sources-Of-Transmission-Errors"><a href="#The-Three-Main-Sources-Of-Transmission-Errors" class="headerlink" title="The Three Main Sources Of Transmission Errors"></a>The Three Main Sources Of Transmission Errors</h2><p>传输中发生的错误可以分为三大类：</p>
<ol>
<li>干扰（Interference）：如第七章所述，环境中存在许多电磁干扰，这些电磁干扰会阻碍无线电传输和线缆中的信号传输。</li>
<li>失真（Distortion）：所有的物理系统都会造成信号的失真。光纤中的光因为移动距离的增加，时域会发生扩张（频域也因此变化）。信道容量会导致一些频率的信号被过滤掉。放在线缆旁边的金属可能会改变线缆内信号的频率，金属也能干扰无线电信号。</li>
<li>衰弱（Attenuation）：信号在媒介中传输的过程中，信号会逐渐衰弱。</li>
</ol>
<p>香农定理给出了介绍错误的思路：提高信噪比。</p>
<p>但无论如何噪声不可能被完全的消除，所以许多方法致力于检测错误，在某些情况下自动修复错误。</p>
<p>但是错误的监测机制无疑是会为系统增加开销的，因此系统设计时要考虑在错误影响与错误检测开销间做权衡，如金融系统，1bit的错误可能会造成很严重的错误，但是在图片中1bit的错误可能根本无法被识别到。</p>
<h2 id="Effect-Of-Transmission-Errors-On-Data"><a href="#Effect-Of-Transmission-Errors-On-Data" class="headerlink" title="Effect Of Transmission Errors On Data"></a>Effect Of Transmission Errors On Data</h2><p>这里要区分传输错误与数据错误，数据是由传输信号在经过例如解码，解调后得到的。传输错误最后都会导致最后的数据出错。主要有三类传输造成的数据错误：</p>
<ol>
<li>单元位错误（Single Bit Error）：即一系列数据中，只有一位数据被改变了。这通常是因为传输信号的短时间（称为脉冲，Spike）干扰造成的。</li>
<li><p>突发性错误：一系列数据中有多位数据被改变，通常是由长时间的干扰造成的。错误长度是由错误开始位到错误结束位直接的位数决定。如下表，错误的数据由加粗表示，错误长度是7：</p>
<p>| 发送 | 1   | 0   | 1     | 1   | 0     | 0   | 0     | 1     | 0     | 1   | 1   |<br>| —— | —- | —- | ——- | —- | ——- | —- | ——- | ——- | ——- | —- | —- |<br>| 接收 | 1   | 0   | <strong>0</strong> | 1   | <strong>1</strong> | 0   | <strong>1</strong> | <strong>0</strong> | <strong>1</strong> | 1   | 1   |</p>
</li>
</ol>
<h2 id="Two-Strategies-For-Handling-Channel-Errors"><a href="#Two-Strategies-For-Handling-Channel-Errors" class="headerlink" title="Two Strategies For Handling Channel Errors"></a>Two Strategies For Handling Channel Errors</h2><p>有一系列的方法解决数据错误并增加数据的可靠性，这些方法统称为<code>信道编码(Channel Coding)</code>，这些方法可以被分为两类：<code>前向错误纠正技术（Forward Error Correction，FEC）</code>，<code>自动重传请求技术（Automatic Repeat reQuest，ARQ）</code>。</p>
<p>前向错误纠正技术的主题思想是在发送的数据中增加额外的信息，接收端可以根据这些额外信息来判断是否有错误发生，有些方法可以检测出究竟是哪一位数据发生了错误，并在可能的情况下纠正错误。</p>
<p>自动重传请求技术是让接收端和发送端互换数据来保证数据被正确的传递。</p>
<h2 id="Block-And-Convolutional-Error-Codes"><a href="#Block-And-Convolutional-Error-Codes" class="headerlink" title="Block And Convolutional Error Codes"></a>Block And Convolutional Error Codes</h2><p>前向错误纠正技术可以再细分为两类：</p>
<ol>
<li>分组错误码（Block Error Codes）：分组错误码是将数据分成一块块的，然后对每一块都增加额外信息。每一块的额外信息只针对于该块数据本身。</li>
<li>卷积错误码（Convolutional Error Codes）：卷积错误码是将数据看作一系列bits，增加的额外信息是由当前的bit和之前的bit共同决定的。</li>
</ol>
<p>卷积错误码相对于分组错误码需要更多的计算，但是也更能检测出错误。</p>
<h2 id="An-Example-Block-Error-Code：Single-Parity-Checking"><a href="#An-Example-Block-Error-Code：Single-Parity-Checking" class="headerlink" title="An Example Block Error Code：Single Parity Checking"></a>An Example Block Error Code：Single Parity Checking</h2><p>单一奇偶校验检查（Single Parity Checking）是分组错误码检测的一个例子，可以再分为偶校验检查和奇校验检查。如果将数据分为$n$ bit一组，那么每一组增加一位数据，当是偶校验时，$n$位数据+1位额外数据应该一共有偶数个1，当是奇校验时，$n$位数据+1位额外数据应该一共有奇数个1。下表为8位数据时的例子：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>原始数据</th>
<th>偶校验</th>
<th>奇校验</th>
</tr>
</thead>
<tbody>
<tr>
<td>00000000</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>01011011</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>01010101</td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p>单一奇偶校验是一个比较弱的信道编码，他只能检测错误，但无法检测出错误具体出现在哪一位，也无法纠正错误。而且当有偶数个位发生错误时，错误就无法被检测出来。</p>
<h2 id="The-Methematics-of-Block-Error-Codes-And-n-k-Notation"><a href="#The-Methematics-of-Block-Error-Codes-And-n-k-Notation" class="headerlink" title="The Methematics of Block Error Codes And (n,k) Notation"></a>The Methematics of Block Error Codes And (n,k) Notation</h2><p>如有$k$位bit的数据，我们将所有$2^k$种可能出现的数据称为<code>数据字(Datawords)</code>，在这些数据中增加$r$位额外数据，一共有$n=k+r$个数据，所有$2^n$种可能称为<code>编码字(codeworks)</code>，其中编码字中合法的部分，即额外添加的数据与原数据时符合规则的部分，称为<code>码书(Codebook)</code>，并将这种方法标记为$(n,k)$</p>
<p>如单一奇偶校验中,$k=8,r=1$，因此一共有256个数据字，也对应了有256个合法的编码字，一共有512个编码字。</p>
<p>在理想状态下，合法编码字中的任一一位被改变了，改变后的编码字就不是合法编码字。但是在单一奇偶校验的例子中，如果同时改变了合法编码字中的两位，那么结果仍然是一个合法编码字。</p>
<p>没有一个信道编码可以达到理想状态，所以要考虑的就是，合法编码字最少多少位数据要被同时改变，才能产生另一个合法编码字。在单一数字编码中，这个位数为2。</p>
<h2 id="Hamming-Distance：A-Measure-Of-A-Code’s-Strength"><a href="#Hamming-Distance：A-Measure-Of-A-Code’s-Strength" class="headerlink" title="Hamming Distance：A Measure Of A Code’s Strength"></a>Hamming Distance：A Measure Of A Code’s Strength</h2><p>汉明距离（Hamming Distance）是用来测量一个合法编码字要转换为另一个合法编码字最少要改变的数据位数的方法中需要用到的概念。如果给定两个$n$长度的字符，两个字符的汉明距离就是两个字符间不同的数据数量。</p>
<p>如$d(000,001)=1,d(000,101)=2,d(000,111)=3,d(101,001)=1$。</p>
<p>可以先对两个字符求异或，然后计算异或出来的字符1的总数，即为汉明距离。</p>
<h2 id="The-Hamming-Distance-Among-String-In-A-Codebook"><a href="#The-Hamming-Distance-Among-String-In-A-Codebook" class="headerlink" title="The Hamming Distance Among String In A Codebook"></a>The Hamming Distance Among String In A Codebook</h2><p>为了计算出一个合法编码字要转换为另一个合法编码字最少要改变的数据位数，先要计算出码书中所有编码字组合的汉明距离。如对2位bit数据进行单一奇校验检测：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>数据字</th>
<th>编码字</th>
</tr>
</thead>
<tbody>
<tr>
<td>00</td>
<td>001</td>
</tr>
<tr>
<td>01</td>
<td>010</td>
</tr>
<tr>
<td>10</td>
<td>100</td>
</tr>
<tr>
<td>11</td>
<td>111</td>
</tr>
</tbody>
</table>
</div>
<p>一共有4个编码字，4个编码字一一配对一共有6种可能，$d(001,010)=2,d(010,100)=2,d(001,100)=2,d(010,111)=2,d(001,111)=2,d(100,111)=2$。6种可能中最小的汉明距离是2，所以最少需要更改2位数据才能从一个合法编码字变为另一个合法编码字。</p>
<p>因此计算从一个合法编码字转换为另一个合法编码字最少要改变的数据位数过程是，计算出所有码书中的编码字（即合法编码字）两两配对后的所有汉明距离$d_{min}$，其中的最小值即为所求值。</p>
<h2 id="The-Tradeoff-Between-Error-Detection-And-Overhead"><a href="#The-Tradeoff-Between-Error-Detection-And-Overhead" class="headerlink" title="The Tradeoff Between Error Detection And Overhead"></a>The Tradeoff Between Error Detection And Overhead</h2><p>对于一个编码，最多的能被检测出来的错误位数为$e=d<em>{min}-1$，如单一奇偶校验，因为$d</em>{min}=2$，所以最多能正确检测出来的错误位数为1。</p>
<p>虽然$d_{min}$越大能检测出来的错误位数越多，但这也意味着要增加更多的额外数据，对于$(n,k)$的编码，工程师用编码率（Code Rate）$R=\frac{k}{n}$来表示为了检测出错误信息的编码开销。</p>
<h2 id="Error-Correction-With-Row-And-Column-RAC-Parity"><a href="#Error-Correction-With-Row-And-Column-RAC-Parity" class="headerlink" title="Error Correction With Row And Column(RAC) Parity"></a>Error Correction With Row And Column(RAC) Parity</h2><p>奇偶校验本身是不能进行错误纠正的，但是通过<code>行列奇偶校验（Row And Column Parity）</code>就可以做到。如一共有12个bit的原始数据，即$k=12$，排成三行四列每一列每一行都进行奇偶校验，增加一个额外位，则一共8个额外位，即$r=8，n=k+r=20$，因此这是一个$(20,12)$的编码，如下图所示：</p>
<p><img src="CNI-Chapter8-Notes/2019-12-05-14-46-47.png" alt="行列奇偶校验"></p>
<p>因此如果一位数据出错，会同时在对应的行和列校验位感知到，因此就可以定位到错误的数据，取反后就能纠正数据。</p>
<p>奇偶校验数据的$d_{min}$还是2，因此如果错误的位数大于1，当是偶数时无法被检测到，当是奇数时虽然能检测出错误，但无法纠正。</p>
<h2 id="The-16-Bit-Checksum-Used-In-The-Internet"><a href="#The-16-Bit-Checksum-Used-In-The-Internet" class="headerlink" title="The 16-Bit Checksum Used In The Internet"></a>The 16-Bit Checksum Used In The Internet</h2><p>有个称为<code>因特网校验和（Internet checksum）</code>的信道编码方法在网络中扮演了重要角色。这个算法的输入可以是任意长度，将输入拆分为一段段16字节的的部分，如果不能长度不能被16整除，则最后补0。如下图所示：</p>
<p><img src="CNI-Chapter8-Notes/2019-12-06-17-25-08.png" alt="拆分为16字节"></p>
<p>算法的流程如下：</p>
<ol>
<li>将输入拆分为以16-bit为一组</li>
<li>定义一个32-bit的变量（这里称为$C$）作为结果。</li>
<li>将每一组16-bit的数据累加给$C$</li>
<li>将$C$的前16位累加给后16位</li>
<li>将$C$的后16位取反，如果取反后全是0，则将其改为全是1</li>
<li>此时$C$的16位即为校验和。</li>
</ol>
<p>可以看出最后的校验和也是16位的数据，将校验和作为新的一组16-bit放在原数据后（经过了补0的原数据）发送出去。接收端接受信息后重复算法流程，如果数据没有发生错误，最后接收端计算出的校验和应该是FFFF。</p>
<p>下面以两个例子进行说明：</p>
<ol>
<li><p>例子1<br>如果发送端输入数据为<code>0100 1000 0110 0101</code>，<code>0110 1100 0110 1100</code>，<code>0110 1111 0010 0001</code>，计算过程如下：</p>
 <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">   0100 1000 0110 0101</span><br><span class="line">   0110 1100 0110 1100</span><br><span class="line">+  0110 1111 0010 0001</span><br><span class="line">----------------------------</span><br><span class="line">1  0010 0011 1111 0010</span><br></pre></td></tr></table></figure>
<p> 将高16位移到后16位</p>
 <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">  0010 0011 1111 0010</span><br><span class="line">+                   1</span><br><span class="line">-------------------------</span><br><span class="line">  0010 0011 1111 0011 </span><br></pre></td></tr></table></figure>
<p> 取反后得到：</p>
 <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1101 1100 0000 1100</span><br></pre></td></tr></table></figure>
<p> 这即为校验和</p>
<p> 对于接收端，因为将校验和也一并发送了过去，所以接收端的计算过程如下：</p>
 <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">   0100 1000 0110 0101</span><br><span class="line">   0110 1100 0110 1100</span><br><span class="line">   0110 1111 0010 0001</span><br><span class="line">+  1101 1100 0000 1100</span><br><span class="line">----------------------------</span><br><span class="line">1  1111 1111 1111 1110</span><br></pre></td></tr></table></figure>
<p> 将高16位移到后16位</p>
 <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">  1111 1111 1111 1110</span><br><span class="line">+                   1</span><br><span class="line">-------------------------</span><br><span class="line">  1111 1111 1111 1111 </span><br></pre></td></tr></table></figure>
<p> 取反后得到：</p>
 <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">0000 0000 0000 0000</span><br></pre></td></tr></table></figure>
<p> 因为全为0，所以改为全为1</p>
 <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1111 1111 1111 1111</span><br></pre></td></tr></table></figure>
</li>
<li><p>例子2<br> 如果发送端输入数据为<code>1111 1111 1111 1111</code>，<code>1111 1111 1111 1111</code>，<code>0000 0000 0000 0001</code>，计算过程如下：</p>
 <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">   1111 1111 1111 1111</span><br><span class="line">   1111 1111 1111 1111</span><br><span class="line">+  0000 0000 0000 0001</span><br><span class="line">----------------------------</span><br><span class="line">1  1111 1111 1111 1111</span><br></pre></td></tr></table></figure>
<p> 将高16位移到后16位</p>
 <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">  1111 1111 1111 1111</span><br><span class="line">+                   1</span><br><span class="line">-------------------------</span><br><span class="line">1 0000 0000 0000 0000 </span><br></pre></td></tr></table></figure>
<p> 此时虽然高16仍然有数值，但不需要再次累加，后16位取反后得到：</p>
 <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1111 1111 1111 11111</span><br></pre></td></tr></table></figure>
<p> 这即为校验和</p>
<p> 对于接收端，因为将校验和也一并发送了过去，所以接收端的计算过程如下：</p>
 <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">   1111 1111 1111 1111</span><br><span class="line">   1111 1111 1111 1111</span><br><span class="line">   0000 0000 0000 0001</span><br><span class="line">+  1111 1111 1111 1111</span><br><span class="line">----------------------------</span><br><span class="line">10 1111 1111 1111 1110</span><br></pre></td></tr></table></figure>
<p> 将高16位移到后16位</p>
 <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">  1111 1111 1111 1110</span><br><span class="line">+                  10</span><br><span class="line">-------------------------</span><br><span class="line">1 0000 0000 0000 0000 </span><br></pre></td></tr></table></figure>
<p> 取反后得到：</p>
 <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1111 1111 1111 1111</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Cyclic-Redundancy-Codes-CRCs"><a href="#Cyclic-Redundancy-Codes-CRCs" class="headerlink" title="Cyclic Redundancy Codes(CRCs)"></a>Cyclic Redundancy Codes(CRCs)</h2><p>在高速网络中，有一个称为<code>循环冗余码(Cyclic Redundancy Codes,CRCs)</code>的信道编码方法。循环冗余码有三个主要优点：</p>
<ol>
<li>可以对任意长度的数据进行计算</li>
<li>可以充分的检测出错误</li>
<li>可以通过硬件实现，所以非常的高效</li>
</ol>
<p>求$CRC$的计算过程可以看作是两个二进制数的相除，一个代表原数据，一个代表一个特定的除数（可根据不同的情况设置，除数的设置决定错误检测的能力），如果需要求得$N$长度的$CRC$，则需要$N+1$长度的被除数。二进制数相除的过程可以看作是多项式相除，如果原数据是$1010$，除数设置为$1011$，则计算过程如下图：</p>
<p><img src="CNI-Chapter8-Notes/2019-12-07-00-01-18.png" alt="CRC计算过程"></p>
<h2 id="An-Efficient-Hardware-Implementation-Of-CRC"><a href="#An-Efficient-Hardware-Implementation-Of-CRC" class="headerlink" title="An Efficient Hardware Implementation Of CRC"></a>An Efficient Hardware Implementation Of CRC</h2><p>CRC算法的实现硬件是由<code>移位寄存器(Shift Register)</code>和<code>异或门(Exclusive or gates)</code>构成的。在计算CRC前，硬件会初始化将移位寄存器中的所有位改为0，上例中的除数$1011$，对应的硬件图如下：</p>
<p><img src="CNI-Chapter8-Notes/2019-12-07-00-06-02.png" alt="1011硬件"></p>
<p>TODO：为什么这么设计的原因。</p>
<h2 id="Automatic-Repeat-Request-ARQ-Mechanisms"><a href="#Automatic-Repeat-Request-ARQ-Mechanisms" class="headerlink" title="Automatic Repeat Request(ARQ) Mechanisms"></a>Automatic Repeat Request(ARQ) Mechanisms</h2><p>自动重传请求技术（Automatic Repeat Request,ARQ）需要发送端和接收端传递信息来检测错误。当一方发送数据给另一方时，接收方需要传递一个回执给发送方。如果在一段时间后发送方仍然没有收到回执，则认为数据丢失，重新发送数据。</p>
<p>自动重传请求技术适合只能检测错误，但不能修复错误的系统。当接收方检测出数据有错误后，将数据丢弃并不传递回执，那么发送方就会再次发送数据。</p>
<div class="note info simple"><ol>
<li><em>Computer Networks and Internets</em> 6th</li>
<li><a href="https://en.wikipedia.org/wiki/Polynomial_long_division">多项式除法</a></li>
<li><a href="https://heasarc.gsfc.nasa.gov/docs/heasarc/ofwg/docs/general/checksum/node11.html">1’s Complement Arithmetic</a></li>
</ol>
</div>
<hr>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《计算机网络与因特网》 第七章笔记</title>
    <url>/CNI-Chapter7-Notes/</url>
    <content><![CDATA[<p>《计算机网络与因特网》 第七章笔记。</p>
<p>这一章是关于传播媒介的，首先给出了传播媒介的分类。</p>
<p>然后依次介绍各种媒介，包括线，光纤，红外线等。</p>
<p>最后介绍了信道容量的概念。</p>
<span id="more"></span>
<h1 id="Chapter-7-Transmission-Media"><a href="#Chapter-7-Transmission-Media" class="headerlink" title="Chapter 7 Transmission Media"></a>Chapter 7 Transmission Media</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>这一章将会给出传播媒介的分类，介绍电磁传播的基本概念以及展示干扰和噪音是如何被屏蔽的，最后会解释容量的概念。</p>
<h2 id="Guided-And-Unguided-Transmission"><a href="#Guided-And-Unguided-Transmission" class="headerlink" title="Guided And Unguided Transmission"></a>Guided And Unguided Transmission</h2><p>有两种重要的将传输媒介分类的方法：</p>
<ol>
<li><p>按传播路径：使用<code>有向（Guided）</code>和<code>无向（Unguided）</code>来描述传播路径。像铜线和光纤这种提供特定路径的方式称为有向。而像无线电这样的传输称为无向。工程师会通俗的将这两种称为<code>有线(wired)</code>和<code>无线(wireless)</code>，因此光纤也算在有线的范畴。</p>
</li>
<li><p>按能的形式：分为三种类型，在线缆上的<code>电信号（Electrical Energy）</code>，无线上使用的<code>无线电（Radio）</code>和光纤中使用的<code>光（Light）</code>。</p>
</li>
</ol>
<h2 id="Taxonomy-By-Forms-Of-Energy"><a href="#Taxonomy-By-Forms-Of-Energy" class="headerlink" title="Taxonomy By Forms Of Energy"></a>Taxonomy By Forms Of Energy</h2><p>下图展示了按能的形式分类的图，这个分类图也不是完美的，例如在无线电部分分为<code>陆地无线电（Terrestrial Radio）</code>和<code>卫星无线电（Satellite）</code>，但实际上太空空间站的无线电部分两者都不符合。</p>
<p><img src="CNI-Chapter7-Notes/2019-12-01-15-46-54.png" alt="能力形式分类"></p>
<h2 id="Background-Radiation-And-Electrical-Noise"><a href="#Background-Radiation-And-Electrical-Noise" class="headerlink" title="Background Radiation And Electrical Noise"></a>Background Radiation And Electrical Noise</h2><p>所有用电信号传输的电路都需要两根线，一根用来将信号传递给接收方，一根用来将反馈还给发送方。最简单的电传输方式就是使用两根铜线，每根线都用塑料包裹住，来防止相互之间的电干扰，在两根线外还有一层整个包裹起来，为了人方便使用。</p>
<p>但在线缆形式下有许多改进，这主要是因为电信号有以下特征：</p>
<ol>
<li>环境中有随机的电磁辐射，称为<code>噪音（Noise）</code>，如霓虹灯和电机就会发出随机的辐射。一般来说通信系统在正常运行状态下就会产生少量的噪音。</li>
<li>当电磁辐射遇到金属会被吸收进而产生细微的信号，这些信号会对正常的信号造成干扰。</li>
<li>正因为金属能吸收电磁辐射，所以可以用足够的金属放在噪声源和通信系统间，将其作为<code>防护（Shield）</code>。</li>
</ol>
<h2 id="Twisted-Pair-Coppter-Wiring"><a href="#Twisted-Pair-Coppter-Wiring" class="headerlink" title="Twisted Pair Coppter Wiring"></a>Twisted Pair Coppter Wiring</h2><p>有三种形式的电缆可以减少电磁噪音的干扰：</p>
<ol>
<li>非屏蔽双绞线（Unshielded Twisted Pair,UTP）</li>
<li>同轴电缆（Coaxial cable）</li>
<li>屏蔽双绞线（Shielded Twisted Pair,STP）</li>
</ol>
<p>第一个形式，非屏蔽双绞线在通信中被广泛应用。如名字一样，双绞线是将两根铜线缠绕在一起的形式，这种相互缠绕的形式比两根线平行排布有更好的抗干扰性。如下图所示，（a）为平行排列，蓝线更接近辐射源，于是它相对于灰线吸收了更多的能量，而在（b）图的缠绕形式中，两根线都各有一部分更靠近辐射源，所以整体来说，两者收到的能量是相同的。</p>
<p><img src="CNI-Chapter7-Notes/2019-12-01-15-06-05.png" alt="双绞线"></p>
<h2 id="Shielding：Coaxial-Cable-And-Shielded-Twisted-Pair"><a href="#Shielding：Coaxial-Cable-And-Shielded-Twisted-Pair" class="headerlink" title="Shielding：Coaxial Cable And Shielded Twisted Pair"></a>Shielding：Coaxial Cable And Shielded Twisted Pair</h2><p>因为非屏蔽双绞线只是让两根线吸收了相同的能量，但噪音还是被吸收了，所以在一些情况下，非屏蔽双绞线仍然会产生问题，如有特别强的电噪音环境，或者特别接近噪声源，或者通信系统中的信号频率很高（频率越高对噪音越敏感）。为了解决这些问题，只能尽量的屏蔽噪声。</p>
<p>一种方法就是<code>同轴电缆（Coaxial Cable）</code>，它在线材的外层增加了一层<code>编织金属屏蔽(Braided metal shield)</code>（如网状）。使用编织样的金属层而非一整块金属层主要是处于便携性的考虑（后者的屏蔽性更好），但相对于非屏蔽双绞线，同轴电缆的便携性还是差的。如电视的信号线，一般都是同轴电缆，同轴电缆如下图所示：</p>
<p><img src="CNI-Chapter7-Notes/2019-12-01-15-19-14.png" alt="同轴电缆"></p>
<p>屏蔽双绞线则是非屏蔽双绞线和同轴电缆的混合，是两者形式的折中，他在一对或多对双绞线的外层使用了更薄的金属屏蔽层，很多情况下用铝来作为金属屏蔽层（铝更软）。</p>
<p>如之前节所述，为了避免铜线间的电干扰，铜线外层会包裹一层塑料。双绞线是将两个两个包裹着塑料的铜线绞在一起，同轴电缆则是在一根包裹住塑料的导线外包裹金属屏蔽层，屏蔽双绞线是在两根包裹着塑料的铜线绞在一起后再包裹金属层。</p>
<h2 id="Categories-Of-Twisted-Pair-Cable"><a href="#Categories-Of-Twisted-Pair-Cable" class="headerlink" title="Categories Of Twisted Pair Cable"></a>Categories Of Twisted Pair Cable</h2><p>一些标准机构为用于计算机网络的双绞线定义了标准，这些机构包括<code>美国国家标准组织（American National Standards Institute，ANSI）</code>，<code>通信产业联合（Telecommunications Industry Association，TIA）</code>，<code>电子产业联合（Electronic Industries Alliance，EIA）</code>，下图为主要分类：</p>
<p><img src="CNI-Chapter7-Notes/2019-12-01-15-45-39.png" alt="双绞线分类"></p>
<h2 id="Media-Using-Light-Energy-And-Optical-Fibers"><a href="#Media-Using-Light-Energy-And-Optical-Fibers" class="headerlink" title="Media Using Light Energy And Optical Fibers"></a>Media Using Light Energy And Optical Fibers</h2><p>有三种形式的媒介是用光能携带数据的：<code>光纤（Optical Fibers）</code>，<code>红外线传输（Infrared transmission）</code>，<code>点对点激光（Point to Point lasers）</code>。</p>
<p>其中最重要的类型是光纤：</p>
<ol>
<li><p>每根光纤都是一根包裹在塑料外层中的细玻璃线或者透明塑料。</p>
</li>
<li><p>光纤是用于单项传播的。在光纤的一段是一个激光或者LED，用来发射光，另一端是连接一个感光设备用来检测光。如果数据需要双向传播，则需要用到两根光纤。多根光纤用塑料封壳包裹在一起生成光纤电缆。</p>
</li>
</ol>
<p>光纤无法被弯折成直角，但光纤仍然可以弯曲，甚至可以弯曲成一个直径小于2英寸的圆，让光纤在弯折状态下仍然可以正常工作，主要是因为光的传播特性。</p>
<p>光从一个低密度物质照射入另一个高密度物质，随着入射的角度不同，光的反应也会不同。存在一个特定的角度，当光以这个角度入射时，光会随着两个物质的交界处传播。当光的入射角大于这个角度时，光会被反射。当光的入射角小于这个角度时，光会发生折射。如下图所示：</p>
<p><img src="CNI-Chapter7-Notes/2019-12-03-08-31-03.png" alt="光的反射"></p>
<p>光纤运用的是光的反射，有一个特殊的镀层（Cladding）与光纤共同形成一个边界，在传输过程中，光会在上下两个边界内反射前进。</p>
<p>但反射的过程中是存在能量损耗的，而且因为光的反射，光传播的路径是比光的直线传播要长的，因此光在光纤一段发射后，抵达另一端时能量会更低，而且会更分散（Dispersed），如下图所示：</p>
<p><img src="CNI-Chapter7-Notes/2019-12-03-08-36-42.png" alt="光分散"></p>
<p>上图中，因为接受时的能量更低，所以Y轴值更低，且因为能量更分散，所以接受的时间也会拖长，因此在X轴上如同被拉伸。</p>
<h2 id="Types-Of-Fiber-And-Light-Transmission"><a href="#Types-Of-Fiber-And-Light-Transmission" class="headerlink" title="Types Of Fiber And Light Transmission"></a>Types Of Fiber And Light Transmission</h2><p>因为光在传输中的反射导致的分散在长距离使用光纤时会成为严重问题，因此有三个种类的光纤，不同的在性能与价格上权衡，</p>
<ol>
<li><p>跃变型多模光纤（Multimode，step index fiber）：这种类型的光纤，光纤与镀层中的边界很陡峭，因此光会在边界内频繁的反射，造成大量的能量分散，但是这种光纤价格最便宜。</p>
</li>
<li><p>渐变型多模光纤（Multimode，graded index fiber）：这种类型比跃变型多模稍贵，但是能减少反射进而有更少的能量分散。</p>
</li>
<li><p>单模光纤（Single mode fiber）：这种类型的光纤最贵，但也有最低能量分散。通常用于长距离传输和高比特率的传输。</p>
</li>
</ol>
<p>如之前节所述光纤的一端会用来发射光，另一端会用来接收光。在发射端，可以通过<code>发光二极管（Light Emitting Diode，LED）</code>，或者<code>激光二极管（Injection Laser Diode，ILD）</code>。在 接收端可以用<code>感光细胞（Phote-sensitive）</code>或者<code>光敏二极管（Photodiode）</code>。</p>
<h2 id="Optical-Fiber-Compared-To-Copper-Wiring"><a href="#Optical-Fiber-Compared-To-Copper-Wiring" class="headerlink" title="Optical Fiber Compared To Copper Wiring"></a>Optical Fiber Compared To Copper Wiring</h2><p>光纤的优势：</p>
<ol>
<li>对电噪音免疫</li>
<li>更少的衰减（相对于铜线而言）</li>
<li>更高的带宽</li>
</ol>
<p>铜线的优势：</p>
<ol>
<li>更低的价格</li>
<li>更少的设备要求（光纤的接收端必须被有效的抛光）</li>
<li>更不易被损坏</li>
</ol>
<h2 id="Infrared-Communication-Technologies"><a href="#Infrared-Communication-Technologies" class="headerlink" title="Infrared Communication Technologies"></a>Infrared Communication Technologies</h2><p><code>红外线通信（Infrared Communication）</code>也是光能通信的一种，也是点对点技术的一种,电视遥控机就是红外线通信的应用。红外线的频率在人眼可见光的范围外，但是红外线仍然表现的如同可见光，它会很快的消散，可以在坚硬光滑表面反射，会被不透明物体阻挡，薄如纸片的物体会阻挡信号，甚至大气中的水气都会阻碍信号。</p>
<p>因此红外线通信适用于室内使用，适用于距离短且无阻挡的通信。</p>
<p>下图是三种红外线通信的常见技术：</p>
<p><img src="CNI-Chapter7-Notes/2019-12-03-09-54-25.png" alt="红外线通信技术"></p>
<h2 id="Point-To-Point-Laser-Communication"><a href="#Point-To-Point-Laser-Communication" class="headerlink" title="Point-To-Point Laser Communication"></a>Point-To-Point Laser Communication</h2><p><code>激光通信（Laser Communication）</code>是另一种点对点通信，如红外线通信一样，激光通信也需要一个无阻挡的路径。</p>
<p>但与红外线通信不同的是，激光通信只能覆盖很小的一片区域，激光的宽度通常只有几厘米（这里是宽度，并不是指长度），也正是因为激光的宽度很窄，所以激光传输的接收条件是比较苛刻的，通常是被永久的固定安装。</p>
<p>激光通信的典型应用是楼与楼之间的信号传输，通常在相邻大楼的外墙或者顶楼安装部署用于激光通信的发射和接收装置。</p>
<h2 id="Electronmagnetic-Radio-Communication"><a href="#Electronmagnetic-Radio-Communication" class="headerlink" title="Electronmagnetic(Radio) Communication"></a>Electronmagnetic(Radio) Communication</h2><p>常用<code>无向性（unguided）</code>来描述不需要任何介质来传播能量的通信方式。在计算机网络中最常用的依赖于电磁能的无向性技术是无线电传播（Radio Frequency Transmission）。无线电传播相较于光传播有个显著的优势，即可以长距离传播且可穿透阻碍物。</p>
<p>电磁能的使用依赖于他的频率属性，常用<code>波谱（Spectrum）</code>来描述可能的频率范围。全球的各政府分配不同频率的使用权，例如在美国是<code>联邦通信委员会（Federal Communications Commission）</code>。下图是主要的能量频率波谱，其中无线电的范围基本是$3KHZ$到$300GHZ$。</p>
<p><img src="CNI-Chapter7-Notes/2019-12-03-14-44-01.png" alt="波谱"></p>
<h2 id="Signal-Progagation"><a href="#Signal-Progagation" class="headerlink" title="Signal Progagation"></a>Signal Progagation</h2><p>电磁波的频率也决定它传播时的特性，下表是波传播的三大类型：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>分类</th>
<th>频率范围</th>
<th>传播类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>低频</td>
<td>&lt; 2 MHZ</td>
<td>沿地球表面传输，可能会被地形阻挡</td>
</tr>
<tr>
<td>中频</td>
<td>2 到 30 MHZ</td>
<td>在大气层中反射传播，尤其是在电离层</td>
</tr>
<tr>
<td>高频</td>
<td>&gt;30 MHZ</td>
<td>直线传播，会被障碍物阻挡</td>
</tr>
</tbody>
</table>
</div>
<p>无线技术也可被分为以下两类：</p>
<ol>
<li>地表（Terrestrial）：依赖相对贴近地表的设备通信，例如无线电发射器和微博发射器。这些设备一般安装在山顶，人造塔或建筑上。</li>
<li>非地表（Nonterrestrial）：依赖于大气层外的设备，例如轨道卫星</li>
</ol>
<h2 id="Types-Of-Satellites"><a href="#Types-Of-Satellites" class="headerlink" title="Types Of Satellites"></a>Types Of Satellites</h2><p>通信卫星可以根据距离地表的距离分为三类：</p>
<ol>
<li><p><code>近地轨道卫星（Low Earth Orbit,LEO）</code>：</p>
<p>有低延迟的优点，但是与地球的相对位置变化的较快，接收端需要追踪卫星。</p>
</li>
<li><p><code>中地球轨道卫星（Medium Earth Orbit,MEO）</code>：</p>
<p>为地球南北极提供信号的椭圆轨道卫星。</p>
</li>
<li><p><code>对地静止轨道卫星（Geostationary Earth Orbit,GEO）</code>：</p>
<p>与地面可以保持固定角度，缺点是离地球较远，延迟大。</p>
</li>
</ol>
<h2 id="Geostationary-Earth-Orbit-GEO-Satellites"><a href="#Geostationary-Earth-Orbit-GEO-Satellites" class="headerlink" title="Geostationary Earth Orbit(GEO) Satellites"></a>Geostationary Earth Orbit(GEO) Satellites</h2><p>从上节对于通信卫星的描述可以看出，通信卫星的权衡主要是在延迟和与轨道周期的权衡（轨道周期与地球自转相差越远，追踪卫星越难）。</p>
<p>这里以<code>对地静止轨道卫星（Geostationary Earth Orbit,GEO）</code>为例，对地静止轨道卫星的距离地表距离约为35805千米，计算过程如下：</p>
<p>因为卫星保持在轨道上，所以离心力与万有引力相等，即</p>
<script type="math/tex; mode=display">
{\omega}^2mr=\frac{GMm}{r^2} \\\\
化简为：\\\\
r^3=\frac{GM}{w^2}\\\\
其中，G是万有引力常数为6.67\times 10^-20 {km}^3/kg\cdot {s^2}，M是地球质量为5.976\times 10^{24} kg\\\\
\omega 为角速度，如果要求对地静止，即角速度与地球自转相同，即\\\\
\omega = \frac{2\pi}{3600*24}=7.29\times10^{-5} rad/s\\\\
都代入上式，求得r=42172 km，减去地球半径6376km，得对地静止轨道卫星的距离地表距离约为35805千米。</script><p>卫星距离如果不足这个数值，其旋转速度就会比地球快，在这个距离下，卫星与地表以相同的速度转动，所以地表上的卫星追踪装置在追踪到卫星后就不需要再次运动，因为两者的角度不会发生变化。但对地静止轨道卫星的最大缺陷是信号的延迟，信号的速度以光速计算，信号的一次来回需要：</p>
<script type="math/tex; mode=display">
2\times \frac{35.8\times 10^6 \text{ meters}}{3\times 10^8 \text{meters/sec}}=0.238 sec</script><p>0.2秒的延迟在许多领域上是无法被接受的。</p>
<h2 id="GEO-Coverage-Of-The-Earth"><a href="#GEO-Coverage-Of-The-Earth" class="headerlink" title="GEO Coverage Of The Earth"></a>GEO Coverage Of The Earth</h2><p>在对地静止轨道上的卫星数量是由限制的。为了避免星号键的相互干扰，卫星与卫星间必须有间隔，间隔的大小与信号的强度相关，但通常而言是4-8度，因为整个轨道是360度，所以对地静止轨道上最多有45-90颗卫星。</p>
<p>最少则需要三颗卫星来覆盖整个地球，如下图所示：</p>
<p><img src="CNI-Chapter7-Notes/2019-12-03-15-52-33.png" alt="最少三颗卫星"></p>
<p>证明如下，首先根据透视原理，距离一个球体越近，能看到球体的部分越少。在距离球体无限远的距离，最多也只能看到球体的50%，如下图所示：</p>
<p><img src="CNI-Chapter7-Notes/2019-12-03-16-17-36.png" alt="透视原理"></p>
<p>将能看到球体的百分比设为X，离球体的距离设为d，求的半径设为R，表达式为：</p>
<script type="math/tex; mode=display">
X=\frac{50\%}{1+\frac{R}{d}}</script><p>式子是由等比三角形得出的，如下图：</p>
<p><img src="CNI-Chapter7-Notes/2019-12-03-16-23-46.png" alt="等比证明"></p>
<p>将地球半径6376KM及对地静止轨道距离35805KM代入，得能看到的范围是约为42.45%，所以最少需要三颗卫星才能覆盖地球。</p>
<h2 id="Low-Earch-Orbit-LEO-Satellites-And-Clusters"><a href="#Low-Earch-Orbit-LEO-Satellites-And-Clusters" class="headerlink" title="Low Earch Orbit(LEO) Satellites And Clusters"></a>Low Earch Orbit(LEO) Satellites And Clusters</h2><p>近地轨道卫星的高度最多为2000千米，其主要的缺点在于无法与地面保持相同速度，因此地面上的天线必须旋转来追踪卫星。最低的近地轨道卫星在大约90分钟就可以环绕一遍地球，移动速度还是将对较快的，因此对于地面天线来说追踪有一定难度。</p>
<p>通常的解决方式是用卫星群（Clustering）或者阵列部署（Array Deployment）的卫星来解决追踪问题。一系列卫星一同工作来覆盖较大的区域。</p>
<p>如一条信息需要从欧洲传到北美，欧洲的地面基站向此时他上方的卫星发送数据，上方的卫星将信息在卫星群之间传播，一直传送到北美上方的卫星，北美上方的卫星再将信息传送给北美的地面基站。</p>
<h2 id="Tradeoffs-Among-Media-Types"><a href="#Tradeoffs-Among-Media-Types" class="headerlink" title="Tradeoffs Among Media Types"></a>Tradeoffs Among Media Types</h2><p>通信媒介的选择是复杂的，通常需要从以下几个方面权衡：</p>
<ol>
<li>花费（Cost）：材料，安装，操作，维护等的开销</li>
<li>数据速率（Data rate）：每秒可以传送多少数据</li>
<li>延迟（Delay）：数据传播和处理的延迟</li>
<li>信号影响（Affect on signal）：信号是否会衰减和失真</li>
<li>环境（Environment）：对干扰的敏感性和电子噪音</li>
<li>安全性（Security）：是否容易被窃听</li>
</ol>
<h2 id="Measuring-Transmission-Media"><a href="#Measuring-Transmission-Media" class="headerlink" title="Measuring Transmission Media"></a>Measuring Transmission Media</h2><p>可以从两个方面来评判传输媒介：<code>传播延迟（Progagation Delay）</code>和<code>信道容量（Channel Capacity）</code>。</p>
<p><code>奈奎斯特第一准则（Nyquist Theorem）</code>表明在理想低通信道下的最高码元速率速率是带宽的2倍。假设有K个电平，则一个码元能传输的bit数为$log_2K$，B表示信道的带宽，因此数据速率可以表达为：</p>
<script type="math/tex; mode=display">
D=2Blog_2K \text{ bits /s}</script><p>下面证明奈奎斯特准则：</p>
<p>一个有限带宽的低通滤波器，如果其截至频率为$\omega_g$其频域图如下：</p>
<p><img src="CNI-Chapter7-Notes/2019-12-03-17-06-01.png" alt="低通滤波器频域"></p>
<p>该滤波器的时域相应图为：</p>
<p><img src="CNI-Chapter7-Notes/2019-12-03-17-07-06.png" alt="低通滤波器时域"></p>
<p>时域的相应波形时一个拖尾的连续信号，这个拖尾会干扰后续信号。但是从波形上可以看出，在$t=\frac{\pi}{\omega_s},\frac{2pi}{\omega_s}…$处是0，所以如果在这些间隔点发送码元，则不会被干扰。这些点的间隔时间为$T_s=\frac{\pi}{\omega_s}=\frac{1}{2f_m}$，所以码元速率为$R=\frac{1}{T_s}=2f_m$</p>
<h2 id="The-Effect-of-Noise-On-Communication"><a href="#The-Effect-of-Noise-On-Communication" class="headerlink" title="The Effect of Noise On Communication"></a>The Effect of Noise On Communication</h2><p>奈奎斯特定理提供了了理论上的最高码元速率，因为他并没有将噪音纳入考虑， 而实际中噪音不可避免。香农在此基础上给出了考虑噪音的数据速率，称为香农定理（Shannon’s Theorem）：</p>
<script type="math/tex; mode=display">
C=B\log_2(1+S/N) bits/s</script><p>其中$S/N$称为信噪比，式子中并没有给出电平数量K，这是因为实际上在考虑噪声时，电平数量是受噪声影响的，噪声越大，为了避免干扰，电平的间隔就只能越大，因此电平数量就越少。</p>
<h2 id="The-Significance-Of-Channel-Capacity"><a href="#The-Significance-Of-Channel-Capacity" class="headerlink" title="The Significance Of Channel Capacity"></a>The Significance Of Channel Capacity</h2><p>奈奎斯特定律鼓励工程师探索更高效的编码方式，因为在最高码元速率受信道带宽限制时，编码方式越高效，一个码元携带的数据就越多，单位时间内就能传输更多的比特。</p>
<p>香农定理给出了真实环境下，数据速率的上限，即无论编码多么高效，在非理想环境（有噪声）下，每秒最大的比特传输量</p>
<div class="note info simple"><ol>
<li><p>Xianping, W.M.L.R.T., 2002. Simple Certification of Nyquist Rule. Journal of Beijing Institufe of Petrochemical Technology, (2), p.12.</p>
</li>
<li><p><a href="https://zh.wikipedia.org/wiki/%E5%9C%B0%E7%90%83%E9%9D%9C%E6%AD%A2%E8%BB%8C%E9%81%93">https://zh.wikipedia.org/wiki/%E5%9C%B0%E7%90%83%E9%9D%9C%E6%AD%A2%E8%BB%8C%E9%81%93</a></p>
</li>
<li><p><em>Computer Networks and Internets</em> 6th</p>
</li>
</ol>
</div>
<hr>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《C++ Primer》 第二章笔记</title>
    <url>/CPPPrimer-Chapter2-Notes/</url>
    <content><![CDATA[<p>《C++ Primer》 第二章笔记，关于变量与基本类型。</p>
<p><img src="CPPPrimer-Chapter2-Notes/2020-04-15-22-06-48.png" alt="第二章内容"></p>
<span id="more"></span>
<h1 id="Chapter-2-Variables-And-Basic-Types"><a href="#Chapter-2-Variables-And-Basic-Types" class="headerlink" title="Chapter 2 Variables And Basic Types"></a>Chapter 2 Variables And Basic Types</h1><h2 id="Primitive-Built-in-Types"><a href="#Primitive-Built-in-Types" class="headerlink" title="Primitive Built-in-Types"></a>Primitive Built-in-Types</h2><p>C++的内置类型（Primitive Type）包括算数类型和空（Void）。算数类型可以用来表示字符，整数，布尔值，浮点数。</p>
<h3 id="Arithmetic-Types"><a href="#Arithmetic-Types" class="headerlink" title="Arithmetic Types"></a>Arithmetic Types</h3><p>算数类型（Arithmetic Types）可以再细分为整数类型（Integral types）和浮点数类型（Floating-point types）。</p>
<blockquote>
<p>算数类型的大小，即占用多少个bit，在不同的设备上是不同的</p>
</blockquote>
<p>C++标准保证了每个类型的最小尺寸，编译器可以给类型分配大于最小尺寸的位数。因为位数的变换，每一个类型所能表示的最大值和最小值也会相应的变换。</p>
<p>C++有的算数类型如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>含义</th>
<th>最小尺寸</th>
</tr>
</thead>
<tbody>
<tr>
<td>bool</td>
<td>布尔值</td>
<td>Not Available</td>
</tr>
<tr>
<td>char</td>
<td>字符</td>
<td>8 bits</td>
</tr>
<tr>
<td>wchar_t</td>
<td>宽字符</td>
<td>16 bits</td>
</tr>
<tr>
<td>char16_t</td>
<td>Unicode 字符</td>
<td>16 bits</td>
</tr>
<tr>
<td>char32_t</td>
<td>Unicode 字符</td>
<td>32 bits</td>
</tr>
<tr>
<td>short</td>
<td>短整数</td>
<td>16 bits</td>
</tr>
<tr>
<td>int</td>
<td>整数</td>
<td>16 bits</td>
</tr>
<tr>
<td>long</td>
<td>长整数</td>
<td>32 bits</td>
</tr>
<tr>
<td>long long</td>
<td>长整数</td>
<td>32 bits</td>
</tr>
<tr>
<td>float</td>
<td>单精度浮点数</td>
<td>精度为6位有效数字</td>
</tr>
<tr>
<td>double</td>
<td>双精度浮点数</td>
<td>精度为10位有效数字</td>
</tr>
<tr>
<td>long double</td>
<td>额外精度浮点数</td>
<td>精度为10位有效数字</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>long long 是C++ 11 后才支持的特性</p>
<p>一个char的大小应该保证可以容纳一个设备的基础字符集，通常尺寸为8 bits。wchar_t,char16_t和char32_t都是为了扩展字符集。</p>
<p>布尔值，字符和各种整数，都是整数类型。</p>
</blockquote>
<p>内存可以分配的最小单元是byte，存储的基本单元为word。在c++中，byte的大小是可以容纳机器基本字符集的大小，通常为8 bits。word的大小通常为32 bits或者64 bits，即4到8 bytes。</p>
<blockquote>
<p>通常编译器会提供给浮点数比最低要求更高的精度，float一般表示7位有效数字，double表示16位有效数字。通常float用1个word表示，double用两个words表示，long double用3或4个words表示。但要注意的是这些精度与尺寸都不是固定的，可能因设备的不同而不同。</p>
</blockquote>
<p>大多数的计算机都会给每个byte分配一个地址。如在一台8-bit byte和 32-bit words的电脑上，一个word的内存如下，可以说是地址在736424的word或地址在736427的byte。</p>
<p><img src="CPPPrimer-Chapter2-Notes/2020-02-07-16-03-22.png" alt="word内存分布"></p>
<p>数据的类型决定了编译器会如何处理这些内存，即多少bit的数据会被认为是一个数据以及该如何翻译这些内存。</p>
<h3 id="Signed-and-Unsigned-Types"><a href="#Signed-and-Unsigned-Types" class="headerlink" title="Signed and Unsigned Types"></a>Signed and Unsigned Types</h3><p>除了布尔值和扩展字符集的字符（如wchar_t等），所有的整数类型都可以被分类为有符号（signed）与无符号（unsigned）。</p>
<p>默认的类型，如int，short，long和long long都是有字符的，可以通过加上相应的<code>unsigned</code>关键字得到无字符版本，如<code>unsigned long</code>。<code>unsigned int</code>被缩写为<code>unsigned</code>。</p>
<p>但是对于char类型，有三个类型<code>char</code>，<code>signed char</code>，<code>unsigned char</code>三个版本。<code>char</code>是<code>signed char</code>或<code>unsigned char</code>中的一种，具体是哪一种由编译器决定。</p>
<p>标准并没有定义有符号类型如何表示数据，但是定义了正数部分和负数部分应该是均匀的分割，如8-bit的 signed char，应该保证能覆盖$-127 \sim 127$的范围。大多数现代设备的实现下，char表示的范围是$-128\sim127$。</p>
<blockquote>
<p>数据定义建议：</p>
<ol>
<li>如果确保数值不会是负数，使用unsigned类型</li>
<li>通常情况下使用int，short的可定义范围太小，如果数值大于了int可表示范围，使用long long。之所以不使用long，是因为在许多设备的实现下，long和int的大小是相同的。</li>
<li>在算数表达式中，不要使用char和布尔值。char类型在不同的设备下，可能是signed char可能是unsigned char，这个会导致bug的发生。布尔值则会被解释为0或1，可能与设想的结果不同，建议直接用0或1来表达。</li>
<li>使用double进行浮点数计算。一是因为float通常没有足够的精度，二是因为单精度和双精度的开销差距几乎可以忽略不计，三是因为对于一些设备而言，双精度反而会有更高的效率。</li>
</ol>
</blockquote>
<h3 id="Type-Conversions"><a href="#Type-Conversions" class="headerlink" title="Type Conversions"></a>Type Conversions</h3><p>类型转换会在使用一个类型的对象，但希望得到另一个类型的对象时自动进行。</p>
<p>如下列代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> b = <span class="number">42</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;value is &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"><span class="type">int</span> i = b;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;value is &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">i = <span class="number">3.14</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;value is &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (i)</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;result is true&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="type">double</span> pi = i;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;value is &quot;</span> &lt;&lt; pi &lt;&lt; endl;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> c = <span class="number">-1</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;value is &quot;</span> &lt;&lt; (<span class="type">int</span>)c &lt;&lt; endl;</span><br><span class="line"><span class="type">signed</span> <span class="type">char</span> c2 = <span class="number">256</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;value is &quot;</span> &lt;&lt; (<span class="type">int</span>)c2 &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>结果为</p>
<p><img src="CPPPrimer-Chapter2-Notes/2020-02-07-17-43-40.png" alt="类型转换例子1结果"></p>
<p>规则如下：</p>
<ol>
<li>如果将一个非布尔值的算数类型赋值给布尔值，如果该数据值为0，则布尔值为false，否则为true。</li>
<li>如果将布尔值赋值给算数类型，如果布尔值是true，则值为1，否则值为0。</li>
<li>如果将浮点数类型赋值给整数类型，整数类型将保留浮点数的整数部分。</li>
<li>如果将整数类型赋值给浮点数类型，则浮点数的小数部分为0。</li>
<li>如果给unsigned类型赋值了超过其能表达的范围的数，结果为值与unsigned类型范围的取模。如上例中，<code>unsigned char c = -1</code>，值为最大能表达的数$256-1$（测试电脑char为8-bit）。</li>
<li>如果给signed类型赋值了超过其能表达的范围的数，结果是未定义的，虽然在这里的测试中，结果为0。<br>但结果在不同电脑，不同编译器，甚至不同的运行时间都会不同，结果是不可预知的。</li>
</ol>
<h4 id="Expression-Involving-Unsigned-Types"><a href="#Expression-Involving-Unsigned-Types" class="headerlink" title="Expression Involving Unsigned Types"></a>Expression Involving Unsigned Types</h4><p>当signed与unsigned数一起计算时，signed会被转换为unsigned，如下面代码所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> u1 = <span class="number">10</span>, u2 = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">-42</span>;</span><br><span class="line">cout &lt;&lt; i + i &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; i + u1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; u2 - u1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; u1 - u2 &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>结果为：</p>
<p><img src="CPPPrimer-Chapter2-Notes/2020-02-07-17-59-23.png" alt="signed隐式转换例子"></p>
<p>第二个表达式值为4294967264，因为在计算时$i$被转换为了unsigned,值为$2^{32}-42$（32次方是因为int用32-bit表示），因此整个式子的结果为$2^{32}-42+10=4294967264$。</p>
<p>同理第四个式子直觉上结果应该为-32，但因为是unsigned的，所以结果为$2^{32}-32=4294967264$。</p>
<p>在使用unsigned作为循环条件时尤其要注意，如下式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">10</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;i is &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果会变成死循环：</p>
<p><img src="CPPPrimer-Chapter2-Notes/2020-02-07-18-04-25.png" alt="unsigned隐式转换造成的死循环"></p>
<p>因为在i变为0后，执行<code>i--</code>，i将变成$2^{32}-1$，而不是-1。</p>
<ul>
<li>因此不要将signed和unsigned混用，即使是知道隐式转换的规则。因为在不同的设备下，用以表达unsigned类型的字节数是可能是不同的，这将会导致隐式转换后的结果不同。本例子中，int为32-bit表达，但并不保证所有的设备都是用32-bit表达int。</li>
</ul>
<h3 id="Literals"><a href="#Literals" class="headerlink" title="Literals"></a>Literals</h3><h4 id="Integar-and-Floating-Point-Literals"><a href="#Integar-and-Floating-Point-Literals" class="headerlink" title="Integar and Floating-Point Literals"></a>Integar and Floating-Point Literals</h4><p>可以使用十进制，八进制或者十六进制来写整数字面量。以<code>0</code>开始的字面量会被认为是八进制，以<code>0x</code>或者<code>0X</code>开始的字面量会被认为是十六进制。</p>
<p>以下的三个表达是等效的，结果都是十进制的20。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i_decimal = <span class="number">20</span>, i_octal = <span class="number">024</span>, i_hexadecimal = <span class="number">0x14</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;i decimal is &quot;</span> &lt;&lt; i_decimal &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;i octal is &quot;</span> &lt;&lt; i_octal &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;i hexadecimal is &quot;</span> &lt;&lt; i_hexadecimal &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>三个表达是等效的，结果都是十进制的20。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> month = <span class="number">09</span>;<span class="comment">//error, 09 is treated as octal</span></span><br></pre></td></tr></table></figure>
<p>上式无法通过编译，因为0开头的字面值会被认为是八进制数，而数字9不会出现在八进制数中。</p>
<p>十进制的字面值会被默认是有符号的，八进制和十六进制则可以是无符号也可以是有符号的。即十进制的字面值类型会被认为是<code>int,long,long long</code>之中最小的满足值的类型。八进制或十六进制则会在<code>int,unsigned int,long,unsigned long,long long, unsigned long long</code>中选择最小的满足的类型。</p>
<p>如果字面值的大小超过long long 或unsigned long long所能匹配的值，则无法匹配任意一种类型，编译器将会报错，如以下语句无法通过编译：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//cout &lt;&lt; 9223372036854775808 &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; -9223372036854775808 &lt;&lt; endl;</span></span><br></pre></td></tr></table></figure>
<p>因为这是10进制的字面值，其最大类型为long long，而signed long long的范围是$-9223372036854775808 \sim 9223372036854775807$。$-9223372036854775808$虽然在范围内，但仍然无法被编译，因为十进制的字面值并不会被认为有负号，即$-9223372036854775808$会被认为是一个$0减去9223372036854775808$，即仍然计算的是$9223372036854775808$。</p>
<blockquote>
<p>这里谈论的限制都是C++标准的限制，但是有些编译器的实现会与标准不同，如上述代码在visual studio 2019中可通过编译，这是因为编译器将其自动转换为了unsigned long long 类型</p>
</blockquote>
<p>浮点数的字面值用十进制的小数点或者用科学计数法（符号E表示），如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; <span class="number">3.14159</span> &lt;&lt; endl;   <span class="comment">//3.14159</span></span><br><span class="line">cout &lt;&lt; <span class="number">3.14159E0</span> &lt;&lt; endl; <span class="comment">//3.14159</span></span><br><span class="line">cout &lt;&lt; <span class="number">3.14159E1</span> &lt;&lt; endl; <span class="comment">//31.14159</span></span><br><span class="line">cout &lt;&lt; <span class="number">0.</span> &lt;&lt; endl;<span class="comment">//0</span></span><br><span class="line">cout &lt;&lt; <span class="number">0e0</span> &lt;&lt; endl;<span class="comment">//0</span></span><br><span class="line">cout &lt;&lt; <span class="number">.001</span> &lt;&lt; endl;<span class="comment">//0.001</span></span><br><span class="line">cout &lt;&lt; <span class="number">1E-3</span> &lt;&lt; endl;<span class="comment">//0.001</span></span><br></pre></td></tr></table></figure>
<p>默认的所有浮点数字面值的类型为double。</p>
<h4 id="Character-and-Character-String-Literals"><a href="#Character-and-Character-String-Literals" class="headerlink" title="Character and Character String Literals"></a>Character and Character String Literals</h4><p>单引号之间的字符会被认为是char字面值，双引号之间的字符会被认为string字面值。如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&#x27;a&#x27;</span> &lt;&lt; endl;	   <span class="comment">//a</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Hello&quot;</span> &lt;&lt; endl;   <span class="comment">//Hello</span></span><br></pre></td></tr></table></figure>
<p>string字面值是const char的数组，编译器会自动在数组的最后加上一个空白字符，即<code>\0</code>，所以string的真实长度比看上去的字符数大1。如’a’长度为1，”a”长度为2。</p>
<p>两个string字面值如果中间只有空格，或tab或者换行符，会被认为是一个string字面值，如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout&lt;&lt;<span class="string">&quot;This is first string literal&quot;</span></span><br><span class="line">		<span class="string">&quot;This is second string literal&quot;</span>&lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<h4 id="Escape-Sequences"><a href="#Escape-Sequences" class="headerlink" title="Escape Sequences"></a>Escape Sequences</h4><p>一些无法显示出来的字符（如回车）和一些有特殊含义的字符可以使用转义序列（Escape sequence）表示。</p>
<p>一些常用转义序列</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>转义符</th>
<th>作用</th>
<th>转义符</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>\n</td>
<td>换行</td>
<td>\t</td>
<td>水平 tab</td>
</tr>
<tr>
<td>\v</td>
<td>纵向tab</td>
<td>\&lt;*&gt;</td>
<td>打印出特殊符号*，如” ‘ \</td>
</tr>
</tbody>
</table>
</div>
<p>也可以使用数字和转义符来生成转义序列，假设编译器使用的是<a href="CPPPrimer-Chapter2-Notes/&quot;https://kb.iu.edu/d/aepu&quot;"><code>Latin-1</code>字符集</a>。可在<code>\x</code>后跟1或多位十六进制数组，或在<code>\</code>后跟着1至3位八进制数字，如以下代码都将显示一样的结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;M\n&quot;</span>;	 <span class="comment">//M</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;\115\12&quot;</span>; <span class="comment">//M</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;\x4d\xA&quot;</span>; <span class="comment">//M</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>这里的\115后跟着的是八进制数，转换为十进制为77，可在Latin-1表中得知，77表示为M。同理\12表示十进制10，表示为LF，即换行。</p>
</li>
<li><p>跟在<code>\</code>后的数字最多只会被计算前三位，如<code>\1234</code>将会被认为是转义序列<code>\123</code>和一个普通的4。而<code>\x</code>之后跟着的所有数字都会被计算,如<code>\x1234</code>会被认为后面跟着16-bits的十六进制数（一个16进制数是4-bits），但是大多数的硬件都是使用8-bits char的，所以通常来说，两位十六进制数就足以表示字符表了。</p>
</li>
</ul>
<h4 id="Specifying-the-Type-of-a-Literal"><a href="#Specifying-the-Type-of-a-Literal" class="headerlink" title="Specifying the Type of a Literal"></a>Specifying the Type of a Literal</h4><p>可以通过前缀或后缀来指定整数、浮点数以及字符字面值的类型。字符字面值用前缀，整数及浮点数字面值用后缀。</p>
<p>字符字面值类型指定如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>前缀</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>u</td>
<td>char16_t</td>
</tr>
<tr>
<td>U</td>
<td>char32_t</td>
</tr>
<tr>
<td>L</td>
<td>wchar_t</td>
</tr>
<tr>
<td>u8（只能用于string类型）</td>
<td>char</td>
</tr>
</tbody>
</table>
</div>
<p>整数字面值指定如下表所示:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>后缀</th>
<th>最小类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>u 或 U</td>
<td>unsigned</td>
</tr>
<tr>
<td>l 或 L</td>
<td>long</td>
</tr>
<tr>
<td>ll 或 LL</td>
<td>long long</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>整数字面值设定的是最小类型，即最终的类型还是会根据字面值的大小来调整<br>指定有无符号的类型后缀可以和指定长度的类型的混合使用</p>
</blockquote>
<p>浮点数字面值指定如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>后缀</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>f 或 F</td>
<td>float</td>
</tr>
<tr>
<td>l 或 L</td>
<td>long double</td>
</tr>
</tbody>
</table>
</div>
<p>指定字面值类型示例代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; <span class="number">9223372036854775808ULL</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">L&#x27;a&#x27;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">u8&quot;hi&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="number">1E-3</span>F &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="number">0.001F</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="number">3.14159L</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h2 id="Variables"><a href="#Variables" class="headerlink" title="Variables"></a>Variables</h2><p>C++中的每个变量（Variables）都有类型。</p>
<h3 id="Variable-Definitions"><a href="#Variable-Definitions" class="headerlink" title="Variable Definitions"></a>Variable Definitions</h3><p>简单的变量定义由一个类型指示器（Type Specifier）跟着一个或多个由逗号分割的变量名称组成，以分号结束。如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> sum = <span class="number">0</span>, value, units_sold = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h3 id="Initializers"><a href="#Initializers" class="headerlink" title="Initializers"></a>Initializers</h3><p>当变量定义在同个语句中定义多个变量时，每个变量在声明后马上可见，即后续的变量可以用前面的变量来初始化，如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> price = <span class="number">109.99</span>, discount = price * <span class="number">0.16</span>;</span><br></pre></td></tr></table></figure>
<p>在C++中初始化（Initialization）和赋值（assignment）是两个不同的操作，在许多语言中这两者的区别几乎可以忽略。但是在C++中两者的区别却很重要，初始化是一个变量在创建时给予参数的过程，赋值是变量已经生成后由新的参数替代原先参数的过程。</p>
<ul>
<li>在后续的章节中会进一步讨论两者的差异。</li>
</ul>
<h3 id="List-initialization"><a href="#List-initialization" class="headerlink" title="List initialization"></a>List initialization</h3><p>C++有多种方法来初始化变量，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> units_sold = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// int units_sold(0);</span></span><br><span class="line"><span class="comment">// int units_sold = &#123;0&#125;;</span></span><br><span class="line"><span class="comment">// int units_sold&#123;0&#125;;</span></span><br></pre></td></tr></table></figure>
<p>这四者都是初始化的方法，其中后两种带有大括号的是C++11的新特性，称为列表初始化（list initialization）。</p>
<p>如果使用列表初始化，那么在初始化变量的过程中不允许出现精度的丢失，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">double</span> id = <span class="number">3.1415926536</span>;</span><br><span class="line"><span class="type">float</span> ifloat&#123;id&#125;;</span><br><span class="line"><span class="type">int</span> a&#123;id&#125;, b = &#123;id&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>书中描述编译器会禁止丢失精度的赋值，但在gcc 8.1.0的版本测试下，编译器只是给出了warning</p>
</blockquote>
<h3 id="Default-Initialization"><a href="#Default-Initialization" class="headerlink" title="Default Initialization"></a>Default Initialization</h3><p>当定义一个变量但没有给初始化数值时，参数会被赋予默认值。在任何函数外的未赋值变量会被初始化为0，在函数内部的未赋值内置变量则不会被初始化。未初始化的变量值是未定义的（Undefined），访问或拷贝任何未初始化的值都会产生错误。</p>
<blockquote>
<p>这里的描述仍然是C++的标准定义，但是不同的编译器会有不同的实现，如在gcc 8.1.0版本中，函数内部的未赋值变量仍然会被初始化为0。但要知道未定义的操作在不同的版本或设备下很可能有不同的结果，所以应该尽可能避免。</p>
</blockquote>
<h3 id="Variable-Declarations-and-Definitions"><a href="#Variable-Declarations-and-Definitions" class="headerlink" title="Variable Declarations and Definitions"></a>Variable Declarations and Definitions</h3><p>C++支持单独编译（Separate Compilation），即可以把整个程序放在多个文件中，每个文件可以独立的被编译。</p>
<p>为支持单独编译，C++需要区分声明（Declaration）和定义（Definition）。</p>
<p><code>声明</code>是为了让程序知道变量的名称。如果一个文件需要使用在其他地方定义的变量，那么在这个文件中需要对该变量进行声明。声明一个变量需要指定它的类型和名称。</p>
<p><code>定义</code>是创建相关的变量。定义一个变量首先会先声明该变量，然后再为该变量开辟存储空间，并赋予初始值。</p>
<p>每个变量都只可以被定义一次，但可以被声明多次。</p>
<p>可以使用关键字<code>extern</code>来指定操作是声明而不是定义，不允许在函数内部使用extern关键字。</p>
<p>如上所属，声明是不包括函数的初始值的，所以如果一个声明包含了对变量的初始化，那么该声明实际上是定义（在后续章节中可以看到，对于const变量会需要同时使用extern和初始化）。如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Declarations and Definitions</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i;			   <span class="comment">// Declares but does not define i</span></span><br><span class="line"><span class="type">int</span> j;					   <span class="comment">//declare and defines j</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">double</span> pi = <span class="number">3.1416</span>; <span class="comment">// declare and defines pi, same with expression without extern</span></span><br></pre></td></tr></table></figure>
<p>为了在多个文件中使用同一个变量，必须在<code>一个文件</code>中定义该变量，在其他文件中声明（不包括定义）该变量。</p>
<h3 id="Identifiers"><a href="#Identifiers" class="headerlink" title="Identifiers"></a>Identifiers</h3><p>C++中的标识符（变量名称）由字符，数字和下划线构成，C++并没有限制名称的长度。</p>
<h3 id="Scope-of-a-Name"><a href="#Scope-of-a-Name" class="headerlink" title="Scope of a Name"></a>Scope of a Name</h3><p>作用域（Scope）是指一个变量在程序中存在意义的部分，在C++中绝大部分的作用域都是通过大括号（<code>&#123;  &#125;</code>）进行分割的。</p>
<h4 id="Nested-scopes"><a href="#Nested-scopes" class="headerlink" title="Nested scopes"></a>Nested scopes</h4><p>作用域有的时候会形成嵌套，如果产生嵌套的话，外部作用域（Outer scope）中定义的参数可以被内部作用域（Inner scope）使用，如果内部作用域定义了一个与外部作用域中某变量名字相同的新变量，外部作用域中的变量将会被隐藏，但可以使用操作符<code>::</code>来访问被隐藏了的变量。</p>
<p>如下所示，其中定义在所有函数外的变量有<code>全局作用域(Global scope)</code>，否则的话有<code>代码块作用域(block scope)</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> reused = <span class="number">42</span>; <span class="comment">//global scope</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> unique = <span class="number">0</span>;							   <span class="comment">//block scope</span></span><br><span class="line">  cout &lt;&lt; reused &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; unique &lt;&lt; endl;   <span class="comment">//42 0</span></span><br><span class="line">  <span class="type">int</span> reused = <span class="number">0</span>;							   <span class="comment">//local named reused hides global reused</span></span><br><span class="line">  cout &lt;&lt; reused &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; unique &lt;&lt; endl;   <span class="comment">// 0 0</span></span><br><span class="line">  cout &lt;&lt; ::reused &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; unique &lt;&lt; endl; <span class="comment">// 42 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中第二个输出中的reused变量是在内部作用域中新定义的变量，因此值为0。第三个输出中的reused使用了<code>::</code>操作符访问了全局变量中的reused,所以值为42。</p>
<h2 id="Compound-Types"><a href="#Compound-Types" class="headerlink" title="Compound Types"></a>Compound Types</h2><p>复合类型（Compound Type）是根据其他类型定义的一种类型，C++有多种混合类型，在这里会先介绍两种，引用（Reference）和指针（Points）。</p>
<h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><blockquote>
<p>在C++11中引入了右引用(rvalue reference)和左引用(lvalue reference)的概念。但通常来说，当提及引用时都是指左引用。</p>
</blockquote>
<p>引用（Reference）是一个物体的别名，引用类型指代另一个类型。</p>
<p>一个引用创建时会绑定至另一个变量，成为它的别名。当引用创建后无法重新绑定至其他变量，因此引用创建的时候必须被初始化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span> &amp;refVal = ival;</span><br><span class="line"><span class="comment">// int &amp;refVal2; //error,must be initialized</span></span><br><span class="line"><span class="comment">// &amp;refVal = reused; //error,can not be rebinded</span></span><br><span class="line">refVal = reused;<span class="comment">//Not rebingding, is to change ival&#x27;s value</span></span><br></pre></td></tr></table></figure>
<h4 id="A-Reference-Is-an-Alias"><a href="#A-Reference-Is-an-Alias" class="headerlink" title="A Reference Is an Alias"></a>A Reference Is an Alias</h4><p>如之前所述，引用不是物体，而是另一个物体的别名，所以对引用的任何操作实际上都是对被绑定的物体的操作。如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ii = refVal;	   <span class="comment">//Bound to ival</span></span><br><span class="line"><span class="type">int</span> &amp;refVal3 = refVal; <span class="comment">//the same value as ival</span></span><br></pre></td></tr></table></figure>
<h4 id="Reference-Definitions"><a href="#Reference-Definitions" class="headerlink" title="Reference Definitions"></a>Reference Definitions</h4><p>引用符号<code>&amp;</code>是针对变量名称而言的，所以每个引用在定义的时候前面都需要加上引用符号。</p>
<p>另外除了在2.4节（const reference可以绑定至任意可转换的对象）和15.2节(基类的引用可以绑定派生类对象)提到的两个特殊情况，引用类型必须和被捆绑的值类型一致，且引用类型不能捆绑至字面值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1024</span>, i2 = <span class="number">2048</span>;</span><br><span class="line"><span class="type">int</span> &amp;r = i, r2 = i2; <span class="comment">//r is int refernece, r2 is int</span></span><br><span class="line"><span class="comment">// int &amp;refVal4 = 10; //error, can&#x27;t be bound to literal</span></span><br><span class="line"><span class="type">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="comment">// int &amp;refVal5 = dval; //error, types not match</span></span><br></pre></td></tr></table></figure>
<h3 id="Pointers"><a href="#Pointers" class="headerlink" title="Pointers"></a>Pointers</h3><p>指针（Pointers）是一个“指向”别的类型的复合类型。</p>
<p>与引用不同的是，指针是一个物体，因此它可以被拷贝和赋值，在指针的生命周期内，它可以被指向多个不同的物体。而且指针在定义时并不一定要被初始化，但与其他的内建类型一样，在代码块作用域中的指针如果未被初始化赋值，则它的值是未定义的。</p>
<p>与引用相似的是，在定义每个指针变量的时候，都需要在前面加上指针符号<code>*</code>。</p>
<h4 id="Taking-the-Address-of-an-Object"><a href="#Taking-the-Address-of-an-Object" class="headerlink" title="Taking the Address of an Object"></a>Taking the Address of an Object</h4><p>一个指针包含另一个物体的地址，可通过取地址符(&amp;)来获得一个对象的地址。</p>
<p>与引用类似，除了在2.4节（pointer to const可以绑定至nonconst对象）和15.2节阐述的特殊情况外，指针所指向的对象类型必须与指针类型相同。如下列代码所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Points</span></span><br><span class="line"><span class="type">int</span> *ip1, *ip2; <span class="comment">//define int pointer without initializer</span></span><br><span class="line"><span class="type">double</span> dp, dp2; <span class="comment">//dp is double, dp2 is double pointer</span></span><br><span class="line"><span class="type">int</span> ival = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;ival; <span class="comment">//p hold the address of ival</span></span><br><span class="line"><span class="type">double</span> dval;</span><br><span class="line"><span class="type">double</span> *pd = &amp;dval; <span class="comment">//Initializer is the address of a double</span></span><br><span class="line"><span class="type">double</span> *pd2 = pd;   <span class="comment">//Initializer is a pointer to double</span></span><br><span class="line"><span class="comment">// int *pi = pd;		//error,pointer types not match</span></span><br><span class="line"><span class="comment">// int *pi2 = &amp;dval;   // error,pointer types and object typenot match</span></span><br></pre></td></tr></table></figure>
<h4 id="Pointer-Value"><a href="#Pointer-Value" class="headerlink" title="Pointer Value"></a>Pointer Value</h4><p>一个指针的值，可以是以下四种情况：</p>
<ol>
<li>指向一个对象的地址</li>
<li>指向一个对象地址后的第一个byte</li>
<li>空指针，不指向任何对象</li>
<li>非法指针，除了上述三个情况的指针都是非法指针。</li>
</ol>
<p>使用非法指针的结果是未定义的，具体的结果由不同的编译器决定。虽然情况2和3是合法的，但是访问这两种情况的指针结果也是未定义的。如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *ip = &amp;ival;	 <span class="comment">//Pointer to ival</span></span><br><span class="line"><span class="type">int</span> *ipEnd = ip + <span class="number">1</span>; <span class="comment">//Pointer to end of ival</span></span><br><span class="line"><span class="type">int</span> *ipNull = <span class="literal">NULL</span>;</span><br><span class="line">cout &lt;&lt; (*ip) &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; (*ipEnd) &lt;&lt; endl; <span class="comment">// 42 0</span></span><br></pre></td></tr></table></figure>
<p>虽然在这里的测试中<code>(*ipEnd)</code>返回的值为0，但实际上这是未定义操作，在不同的编译器会返回不同的结果。</p>
<h4 id="Using-a-Pointer-to-Access-an-Object"><a href="#Using-a-Pointer-to-Access-an-Object" class="headerlink" title="Using a Pointer to Access an Object"></a>Using a Pointer to Access an Object</h4><p>当使用指针访问变量时，需要使用解引用符号<code>*</code>。如上节代码中的<code>(*ip)</code>。</p>
<ul>
<li>尽可能避免解引用那些非法或者没有指向具体对象的指针。</li>
</ul>
<p>&amp;和*符号现在都有多个含义，&amp;既可以表示为引用，又可以表示取地址符号，*既可以表示指针，又可以表示解引用符号。它们在代码中的具体含义由上下文决定：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> &amp;r = i;							 <span class="comment">//reference</span></span><br><span class="line"><span class="type">int</span> *pp;							 <span class="comment">//pointer</span></span><br><span class="line">pp = &amp;r;							 <span class="comment">//address-of operator</span></span><br><span class="line">*pp = i;							 <span class="comment">//dereference</span></span><br><span class="line"><span class="type">int</span> &amp;r2 = *pp;						 <span class="comment">// reference and dereference</span></span><br><span class="line">cout &lt;&lt; (r2) &lt;&lt; <span class="string">&quot;&quot;</span> &lt;&lt; (*pp) &lt;&lt; endl; <span class="comment">//4242</span></span><br></pre></td></tr></table></figure>
<h4 id="Null-Pointers"><a href="#Null-Pointers" class="headerlink" title="Null Pointers"></a>Null Pointers</h4><p>空指针（Null Pointers）并不指向任何对象，代码可以在使用指针前检查其是否为空。</p>
<p>有三种方法定义空指针，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p1 = <span class="literal">nullptr</span>; <span class="comment">// c++ 11</span></span><br><span class="line"><span class="type">int</span> *p2 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *p3 = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<p>nullptr是C++11标准中引入的特性，它是一个特殊的字面值，可以转换为任何指针类型。NULL定义在头文件<code>cstdlib</code>中，它使用预处理器(<code>#define</code>)转换为0，所以使用NULL和使用0来定义空指针实际上是等效的。</p>
<ul>
<li>尽量使用nullptr</li>
</ul>
<p>虽然可以用0来表示空指针，但并不能将int变量直接赋值给指针，即使该变量值为0也不行，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> zero = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// p3 = zero; //error, can&#x27;t assign an int to pointer</span></span><br></pre></td></tr></table></figure>
<h4 id="Assignment-and-Pointers"><a href="#Assignment-and-Pointers" class="headerlink" title="Assignment and Pointers"></a>Assignment and Pointers</h4><p>指针和引用都是对对象的间接访问，但引用是对象的别名，且引用本身并不是一个对象，但指针是一个对象，它存储另一个对象的地址。</p>
<p>引用在初始化后无法修改其本身绑定的对象，指针可以在生命周期内修改它所指向的对象。</p>
<h4 id="Other-Pointer-Operations"><a href="#Other-Pointer-Operations" class="headerlink" title="Other Pointer Operations"></a>Other Pointer Operations</h4><p>指针可以用来作为判断条件，如果指针为0（空指针）则为false，任何非空指针都为true。</p>
<p>可以比较两个指针是否相同（== 或 !=），如果两个指针包含的地址是一样的，则两者相同。</p>
<p>如果用了非法的指针来作为判断条件或判断是否相同，结果是<em>未定义的</em>。</p>
<h4 id="void-Pointers"><a href="#void-Pointers" class="headerlink" title="void* Pointers"></a>void* Pointers</h4><p>void*类型是一个可以包含任何类型的对象的地址的特殊类型。如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> obj = <span class="number">3.14</span>, *pdd = &amp;obj;</span><br><span class="line"><span class="type">void</span> *pv = &amp;obj;<span class="comment">//pv can hold a pointer to any type</span></span><br><span class="line">pv = pdd;</span><br></pre></td></tr></table></figure>
<p>但无法通过void*对其指向的对象进行操作，因为void*无法得知对象的具体类型，也就无法解释对象，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cout &lt;&lt; (*pv) &lt;&lt; endl;//error,can&#x27;t operate in the object void* addresses</span></span><br></pre></td></tr></table></figure>
<p>void*更多的是用来处理内存方面的工作。</p>
<h3 id="Understanding-Compound-Type-Declarations"><a href="#Understanding-Compound-Type-Declarations" class="headerlink" title="Understanding Compound Type Declarations"></a>Understanding Compound Type Declarations</h3><h4 id="Defining-Multiple-Variables"><a href="#Defining-Multiple-Variables" class="headerlink" title="Defining Multiple Variables"></a>Defining Multiple Variables</h4><p>如之前所述，引用和指针的定义是跟着变量名字的，因此可以在一个定义中同时定义普通变量，引用和指针。如:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1024</span>, *p = &amp;i, &amp;r = i</span><br></pre></td></tr></table></figure>
<p>&amp;和*符号可以写在类型后面，也可以写在变量前面，如下面两个式子是等效的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* p;</span><br><span class="line"><span class="type">int</span> *p;</span><br></pre></td></tr></table></figure>
<p>但为了避免误解，即认为引用和指针的定义是跟着变量类型的，推荐使用第二种方式。</p>
<h4 id="Pointers-to-Pointers"><a href="#Pointers-to-Pointers" class="headerlink" title="Pointers to Pointers"></a>Pointers to Pointers</h4><p>指针是内存中的一个对象，所以可以创建指针指向另一个指针对象，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span> *pi = &amp;ival;</span><br><span class="line"><span class="type">int</span> **ppi = &amp;pi;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Direct value is &quot;</span> &lt;&lt; ival &lt;&lt; endl;<span class="comment">//Direct value is1024</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Indirect value is &quot;</span> &lt;&lt; *pi &lt;&lt; endl;<span class="comment">//Indirect valueis 1024</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Double indirect value is &quot;</span> &lt;&lt; **ppi &lt;&lt; endl;<span class="comment">//Doubleindirect value is 1024</span></span><br></pre></td></tr></table></figure>
<p>C++并没有限定指针的个数，因此可以进一步定义<code>***pppi</code>等。</p>
<h4 id="Reference-to-Pointers"><a href="#Reference-to-Pointers" class="headerlink" title="Reference to Pointers"></a>Reference to Pointers</h4><p>因为引用并不是一个对象，所以不可能存在引用的指针，但可能存在指针的引用，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line"><span class="type">int</span> *&amp;r = p;</span><br><span class="line">r = &amp;i; <span class="comment">//make p point to i</span></span><br><span class="line">*r = <span class="number">0</span>; <span class="comment">//make i&#x27;s value to 0</span></span><br></pre></td></tr></table></figure>
<p>重点是语句<code>int *&amp;r = p</code>，该语句的操作符比较多，为了很好理解，可以从变量名逐渐向外层读。变量名是r，离变量名最近的操作符是<code>&amp;</code>，因此r是一个引用，外层的操作符是<code>*</code>，因此r是指针的引用，再外层是<code>int</code>，所以r是int指针的引用。</p>
<h2 id="const-Qualifier"><a href="#const-Qualifier" class="headerlink" title="const Qualifier"></a>const Qualifier</h2><p>可以使用const限定词来限制一个变量在初始化后不会被改变。</p>
<h4 id="Initialization-and-const"><a href="#Initialization-and-const" class="headerlink" title="Initialization and const"></a>Initialization and const</h4><p>const限定的变量必须被初始化，初始化的语句可以是任何复杂的表达式，且用于初始化的变量并不一定要是const的。</p>
<p>const变量的初始化如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> kk = <span class="built_in">getSize</span>();</span><br><span class="line"><span class="comment">// const int k; //error, const value must be initialized</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = i;</span><br><span class="line"><span class="type">int</span> j = ci;</span><br></pre></td></tr></table></figure>
<p>其中修饰变量$ci$的const限定符，只是表明变量$ci$不能会修改，用于初始化的$i$仍然能被修改，使用$ci$初始化的j也仍然能被修改。</p>
<h4 id="By-Default-const-Objects-Are-Local-to-a-File"><a href="#By-Default-const-Objects-Are-Local-to-a-File" class="headerlink" title="By Default, const Objects Are Local to a File"></a>By Default, const Objects Are Local to a File</h4><p>对于const限定的变量，大多数编译器在编译的过程中会将相关的代码直接修改为限定的值，如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> bufSize = <span class="number">512</span>;</span><br></pre></td></tr></table></figure>
<p>在代码中使用bufSize的地方在编译后都会被修改为512。</p>
<p>也因此，在不同的文件中，可以定义多个同名的const变量，因为const的作用域是仅局限在本文件中的。普通的非const的变量则不行，它们只能在某一个文件中被定义一次，其他文件中只能声明。</p>
<p>而需要在多个文件中公用一个const变量时则需要用到extern关键字，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//In file Chapter2Const.h</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> bufSize = <span class="built_in">getSize</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//In file Chapter2_VariablesAndBasicType.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> bufSize;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;value is: &quot;</span> &lt;&lt; bufSize; <span class="comment">//value is: 42</span></span><br></pre></td></tr></table></figure>
<h3 id="Reference-to-const"><a href="#Reference-to-const" class="headerlink" title="Reference to const"></a>Reference to const</h3><p>将有限定词const的引用成为<code>const reference</code>，但这个称呼有的时候会造成干扰，实际上应该的表达时reference to const。因为严格意义上，所有的引用本身在初始化后都是无法修改的（无法绑定至别人的变量），所以所有的引用都是const的。</p>
<p>一个const变量的引用必须是const reference，否则就可以通过普通的引用来修改const变量。示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">1024</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r1 = ci;</span><br><span class="line"><span class="comment">// r1 = 42;	  //error,ri is reference to a const variable</span></span><br><span class="line"><span class="comment">// int &amp;r2 = ci; //error, reference to a const variable mustbe const</span></span><br></pre></td></tr></table></figure>
<h4 id="Initialization-and-Reference-to-const"><a href="#Initialization-and-Reference-to-const" class="headerlink" title="Initialization and Reference to const"></a>Initialization and Reference to const</h4><p>在之前的引用章节中，提到引用类型必须与被引用的对象类型一致。</p>
<p>这里将阐述第一个意外，一个const reference可以绑定至任意其他可以被转换的变量和表达式（如非const的变量，字面值，类型不同但可转换的变量等），如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r1 = i;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r2 = <span class="number">42</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r3 = r1 * <span class="number">2</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r4 = dval;</span><br><span class="line"><span class="comment">// int &amp;r5 = i * 2;//error, plain,nonconst reference must match type</span></span><br></pre></td></tr></table></figure>
<p>如语句<code>const int &amp;r4 = dval</code>，编译器实际上将初始化过程转换为了类似于如下的语句：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> temp = dval;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r4 = temp;</span><br></pre></td></tr></table></figure>
<p>因为r4是const reference，所以它不会修改绑定的对象，因此绑定的对象是临时变量也没有问题。而对于普通引用来说，如果执行了同样的操作，那后续对普通引用的操作就变成了操作一个临时变量了。</p>
<h4 id="A-Reference-to-const-May-Refer-to-an-Object-That-is-not-const"><a href="#A-Reference-to-const-May-Refer-to-an-Object-That-is-not-const" class="headerlink" title="A Reference to const May Refer to an Object That is not const"></a>A Reference to const May Refer to an Object That is not const</h4><p>const Refernece只是限定了不能通过该引用来修改绑定的参数，但参数本身是否能修改并不限定，如下代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> &amp;r1 = i;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r2 = i;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;value is &quot;</span> &lt;&lt; r2 &lt;&lt; endl; <span class="comment">//value is 42</span></span><br><span class="line">r1 = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// r2=0;//error,can&#x27;t change const reference</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;value is &quot;</span> &lt;&lt; r2 &lt;&lt; endl; <span class="comment">//value is 0</span></span><br></pre></td></tr></table></figure>
<h3 id="Points-and-const"><a href="#Points-and-const" class="headerlink" title="Points and const"></a>Points and const</h3><p>指向const变量的指针也必须是const类型的指针。对于指向const变量的指针而言，也可以指向非const的变量，但仍然不能绑定至类型不同的变量和字面值。如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="comment">// double *ptr = &amp;pi;//error,pointer must be pointer to const</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> *cptr = &amp;pi;</span><br><span class="line"><span class="comment">// *cptr = 42; //error,can&#x27;t modify const value</span></span><br><span class="line"><span class="type">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line">cptr = &amp;dval; <span class="comment">//can pointer to different variable</span></span><br><span class="line"><span class="comment">// const int *iptr = &amp;dval;//error,can&#x27;t point to differnet type</span></span><br></pre></td></tr></table></figure>
<p>pointer to const只是限制了不能通过该指针对变量进行修改（这一点如同const refernece）。但是对指针本身的值可以修改（reference不行，无论是不是const的）。</p>
<h4 id="const-Pointers"><a href="#const-Pointers" class="headerlink" title="const Pointers"></a>const Pointers</h4><p>如果要限定指针本身的值不被修改，可以使用const Pointers。const Pointer是在指针符号*后加上const。<br>const pointers必须初始化。</p>
<script type="math/tex; mode=display">
\begin{cases}
  \text{pointer to const} & \text{不能通过该指针修改绑定的内容} \\\\
  \text{const pointer} & \text{不能修改指针本身}
\end{cases}</script><p>如下代码所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> errorNum = <span class="number">0</span>, warningNum = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// int *const curErr;//error, must be initialized.</span></span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> curErr = &amp;errorNum;</span><br><span class="line"><span class="comment">// curErr = &amp;warningNum; // can not change pointer value</span></span><br><span class="line">*curErr = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">double</span> p = <span class="number">3.1415</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> *<span class="type">const</span> pip = &amp;pi;</span><br><span class="line"><span class="comment">// pip = &amp;p; //error,can not change pointer value</span></span><br><span class="line"><span class="comment">// *pip = 2.0; //error,can not const variable value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Top-Level-const"><a href="#Top-Level-const" class="headerlink" title="Top-Level const"></a>Top-Level const</h3><p>使用术语<code>top-level const</code>来表示本身是const,使用术语<code>low-level const</code>表示指向的值是const类型。</p>
<p>更宽泛的说，任何类型都可以是top-level const的，复合类型如引用和指针可以是low-level const的。而指针与其他类型不同，可以同时是top-level和low-level的const。</p>
<p>当拷贝top-level const类型的变量时，top-level const属性会被无视。而low-level const则必须满足，即被拷贝的对象和接纳拷贝数据的对象都必须有相同的low-level const属性或者它们的类型可以转换，通常non-const可以转换至const，但是const不能转换至non-const。</p>
<p>top-level const和low-level const的测试代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> pi = &amp;i;  <span class="comment">//pi is top level const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">42</span>;   <span class="comment">//top level const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p2 = &amp;ci; <span class="comment">//low level const</span></span><br><span class="line"><span class="comment">// int *p3 = p2;	//error,differnt low level const,and const can&#x27;t convert to nonconst</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> p4 = p2; <span class="comment">//both top and low level const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r1 = ci;		  <span class="comment">//low level const</span></span><br><span class="line"><span class="comment">// int &amp;r2 = ci;	//error,differnt low level const,and const can&#x27;t convert to nonconst</span></span><br><span class="line">i = ci;			   <span class="comment">//high level const of ci is ignored</span></span><br><span class="line">p2 = p4;		   <span class="comment">//high level of p4 is ignored</span></span><br><span class="line">p2 = &amp;i;		   <span class="comment">//although different low level const,but nonconst can convert to const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r3 = i; <span class="comment">//although different low level const,but nonconst can convert to const</span></span><br></pre></td></tr></table></figure>
<h3 id="constexpr-and-Constant-Expressions"><a href="#constexpr-and-Constant-Expressions" class="headerlink" title="constexpr and Constant Expressions"></a>constexpr and Constant Expressions</h3><p>//TODO</p>
<h2 id="Dealing-with-Types"><a href="#Dealing-with-Types" class="headerlink" title="Dealing with Types"></a>Dealing with Types</h2><h3 id="Type-Aliases"><a href="#Type-Aliases" class="headerlink" title="Type Aliases"></a>Type Aliases</h3><p>类型别名（Type Aliases）是用来给另一个类型定义一个新名字。可以用<code>typedef</code>关键字和<code>using</code>关键字（C++11特性）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> wages; <span class="comment">//wages is a synonym for double</span></span><br><span class="line"><span class="keyword">using</span> base = wages;   <span class="comment">//base is a synonym for wages(double)</span></span><br><span class="line">base b = <span class="number">3.14</span>;</span><br><span class="line">wages w = b;</span><br><span class="line">cout &lt;&lt; b &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; w &lt;&lt; endl;<span class="comment">//3.14  3.14</span></span><br></pre></td></tr></table></figure>
<h4 id="Pointers-const-and-Type-Aliases"><a href="#Pointers-const-and-Type-Aliases" class="headerlink" title="Pointers, const, and Type Aliases"></a>Pointers, const, and Type Aliases</h4><p>也可以对类型的指针使用别名，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> value1 = <span class="number">15</span>, value2 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> *pInt;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">int</span> *cpInt;</span><br><span class="line"><span class="type">const</span> pInt p = &amp;value1;<span class="comment">//equals to int *const p=&amp;value1;</span></span><br><span class="line">cpInt cp = &amp;value1;<span class="comment">//equals to const int *cp=&amp;value1;</span></span><br><span class="line"><span class="comment">// *cp = 20; //error, cp is pointer to const int</span></span><br><span class="line">*p = <span class="number">20</span>; <span class="comment">// p is int* const</span></span><br><span class="line"><span class="comment">// p = &amp;value2; //error,p is int * const</span></span><br></pre></td></tr></table></figure>
<p>需要注意分辨指针别名的类型，如在上例中，定义了<code>pInt</code>类型为pointer to int，那么const pInt还是修饰指针的，即其类型应该是<code>int * const</code>,为const pointer to int</p>
<h3 id="The-auto-Type-Specifier"><a href="#The-auto-Type-Specifier" class="headerlink" title="The auto Type Specifier"></a>The auto Type Specifier</h3><p>auto关键字是C++11的特性，可以使用auto来让编译器自动识别变量的类型。变量的类型是由初始化数值决定的。即使用了auto的话，必须对变量进行初始化。</p>
<ul>
<li>C++是静态语言，所以auto只是让编译器识别出变量类型，但变量类型在运行时仍然是不可改变的。</li>
</ul>
<p>在同一个声明语句中，auto必须指代同一个类型，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = <span class="number">0</span>, *p = &amp;i; <span class="comment">//i is int, p is int*</span></span><br><span class="line"><span class="comment">// auto sz = 0, pi = 3.14; //error, sz is int but pi is double</span></span><br></pre></td></tr></table></figure>
<h4 id="Compound-Types-const-and-auto"><a href="#Compound-Types-const-and-auto" class="headerlink" title="Compound Types,const,and auto"></a>Compound Types,const,and auto</h4><p>在复合类型下，编译器并不能保证auto关键字解析出的数据类型与初始值的类型一致。</p>
<p>如使用引用来初始化auto类型，会得到引用类型绑定的值的类型。而且auto类型会无视top level const,如果要保留的话需要显示的使用const，但当对top level const使用引用时，top level const不会被无视。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>, &amp;r = i;</span><br><span class="line"><span class="keyword">auto</span> a = r; <span class="comment">//a is int not int reference because r is alias for i</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = i, &amp;cr = i; <span class="comment">//ci is const int,cr is const int reference</span></span><br><span class="line"><span class="keyword">auto</span> b = ci;			   <span class="comment">//b is int</span></span><br><span class="line"><span class="keyword">auto</span> d = &amp;i;			   <span class="comment">//d is int*</span></span><br><span class="line"><span class="keyword">auto</span> e = &amp;ci;			   <span class="comment">//e is const int *</span></span><br><span class="line"><span class="keyword">auto</span> &amp;g = ci;			   <span class="comment">// g is const int reference</span></span><br><span class="line"><span class="comment">// auto &amp;h=42;//error</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> &amp;h = <span class="number">42</span>; <span class="comment">//can bind const reference to literal</span></span><br><span class="line"><span class="keyword">auto</span> &amp;m = i, k = ci;	<span class="comment">//although i is int while ci is const int,but the top-level constis ignored</span></span><br><span class="line"><span class="comment">// auto &amp;n = i, *p2 = &amp;ci; //error,while using reference, top-level const is not ignored</span></span><br></pre></td></tr></table></figure>
<p>有几个语句需要特别注意，首先是<code>auto e = &amp;ci</code>，这里对const int的ci使用了引用，所以const保留，即e类型为const int，同理还有<code>auto &amp;g = ci</code>,g也同样是const int reference。</p>
<p>还有语句<code>auto &amp;m = i, k = ci</code>，虽然i和ci的类型不同，但是因为top level const被无视，所以这里仍然可以放在一起被定义。而<code>auto &amp;n = i, *p2 = &amp;ci</code>中因为对ci使用了引用符号，所以top level const被保留，i和ci类型不同，因此无法在一起定义。</p>
<h3 id="The-decltype-Type-Specifier"><a href="#The-decltype-Type-Specifier" class="headerlink" title="The decltype Type Specifier"></a>The decltype Type Specifier</h3><p>有时希望编译器可以根据一个表达式的返回值来自动判定一个变量的类型，但却不希望用表达式的返回值来初始化变量。这时候可以使用<code>decltype</code>关键字，该关键字是C++11的特性，使用如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(<span class="built_in">getSize_Literal</span>()) size;</span><br></pre></td></tr></table></figure>
<p>但需要特别说明的，当decltype传入的是<em>变量</em>时，decltype对top level const和引用的处理与auto不一样，auto默认会无视这些，但是decltype则全部保留，如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">0</span>, &amp;cj = ci;</span><br><span class="line"><span class="keyword">decltype</span>(ci) x = <span class="number">0</span>; <span class="comment">// x is const int</span></span><br><span class="line"><span class="keyword">auto</span> xx = ci;<span class="comment">//xx is int</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) y = x; <span class="comment">//y is int reference</span></span><br><span class="line"><span class="comment">// decltype(cj) yy; //yy is int reference, must be initialized</span></span><br></pre></td></tr></table></figure>
<p>上例中的y会被认为是int的引用所以必须要初始化，这也是C++语言中唯一的引用类型不表现为另一个变量的别名，而真的将其视为引用类型的情况。</p>
<h4 id="decltype-and-Reference"><a href="#decltype-and-Reference" class="headerlink" title="decltype and Reference"></a>decltype and Reference</h4><p>当decltype传入的是表达式时，如果表达式返回的值可以作为赋值操作的左参数，那么decltype的判断类型将是返回类型的引用，如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>, *p = &amp;i, &amp;r = i;</span><br><span class="line"><span class="keyword">decltype</span>(r) b = i;  <span class="comment">//b is int reference</span></span><br><span class="line"><span class="keyword">decltype</span>(r + <span class="number">0</span>) bb; <span class="comment">//bb is int,because r + 0 is a expression and result is literal</span></span><br><span class="line"><span class="keyword">decltype</span>(p) c;		<span class="comment">// c is int pointer</span></span><br><span class="line"><span class="comment">// decltype(*p) cc;//error,*p is a expression and *p can be the left hand side of assignment,cc is int&amp;</span></span><br></pre></td></tr></table></figure>
<p>如上式，如果想通过一个引用类型返回普通类型，将其写成返回字面值的表达式即可。且如上式中，<code>p</code>是参数，所以判断的类型是参数本身的类型即int指针，而*p是表达式，且返回的结果是int，因此最终结果是int &amp;</p>
<p>注意普通函数返回是字面值，如下函数看起来返回的是一个变量，但实际上是该变量值的字面值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getSize_Int</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此形如<code>decltype(getSize_Int()) size;</code>,size的类型为Int,因为返回的字面值无法作为左参数。</p>
<p>另外在decltype中，如果普通参数外有额外的括号，则也会被认为是表达式，如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(i) d; <span class="comment">// d is uninitialized int</span></span><br><span class="line"><span class="comment">// decltype((i)) dd;//error,(i) is expression and i can be left hand side, so dd is int&amp;</span></span><br></pre></td></tr></table></figure>
<h2 id="Defining-Our-Own-Data-Structures"><a href="#Defining-Our-Own-Data-Structures" class="headerlink" title="Defining Our Own Data Structures"></a>Defining Our Own Data Structures</h2><h3 id="Defining-the-Sales-Data-Type"><a href="#Defining-the-Sales-Data-Type" class="headerlink" title="Defining the Sales_Data Type"></a>Defining the Sales_Data Type</h3><p>在类与结构体的定义主体后可直接声明对象，虽然通常不这样做。如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span></span><br><span class="line">&#123;</span><br><span class="line">	std::string bookNo;</span><br><span class="line">	<span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">	<span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125; accum, trans, *salesptr;</span><br></pre></td></tr></table></figure>
<p>但通常将类与结构体的定义和相关对象的声明分开，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span></span><br><span class="line">&#123;</span><br><span class="line">	std::string bookNo;</span><br><span class="line">	<span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">	<span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Sales_data accum, trans, *salesptr;</span><br></pre></td></tr></table></figure>
<h4 id="Class-Data-Menbers"><a href="#Class-Data-Menbers" class="headerlink" title="Class Data Menbers"></a>Class Data Menbers</h4><p>结构体中的变量如果没有初始值，将会默认初始化。</p>
<p>而如同<code>double revenue = 0.0</code>这样在类的内部定义变量时直接赋予初值，称为类内初始化（in-class initializer）。这也是C++11的特性。</p>
<h3 id="Using-the-Sales-data-Class"><a href="#Using-the-Sales-data-Class" class="headerlink" title="Using the Sales_data Class"></a>Using the Sales_data Class</h3><p>无重要内容</p>
<h3 id="Writing-Our-Own-Header-Files"><a href="#Writing-Our-Own-Header-Files" class="headerlink" title="Writing Our Own Header Files"></a>Writing Our Own Header Files</h3><p>通常类是在函数外定义的（在19.7节可以看到在函数内定义类的方法）。</p>
<p>为了保证类的定义在每个文件中是相同的，在头文件中定义类。通常来说头文件的名字与其中定义的类名字相同。</p>
<p>因为头文件在多次引用（include），所以必须有一个方式可以保证即使头文件多次被引用，类的定义也不会重复。</p>
<h3 id="A-Brief-Introduction-to-the-Preprocessor"><a href="#A-Brief-Introduction-to-the-Preprocessor" class="headerlink" title="A Brief Introduction to the Preprocessor"></a>A Brief Introduction to the Preprocessor</h3><p>通常保证头文件可以被安全多次引用的方法是预处理器（preprocessor）。C++的预处理器继承自C语言，是一个在编译器前运行的程序，它可以修改部分源码内容。</p>
<p>当预处理器看到<code>#include xxx</code>时，它会将<code>#include xxx</code>替换为指定头文件中的内容。 </p>
<p>C++使用预处理器来定义文件保护符（Header guards），预处理器变量有两个可能的状态，定义（define）和未定义（undefined）。</p>
<p><code>#define</code>关键字加上一个名字可直接将这个名字定义为预处理变量。同样，预处理器还有两个关键字来判断变量是否被定义，<code>#ifndef</code>和<code>#ifdef</code>，前者在变量未定义时为true，后者在变量定义时为true。</p>
<blockquote>
<p>注意#define的作用域是文件，所以使用该方法只能保证在同一个文件内，不会多次include同一个文件。但无法保证整个程序只include一次。如程序有多个CPP文件，每个文件都include某h文件，且该文件内有定义（非声明）参数，那么同样会造成重复定义。<br>因此，尽量不要在头文件中进行任何函数或变量的定义。除非是内联函数的定义。</p>
</blockquote>
<p>当<code>#ifndef</code>和<code>#ifdef</code>为true的情况下，它们后面的代码会一直执行，直到遇到<code>#endif</code>关键字。</p>
<p>如一个带有文件保护符的头文件如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SALES_DATA_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SALES_DATA_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span></span><br><span class="line">&#123;</span><br><span class="line">    std::string bookNo;</span><br><span class="line">    <span class="type">unsigned</span> units_sold;</span><br><span class="line">    <span class="type">double</span> revenue;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>在第一次引入该头文件时，还没有定义过<code>SALES_DATA_H</code>，所以<code>ifndef</code>为true。但第二次引入时因为<code>#define</code>语句的执行，<code>ifndef</code>为false，即之后的语句不会再被执行，也就不会有类的重复定义。</p>
<p>预处理器变量的作用域与C++变量的作用域不同，预处理器变量的名称必须在整个程序中都是独一无二的。通常来说为了避免重复，都根据头文件的名字对预处理器变量取名，且一般都是全大写。</p>
<ul>
<li>虽然不是强制规定，但建议每个头文件都带有文件保护符。</li>
</ul>
<div class="note info simple"><p>引用：</p>
<ol>
<li><em>Cpp Primer</em> 5th Aug.2012</li>
<li><a href="CPPPrimer-Chapter2-Notes/&quot;https://kb.iu.edu/d/aepu&quot;">Latin-1字符集</a></li>
</ol>
</div>
<hr>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>计算机语言</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>《C++ Primer》 第三章笔记</title>
    <url>/CPPPrimer-Chapter3-Notes/</url>
    <content><![CDATA[<p>《C++ Primer》 第三章笔记。</p>
<p>第二章介绍的是C++中的内建类型，这一章则是会介绍C++标准库中的一些重要类型。</p>
<p><img src="CPPPrimer-Chapter3-Notes/Ch3.png" alt="第三章内容"></p>
<span id="more"></span>
<h1 id="Chapter-3-String-Vectors-And-Arrays"><a href="#Chapter-3-String-Vectors-And-Arrays" class="headerlink" title="Chapter 3 String, Vectors, And Arrays"></a>Chapter 3 String, Vectors, And Arrays</h1><h2 id="Namespace-using-Declarations"><a href="#Namespace-using-Declarations" class="headerlink" title="Namespace using Declarations"></a>Namespace using Declarations</h2><p>可以使用<code>using &lt;namespace&gt;::&lt;name&gt;</code>的方式定义在命名空间中的一个函数或变量，注意一个<code>using</code>命令符只能对应一个名字，如下式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">voidTestNamespace</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">voidTestNamespace</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">voidTestNamespace</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter two number&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> v1, v2;</span><br><span class="line">    cin &gt;&gt; v1 &gt;&gt; v2;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The sum is &quot;</span> &lt;&lt; v1 &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; v2 &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; v1 + v2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Header-Should-not-include-using-Declarations"><a href="#Header-Should-not-include-using-Declarations" class="headerlink" title="Header Should not include using Declarations"></a>Header Should not include using Declarations</h3><p>如之前所述，预处理器实际上是把<code>#incldue</code>语句替换为头文件中的内容，所以如果在头文件中使用了using声明，那么所有引用了该头文件的文件都会使用该using声明。</p>
<p>这可能会造成意想不到的情况发生，所以应该尽量避免在头文件中使用using声明。</p>
<h2 id="Library-string-Type"><a href="#Library-string-Type" class="headerlink" title="Library string Type"></a>Library string Type</h2><p>使用C++标准库的string前，应该首先引入string，如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br></pre></td></tr></table></figure>
<h3 id="Defining-and-Initializing-strings"><a href="#Defining-and-Initializing-strings" class="headerlink" title="Defining and Initializing strings"></a>Defining and Initializing strings</h3><p>初始化String的方法如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>实例代码</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>string s1</td>
<td>默认的初始化，s1是空字符串</td>
</tr>
<tr>
<td>string s2</td>
<td>s2是s1的拷贝</td>
</tr>
<tr>
<td>string s2 = s1</td>
<td>与上式相同</td>
</tr>
<tr>
<td>string s3(“value”)</td>
<td>s3是字符串字面值的拷贝，不包括最后的空字符</td>
</tr>
<tr>
<td>string s3 = “value”</td>
<td>与上式相同</td>
</tr>
<tr>
<td>string s4(n,’c’)</td>
<td>用n个’c’来初始化s4</td>
</tr>
</tbody>
</table>
</div>
<p>如果用string字面值来初始化string类型，字面值最后的空字符是不会被拷贝进string的，如上表中，<code>&quot;value&quot;</code>是字面值，其长度为6，而通过<code>&quot;value&quot;</code>初始化的s3，长度为5，如下代码验证：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s3</span><span class="params">(<span class="string">&quot;value&quot;</span>)</span></span>;</span><br><span class="line">string s4 = <span class="string">&quot;value&quot;</span>;</span><br><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;value&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(str) / <span class="built_in">sizeof</span>(*str) &lt;&lt; endl; <span class="comment">//6</span></span><br><span class="line">cout &lt;&lt; s3.<span class="built_in">length</span>() &lt;&lt; endl;                <span class="comment">//5</span></span><br><span class="line">cout &lt;&lt; s4.<span class="built_in">length</span>() &lt;&lt; endl;                <span class="comment">//5</span></span><br></pre></td></tr></table></figure>
<h4 id="Direct-and-Copy-Forms-of-Initialization"><a href="#Direct-and-Copy-Forms-of-Initialization" class="headerlink" title="Direct and Copy Forms of Initialization"></a>Direct and Copy Forms of Initialization</h4><p>当使用<code>=</code>进行初始化的时候，实际上编译器执行的是<code>拷贝初始化(Copy Initialize)</code>，当不使用<code>=</code>时，是<code>直接初始化（Direct Initialization）</code>。</p>
<p>上表中，<code>string s2 = s1</code>和<code>string s3 = &quot;value&quot;</code>是拷贝初始化，其他的都是直接初始化</p>
<h3 id="Operations-on-strings"><a href="#Operations-on-strings" class="headerlink" title="Operations on strings"></a>Operations on strings</h3><h4 id="Reading-and-Writing-strings"><a href="#Reading-and-Writing-strings" class="headerlink" title="Reading and Writing strings"></a>Reading and Writing strings</h4><p>下表为可以对string进行的操作：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>操作代码</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>os &lt;&lt; s</td>
<td>输出结果到os,返回os</td>
</tr>
<tr>
<td>is &gt;&gt; s</td>
<td>is的结果到s，返回is。is的数值以whitespace分隔</td>
</tr>
<tr>
<td>getline(is,s)</td>
<td>读取is中的一行，返回is</td>
</tr>
<tr>
<td>s.empty()</td>
<td>s是否为空</td>
</tr>
<tr>
<td>s.size()</td>
<td>s中的字符数</td>
</tr>
<tr>
<td>s.length()</td>
<td>s中的字符数，与size是同义api，返回的结果相同</td>
</tr>
<tr>
<td>s[n]</td>
<td>去s中index为n的字符</td>
</tr>
<tr>
<td>s1 + s2</td>
<td>返回一个新string,值为s1和s2的结合</td>
</tr>
<tr>
<td>s1 = s2</td>
<td>将s1中的值替换为s2的值</td>
</tr>
<tr>
<td>s1 == s2</td>
<td>s1和s2是否相同</td>
</tr>
<tr>
<td>s1 != s2</td>
<td>s1和s2是否不同</td>
</tr>
<tr>
<td>&lt;,&lt;=,&gt;,&gt;=</td>
<td>s1和s2的大小，根据字典规则排序</td>
</tr>
</tbody>
</table>
</div>
<p>其中<code>is &gt;&gt; s</code>是以whitespace分隔的（空格，换行，tab），当读到whitespace时一个读取便结束（不包括whitespace），如下所示</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s1, s2;</span><br><span class="line">cin &gt;&gt; s1 &gt;&gt; s2;                <span class="comment">//input is &quot;   Hello World!    &quot;</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;s1 is &quot;</span> &lt;&lt; s1 &lt;&lt; endl; <span class="comment">//Hello</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;s2 is &quot;</span> &lt;&lt; s2 &lt;&lt; endl; <span class="comment">//World!</span></span><br></pre></td></tr></table></figure>
<p>可以看到用cin的话，是无法读取输入中的空格的，如果需要读取空格，建议使用<code>getline</code>，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string line;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">getline</span>(cin, line))</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;result is &quot;</span> &lt;&lt; line &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">$ ./a.exe</span></span><br><span class="line"><span class="comment">123  456   789</span></span><br><span class="line"><span class="comment">result is 123  456   789</span></span><br><span class="line"><span class="comment">    Hello World    </span></span><br><span class="line"><span class="comment">result is     Hello World </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><code>getline</code>以换行符进行分割，在Windows中输入回车即可，当getline读取到换行符后即会停止，读取的结果不包含换行符，即如果一行的开头便是换行符，则这次读取的结果为空字串。</p>
<p>又因为<code>getline</code>返回的也是stream类型，所以同样可以作为判断条件。</p>
<h4 id="The-string-size-type-Type"><a href="#The-string-size-type-Type" class="headerlink" title="The string::size_type Type"></a>The string::size_type Type</h4><p>string.size()方法返回字符串中的字符数，但是返回的结果并不是int或者unsigned，而是<code>string::size_type</code>。</p>
<p>string类和其他大部分的库类都定义了伴侣类型(companion type)，string::size_type就是其中一个。int之类的内建类型是硬件相关的，即不同的硬件会有不同的结果，而伴侣类型则是机器不相干的实现。</p>
<p>string::size_type内部的细节书中未提及，但是它是大到足够容纳任何长度字符串的unsigned类型。也因为是unsigned，所以要注意表达式中signed int到unsigned int的隐式转换，如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">-3</span>;</span><br><span class="line"><span class="keyword">if</span> (n &lt; s3.<span class="built_in">length</span>())</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;n is smaller&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s3 length is smaller&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">s3 length is smaller&quot;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>直觉上，n是负数，而s3的长度必然是正数，所以n一定小于s3的长度，但实际上因为n被转换为了unsigned int，所以是一个非常大的数（$2^32-3$）。因此最终的结果是s3的长度更小。</p>
<p>在C++11中，可以通过auto关键字来避免每次都手动的输入伴侣类型（通常比内建类型长，所以相对不太容易输入），如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> len = line.<span class="built_in">size</span>()</span><br></pre></td></tr></table></figure>
<h4 id="Adding-Literals-and-strings"><a href="#Adding-Literals-and-strings" class="headerlink" title="Adding Literals and strings"></a>Adding Literals and strings</h4><p>string标准库允许将字符字面值和字符串字面值转换为string字面值。</p>
<p>但如果需要用<code>+</code>操作符将字面值和string类型合并的时候，必须保证操作符的至少一端是string类型，如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s1 = <span class="string">&quot;hello&quot;</span>, s2 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">string s3 = s1 + <span class="string">&#x27;,&#x27;</span> + s2 + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">cout &lt;&lt; s3;</span><br><span class="line"><span class="comment">// string s4 = &quot;Hello&quot; + &quot;world&quot;;  //error,both sides of + are literals</span></span><br><span class="line">string s4 = s1 + <span class="string">&quot;,&quot;</span> + s2; <span class="comment">//ok, s1 + &quot;,&quot; return string</span></span><br></pre></td></tr></table></figure>
<h3 id="Dealing-with-the-Characters-in-a-string"><a href="#Dealing-with-the-Characters-in-a-string" class="headerlink" title="Dealing with the Characters in a string"></a>Dealing with the Characters in a string</h3><p>在标准库的cctype头文件中定义了许多关于字符的函数。</p>
<blockquote>
<p>cctype实际上是从C标准库中继承来的，在c中命名为<code>ctype.h</code>。通常而言，在C中的标准库会被命名为<code>c&lt;Name&gt;.h</code>，如果这个库被移植到到C++，则会被命名为<code>cc&lt;Name&gt;</code>。<br>C和C++在很大程度上是通用的，在C++的移植版本中主要变换是将所有的函数和变量会被移到std命名空间下。如果直接使用C版本的标准库也是可以运行的，但是推荐还是使用C++版本，这样可以保证标准库命名空间的统一。</p>
</blockquote>
<p>cctype中常用的函数如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>代码实例</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>isalnum (c)</td>
<td>c是否是字母或者数字</td>
</tr>
<tr>
<td>isalpha (c)</td>
<td>c是否是字母</td>
</tr>
<tr>
<td>iscntrl (c)</td>
<td>c是否是控制字符</td>
</tr>
<tr>
<td>isdigit (c)</td>
<td>c是否是数字</td>
</tr>
<tr>
<td>isgraph (c)</td>
<td>c是否是可显示的（不包括空格）</td>
</tr>
<tr>
<td>islower (c)</td>
<td>c是否是小写的</td>
</tr>
<tr>
<td>isprint (c)</td>
<td>c是否是可显示的（包括空格）</td>
</tr>
<tr>
<td>isupper (c)</td>
<td>c是否是大写的</td>
</tr>
<tr>
<td>ispunct (c)</td>
<td>c是否是标点符号</td>
</tr>
<tr>
<td>isspace (c)</td>
<td>c是否是空白字符（空格，tab，vertical tab,返回，换行符等）</td>
</tr>
<tr>
<td>isxdigit (c)</td>
<td>c是否是十六进制字符</td>
</tr>
<tr>
<td>tolower(c)</td>
<td>将c从大写切换为小写</td>
</tr>
<tr>
<td>toupper(c)</td>
<td>将c从小写切换为大写</td>
</tr>
</tbody>
</table>
</div>
<h4 id="Processing-Every-Character-Use-Range-Based-for"><a href="#Processing-Every-Character-Use-Range-Based-for" class="headerlink" title="Processing Every Character? Use Range-Based for"></a>Processing Every Character? Use Range-Based for</h4><p>可以使用<code>Range for</code>来改变字符串中的每个字符，<code>Range for</code>结构如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (declaration : expression)</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure>
<p>如需要判断字符串中的每个字符是否是标点符号，可以通过如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;Hello World!!!&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">decltype</span>(s.<span class="built_in">size</span>()) punct_cnt = <span class="number">0</span>; <span class="comment">//type is size_t</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> c : s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ispunct</span>(c))</span><br><span class="line">        ++punct_cnt;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;There are &quot;</span> &lt;&lt; punct_cnt &lt;&lt; <span class="string">&quot; punctuation characters in &quot;</span> &lt;&lt; s &lt;&lt;endl;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">There are 3 punctuation characters in Hello World!!!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>在使用range for的时候，为了避免数值的拷贝，可以使用引用，并且在只访问数据的情况下，为了避免对值进行修改，可以使用const reference，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;c : s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ispunct</span>(c))</span><br><span class="line">        ++punct_cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Using-a-Range-for-to-Change-the-Characters-in-a-string"><a href="#Using-a-Range-for-to-Change-the-Characters-in-a-string" class="headerlink" title="Using a Range for to Change the Characters in a string"></a>Using a Range for to Change the Characters in a string</h4><p><code>Range for</code>实际上是返回值的拷贝，如上节的例子中在每次迭代的情况下，是将str中下个字符拷贝至c中。因此如果需要通过Range for修改string中的数值，就需要使用引用，如下是将字符串中的每个字符转换为大写的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c : s)</span><br><span class="line">&#123;</span><br><span class="line">    c = <span class="built_in">toupper</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;result is &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">HELLO WORLD!!!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="Using-a-Subsctipt-for-Iteration"><a href="#Using-a-Subsctipt-for-Iteration" class="headerlink" title="Using a Subsctipt for Iteration"></a>Using a Subsctipt for Iteration</h4><p>可以使用下标（<code>[&lt;index&gt;]</code>）取string中的每个字符。使用下标返回的并不是拷贝，而直接是string中的数值，所以可以直接进行修改，并不需要引用，如下是使用下标来将每个字符改为大写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;Hello World!!!&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">decltype</span>(s.<span class="built_in">size</span>()) i = <span class="number">0</span>; i != s.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    s[i] = <span class="built_in">toupper</span>(s[i]);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;result is &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">HELLO WORLD!!!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="Library-vector-Type"><a href="#Library-vector-Type" class="headerlink" title="Library vector Type"></a>Library vector Type</h2><p>Vector是对象的集合，所有的对象都必须有相同的类型。Vector并不是一个具体的类，而是一个类模板。</p>
<p>模板可以被视为是编译器生成函数或者类的指导，编译器使用模板生成函数和类的过程称为<code>实例化（Instantiation）</code>。当使用模板时，必须提供想要编译器创建的函数或类类型。在模板后跟上一对尖括号，在尖括号内部加上想要创建的类型，如<code>vector&lt;int&gt;</code>。</p>
<p>Vector中可以容纳绝大部分的类型，无论是内建类型还是自定义的类型，但是不能包含引用，严格严格来说引用并非是对象。Vector中的对象也可以是另一个Vector，在老版本中嵌套Vector的尖括号中必须带有空格，如<code>vector&lt;vector&lt;int&gt; &gt;</code>，但在C++11中不需要如此，直接写成<code>vector&lt;vector&lt;int&gt;&gt;</code>即可。</p>
<h3 id="Defining-and-Initializing-vectors"><a href="#Defining-and-Initializing-vectors" class="headerlink" title="Defining and Initializing vectors"></a>Defining and Initializing vectors</h3><h4 id="Value-Initialization-and-Default-Initialization"><a href="#Value-Initialization-and-Default-Initialization" class="headerlink" title="Value Initialization and Default Initialization"></a>Value Initialization and Default Initialization</h4><p>首先要说明值初始化（Value Initialization）和默认初始化（Default Initialization）的概念。</p>
<ol>
<li>在默认初始化情况下，如果变量声明在函数外，一个变量将获得其初始值。而在函数内，内建类型的值是未定义的。</li>
<li>在值初始化情况下，无论变量声明在函数内外，它都会获得其初始值。</li>
</ol>
<p>定义和初始化vector的方法如下所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>示例代码</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>vector<T> v1</td>
<td>vector中的元素类型为T，v1为空</td>
</tr>
<tr>
<td>vector<T> v2(v1)</td>
<td>v2中包含有v1中每个元素的拷贝</td>
</tr>
<tr>
<td>vector<T> v2 = v1</td>
<td>与上式一样</td>
</tr>
<tr>
<td>vector<T> v3(n,val)</td>
<td>v3中有n个元素，每个元素的值都是val</td>
</tr>
<tr>
<td>vector<T> v4(n)</td>
<td>v4中有n个元素，每个元素都是T的默认值</td>
</tr>
<tr>
<td>vector<T> v5{a, b, c}</td>
<td>如果a,b,c与T类型匹配，则v5包含a,b,c三个元素（不匹配的情况在下面有详细说明）。</td>
</tr>
<tr>
<td>vector<T> v5 = {a, b, c}</td>
<td>与上式相同</td>
</tr>
</tbody>
</table>
</div>
<p>vector的创建同样分类为拷贝初始化和直接初始化，定义和string中的初始化一样，如<code>vector&lt;T&gt; v2 = v1</code>和<code>vector&lt;T&gt; v5 = &#123;a, b, c&#125;</code>为拷贝初始化，其他的都为直接初始化。</p>
<p>在初始化中，如果使用的是括号(<code>()</code>)，则括号中的值为vector中元素的数量，所以括号内的值必须是自然数。如果使用的是大括号（<code>&#123;&#125;</code>），则会尝试将其中的值作为vector的元素，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intList_1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="comment">// vector&lt;string&gt; intList_1(&quot;abc&quot;);//error</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; intList_2&#123;<span class="number">10</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intList_3</span><span class="params">(<span class="number">10</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; intList_4&#123;<span class="number">10</span>, <span class="number">1</span>&#125;;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;vector_1 size is &quot;</span> &lt;&lt; intList_1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;vector_2 size is &quot;</span> &lt;&lt; intList_2.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;vector_3 size is &quot;</span> &lt;&lt; intList_3.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;vector_4 size is &quot;</span> &lt;&lt; intList_4.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">vector_1 size is 10</span></span><br><span class="line"><span class="comment">vector_2 size is 1</span></span><br><span class="line"><span class="comment">vector_3 size is 10</span></span><br><span class="line"><span class="comment">vector_4 size is 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>式子<code>vector&lt;T&gt; v4(n)</code>中，进行的是值初始化。类型T必须含有默认初始化值，否则vector的初始化会失败。</p>
</blockquote>
<p>但如果使用的是大括号，而且大括号内的值与vector中的元素类型不匹配，那么就无法将其作为vector中的元素，编译器会尝试将大括号替换为括号再次解析，如果仍然解析失败则会编译错误。如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;string&gt; v5&#123;<span class="string">&quot;hi&quot;</span>&#125;;</span><br><span class="line"><span class="comment">// vector&lt;string&gt; v6(&quot;hi&quot;);//Error, value in parentheses must be digit</span></span><br><span class="line">vector&lt;string&gt; v7&#123;<span class="number">10</span>&#125;;</span><br><span class="line">vector&lt;string&gt; v8&#123;<span class="number">10</span>, <span class="string">&quot;hi&quot;</span>&#125;; <span class="comment">//try to analyse as parentheses</span></span><br><span class="line"><span class="comment">// vector&lt;string&gt; v9&#123;10, 20&#125;;//Error, analyse as parenthese still not work</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v5 size is &quot;</span> &lt;&lt; v5.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v7 size is &quot;</span> &lt;&lt; v7.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v8 size is &quot;</span> &lt;&lt; v8.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">v5 size is 1</span></span><br><span class="line"><span class="comment">v7 size is 10</span></span><br><span class="line"><span class="comment">v8 size is 10</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="Adding-Elements-to-a-vector"><a href="#Adding-Elements-to-a-vector" class="headerlink" title="Adding Elements to a vector"></a>Adding Elements to a vector</h3><p>使用<code>push_back</code>方法来增加vector中的元素。</p>
<p>在标准库中vector的实现下，vector的扩张是很高效的，所以通常来说不需要用括号的初始化方法来定义vector的大小，有的时候定义vector的大小反而会造成性能方面的影响。除了所有的元素都是相同值的情况，否则尽量避免使用括号的初始化方法。</p>
<h4 id="Programming-Implications-of-Adding-Elements-to-a-vector"><a href="#Programming-Implications-of-Adding-Elements-to-a-vector" class="headerlink" title="Programming Implications of Adding Elements to a vector"></a>Programming Implications of Adding Elements to a vector</h4><p>在vector的循环中要注意使vector大小发生变化的操作。</p>
<p>如果操作时关于改vector的大小的，则无法使用在string节提到的<code>range for</code>来遍历vector。</p>
<h3 id="Other-vector-Operations"><a href="#Other-vector-Operations" class="headerlink" title="Other vector Operations"></a>Other vector Operations</h3><p>对vector的操作如下表，绝大部分的含义与之前介绍的string的操作一样。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>代码示例</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>v.empty()</td>
<td>返回vector是否为空</td>
</tr>
<tr>
<td>v.size()</td>
<td>返回vector中元素的个数</td>
</tr>
<tr>
<td>v.push_back(t)</td>
<td>将一个元素加到vector最后，元素的值与t相同</td>
</tr>
<tr>
<td>v[n]</td>
<td>访问下标为n的元素</td>
</tr>
<tr>
<td>v1 = v2</td>
<td>将v1中的元素都替换为v2中元素的拷贝</td>
</tr>
<tr>
<td>v1 = {a,b,c}</td>
<td>将v1中的元素都替换为大括号内的元素</td>
</tr>
<tr>
<td>v1 == v2</td>
<td>v1与v2是否完全相同（元素个数，顺序，数值都相同）</td>
</tr>
<tr>
<td>v1 != v2</td>
<td>v1和v2是否不同</td>
</tr>
<tr>
<td>&lt;, &lt;=, &gt;, &gt;=</td>
<td>顺序排列，按字典顺序</td>
</tr>
</tbody>
</table>
</div>
<p>与string类似，size()操作返回的也是size_type，注意这里的size_type是属于实例化后的vector，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vector::size_type size = 1; //error</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::size_type size = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>与string类似，下标操作[]也必须注意元素的存在，如果通过下标访问了不存在的元素，称为缓存区溢出错误（Buffer overflow）。通常可以通过使用range for来避免下标操作，也进而避免了缓存区溢出错误。</p>
</blockquote>
<h2 id="Introducing-Iterators"><a href="#Introducing-Iterators" class="headerlink" title="Introducing Iterators"></a>Introducing Iterators</h2><p>除了Vector，标准库还定义了其他的容器（Container），所有的容器都包含迭代器操作（Iterator），但仅有部分的容器支持下标操作（<code>[]</code>）。</p>
<p>严格意义上，string并不是容器，但是string提供了非常多的容器操作。</p>
<p>迭代器有的像指针，同样提供了对象的非直接访问，而且同样也有合法和非法迭代器。一个合法的迭代器应该指向容器中一个元素或者指向容器最后的元素尾部的位置（position on past the last element）。</p>
<h3 id="Using-Iterators"><a href="#Using-Iterators" class="headerlink" title="Using Iterators"></a>Using Iterators</h3><p>通常来说，支持迭代器的类型都有两个成员迭代器，<code>begin</code>和<code>end</code>，<code>begin</code>指向容器中的第一个元素，<code>end</code>指向最后的元素尾部的位置，所以<code>end</code>指向的位置实际上并不是任何元素，<code>end</code>是一个用来标记容器尾部的指示器，通常将<code>end</code>迭代器值称为<code>off-the-end</code>迭代器。</p>
<p>如果一个容器是空的，则其<code>begin</code>和<code>end</code>指向的是同一个位置，都是<code>off-the-end</code>迭代器。</p>
<h4 id="Iterator-Operations"><a href="#Iterator-Operations" class="headerlink" title="Iterator Operations"></a>Iterator Operations</h4><p>迭代器只支持部分操作，如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>代码实例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>*iter</td>
<td>返回迭代器指向的元素的引用</td>
</tr>
<tr>
<td>iter-&gt;mem</td>
<td>访问迭代器指向元素中的成员mem，等同于(*item).mem</td>
</tr>
<tr>
<td>++iter</td>
<td>迭代器指向下一个元素的位置</td>
</tr>
<tr>
<td>—iter</td>
<td>迭代器指向上一个元素的位置</td>
</tr>
<tr>
<td>iter1 == iter2</td>
<td>判断两个迭代器是否相同，两个迭代器都指向同一元素或都指向<code>off-the-end</code>时相同</td>
</tr>
<tr>
<td>iter1 != iter2</td>
<td>判断两个迭代器是否不同</td>
</tr>
</tbody>
</table>
</div>
<p>因为end返回的并不是元素，所以不能被解引用或再使用<code>++</code>操作符。</p>
<p>因为并非所有的容器类都支持下标运算，且不一定支持关系比较，如<code>&lt;</code>和<code>&gt;</code>，所以C++程序会推荐使用迭代器并使用<code>!=</code>来进行循环操作，因为这样的实现可以适应任何的容器。</p>
<p>如下是两个等效的代码，一个对string使用下标，一个对string使用迭代器：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;Hello World!!!&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">decltype</span>(s.<span class="built_in">size</span>()) i = <span class="number">0</span>; i != s.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    s[i] = <span class="built_in">toupper</span>(s[i]);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;result is &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">s = <span class="string">&quot;Hello World!!!&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = s.<span class="built_in">begin</span>(); i != s.<span class="built_in">end</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    (*i) = <span class="built_in">toupper</span>(*i);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;result is &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">result is HELLO WORLD!!!</span></span><br><span class="line"><span class="comment">result is HELLO WORLD!!!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="Iterator-Types"><a href="#Iterator-Types" class="headerlink" title="Iterator Types"></a>Iterator Types</h4><p>像<code>size_type</code>一样，含有迭代器的类型也定义了相应的同伴类型，<code>iterator</code>和<code>const_iterator</code>，且类型是属于实例化后的类，如<code>vector&lt;int&gt;</code>。iterator和const_iterator的关系如同pointer和pointer to const，后者只能读取指向的元素，但不能修改，而且对于const对象来说，必须使用const_iterator，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v1&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">const</span> vector&lt;string&gt; v2&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator v1Iter = v1.<span class="built_in">begin</span>();</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::const_iterator v1Iter2 = v1.<span class="built_in">begin</span>();</span><br><span class="line"><span class="type">const</span> vector&lt;<span class="type">int</span>&gt;::iterator v1Iter3 = v1.<span class="built_in">begin</span>();</span><br><span class="line"><span class="comment">// (*v1Iter2) = 2;//error,can&#x27;t modify value through const_iterator</span></span><br><span class="line">++v1Iter2;</span><br><span class="line"><span class="comment">// ++v1Iter3; //can&#x27;t modify const iterator</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// vector&lt;string&gt;::iterator v2Iter = v2.begin(); //error, must beconst_iterator</span></span><br><span class="line">vector&lt;string&gt;::const_iterator v2Iter2 = v2.<span class="built_in">begin</span>();</span><br><span class="line"><span class="comment">// const vector&lt;string&gt;::iterator v2Iter3 = v2.begin(); //error,still mustbe const_iterator</span></span><br></pre></td></tr></table></figure>
<p>注意区分<code>const iterator</code>和<code>const_iterator</code>，前者类似于const pointer,指的是迭代器本身不能改变，即在初始化后无法指向其他元素，后者类似于pointer to const，指的是不能通过该迭代器修改指向的元素。</p>
<p>可以通过<code>cbegin</code>和<code>cend</code>来自动获取<code>const_iterator</code>，如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> cIter = v1.<span class="built_in">cbegin</span>();</span><br></pre></td></tr></table></figure>
<h4 id="Combining-Dereference-and-Member-Access"><a href="#Combining-Dereference-and-Member-Access" class="headerlink" title="Combining Dereference and Member Access"></a>Combining Dereference and Member Access</h4><p>可以使用<code>-&gt;</code>来取代<code>(*).</code>操作，如<code>it-&gt;empty()</code>等同于<code>(*it).empty()</code>。注意在使用后者时，必须加上括号。</p>
<p>如果去掉括号，<code>*it.empty()</code>指的是在<code>it</code>这个迭代器中寻找成员<code>empty</code>，无疑会造成编译错误。</p>
<h4 id="Some-vector-Operations-Invalidata-Iterators"><a href="#Some-vector-Operations-Invalidata-Iterators" class="headerlink" title="Some vector Operations Invalidata Iterators"></a>Some vector Operations Invalidata Iterators</h4><p>使用迭代器来执行循环操作时，也要注意循环操作造成容器大小变化时，很可能会造成循环的错误结果。</p>
<h3 id="Iterator-Arithmetic"><a href="#Iterator-Arithmetic" class="headerlink" title="Iterator Arithmetic"></a>Iterator Arithmetic</h3><p>vector和string支持一些额外的迭代器操作，如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>代码实例</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>iter + n</td>
<td>返回该迭代器后n个元素的位置</td>
</tr>
<tr>
<td>iter - n</td>
<td>返回该迭代器前n个元素的位置</td>
</tr>
<tr>
<td>iter += n</td>
<td>让迭代器指向后n个元素的位置</td>
</tr>
<tr>
<td>iter -= n</td>
<td>让迭代器指向前n个元素的位置</td>
</tr>
<tr>
<td>iter1 - iter2</td>
<td>获得两个迭代器之间的距离，即相距多少个元素</td>
</tr>
<tr>
<td>&lt;, &lt;=, &gt;, &gt;=</td>
<td>关系比较，比较迭代器指向元素的前后，越靠前越小</td>
</tr>
</tbody>
</table>
</div>
<h4 id="Arithmetic-Operations-on-Iterators"><a href="#Arithmetic-Operations-on-Iterators" class="headerlink" title="Arithmetic Operations on Iterators"></a>Arithmetic Operations on Iterators</h4><p><code>iter1 - iter2</code>操作返回的是一个名为<code>difference_type</code>的signed int类型,该类型同样属于实例化后的容器类型。</p>
<h4 id="Using-Iterator-Arithmetic"><a href="#Using-Iterator-Arithmetic" class="headerlink" title="Using Iterator Arithmetic"></a>Using Iterator Arithmetic</h4><p>使用迭代器进行二分查找例子:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string text = <span class="string">&quot;abcdefghijk&quot;</span>;</span><br><span class="line"><span class="type">char</span> toSearch;</span><br><span class="line">cin &gt;&gt; toSearch;</span><br><span class="line"><span class="keyword">auto</span> beg = text.<span class="built_in">cbegin</span>(), end = text.<span class="built_in">cend</span>();</span><br><span class="line"><span class="keyword">auto</span> mid = beg + (end - beg) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (mid != end &amp;&amp; (*mid) != toSearch)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (toSearch &lt; (*mid))</span><br><span class="line">        end = mid;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        beg = mid + <span class="number">1</span>;</span><br><span class="line">    mid = beg + (end - beg) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; (end != mid ? <span class="string">&quot;Found&quot;</span> : <span class="string">&quot;Not Found&quot;</span>) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><h3 id="Defining-and-Initializaing-Build-in-Arrays"><a href="#Defining-and-Initializaing-Build-in-Arrays" class="headerlink" title="Defining and Initializaing Build-in Arrays"></a>Defining and Initializaing Build-in Arrays</h3><p>数组同样也是复合类型（compound type）。</p>
<p>数组的大小是数组类型的一部分，所以必须在编译阶段就确定，也因此设定数组大小的值必须是const的，且数组的定义不能使用auto，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> num = <span class="number">42</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> cnum = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="comment">// int arr2[]; //error,must indicate array size</span></span><br><span class="line"><span class="comment">// auto aarr[] = &#123;1, 2, 3&#125;; //error,can not use auto</span></span><br><span class="line"><span class="comment">// auto aarr[10]; //error,can not use auto</span></span><br><span class="line"><span class="comment">// int arr2[num]; //error,num is not const</span></span><br><span class="line"><span class="type">int</span> arr3[cnum];</span><br></pre></td></tr></table></figure>
<p>形如<code>arr3[cnum]</code>的式子，执行的是默认初始化，如果该式子出现在函数内，且其元素类型是内建类型，则值是未定义的。</p>
<p>因为引用并不是对象，所以也没有引用的数组。</p>
<h4 id="Explicitly-Initializing-Array-Elements"><a href="#Explicitly-Initializing-Array-Elements" class="headerlink" title="Explicitly Initializing Array Elements"></a>Explicitly Initializing Array Elements</h4><p>对数组可以使用列表初始化，在使用列表初始化的时候可以不指定数组的大小，此时数组的大小由列表内的元素数量决定。如果指定了数组大小，那么这个大小必须大于列表中元素的数量，在比列表元素数量大的情况下，数组中剩余的部分将进行值初始化。在不适用列表初始化的情况下，必须指定数组大小，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">unsigned</span> sz = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> ia1[sz] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> a2[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;          <span class="comment">//array size is 3</span></span><br><span class="line"><span class="type">int</span> a3[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;         <span class="comment">//array size is 5, value is 01,2,0,0</span></span><br><span class="line">string sa[sz] = &#123;<span class="string">&quot;hi&quot;</span>, <span class="string">&quot;byt&quot;</span>&#125;; <span class="comment">//size is 3,value is &quot;hi&quot;&quot;bye&quot; &quot;&quot;</span></span><br><span class="line"><span class="comment">// int a4[sz] = &#123;0, 1, 2, 3&#125;;     //error, list elements count is greater than array size</span></span><br></pre></td></tr></table></figure>
<h4 id="Character-Arrays-Are-Special"><a href="#Character-Arrays-Are-Special" class="headerlink" title="Character Arrays Are Special"></a>Character Arrays Are Special</h4><p>使用string字面值初始化char数组时要注意，string字面值最后是带有一个空白字符的，所以数组的大小应该是string字面值的大小+1。如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> ca1[] = &#123;<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>&#125;;       <span class="comment">//size is 3</span></span><br><span class="line"><span class="type">char</span> ca2[] = &#123;<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;; <span class="comment">//size is 4</span></span><br><span class="line"><span class="type">char</span> ca3[] = <span class="string">&quot;abc&quot;</span>;                 <span class="comment">//size is 4</span></span><br><span class="line"><span class="comment">// const char a4[6] = &quot;Daniel&quot;;       //error,no space for \0</span></span><br></pre></td></tr></table></figure>
<h4 id="No-Copy-or-Assignment"><a href="#No-Copy-or-Assignment" class="headerlink" title="No Copy or Assignment"></a>No Copy or Assignment</h4><p>数组是没有拷贝初始化和赋值的，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="comment">// int aa[] = a;   //error</span></span><br><span class="line"><span class="comment">// int aa[] = a[]; //still error</span></span><br><span class="line"><span class="type">int</span> aa[<span class="number">3</span>];</span><br><span class="line"><span class="comment">// aa = a;         //error,can&#x27;t use assignment</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>某些编译器会允许数组的赋值，但仍然建议不要这样做，因为这不是C++标准的实现，在其他编译器中可能会引发问题。</p>
</blockquote>
<h4 id="Understanding-Complicated-Array-Declarations"><a href="#Understanding-Complicated-Array-Declarations" class="headerlink" title="Understanding Complicated Array Declarations"></a>Understanding Complicated Array Declarations</h4><p>指针的数组和数组的指针的声明会看起来有点复杂，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> array[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> *ptrs[<span class="number">10</span>]; <span class="comment">// ptrs is an array of size 10 where elementstype is int*</span></span><br><span class="line"><span class="comment">// int &amp;refs[10];//error,refs seems to be an array whereelemtns type is int&amp;, however reference is not object</span></span><br><span class="line"><span class="built_in">int</span>(*parray)[<span class="number">10</span>] = &amp;array;   <span class="comment">//parray is a pointer point toan int array of size 10</span></span><br><span class="line"><span class="built_in">int</span>(&amp;rarray)[<span class="number">10</span>] = array;    <span class="comment">//rarray is a reference bind toan int array of size 10</span></span><br><span class="line"><span class="type">int</span> *(*pparray)[<span class="number">10</span>] = &amp;ptrs; <span class="comment">//pparray is a pointer point toan int* array of size 10</span></span><br></pre></td></tr></table></figure>
<p>当没有括号将*与变量名称合在一起时，*表示元素的类型，如<code>int *ptrs[10]</code>表示<code>int*</code>的数组，当有括号时，表示变量本身的类型，如<code>int(*parray)[10] = &amp;array</code>，表示parray是一个指针，指向int[10]。</p>
<p>引用符号同理。</p>
<h3 id="Accessing-the-Elements-of-an-Array"><a href="#Accessing-the-Elements-of-an-Array" class="headerlink" title="Accessing the Elements of an Array"></a>Accessing the Elements of an Array</h3><p>当使用一个参数来作为数组的下标值时，这个参数的类型应该时<code>size_t</code>。<code>size_t</code>是一个机器相关的unsigned type。size_t定义在头文件cstddef中，该头文件是从C语言的头文件<code>stddef.h</code>改写而来。</p>
<p>同样可以使用下标和range for对数组进行操作，如下使用下标访问元素，使用range for遍历所有的元素，代码的功能是将输入的数组分类，判断有多少是在0-9范围中，有多少在10-19范围中等：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// unsigned scores[11];//warning,not defined value</span></span><br><span class="line"><span class="type">unsigned</span> scores[<span class="number">11</span>] = &#123;&#125;;</span><br><span class="line"><span class="type">unsigned</span> grade;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; grade)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (grade &lt;= <span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ++scores[grade / <span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> c : scores)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; c &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意必须对scores进行初始化。被初始化的第一条语句，执行的是默认初始化，而第二条语句<code>unsigned scores[11] = &#123;&#125;</code>使用的是值初始化。因此在函数内，后者可以保证所有的元素有确定的初始值（unsigned为0），而前者的值是未定义的。</p>
<p>如输入为<code>33 1 44 112 100 22 77 76 75 ^Z</code>，输出可能为<code>1  0  268501010  1  16713577  0  898214646  32766  8  0  1</code>，在这种情况下输出的结果是无法保证的。</p>
<p>而进行初始化的话，使用相同的输入，结果为<code>1  0  1  1  1  0  1  2  0  0  1</code>与预期结果相同。</p>
<p>在代码的最后通过range for遍历输出了scores中的元素，因为数组的大小是数组的一部分即必须在编译时确认，所以系统可以了解究竟有多少元素在数组中。</p>
<h3 id="Pointers-and-Arrays"><a href="#Pointers-and-Arrays" class="headerlink" title="Pointers and Arrays"></a>Pointers and Arrays</h3><p>在C++中，数组和指针是紧密关联的。在绝大部分表达式中，当使用数组时，编译器会将其转换为对第一个元素的指针，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string nums[] = &#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>&#125;;</span><br><span class="line">cout &lt;&lt; (*nums) &lt;&lt; endl;</span><br><span class="line">string *p = nums;</span><br><span class="line">string *pp = &amp;nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span> (p == pp)</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;two pointers are the same&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;they are different&quot;</span> &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">one</span></span><br><span class="line"><span class="comment">two pointers are the same</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>在上例中，当使用<code>nums</code>实际上使用的是<code>&amp;nums[0]</code>，即对第一个元素的指针。</p>
<p>如使用auto也可以发现，编译器自动对数组进行了转换，如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> pnums = nums; <span class="comment">// same as auto pnums = &amp;nums[0]</span></span><br><span class="line"><span class="comment">// pnums = &quot;zero&quot;;</span></span><br><span class="line">(*pnums) = <span class="string">&quot;zero&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;first element is &quot;</span> &lt;&lt; nums[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">first element is zero</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><code>pnums</code>的类型为<code>string*</code>，对pnums指向对象的操作即是对数组第一个元素的操作。</p>
<p>需要注意的是，当使用关键字<code>decltype</code>时，返回的仍然是数组类型，而不是对第一个元素的指针，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(nums) another = &#123;<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> n : another)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;value is &quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">value is abc</span></span><br><span class="line"><span class="comment">value is def</span></span><br><span class="line"><span class="comment">value is</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>如之前所述，数组的大小是数组类型的一部分，所以这里的another类型为string[3]，而列表初始化只给了两个元素，所以最有一个元素将默认为空string。</p>
<h4 id="Pointers-are-Iterators"><a href="#Pointers-are-Iterators" class="headerlink" title="Pointers are Iterators"></a>Pointers are Iterators</h4><p>对于数组中元素的指针，其支持的操作与之前提到的迭代器支持的操作一样，包括<code>++</code>,<code>--</code>，通过<code>*</code>解引用，<code>==,!=</code>，关系判断，<code>+= n</code>等。</p>
<p>如可以通过数组来进行循环遍历，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> *endPtr = &amp;arr[<span class="number">10</span>]; <span class="comment">//point to one past last elemment</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;value is: &quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> *i = arr; i != endPtr; i++)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; (*i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">value is: </span></span><br><span class="line"><span class="comment">0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>在代码中使用了<code>&amp;arr[10]</code>来获取相当于off-the-end迭代器的指针，因为其指向了最后一个元素后面的位置。在C++11标准中，可以使用函数<code>begin</code>和<code>end</code>来获取对应的迭代器的指针，如下所示，判断两种方法取得的值是否相同：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *oBeg = arr;</span><br><span class="line"><span class="type">int</span> *oEnd = &amp;arr[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> *beg = std::<span class="built_in">begin</span>(arr);</span><br><span class="line"><span class="type">int</span> *end = std::<span class="built_in">end</span>(arr);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Begin is &quot;</span> &lt;&lt; (oBeg == beg ? <span class="string">&quot;the same&quot;</span> : <span class="string">&quot;not thesame&quot;</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;End is &quot;</span> &lt;&lt; (oEnd == end ? <span class="string">&quot;the same&quot;</span> : <span class="string">&quot;not thesame&quot;</span>) &lt;&lt; endl;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Begin is the same</span></span><br><span class="line"><span class="comment">End is the same</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>下例是使用使用指针来判断两个数组是否相同的例子:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CompareTwoArray</span><span class="params">(<span class="type">int</span> *<span class="type">const</span> pb1, <span class="type">int</span> *<span class="type">const</span> pe1, <span class="type">int</span> *<span class="type">const</span> pb2, <span class="type">int</span> *<span class="type">const</span> pe2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((pe1 - pb1) != (pe2 - pb2))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//Different length</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = pb1, j = pb2; i &lt; pe1 &amp;&amp; j &lt; pe2; i++, j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((*i) != (*j))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Exercise3_36</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> arr1[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> arr2[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> arr3[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> arr4[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">CompareTwoArray</span>(<span class="built_in">begin</span>(arr1), <span class="built_in">end</span>(arr1), <span class="built_in">begin</span>(arr2), <span class="built_in">end</span>(arr2)) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">CompareTwoArray</span>(<span class="built_in">begin</span>(arr1), <span class="built_in">end</span>(arr1), <span class="built_in">begin</span>(arr3), <span class="built_in">end</span>(arr3)) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">CompareTwoArray</span>(<span class="built_in">begin</span>(arr1), <span class="built_in">end</span>(arr1), <span class="built_in">begin</span>(arr4), <span class="built_in">end</span>(arr4)) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1</span></span><br><span class="line"><span class="comment">    0</span></span><br><span class="line"><span class="comment">    0</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Pointer-Arithmetic"><a href="#Pointer-Arithmetic" class="headerlink" title="Pointer Arithmetic"></a>Pointer Arithmetic</h4><p>两个指针也是可以相减的，结果类型为<code>ptrdiff_t</code>，是一个硬件相关的类型，定义在<code>cstddef</code>头文件中。在不同的硬件上，它可能会被转换为不同的类型，如转换为long long等。</p>
<p>对不指向任何数组元素的指针进行访问，或比较两个不相关的指针是可以编译的，但其运行的结果是未定义的，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;value of end is &quot;</span> &lt;&lt; *end &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;value of end next is &quot;</span> &lt;&lt; *(++end) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>, sz = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;i, *e = &amp;sz;</span><br><span class="line">cout &lt;&lt; (p &lt; e ? <span class="string">&quot;p is smaller than e&quot;</span> : <span class="string">&quot;p is larger thane&quot;</span>) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>这些操作的结果都是未定义的，不同的硬件，不同的编译器甚至不同的运行时间都会造成不同的结果。</p>
<h4 id="Interaction-between-Dereference-and-Pointer-Arithmetic"><a href="#Interaction-between-Dereference-and-Pointer-Arithmetic" class="headerlink" title="Interaction between Dereference and Pointer Arithmetic"></a>Interaction between Dereference and Pointer Arithmetic</h4><p>在对指针进行解引用时，括号的使用会影响结果,如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ia[] = &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>&#125;;</span><br><span class="line">cout &lt;&lt; *(ia + <span class="number">4</span>) &lt;&lt; endl;<span class="comment">//Access the fifth element</span></span><br><span class="line">cout &lt;&lt; *ia + <span class="number">4</span> &lt;&lt; endl;<span class="comment">//Access the first element and add 4to the result</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="Subscripts-and-Pointers"><a href="#Subscripts-and-Pointers" class="headerlink" title="Subscripts and Pointers"></a>Subscripts and Pointers</h4><p>可以对任何指针使用下标，但是大多数情况下，只有对指向数组中元素的指针使用下标才有意义，剩下的都是未定义的结果，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ia[] = &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>&#125;;</span><br><span class="line"><span class="type">int</span> *iaP = &amp;ia[<span class="number">2</span>];</span><br><span class="line">cout &lt;&lt; *iaP &lt;&lt; endl;       <span class="comment">//Third element</span></span><br><span class="line">cout &lt;&lt; iaP[<span class="number">-2</span>] &lt;&lt; endl;    <span class="comment">//First element</span></span><br><span class="line">cout &lt;&lt; *(iaP - <span class="number">2</span>) &lt;&lt; endl; <span class="comment">//First element,same with lastexpression</span></span><br><span class="line">cout &lt;&lt; iaP[<span class="number">-3</span>] &lt;&lt; endl;    <span class="comment">//undefined result</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> *ap = &amp;a;</span><br><span class="line">cout &lt;&lt; ap[<span class="number">0</span>] &lt;&lt; endl;  <span class="comment">// a</span></span><br><span class="line">cout &lt;&lt; ap[<span class="number">-1</span>] &lt;&lt; endl; <span class="comment">//undefined result</span></span><br></pre></td></tr></table></figure>
<p>如上所示，通过解引用符号*对指针的访问，相当于使用<code>[0]</code>操作,因此如<code>iaP[-2]</code>和<code>*(iaP - 2)</code>是等效的。</p>
<h3 id="C-Style-Character-Strings"><a href="#C-Style-Character-Strings" class="headerlink" title="C-Style Character Strings"></a>C-Style Character Strings</h3><p>C++中的string字面值实际上是继承自C语言的。通过C++的string存储string字面值会将其转换为string类型，但如果要完全体现String字面值（C风格的String）本身的特性，可以使用char数组或者指针，如<code>char str[] = &quot;ABC&quot;;</code>，该数组的大小为4，因为还有在最后包含一个空字符。</p>
<p>在<code>cstring</code>头文件中，定义了对C-style的string操作的方法，如下表所示</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>代码实例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>strlen(p)</td>
<td>返回p的长度，不包含最后的空字符</td>
</tr>
<tr>
<td>strcmp(p1,p2)</td>
<td>判断两个字符串的大小，p1大于p2返回正数，小于p2返回负数，等于p2返回0</td>
</tr>
<tr>
<td>strcat(p1,p2)</td>
<td>将p2的内容添加到p1后，返回p1</td>
</tr>
<tr>
<td>strcpy(p1,p2)</td>
<td>将p2的内容拷贝到p1中，返回p1</td>
</tr>
</tbody>
</table>
</div>
<p>对C-Style字符串（使用char数组或指针）进行判断，必须使用<code>strcmp</code>，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s1 = <span class="string">&quot;A string example&quot;</span>;</span><br><span class="line">string s2 = <span class="string">&quot;A different string&quot;</span>;</span><br><span class="line">cout &lt;&lt; (s1 &gt; s2) &lt;&lt; endl;</span><br><span class="line"><span class="type">char</span> cs1[] = <span class="string">&quot;A string example&quot;</span>;</span><br><span class="line"><span class="type">char</span> cs2[] = <span class="string">&quot;A different string&quot;</span>;</span><br><span class="line">cout &lt;&lt; (cs1 &gt; cs2) &lt;&lt; endl;      <span class="comment">//wrong way,no meaning, iscomparing address of first element</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">strcmp</span>(cs1, cs2) &lt;&lt; endl; <span class="comment">//correct way</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Although cs1&gt;cs1 also yield correct result,but it&#x27;s nomeaning.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="Caller-is-Responsible-for-Size-of-a-Destination-String"><a href="#Caller-is-Responsible-for-Size-of-a-Destination-String" class="headerlink" title="Caller is Responsible for Size of a Destination String"></a>Caller is Responsible for Size of a Destination String</h4><p>使用C-Stype字符串相关操作时需要额外的小心，如<code>strcat</code>和<code>strcpy</code>操作，并不会检查第一个参数，即装填最终结果的数组的大小，如果数组大小不满足，则会产生错误结果。</p>
<p>另外<code>strlen</code>的长度通常是通过找寻C-Style字符串最后的空字符来实现的，如果参数是一个没有空字符的C-Style字符串，那么结果是未定义的，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> ca[]&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">strlen</span>(ca) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">21</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>这里的21即是一个未定义的结果，在不同情况下结果会不同。在通常的编译器实现下，strlen会一直向后遍历内存，直到找到一块内存其中值未空白字符。</p>
<p>也正因为使用C-Style字符串需要额外的小心，一般现代C++程序推荐使用标准库中的string类型。</p>
<h3 id="Interfacing-to-Older-Code"><a href="#Interfacing-to-Older-Code" class="headerlink" title="Interfacing to Older Code"></a>Interfacing to Older Code</h3><p>在之前已经说明了，可以使用字符串字面值来直接初始化标准库中的string类型，更通常来说，可以使用任何最后是空白字符结尾的C-Style字符串直接转换为标准库中的string类型。如果C-Style字符串结尾不是空白字符，同样结果是未定义的。如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s = <span class="string">&quot;ABCD&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;value is &quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;, size is &quot;</span> &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"><span class="type">char</span> cs[]&#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line">string sc = cs;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;value is &quot;</span> &lt;&lt; sc &lt;&lt; <span class="string">&quot;, size is &quot;</span> &lt;&lt; sc.<span class="built_in">size</span>() &lt;&lt;endl;</span><br><span class="line"><span class="type">char</span> cs2[]&#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>&#125;;</span><br><span class="line">string sc2 = cs2;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;value is &quot;</span> &lt;&lt; sc2 &lt;&lt; <span class="string">&quot;, size is &quot;</span> &lt;&lt; sc2.<span class="built_in">size</span>() &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">value is ABCD, size is 4</span></span><br><span class="line"><span class="comment">value is ABCD, size is 4</span></span><br><span class="line"><span class="comment">value is ABCD慅a, size is 7</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>相反，无法直接将string转换为C-Style字符串，但可以通过string的成员函数<code>c_str</code>将结果转换为<code>const char *</code>。</p>
<p>需要注意的是，c_str返回的是字符串第一个元素的指针，且最后是由空字符结尾，并且标准库的string值改变的话，对应返回的数据也会自动改变，如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s = <span class="string">&quot;ABCD&quot;</span>;</span><br><span class="line"><span class="comment">// char *cs3 = s; //error,can&#x27;t direct convert</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *cs3 = s.<span class="built_in">c_str</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;value is &quot;</span> &lt;&lt; cs3 &lt;&lt; endl;</span><br><span class="line">s = <span class="string">&quot;DEFC&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;value is &quot;</span> &lt;&lt; cs3 &lt;&lt; endl;</span><br><span class="line">string css = cs3;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;value is &quot;</span> &lt;&lt; css &lt;&lt; <span class="string">&quot;, size is &quot;</span> &lt;&lt; css.<span class="built_in">size</span>() &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">value is ABCD</span></span><br><span class="line"><span class="comment">value is DEFC</span></span><br><span class="line"><span class="comment">value is DEFC, size is 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="Using-an-Array-to-Initialize-a-vector"><a href="#Using-an-Array-to-Initialize-a-vector" class="headerlink" title="Using an Array to Initialize a vector"></a>Using an Array to Initialize a vector</h4><p>如前所述，无法直接通过一个数组初始化另一个数组。同样的，无法通过一个vector直接初始化一个数组，但却可以通过指向数组元素的指针来初始化vector，如下所示</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> intArr[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intVec</span><span class="params">(begin(intArr), end(intArr))</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : intVec)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">intVec = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(intArr, intArr + <span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : intVec)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0 1 2 3 4 5 </span></span><br><span class="line"><span class="comment">0 1 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>代码的前半段是使用begin和end函数来获取第一个元素指针和off-the-end指针，这样就是完整拷贝了数组的元素到新vector中。</p>
<p>后半段是直接使用指针操作，需要注意的是传入的第二个参数是指向vector最后一个元素的内存尾部的地址。因此代码中第二个参数为<code>intArr+3</code>，但实际上Vectr中最后一个参数值是<code>*(intArr+2)</code>。</p>
<p>创建的vector和原数组是不同的内存，因此创建完后，修改原数组并不会对vector中的元素造成影响。</p>
<h2 id="Multidimensional-Arrays"><a href="#Multidimensional-Arrays" class="headerlink" title="Multidimensional Arrays"></a>Multidimensional Arrays</h2><p>C++并没有多维数组的概念，实际上多维数组的实现是通过数组的数组。如<code>ia[3][4]</code>可以看作是一个三行四列的数组。对于多维数组必须指定维度，不能初始值来推断。</p>
<h3 id="Initializing-the-Elements-of-a-Multidimensional-Array"><a href="#Initializing-the-Elements-of-a-Multidimensional-Array" class="headerlink" title="Initializing the Elements of a Multidimensional Array"></a>Initializing the Elements of a Multidimensional Array</h3><p>以下是初始化多维数组的几种方式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ia[<span class="number">3</span>][<span class="number">4</span>];   <span class="comment">//without initialization;</span></span><br><span class="line"><span class="type">int</span> ib[<span class="number">3</span>][<span class="number">4</span>]&#123;&#125;; <span class="comment">//All elements will be 0</span></span><br><span class="line"><span class="type">int</span> ic[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;, &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> id[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;;</span><br><span class="line"><span class="type">int</span> ie[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0</span>&#125;, &#123;<span class="number">4</span>&#125;, &#123;<span class="number">8</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> ix[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">4</span>, <span class="number">8</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>其中<code>ic</code>和<code>id</code>的初始化结果是相同的，<code>ie</code>是初始化了每一行的第一个元素的值，<code>ix</code>的初始化了第一行的前三个元素，之后的元素都会被装填为0（进行了值初始化）。</p>
<h3 id="Subscripting-a-Multidimentional-Array"><a href="#Subscripting-a-Multidimentional-Array" class="headerlink" title="Subscripting a Multidimentional Array"></a>Subscripting a Multidimentional Array</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ia[<span class="number">3</span>][<span class="number">4</span>]= = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;, &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;&#125;;</span><br><span class="line"><span class="built_in">int</span> (&amp;row)[<span class="number">4</span>] = ia[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<p>其中<code>ia[0]</code>表示第一行，是一个长度为4的int数组。row是一个绑定至长度为4的int数组的引用。</p>
<p>可以使用下标来遍历数组，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ic[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;, &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; ic[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0 1 2 3 4 5 6 7 8 9 10 11</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="Using-a-Range-for-with-Multidimentsional-Arrays"><a href="#Using-a-Range-for-with-Multidimentsional-Arrays" class="headerlink" title="Using a Range for with Multidimentsional Arrays"></a>Using a Range for with Multidimentsional Arrays</h3><p>当使用C++ 11标准的<code>range for</code>遍历多维数组时，需要注意除了最内侧的数组外，外层的遍历都需要用引用，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ic[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;, &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;row : ic)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;col : row)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; col &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;row : ic)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> col : row)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; col &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for (auto row : ic)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     for (auto col : row)</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//         cout &lt;&lt; col &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0 1 2 3 4 5 6 7 8 9 10 11 </span></span><br><span class="line"><span class="comment">0 1 2 3 4 5 6 7 8 9 10 11</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，第一部分是两层循环都使用了引用，第二部分是之后外层循环使用了引用，第三部分是两层循环都没有使用引用。第一部分和第二部分都得到了理想的结果，而第三部分是无法通过编译的。</p>
<p>当外层循环的row不是引用时，编译器会自动将其转换为指针，即row的类型会变为<code>int *</code>，指向每一行数组的第一个元素，而对于指针没法使用range for，所以会出现编译错误。</p>
<h4 id="Pointers-and-Multidimensional-Arrays"><a href="#Pointers-and-Multidimensional-Arrays" class="headerlink" title="Pointers and Multidimensional Arrays"></a>Pointers and Multidimensional Arrays</h4><p>首先要注意数组与指针的关系，式子<code>int *ip[4]</code>表示ip是一个长度为4的数组，其中元素类型为int*。式子<code>int (*ip)[4]</code>表示ip是一个指针，指向长度为4的数组。</p>
<p>可以使用指针来遍历数组，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ic[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;, &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span>(*p)[<span class="number">4</span>] = ic; p != ic + <span class="number">3</span>; ++p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> *q = (*p); q != (*p) + <span class="number">4</span>; q++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; (*q) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0 1 2 3 4 5 6 7 8 9 10 11 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>注意外部循环中遍历p的类型是<code>int (*)[4]</code>，即指向大小为4的数组的指针，将ic赋值给p，是因为编译器会自动的将数组转换为指向第一个元素的指针，在外部循环中，第一个元素是数组。在内部循环中，初始值是(*p)，即是一个大小为4的数组，同样编译器会将其转换为第一个元素的指针，即int*。</p>
<p>如之前节所示，可以用begin和end简化代码，如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span>(*p)[<span class="number">4</span>] = <span class="built_in">begin</span>(ic); p != <span class="built_in">end</span>(ic); ++p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> *q = <span class="built_in">begin</span>(*p); q != <span class="built_in">end</span>(*p); q++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; (*q) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0 1 2 3 4 5 6 7 8 9 10 11 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="Type-Aliases-Simplify-Pointers-to-Multidimensional-Arrays"><a href="#Type-Aliases-Simplify-Pointers-to-Multidimensional-Arrays" class="headerlink" title="Type Aliases Simplify Pointers to Multidimensional Arrays"></a>Type Aliases Simplify Pointers to Multidimensional Arrays</h4><p>可以通过为int数组取一个别名来简化代码，如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// using int_array = int[4];</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> int_array[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ic[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;, &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">for</span> (int_array *p = ic; p != ic + <span class="number">3</span>; ++p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> *q = (*p); q != (*p) + <span class="number">4</span>; q++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; (*q) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0 1 2 3 4 5 6 7 8 9 10 11</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>示例中，将长度为4的int数组称为int_array。示例中使用using和typedef是等效的。</p>
<div class="note info simple"><p>引用：</p>
<ol>
<li><em>Cpp Primer</em> 5th Aug.2012</li>
</ol>
</div>
<hr>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>计算机语言</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>《C++ Primer》 第四章笔记</title>
    <url>/CPPPrimer-Chapter4-Notes/</url>
    <content><![CDATA[<p>《C++ Primer》 第四章笔记</p>
<p>主要关于对内建类型的操作。</p>
<p><img src="CPPPrimer-Chapter4-Notes/Ch4.png" alt="第四章内容"></p>
<span id="more"></span>
<h1 id="Chapter-4-Expressions"><a href="#Chapter-4-Expressions" class="headerlink" title="Chapter 4 Expressions"></a>Chapter 4 Expressions</h1><h2 id="Fundamentals"><a href="#Fundamentals" class="headerlink" title="Fundamentals"></a>Fundamentals</h2><h3 id="Basic-Concepts"><a href="#Basic-Concepts" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h3><h4 id="Grouping-Operators-and-Operands"><a href="#Grouping-Operators-and-Operands" class="headerlink" title="Grouping Operators and Operands"></a>Grouping Operators and Operands</h4><p>多个操作符的顺序是由优先级（Precedence）和结合性（associatively）有时还有求值顺序（order of evaluation）决定的。</p>
<h4 id="Overloaded-Operators"><a href="#Overloaded-Operators" class="headerlink" title="Overloaded Operators"></a>Overloaded Operators</h4><p>操作符可以被重载，但是操作符接受的参数数量，优先级还有结合性是没法被改变的。</p>
<h4 id="Lvalues-and-Rvalues"><a href="#Lvalues-and-Rvalues" class="headerlink" title="Lvalues and Rvalues"></a>Lvalues and Rvalues</h4><p>左参数（Lvalues）是出现在赋值左侧的参数，右参数(Rvalues)是出现在赋值右侧的参数。当使用右参数时，使用的是右参数的值，当使用左参数时，使用的是参数的地址。</p>
<p>除了在13.6节会提到一个例外，可以在右参数的地方使用左参数代替，但是在左参数的地方无法使用右参数代替。</p>
<blockquote>
<p>赋值操作会返回左参数，取地址操作返回的指针是右参数，前置的<code>++</code>和<code>--</code>返回左参数。</p>
</blockquote>
<p>左右参数在使用<code>decltype</code>时也会体现出区别，当传入decltype的是表达式时，且表达式的结果是左参数，那么decltype的结果是引用。</p>
<p>假设<code>p</code>的类型是<code>int *</code>，那么<code>*p</code>返回的是左参数，因此<code>decltype(*p)</code>结果是int&amp;，而因为取地址符返回的是右参数，即<code>(&amp;p)</code>结果为为右参数，所以<code>decltype(&amp;p)</code>结果是<code>int* *</code>，而不是引用<code>int** &amp;</code></p>
<h3 id="Precedence-and-Associativity"><a href="#Precedence-and-Associativity" class="headerlink" title="Precedence and Associativity"></a>Precedence and Associativity</h3><p>优先级（Precedence）决定是操作符执行的先后顺序，结合性（Associativity）决定的是同优先级的操作符之间执行的顺序。</p>
<p>算数操作符是左结合，即计算顺序是从左到右的，如<code>3*4/2</code>，会先计算除法，而赋值操作是右结合。</p>
<p>可以使用括号来重新决定优先级和结合性。</p>
<h3 id="Order-of-Evaluation"><a href="#Order-of-Evaluation" class="headerlink" title="Order of Evaluation"></a>Order of Evaluation</h3><p>求值顺序决定了操作符的多个参数，哪个还会先进行求值。</p>
<p>如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="built_in">f1</span>() * <span class="built_in">f2</span>();</span><br></pre></td></tr></table></figure>
<p>C++标准只能保证在执行乘法操作前，函数f1和f2都会被执行完毕，但是f1和f2的执行顺序是<em>未定义的</em>。</p>
<p>同理，如下代码的结果也是未定义的，即使在测试中得到了期待答案，也无法保证在其他硬件或编译器下能正常工作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ++i &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>所有出现在同一个表达式中的未限定求值顺序的操作符的执行顺序都是未定义的。所以尽量不要在同一个表达式中引用或修改同一个对象，这很可能会引发Bug。</p>
<p>只有四个操作符的执行顺序是指定了的，逻辑与<code>&amp;&amp;</code>，逻辑或<code>||</code>，条件判断<code>?:</code>和逗号<code>,</code>。</p>
<p>只有一种情况下，在同一个式子中使用未限定求值顺序的操作符对同一个变量多次操作能得到确定的答案，即修改了变量的子表达式本身就是另一个表达式的对象。</p>
<p>如<code>int*++iter</code>，按优先级会计算<code>++iter</code>，而改变后的<code>iter</code>本身就是<code>int*</code>表达式的对象。但是在之前的式子的<code>f1() * f2()</code>中，乘法操作符的对象是函数运行后的值，而不是函数本身。同理，对于<code>cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; ++i</code>，前面的<code>i</code>和<code>i++</code>实际上是不相关的，即<code>&lt;&lt;</code>操作符并不是将它俩链接在一起，所以谁先执行也是不能保证的。</p>
<h4 id="Order-of-Evaluation-Precedence-and-Associativity"><a href="#Order-of-Evaluation-Precedence-and-Associativity" class="headerlink" title="Order of Evaluation,Precedence and Associativity"></a>Order of Evaluation,Precedence and Associativity</h4><p>如有式子<code>f()+g()* h()+j()</code>,可以得出以下结论：</p>
<ol>
<li>优先级保证了，g()的结果和h()的结果会先相乘</li>
<li>结合性保证了f()的结果会先和g()和h()相乘的结果相加，然后得到的结果再与j()相加。</li>
<li>四个函数的执行顺序无法保证。</li>
</ol>
<p>如果这四个函数是相关的，如都会在内部对同一个全局变量进行修改或访问，那么结果将是未定义的。</p>
<h3 id="Arithmetic-Operators"><a href="#Arithmetic-Operators" class="headerlink" title="Arithmetic Operators"></a>Arithmetic Operators</h3><p>算数操作符的优先级排序如下，所有的算数操作符的结合性都是从左至右：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>优先级</th>
<th>操作符</th>
<th>含义</th>
<th>使用</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>+</td>
<td>正号</td>
<td>+ expr</td>
</tr>
<tr>
<td>1</td>
<td>-</td>
<td>负号</td>
<td>- expr</td>
</tr>
<tr>
<td>2</td>
<td>*</td>
<td>相乘</td>
<td>expr * expr</td>
</tr>
<tr>
<td>2</td>
<td>/</td>
<td>相除</td>
<td>expr / expr</td>
</tr>
<tr>
<td>2</td>
<td>%</td>
<td>求余</td>
<td>expr % expr</td>
</tr>
<tr>
<td>3</td>
<td>+</td>
<td>相加</td>
<td>expr + expr</td>
</tr>
<tr>
<td>3</td>
<td>-</td>
<td>相减</td>
<td>expr - expr</td>
</tr>
</tbody>
</table>
</div>
<p>算数操作符的结果都是右参数。</p>
<h4 id="Arithmetic-Operation-on-Boolean"><a href="#Arithmetic-Operation-on-Boolean" class="headerlink" title="Arithmetic Operation on Boolean"></a>Arithmetic Operation on Boolean</h4><p>在对布尔值进行算数操作时需要额外的注意，如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> b = <span class="literal">true</span>;</span><br><span class="line"><span class="type">bool</span> b2 = -b;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b2 is &quot;</span> &lt;&lt; b2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">b2 is 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>因为对b使用了负号操作符，所以b会转换为int，因为b值为true，所以被转换为1，即b2的值为-1,因为非0，所以b2值为true。最后使用cout打印时，又转换为了int，为1。</p>
<h4 id="Overflow"><a href="#Overflow" class="headerlink" title="Overflow"></a>Overflow</h4><p>如果对整数类型使用了算数操作符且结果超过了类型所能表达的最大值，那么结果是未定义的，如使用short表示一个数，且在某设备上short是16-bits的类型，那么它的表达范围是$-32768\sim 32767$，如有以下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">short</span> short_value = <span class="number">32767</span>;</span><br><span class="line">short_value++;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;short value is &quot;</span> &lt;&lt; short_value &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">b2 is 1short value is -32768</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>结果为-32768，是因为编译器对其进行了<code>wrap around</code>，但因为结果实际上是未定义的，并不能保证所有设备上都是这个结果。</p>
<h4 id="remainder-operation"><a href="#remainder-operation" class="headerlink" title="remainder(%) operation"></a>remainder(%) operation</h4><p>取余符号的操作对象必须是整数类型，对于<code>m % n</code>，结果的正负与m一样。即<code>m%(-n)</code>的值与<code>m%n</code>相同，<code>(-m)%n</code>的值与<code>-(m%n)</code>相同。</p>
<h3 id="Logical-and-Relational-Operators"><a href="#Logical-and-Relational-Operators" class="headerlink" title="Logical and Relational Operators"></a>Logical and Relational Operators</h3><p>所有的算数值（整数和浮点数）和指针转换为布尔值的规则相同，值为0为false，值非0为true。</p>
<p>所有的逻辑和关系运算符优先级如下标：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>优先级</th>
<th>结合性</th>
<th>操作符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Right</td>
<td>!</td>
<td>取非</td>
</tr>
<tr>
<td>2</td>
<td>Left</td>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td>2</td>
<td>Left</td>
<td>&lt;=</td>
<td>小于等于</td>
</tr>
<tr>
<td>2</td>
<td>Left</td>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td>2</td>
<td>Left</td>
<td>&gt;=</td>
<td>大于等于</td>
</tr>
<tr>
<td>3</td>
<td>Left</td>
<td>==</td>
<td>相等</td>
</tr>
<tr>
<td>3</td>
<td>Left</td>
<td>!=</td>
<td>不等</td>
</tr>
<tr>
<td>4</td>
<td>Left</td>
<td>&amp;&amp;</td>
<td>与</td>
</tr>
<tr>
<td>4</td>
<td>Left</td>
<td>\</td>
<td>\</td>
<td></td>
<td>或</td>
</tr>
</tbody>
</table>
</div>
<p><code>&amp;&amp;</code>操作和<code>||</code>操作都是最短路径求值</p>
<h4 id="The-Relational-Operators"><a href="#The-Relational-Operators" class="headerlink" title="The Relational Operators"></a>The Relational Operators</h4><p>因为关系运算符的返回结果是bool值，级联关系运算符的结果通常如期望的不同，如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">3</span>, j = <span class="number">2</span>, k = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span> (i &lt; j &lt; k)</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;enter case 1&quot;</span>;</span><br><span class="line">        </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">enter case 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>运算的实际过程是，先判断<code>i&lt;j</code>，结果为false，返回0，然后判断<code>o&lt;k</code>，结果为true。如果要判断i,j,k是否是递增的，应该写为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(i &lt; j &amp;&amp; j &lt; k)</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;enter case 1&quot;</span>;</span><br></pre></td></tr></table></figure>
<h4 id="Equality-Tests-and-the-bool-Literals"><a href="#Equality-Tests-and-the-bool-Literals" class="headerlink" title="Equality Tests and the bool Literals"></a>Equality Tests and the bool Literals</h4><p>可以在condition中直接使用算数值或者指针来判断该参数是否是0，如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(val) &#123;<span class="comment">/* ... */</span>&#125;<span class="comment">//true if val is nonzero value</span></span><br></pre></td></tr></table></figure>
<p>但上式不能改写为<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(val == <span class="literal">true</span>)  &#123;<span class="comment">/* ... */</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个式子中，true会被转换为val的类型，即变为1，因此式子判断的是val的值是否为1。</p>
<h2 id="Assignment-Operators"><a href="#Assignment-Operators" class="headerlink" title="Assignment Operators"></a>Assignment Operators</h2><h4 id="Assignment-Is-Right-Associative"><a href="#Assignment-Is-Right-Associative" class="headerlink" title="Assignment Is Right Associative"></a>Assignment Is Right Associative</h4><p>赋值操作的结合性是从右至左的，且赋值的右参数必须与左参数类型相同或者可以转换到左参数的类型，如下代码所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">double</span> d;</span><br><span class="line">i = d = <span class="number">3.5</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;i is &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, d is &quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">d = i = <span class="number">3.5</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;i is &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, d is &quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">i is 3, d is 3.5</span></span><br><span class="line"><span class="comment">i is 3, d is 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="Assignment-Has-Low-Precedence"><a href="#Assignment-Has-Low-Precedence" class="headerlink" title="Assignment Has Low Precedence"></a>Assignment Has Low Precedence</h4><p>在C++中，可以在condition中使用赋值操作，如下两部分代码是等效的，但第二个更简洁：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="built_in">getValue</span>();</span><br><span class="line"><span class="keyword">while</span> ( i != <span class="number">42</span> )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// do sth</span></span><br><span class="line">  i = <span class="built_in">getValue</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">while</span>( (i = <span class="built_in">getValue</span>()) != <span class="number">42</span>)</span><br><span class="line">  <span class="comment">// do sth</span></span><br></pre></td></tr></table></figure>
<p>注意赋值操作的优先级很低，所以需要使用括号来限定优先操作，如果不使用括号，则i的值会变成getValue返回值与42的比较结果，即只会是0或1。</p>
<h4 id="Compound-Assignment-Operators"><a href="#Compound-Assignment-Operators" class="headerlink" title="Compound Assignment Operators"></a>Compound Assignment Operators</h4><p>以下都是复合赋值操作符：<br><code>+=</code>,<code>-=</code>,<code>*=</code>,<code>/=</code>,<code>%=</code>,<code>&lt;&lt;=</code>,<code>&gt;&gt;=</code>,<code>&amp;=</code>,<code>^=</code>,<code>|=</code>。</p>
<p>以<code>+=</code>为例，下两个式子是等效的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a += <span class="number">1</span>;</span><br><span class="line">a = a+<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>但是从性能角度考虑，使用复合赋值操作只需要读取一次左参数，而普通的赋值方法则需要读取两次，因此复合赋值操作有更好的性能，虽然之中的差距不是很明显。</p>
<h2 id="Increment-and-Decrement-Operators"><a href="#Increment-and-Decrement-Operators" class="headerlink" title="Increment and Decrement Operators"></a>Increment and Decrement Operators</h2><p><code>++</code>和<code>--</code>操作都有两个形式，前置(Prefix)和后置（Postfix），前置返回的是原值加1后的原对象本身，结果是左参数。后置返回的是原对象的原值，结果是右参数。如下代码所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>, j;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;i is &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, j is &quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">j = ++i;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;i is &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, j is &quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">j = i++;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;i is &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, j is &quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">i is 0, j is 0</span></span><br><span class="line"><span class="comment">i is 1, j is 1</span></span><br><span class="line"><span class="comment">i is 2, j is 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>尽量使用前置操作，这样代码更简洁，且因为避免了拷贝也有更好的性能</p>
</blockquote>
<h3 id="Combining-Dereference-and-Increment-in-a-Single-Expression"><a href="#Combining-Dereference-and-Increment-in-a-Single-Expression" class="headerlink" title="Combining Dereference and Increment in a Single Expression"></a>Combining Dereference and Increment in a Single Expression</h3><p>因为累加符号的优先级低于解引用符，所以<code>*p++</code>等同于<code>*(p++)</code></p>
<h3 id="Remember-That-Operands-Can-Be-Evaluated-in-Any-Order"><a href="#Remember-That-Operands-Can-Be-Evaluated-in-Any-Order" class="headerlink" title="Remember That Operands Can Be Evaluated in Any Order"></a>Remember That Operands Can Be Evaluated in Any Order</h3><p>如之前所述，在同一个表达式内，子表达式的计算顺序是无法保证的（操作符的优先级决定的是子表达式的计算结果在总表达式中计算的顺序）。</p>
<p>在同一个表达式中，有子表达式使用对象，另一个子表达式修改对象时，结果是未定义的，如下式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line"><span class="keyword">auto</span> beg = s.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (beg != s.<span class="built_in">end</span>() &amp;&amp; !<span class="built_in">isspace</span>(*beg))</span><br><span class="line">&#123;</span><br><span class="line">    *beg = <span class="built_in">toupper</span>(*beg++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">aAAAAAA </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>结果并不是期望的遍历整个字符串并将所有字符换为大写，这是因为语句<code>*beg = toupper(*beg++)</code>是未定义的，它可能被解释为以下任何情况：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">*beg = <span class="built_in">toupper</span>(*beg)</span><br><span class="line">*(beg + <span class="number">1</span>) = <span class="built_in">toupper</span>(*beg)</span><br><span class="line"><span class="comment">//Others</span></span><br></pre></td></tr></table></figure>
<p>右侧的<code>*beg++</code>中的两个操作符的顺序是固定的，即先进行累加，在进行解引用。</p>
<p>但是左侧的<code>*beg</code>和右侧的<code>*beg++</code>哪个先进行运算结果是不一定的，如果先运行了左侧，则结果对应上述第一种可能，否则对应上述第二种可能。</p>
<h2 id="The-Member-Access-Operators"><a href="#The-Member-Access-Operators" class="headerlink" title="The Member Access Operators"></a>The Member Access Operators</h2><p><code>ptr-&gt;mem</code>相当于<code>(*ptr).mem</code></p>
<p>箭头操作需要对指针对象进行操作，且返回的是左参数，点操作返回的参数是左参数还是右参数由对象本身决定。</p>
<h2 id="The-Conditional-Operator"><a href="#The-Conditional-Operator" class="headerlink" title="The Conditional Operator"></a>The Conditional Operator</h2><p>条件操作符的形式为<code>cond ? expr1 : expr2</code>，和逻辑与和逻辑或一样，条件操作符同样也是最短求值，所以<code>expr1</code>和<code>expr2</code>中只会有一个参数被计算。</p>
<h3 id="Nesting-Conditional-Operations"><a href="#Nesting-Conditional-Operations" class="headerlink" title="Nesting Conditional Operations"></a>Nesting Conditional Operations</h3><p>当有多个条件操作符嵌套时，结合性是从右至左的，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestConditionalOperations</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> grade;</span><br><span class="line">    cin &gt;&gt; grade;</span><br><span class="line">    string <span class="keyword">final</span> = (grade &gt; <span class="number">90</span>) ? <span class="string">&quot;High Pass&quot;</span> : (grade &lt; <span class="number">60</span>) ? <span class="string">&quot;fail&quot;</span> : <span class="string">&quot;pass&quot;</span>;</span><br><span class="line">    <span class="comment">//Equals to:</span></span><br><span class="line">    <span class="comment">//(grade &gt; 90) ? &quot;High Pass&quot; : ((grade &lt; 60) ? &quot;fail&quot; : &quot;pass&quot;)</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Final is &quot;</span> &lt;&lt; <span class="keyword">final</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结合性是从右至左的，但是计算顺序仍然是从左至右，即会先计算<code>grade &gt; 90</code>的情况，再计算<code>grade &lt;60</code>。</p>
<h3 id="Using-a-Conditional-Operator-in-an-Output-Expression"><a href="#Using-a-Conditional-Operator-in-an-Output-Expression" class="headerlink" title="Using a Conditional Operator in an Output Expression"></a>Using a Conditional Operator in an Output Expression</h3><p>因为条件操作符（Conditional Operator）的优先级很低，所以在输出表达式中使用条件操作符时往往都需要加上括号，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; ((grade &lt; <span class="number">60</span>) ? <span class="string">&quot;fail&quot;</span> : <span class="string">&quot;pass&quot;</span>);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; (grade &lt; <span class="number">60</span>) ? <span class="string">&quot;fail&quot;</span> : <span class="string">&quot;pass&quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">// cout &lt;&lt; grade &lt; 60 ? &quot;fail&quot; : &quot;pass&quot;; //Error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">fail</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>第三个表达式无法正常编译，第二个表达式输出了1，因为都是因为<code>&lt;&lt;</code>操作比条件操作符有更高的优先级。</p>
<p>第二个表达式和第三个表达式等效为以下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cout &lt;&lt; (grade &lt; 60) ? &quot;fail&quot; : &quot;pass&quot;;</span></span><br><span class="line">cout &lt;&lt; (grade &lt;<span class="number">60</span>) ;</span><br><span class="line">cout ? <span class="string">&quot;fail&quot;</span> : <span class="string">&quot;pass&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// cout &lt;&lt; grade &lt; 60 ? &quot;fail&quot; : &quot;pass&quot;; //Error</span></span><br><span class="line">cout &lt;&lt; grade;</span><br><span class="line"><span class="comment">// cout &lt; 60 ? &quot;fail&quot; : &quot;pass&quot;; //Error, can not use &lt; on cout</span></span><br></pre></td></tr></table></figure>
<h2 id="The-Bitwise-Operators"><a href="#The-Bitwise-Operators" class="headerlink" title="The Bitwise Operators"></a>The Bitwise Operators</h2><p>位操作符（Bitwise Operators）使用整数类型来表示一系列的bits。如果操作的对象类型小于操作的结果类型，则会首先将操作的对象转换为结果类型，然后再进行操作。</p>
<p>位操作符的优先级及描述如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>优先级</th>
<th>操作</th>
<th>含义</th>
<th>代码实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>~</td>
<td>位取反</td>
<td>~expr</td>
</tr>
<tr>
<td>2</td>
<td>&lt;&lt;</td>
<td>左移</td>
<td>expr1 &lt;&lt; expr2</td>
</tr>
<tr>
<td>2</td>
<td>&gt;&gt;</td>
<td>右移</td>
<td>expr1 &gt;&gt; expr2</td>
</tr>
<tr>
<td>3</td>
<td>&amp;</td>
<td>与</td>
<td>expr1 &amp; expr2</td>
</tr>
<tr>
<td>3</td>
<td>^</td>
<td>异或</td>
<td>expr1 ^ expr2</td>
</tr>
<tr>
<td>3</td>
<td>\</td>
<td></td>
<td>或</td>
<td>expr1 \ expr2</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Bitwise-Shift-Operators"><a href="#Bitwise-Shift-Operators" class="headerlink" title="Bitwise Shift Operators"></a>Bitwise Shift Operators</h3><ol>
<li><p><code>&lt;&lt;</code>和<code>&gt;&gt;</code>都是位移操作，右侧的参数必须是正整数，而且必须小于左侧操作对象的bit数，否则将是未定义的。</p>
</li>
<li><p>位移运算结合性时从左至右的。</p>
</li>
<li><p>返回的结果是拷贝的左侧操作对象位移右侧参数后的结果，即位移运算不会影响原变量。</p>
</li>
<li><p>位移出边界的bit将被舍弃。</p>
</li>
<li><p>对于左移操作，如果操作对象是signed的，那么操作结果是未定义的，如果操作对象是unsigned的，数据左移后，在右侧装填0。<br>对于右移操作，如果操作对象是signed的，操作结果是基于实现的，可以实现为操作后左侧插入1，也可以实现为操作后左侧拷贝sign位（即数据的第一位）。如果操作对象是unsigned的，则在操作后在左侧插入0。</p>
<blockquote>
<p>在操作对象为signed时，左移和右移操作要么是未定义的，要么是基于实现的，都不可控。所以建议只对unsigned对象进行位移操作。</p>
</blockquote>
</li>
</ol>
<p>例子1：</p>
<p>如有一台设备，其中char为8-bits，int为16-bits，一个名为bits的char对象的值为0233（八进制表示），则其二进制表示为</p>
<p><code>10011011</code></p>
<p>首先将其，转换为int，拓展的位都为0，如下<br><code>00000000 10011011</code></p>
<p>如果执行的函数是<code>bits&lt;&lt;8</code>，即将bits左移8位，结果为</p>
<p><code>10011011 00000000</code>，最左侧的8位移除了范围，所以被丢弃了。</p>
<p>如果执行的函数是<code>bits &gt;&gt; 3</code>，即将bits右移动3位，结果为<br><code>000000000 00010011</code>，最右侧的三位移出了范围，所以被丢弃了。</p>
<h3 id="Bitwise-Not-Operator"><a href="#Bitwise-Not-Operator" class="headerlink" title="Bitwise Not Operator"></a>Bitwise Not Operator</h3><p>同样在操作前，如果操作对象的整数类型较小，需要将其提升为结果的整数类型，如结果为int（16-bits）,对象为char，且值为<code>10010111</code>，则对其进行取反操作的结果为：</p>
<p><code>11111111 01101000</code></p>
<h3 id="Bitwise-And-Or"><a href="#Bitwise-And-Or" class="headerlink" title="Bitwise And,Or"></a>Bitwise And,Or</h3><p>同样在操作前，如果操作对象的整数类型较小，需要将其提升为结果的整数类型。</p>
<p>对于异或操作，如果两个操作对象中，有且只有一个1，则结果为0，否则结果都为0。</p>
<p>例子2：</p>
<p>在一台int为21-bits，char为8-bits的设备上运行<code>~&#39;q&#39; &lt;&lt; 6</code>，该设备用Latin-1字符集，q二进制表示为<code>01110001</code>。</p>
<p>首先将其转换为int，结果为</p>
<p><code>00000000 00000000 00000000 01110001</code></p>
<p>然后进行取反操作，结果为</p>
<p><code>11111111 11111111 11111111 10001110</code>，</p>
<p>再左移6位，结果为</p>
<p><code>11111111 11111111 11100011 10000000</code></p>
<p>如果要将该结果转换为10进制，首先第一位数据是1，说明为负数，负数的二进制是补码，因此需要将该二进制转换为原码，首先减一，得到</p>
<p><code>11111111 11111111 11100011 01111111</code></p>
<p>再取反，得到</p>
<p><code>00000000 00000000 00011100 10000000</code></p>
<p>表达为10进制为7296,所以结果为-7296。</p>
<h3 id="Using-Bitwise-Operators"><a href="#Using-Bitwise-Operators" class="headerlink" title="Using Bitwise Operators"></a>Using Bitwise Operators</h3><p>如果有一个int值quiz1，需要将其第27位变为1，则可使用以下代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">quiz1 |= <span class="number">1UL</span> &lt;&lt; <span class="number">27</span>;</span><br></pre></td></tr></table></figure>
<p>如果要将其27位变为0，则可使用如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">quize1 &amp;= ~(<span class="number">1UL</span> &lt;&lt; <span class="number">27</span>);</span><br></pre></td></tr></table></figure>
<p>如想要的到第27位的值，可以使用如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> status= quiz1 &amp; (<span class="number">1UL</span> &lt;&lt; <span class="number">27</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Shift-Operators-Are-Left-Associateive"><a href="#Shift-Operators-Are-Left-Associateive" class="headerlink" title="Shift Operators Are Left Associateive"></a>Shift Operators Are Left Associateive</h3><p>位移操作符的结合性是从左至右的，而IO的操作符是继承自位移操作符的，因此IO的操作符的结合性也同样是从左至右的，因此如下代码将会无法通过编译：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; <span class="number">10</span> &lt;<span class="number">24</span>;</span><br></pre></td></tr></table></figure>
<p>因为&lt;&lt;的优先级高于关系操作符，因此上式实际上等于：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; <span class="number">10</span>;</span><br><span class="line">cout &lt; <span class="number">24</span></span><br></pre></td></tr></table></figure>
<p>因此会造成编译错误。</p>
<h2 id="The-sizeof-Operator"><a href="#The-sizeof-Operator" class="headerlink" title="The sizeof Operator"></a>The sizeof Operator</h2><p>sizeof操作符返回类型的大小，单位为byte，该操作符结合性是从右至左的，结果为<code>type_t</code>类型。有以下两种表达方式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sizeof</span> (type)</span><br><span class="line"><span class="keyword">sizeof</span> expr</span><br></pre></td></tr></table></figure>
<p>sizeof操作符并不会对操作对象求值，因此如果表达式的结果是未定义的也没关系。</p>
<p>对于sizeof有以下规则：</p>
<ol>
<li>对于char或者返回结果为char类型的表达式，sizeof的结果为1</li>
<li>对引用对象使用sizeof，结果为绑定的对象类型大小</li>
<li>对指针使用sizeof，结果为该设备上容纳地址需要的字节数（硬件相关）。</li>
<li>对数组使用sizeof，返回的是整个数组的大小，因为实际上数组的大小是数组类型的一部分</li>
<li>对string和vector使用sizeof，返回是这两个类的固定部分，即大小是固定的，并不随元素数量而变化。</li>
</ol>
<p>sizeof实例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s = <span class="string">&quot;ABCD&quot;</span>, ss = <span class="string">&quot;&quot;</span>, *sp = &amp;s;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(string) &lt;&lt; endl;<span class="comment">//32</span></span><br><span class="line">cout &lt;&lt; <span class="keyword">sizeof</span> ss &lt;&lt; endl;<span class="comment">//32</span></span><br><span class="line">cout &lt;&lt; <span class="keyword">sizeof</span> s &lt;&lt; endl;<span class="comment">//32</span></span><br><span class="line">cout &lt;&lt; <span class="keyword">sizeof</span> sp &lt;&lt; endl;<span class="comment">//8</span></span><br><span class="line">cout &lt;&lt; <span class="keyword">sizeof</span> *sp &lt;&lt; endl;<span class="comment">//32</span></span><br><span class="line">cout &lt;&lt; <span class="keyword">sizeof</span> s.<span class="built_in">size</span>() &lt;&lt; endl;<span class="comment">//8</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">size_t</span>) &lt;&lt; endl;<span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[<span class="number">3</span>]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(arr) &lt;&lt; endl;<span class="comment">//12</span></span><br><span class="line"><span class="type">int</span> arrr[<span class="number">4</span>]&#123;&#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(arrr) &lt;&lt; endl;<span class="comment">//16</span></span><br></pre></td></tr></table></figure>
<h2 id="Comma-Operator"><a href="#Comma-Operator" class="headerlink" title="Comma Operator"></a>Comma Operator</h2><p>逗号操作符（Comma Operator）使用两个操作对象，求值顺序是从左至右的，即逗号操作符可以保证操作对象求值的顺序。</p>
<p>逗号操作符会先对左手边的操作对象求值，然后丢弃结果，再对右手边的操作对象求值，然后返回结果，如果右手边的对象操作对象是左参数，则返回左参数，否则返回右参数。</p>
<p>如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">1</span>, y = <span class="number">3</span>, i;</span><br><span class="line">cin &gt;&gt; i;</span><br><span class="line">(i &gt; <span class="number">0</span>) ? ++x, ++y : --x, --y;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;x is &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y is &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">x is 2, y is 3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">-1</span></span><br><span class="line"><span class="comment"> x is 0, y is 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>因为逗号操作符的优先级是最低的，所以上式实际上为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">( (i &gt; <span class="number">0</span>) ? ++x, ++y : --x ), --y;</span><br></pre></td></tr></table></figure>
<p>无论如何，逗号操作符的右手边参数，<code>--y</code>都会被运行。</p>
<p>当i&gt;0时，执行的是<code>(++x,++y)</code>，然后再执行<code>--y</code>，因此结果为x=2,y=3。</p>
<p>当i&lt;0时，执行的是<code>--x</code>，再执行<code>--y</code>，所以结果为x=0,y=2</p>
<p>也因为逗号操作符的优先级是最低的，因此下式无法正常编译</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = --x , ++y;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Equals to</span></span><br><span class="line"><span class="comment">//int a = --x;</span></span><br><span class="line"><span class="comment">//,++y</span></span><br></pre></td></tr></table></figure>
<h2 id="Type-Conversions"><a href="#Type-Conversions" class="headerlink" title="Type Conversions"></a>Type Conversions</h2><p>C++会自动进行隐式转换，如表达式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">3.541</span> + <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>表达式中的3会先转换为double类型，然后相加的结果再转换为int类型。</p>
<p>隐式转换会在以下情况下发生：</p>
<ol>
<li>在多数表达式中，小于int的整数类型会被先转换为int类型</li>
<li>在条件中，非布尔值的表达式会转换为布尔值</li>
<li>在初始化中，初始化值会被转换为目标类型；在赋值中，等号右手边的参数类型会转换为左手边的参数类型</li>
<li>在算数和关系表达式中，如果操作数的类型不同，那么会转换为一个通用的类型（在下一节解释）</li>
</ol>
<h3 id="The-Arithmetic-Conversions"><a href="#The-Arithmetic-Conversions" class="headerlink" title="The Arithmetic Conversions"></a>The Arithmetic Conversions</h3><p>这节阐述的是算数类型的隐式转换，算数表达式中的隐式转换遵循以下规则：</p>
<ol>
<li><p>算术类型的转换会尽量保持精度，如<code>3.541+3</code>中是3转换为了double类型，因为这样可以保留结果的精度。</p>
</li>
<li><p>小的整数类型会被转换为大的整数类型，如<code>bool</code>, <code>short</code>, <code>unsigned short</code>, <code>char</code>, <code>unsigned char</code>都会默认尝试转换为int，如果int无法容纳参数值，则转换为unsigned int。<br>a. 如果与较小的整数类型进行计算的是比int更大的整数类型，则直接转换为该类型，如<code>&#39;a&#39;+12L</code>，会直接将’a’转换为long类型。<br>b. 注意这里必须是与较小的整数类型直接连接的，如<code>12+b+12L</code>中，b还是会先转换为int。<br>c. 如果更大的类型非整数类型，仍然会先转换为int再转换为目标类型，如<code>3.14L+&#39;a&#39;</code>，’a’会先转换为int。</p>
</li>
</ol>
<ol>
<li>signed和unsigned类型转换<br>a. 如果两个类型都是signed或都是unsigned，则较小的类型转换为较大的类型<br>b. 如果unsigned的类型大于等于signed的类型（这里比较的是类型，不是参数值），则signed类型转换至unsigned的目标类型。<br>c. 如果signed类型大于unsigned类型，则首先尝试将unsigned类型转换至signed的目标类型，如果signed目标类型无法容纳unsigned类型的参数值，则将signed类型转换至unsigned 目标类型。</li>
</ol>
<h3 id="Other-Implicit-Conversions"><a href="#Other-Implicit-Conversions" class="headerlink" title="Other Implicit Conversions"></a>Other Implicit Conversions</h3><p>除了算数类型的隐式转换，C++还有其他类型的隐式转换，如</p>
<ol>
<li><p>数组到指针的隐式转换：<br>如之前所述，在使用数组名称时，会自动转换为指向数组第一个元素的指针。<br>这个转换在以下情况不适用：<br>a. 使用decltype<br>b. 使用取地址符&amp;<br>c. 使用sizeof<br>d. typeid，在19.2.2节会说明</p>
</li>
<li><p>指针转换<br>指针转换包含以下几种：<br>a. 固定字面值0和字面值nullptr可以被转换至任意类型的指针（空指针）<br>b. 指向任何非const类型的指针可以转换至void<em><br>c. 指向任何类型的指针都可以转换至const void</em></p>
</li>
<li><p>布尔值转换<br>任何在表达式中的算数类型和指针都会被转换至布尔值，如果参数值为0为false，否则为true</p>
</li>
<li><p>const转换<br>a. 在初始化时，非const的对象可以初始化const对象。<br>b. 指向普通类型的指针也可以转换为指向const类型的指针。<br>c. 相反的操作，即将const类型转换至非const的隐式转换不存在。</p>
</li>
<li><p>类型自定义隐式转换<br>a. <code>string s = &quot;abc&quot;</code>就是string类型自定义的隐式转换，将C类型的字符串字面值转换为string类型<br>b. <code>while ( cin &gt;&gt; s)</code>也是cin类型自定义的隐式转换，将cin类型转换为布尔值</p>
</li>
</ol>
<h3 id="Explicit-Conversions"><a href="#Explicit-Conversions" class="headerlink" title="Explicit Conversions"></a>Explicit Conversions</h3><p>可以使用cast来进行显示转换，显示转换的格式为：</p>
<p><code>cast-name&lt;type&gt;(express)</code></p>
<p>其中<code>cast-name</code>为显示转换的方法，一共有四种，其中<code>dynamic_cast</code>在19.2节会进行详细说明，剩下三种如下：</p>
<h4 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h4><p>任何定义了的转换（除了low-level const）都可以通过静态转换（static_cast）来执行，这里的<code>定义</code>指的是可能存在的转换。如double和int之间存在转换，但vector和int之间不存在转换，因此前者可以使用静态转换，后者不行。</p>
<p>如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">10</span>, j = <span class="number">3</span>;</span><br><span class="line"><span class="type">double</span> slope = i / j;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;slope is &quot;</span> &lt;&lt; slope &lt;&lt; endl;</span><br><span class="line">slope = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(i) / j;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;slope is &quot;</span> &lt;&lt; slope &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">slope is 3</span></span><br><span class="line"><span class="comment">slope is 3.33333</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>直接进行<code>i/j</code>的话，因为两者都是int，所以结果也是int，因此输出的值为3。而通过static_cast将i的类型转换为double，此时j也会被隐式转换为double，因此结果为3.33。</p>
<p>通常也会用静态转换将<code>void*</code>转换到目标指针，如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *p = &amp;slope;</span><br><span class="line"><span class="type">double</span> *dp = <span class="built_in">static_cast</span>&lt;<span class="type">double</span> *&gt;(p);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;slope is &quot;</span> &lt;&lt; (*dp) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">slope is 3.33333</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><code>void*</code>转换为的目标指针必须是原先的值匹配，否则结果是未定义的。</p>
<h4 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h4><p>low-level的const只能通过<code>const_cast</code>显示转换，<code>const_cast</code>唯一能做的是也只是转换low-level的const。</p>
<p>如:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *value1 = &amp;i;</span><br><span class="line"><span class="comment">// int *valueP = value;</span></span><br><span class="line"><span class="type">int</span> *value2 = <span class="built_in">const_cast</span>&lt;<span class="type">int</span> *&gt;(value1);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;value1 is &quot;</span> &lt;&lt; (*value1) &lt;&lt; endl;</span><br><span class="line">*value2 = <span class="number">3</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;value1 is &quot;</span> &lt;&lt; (*value1) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;value2 is &quot;</span> &lt;&lt; (*value2) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">value1 is 10</span></span><br><span class="line"><span class="comment">value1 is 3</span></span><br><span class="line"><span class="comment">value2 is 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>通过了const_cast，上式将<code>const int *</code>赋值给了普通的<code>int*</code>。甚至通过<code>int*</code>修改了参数，但是C++标准中，修改通过const_cast得到的指针结果是未定义的。</p>
<ul>
<li>虽然在测试中得到了期望的结果，但是极度不推荐用这样的方法。</li>
</ul>
<h4 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h4><p>reinterpret_cast可以在更低的层次转换类型，因此提供了更多的转换可能。</p>
<p>但在转换后的类型很可能是无法正常操作的，如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *ip;</span><br><span class="line"><span class="type">char</span>* cstr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(ip);</span><br><span class="line">string str = cstr;</span><br></pre></td></tr></table></figure>
<p>代码中，将<code>int*</code>转换为了<code>char*</code>，并用它来初始化<code>string</code>，在编译过程中代码不会出现任何问题，但在运行时的结果是未定义的，因为实际上<code>char*</code>和<code>int*</code>在bit层面的解释方法是不一样的。</p>
<ul>
<li>尽量避免使用reinterpret_cast,该操作太危险了</li>
</ul>
<h4 id="Old-Style-Casts"><a href="#Old-Style-Casts" class="headerlink" title="Old-Style Casts"></a>Old-Style Casts</h4><p>在C语言中，可以通过以下两种方式进行显示转换：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">type (expr)</span><br><span class="line">(type) expr</span><br><span class="line"></span><br><span class="line"><span class="comment">//Like,</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *pc;</span><br><span class="line"><span class="type">int</span> i = <span class="type">int</span>(*pc);</span><br><span class="line">i = (<span class="type">int</span>)(*pc);</span><br></pre></td></tr></table></figure>
<p>old-stype转换与上述的三个显示转换实际上是等效的，它会首先尝试进行<code>static_cast</code>和<code>const_cast</code>，如果是合法的，则进行相应操作，如果这两个都不合法，则进行<code>reinterpret_cast</code>操作。</p>
<p>如以下两个操作是等效的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> string *ps;</span><br><span class="line"><span class="type">void</span> *pv;</span><br><span class="line">pv = <span class="built_in">static_cast</span>&lt;<span class="type">void</span> *&gt;(<span class="built_in">const_cast</span>&lt;string *&gt;(ps));</span><br><span class="line">pv = (<span class="type">void</span> *)ps;</span><br></pre></td></tr></table></figure>
<h2 id="Operator-Precedence-Table"><a href="#Operator-Precedence-Table" class="headerlink" title="Operator Precedence Table"></a>Operator Precedence Table</h2><p>下图为C++所有操作符的含义，实例代码，结合性，优先级以双横线区分：</p>
<p><img src="CPPPrimer-Chapter4-Notes/2020-02-17-23-16-54.png" alt="操作符1"></p>
<p><img src="CPPPrimer-Chapter4-Notes/2020-02-17-23-17-07.png" alt="操作符2"></p>
<div class="note info simple"><p>引用：</p>
<ol>
<li><em>Cpp Primer</em> 5th Aug.2012</li>
</ol>
</div>
<hr>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>计算机语言</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>《C++ Primer》 第五章笔记</title>
    <url>/CPPPrimer-Chapter5-Notes/</url>
    <content><![CDATA[<p>《C++ Primer》 第五章笔记</p>
<p>讨论了基础语句，循环语句和条件判断语句，以及讨论了C++的异常处理。</p>
<p><img src="CPPPrimer-Chapter5-Notes/Ch_5.png" alt="第五章内容"></p>
<span id="more"></span>
<h1 id="Chapter-5-Statements"><a href="#Chapter-5-Statements" class="headerlink" title="Chapter 5 Statements"></a>Chapter 5 Statements</h1><h2 id="Simple-Statements"><a href="#Simple-Statements" class="headerlink" title="Simple Statements"></a>Simple Statements</h2><h3 id="Null-Statements"><a href="#Null-Statements" class="headerlink" title="Null Statements"></a>Null Statements</h3><p>一个单一的分号即构成了一条空语句（Null Statements），当语言语法需要一条语句，但是代码逻辑并不需要的时候，空语句是很有用的。如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(cin&gt;&gt; s &amp;&amp; s != sought)</span><br><span class="line">    ;   <span class="comment">//null Statements</span></span><br></pre></td></tr></table></figure>
<p>建议在每个空语句后都加上注释，表明是故意使用空语句而不是不小心遗漏。</p>
<h3 id="Compound-Statements-Blocks"><a href="#Compound-Statements-Blocks" class="headerlink" title="Compound Statements(Blocks)"></a>Compound Statements(Blocks)</h3><p>多条语句可以放在一个代码块中，代码块以两个大括号构成。如果代码块中没有任何的语句，则相当于一个空语句，如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(cin&gt;&gt; s &amp;&amp; s != sought)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Statement-Scope"><a href="#Statement-Scope" class="headerlink" title="Statement Scope"></a>Statement Scope</h2><p>可以在<code>if</code>, <code>switch</code>,<code>while</code>和<code>for</code>的控制语句中定义变量，在控制语句中定义的变量，只在其对应的作用域下有用，如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="type">int</span> i = <span class="built_in">getNum</span>())</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;i is &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// i = 0; //error, out of scope</span></span><br></pre></td></tr></table></figure>
<h2 id="Conditional-Statements"><a href="#Conditional-Statements" class="headerlink" title="Conditional Statements"></a>Conditional Statements</h2><h3 id="The-if-Statement"><a href="#The-if-Statement" class="headerlink" title="The if Statement"></a>The if Statement</h3><p>If与C语言的If语句类似。</p>
<h4 id="Dangling-else"><a href="#Dangling-else" class="headerlink" title="Dangling else"></a>Dangling else</h4><p>当if和else的数量不匹配时，else该与哪个if结合称为<code>dangling else</code>问题，C++的解决方法是，else与上方最近的未匹配其他else的if语句结合。</p>
<h3 id="The-switch-Statement"><a href="#The-switch-Statement" class="headerlink" title="The switch Statement"></a>The switch Statement</h3><p>switch语句的构造如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (expression)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> caseLabel1:</span><br><span class="line">        <span class="comment">//some code</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> caseLabel2:</span><br><span class="line">        <span class="comment">//some code</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> caseLabel3:</span><br><span class="line">        <span class="comment">//some code</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">//some code</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>expression</code>可以是一个变量的定义语句，或普通的一个变量，但expression必须是可以转换到整数类型的，expression的值会与每一个<code>caseLabel</code>进行比较，决定进入哪个case。</p>
<p>当进入一个case后，case内的代码会被执行，然后会进入顺应的下一个case，直到遇见<code>break</code>语句为止，所以在大多数情况下，每一个case中都会有一个break语句。</p>
<blockquote>
<p>如果在某个case下故意的不加入break，要继续执行下一个case中的代码时，建议加上注释表明不是意外遗漏了break。</p>
</blockquote>
<p><code>caseLabel</code>必须是一固定的整数表达式参数（Integral constant），如<code>case 3.14:</code>，<code>case ival</code>（ival不是const int）等语句都无法通过编译。</p>
<p>当所有的case都不满足时，会进入<code>default</code>中，虽然default case不是强制的，但还是建议添加default。</p>
<h4 id="Variable-Definitions-inside-the-Body-of-a-switch"><a href="#Variable-Definitions-inside-the-Body-of-a-switch" class="headerlink" title="Variable Definitions inside the Body of a switch"></a>Variable Definitions inside the Body of a switch</h4><p>因为switch下所有case都是在一个作用域中（并没有大括号进行分割），所以在一个case中定义的变量是可以在另一个case中使用的，但是定义变量时不能进行初始化，因为初始化的case并不一定会被选中，如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (val)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="comment">// string file_name; //error, default initialization, and the initialization may bebypassed</span></span><br><span class="line">    <span class="comment">// int ival = 0;//error, the initialization may be bypassed</span></span><br><span class="line">    <span class="type">int</span> jval; <span class="comment">//int is build-in type and this is in function so it isn&#x27;t initialiazed</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    jval = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中的file_name和ival都会造成编译失败，两者都有初始化的过程，file_name虽然没有指定初始化变量，但是因为它不是内建类型，所以会被默认初始化。</p>
<p>如果确实需要在某个case下定义变量且要初始化，那么只能将这个case的作用域与其他case分开，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (val)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// string file_name; //error, default initialization, and the initialization may bebypassed</span></span><br><span class="line">    <span class="comment">// int ival = 0;//error, the initialization may be bypassed</span></span><br><span class="line">    <span class="type">int</span> jval; <span class="comment">//int is build-in type and this is in function so it isn&#x27;t initialiazed</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="comment">// jval = 2;//error, jval is in another code scope</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Iterative-Statements"><a href="#Iterative-Statements" class="headerlink" title="Iterative Statements"></a>Iterative Statements</h2><p><code>while</code>和<code>for</code>在执行body的代码前会先进行条件判断，而<code>do while</code>会先执行一次body代码，再进行条件判断</p>
<h3 id="The-while-Statement"><a href="#The-while-Statement" class="headerlink" title="The while Statement"></a>The while Statement</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition)</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure>
<p>在condition或statement中定义的变量会在每一次的迭代中被创建和摧毁。</p>
<h3 id="Traditional-for-Statement"><a href="#Traditional-for-Statement" class="headerlink" title="Traditional for Statement"></a>Traditional for Statement</h3><p>for语句的标准形式为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (initializer; condition; expression)</span><br><span class="line">    statement;</span><br></pre></td></tr></table></figure>
<p>for语句的执行顺序是：先执行<code>initializer</code>，再执行<code>condition</code>判断条件，如果不满足则退出for循环，否则执行<code>statement</code>再执行<code>expression</code>。然后再次回到<code>condtion</code>进行循环。</p>
<p>如while循环一样，在<code>initialzier</code>中定义的变量的作用域只在控制语句和statement内部。</p>
<h4 id="Multiple-Definitions-in-the-for-Header"><a href="#Multiple-Definitions-in-the-for-Header" class="headerlink" title="Multiple Definitions in the for Header"></a>Multiple Definitions in the for Header</h4><p>在<code>initializer</code>中可以定义多个变量，但只能使用一条定义语句，因此所有初始化的变量都是一个类型的，如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">decltype</span>(v.<span class="built_in">size</span>()) i = <span class="number">0</span>, sz = v.<span class="built_in">size</span>(); i != sz; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    v.<span class="built_in">push_back</span>(v[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;val : v)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>在第一个for循环中，定义了i和sz两个变量。</p>
<h4 id="Omitting-Parts-of-the-for-Header"><a href="#Omitting-Parts-of-the-for-Header" class="headerlink" title="Omitting Parts of the for Header"></a>Omitting Parts of the for Header</h4><p>for控制语句中的<code>initializer</code>, <code>condition</code>, <code>expression</code>都是可以被省略的。</p>
<p>如果<code>condition</code>被省略，相当于将true作为condition，因此为了避免死循环，必须在循环body中使用break。</p>
<h3 id="Range-for-Statement"><a href="#Range-for-Statement" class="headerlink" title="Range for Statement"></a>Range for Statement</h3><p>range for循环的结构如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(declaration: expression)</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure>
<p>expression必须是用大括号括起的一系列元素，或者数组，或者带有begin, end迭代器的类型（如vector和string）。</p>
<p>declaration的类型必须是expression中元素的类型匹配，可以使用auto来简化操作。</p>
<p>如果要修改元素，必须将declaration的类型设置为引用，且使用引用也可以避免元素的拷贝来提升性能。</p>
<p>declaration中的变量会在每次statment执行后运行，并且用下一个元素来进行初始化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;val : &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在range for中添加或删除元素可能会造成错误，这是因为range for循环的范围，即最终结束的end是被缓存下来的，在其中修改了元素的数量，range for的范围也不会改变。</p>
<h3 id="The-do-while-Statement"><a href="#The-do-while-Statement" class="headerlink" title="The do while Statement"></a>The do while Statement</h3><p><code>do while</code>与<code>while</code>很类似，只是在statement执行后再检查condition，如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">do</span></span></span><br><span class="line"><span class="function">    statement</span></span><br><span class="line"><span class="function"><span class="title">while</span><span class="params">(condition)</span></span></span><br></pre></td></tr></table></figure>
<p>因为<code>do while</code>的condition会后执行，所以condition中不允许定义变量，否则将会出现statement中使用未定义变量的情况。</p>
<h2 id="Jump-Statements"><a href="#Jump-Statements" class="headerlink" title="Jump Statements"></a>Jump Statements</h2><p>C++中一共有四种跳转语句，<code>break</code>,<code>continue</code>,<code>goto</code>,<code>return</code>，<code>return</code>会在6.3节介绍。</p>
<h3 id="The-break-Statement"><a href="#The-break-Statement" class="headerlink" title="The break Statement"></a>The break Statement</h3><p>break语句可以出现在<code>while</code>，<code>do while</code>，<code>for</code>和<code>switch</code>语句中，break语句只影响最近的loop或者switch语句，使用了break后会终止整个循环。</p>
<h3 id="The-continue-Statement"><a href="#The-continue-Statement" class="headerlink" title="The continue Statement"></a>The continue Statement</h3><p>continue语句会终止当前的循环语句，并进入下一次循环。continue只出现在for,while和do while中（break还能出现在switch中），continue只有在switch是嵌套在循环中的时候才能写在switch内部，而且终止的也是嵌套switch的循环。</p>
<p>在while和do while中，continue后执行的是循环的condition，在传统for循环中，continue后执行的是for循环控制语句的expression，在range for中，continue后执行的是用下一个元素初始化declaration中的变量。</p>
<h3 id="The-goto-Statement"><a href="#The-goto-Statement" class="headerlink" title="The goto Statement"></a>The goto Statement</h3><p>goto语句提供了无条件的跳转，goto语句可以跳转到同一函数中的另一个语句中，如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">int</span> print1;</span><br><span class="line">    cin &gt;&gt; val;</span><br><span class="line">    <span class="keyword">if</span> (val == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> print0;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">goto</span> print1;</span><br><span class="line"></span><br><span class="line">print0:</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is 0&quot;</span> &lt;&lt; endl;</span><br><span class="line">print1:</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is 1&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>其中goto语句后跟着的print0和print1称为label，label指定了程序的跳转点。且label的命名和变量的命名是独立的，如代码中，定义了变量print1和label print1。</p>
<blockquote>
<p>goto的作用域是同一个函数，即只能跳转到同一个函数中定义的label中。</p>
</blockquote>
<p>goto语句还可以向上跳转，向上跳转的过程中，如果遇到了定义变量的语句，被定义的变量会被销毁，并重新构造，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">begin:</span><br><span class="line">    <span class="type">int</span> sz = <span class="built_in">getNum</span>();</span><br><span class="line">    <span class="keyword">if</span> (sz &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> begin;</span><br></pre></td></tr></table></figure>
<p>上述代码中，如果执行了<code>goto begin</code>，则变量sz会被销毁并被重新定义。</p>
<h2 id="Try-Blocks-and-Exception-Handling"><a href="#Try-Blocks-and-Exception-Handling" class="headerlink" title="Try Blocks and Exception Handling"></a>Try Blocks and Exception Handling</h2><p>异常（Exceptions）是runtime时的不正常情况，如数据库连接错误，错误输入等。</p>
<p>异常处理是在程序的一部分检测到问题时，抛出异常信息，由另一部分程序来处理异常信息且问题之后的代码将不再运行。</p>
<p>C++的异常处理由三部分构成：</p>
<ol>
<li>throw expressions：当检测到错误时，使用throw来抛出异常信息。</li>
<li>try blocks，用来标记需要检测的代码部分，try block由语句try开始，由一个或多个catch语句作为终止。catch语句后的代码块是处理异常的代码。</li>
<li>一系列异常类，用来提供关于异常的信息。</li>
</ol>
<p>示例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> salesNum1, salesNum2;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; salesNum1 &gt;&gt; salesNum2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (salesNum1 &lt; <span class="number">0</span> || salesNum2 &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;num can&#x27;t be less than 0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> total = salesNum1 + salesNum2;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Total num is &quot;</span> &lt;&lt; total &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (runtime_error err)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; err.<span class="built_in">what</span>() &lt;&lt; <span class="string">&quot;, try again?&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">        cin &gt;&gt; c;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">20 11</span></span><br><span class="line"><span class="comment">Total num is 31</span></span><br><span class="line"><span class="comment">-1 25</span></span><br><span class="line"><span class="comment">num can&#x27;t be less than 0, try again?</span></span><br><span class="line"><span class="comment">y</span></span><br><span class="line"><span class="comment">22 20</span></span><br><span class="line"><span class="comment">Total num is 42</span></span><br><span class="line"><span class="comment">-2 1</span></span><br><span class="line"><span class="comment">num can&#x27;t be less than 0, try again?</span></span><br><span class="line"><span class="comment">n</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>当运行了<code>throw</code>语句后，之后的代码将不再运行，在示例代码中，抛出的是<code>runtime_error</code>异常，该异常定义在头文件<code>stdexcept</code>中，且必须通过string或C风格的字符串来初始化。关于不同类型的异常，将在之后章节中说明。</p>
<p>try语句块就是被检测的代码部分，注意其中定义的变量作用域仅在try代码块中，即使在后面的catch代码块中也无法访问。</p>
<p>try代码块后跟着一个或多个catch语句，每个catch负责一个错误类型，如果try代码块中抛出的错误语句与catch的错误类型匹配，则会进入相应的catch代码块，代码块中就是错误处理。</p>
<p>注意其中使用了<code>err.what()</code>，这里的<code>err</code>就是监听到的异常信息，由try中通过throw抛出。每个异常类都定义了<code>what</code>函数，该函数返回用于初始化异常对象的语句，在本例中即是<code>num can&#39;t be less than 0</code>，返回的类型是C风格的字符串。</p>
<h4 id="Functions-Are-Exited-during-the-Search-for-a-Handler"><a href="#Functions-Are-Exited-during-the-Search-for-a-Handler" class="headerlink" title="Functions Are Exited during the Search for a Handler"></a>Functions Are Exited during the Search for a Handler</h4><p>如果出现了try代码块的中嵌套了多个其他的try，则当某个try代码块中抛出了异常信息，则会先在这个try对应的catch语句中搜索对应的异常处理。如果没有则再更外层的try代码块中找对应的异常处理。</p>
<p>如果最终没有搜索到对应的异常处理，将会执行标准库中的函数<code>terminate</code>，该函数的实现是系统相关的，但无论什么实现都保证程序之后的部分不会被继续执行。</p>
<p>如果一段程序再非try块中发生了异常，则会是直接调用<code>terminate</code>函数。</p>
<h4 id="Writing-Exception-Safe-code-is-hard"><a href="#Writing-Exception-Safe-code-is-hard" class="headerlink" title="Writing Exception Safe code is hard"></a>Writing Exception Safe code is hard</h4><p>当一个异常发生时，代码中的一部分被执行了，另一部分没有被执行。这就可能造成物体只初始化了一部分或者一些物体没有被释放等等，这些都需要在代码的异常处理中完成。</p>
<p>如果一个程序的异常处理部分可以完全解决异常遗留下的各种问题，那么就说这个异常处理是安全的（Exception safe）。但要实现一份安全的异常处理是很困难的，需要额外的细心和考虑到各种可能的情况。</p>
<h3 id="Standard-Exceptions"><a href="#Standard-Exceptions" class="headerlink" title="Standard Exceptions"></a>Standard Exceptions</h3><p>C++库中所有的异常类型定义在四个头文件中：</p>
<ol>
<li><code>exception</code>头文件，定义了最通用的异常类型<code>exception</code>，这个类型只能告知有异常发生，但无法提供任何额外的信息。</li>
<li><code>new</code>头文件，定义了<code>bad_alloc</code>异常类型，会在12.1.2节进行说明</li>
<li><code>type_info</code>头文件，定义了<code>bad_cast</code>异常类型，会在19.2节说明</li>
<li><code>stdexcept</code>头文件，该头文件定义了一系列常用的异常类。如下表所示：</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>异常类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>exception</td>
<td>最普通的异常</td>
</tr>
<tr>
<td>runtime_error</td>
<td>只能在runtime检测到的异常</td>
</tr>
<tr>
<td>range_error</td>
<td>运行时的错误，结果超出了有效范围</td>
</tr>
<tr>
<td>overflow_error</td>
<td>运行时的错误，计算上溢</td>
</tr>
<tr>
<td>underflow_error</td>
<td>运行时错误，计算下溢</td>
</tr>
<tr>
<td>logic_error</td>
<td>逻辑错误</td>
</tr>
<tr>
<td>domain_error</td>
<td>逻辑错误，没有结果的参数</td>
</tr>
<tr>
<td>invalid_error</td>
<td>逻辑错误，不合适的参数</td>
</tr>
<tr>
<td>length_error</td>
<td>逻辑错误，尝试创建大于物体最大值的参数</td>
</tr>
<tr>
<td>out_of_error</td>
<td>逻辑错误，使用了超出合理范围的参数</td>
</tr>
</tbody>
</table>
</div>
<p><code>exception</code>，<code>bad_accloc</code>和<code>bad_cast</code>类都使用默认初始化，无法提供其他的初始值。<code>stdexcept</code>中定义的一系列异常处理类，都必须用string或者C风格的字符串进行初始化，没有默认的构造函数。</p>
<p>所有的异常都有且只有一个函数<code>what</code>，该函数返回值类型为<code>const char*</code>，用来说明异常的信息。对于<code>stdexcept</code>中的异常类，返回的信息即是在初始化异常对象时传入的信息，对于其他的异常类，返回的内容由编译器决定。</p>
<div class="note info simple"><p>引用：</p>
<ol>
<li><em>Cpp Primer</em> 5th Aug.2012</li>
</ol>
</div>
<hr>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>计算机语言</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>《C++ Primer》 第六章笔记</title>
    <url>/CPPPrimer-Chapter6-Notes/</url>
    <content><![CDATA[<p>《C++ Primer》 第六章笔记。</p>
<p>关于函数的定义，函数参数的传递方式，函数重载，函数指针。</p>
<p><img src="CPPPrimer-Chapter6-Notes/Ch_6.png" alt="第六章内容"></p>
<span id="more"></span>
<h1 id="Chapter-6-Functions"><a href="#Chapter-6-Functions" class="headerlink" title="Chapter 6 Functions"></a>Chapter 6 Functions</h1><h2 id="Function-Basics"><a href="#Function-Basics" class="headerlink" title="Function Basics"></a>Function Basics</h2><h4 id="Parameters-and-Arguments"><a href="#Parameters-and-Arguments" class="headerlink" title="Parameters and Arguments"></a>Parameters and Arguments</h4><p>函数的形参（Parameters）和实参（Arguments）是一一对应关系，但是编译器不能保证形参被初始化的顺序。</p>
<h4 id="Function-Parameter-List"><a href="#Function-Parameter-List" class="headerlink" title="Function Parameter List"></a>Function Parameter List</h4><p>为了与C语言兼容，C++同样允许用void来作为形参的参数，如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数的名字是可选的。但是如果没有设置参数名字，但因为参数没有名字所以无法在函数内部引用。但是未命名的参数还是需要指定实参的，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pareNoName</span><span class="params">(<span class="type">int</span>, <span class="type">float</span> fval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pareNoName(0.1f);//Although int doesn&#x27;t have name, we still must assign it</span></span><br><span class="line"><span class="built_in">pareNoName</span>(<span class="number">3</span>, <span class="number">0.1f</span>);</span><br></pre></td></tr></table></figure>
<h4 id="Function-Return-Type"><a href="#Function-Return-Type" class="headerlink" title="Function Return Type"></a>Function Return Type</h4><p>函数返回的类型不能是数组类型，也不能是函数类型，但可以返回函数和数组的指针，以及函数的调用（相当于返回调用的函数的结果）。</p>
<h3 id="Local-Objects"><a href="#Local-Objects" class="headerlink" title="Local Objects"></a>Local Objects</h3><p>对于一个变量而言，需要关注它的作用域以及生命周期。</p>
<p>在函数内部定义的变量称为局部变量，如果局部变量与全局变量有相同的名称，局部变量会隐藏全局变量的定义，如果想要调用全局变量，需要用到作用域符号<code>::</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> val = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestLocalObject</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> val = <span class="number">3</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;local val is &quot;</span> &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;global val is &quot;</span> &lt;&lt; ::val &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    local val is 3</span></span><br><span class="line"><span class="comment">    global val is 2</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>全局变量的生命周期是从定义到程序终止，局部变量的生命周期是当退出了作用域。</p>
<h4 id="Automatic-Objects"><a href="#Automatic-Objects" class="headerlink" title="Automatic Objects"></a>Automatic Objects</h4><p>函数的形参就是自动物体（Automatic Objects），它们在函数开始时被分配创建， 在函数终结时被释放。</p>
<h4 id="Local-static-Objects"><a href="#Local-static-Objects" class="headerlink" title="Local static Objects"></a>Local static Objects</h4><p>局部静态物体是在第一次被调用时创建，在程序终止时被摧毁，作用域在函数内部。如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">count_calls</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> ctr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ++ctr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestStaticObjects</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">count_calls</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1</span></span><br><span class="line"><span class="comment">    2</span></span><br><span class="line"><span class="comment">    3</span></span><br><span class="line"><span class="comment">    4</span></span><br><span class="line"><span class="comment">    5</span></span><br><span class="line"><span class="comment">    6</span></span><br><span class="line"><span class="comment">    7</span></span><br><span class="line"><span class="comment">    8</span></span><br><span class="line"><span class="comment">    9</span></span><br><span class="line"><span class="comment">    10</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态的局部变量执行的是值初始化，因此即使是内建类型，它也会默认值，不会像普通的内建局部变量一样变成未定义的。</p>
<h3 id="Function-Declarations"><a href="#Function-Declarations" class="headerlink" title="Function Declarations"></a>Function Declarations</h3><p>如同变量一样，函数也只能被定义一次，但可以多次声明。</p>
<p>如果是函数声明，则使用分号取代函数主体，也因为声明并没有函数主体，所以所有的形参有没有名字都没有区别。</p>
<p>如<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pareName</span><span class="params">(<span class="type">int</span> val, <span class="type">float</span> fval)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pareName</span><span class="params">(<span class="type">int</span>, <span class="type">float</span>)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>一个函数的类型由函数名字，返回类型以及形参类型决定，函数的类型也成为函数原型(function prototype)。</p>
<h4 id="Function-Declarations-Go-in-Header-Files"><a href="#Function-Declarations-Go-in-Header-Files" class="headerlink" title="Function Declarations Go in Header Files"></a>Function Declarations Go in Header Files</h4><p>函数的声明应该在头文件中，函数的定义在源文件中，这样如果后续要修改函数的声明，只需要改动一处即可。</p>
<p>在定义函数的源文件中，需要引入声明的头文件。</p>
<h3 id="Separate-Compilation"><a href="#Separate-Compilation" class="headerlink" title="Separate Compilation"></a>Separate Compilation</h3><h4 id="Compiling-and-Linking-Multiple-Source-Files"><a href="#Compiling-and-Linking-Multiple-Source-Files" class="headerlink" title="Compiling and Linking Multiple Source Files"></a>Compiling and Linking Multiple Source Files</h4><p>如我们将函数<code>GetNum</code>声明在头文件<code>GetNum.h</code>中，将函数的定义写在源文件<code>GetNum.cpp</code>中，将调用<code>GetNum</code>的语句写在源文件<code>Chapter6_Functions.cpp</code>中，则所有的文件内容如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//GetNum.h</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetNum</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//GetNum.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GetNum.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetNum</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Chapter6_Functions.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GetNum.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">GetNum</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>对于有多个源文件（CPP）文件的情况下，编译时要把所有的源文件都带上，源文件的顺序并不造成影响，如：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">g++ Chapter6_Functions.cpp GetNum.cpp</span><br></pre></td></tr></table></figure>
<p>也可以单独编译（带上-c flag）某个源文件（必须是与其他源文件不依赖的），将其编译为.o文件，之后再编译其他依赖该源文件的文件时，只要带上.o文件，而不需要重新编译该文件，如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">g++ -c GetNum.cpp</span><br><span class="line">g++ Chapter6_Functions.cpp GetNum.o</span><br></pre></td></tr></table></figure>
<h2 id="Argument-Passing"><a href="#Argument-Passing" class="headerlink" title="Argument Passing"></a>Argument Passing</h2><p>当调用函数时，实际上是用实参初始化了形参，初始化的过程与一般的参数初始化一样。而如果形参的类型是引用的话，那么会直接绑定至实参，否则的话初始化时会拷贝实参的值。</p>
<p>如果形参的参数是引用，称实参是引用传递（Paseed by reference或called by reference）。</p>
<p>如果形参的类型不是引用，那么实参会进行拷贝，称实参是值传递（Passed by value或called by value）。</p>
<h3 id="Passing-Arguments-by-Value"><a href="#Passing-Arguments-by-Value" class="headerlink" title="Passing Arguments by Value"></a>Passing Arguments by Value</h3><p>当形参是值传递时，修改函数中的局部变量并不会影响实参。</p>
<h4 id="Pointer-Parameters"><a href="#Pointer-Parameters" class="headerlink" title="Pointer Parameters"></a>Pointer Parameters</h4><p>指针与其他非引用的变量一样，形参会通过拷贝实参的值进行初始化。但是指针的值即是指向的对象，因此拷贝生成的形参与实参指向的是同一个变量，也因此通过形参修改对象也同样会影响实参指向的对象。</p>
<p>如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(<span class="type">int</span> *val1, <span class="type">int</span> *val2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = (*val1);</span><br><span class="line">    *val1 = *val2;</span><br><span class="line">    *val2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Exercise6_10</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> val1 = <span class="number">10</span>, val2 = <span class="number">5</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Val 1 is &quot;</span> &lt;&lt; val1 &lt;&lt; <span class="string">&quot;, Val2 is &quot;</span> &lt;&lt; val2 &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">Swap</span>(&amp;val1, &amp;val2);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Val 1 is &quot;</span> &lt;&lt; val1 &lt;&lt; <span class="string">&quot;, Val2 is &quot;</span> &lt;&lt; val2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Passing-Argument-by-Reference"><a href="#Passing-Argument-by-Reference" class="headerlink" title="Passing Argument by Reference"></a>Passing Argument by Reference</h3><p>使用引用传递就可以在函数内部修改实参的值，如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestCallByReference</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> val1 = <span class="number">10</span>, val2 = <span class="number">5</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Val 1 is &quot;</span> &lt;&lt; val1 &lt;&lt; <span class="string">&quot;, Val2 is &quot;</span> &lt;&lt; val2 &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">Swap</span>(val1, val2);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Val 1 is &quot;</span> &lt;&lt; val1 &lt;&lt; <span class="string">&quot;, Val2 is &quot;</span> &lt;&lt; val2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(<span class="type">int</span> &amp;val1, <span class="type">int</span> &amp;val2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = val1;</span><br><span class="line">    val1 = val2;</span><br><span class="line">    val2 = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Using-Reference-to-Avoid-Copies"><a href="#Using-Reference-to-Avoid-Copies" class="headerlink" title="Using Reference to Avoid Copies"></a>Using Reference to Avoid Copies</h4><p>函数可以通过将形参设置为引用类型来避免拷贝的过程，进而可以提升性能。</p>
<p>且尽量使用const reference，本章的后小节会进行说明。</p>
<h4 id="Using-Reference-Parameters-to-Return-Additional-Information"><a href="#Using-Reference-Parameters-to-Return-Additional-Information" class="headerlink" title="Using Reference Parameters to Return Additional Information"></a>Using Reference Parameters to Return Additional Information</h4><p>一个函数只可以返回一个值，在需要返回多个参数的时候，也可以通过引用，将要返回的参数作为形参的一部分传递进函数，并在函数内部修改成结果的值。</p>
<h3 id="const-Parameters-and-Arguments"><a href="#const-Parameters-and-Arguments" class="headerlink" title="const Parameters and Arguments"></a>const Parameters and Arguments</h3><p>如普通的参数初始化一样，当使用实参来初始化形参时，top-level的const会被无视，如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestConstParametersAndArguments</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> ci = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">func</span>(ci);</span><br><span class="line">    <span class="built_in">func</span>(i);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    value is 3</span></span><br><span class="line"><span class="comment">    value is 2</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;value is &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void func(int i) &#123;&#125;//Error,redefines</span></span><br></pre></td></tr></table></figure>
<p>函数func的形参类型为const int，但是可以用int的来进行初始化，因为这里是top-level的const。也因此函数<code>func(int)</code>和函数<code>func(const int)</code>是无法同时定义的，不然当使用int调用参数时，两个函数都可匹配。</p>
<h4 id="Use-Reference-to-const-When-Possible"><a href="#Use-Reference-to-const-When-Possible" class="headerlink" title="Use Reference to const When Possible"></a>Use Reference to const When Possible</h4><p>当可能的时候尽量使用const referencce，因为</p>
<ol>
<li>const reference可以避免函数中意外的修改实参值</li>
<li>普通reference形参，不能通过字面值进行初始化</li>
<li>普通reference形参，不能通过非const实参进行初始化</li>
</ol>
<p>如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> string ss = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="comment">// funs(&quot;&quot;);//error,can not use literal to initialize string reference</span></span><br><span class="line"><span class="comment">// funs(ss);//error,can not use const string to initialize stringreference</span></span><br><span class="line"><span class="built_in">funss</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="built_in">funss</span>(ss);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">funs</span><span class="params">(string &amp;s)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">funss</span><span class="params">(<span class="type">const</span> string &amp;s)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Array-Parameters"><a href="#Array-Parameters" class="headerlink" title="Array Parameters"></a>Array Parameters</h3><p>虽然可以使用数组作为形参，但当数组作为形参的时候，是无法进行有效的值拷贝的。因为数组无法进行拷贝初始化，且当调用数组时，调用的实际上是指向数组第一个元素的指针。</p>
<p>以下三个函数定义，实际上是完全等效的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span>[])</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span>[<span class="number">10</span>])</span></span>;</span><br></pre></td></tr></table></figure>
<p>即可以使用其中任意一个作为声明，再用另一个作来进行定义，而想声明其中两个则是不行的，因为会形成重复定义，后两个在编译的过程中会变换为第一种的写法。也因此，即使定义的是最后一种写法，看起来是要求一个大小为10的const int数组，但仍然可以传递普通的int指针进去，如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>, j[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">print</span>(&amp;i);</span><br><span class="line"><span class="built_in">print</span>(j);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span>[<span class="number">10</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为即使形参使用数组，也会在编译时转换为指针，所以函数是不知道传进来的数组大小的，因此需要额外的信息来指定数组大小，以下为三种普遍的方式：</p>
<h4 id="Using-a-Marker-to-Specify-the-Extent-of-an-Array"><a href="#Using-a-Marker-to-Specify-the-Extent-of-an-Array" class="headerlink" title="Using a Marker to Specify the Extent of an Array"></a>Using a Marker to Specify the Extent of an Array</h4><p>如之前所示，C风格的字符串实际上是const char[]，而C风格的字符串用来判断是否是数组结尾就是用一个空白的字符作为数组结束的标记位（Marker），如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">char</span> cp[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (*cp)</span><br><span class="line">            cout &lt;&lt; *cp++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">abcd</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>但是这种方法需要找到一个几乎不会作为正常数据的值，否则就会与正常数据产生干扰。</p>
<h4 id="Using-the-Standard-Liberary-Conventions"><a href="#Using-the-Standard-Liberary-Conventions" class="headerlink" title="Using the Standard Liberary Conventions"></a>Using the Standard Liberary Conventions</h4><p>第二种方法是通过标准库中的<code>begin</code>和<code>end</code>方法来传递数组的开始与结束指针，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> j[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">begin</span>(j), <span class="built_in">end</span>(j));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *beg, <span class="type">const</span> <span class="type">int</span> *end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (beg != end)</span><br><span class="line">        cout &lt;&lt; *beg++ &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="Explicitly-Passing-a-Size-Parameter"><a href="#Explicitly-Passing-a-Size-Parameter" class="headerlink" title="Explicitly Passing a Size Parameter"></a>Explicitly Passing a Size Parameter</h4><p>函数中使用一个形参来指定数组的大小，如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(j, <span class="built_in">end</span>(j) - <span class="built_in">begin</span>(j));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *beg, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i != size; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *beg++ &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="Array-Parameters-and-const"><a href="#Array-Parameters-and-const" class="headerlink" title="Array Parameters and const"></a>Array Parameters and const</h4><p>可以使用在形参使用数组的引用，这个方法可以限定传递的数组的大小，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> valList[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">print</span>(valList);</span><br><span class="line"><span class="comment">//print(j); // j is int array with size 2,so can&#x27;t pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> (&amp;arr)[<span class="number">5</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> val : arr)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意数组的大小也是数组类型的一部分，所以对数组进行引用限定了数组大小，例子中只有数组大小是5的数组可以传递。</p>
<h4 id="Passing-a-Multidimensional-Array"><a href="#Passing-a-Multidimensional-Array" class="headerlink" title="Passing a Multidimensional Array"></a>Passing a Multidimensional Array</h4><p>对于多维数组，可以通过使用一个数组的指针进行传递，如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> mat[<span class="number">3</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">5</span>, <span class="number">6</span>&#125;&#125;;</span><br><span class="line"><span class="built_in">print</span>(mat, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> (*matrix)[<span class="number">2</span>], <span class="type">int</span> rowSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != rowSize; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j != <span class="number">2</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; matrix[i][j] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>其中因为传入的是长度为2的数组的指针，所以在循环中，可以确认内部循环的最大值为2。<code>matrix[i]</code>实际上获取的是长度为2的数组，但是会自动转为int<em>，所以<code>matrix[i][i]</code>实际上对一个int</em>使用<code>[j]</code>。也可以通过解引用符进行访问，即写成<code>*((*(matrix + i)) + j)</code></p>
<p>需要注意的是，无法直接通过指针的指针，如<code>int**</code>来进行传递的。因为数组的大小是类型的一部分，在上例中，<code>mat</code>的会自动转换为<code>int*[2]</code>而不是<code>int*</code>。因此如果函数的形参为<code>int**</code>，将无法匹配。如果要使用指针的指针来传递，那么就必须用指针来表示多维数组，如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Initial array</span></span><br><span class="line"><span class="type">int</span> **matrix = <span class="keyword">new</span> <span class="type">int</span> *[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != <span class="number">3</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    matrix[i] = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">2</span>];</span><br><span class="line">    matrix[i][<span class="number">0</span>] = <span class="number">2</span> * i;</span><br><span class="line">    matrix[i][<span class="number">1</span>] = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(matrix, <span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">//release data</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != <span class="number">3</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] matrix[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] matrix;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> **matrix, <span class="type">int</span> rowSize, <span class="type">int</span> columnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != rowSize; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j != columnSize; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; matrix[i][j] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="main-Handling-Command-Line-Options"><a href="#main-Handling-Command-Line-Options" class="headerlink" title="main: Handling Command-Line Options"></a>main: Handling Command-Line Options</h3><p>c++的main函数入口，可以是无参的，也可以是以下的格式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>第一个int参数表示传入的参数数量，第二个是C风格的字符串的类型表示传入的参数。通常最少有一个参数，该参数是运行的exe文件的路径，如定义main函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;argc count is &quot;</span> &lt;&lt; argc &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != argc; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;arg is &quot;</span> &lt;&lt; argv[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当直接启动编译完的exe文件，<code>./a.exe</code>，输出结果为</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">argc count is 1</span><br><span class="line">arg is D:\Study-Notes\C++Primer\Chapter6_Functions\a.exe</span><br></pre></td></tr></table></figure>
<p>当启动exe并传入参数时，<code>./a.exe 1 2 3</code>，输出结果为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">argc count is 4</span><br><span class="line">arg is D:\Study-Notes\C++Primer\Chapter6_Functions\a.exe</span><br><span class="line">arg is 1</span><br><span class="line">arg is 2</span><br><span class="line">arg is 3</span><br></pre></td></tr></table></figure>
<h3 id="Functions-with-Varying-Parameters"><a href="#Functions-with-Varying-Parameters" class="headerlink" title="Functions with Varying Parameters"></a>Functions with Varying Parameters</h3><p>有的时候并不了解一个函数究竟需要多少个形参，如一个函数需要来处理错误信息，但错误信息的数量是不固定的。</p>
<p>为了处理这样的情况，在C++11的特性中，有两个方法，第一种是通过<code>initializer_list</code>，第二种是通过<code>variadic</code>模板。第二种方法将在16.4中进行说明。</p>
<p>C++还有一种名为<code>elipsis</code>的参数类型，可以实现传递不同数量的实参，但是该方法应该仅在与C接口进行通信时使用。</p>
<h4 id="initializer-list-Parameters"><a href="#initializer-list-Parameters" class="headerlink" title="initializer_list Parameters"></a>initializer_list Parameters</h4><p>initializer_list是一种表示数组的标准库中的类型，支持的操作如下表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>代码</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>initializer_list<T> lst;</td>
<td>默认初始化</td>
</tr>
<tr>
<td>initializer_list<T> lst{a,b,c}</td>
<td>参数初始化，元素是初始值的拷贝，且list中的元素都是const的</td>
</tr>
<tr>
<td>lst2(lst)</td>
<td>initializer_list的拷贝或赋值</td>
</tr>
<tr>
<td>lst2 = lst</td>
<td>同上</td>
</tr>
<tr>
<td>lst.size()</td>
<td>返回initializer_list中的元素数量</td>
</tr>
<tr>
<td>lst.begin()</td>
<td>返回第一个元素的指针</td>
</tr>
<tr>
<td>lst.end()</td>
<td>返回最后一个元素后面的指针</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>initializer_list的拷贝操作实际上并没有拷贝，而是共享被拷贝对象的元素</li>
</ul>
<p>如同vector，initializer_list也是模板类，需要指定元素的类型。</p>
<p>如表格中所述，initializer_list中的元素都是const的，无法进行修改。</p>
<p>当调用initializer_list作为参数的函数时，如果想传递一系列的值来直接初始化initializer_list，则这些值必须放在大括号内。</p>
<p>使用例子如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestVaryingParameters</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">error_msg</span>(&#123;<span class="string">&quot;functionX&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_msg</span><span class="params">(initializer_list&lt;string&gt; il)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> beg = il.<span class="built_in">begin</span>(); beg != il.<span class="built_in">end</span>(); ++beg)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *beg &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">functionX abc def </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="Ellipsis-Parameters"><a href="#Ellipsis-Parameters" class="headerlink" title="Ellipsis Parameters"></a>Ellipsis Parameters</h4><p>Elipsis是C++用来访问C中的库的，书中也未进行详细说明。但日后使用到时再进行查询。</p>
<h2 id="Return-Types-and-the-return-Statement"><a href="#Return-Types-and-the-return-Statement" class="headerlink" title="Return Types and the return Statement"></a>Return Types and the return Statement</h2><h3 id="Functions-with-No-Return-Value"><a href="#Functions-with-No-Return-Value" class="headerlink" title="Functions with No Return Value"></a>Functions with No Return Value</h3><p>在无返回值的函数中，编译器会在函数尾部隐式的加入一个return语句。</p>
<h4 id="Functions-That-Return-a-value"><a href="#Functions-That-Return-a-value" class="headerlink" title="Functions That Return a value"></a>Functions That Return a value</h4><p>如果函数的返回值不为空，则必须写明有return语句返回该类型的值，或者是返回一个可以隐式转换为该类型的值。</p>
<p>如果函数中有判断语句，且在某些case下没有返回值，那么编译器有可能可以检测出该错误，也有可能检测不出来，当检测不出来时，函数的结果是未定义的。</p>
<h4 id="How-Values-Are-returned"><a href="#How-Values-Are-returned" class="headerlink" title="How Values Are returned"></a>How Values Are returned</h4><p>函数中返回的值，会用来初始化一个临时的变量，该临时的变量会作为函数的返回结果。如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">ReturnThePluralVersionOfWord</span><span class="params">(<span class="type">size_t</span> ctr, <span class="type">const</span> string &amp;word, <span class="type">const</span> string &amp;ending)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (ctr &lt;= <span class="number">1</span>) ? word : word + ending;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当ctr &lt;= 1时，返回的是word的拷贝，当ctr &gt; 1时，返回的是一个未命名的临时string，其中的值为word + ending。</p>
<h4 id="Nerver-Return-a-Reference-or-Pointer-to-a-Local-Object"><a href="#Nerver-Return-a-Reference-or-Pointer-to-a-Local-Object" class="headerlink" title="Nerver Return a Reference or Pointer to a Local Object"></a>Nerver Return a Reference or Pointer to a Local Object</h4><p>如果要避免函数返回参数的时的拷贝，可以将返回类型设置为引用。但要注意千万不要返回本地局部变量的引用或指针。如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> string &amp;<span class="title">manip</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string ret;</span><br><span class="line">    <span class="keyword">if</span> (!ret.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span> ret; <span class="comment">//error,return reference of local variable</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;empty&quot;</span>;<span class="comment">//error, return reference of a temporary string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在例子中，如果返回的是ret，那么返回的是一个局部变量的引用，当退出函数时，该变量会被释放，于是引用的就是一个空参数。如果返回的是”empty”，实际上返回的是值为empty的临时变量的引用。</p>
<p>这两种返回方式的结果都是未定义的。</p>
<h4 id="Reference-Returns-Are-Lvalues"><a href="#Reference-Returns-Are-Lvalues" class="headerlink" title="Reference Returns Are Lvalues"></a>Reference Returns Are Lvalues</h4><p>如果一个函数返回的是类型，那么该函数返回的是右参数。如果一个函数返回的是类型的引用，那么该函数返回的是左参数。因此可以将返回结果为引用的函数放在等式的左边，如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> &amp;<span class="title">Get_Val</span><span class="params">(string &amp;str, string::size_type ix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str[ix];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;abc&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">Get_Val</span>(s,<span class="number">0</span>) = <span class="string">&#x27;A&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h4 id="List-Initializing-the-Return-Value"><a href="#List-Initializing-the-Return-Value" class="headerlink" title="List Initializing the Return Value"></a>List Initializing the Return Value</h4><p>在C++11特性下，函数可以通过大括号括其一系列返回的函数，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">process</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;Bb&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该例子中，会返回一个临时的vector<string>变量，变量中有三个元素，由返回值来充填。</p>
<h4 id="Return-from-main"><a href="#Return-from-main" class="headerlink" title="Return from main"></a>Return from main</h4><p>main函数虽然指定了返回类型为int，但却可以不写返回语句，这是因为当没有返回语句时，编译器会补上return 0。</p>
<p>main函数返回0表示执行成功，返回其他数值通常表示执行不成功，具体的定义是系统相关的，要返回系统不相关的值，可以使用头文件<code>cstdlib</code>。如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(someFailure)</span><br><span class="line">        <span class="keyword">return</span> EXIST_FAILURE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> EXIST_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两者都是预处理器的变量，所以不需要定义作用域或using语句。</p>
<h4 id="Recursion"><a href="#Recursion" class="headerlink" title="Recursion"></a>Recursion</h4><p>在函数中可以再调用自己，这种称为递归。</p>
<p>main函数中不能再调用自己。</p>
<h3 id="Returning-a-Pointer-to-an-Array"><a href="#Returning-a-Pointer-to-an-Array" class="headerlink" title="Returning a Pointer to an Array"></a>Returning a Pointer to an Array</h3><p>同样因为数组无法被拷贝，一个函数无法返回数组类型，但是返回数组的指针。关于定义返回数组指针的函数，有以下几种方法</p>
<h4 id="Typedef-Using"><a href="#Typedef-Using" class="headerlink" title="Typedef / Using"></a>Typedef / Using</h4><h4 id="Functions-That-Return-Class-Types-and-the-Call-Operator"><a href="#Functions-That-Return-Class-Types-and-the-Call-Operator" class="headerlink" title="Functions That Return Class Types and the Call Operator"></a>Functions That Return Class Types and the Call Operator</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> arrt[<span class="number">10</span>];</span><br><span class="line"><span class="comment">// using arrt = int[10];// equally</span></span><br><span class="line"></span><br><span class="line"><span class="function">arrt *<span class="title">funcArray</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="Declaring-a-Function-That-Returns-a-Pointer-to-an-Array"><a href="#Declaring-a-Function-That-Returns-a-Pointer-to-an-Array" class="headerlink" title="Declaring a Function That Returns a Pointer to an Array"></a>Declaring a Function That Returns a Pointer to an Array</h4><p>像声明指向数组的变量那样直接定义，如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> (*<span class="built_in">funcArray</span>())[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<p>funcArray()表明形参为空，(*funcArray())表明返回的是一个指针类型。</p>
<h4 id="Using-a-Trailing-Return-Type"><a href="#Using-a-Trailing-Return-Type" class="headerlink" title="Using a Trailing Return Type"></a>Using a Trailing Return Type</h4><p>该方法是C++11的特性，Trailing Return可以针对任何的类型的函数，但针对返回值为数组的指针的函数时尤为有效。如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">funcArray</span><span class="params">()</span> -&gt; <span class="title">int</span> <span class="params">(*)</span>[]</span>;</span><br></pre></td></tr></table></figure>
<p>该方法下，用auto替代原先定义返回类型的地方。</p>
<h4 id="Using-decltype"><a href="#Using-decltype" class="headerlink" title="Using decltype"></a>Using decltype</h4><p>因为对数组使用decltype，返回的是数组类型，而不是指针类型，如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> odd[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> even[] = &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>&#125;;</span><br><span class="line"><span class="keyword">decltype</span>(odd) *<span class="built_in">funcArray</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;odd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Overloaded-Functions"><a href="#Overloaded-Functions" class="headerlink" title="Overloaded Functions"></a>Overloaded Functions</h2><p>main函数无法被重载</p>
<h4 id="Defining-Overloaded-Functions"><a href="#Defining-Overloaded-Functions" class="headerlink" title="Defining Overloaded Functions"></a>Defining Overloaded Functions</h4><p>重载函数必须在形参的类型或者形参的数量上有区分。无法仅仅通过函数的返回类型来进行重载。</p>
<h4 id="Overloading-and-const-Parameters"><a href="#Overloading-and-const-Parameters" class="headerlink" title="Overloading and const Parameters"></a>Overloading and const Parameters</h4><p>无法仅通过形参的top-level的const属性进行函数重载，如下两个函数虽然不同，但却会造成重复定义。因为当调用函数时，top-level的const属性会被无视，因此对于调用者而说，两个函数是没有区别的，它们实际差异是体现在函数body中对形参的处理。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone)</span></span>;</span><br><span class="line">Record lookup[(<span class="type">const</span> Phone);</span><br></pre></td></tr></table></figure>
<p>但如果const的区别是low-level的，那么是可以进行重载的，如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Record <span class="title">loopup</span><span class="params">(Account&amp;)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">loopup</span><span class="params">(<span class="type">const</span> Account&amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>对于调用者而言，上面的两个函数是不同的。如果使用的实参是const的，那么将无法直接调用第一个函数。当使用的形参是非const的，那么会优先调用第一个函数，关于重载函数的调用选择规则会在之后的小节中进行说明。</p>
<h4 id="const-cast-and-Overloading"><a href="#const-cast-and-Overloading" class="headerlink" title="const_cast and Overloading"></a>const_cast and Overloading</h4><p>如有以下函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> string &amp;<span class="title">shorterString</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt; s2.<span class="built_in">size</span>() ? s1 : s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数的形参是low level的const引用，返回的类型也为low level的const引用。如果调用的实参为非const的引用，会进行隐式的类型转换，此时返回结果将仍然是const的引用。</p>
<p>而如果想要实现，传入的实参是const的，返回为const类型；传入的实参是non-const类型，返回也会non-const类型，就需要进行函数重载。如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string &amp;<span class="title">shorterString</span><span class="params">(string &amp;s1, string &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> string &amp;r = <span class="built_in">shorterString</span>(<span class="built_in">const_cast</span>&lt;<span class="type">const</span> string &amp;&gt;(s1), <span class="built_in">const_cast</span>&lt;<span class="type">const</span> string &amp;&gt;(s2));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">const_cast</span>&lt;string &amp;&gt;(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里通过调用形参为const引用的版本来获取结果，注意在调用函数时，需要将形参转换为const类型，否则调用的将还是这个函数本身，即形成了无止境的递归。在返回结果时将const引用的版本返回的const string&amp;转换为string&amp;。</p>
<h4 id="Calling-an-Overloaded-Function"><a href="#Calling-an-Overloaded-Function" class="headerlink" title="Calling an Overloaded Function"></a>Calling an Overloaded Function</h4><p>从一系列重载函数中找到正确的函数，这个过程叫做函数匹配（Function matching）。</p>
<p>对于调用重载函数，一共有三种可能的结果：</p>
<ol>
<li>编译器找到了最佳的匹配函数（Best match），最终将调用该函数。</li>
<li>编译器没有找到任何可以匹配的函数（No match），最终编译器将报错。</li>
<li>编译器找到了多个匹配的函数，且无法从中判断出谁匹配度更高，为歧义调用（Ambiguous call），最终编译器将报错。</li>
</ol>
<h3 id="Overloading-and-Scope"><a href="#Overloading-and-Scope" class="headerlink" title="Overloading and Scope"></a>Overloading and Scope</h3><p>如果在内层的代码范围内声明或者定义一个名字，则在外层代码块范围中同样名字的对象将被隐藏。这个规则同时适用于变量和函数。</p>
<p>如下代码，在内层作用域中定义的变量和函数将隐藏外层作用域中的同名变量与函数，如果要调用外层作用域的话需要<code>::</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">read</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;readed&quot;</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> string &amp;s)</span> </span>&#123; cout &lt;&lt; s &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">double</span> d)</span> </span>&#123; cout &lt;&lt; d &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fooBar</span><span class="params">(<span class="type">int</span> ival)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> read = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// string s = read();//error, read() is hidden, in this scope read is a bool variable</span></span><br><span class="line">    string s = ::<span class="built_in">read</span>(); <span class="comment">//ok,use :: to indicate search name is global scope</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decalare a function in the inner scope.This action is rare in practice.</span></span><br><span class="line">    <span class="comment">//Here we only use this to illustrate scope hidding</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="comment">// print(&quot;value :&quot;);//error, print(const string &amp;s) is hidden.</span></span><br><span class="line">    <span class="built_in">print</span>(ival);</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">3.14</span>);<span class="comment">//ok, but it will call print(int)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在C++中，如果调用了一个名字的对象，编译器会在当前作用域首先找该名字的对象（可能不存在，可能一个，可能多个）。如果对象不存在的话，才会去外部作用域查找。</p>
<p>因此在上述代码中，调用<code>print</code>函数，编译器在当前的作用域找到了<code>print(int)</code>，就不会在外层的作用域查找了，于是<code>print(double)</code>与<code>print(const string&amp;)</code>都不会被作为重载的候选人，更不会进行函数匹配。</p>
<h2 id="Features-for-Specialized-Uses"><a href="#Features-for-Specialized-Uses" class="headerlink" title="Features for Specialized Uses"></a>Features for Specialized Uses</h2><h3 id="Default-Arguments"><a href="#Default-Arguments" class="headerlink" title="Default Arguments"></a>Default Arguments</h3><p>可以为形参设定默认参数。但如果为一个形参设定了默认参数，该形参后面的所有形参都必须指明默认参数。</p>
<p>如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(<span class="type">int</span> ht = <span class="number">24</span>, <span class="type">int</span> wid = <span class="number">80</span>,<span class="type">char</span> background = <span class="string">&#x27; &#x27;</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>如果仅想要修改最后一个变量，其他的变量仍然按默认参数，也仍然必须写明前面的参数。</p>
<p>如调用<code>screen(&#39;?&#39;)</code>，看起来实参类型为<code>char</code>，与最后一个参数相匹配，但在调用过程中，形参与实参是一一对应的，该表达式等同于<code>screen(&#39;?&#39;, 80, &#39; &#39;</code>，即<code>&#39;?&#39;</code>会被转换为int作为第一个参数。</p>
<h4 id="Default-Argument-Declarations"><a href="#Default-Argument-Declarations" class="headerlink" title="Default Argument Declarations"></a>Default Argument Declarations</h4><p>C++中，只可以定义一个变量，但可以多次声明变量。但是对于默认参数而言，每个形参的默认参数都最多被声明一次，如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>,<span class="type">char</span> = <span class="string">&#x27; &#x27;</span>)</span></span>;</span><br><span class="line"><span class="comment">// string screen(int,int,char = &#x27;*&#x27;);</span></span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(<span class="type">int</span>=<span class="number">24</span>,<span class="type">int</span>=<span class="number">80</span>,<span class="type">char</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在第一条语句执行后，第二条语句无法通过编译，因为它重新声明了char类型的形参的默认值，造成了重复定义。而第三条语句仍然可以执行，且第三条语句执行后，函数<code>screen</code>的三个形参都有了默认值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>, <span class="type">char</span> = <span class="string">&#x27;*&#x27;</span>)</span></span>;</span><br><span class="line"><span class="comment">// string screen(int, int, char = &#x27; &#x27;);</span></span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(<span class="type">int</span> = <span class="number">24</span>, <span class="type">int</span> = <span class="number">80</span>, <span class="type">char</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height, <span class="type">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;width is &quot;</span> &lt;&lt; width &lt;&lt; <span class="string">&quot;, height is &quot;</span> &lt;&lt; height &lt;&lt; <span class="string">&quot;, c is &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">screen</span>();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">width is 24, height is 80, c is *</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="Default-Argument-Initializers"><a href="#Default-Argument-Initializers" class="headerlink" title="Default Argument Initializers"></a>Default Argument Initializers</h4><p>函数的默认参数可以是任何可以转换为形参类型的表达式，如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> vall = <span class="number">20</span>;</span><br><span class="line"><span class="type">char</span> cc = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printDefaultArgument</span><span class="params">(<span class="type">int</span> ran = rand(), <span class="type">int</span> w = vall, <span class="type">char</span> c = cc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;random is &quot;</span> &lt;&lt; ran &lt;&lt; <span class="string">&quot;, w is &quot;</span> &lt;&lt; w &lt;&lt; <span class="string">&quot;, c is &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestDefaultArgument</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printDefaultArgument</span>();</span><br><span class="line">    vall = <span class="number">30</span>;</span><br><span class="line">    <span class="type">char</span> cc = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    <span class="built_in">printDefaultArgument</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">random is 41, w is 20, c is a</span></span><br><span class="line"><span class="comment">random is 18467, w is 30, c is a</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>上述代码中，<code>printDefaultArgument</code>函数第一个形参<code>ran</code>的默认值是一个函数，函数会随机取一个int值，第二个和第三个形参都是全局变量。</p>
<p>在函数<code>TestDefaultArgument</code>中调用<code>printDefaultArgument</code>函数，第二次调用前先改变了全局变量<code>vall</code>的值，然后定义了一个同名新局部变量<code>cc</code>。但是因为<code>printDefaultArgument</code>函数的第三个形参实际上是全局变量中的<code>cc</code>，所以在第二次调用<code>printDefaultArgument</code>时，第三个形参的数值并没有发生改变。</p>
<h3 id="Inline-and-constexpr-Functions"><a href="#Inline-and-constexpr-Functions" class="headerlink" title="Inline and constexpr Functions"></a>Inline and constexpr Functions</h3><p>在大多数的设备下，函数调用是一个花费较大的操作，需要拷贝实参，记录和回复调用时的状态等。<code>inline</code>关键字可以减少函数的调用。</p>
<h4 id="inline-Functions-Avoid-Function-Call-Overhead"><a href="#inline-Functions-Avoid-Function-Call-Overhead" class="headerlink" title="inline Functions Avoid Function Call Overhead"></a>inline Functions Avoid Function Call Overhead</h4><p>如果定义一个函数为<code>inline</code>的，那么编译器会在编译阶段，将函数调用的地方换成函数主体，这样就避免了函数的调用。这样的函数称为内联函数（inline Function）。</p>
<p>如<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">const</span> string &amp;<span class="title">shorterString</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt; s2.<span class="built_in">size</span>() ? s1 : s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意并不是函数加上了<code>inline</code>关键字就一定会变成内联函数，<code>inline</code>关键字如同一个申请，至于函数最终是否会变成内联由编译器决定。通常而言，递归函数和行数大于75行的函数是不会变成内联函数的。</p>
<h4 id="constexpr-Functions"><a href="#constexpr-Functions" class="headerlink" title="constexpr Functions"></a>constexpr Functions</h4><p>//TODO</p>
<h4 id="Put-inline-and-constexpr-Functions-in-Header-Files"><a href="#Put-inline-and-constexpr-Functions-in-Header-Files" class="headerlink" title="Put inline and constexpr Functions in Header Files"></a>Put inline and constexpr Functions in Header Files</h4><p>和其他的函数不同，内联函数在一个程序中是可以被多次定义的，如:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GetNum.h</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetNum</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">GetDoubleNum</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetNum.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetNum</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">GetDoubleNum</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3.14</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Chapter6_Functions.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// int GetNum()</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     return 10;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">GetDoubleNum</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4.15</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">GetDoubleNum</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4.15</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>可以看到在<code>Chapter6_Functions.cpp</code>和<code>GetNum.cpp</code>两个源文件中都对<code>GetDoubleNum</code>函数进行了定义，且仍然可以正常运行。而如果尝试在<code>Chapter6_Functions.cpp</code>中再次定义<code>GetNum</code>函数，则会发生编译错误。</p>
<p>这是因为对于内联函数而言，是在本源文件中搜索内联函数的定义然后进行替代。</p>
<p>最合理的方式是将内联函数的定义放在头文件中，这样在使用include时，实际上就将内联函数的定义拷贝到了源文件中。</p>
<h3 id="Aids-for-Debugging"><a href="#Aids-for-Debugging" class="headerlink" title="Aids for Debugging"></a>Aids for Debugging</h3><p>可以使用预处理器来帮助C++进行调试工作，即实现在开发过程中，可以打出调试log，而在实际程序中log则不予显示的方法。</p>
<h4 id="The-assert-Preprocessor-Macro"><a href="#The-assert-Preprocessor-Macro" class="headerlink" title="The assert Preprocessor Macro"></a>The assert Preprocessor Macro</h4><p>预处理宏（Preprocessor Macro）是一种预处理器变量，运行起来有点像内联函数。</p>
<p><code>assert</code>预处理器宏可以接纳一个表示condition的表达式，定义在头文件<code>cassert</code>中，且因为是预处理器变量，因此不需要设定命名空间。当表达式的结果为false时，将打出信息并且终止程序的运行。如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">3</span>, b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">assert</span>(a &lt; b);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Assertion failed!</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Program: D:\Study-Notes\C++Primer\Chapter6_Functions\a.exe</span></span><br><span class="line"><span class="comment">File: Chapter6_Functions.cpp, Line 50</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Expression: a &lt; b</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><code>assert</code>通常是用来判断那些不可能发生的情况，如当某个数值超过了阈值等。</p>
<h4 id="The-NDEBUG-Preprocessor-Variable"><a href="#The-NDEBUG-Preprocessor-Variable" class="headerlink" title="The NDEBUG Preprocessor Variable"></a>The NDEBUG Preprocessor Variable</h4><p><code>assert</code>的运行状态预处理变量<code>NDEBUG</code>决定，如果该变量被定义了，则<code>assert</code>不会被执行。</p>
<p>因此可以通过在代码中加入<code>#define NDEBUG</code>来关闭<code>assert</code>的调试。也可以直接在编译时通过flag -D来加入这句话，如</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">g++ Chapter6_Functions.cpp </span><br><span class="line"></span><br><span class="line">$ ./a.exe </span><br><span class="line"></span><br><span class="line">Assertion failed!</span><br><span class="line"></span><br><span class="line">Program: D:\Study-Notes\C++Primer\Chapter6_Functions\a.exe</span><br><span class="line">File: Chapter6_Functions.cpp, Line 50</span><br><span class="line"></span><br><span class="line">Expression: a &lt; b</span><br><span class="line"></span><br><span class="line">g++ Chapter6_Functions.cpp -D NDEBUG</span><br><span class="line"></span><br><span class="line">$ ./a.exe </span><br><span class="line">4.15</span><br></pre></td></tr></table></figure>
<p>也可以进一步利用NDEBUG来定义自己的调试函数，如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Debug</span><span class="params">(<span class="type">const</span> string &amp;msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NDEBUG</span></span><br><span class="line">    cout &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C++还提供了一些帮助调试的预处理器变量：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>变量</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>func</strong></td>
<td>当前的函数名</td>
</tr>
<tr>
<td><strong>FILE</strong></td>
<td>当前文件名</td>
</tr>
<tr>
<td><strong>LINE</strong></td>
<td>当前行号</td>
</tr>
<tr>
<td><strong>TIME</strong></td>
<td>该文件被编译的时间</td>
</tr>
<tr>
<td><strong>DATE</strong></td>
<td>该文件被编译的日期</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestPreprocessorVariable</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Function is &quot;</span> &lt;&lt; __func__ &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;File is &quot;</span> &lt;&lt; __FILE__ &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Line is &quot;</span> &lt;&lt; __LINE__ &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Time is &quot;</span> &lt;&lt; __TIME__ &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Dateis &quot;</span> &lt;&lt; __DATE__ &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Function is TestPreprocessorVariable</span></span><br><span class="line"><span class="comment">File is Chapter6_Functions.cpp</span></span><br><span class="line"><span class="comment">Line is 78</span></span><br><span class="line"><span class="comment">Time is 16:49:12</span></span><br><span class="line"><span class="comment">Dateis Feb 22 2020</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Function-Matching"><a href="#Function-Matching" class="headerlink" title="Function Matching"></a>Function Matching</h2><p>函数匹配过程可以分为三步：</p>
<ol>
<li>找出候选函数（candidate functions），通过函数的名字，找到所有可能的重载函数（注意作用域隐藏）。</li>
<li>找出可选函数（viable functions），在候选函数中通过形参数量和类型找出可以被调用的函数</li>
<li>找出最佳匹配，在所有的可选函数中根据规则找出最佳匹配函数。</li>
</ol>
<p>以下是找最佳匹配函数的规则，排名越靠前的函数，会越优先被选取</p>
<ol>
<li><p>实参类型与形参类型完全匹配，包括<br>a. 实参类型与形参类型相同，不需要任何转换<br>b. 实参是数组或函数，形参是对应的指针类型<br>c. 实参和形参的差距是可以无视的top-level const</p>
</li>
<li><p>需要进行const转换<br>low level的const转换，如实参是nonconst的引用，形参是const的引用。</p>
</li>
<li><p>需要进行数值提升（promotion）<br>较小的整数类型会自动转换成int或更高类型的整数类型。如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ff</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ff</span><span class="params">(<span class="type">short</span>)</span></span>;</span><br><span class="line"><span class="built_in">ff</span>(<span class="string">&#x27;a&#x27;</span>);<span class="comment">//Call ff(int)</span></span><br></pre></td></tr></table></figure>
<p>因为十进制的字面值会自动转换为最小为<code>int</code>的变量，所以<code>a</code>的最终类型为int。所以可以与<code>ff(int)</code>完全匹配，但是与<code>ff(short)</code>需要进行一次转换。</p>
</li>
<li><p>需要进行算数转换或者指针转换<br>算数类型的转换，如int转float,int转double。注意只要都是算数转换，则它们的排名就是一样的，无论正在进行的类型转换是什么。</p>
<p>指针转换指的是，0转换为空指针，non const的指针可以转换为void<em>，任何指针都可以转换为`const void</em>`。</p>
</li>
<li><p>需要进行类转换（14.9节中进行说明）</p>
</li>
</ol>
<p>如果出现了多个可选函数由相同的排名，则会出现歧义调用（Ambiguous call）。如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">f</span>(<span class="type">int</span>,<span class="type">int</span>);</span><br><span class="line"><span class="built_in">f</span>(<span class="type">double</span>,<span class="type">double</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// f(42,2.56); // ambiguous call</span></span><br></pre></td></tr></table></figure>
<p>对于调用<code>f(42,2.56)</code>无论是访问<code>f(int,int)</code>和<code>f(double,double)</code>都是进行了一次算数转换，所以这两个函数的优先级一样的，为歧义调用。</p>
<p>还有类似于</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">manip</span><span class="params">(<span class="type">long</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">manip</span><span class="params">(<span class="type">float</span>)</span></span>;</span><br><span class="line"><span class="comment">// manip(3.14); // ambiguous call</span></span><br></pre></td></tr></table></figure>
<p>无论调用哪个函数都会进行算数转换，即使转换的目标类型不同，但是函数的优先级仍然是一样的，所以为歧义调用。</p>
<h2 id="Pointers-to-Functions"><a href="#Pointers-to-Functions" class="headerlink" title="Pointers to Functions"></a>Pointers to Functions</h2><p>函数指针就是指向函数的指针，指针的类型需要匹配要指向的函数的形参数量，形参类型和返回值类型。如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span> (*pf)(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;); <span class="comment">// uninitialized</span></span><br></pre></td></tr></table></figure>
<p>pf为指向两个形参都是<code>const string&amp;</code>，返回值为bool的函数的指针。如可以指向</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">lengthCompare</span><span class="params">(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>但是并不能指向类内成员函数，即使形参和返回值类型一样，因为类内函数实际上有一个this指针的传递</p>
<p>注意，定义pf时，外面的括号不能缺少，不然变成</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> *<span class="title">pf</span><span class="params">(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>上述代码意思为一个名为pf的返回值为bool*的函数的声明。</p>
<h4 id="Using-Function-Pointers"><a href="#Using-Function-Pointers" class="headerlink" title="Using Function Pointers"></a>Using Function Pointers</h4><p>在赋值和使用函数指针的时候，取地址符(&amp;)以及解引用符(*)都可以被省略。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span> (*fp)(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;) = lengthCompare;</span><br><span class="line"><span class="comment">// bool (*fp)(const string &amp;, const string &amp;) = &amp;lengthCompare;//equal to above</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> b1 = <span class="built_in">fp</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;goodbyte&quot;</span>);</span><br><span class="line"><span class="type">bool</span> b2 = (*fp)(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;goodbyte&quot;</span>);<span class="comment">// equal to above</span></span><br><span class="line"><span class="type">bool</span> b3 = <span class="built_in">lengthCompare</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;goodby&quot;</span>);<span class="comment">//equal ro above</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b1: &quot;</span> &lt;&lt; b1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b2: &quot;</span> &lt;&lt; b2 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b3: &quot;</span> &lt;&lt; b3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">b1: 0</span></span><br><span class="line"><span class="comment">b2: 0</span></span><br><span class="line"><span class="comment">b3: 0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">当使用函数指针时，赋值给函数指针的函数的类型必须与函数指针的类型完全一致。</span><br><span class="line"></span><br><span class="line">```<span class="function">cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ff</span><span class="params">(<span class="type">int</span> val)</span></span>;</span><br><span class="line"><span class="built_in">void</span> (*p1)(<span class="type">unsigned</span> <span class="type">int</span>) = ff;</span><br><span class="line"><span class="comment">// void (*p2)(int) = ff; //error, can&#x27;t convert unsigned int to int</span></span><br></pre></td></tr></table></figure>
<h4 id="Function-Pointer-Parameters"><a href="#Function-Pointer-Parameters" class="headerlink" title="Function Pointer Parameters"></a>Function Pointer Parameters</h4><p>无法将函数类型作为函数的形参类型，但是可以将函数指针作为形参的函数类型。如同数组一样，如果将函数的形参类型设置为某个函数类型，那么会形参类型会自动转换为该函数类型的指针，如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span>[])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">(<span class="type">const</span> string &amp;s1,<span class="type">const</span> string &amp;s2,<span class="type">bool</span> pf(<span class="type">const</span> string&amp;,<span class="type">const</span> string&amp;))</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">(<span class="type">const</span> string &amp;s1,<span class="type">const</span> string &amp;s2,<span class="type">bool</span> (*pf)(<span class="type">const</span> string&amp;,<span class="type">const</span> string&amp;))</span></span>;</span><br></pre></td></tr></table></figure>
<p>上述代码，每一组是完全相同的。</p>
<p>调用形参为函数指针的函数时，也可以省略取地址符，如以下两个语句是完全相同的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">useBigger</span>(s1, s2, lengthCompare);</span><br><span class="line"><span class="built_in">useBigger</span>(s1, s2, &amp;lengthCompare);</span><br></pre></td></tr></table></figure>
<p>但当使用<code>decltype</code>时，使用函数类型以及函数类型的指针返回的结果是不同的，如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Func and Func2 are function type</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="type">bool</span> <span class="title">Func</span> <span class="params">(<span class="type">const</span> string &amp;,<span class="type">const</span> string &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(lengthCompare)</span> Func2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//FuncP and FuncP2 are pointer to function type</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(*FuncP)</span> <span class="params">(<span class="type">const</span> string &amp;,<span class="type">const</span> string &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(lengthCompare)</span> *FuncP2</span>;</span><br></pre></td></tr></table></figure>
<p>上述代码，每组等效，但是第一组定义的是函数类型的别名，第二组定义的是函数指针的别名。</p>
<p>但使用函数类型和函数指针的别名来定义函数时，又可以直接进行转换，如下两句，完全等效</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">(s1, s2, Func)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">(s1, s2, FuncP)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="Returning-a-Pointer-to-Function"><a href="#Returning-a-Pointer-to-Function" class="headerlink" title="Returning a Pointer to Function"></a>Returning a Pointer to Function</h4><p>如同数组一样，无法将函数类型作为函数的返回值，但可以返回函数类型的指针。如需要定义函数<code>f1</code>，形参为int，返回值类型为指向形参为(int*,int)，返回值为int的函数的指针。</p>
<p>以下是四种定义返回类型为函数指针的函数的方法，分别是使用别名，直接定义，使用trailing方法，使用decltype</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Method1: use alias</span></span><br><span class="line"><span class="keyword">using</span> F = <span class="built_in">int</span>(<span class="type">int</span> *, <span class="type">int</span>);      <span class="comment">//F is Function type,retun type is int</span></span><br><span class="line"><span class="keyword">using</span> FF = <span class="type">int</span> *(<span class="type">int</span> *, <span class="type">int</span>);   <span class="comment">//F is Function type,retun type is pointe to int</span></span><br><span class="line"><span class="keyword">using</span> PF = <span class="built_in">int</span> (*)(<span class="type">int</span> *, <span class="type">int</span>); <span class="comment">//FP is pointer to Function type</span></span><br><span class="line"><span class="function">PF <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="comment">// F f1(int); //error, function type can not be return type</span></span><br><span class="line"><span class="function">F *<span class="title">f1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Method 2: directly</span></span><br><span class="line"><span class="comment">//like directly define return is pointer to array, which looks like</span></span><br><span class="line"><span class="comment">//int (*f1(int)) [10];</span></span><br><span class="line"><span class="built_in">int</span> (*<span class="built_in">f1</span>(<span class="type">int</span>))(<span class="type">int</span>*,<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Method 3: use trailing return</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span> -&gt; <span class="title">int</span> <span class="params">(*)</span><span class="params">(<span class="type">int</span> *, <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Method4: use decltype</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func1</span><span class="params">(<span class="type">int</span>*,<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">decltype</span>(func1)* <span class="built_in">f1</span>(<span class="type">int</span>);</span><br></pre></td></tr></table></figure>
<div class="note info simple"><p>引用：</p>
<ol>
<li><em>Cpp Primer</em> 5th Aug.2012</li>
</ol>
</div>
<hr>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>计算机语言</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>《C++ Primer》 第八章笔记</title>
    <url>/CPPPrimer-Chapter8-Notes/</url>
    <content><![CDATA[<p>《C++ Primer》 第八章笔记。</p>
<p><img src="CPPPrimer-Chapter8-Notes/Ch_8.png" alt="第八章内容" style="zoom:50%;" /></p>
<span id="more"></span>
<h1 id="Chapter-8-The-IO-Library"><a href="#Chapter-8-The-IO-Library" class="headerlink" title="Chapter 8 The IO Library"></a>Chapter 8 The IO Library</h1><p>IO库定义了一系列读取和写入内建类型的操作。</p>
<h2 id="The-IO-Classes"><a href="#The-IO-Classes" class="headerlink" title="The IO Classes"></a>The IO Classes</h2><p>为了处理不同的IO操作，IO库定义了一系列的IO类型，他们集中在三个头文件中：<code>iostream</code>中定义列读取和写入流（Steam）的基本类型，<code>fstream</code>定义了读取和写入文件的类型，<code>sstream</code>定义列读取和写入字符串的类型。如下所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>头文件</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>iostream</td>
<td>istream,wistream 从流中读取</td>
</tr>
<tr>
<td></td>
<td>ostream,wostream 向流中写入</td>
</tr>
<tr>
<td></td>
<td>iostream,wiostream 对流读取和写入</td>
</tr>
<tr>
<td>fstream</td>
<td>ifstream,wifstream 从文件中读取</td>
</tr>
<tr>
<td></td>
<td>ofstream,wofstream 向文件中写入</td>
</tr>
<tr>
<td></td>
<td>fstream,wfstream 对文件读取和写入</td>
</tr>
<tr>
<td>sstream</td>
<td>istringstream,wistringstream 从string中读取</td>
</tr>
<tr>
<td></td>
<td>ostringstream,wostringstream 向string中写入</td>
</tr>
<tr>
<td></td>
<td>stringstream,wstringstream 对string读取和写入</td>
</tr>
</tbody>
</table>
</div>
<p>从表中可以看出，每个类型都有一个<code>w</code>版本，这个版本是针对宽字符处理的。如<code>cin,cout,cerr</code>都有对应的<code>wcin,wcout,wcerr</code>。</p>
<h4 id="Relationships-among-the-IO-Types"><a href="#Relationships-among-the-IO-Types" class="headerlink" title="Relationships among the IO Types"></a>Relationships among the IO Types</h4><p>IO库用继承来实现对于不同类型的操作，如<code>ifstream</code>和<code>istringstream</code>都是继承自<code>istream</code>，因此所有对于<code>istream</code>的操作都可以使用在<code>ifstream</code>和<code>istringstream</code>上。</p>
<h3 id="No-Copy-or-Assign-for-IO-Objects"><a href="#No-Copy-or-Assign-for-IO-Objects" class="headerlink" title="No Copy or Assign for IO Objects"></a>No Copy or Assign for IO Objects</h3><p>IO类型不支持赋值和拷贝操作，如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ofstream out1, out2;</span><br><span class="line"><span class="comment">// out1 = out2; //error, cannot assign stream objects</span></span><br></pre></td></tr></table></figure>
<p>因此无法将IO类型作为函数的形参和返回值，通常是使用IO类型的引用来表示。读写IO类型都会改变其状态，所以通常也不会将传递的IO类型变为const reference。</p>
<h3 id="Condition-States"><a href="#Condition-States" class="headerlink" title="Condition States"></a>Condition States</h3><p>一旦一个问题发生，之后对于IO类型的操作就会失败，只有当IO类型处于无错误状态下才能进行流的读取和写入。因此，通常在代码中需要首先判断IO类型的状态，最简单的方法就是直接将io作为判断条件，如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (cin &gt;&gt; word)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Interrogating-the-State-of-a-Stream"><a href="#Interrogating-the-State-of-a-Stream" class="headerlink" title="Interrogating the State of a Stream"></a>Interrogating the State of a Stream</h4><p>将IO作为判断条件，只能得到IO是否是正确的，但无法确定其究竟是因为什么原因导致失败。</p>
<p>IO类型定义了一系列机器相关的<code>iostate</code>类型来表示IO流的状态，每个IO类型都有自己的<code>iostate</code>类型，如<code>istream::iostate</code>，<code>fstream::iostate</code>。这个类型本质上是一系列的bits，所以可以通过位运算来进行操作。<code>iostate</code>类型和内置的函数操作如下所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型与函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>strm::iostate</td>
<td>stm表示IO类型，strm::iostate表示该类型对应的状态</td>
</tr>
<tr>
<td>strm::badbit</td>
<td>一个不可自动恢复的错误发生了，通常是系统层面的错误</td>
</tr>
<tr>
<td>strm::failbit</td>
<td>一个可自动恢复的错误发生了，如读取string，赋值给int</td>
</tr>
<tr>
<td>strm:: eofbit</td>
<td>遇到了文件结尾（end-of-file）</td>
</tr>
<tr>
<td>strm:: goodbit</td>
<td>表示流没有错误，该值保证为0</td>
</tr>
<tr>
<td>s.eof()</td>
<td>s是stm类型的实例，当eofbit位被置上时，该值为true</td>
</tr>
<tr>
<td>s.fail()</td>
<td>当failbit位或badbit位被置上时，该值为true</td>
</tr>
<tr>
<td>s.bad()</td>
<td>当badbit位被置上时，该值为true</td>
</tr>
<tr>
<td>s.good()</td>
<td>当badbit,failbit和eofbit都没有置上时，该值为true，</td>
</tr>
<tr>
<td>s.clear()</td>
<td>清空流的所有位，使其恢复正确状态，返回空</td>
</tr>
<tr>
<td>s.clear(flags)</td>
<td>清空flags位，flags为iostate类型，返回空</td>
</tr>
<tr>
<td>s.setstate(flags)</td>
<td>设置flags位，flags为iostate类型，返回空</td>
</tr>
<tr>
<td>s.sdstate</td>
<td>返回当前状态</td>
</tr>
</tbody>
</table>
</div>
<p>通常来说，使用<code>good()</code>和<code>fail()</code>两个函数来判断流的状态。当将流作为判断条件时，实际上等同于调用了<code>!fail()</code>。要注意调用<code>fail()</code>并没有检查<code>eofbit</code>位，所以直接将流作为判断条件时，读取到文件末尾并不会停止，还会继续读取一次。</p>
<p>如下使用<code>ifstream</code>测试所示，文件内已有内容为<code>123\n456</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">&quot;./Test.txt&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">while</span> (in.<span class="built_in">good</span>())</span><br><span class="line">&#123;</span><br><span class="line">    in &gt;&gt; content;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Read Content with good is &quot;</span> &lt;&lt; content &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">in.<span class="built_in">close</span>();</span><br><span class="line">in.<span class="built_in">open</span>(<span class="string">&quot;./Test.txt&quot;</span>);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (in)</span><br><span class="line">&#123;</span><br><span class="line">    in &gt;&gt; content;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Read Content with condition is &quot;</span> &lt;&lt; content &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Read Content with good is 123</span></span><br><span class="line"><span class="comment">Read Content with good is 456</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Read Content with condition is 123</span></span><br><span class="line"><span class="comment">Read Content with condition is 456</span></span><br><span class="line"><span class="comment">Read Content with condition is 456</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="Managing-the-Condition-State"><a href="#Managing-the-Condition-State" class="headerlink" title="Managing the Condition State"></a>Managing the Condition State</h4><p>如之前所述，可以对<code>iostate</code>类型进行位操作，如需要将<code>failbit</code>和<code>badbit</code>还原，但保留<code>eofbit</code>，可以使用以下语句：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cin.<span class="built_in">clear</span>(cin.<span class="built_in">rdstate</span>() &amp; ~cin.failbit &amp; ~cin.badbit);</span><br></pre></td></tr></table></figure>
<h3 id="Managing-the-Output-Buffer"><a href="#Managing-the-Output-Buffer" class="headerlink" title="Managing the Output Buffer"></a>Managing the Output Buffer</h3><p>对于操作系统而言，将数据写入设备，可能是一个耗时的操作，所以通常操作系统会将数据先缓存起来，之后将多个数据合并再一起写入设备。</p>
<p>但这种缓存机制可能会导致Debug时的困扰，如程序意外终止时，缓存的数据并没有被输出，于是明明某个Debug语句已经运行，但因为数据没有刷新，导致被误以为并没有运行。</p>
<p>以下几种情况会让存储的数据被刷新，输出给设备：</p>
<ol>
<li>当整个程序正常结束时。在main return的过程中，所有的输出缓存被刷新。</li>
<li>当缓存满时，会进行刷新。</li>
<li>当使用刷新操作符时，如<code>endl</code>，<code>flush</code>,<code>ends</code>。</li>
<li>可以使用操作符<code>unitbuf</code>设置IO对象，让输出IO对象的每一次操作都刷新缓存。默认情况下，<code>cerr</code>是已经被设置了<code>unitbuf</code>的。</li>
<li>如果输出IO对象被绑定至另一个IO对象，那么另一个IO对象无论进行了读还是写操作，都会刷新输出IO对象。默认情况下，<code>cin</code>和<code>cerr</code>都绑定了<code>cout</code>，所以无论是读和写这两个对象，都会刷新<code>cout</code>的缓存。</li>
</ol>
<h4 id="Flushing-the-Output-Buffer"><a href="#Flushing-the-Output-Buffer" class="headerlink" title="Flushing the Output Buffer"></a>Flushing the Output Buffer</h4><p>操作符<code>endl</code>会刷新缓存，并在增加一个换行符。<br>操作符<code>ends</code>会刷新缓存，并在增加一个空白字符。<br>操作符<code>flush</code>单纯刷新缓存。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;hi!&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;hi!&quot;</span> &lt;&lt; flush;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;hi!&quot;</span> &lt;&lt; ends;</span><br></pre></td></tr></table></figure>
<h4 id="The-unitbuf-Manipulator"><a href="#The-unitbuf-Manipulator" class="headerlink" title="The unitbuf Manipulator"></a>The unitbuf Manipulator</h4><p><code>unitbuf</code>可以理解为一个开关，当设上时，每一次的输出操作都会立刻的刷新缓存。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; unitbuf;</span><br></pre></td></tr></table></figure>
<p>可以通过<code>nounitbuf</code>关闭</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; nounitbuf;</span><br></pre></td></tr></table></figure>
<h4 id="Tying-Input-and-Output-Streams-Together"><a href="#Tying-Input-and-Output-Streams-Together" class="headerlink" title="Tying Input and Output Streams Together"></a>Tying Input and Output Streams Together</h4><p>当一个输入IO对象绑定输出IO对象时，任何对于输入IO对象的读取，都会刷新输出IO对象的缓存。</p>
<p>默认情况下，<code>cin</code>绑定给了<code>cout</code>，所以执行任何的<code>cin &gt;&gt; xxx</code>操作都会先刷新<code>cout</code>对象</p>
<p>关于绑定有两个操作函数，<code>tie()</code>和<code>tie(&amp; o)</code>，前者返回当前绑定的IO输出对象的指针，后者也返回当前绑定的IO输出对象的指针，然后将<code>o</code>作为新的绑定IO输出对象。如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cin.<span class="built_in">tie</span>(&amp;cout); <span class="comment">//System already do</span></span><br><span class="line"></span><br><span class="line">ostream *old_tie = cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="comment">//old_tie is pointer to cout</span></span><br><span class="line"><span class="comment">//Now cin is tied to nothing</span></span><br><span class="line"></span><br><span class="line">cin.<span class="built_in">tie</span>(&amp;cerr);</span><br><span class="line">cin.<span class="built_in">tie</span>(old_tie);</span><br><span class="line"><span class="comment">//cin is tied to cout</span></span><br></pre></td></tr></table></figure>
<p>注意，每个IO对象只能绑定给一个输出对象，所以上示代码中，<code>cin</code>最终绑定给了<code>old_tie</code>。但是一个输出对象可以同时被多个IO对象绑定，如<code>cout</code>同时被<code>cin</code>和<code>cerr</code>绑定。</p>
<h2 id="File-Input-and-Output"><a href="#File-Input-and-Output" class="headerlink" title="File Input and Output"></a>File Input and Output</h2><p>对于文件的流操作包含有三个类型：</p>
<ol>
<li><code>ifstream</code>：读取给定文件</li>
<li><code>ofstream</code>：写入给定文件</li>
<li><code>fstream</code>：读取或写入给定文件</li>
</ol>
<p>如之前所述，对于<code>iostream</code>的所有操作都可以用于<code>fstream</code>，而<code>fstream</code>还有一些特定的操作，如下所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>fstream fstrm;</td>
<td>fstream是fstream头文件中定义的类型，fstrm是实例，且没有打开任何的文件</td>
</tr>
<tr>
<td>fstream fstrm(s, mode);</td>
<td>fstrm打开地址为s的文件，s可以是string，也可以是C风格的字符串，默认的mode与fstream的类型相关</td>
</tr>
<tr>
<td>fstream fstrm(s, mode);</td>
<td>指定打开文件的模式为mode</td>
</tr>
<tr>
<td>fstrm.open(s)</td>
<td>打开地址为s的文件，mode与类型相关，返回空</td>
</tr>
<tr>
<td>fstrm.open(s,mode)</td>
<td>打开地址为s的文件，指定mode，返回空</td>
</tr>
<tr>
<td>fstrm.close()</td>
<td>关闭当前绑定的文件</td>
</tr>
<tr>
<td>fstrm.is_open()</td>
<td>检查绑定的文件是否被正确打开</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Using-File-Stream-Objects"><a href="#Using-File-Stream-Objects" class="headerlink" title="Using File Stream Objects"></a>Using File Stream Objects</h3><p>无论是要写入还是读取一个文件，都需要定义一个文件流，然后使用该文件流打开文件。</p>
<p>当使用带有文件地址的文件流构造函数时，文件会被自动打开。如<code>ifstream in(file)</code>。</p>
<p>file为C风格的字符串，在C++11下，file还可以是string。</p>
<h4 id="Using-an-fstream-in-Place-of-an-iostream-amp"><a href="#Using-an-fstream-in-Place-of-an-iostream-amp" class="headerlink" title="Using an fstream in Place of an iostream&amp;"></a>Using an fstream in Place of an iostream&amp;</h4><p>fstream作为iostream的派生类，如果一个函数的形参为<code>iostream&amp;</code>，则也可以传递<code>fstream</code>。</p>
<p>注意，因为IO操作不支持拷贝和赋值，所以函数的形参必然为引用。</p>
<h4 id="The-open-and-close-Members"><a href="#The-open-and-close-Members" class="headerlink" title="The open and close Members"></a>The open and close Members</h4><p><code>open</code>操作并不一定成功，当失败时其中的<code>failbit</code>位会被置上，所以通常来说，最好使用代码检查文件流的状态，如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ofstream out;</span><br><span class="line">out.<span class="built_in">open</span>(file);</span><br><span class="line"><span class="keyword">if</span> (out)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>当文件流已经打开了一个文件，则该文件流无法直接打开其他的文件，必须先关闭前一个文件才行，如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ofstream out;</span><br><span class="line">out.<span class="built_in">open</span>(file);</span><br><span class="line">out.<span class="built_in">close</span>();</span><br><span class="line">out.<span class="built_in">open</span>(file2);</span><br></pre></td></tr></table></figure>
<p>一个文件，也无法被多个文件流打开，当需要另一个文件流操作时，需要先让使用该文件的文件流关闭文件，如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">out1.<span class="built_in">open</span>(<span class="string">&quot;./Test.txt&quot;</span>);</span><br><span class="line">out1.<span class="built_in">close</span>();</span><br><span class="line">in.<span class="built_in">open</span>(<span class="string">&quot;./Test.txt&quot;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="Automatic-Construction-and-Destruction"><a href="#Automatic-Construction-and-Destruction" class="headerlink" title="Automatic Construction and Destruction"></a>Automatic Construction and Destruction</h4><p>当一个文件流对象离开了作用域时，它会被销毁，在销毁时会自动的给关闭当前绑定的文件。</p>
<h3 id="File-Modes"><a href="#File-Modes" class="headerlink" title="File Modes"></a>File Modes</h3><p>文件流的打开模式有以下几种：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>模式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>in</td>
<td>作为程序的输入打开（读取文件）</td>
</tr>
<tr>
<td>out</td>
<td>作为程序输出打开（写入文件）</td>
</tr>
<tr>
<td>app</td>
<td>每一次写入前，定位到文件的最后</td>
</tr>
<tr>
<td>ate</td>
<td>在文件打开时，直接定位到文件的最后</td>
</tr>
<tr>
<td>trunc</td>
<td>删除文件的内容</td>
</tr>
<tr>
<td>binary</td>
<td>以位模式进行IO操作</td>
</tr>
</tbody>
</table>
</div>
<p><code>ifstream</code>默认以<code>in</code>模式打开。<code>ofstream</code>默认以<code>out</code>模式打开，且<code>trunc</code>位被置上，即输出时默认将文件内已有的内容删除的。<code>fstream</code>默认同时以in和out模式打开文件</p>
<p>主动设定模式，要以下限制：</p>
<ol>
<li><code>out</code>只能在<code>ofsteram</code>和<code>fstream</code>类型时被置上</li>
<li><code>in</code>只能在<code>ifsteram</code>和<code>fstream</code>类型时被置上</li>
<li><code>trunc</code>只有在<code>out</code>模式下才能置上</li>
<li><code>app</code>只能在<code>trunc</code>没有被置上时才能置上</li>
<li><code>ate</code>和<code>binary</code>可以在任何文件流类型置上，且可以与其他的类型任意搭配。</li>
</ol>
<h4 id="Opening-a-File-in-out-Mode-Discards-Existing-Data"><a href="#Opening-a-File-in-out-Mode-Discards-Existing-Data" class="headerlink" title="Opening a File in out Mode Discards Existing Data"></a>Opening a File in out Mode Discards Existing Data</h4><p><code>ofstream</code>模式默认是以<code>out</code>模式打开，且置上<code>trunc</code>位，所以如下的几种定义方式没有区别：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">&quot;file1&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">out2</span><span class="params">(<span class="string">&quot;file1&quot;</span>, ofstream::out)</span></span>; <span class="comment">// outand truncare implicit</span></span><br><span class="line"><span class="function">ofstream <span class="title">out3</span><span class="params">(<span class="string">&quot;file1&quot;</span>, ofstream::out | ofstream::trunc)</span></span>;</span><br></pre></td></tr></table></figure>
<p>如果要保护文件的内容不被删除，有两种方法，一是置上<code>app</code>位，二是同时置上<code>in</code>和<code>out</code>位。如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// to preserve the file’s contents, we must explicitly specify appmode </span></span><br><span class="line"><span class="function">ofstream <span class="title">app</span><span class="params">(<span class="string">&quot;file2&quot;</span>, ofstream::app)</span></span>; <span class="comment">// out is implicit</span></span><br><span class="line"><span class="function">ofstream <span class="title">app2</span><span class="params">(<span class="string">&quot;file2&quot;</span>, ofstream::out | ofstream::app)</span></span>;</span><br></pre></td></tr></table></figure>
<p>注意<code>in</code>模式只能赋给<code>ifstream</code>和<code>fstream</code>，所以上示代码中是通过置上<code>app</code>位。</p>
<h4 id="File-Mode-is-Determined-Each-Time-open-Is-Called"><a href="#File-Mode-is-Determined-Each-Time-open-Is-Called" class="headerlink" title="File Mode is Determined Each Time open Is Called"></a>File Mode is Determined Each Time open Is Called</h4><p>文件流的mode可以看作是与文件结合的，文件流的mode会在每次打开文件时重新指定。如果没有在重新打开文件时，没有显示的设置mode，则该文件会重新以默认的mode打开（不会保留打开前一个文件时指定的mode）。</p>
<p>如下测试，文件已有内容为<code>123\456</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">out1</span><span class="params">(<span class="string">&quot;./Test.txt&quot;</span>, ostream::app)</span></span>;</span><br><span class="line">out1 &lt;&lt; <span class="string">&quot;\n789&quot;</span>;</span><br><span class="line">out1.<span class="built_in">close</span>();</span><br><span class="line">in.<span class="built_in">open</span>(<span class="string">&quot;./Test.txt&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (in.<span class="built_in">good</span>())</span><br><span class="line">&#123;</span><br><span class="line">    in &gt;&gt; content;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Read Content with good is &quot;</span> &lt;&lt; content &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">in.<span class="built_in">close</span>();</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">out1.<span class="built_in">open</span>(<span class="string">&quot;./Test.txt&quot;</span>);</span><br><span class="line">out1 &lt;&lt; <span class="string">&quot;\n666&quot;</span>;</span><br><span class="line">out1.<span class="built_in">close</span>();</span><br><span class="line">in.<span class="built_in">open</span>(<span class="string">&quot;./Test.txt&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (in.<span class="built_in">good</span>())</span><br><span class="line">&#123;</span><br><span class="line">    in &gt;&gt; content;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Read Content with good is &quot;</span> &lt;&lt; content &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Read Content with good is 123</span></span><br><span class="line"><span class="comment">Read Content with good is 456</span></span><br><span class="line"><span class="comment">Read Content with good is 789</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Read Content with good is 666</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>可以看到<code>out1</code>，在创建时设置上了<code>app</code>位，所以没有擦除文件已有内容。但当其重新打开文件时，<code>app</code>位被清空，仍然是<code>trunc</code>被置上，文件已有内容被删除。</p>
<h2 id="string-Streams"><a href="#string-Streams" class="headerlink" title="string Streams"></a>string Streams</h2><p>String流是把String看作一个IO流进行操作，定义在<code>sstream</code>头文件中，其中包括<code>istringstream</code>读取string，<code>ostringstream</code>写入string，<code>stringstream</code>可同时读取和写string。string流有以下特有的操作：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>sstream strm</td>
<td>创建一个未绑定的string流</td>
</tr>
<tr>
<td>sstream stream(s)</td>
<td>创建一个绑定s拷贝的string流，s是string类型，该构造函数是explicit的</td>
</tr>
<tr>
<td>strm.str()</td>
<td>返回strm绑定的string的拷贝</td>
</tr>
<tr>
<td>strm.str(s)</td>
<td>将s的拷贝绑定至strm，返回空</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Using-an-istringstream"><a href="#Using-an-istringstream" class="headerlink" title="Using an istringstream"></a>Using an istringstream</h3><p>因为sstringstream继承自iostream可以使用操作符，所以istringstream可以使用&gt;&gt;操作符，且如同cin中的&gt;&gt;一样，一次读取是以空白字符为结束的。如以下代码就是通过stringstream来从输入中读取数据：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//morgan 2015 86255</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">getline</span>(cin, line))</span><br><span class="line">&#123;</span><br><span class="line">    PersonInfo info;</span><br><span class="line">    <span class="function">istringstream <span class="title">record</span><span class="params">(line)</span></span>; <span class="comment">//Bind line to record</span></span><br><span class="line">    record &gt;&gt; info.name;        <span class="comment">//Read one word,in this case, it&#x27;s name</span></span><br><span class="line">    <span class="comment">// Read one word,in this case, it&#x27;s phone,</span></span><br><span class="line">    <span class="comment">//If condition is false, means that there is no content</span></span><br><span class="line">    <span class="keyword">while</span> (record &gt;&gt; word)</span><br><span class="line">    &#123;</span><br><span class="line">        info.phones.<span class="built_in">push_back</span>(word);</span><br><span class="line">    &#125;</span><br><span class="line">    people.<span class="built_in">push_back</span>(info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Using-ostringstreams"><a href="#Using-ostringstreams" class="headerlink" title="Using ostringstreams"></a>Using ostringstreams</h3><p>同样的，ostringstream可以使用&lt;&lt;操作符，对ostringstream使用&lt;&lt;操作符类似于对string使用+=。如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ostringstream ssf;</span><br><span class="line">ssf &lt;&lt; <span class="string">&quot;123&quot;</span></span><br><span class="line">    &lt;&lt; <span class="string">&quot; 456&quot;</span>;</span><br><span class="line">cout &lt;&lt; ssf.<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">123 456</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<div class="note info simple"><p>引用：</p>
<ol>
<li><em>Cpp Primer</em> 5th Aug.2012</li>
</ol>
</div>
<hr>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>计算机语言</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>《C++ Primer》 第七章笔记</title>
    <url>/CPPPrimer-Chapter7-Notes/</url>
    <content><![CDATA[<p>《C++ Primer》 第七章笔记</p>
<p><img src="CPPPrimer-Chapter7-Notes/Ch_7.png" alt="第七章内容"></p>
<span id="more"></span>
<h1 id="Chapter-7-Classes"><a href="#Chapter-7-Classes" class="headerlink" title="Chapter 7 Classes"></a>Chapter 7 Classes</h1><h2 id="Defining-Abstract-Data-Types"><a href="#Defining-Abstract-Data-Types" class="headerlink" title="Defining Abstract Data Types"></a>Defining Abstract Data Types</h2><p>如果一个类让用户可以任意访问其中的数据，且必须自己定义针对相关数据的操作，则该类不是抽象类型。</p>
<h3 id="Designing-the-Sales-data-class"><a href="#Designing-the-Sales-data-class" class="headerlink" title="Designing the Sales_data class"></a>Designing the Sales_data class</h3><p>在本章中，会逐步完善一个称为Sales_data的类，在完善的过程中解释类的特性。</p>
<h3 id="Defining-the-Revised-Sales-data-Class"><a href="#Defining-the-Revised-Sales-data-Class" class="headerlink" title="Defining the Revised Sales_data Class"></a>Defining the Revised Sales_data Class</h3><p>成员函数必须在类内声明，可以在类内或类外进行定义。且在类内定义的函数默认是内联（inline）的。</p>
<p>如目前Sales_data类为：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::istream;</span><br><span class="line"><span class="keyword">using</span> std::ostream;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Member function</span></span><br><span class="line">    <span class="function">string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> bookNo; &#125;</span><br><span class="line">    <span class="function">Sales_data &amp;<span class="title">combine</span><span class="params">(<span class="type">const</span> Sales_data &amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">avg_Price</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Member variable</span></span><br><span class="line">    string bookNo;</span><br><span class="line">    <span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//nonmember but related function</span></span><br><span class="line"></span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data &amp;, <span class="type">const</span> Sales_data &amp;)</span></span>;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;, <span class="type">const</span> Sales_data &amp;)</span></span>;</span><br><span class="line"><span class="function">istream &amp;<span class="title">read</span><span class="params">(istream &amp;, Sales_data &amp;)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="Introducing-this"><a href="#Introducing-this" class="headerlink" title="Introducing this"></a>Introducing this</h4><p>首先注意成员函数:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> bookNo; &#125;</span><br></pre></td></tr></table></figure>
<p>当类的实例化调用函数时，实际上会隐式的传递一个this指针，指针指向该实例的地址，如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Sales_data total;</span><br><span class="line">total.<span class="built_in">isbn</span>();</span><br></pre></td></tr></table></figure>
<p>编译器会将<code>total.isbn()</code>调用，改写为类似于如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Sales_data::<span class="built_in">isbn</span>(&amp;total);</span><br></pre></td></tr></table></figure>
<p>当在函数内部访问成员变量时都相当于用了<code>this-&gt;</code>。如函数体内访问了bookNo，实际上等同于<code>this-&gt;bookNo</code>，而这个调用下，this指向total，所以访问的是实例化total中的bookNo变量。</p>
<p>另外this是一个const指针，即无法让this指向别的变量。</p>
<h4 id="Intruducing-const-Member-Functions"><a href="#Intruducing-const-Member-Functions" class="headerlink" title="Intruducing const Member Functions"></a>Intruducing const Member Functions</h4><p>同样还是成员函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> bookNo; &#125;</span><br></pre></td></tr></table></figure>
<p>还需要注意到在这个函数的声明中有关键字<code>const</code>，当const跟在参数列表后时，其目的是改变this指针的类型，让this指针是一个指向const变量的指针。整个函数的定义会被编译器翻译为类似如下的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">Sales_data::isbn</span><span class="params">(<span class="type">const</span> Sales_data* <span class="type">const</span> <span class="keyword">this</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;bookNo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>称这样的函数为const函数。</p>
<p>如果该函数不是定义为const的，则const的Sales_data实例将无法调用isbn函数。如同变量的隐式转换规律，一个const变量无法赋值给一个指向非const变量的指针。实例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//In SalesData_Struct.h, modify the declaration of isbn function</span></span><br><span class="line"><span class="function">string <span class="title">isbn</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> bookNo; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Call isbn function</span></span><br><span class="line">Sales_data total;</span><br><span class="line">total.<span class="built_in">isbn</span>();</span><br><span class="line"><span class="type">const</span> Sales_data cTotal;</span><br><span class="line"><span class="comment">// cTotal.isbn();//error</span></span><br></pre></td></tr></table></figure>
<p>在编译器的隐式转换后，<code>cTotal.isbn()</code>会变成用一个<code>const Sales_data* const</code>类型的指针区初始化一个<code>Sales_data* const</code>类型的指针，如之前章节所述，该操作是非法的。</p>
<h4 id="Class-Scope-and-Member-Functions"><a href="#Class-Scope-and-Member-Functions" class="headerlink" title="Class Scope and Member Functions"></a>Class Scope and Member Functions</h4><p>类的编译分为两步，首先会先编译所有的声明，然后再编译函数的定义（实现），因此在函数的实现中，可以任意调用其他的成员变量，无论它定义在更前面还是后面。</p>
<h4 id="Defining-a-Member-Function-outside-the-Class"><a href="#Defining-a-Member-Function-outside-the-Class" class="headerlink" title="Defining a Member Function outside the Class"></a>Defining a Member Function outside the Class</h4><p>如果在类外定义const函数，同样需要在参数列表后加上const关键字</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">Sales_data::avg_Price</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (units_sold)</span><br><span class="line">        <span class="keyword">return</span> revenue / units_sold;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Defining-a-Function-to-Return-“This”-Object"><a href="#Defining-a-Function-to-Return-“This”-Object" class="headerlink" title="Defining a Function to Return “This” Object"></a>Defining a Function to Return “This” Object</h4><p>如果成员函数返回类型是该类型本身或者该类型的引用，可以返回<code>*this</code>，如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Sales_data &amp;<span class="title">Sales_data::combine</span><span class="params">(<span class="type">const</span> Sales_data &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    units_sold += rhs.units_sold;</span><br><span class="line">    revenue += rhs.revenue;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Defining-Nonmember-Class-Related-Functions"><a href="#Defining-Nonmember-Class-Related-Functions" class="headerlink" title="Defining Nonmember Class-Related Functions"></a>Defining Nonmember Class-Related Functions</h3><p>一些函数从概念上是某种类型的一部分，但却不是定义在函数的内部。这样的函数声明应该写在该类型的头文件（函数定义可以放在头文件对应的cpp文件中）。</p>
<p>如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//In SalesData_struct.h</span></span><br><span class="line"><span class="comment">//nonmember but related function</span></span><br><span class="line"></span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data &amp;, <span class="type">const</span> Sales_data &amp;)</span></span>;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;, <span class="type">const</span> Sales_data &amp;)</span></span>;</span><br><span class="line"><span class="function">istream &amp;<span class="title">read</span><span class="params">(istream &amp;, Sales_data &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//In SalesData_struct.cpp</span></span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data &amp;lhs, <span class="type">const</span> Sales_data &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Sales_data sum = lhs;</span><br><span class="line">    sum.<span class="built_in">combine</span>(rhs);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="type">const</span> Sales_data &amp;item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    os &lt;&lt; item.<span class="built_in">isbn</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.units_sold &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.revenue &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.<span class="built_in">avg_Price</span>();</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">istream &amp;<span class="title">read</span><span class="params">(istream &amp;is, Sales_data &amp;item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> price = <span class="number">0</span>;</span><br><span class="line">    is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;</span><br><span class="line">    item.revenue = price * item.units_sold;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意在函数<code>print</code>和<code>read</code>中返回的是ostream和istream的引用，这是因为这两个类型不支持拷贝。</p>
<p>在<code>add</code>函数中，首先是一个拷贝初始化<code>Sales_data sum = lhs</code>。C++的默认实现中，拷贝一个类类型会拷贝其中所有的成员变量，因此sum和lhs中的所有成员变量将有相同的值（但在不同的内存中）。</p>
<h3 id="Constructors"><a href="#Constructors" class="headerlink" title="Constructors"></a>Constructors</h3><p>构造函数特点：</p>
<ol>
<li>构造函数在实例化创建时被执行。</li>
<li>构造函数与函数类型同名</li>
<li>构造函数没有返回值</li>
<li>构造函数不允许被定义成const函数。因为一个对象的const与否是在创建后才决定的，所以构造函数会在决定constness前先执行。</li>
</ol>
<h4 id="The-Synthesized-Default-Constructor"><a href="#The-Synthesized-Default-Constructor" class="headerlink" title="The Synthesized Default Constructor"></a>The Synthesized Default Constructor</h4><p>默认构造函数（default constructor）是不需要任何形参的构造函数。</p>
<p>当类没有定义任何构造函数时，编译器会创建合成默认构造函数（synthesized default constructor）。合成默认构造函数的操作为，当参数有类内初始化（变量定义时有初始化值），如<code>int a = 3;</code>，则使用类内初始化值进行值初始化，否则使用变量的默认初始化。</p>
<h4 id="Some-Classes-Cannot-Rely-on-the-synthesized-Default-Constructor"><a href="#Some-Classes-Cannot-Rely-on-the-synthesized-Default-Constructor" class="headerlink" title="Some Classes Cannot Rely on the synthesized Default Constructor"></a>Some Classes Cannot Rely on the synthesized Default Constructor</h4><p>一些类无法依赖合成默认构造函数，因为</p>
<ol>
<li>只有类没有定义任何构造函数时，才会有合成默认构造函数</li>
<li>当没有类内初始化值时，合成默认构造函数会使用变量默认初始化，但内建类型（int等）和复合类型（array，pointer）出现在函数内部时默认值是未定义的。所以当且仅当这些参数有类内初始化值时才可以依赖合成默认构造函数，否则构造的结果是未定义的。</li>
<li>有的情况下，编译器无法生成合成默认构造函数。如类中的一个成员变量并没有默认构造函数，合成默认构造函数也就无法去初始化这个变量。因此在这种情况下，需要自己定义默认构造函数。</li>
</ol>
<h4 id="Defining-the-Sales-data-Constructors"><a href="#Defining-the-Sales-data-Constructors" class="headerlink" title="Defining the Sales_data Constructors"></a>Defining the Sales_data Constructors</h4><p>Sales_data构造函数定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Inside class body</span></span><br><span class="line"><span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="built_in">Sales_data</span>(<span class="type">const</span> string &amp;s) : <span class="built_in">bookNo</span>(s) &#123;&#125;</span><br><span class="line"><span class="built_in">Sales_data</span>(<span class="type">const</span> string &amp;s, <span class="type">unsigned</span> n, <span class="type">double</span> p) : <span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(n), <span class="built_in">revenue</span>(p * n) &#123;&#125;</span><br><span class="line"><span class="built_in">Sales_data</span>(istream &amp;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Outside class body</span></span><br><span class="line">Sales_data::<span class="built_in">Sales_data</span>(istream &amp;is)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">read</span>(is, *<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述一共定义了四个构造函数，其中三个是在类内定义的，一个是在类外定义的。</p>
<p>在定义默认构造函数时，使用了default关键字，该关键字是C++11的特性，表示希望构造函数表现的如同合成默认构造函数一模一样。</p>
<h4 id="Constructor-Initializer-List"><a href="#Constructor-Initializer-List" class="headerlink" title="Constructor Initializer List"></a>Constructor Initializer List</h4><p>在构造函数中的定义中，出现在参数列表后，函数主体前，以<code>:</code>开头的部分称为初始化列表（Initializer List）。初始化列表必须出现在函数定义中，即必须与函数主体一起出现。</p>
<p>当一个成员变量没有出现在初始化列表中时，该函数的初始化逻辑与合成构造函数相同，即有类内初始化值使用类内初始化，否则使用默认初始化。</p>
<ul>
<li>建议为每个成员参数都设置类内初始化值</li>
</ul>
<h4 id="Defining-a-Constructor-outside-the-Class-Body"><a href="#Defining-a-Constructor-outside-the-Class-Body" class="headerlink" title="Defining a Constructor outside the Class Body"></a>Defining a Constructor outside the Class Body</h4><p>如形参为<code>istream</code>版本的构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Sales_data</span>(istream &amp;);</span><br><span class="line"></span><br><span class="line">Sales_data::<span class="built_in">Sales_data</span>(istream &amp;is)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">read</span>(is, *<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该构造函数没有初始化列表，或者严格意义上说，初始化列表为空。则该构造函数会在执行函数主体前，先按照合成默认构造函数的逻辑初始化所有成员变量，然后再执行函数主体。</p>
<blockquote>
<p>尽量在初始化列表中初始化变量。如果将成员变量的赋值写在构造函数主体内，则实际上是经过了一个默认初始化，再进行了一个赋值。</p>
</blockquote>
<h3 id="Copy-Assignment-and-Destruction"><a href="#Copy-Assignment-and-Destruction" class="headerlink" title="Copy, Assignment, and Destruction"></a>Copy, Assignment, and Destruction</h3><p>类还要控制对象是如何被拷贝，赋值和摧毁的。</p>
<ol>
<li>拷贝：当使用对象初始化另一个变量，或作为值类型（没有引用）传递进函数或从函数返回时，对象都会经历拷贝。</li>
<li>赋值：当使用赋值操作符（<code>=</code>）时会经历赋值</li>
<li>摧毁：当对象退出作用域时会被摧毁。在数组和vector中的元素，会在容器摧毁时被摧毁。</li>
</ol>
<p>如果用户没有指定拷贝，赋值和摧毁的实现，编译器都会提供合成版本。以下代码展示了编译器提供的合成赋值操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">total = trans; <span class="comment">// synthesized assignment</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Equals to</span></span><br><span class="line">total.bookNo = trans.bookNo</span><br><span class="line">total.units_sold = trans.units_sold</span><br><span class="line">total.revenue = trans.revenue</span><br></pre></td></tr></table></figure>
<h4 id="Some-Classes-Canot-Rely-on-the-Synthesized-Versins"><a href="#Some-Classes-Canot-Rely-on-the-Synthesized-Versins" class="headerlink" title="Some Classes Canot Rely on the Synthesized Versins"></a>Some Classes Canot Rely on the Synthesized Versins</h4><p>通常来说，有动态内存分配的类不适合合成版本的拷贝，赋值和摧毁（第12章和13.1.4节会解释）。</p>
<p>但是合成版本可以正确处理string和vector，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Test firstOne;</span><br><span class="line">firstOne.value = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">Test secondOne;</span><br><span class="line">secondOne = firstOne;</span><br><span class="line"></span><br><span class="line">firstOne.value[<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;First one value is: &quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : firstOne.value)</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Second one value is: &quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : secondOne.value)</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// First one value is: </span></span><br><span class="line"><span class="comment">// 4 2 3</span></span><br><span class="line"><span class="comment">// Second one value is:</span></span><br><span class="line"><span class="comment">// 123</span></span><br></pre></td></tr></table></figure>
<p>Test类中仅包含一个vector，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到合成默认赋值正确的拷贝了vector中的每个元素。</p>
<h2 id="Access-Control-and-Encapsulation"><a href="#Access-Control-and-Encapsulation" class="headerlink" title="Access Control and Encapsulation"></a>Access Control and Encapsulation</h2><p>public关键字后的变量可以被程序的其他部分访问，private关键字后变量仅能被类中的成员函数访问。</p>
<p>public和private关键字可以出现在类中出现任意多次。</p>
<h4 id="Using-the-class-or-struct-keyboard"><a href="#Using-the-class-or-struct-keyboard" class="headerlink" title="Using the class or struct keyboard"></a>Using the class or struct keyboard</h4><p>struct和class的<strong>唯一</strong>区别在于，class中没有写在public和private后的成员默认是private的，而struct中则默认是public的（struct中同样可以定义public和private）。</p>
<h3 id="Friends"><a href="#Friends" class="headerlink" title="Friends"></a>Friends</h3><p>一个类可以允许其他的类或者函数访问其中的非public变量，此时其他的函数或者类被称为友类（函数）（Friends）。</p>
<p>要声明函数是友函数，只需要在类中加上函数的声明，并且最前方加入<code>friend</code>关键字即可。如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data &amp;, <span class="type">const</span> Sales_data &amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;, <span class="type">const</span> Sales_data &amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> istream &amp;<span class="title">read</span><span class="params">(istream &amp;, Sales_data &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> string &amp;s);</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> string &amp;s, <span class="type">unsigned</span> n, <span class="type">double</span> p) : <span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(n), <span class="built_in">revenue</span>(p * n) &#123;&#125;</span><br><span class="line">    <span class="built_in">Sales_data</span>(istream &amp;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//Member function</span></span><br><span class="line">    <span class="function">string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> bookNo; &#125;</span><br><span class="line">    <span class="comment">// string isbn() &#123; return bookNo; &#125; // should be const</span></span><br><span class="line">    <span class="function">Sales_data &amp;<span class="title">combine</span><span class="params">(<span class="type">const</span> Sales_data &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">avg_Price</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">//Member variable</span></span><br><span class="line">    string bookNo;</span><br><span class="line">    <span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>friend</code>关键字只可以出现在类的定义中，而且因为严格意义上它并不是类的一部分，所以可以出现在类中的任意地方，不受public和private影响。</p>
<h4 id="Declarations-for-Friends"><a href="#Declarations-for-Friends" class="headerlink" title="Declarations for Friends"></a>Declarations for Friends</h4><p>在类内部关于friends的声明并不是函数声明，因此应该在类外部再次声明函数。如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data &amp;, <span class="type">const</span> Sales_data &amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;, <span class="type">const</span> Sales_data &amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> istream &amp;<span class="title">read</span><span class="params">(istream &amp;, Sales_data &amp;)</span></span>; </span><br><span class="line"></span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sales_data returnAddResult(const Sales_data &amp;lhs, const Sales_data &amp;rhs)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     return add(lhs, rhs);</span></span><br><span class="line"><span class="comment">// &#125; //Error</span></span><br><span class="line"></span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data &amp;, <span class="type">const</span> Sales_data &amp;)</span></span>;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;, <span class="type">const</span> Sales_data &amp;)</span></span>;</span><br><span class="line"><span class="function">istream &amp;<span class="title">read</span><span class="params">(istream &amp;, Sales_data &amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>示例代码中的<code>returnAddResult</code>尝试返回<code>add</code>函数的结果，但因为<code>add</code>函数仅被声明为了友函数，并没有真正的进行声明，所以无法访问。</p>
<ul>
<li>虽然即使不在类外部再次声明函数，大部分的编译器也都能正确编译。但是C++标准是要求在类外再次声明的，即使程序在没有再次声明的情况下正常运行了，也不能保证该代码换一个编译器仍然能正常工作。</li>
</ul>
<h2 id="Additional-Class-Features"><a href="#Additional-Class-Features" class="headerlink" title="Additional Class Features"></a>Additional Class Features</h2><p>7.1-7.2以<code>Sales_data</code>这个类作为例子说明了类的一些特性。在这一节中会继续深入探讨这些特性。</p>
<h3 id="Class-Members-Revisited"><a href="#Class-Members-Revisited" class="headerlink" title="Class Members Revisited"></a>Class Members Revisited</h3><h4 id="Defining-a-Type-Member"><a href="#Defining-a-Type-Member" class="headerlink" title="Defining a Type Member"></a>Defining a Type Member</h4><p>在类内部，也可以定义Type成员。该成员与其他的成员类型一样，是受public和private关键字影响的。但与其他成员不同的是，在使用该类型前，必须已经出现了该类型的定义（对其他成员，会先编译声明，再编译定义，因此成员的位置不造成任何影响），如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// pos i = 0; //error, the pos hasn&#x27;t been </span></span><br><span class="line">    <span class="keyword">typedef</span> string::size_type pos;</span><br><span class="line">    <span class="comment">// using pos = string::size_type; // same with above</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    pos cursor = <span class="number">0</span>, height = <span class="number">0</span>, width = <span class="number">0</span>;</span><br><span class="line">    string content;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当在类外访问该别名时，也需要像访问普通变量一样，如<code>Screen::pos</code></p>
<h4 id="Making-Members-inline"><a href="#Making-Members-inline" class="headerlink" title="Making Members inline"></a>Making Members inline</h4><p>如之前所述，定义在类内部的函数会隐式的认为为inline的。也可以通过显示的在函数类内声明或类外定义前加上inline来将函数变为内联函数，如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">get</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> content[cursor];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">get</span><span class="params">(pos ht, pos wd)</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">Screen::get</span><span class="params">(pos ht, pos wd)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，<code>get()</code>是隐式的被定义为内联，<code>get(pos ht, pos wd)</code>是显示的被定义为内联，代码中<code>get(pos ht, pos wd)</code>的声明和定义处都加上了关键字inline，实际上只需要在任意一处定义即可。</p>
<p>注意如在第六章中所述，内联函数的定义建议与声明放在同一个头文件中</p>
<h4 id="mutable-Data-Members"><a href="#mutable-Data-Members" class="headerlink" title="mutable Data Members"></a>mutable Data Members</h4><p>mutable数据成员永远不会是const的，即使在const函数中（this指针是指向const的指针）仍然能被修改。如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ChangeAccessCtr</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">size_t</span> accessCtr = <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Screen::ChangeAccessCtr</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ++accessCtr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上述代码中,<code>ChangeAccessCtr</code>是const函数，但因为accessCtr变量是mutable的，所以仍然能够修改accessCtr。</p>
<h3 id="Functions-That-Return-this"><a href="#Functions-That-Return-this" class="headerlink" title="Functions That Return *this"></a>Functions That Return *this</h3><p>如果某成员函数返回的类型为类的引用，则该函数可以被正确的级联起来，否则虽然可以通过编译，但之后的操作是基于临时变量，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Define class function outside class</span></span><br><span class="line"><span class="function">Screen &amp;<span class="title">Screen::move</span><span class="params">(pos ht, pos wd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pos row = ht * width;</span><br><span class="line">    cursor = row + wd;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Screen &amp;<span class="title">Screen::set</span><span class="params">(<span class="type">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    content[cursor] = c;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Screen <span class="title">Screen::move_copy</span><span class="params">(pos ht, pos wd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pos row = ht * width;</span><br><span class="line">    cursor = row + wd;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Test code</span></span><br><span class="line"></span><br><span class="line"><span class="function">Screen <span class="title">sc</span><span class="params">(<span class="number">20</span>, <span class="number">20</span>, <span class="string">&#x27; &#x27;</span>)</span></span>;</span><br><span class="line">sc.<span class="built_in">move</span>(<span class="number">4</span>, <span class="number">0</span>).<span class="built_in">set</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;content is &quot;</span> &lt;&lt; sc.<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">sc.<span class="built_in">move_copy</span>(<span class="number">4</span>,<span class="number">0</span>).<span class="built_in">set</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;content is &quot;</span> &lt;&lt; sc.<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">content is a</span></span><br><span class="line"><span class="comment">content is a</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>如上述代码所示，<code>move</code>函数返回的是类型的引用，<code>move_copy</code>函数返回的是类型本身，因此实际上返回的是一个经过拷贝初始化临时变量。当对<code>move</code>函数的返回值调用<code>set</code>时，原先的值被修改了，而对<code>move_copy</code>函数的返回值调用<code>set</code>时，被修改的实际上是返回的临时变量。</p>
<h4 id="Returning-this-from-a-const-Member-Function"><a href="#Returning-this-from-a-const-Member-Function" class="headerlink" title="Returning *this from a const Member Function"></a>Returning *this from a const Member Function</h4><p>如果成员函数是const函数，且返回类型是该类型的指针或引用，那么该指针或引用是指向const变量的。也因此无法级联调用其他非const的函数，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//In Screen.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">const</span> Screen &amp;<span class="title">Display</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> Screen &amp;<span class="title">Screen::Display</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; content;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//In Chapter7_Classes.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sc.Display().set(&#x27;a&#x27;); //error when there is no nonconst overload</span></span><br></pre></td></tr></table></figure>
<p>在上述代码中，因为<code>Display</code>函数是const的，因此传入的this指针是<code>const Screen * const</code>类型，也因此如果返回的是<code>*this</code>，返回类型为<code>const Screen&amp;</code>。</p>
<p>调用语句<code>sc.Display().set(&#39;a&#39;)</code>失败，是因为set不是const函数，所以其this指针类型为<code>Screen * const</code>，而传入的是Display返回的变量指针，类型为<code>const Screen * const</code>，所以无法进行隐式转换。</p>
<h4 id="Overloading-Based-on-const"><a href="#Overloading-Based-on-const" class="headerlink" title="Overloading Based on const"></a>Overloading Based on const</h4><p>解决上述问题的方法是，定义一个非const的函数进行重载，因为函数的const与否实际是决定传入的this指针的类型，而且是low level的const区别，所以可以进行重载。如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//In Screen.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">const</span> Screen &amp;<span class="title">Display</span><span class="params">(ostream &amp;)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> Screen &amp;<span class="title">Display</span><span class="params">(ostream &amp;)</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">do_display</span><span class="params">(ostream &amp;os)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> Screen &amp;<span class="title">Screen::Display</span><span class="params">(ostream &amp;os)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">do_display</span>(os);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//In Screen.cpp</span></span><br><span class="line"><span class="function">Screen &amp;<span class="title">Screen::Display</span><span class="params">(ostream &amp;os)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">do_display</span>(os);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Screen::do_display</span><span class="params">(ostream &amp;os)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    os &lt;&lt; content;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//In Chapter7_Classes.cpp</span></span><br><span class="line">sc.<span class="built_in">Display</span>(cout).<span class="built_in">set</span>(<span class="string">&#x27;a&#x27;</span>); <span class="comment">// correct,when there is nonconst overwrite</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上述代码中，<code>sc.Display(cout).set(&#39;a&#39;)</code>可以成功运行，因为类中定义了const和非const两个版本的Display函数。该语句实际调用的是非const版本的Display，其中会调用const函数<code>do_display</code>，调用中存在将指向非const对象的指针（this指针）隐式转换为指向const对象的指针的过程。</p>
<h3 id="Class-Type"><a href="#Class-Type" class="headerlink" title="Class Type"></a>Class Type</h3><p>每个类都定义了一个独特的类型。两个不同的类即使其中的所有成员都一模一样，也无法相互赋值，但可以通过指针进行转换。如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//In Test.h</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">First</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> memi = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> getMem = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Second</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> memi = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> getMem = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//In Chapter7_Classes.cpp</span></span><br><span class="line"></span><br><span class="line">First first;</span><br><span class="line">Second sec;</span><br><span class="line">first.memi = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sec = first; //Error</span></span><br><span class="line"></span><br><span class="line">Second *sp = <span class="built_in">reinterpret_cast</span>&lt;Second *&gt;(&amp;first);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sp value is &quot;</span> &lt;&lt; sp-&gt;memi &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sp value is 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="Class-Declarations"><a href="#Class-Declarations" class="headerlink" title="Class Declarations"></a>Class Declarations</h4><p>可以在没有定义类的情况下声明类，如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">NotDefined</span>;</span><br></pre></td></tr></table></figure>
<p>这种声明称为前向声明(forward declaration)。在执行完声明，但还没有执行完定义前，类<code>NotDefined</code>是不完整类型（incomplete type）。编译器知道了该类型是类，但还不知道其中包含有什么成员。</p>
<p>当创建一个类型的实例化时，该类型必须经过了定义。否则编译器不知道需要为他分配多少的内存。</p>
<p>不完整类型只能用于三个地方：</p>
<ol>
<li>定义该类型的指针或引用</li>
<li>作为函数声明中的参数或者返回类型。注意是声明，不是定义</li>
<li>作为静态类型成为类的成员</li>
</ol>
<p>在类的定义过程中，类还是不完整的。因为不完整类型可以用于以上三个地方，所以一个类型可以将本类型的指针或引用作为成员参数，或作为静态成员。也可以用本类型作为成员函数的形参和返回值。如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TestNotDefined</span></span><br><span class="line">&#123;</span><br><span class="line">    NotDefined *np;</span><br><span class="line">    <span class="type">static</span> NotDefined ns;</span><br><span class="line">    <span class="function">NotDefined <span class="title">functionAboutNotDefine</span><span class="params">(NotDefined)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Friendship-Revisited"><a href="#Friendship-Revisited" class="headerlink" title="Friendship Revisited"></a>Friendship Revisited</h3><p>一个类可以将另一个类或者某个类中特定的成员函数作为友类或友函数。</p>
<h4 id="Friendship-between-Classes"><a href="#Friendship-between-Classes" class="headerlink" title="Friendship between Classes"></a>Friendship between Classes</h4><p>在类中定义另一个类为友类，同样需要使用关键字<code>friend</code>，另外还需要指定类型为class，如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//In Screen.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Window_mgr</span>;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与定义普通的友函数一样，定义友类的语句可以出现在类定义内部的任何地方。此时，虽然出现了<code>Window_mgr</code>类名，但并不需要<code>Window_mgr</code>类被定义，甚至不需要其被声明。</p>
<p>定义<code>Window_mgr</code>类的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//In Window_mgr.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Screen.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Window_mgr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ScreenIndex = vector&lt;Screen&gt;::size_type;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">(ScreenIndex index)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;Screen&gt; screens&#123;<span class="built_in">Screen</span>(<span class="number">5</span>, <span class="number">5</span>, <span class="string">&#x27;a&#x27;</span>)&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//In Window_mgr.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Window_mgr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Window_mgr::Clear</span><span class="params">(ScreenIndex index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Screen &amp;s = screens[index];</span><br><span class="line">    s.content = <span class="built_in">string</span>(s.height * s.width, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里因为需要真切的用到Screen类型，所以需要引入<code>Screen.h</code>文件。注意在函数Clear的实现中，访问了Screen中的private成员，如height和width。</p>
<blockquote>
<p>友类或友函数性质不能传递，即A将B定义为朋友，B将C定义为朋友。但C并不是A的朋友，因此不能访问A中变量。</p>
</blockquote>
<h4 id="Making-A-member-Function-a-Friend"><a href="#Making-A-member-Function-a-Friend" class="headerlink" title="Making A member Function a Friend"></a>Making A member Function a Friend</h4><p>上例中是将完整的Window_mgr定义为友类，所以类中的所有函数都可以访问Screen的私有成员，存在一定的风险性。Screen可以仅将Window_mgr中的Clear函数定义为友函数，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//In Screen.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Window_mgr.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Window_mgr::Clear</span><span class="params">(ScreenIndex)</span></span>;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//In Window_mgr.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">Screen</span>;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Window_mgr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ScreenIndex = vector&lt;Screen&gt;::size_type;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">(ScreenIndex index)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;Screen&gt; screens;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//In Window_mgr.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Window_mgr.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Screen.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Window_mgr::Clear</span><span class="params">(Window_mgr::ScreenIndex index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Screen &amp;s = screens[index];</span><br><span class="line">    s.content = <span class="built_in">string</span>(s.height * s.width, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意当设置某类中的成员函数作为另一个类的友函数时，要额外注意引用依赖问题。</p>
<p>在本例中，因为在Screen类里要访问Window_mgr中的clear函数，所以这时就必须引入（include）<code>Window_mgr.h</code>。但这就会造成<code>Screen.h</code>中<code>include &quot;Window_mgr.h&quot;</code>，<code>Window_mgr.h</code>中<code>include &quot;Screen.h&quot;</code>的相互依赖。</p>
<p>实际上在<code>Window_mgr.h</code>中根本不需要访问<code>Screen</code>类中的成员，而仅仅是将<code>Screen</code>类作为形参类型和Vector中元素类型，因此完全可以使用不完整类型，即仅仅声明Screen类，代码中写为<code>class Screen;</code>。而在<code>Window_mgr.cpp</code>中因为需要访问了<code>Screen</code>类中的成员，所以必须引入<code>Screen.h</code>。</p>
<p>总结定义和声明顺序应该为：</p>
<ol>
<li>定义<code>Window_mgr</code>类，其中只能声明<code>Clear</code>函数，不能定义<code>Clear</code>函数，否则就需要访问到<code>Screen</code>中的成员，则必须引用<code>Screen.h</code>，这里要避免引用。当需要用到<code>Screen</code>类型本身时，声明<code>Screen</code>类。</li>
<li>定义<code>Screen</code>类，其中声明<code>Window::mgr</code>为友函数。此步骤需要引入<code>Window_mgr</code>的定义。</li>
<li>定义<code>clear</code>函数，此步骤需要引入<code>Screen</code>类定义</li>
</ol>
<h4 id="Overloaded-Functions-and-Friendship"><a href="#Overloaded-Functions-and-Friendship" class="headerlink" title="Overloaded Functions and Friendship"></a>Overloaded Functions and Friendship</h4><p>在声明一个函数为友函数时，需要带上函数的返回类型和参数。因此当友函数有重载类型时，仅会将满足友函数定义的那个版本作为友函数。</p>
<h4 id="Friend-Declarations-and-Scope"><a href="#Friend-Declarations-and-Scope" class="headerlink" title="Friend Declarations and Scope"></a>Friend Declarations and Scope</h4><p>如之前所述，友类和友函数的声明，并非是该函数的真正声明。该函数未进行外部声明时，仍然是无法被其他的函数使用的，如下代码所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// X() &#123; f(); &#125; //error</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void X::g() &#123; return f(); &#125; //error</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">X::h</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">f</span>(); &#125;</span><br></pre></td></tr></table></figure>
<p>虽然代码中声明了<code>f()</code>为友函数，但构造函数和函数<code>g()</code>都是在外部声明前想访问函数<code>f()</code>，所以都会造成编译错误，而<code>h()</code>在外部声明后再进行定义，因此就能正常访问。</p>
<h2 id="Class-Scope"><a href="#Class-Scope" class="headerlink" title="Class Scope"></a>Class Scope</h2><h4 id="Scope-and-Members-Defined-outside-the-Class"><a href="#Scope-and-Members-Defined-outside-the-Class" class="headerlink" title="Scope and Members Defined outside the Class"></a>Scope and Members Defined outside the Class</h4><p>类的定义本身就是一个作用域，因此在类外定义成员函数时需要加上<code>::</code>操作符。</p>
<p>当成员函数的名字出现后，它的参数列表和定义主体就是在作用域里面的了。因此在参数列表和定义主体中访问类中成员时不需要加上<code>::</code>操作符。但是返回类型是在作用域外的，所以返回类型是类中的成员类型，则需要加上<code>::</code>操作符。如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//In Window_mgr.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Window_mgr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ....</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">(ScreenIndex index)</span></span>;</span><br><span class="line">    <span class="function">ScreenIndex <span class="title">addScreen</span><span class="params">(<span class="type">const</span> Screen &amp;s)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//In Window_mgr.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Window_mgr::Clear</span><span class="params">(ScreenIndex index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Screen &amp;s = screens[index];</span><br><span class="line">    s.content = <span class="built_in">string</span>(s.height * s.width, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Window_mgr::ScreenIndex <span class="title">Window_mgr::addScreen</span><span class="params">(<span class="type">const</span> Screen &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    screens.<span class="built_in">push_back</span>(s);</span><br><span class="line">    <span class="keyword">return</span> screens.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在例子中，当<code>ScreenIndex</code>出现在了参数列表中时不需要加上<code>Window_mgr::</code>修饰作用域，但是当<code>ScreenIndex</code>作为返回类型时则必须加上。</p>
<h3 id="Name-Lookup-and-Class-Scope"><a href="#Name-Lookup-and-Class-Scope" class="headerlink" title="Name Lookup and Class Scope"></a>Name Lookup and Class Scope</h3><p>C++找寻一个名字的含义时步骤是：</p>
<ol>
<li>现在使用该名字的作用域里搜索该名字的声明，声明必须出现在使用之前</li>
<li>如果名字在当前作用域没有找到，在其嵌套的作用域中寻找（同样需要出现在使用之前）</li>
<li>如果找不到声明，则报错</li>
</ol>
<p>类编译的顺序为：</p>
<ol>
<li>先编译所有的声明</li>
<li>所有声明编译完，整个类的成员都是可见后，再编译函数主体等定义部分。</li>
</ol>
<h4 id="Name-Lookup-for-Class-Member-Declarations"><a href="#Name-Lookup-for-Class-Member-Declarations" class="headerlink" title="Name Lookup for Class Member Declarations"></a>Name Lookup for Class Member Declarations</h4><p>C++找寻名字的策略和类编译顺序共同决定了以下结果：</p>
<ol>
<li>当名字出现在返回类型或者参数列表中时，该名字必须在使用前已经声明过</li>
<li>当名字出现在成员函数主体中时，如果在使用该名字前无法在函数内部找到该名字的声明，则在类内部搜索该名字，所有的类成员变量都会被搜索，无论它的出现顺序。</li>
</ol>
<p>如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> Money;</span><br><span class="line">string bal;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Money <span class="title">balnce</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> bal; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Money bal;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，函数<code>balance</code>返回的bal是成员变量<code>Money bal</code>，而不是全局变量string，即使成员变量的声明在全局变量<code>bal</code>使用后面。</p>
<h4 id="Type-Names-Are-Special"><a href="#Type-Names-Are-Special" class="headerlink" title="Type Names Are Special"></a>Type Names Are Special</h4><p>通常而言，Type声明可以在嵌套的作用域中重新修改，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> Money;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testTypedef</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Money i;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">int</span> Money;<span class="comment">//correct</span></span><br><span class="line">    Money j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i的类型为double，j的类型为int。</p>
<p>但是在类中不允许重新定义，即使是一样的类型，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> Money;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Money <span class="title">balnce</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> bal; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// typedef double Money; //error, class not allow redefine</span></span><br><span class="line">    Money bal;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>很多的编译器仍然会允许类内进行type重定义，但这样的行为是不符合标准的，无法保证在更换了编译器后仍然能正常工作。</p>
</blockquote>
<h4 id="Normal-Block-Scope-Name-Lookup-inside-Member-Definitions"><a href="#Normal-Block-Scope-Name-Lookup-inside-Member-Definitions" class="headerlink" title="Normal Block-Scope Name Lookup inside Member Definitions"></a>Normal Block-Scope Name Lookup inside Member Definitions</h4><h4 id="After-Class-Scope-Look-in-the-Surrounding-Scope"><a href="#After-Class-Scope-Look-in-the-Surrounding-Scope" class="headerlink" title="After Class Scope, Look in the Surrounding Scope"></a>After Class Scope, Look in the Surrounding Scope</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//In Screen.cpp</span></span><br><span class="line"><span class="type">int</span> height = <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Screen::dummyFcn</span><span class="params">(pos height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;height is &quot;</span> &lt;&lt; height &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Screen height is &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;height &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Global height is &quot;</span> &lt;&lt; ::height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//In Chapter7_Classes.cpp</span></span><br><span class="line"><span class="function">Screen <span class="title">s</span><span class="params">(<span class="number">10</span>, <span class="number">2</span>, <span class="string">&#x27; &#x27;</span>)</span></span>;</span><br><span class="line">s.<span class="built_in">dummyFcn</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">height is 3</span></span><br><span class="line"><span class="comment">Screen height is 10</span></span><br><span class="line"><span class="comment">Global height is 5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="Constructors-Revisited"><a href="#Constructors-Revisited" class="headerlink" title="Constructors Revisited"></a>Constructors Revisited</h2><h3 id="Constructor-Initializer-List-1"><a href="#Constructor-Initializer-List-1" class="headerlink" title="Constructor Initializer List"></a>Constructor Initializer List</h3><h4 id="Constructor-Initializers-Are-Sometimes-Required"><a href="#Constructor-Initializers-Are-Sometimes-Required" class="headerlink" title="Constructor Initializers Are Sometimes Required"></a>Constructor Initializers Are Sometimes Required</h4><p>const成员变量必须通过初始化列表进行初始化，因为在构造函数体内部的操作实际上是赋值不是初始化，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConstRef</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">ConstRef</span>(<span class="type">int</span> ii) : <span class="built_in">ci</span>(ii), <span class="built_in">ri</span>(ii)</span><br><span class="line">    &#123;</span><br><span class="line">        i = ii;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ConstRef(int ii) //error</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     ri = i;</span></span><br><span class="line">    <span class="comment">//     ci = i;</span></span><br><span class="line">    <span class="comment">//     i = ii;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> ci;</span><br><span class="line">    <span class="type">int</span> &amp;ri;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上述代码中，<code>ci</code>和<code>ri</code>必须通过初始化列表进行初始化，而i可以出现在初始化列表中（初始化），或者在出现在构造函数体内（先被默认初始化，因为是内置类型，所以结果为未定义，再将ii赋值给它）</p>
<h4 id="Order-of-Member-Initialization"><a href="#Order-of-Member-Initialization" class="headerlink" title="Order of Member Initialization"></a>Order of Member Initialization</h4><p>成员参数的初始化顺序是由其在声明中出现的顺序决定的，和在初始化列表中的顺序无关。如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Num</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Num</span>(<span class="type">int</span> val) : <span class="built_in">j</span>(val), <span class="built_in">i</span>(j) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;i value is: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;j value is: &quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Num <span class="title">n</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">n.<span class="built_in">Print</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">i value is: 0</span></span><br><span class="line"><span class="comment">j value is: 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>在上例中，初始化列表中是先出现用<code>val</code>值初始化<code>j</code>，再通过<code>j</code>初始化<code>i</code>。但因为类的声明顺序中，是先声明了<code>i</code>再声明<code>j</code>。所以实际上的运行逻辑为，用未定义的<code>j</code>初始化了<code>i</code>，再通过<code>val</code>值初始化了<code>j</code>。</p>
<p>因此输出结果为<code>i</code>为0，<code>j</code>为2，<code>i</code>的值实际上是未定义的。</p>
<h3 id="Delegating-Constructors"><a href="#Delegating-Constructors" class="headerlink" title="Delegating Constructors"></a>Delegating Constructors</h3><p>代理构造函数时可以通过该类中的另一个构造函数来完成初始化，如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">Sales_data::Sales_data</span><span class="params">(<span class="type">const</span> string &amp;s, <span class="type">unsigned</span> n, <span class="type">double</span> p)</span> : bookNo(s), units_sold(n), revenue(p * n)</span></span><br><span class="line"><span class="function">&#123;</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Constructor with 3 parameters&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">Sales_data::Sales_data</span><span class="params">()</span> : Sales_data(<span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span><br><span class="line"><span class="function">&#123;</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Constructor with no Parameters&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">Sales_data::Sales_data</span><span class="params">(<span class="type">const</span> string &amp;s)</span> : Sales_data(s, <span class="number">0</span>, <span class="number">0</span>)</span></span><br><span class="line"><span class="function">&#123;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// inline Sales_data::Sales_data(istream &amp;is) : Sales_data(),revenue(0) &#123; read(is, *this); &#125;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">Sales_data::Sales_data</span><span class="params">(istream &amp;is)</span> : Sales_data()</span></span><br><span class="line"><span class="function">&#123;</span></span><br><span class="line">    <span class="built_in">read</span>(is, *<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，当使用了代理构造函数时，初始化列表中就不能出现其他的变量初始化了，如上述代码尝试同时使用代理构造函数和初始化revenue就失败了。</p>
<p>当一个构造函数使用另一个代理构造函数时，代理构造函数的列表初始化会先运行，然后它的函数体会执行，最后执行本构造函数的函数体，如使用语句<code>Sales_data s</code>调用无参构造函数，它会调用三个参数的代理构造函数，输入结果如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Constructor with 3 parameters</span></span><br><span class="line"><span class="comment">Constructor with no Parameters</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>可以看出，三个参数的代理构造函数先运行了，然后运行的是无参构造函数。</p>
<h3 id="The-Role-of-the-Default-Constructor"><a href="#The-Role-of-the-Default-Constructor" class="headerlink" title="The Role of the Default Constructor"></a>The Role of the Default Constructor</h3><p>无论一个对象是被默认初始化还是值初始化（相关概念在3.3.1节中），默认构造函数都会被执行。</p>
<p>默认初始化在以下情况会发生：</p>
<ol>
<li>当在代码作用域中定义了非static的变量或者数组，且数组没有初始化列表（<code>&#123;&#125;</code>）</li>
<li>当一个类有使用合成默认构造函数的类成员。</li>
<li>当类中的成员在构造函数中并没有通过初始化列表进行初始化，这些成员会被默认初始化。</li>
</ol>
<p>值初始化在以下情况发生：</p>
<ol>
<li>定义数组时，提供了初始化列表，但是列表大小小于数组大小，剩余元素被值初始化。</li>
<li>当定义局部static变量</li>
<li>对于类类型，使用<code>T()</code>形式进行声明，所以Vector(n)，里面的元素都进行的是值初始化。</li>
</ol>
<h3 id="Using-the-Default-Constructor"><a href="#Using-the-Default-Constructor" class="headerlink" title="Using the Default Constructor"></a>Using the Default Constructor</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NoDefault</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NoDefault</span>(<span class="type">const</span> string);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    NoDefault my_mem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A a;</span></span><br><span class="line"><span class="comment">// A a = A();</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// B()&#123;&#125;; //error</span></span><br><span class="line">    <span class="built_in">B</span>() : <span class="built_in">b_member</span>(<span class="string">&quot;&quot;</span>)&#123;&#125;;</span><br><span class="line">    NoDefault b_member;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上述代码中，<code>NoDefault</code>没有默认构造函数。当<code>A</code>包含有<code>NoDefault</code>类型的成员，A的合成默认构造函数就无法使用，因为其无法调用<code>NonDefault</code>变量的默认构造函数。</p>
<p>语句<code>A a;</code>使用的是默认初始化，<code>A a=A()</code>使用的是值初始化，但两者都无法通过编译。</p>
<p>同理，在<code>B</code>中必须手动的在初始化列表中为<code>NonDefault</code>类型变量初始化，否则在尝试调用其默认构造函数时会发生错误。</p>
<h3 id="Implicit-Class-Type-Conversions"><a href="#Implicit-Class-Type-Conversions" class="headerlink" title="Implicit Class-Type Conversions"></a>Implicit Class-Type Conversions</h3><p>可以通过<strong>一个参数</strong>被调用的类构造器提供了隐式类型转换，从调用参数转换为该类型。</p>
<p>如<code>Sales_data</code>类提供了只需要一个const string引用的构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">Sales_data::Sales_data</span><span class="params">(<span class="type">const</span> string &amp;s)</span> : Sales_data(s, <span class="number">0</span>, <span class="number">0</span>)</span></span><br><span class="line"><span class="function">&#123;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此可以从const string类型隐式转换为Sales_data，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Sales_data &amp;<span class="title">Sales_data::combine</span><span class="params">(<span class="type">const</span> Sales_data &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    units_sold += rhs.units_sold;</span><br><span class="line">    revenue += rhs.revenue;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">string null_book = <span class="string">&quot;9999&quot;</span>;</span><br><span class="line">Sales_data item;</span><br><span class="line">item.<span class="built_in">combine</span>(null_book);</span><br></pre></td></tr></table></figure>
<p>上述代码中<code>null_book</code>会隐式转化成<code>Sales_data</code>对象，然后传递给<code>combine</code>函数。</p>
<p>注意这一步中，<code>null_book</code>隐式转换成的对象是一个临时变量，当combine函数执行完后就会被抛弃。</p>
<h4 id="Only-One-Class-Type-Conversions-Is-Allowed"><a href="#Only-One-Class-Type-Conversions-Is-Allowed" class="headerlink" title="Only One Class-Type Conversions Is Allowed"></a>Only One Class-Type Conversions Is Allowed</h4><p>需要注意，语句<code>item.combine(&quot;9999&quot;)</code>无法通过编译。</p>
<p>因为<code>&quot;9999&quot;</code>类型是C类型的字符串，它要先隐式转换为<code>string</code>，<code>string</code>再隐式转换为<code>Sales_data</code>，该过程包含了两次隐式转换，而C++的隐式转换仅支持一次，所以编译器无法执行。</p>
<h4 id="Suppressing-Implicit-Conversions-Defined-by-Constructors"><a href="#Suppressing-Implicit-Conversions-Defined-by-Constructors" class="headerlink" title="Suppressing Implicit Conversions Defined by Constructors"></a>Suppressing Implicit Conversions Defined by Constructors</h4><p>可以通过<code>explicit</code>关键字禁止构造函数的隐式转换，<code>explicit</code>关键字仅能出现在类内的成员函数声明中。如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Sales_data</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span>;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">string null_book = <span class="string">&quot;9999&quot;</span>;</span><br><span class="line">Sales_data item;</span><br><span class="line"><span class="comment">// item.combine(null_book);// error, when constructor isexplicit</span></span><br><span class="line">item.<span class="built_in">combine</span>(<span class="built_in">Sales_data</span>(null_book));<span class="comment">//Direct Initialization</span></span><br><span class="line">item.<span class="built_in">combine</span>(<span class="built_in">static_cast</span>&lt;Sales_data&gt;(null_book));<span class="comment">//static_cast</span></span><br></pre></td></tr></table></figure>
<p>在上述代码中可以看到，Sales_data构造函数被定义为了explicit，隐式转换不再能执行，但仍然可以通过直接初始化和<code>static_cast</code>进行转换。</p>
<p>标准库中：</p>
<ol>
<li>string类型有通过const char*的构造函数，如<code>string(&quot;abc&quot;)</code>，该构造函数不是explicit的</li>
<li>vector类型中有通过int的构造函数，如<code>vector(2)</code>，该构造函数是explicit的</li>
</ol>
<h3 id="Aggregate-Classes"><a href="#Aggregate-Classes" class="headerlink" title="Aggregate Classes"></a>Aggregate Classes</h3><p>如果一个类满足以下条件，则它是一个聚合类（Aggregate Classes）：</p>
<ol>
<li>所有的成员变量都是public的</li>
<li>没有定义任何的构造函数</li>
<li>没有任何的类内初始值（如<code>int a = 1</code>）</li>
<li>没有基类，没有虚函数。</li>
</ol>
<p>如下就是一个聚合类：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Data</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ival;</span><br><span class="line">    string s;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于聚合类，可以通过大括号进行初始化，大括号中的参数按顺序与聚合类中定义的变量一一初始化。如果大括号中的参数数量小于聚合类中的数据数量，后面的参数进行值初始化。如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Data val1&#123;<span class="number">0</span>, <span class="string">&quot;Anna&quot;</span>&#125;;</span><br><span class="line">Data val2&#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Literal-Classes"><a href="#Literal-Classes" class="headerlink" title="Literal Classes"></a>Literal Classes</h3><p>//TODO,after read 2.4.4</p>
<h2 id="static-Class-Members"><a href="#static-Class-Members" class="headerlink" title="static Class Members"></a>static Class Members</h2><p>当给成员变量加上<code>static</code>关键字后，该变量就变成了静态成员变量，静态成员变量也受到public，private等关键字的影响。</p>
<p>静态成员可以是const的，但静态函数不允许是const的。如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account_S</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        amount += amount * interestRate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">rate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> interestRate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">rate</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string owner;</span><br><span class="line">    <span class="type">double</span> amount;</span><br><span class="line">    <span class="type">static</span> <span class="type">double</span> interestRate;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">double</span> cRate;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">InitRate</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// static double CInitRate() const; //error static member function can&#x27;t be const</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一个类的对象实际上并不包含其中的静态成员，因此静态函数也没有this指针，所以定义为函数定义为const与否并没有意义。</p>
<h4 id="Using-a-Class-static-Member"><a href="#Using-a-Class-static-Member" class="headerlink" title="Using a Class static Member"></a>Using a Class static Member</h4><p>可以通过作用域操作符，对象本身，对象引用，对象指针等来访问静态成员，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> r = Account_S::<span class="built_in">rate</span>();</span><br><span class="line">Account_S ac1;</span><br><span class="line">Account_S *ac2 = &amp;ac1;</span><br><span class="line">r = ac1.<span class="built_in">rate</span>();</span><br><span class="line">r = ac2-&gt;<span class="built_in">rate</span>();</span><br></pre></td></tr></table></figure>
<p>对于普通成员函数而言，可以直接通过访问静态成员，如<code>Account_S</code>中的方法<code>calculate</code>，其中直接访问了静态成员<code>interestRata</code>。</p>
<h4 id="Defining-static-Members"><a href="#Defining-static-Members" class="headerlink" title="Defining static Members"></a>Defining static Members</h4><p>当在类外定义静态成员函数时，不需要再次写明<code>static</code>关键字，如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Account_S::rate</span><span class="params">(<span class="type">double</span> rate)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    interestRate = rate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为静态成员变量不是类对象的一部分，因此不能使用类内初始值，也不会被构造函数初始化（但可以在构造函数函数体内赋值），如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account_S</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Account_S() : interestRate(0) //error</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Account_S</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        interestRate = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// static double interestRate = 2;//error</span></span><br><span class="line">    <span class="type">static</span> <span class="type">double</span> interestRate;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当尝试使用类内初始值时就会发生编译错误，静态成员变量的初始化过程与静态成员函数定义过程相同，如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//inside class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account_S</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">double</span> RateD;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> RateD interestRate;</span><br><span class="line">    <span class="type">static</span> <span class="type">double</span> interest;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">InitRate</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//outside class</span></span><br><span class="line">Account_S::RateD Account_S::interestRate = <span class="built_in">InitRate</span>();</span><br><span class="line"><span class="type">double</span> Account_S::interest = <span class="number">2.0</span>;</span><br></pre></td></tr></table></figure>
<p>如同在定义成员函数时一样，当成员函数的名字出现后，参数列表和函数主体就已经在作用域内部了。同理在上述定义中，当成员变量<code>interestRate</code>名字出现后，其余的部分就已经在作用域里了（变量的参数类型在名字出现前，所以不在作用域里），因此<code>InitRate</code>不需要使用作用域操作符来访问。</p>
<h4 id="In-Class-Initialization-of-static-Data-Members"><a href="#In-Class-Initialization-of-static-Data-Members" class="headerlink" title="In-Class Initialization of static Data Members"></a>In-Class Initialization of static Data Members</h4><p>//TODO，关于 costexpr</p>
<h4 id="static-Members-Can-be-Used-in-Ways-Ordinary-Members-Can’t"><a href="#static-Members-Can-be-Used-in-Ways-Ordinary-Members-Can’t" class="headerlink" title="static Members Can be Used in Ways Ordinary Members Can’t"></a>static Members Can be Used in Ways Ordinary Members Can’t</h4><ol>
<li>当一个类型是不完整类型时，无法使用该类型作为类中普通成员变量的类型，但可以作为类中静态成员变量的类型，如</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">static</span> Bar mem1;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>可以在类中使用静态成员变量作为成员函数的初始值，而普通成员变量不行，如</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account_S</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// void TestDefaultValue(double a = amount)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">// &#125;//can not use member variable as default parameters</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">TestDefaultValue</span><span class="params">(<span class="type">double</span> a = interest)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;<span class="comment">//can use member variable as default parameters</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> amount;</span><br><span class="line">    <span class="type">static</span> <span class="type">double</span> interest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note info simple"><p>引用：</p>
<ol>
<li><em>Cpp Primer</em> 5th Aug.2012</li>
</ol>
</div>
<hr>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>计算机语言</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>《C++ Primer》 序言与第一章笔记</title>
    <url>/CPPPrimer-Preface-Chapter1-Notes/</url>
    <content><![CDATA[<p>《C++ Primer》 序言与第一章笔记</p>
<p>因为之前已经对C++语言有一些了解，所以在笔记中不会事无巨细的罗列所有细节。</p>
<p><img src="CPPPrimer-Preface-Chapter1-Notes/2020-04-15-22-10-51.png" alt="第一章与序章内容"></p>
<span id="more"></span>
<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><h2 id="Why-Read-This-Book"><a href="#Why-Read-This-Book" class="headerlink" title="Why Read This Book?"></a>Why Read This Book?</h2><p>现代C++可以看作是由三个部分组成的：</p>
<ol>
<li>低Level的语言，大部分都是继承自C</li>
<li>更高级的一些语言特性，让程序员可以定义自己的数据类型</li>
<li>使用高级语言特性实现的提供一些算法和数据结构的标准库</li>
</ol>
<p>许多C++书籍的教学方式是从低Level的C语言特性开始，纯粹用C的特性来实现一些功能。在后期再用高级特性来重新实现这些功能，或直接使用标准库中的方法来代替实现。</p>
<p>这样教学的方法问题在于，首先低Level的C特性较为复杂繁琐，很多初学者在第一阶段就放弃。第二，在后期学会了高级特性后，之前所学的使用低Level实现的方法就要被替代，这一定程度上是浪费时间。</p>
<p>所以本书直接在介绍每一部分时都会尽量直接使用高级特性，不需要拘泥于C特性的一些细节。</p>
<h2 id="Structure-of-This-Book"><a href="#Structure-of-This-Book" class="headerlink" title="Structure of This Book"></a>Structure of This Book</h2><p>本书的第一部分与第二部分是关于语言的基础。</p>
<p>第三部分与第四部分是关于如何让用户实现自己的数据类型，即C++语言的特性。第三部分较为基础，第四部分会深入一些特性。</p>
<h1 id="Chapter-1-Getting-Started"><a href="#Chapter-1-Getting-Started" class="headerlink" title="Chapter 1 Getting Started"></a>Chapter 1 Getting Started</h1><h2 id="Writing-a-Simple-C-Program"><a href="#Writing-a-Simple-C-Program" class="headerlink" title="Writing a Simple C++ Program"></a>Writing a Simple C++ Program</h2><p>每个C++程序都必须有一个main函数，操作系统通过调用main函数来执行C++程序。</p>
<p>对于大部分操作系统来说，main函数返回的是状态指示器。返回0表示操作成功，非0的含义由操作系统决定，通常而言非0表示某个错误的发生。</p>
<h3 id="Compiling-And-Executing-Our-Program"><a href="#Compiling-And-Executing-Our-Program" class="headerlink" title="Compiling And Executing Our Program"></a>Compiling And Executing Our Program</h3><p>可使用Visual studio调试程序，或者使用命令行的g++来编译程序。g++编译下可使用 <code>-o</code>来指定编译后的文件名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">g++ [-o &lt;BuildFileName&gt;] &lt;sourceFileName&gt;</span><br><span class="line"></span><br><span class="line">g++ -o test test.cpp</span><br></pre></td></tr></table></figure>
<h2 id="A-First-Look-at-Input-Output"><a href="#A-First-Look-at-Input-Output" class="headerlink" title="A First Look at Input/Output"></a>A First Look at Input/Output</h2><p>C++中有提供IO功能的标准库，本书中大部分使用的是<code>iostream</code>库，其中<code>istream</code>类型表示输入，<code>ostream</code>类型表示输出。<code>stream</code>一词暗示了这些IO操作是可以连续的产生或消耗数据。</p>
<h3 id="Standard-Input-and-Output-Objects"><a href="#Standard-Input-and-Output-Objects" class="headerlink" title="Standard Input and Output Objects"></a>Standard Input and Output Objects</h3><p><code>istream</code>类型对应的实例是<code>cin</code>，<code>ostream</code>对应的实例是<code>cout</code>，它们分别是标准输入和输出。<code>iostream</code>库也定义了一些<code>cerr</code>和<code>clog</code>输出实例，分别表示标准错误信息的输出和调试信息的输出</p>
<p>默认的，系统会将这些实例与正在执行程序的窗口联系在一起，即如果是输入，则从这个窗口中读取，如果是输出，则输出到这个窗口中。</p>
<p>如果需要避免每次调试时都手动在窗口中输出信息，可以使用文件重定向（File Redirection）</p>
<p>如通过g++编译出的程序名为a.exe，可以在命令行中通过下列命令实现文件重定向</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/a.exe &lt; input.txt &gt; output.txt</span><br></pre></td></tr></table></figure>
<p>该命令的意思是将Input.txt中的文本都作为<code>cin</code>的输入数据，<code>cout</code>的输出数据都写入到output.txt中，这里的<code>&lt;</code>和<code>&gt;</code>即为文件重定向符。如其他Unix命令一样，输出时的<code>&gt;</code>表示会覆盖原文件的内容，如果想要追加内容，则通过<code>&gt;&gt;</code>操作符即可。</p>
<h3 id="A-Program-that-Uses-the-IO-Library"><a href="#A-Program-that-Uses-the-IO-Library" class="headerlink" title="A Program that Uses the IO Library"></a>A Program that Uses the IO Library</h3><p><code>#include</code>与头文件必须在同一行中，<code>#include</code>必须在函数外定义，通常而言都是将它放在文件开头的地方。</p>
<p>标准库的头文件，在调用时文件名放在<code>&lt; &gt;</code>中，不是库的头文件调用时文件名放在<code>&quot; &quot;</code>中</p>
<h3 id="Writing-to-a-Stream"><a href="#Writing-to-a-Stream" class="headerlink" title="Writing to a Stream"></a>Writing to a Stream</h3><p><code>&lt;&lt;</code>是输出操作符，操作符的返回的结果是左参数，即语句<code>cout &lt;&lt; &quot;Hellow world&quot;</code>返回的是<code>cout</code>对象。因此可以</p>
<p>使用<code>&lt;&lt;</code>操作符，如<code>cout &lt;&lt; &quot;Hellow world&quot;&lt;&lt;&quot;!&quot;</code></p>
<p><code>endl</code>是在<code>iostream</code>中定义的一个特殊的参数，它不仅可以表示一行的结束，也会刷新当前设备的缓冲（Buffer），即保证当前程序所有产生的数据都会被写入到输出流中，而不是仍然在内存中等待写入。</p>
<p>当程序员使用输出流进行调试时，建议每句后都加上<code>endl</code>。因为程序意外崩溃的话，如果没有刷新缓冲的操作将会导致调试器对于程序在何处崩溃产生错误的判断。</p>
<h3 id="Using-Names-from-the-Standard-Library"><a href="#Using-Names-from-the-Standard-Library" class="headerlink" title="Using Names from the Standard Library"></a>Using Names from the Standard Library</h3><p>所有标准库中的内容都在<code>std</code>命名空间下。</p>
<h3 id="Reading-from-a-Stream"><a href="#Reading-from-a-Stream" class="headerlink" title="Reading from a Stream"></a>Reading from a Stream</h3><p><code>&gt;&gt;</code>是输入操作符，如输出操作符一样，输出操作符的返回也是左参数，因此也可以连续使用<code>&gt;&gt;</code>操作符，如<code>cin &gt;&gt; v1 &gt;&gt; v2</code>。输入的数据会被依次读进输入操作符的右参数中。</p>
<p>数据可由空格或者换行来区分，如输入数据是<code>12 13</code>，则在上述代码中，V1的值为12，V2的值为13。</p>
<h2 id="A-Word-about-Comments"><a href="#A-Word-about-Comments" class="headerlink" title="A Word about Comments"></a>A Word about Comments</h2><p>编译器会无视注释。</p>
<p>错误的注释不如没有注释，所以在修改代码后要及时的修改注释。</p>
<h3 id="Kinds-of-Comments-in-C"><a href="#Kinds-of-Comments-in-C" class="headerlink" title="Kinds of Comments in C++"></a>Kinds of Comments in C++</h3><p>C++支持两种注释方式，单行注释（Single-line）和多行注释（Paired）。</p>
<p>单行注释以<code>//</code>开始，以换行结束</p>
<p>多行注释以<code>/*</code>开始，以<code>/*</code>结束。当使用多行注释时，建议每一行前都加上一个*号，这样可以快速的知道内容是在注释中，如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is a comment</span></span><br><span class="line"><span class="comment"> * This is also a comment</span></span><br><span class="line"><span class="comment">/*</span></span><br></pre></td></tr></table></figure>
<h3 id="Comment-Paris-Do-Not-Nest"><a href="#Comment-Paris-Do-Not-Nest" class="headerlink" title="Comment Paris Do Not Nest"></a>Comment Paris Do Not Nest</h3><p>多行注释不支持嵌套，如下面这样写，最后一行的<code>*/</code>不会被认为是注释，因为在上一行的嵌套注释中，已经出现了<code>*/</code>,所以编辑器会认为注释在上一行已经结束。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is a comment</span></span><br><span class="line"><span class="comment"> * This is also a comment</span></span><br><span class="line"><span class="comment"> * /* Want to nest */</span></span><br><span class="line"><span class="comment">/*</span></span><br></pre></td></tr></table></figure>
<p>对于代码块，即使是需要注释多行，也建议通过多次使用单行注释来实现。因为很可能出现想要注释一大段代码时，其中的一部分已经被注释过了，那么如果都使用多行注释的话，就会出现嵌套。</p>
<h2 id="Flow-of-Control"><a href="#Flow-of-Control" class="headerlink" title="Flow of Control"></a>Flow of Control</h2><h3 id="The-while-Statement"><a href="#The-while-Statement" class="headerlink" title="The while Statement"></a>The while Statement</h3><p>与C类似</p>
<h3 id="The-for-Statement"><a href="#The-for-Statement" class="headerlink" title="The for Statement"></a>The for Statement</h3><p>与C类似</p>
<h3 id="Reading-an-Unknown-Number-of-Inputs"><a href="#Reading-an-Unknown-Number-of-Inputs" class="headerlink" title="Reading an Unknown Number of Inputs"></a>Reading an Unknown Number of Inputs</h3><p>如有代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(std::cin &gt;&gt; value)</span><br><span class="line">    sum += value;</span><br></pre></td></tr></table></figure>
<p>当使用istream作为循环的判断条件时，如果stream是合法的，则循环将继续，否则循环结束。在istream中，如果遇到了<code>end-of-file</code>（不同操作系统定义不同）或者非法输入（将字符串赋值给int变量）则认为stream是非法的。</p>
<p>在Windows系统下，通过ctrl+z键入<code>end-of-file</code>，在Unix系统中，通常是通过control+d。</p>
<p>在C++程序中通常会遇到以下的语法错误：</p>
<ol>
<li><p>Syntax errors: 由操作符方面的错误造成，如少了操作符，没有写;符号等。</p>
</li>
<li><p>Type errors: 赋值过程不符合值的类型定义</p>
</li>
<li><p>Declaration errors: 使用变量前未定义该变量</p>
</li>
</ol>
<p>最好是按报错误的顺序来修复错误，因为一个错误的发生可能会导致一系列错误的发生，在很多情况下修复了一个错误，后续的一系列错误将自动消失。</p>
<h3 id="The-if-Statement"><a href="#The-if-Statement" class="headerlink" title="The if Statement"></a>The if Statement</h3><p>与C类似。</p>
<p>在c++中，<code>=</code>和<code>==</code>操作符都可以作为判断条件，所以编程时需要注意，不要误输入错误的操作符。</p>
<p>c++基本上是<code>free-format</code>语言，即语言编译过程并不会在意大括号，缩进，注释，换行这些信息的位置。</p>
<h2 id="Introducing-Classes"><a href="#Introducing-Classes" class="headerlink" title="Introducing Classes"></a>Introducing Classes</h2><p>一个类定义一系列与这个类型相关的操作。</p>
<p>通常类的定义放在<code>.h</code>文件中，文件的名字与其中的类名字相同。也有程序员会使用<code>.H</code>，<code>.hpp</code>，<code>.hxx</code>来表示头文件，编译器通常不会在意文件后缀名，但是IDE有时会。</p>
<div class="note info simple"><p>引用：</p>
<ol>
<li><em>Cpp Primer</em> 5th Aug.2012</li>
</ol>
</div>
<hr>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>计算机语言</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>《Experts at Play：Understanding Skilled Expertise》 笔记</title>
    <url>/ExpertsAtPlay-Understanding-Skilled-Expertise-Notes/</url>
    <content><![CDATA[<p>《Experts at Play：Understanding Skilled Expertise》论文笔记</p>
<p>这篇文章，作者主要是分析CS中是哪些因素让一个玩家可以称为专家。</p>
<p>这些因素包括，对于地形的理解，与队友的合作，对方位的感知等等。</p>
<span id="more"></span>
<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>目前大部分的对于游戏设计研究的论文是针对那些有宏大背景的游戏，如魔兽世界，星球大战系列等，而对于FPS的研究不多。其次对于游戏是如何被玩的研究不多，即玩家的游戏技能。</p>
<p>作者在这里探讨的主要是是什么让玩家能与别人玩家一起去玩好一个游戏。</p>
<p>分析会通过以下几个关键概念：</p>
<ol>
<li>玩家如何实现游戏中的移动</li>
<li>玩家是如何学习和参与进游戏的场景中的</li>
<li>网络游戏的合作和冲突是如何支持并提升玩家的技能的。</li>
</ol>
<h2 id="Studing-experts"><a href="#Studing-experts" class="headerlink" title="Studing experts"></a>Studing experts</h2><p>作者首先给出了技能的定义：技能是用来描述可认知的操作，记忆理论，信息处理和心理结构的。</p>
<p>现在大量的关于游戏操作的测试，都是基于操作的速度，年纪与反应速度的关系，准确性等等，但很少有去分析再特定情况下的技能运用，</p>
<p>这篇文章的目的就是以游戏<em>反恐精英（CS）</em>作为例子，研究在<strong>真实情况下</strong>的对技能的应用和队友合作等。</p>
<h2 id="Counter-Strike"><a href="#Counter-Strike" class="headerlink" title="Counter-Strike"></a>Counter-Strike</h2><p>这一部分是描述介绍反恐精英游戏戏。</p>
<h2 id="Examining-skill：a-drop-into-the-action"><a href="#Examining-skill：a-drop-into-the-action" class="headerlink" title="Examining skill：a drop into the action"></a>Examining skill：a drop into the action</h2><p>这一部分作者去观察一个“专业”的玩家，每周有数十小时的游戏经验，他通过观察玩家两个游戏片段总结出专业玩家的技能。</p>
<p>在文中作者详细描写了这两个游戏片段，但这里就不再赘述这两个片段的细节，直接总结作者从片段中得出的结论。</p>
<h3 id="Moving-competently"><a href="#Moving-competently" class="headerlink" title="Moving competently"></a>Moving competently</h3><p>在地图中的移动是鼠标和键盘的混合操作，用鼠标控制角度，用键盘控制移动。虽然熟悉游戏的人会觉得这操作很简单，但对于刚接触游戏的人来说这是个需要一段时间学习的技能。</p>
<p>玩家在移动的同时，还需要做大量其他的工作，如快速的扫视别的方向，蹲下、跳跃等，这也说明了玩家在移动的还需要保有对地形的理解。</p>
<p>即使是对于熟悉游戏的人而言，更专业的玩家可以更快，更流畅的完成上述的一系列操作。如何比别的玩家更快，更精准的完成这些也是一个挑战。</p>
<p>另外对于通过这一系列的流畅的操作来获得胜利，或者在其他玩家前展示这些操作，对玩家而言也是一种愉悦的体验。</p>
<h3 id="Collaboration"><a href="#Collaboration" class="headerlink" title="Collaboration"></a>Collaboration</h3><p>队友间会相互合作，如组成一个攻击队列，前方的队友危险但有更好的视野，后面的人相对安全，但也视野受限。</p>
<p>在游戏合作中，对于获取队友的位置，不仅仅是通过视线，也会通过脚步，射击的火光或者预制的语音信息等。</p>
<p>对手也可以反利用玩家对于队友位置的预判来进行攻击，如故意绕路，从通常是队友才会出现的地方进行攻击（如玩家的背后）。</p>
<h3 id="Terrain"><a href="#Terrain" class="headerlink" title="Terrain"></a>Terrain</h3><p>为了理解游戏中的地形，首先要理解游戏中的地图概念。对于CS而言，地图的数量是有限的，一个熟练的游戏玩家通过大量的游戏时间会对这些地图非常的熟悉。玩家过去的游戏经验会提供给他们判断的依据，如根据子弹的方向判断敌人的方位。</p>
<p>正是因为单一的游戏地图是不变的，才给玩家通过大量的游戏体验来熟悉地图的可能。作者在总结阶段，也将地形称为临时交互环境（Interactive temporal environment），即其中的可能性会在事件的运行过程中不断的变化。</p>
<p>而且地形的关键不仅仅子在于知道地图的某一个地方有什么，还要知道在不同的情况下，同一个位置有没有不同的意义（进攻时的掩护处，防守时的阻挡点等等）。</p>
<h3 id="Presence-and-awareness"><a href="#Presence-and-awareness" class="headerlink" title="Presence and awareness"></a>Presence and awareness</h3><p>玩家在行动的时候都要注意自己的方位是否会被别人注意到，无论是敌人还是队友。</p>
<p>队友对于自己而言可以作为一个侦察兵的存在，可以根据队友的状态判断出敌人的位置，甚至队友死亡时的身体朝向也能用来判断敌人信息。</p>
<p>同时要尽量减少自己出现在敌人视野内的时间，并猜测敌人出现的位置，如狙击时的卡地形的同时不停移动（减少出现在视野内的时间）和始终标准固定高度（猜测敌人的头出现的位置）</p>
<h3 id="The-right-tool-for-the-job"><a href="#The-right-tool-for-the-job" class="headerlink" title="The right tool for the job"></a>The right tool for the job</h3><p>在游戏中选择不同的武器针对不同的情况。</p>
<p>如狙击枪的设计距离远，攻击力高，但换子弹时间慢，以及使用狙击枪时移动速度慢。</p>
<p>优秀的玩家会根据当前的情况，去做出武器之间的权衡，并找到适合这个武器的地形。</p>
<h3 id="Round-strategies-and-flashpoints"><a href="#Round-strategies-and-flashpoints" class="headerlink" title="Round strategies and flashpoints"></a>Round strategies and flashpoints</h3><p>因为CS一定程度上是回合制游戏（警察和警匪有多轮对决），玩家可以在每一轮中根据之前轮的情况来调整战术，如在某局中使用某战术非常成功，下一轮就可以继续使用该战术等等。</p>
<p>同时玩家也可以通过大量的游戏经验，来贯彻一个战术，并使其越来越完善。</p>
<p>并且玩家的战术也会受同伴的影响，如在开局时看到队友的走向，判断队友想使用的战术，并以此来调整自己的战术。</p>
<p>闪电（flashpoint）就是这种在实时的情况下，根据情况和玩家的变换做出策略转换的时刻。</p>
<h2 id="Conclusion-Understanding-expertise"><a href="#Conclusion-Understanding-expertise" class="headerlink" title="Conclusion Understanding expertise"></a>Conclusion Understanding expertise</h2><p>对于游戏的分析不仅仅应该将游戏的动作分割开来，如去研究玩家按下跳跃键的速度，玩家的反应速度，而应该将玩家的一系列动作联系起来看，如同研究其他的人类行为意义，去研究玩家在游戏中的行为意义。</p>
<p>FPS与其他游戏不同的是，在FPS中玩家的行为反馈会非常的快，如果做了一个错误的行为，可能下一秒就会因此输掉游戏。</p>
<div class="note info simple"><p>引用：</p>
<ol>
<li>Reeves, S., Brown, B., &amp; Laurier, E. (2009). Experts at Play: Understanding Skilled Expertise. Games and Culture, 4(3), 205–227. <a href="https://doi.org/10.1177/1555412009339730">https://doi.org/10.1177/1555412009339730</a></li>
</ol>
</div>
<hr>
]]></content>
      <categories>
        <category>论文笔记</category>
      </categories>
      <tags>
        <tag>论文笔记</tag>
        <tag>游戏设计</tag>
      </tags>
  </entry>
  <entry>
    <title>《Formal ABstract Design Tools》 笔记</title>
    <url>/FormalAbstractDesignTools-Notes/</url>
    <content><![CDATA[<p>该文是作者Doug Church在1999年发布在GAMASUTRA上的文章。</p>
<p>作者认为当前阻碍游戏设计发展的是没有足够的词汇去描述游戏中的设计。</p>
<p>因此他提出了<code>Formal Abstract Design Tool</code>框架，作为一个词汇工具集。</p>
<p>在文章中作者着重讨论了<code>目的</code>，<code>可预测结果</code>和<code>故事</code>三个工具。</p>
<span id="more"></span>
<h1 id="Formal-Abstract-Design-Tools"><a href="#Formal-Abstract-Design-Tools" class="headerlink" title="Formal Abstract Design Tools"></a>Formal Abstract Design Tools</h1><p>游戏在科技方面的发展很迅速，但是在设计方面的发展却不尽如人意。</p>
<p>游戏设计是关于玩家的目标和节奏，是游戏设计让游戏成为了游戏。否则游戏光盘中装的只是数据而没有关于游戏的体验。</p>
<h2 id="How-Do-We-Talk-About-Games"><a href="#How-Do-We-Talk-About-Games" class="headerlink" title="How Do We Talk About Games"></a>How Do We Talk About Games</h2><p>游戏设计最大的障碍在于，缺少一个通用的设计词汇。</p>
<p>对于技术而言，又非常多的专业词汇来描述技术问题，但是对于游戏设计，往往讨论就只停留在有趣和不有趣。</p>
<hr>
<h2 id="A-Language-Without-Boarders"><a href="#A-Language-Without-Boarders" class="headerlink" title="A Language Without Boarders"></a>A Language Without Boarders</h2><p>目前游戏设计中的设计词汇大多限定在特定的游戏分类中，如可以去谈论RTS游戏中，每个单位该如何平衡。但是很少有去谈论如何汲取RTS游戏的优点，然后运用在RPGs游戏中的。</p>
<p>因此作者提出了”Formal Abstract Design Tools”（后简称FADT）这一概念，他实际上是一个针对于游戏专业词汇的框架。</p>
<p><code>Formal</code>表示它是一个精确的，形式化（即可以运用到别的种类游戏上）的描述。如“有趣的东西”就不是一个Formal的描述，它不够精确，这一个并不精确的描述也无法运用在其他游戏上，而“玩家奖励”就是一个Formal的描述。</p>
<p><code>Abstract</code>表示它是一个抽象的描述。如“+2攻击力的巨人之剑”就不是一个抽象描述，对应的是抽象描述是“玩家能力提升曲线”。</p>
<h2 id="Let’s-Create-a-Design-Vocabulary——What-Could-Possibly-Go-Wrong？"><a href="#Let’s-Create-a-Design-Vocabulary——What-Could-Possibly-Go-Wrong？" class="headerlink" title="Let’s Create a Design Vocabulary——What Could Possibly Go Wrong？"></a>Let’s Create a Design Vocabulary——What Could Possibly Go Wrong？</h2><p>要注意FADT本质上还是只是工具，作为设计师，还是需要判断出什么是有趣的，游戏是关于什么的，你想展现给玩家的是什么，这才是构建出游戏的关键。这就如同房子不是由工具建成的，房子是由砖瓦构建而成的，工具之hi是帮助作用。</p>
<p>FADT只是一个工具，一个关于词汇的工具。设计师们只是用他来挑选出游戏中值得注意且能运用到自己游戏中的部分，并用合理的词汇将其描述出来。如上述的“玩家能力提升曲线”就是工具箱中的一个工具，一个FADT，设计师可以考虑将其运用到自己的游戏中，或不运用。</p>
<h2 id="Tools-Would-Be-Useful——Where-Do-We-Find-Them"><a href="#Tools-Would-Be-Useful——Where-Do-We-Find-Them" class="headerlink" title="Tools Would Be Useful——Where Do We Find Them?"></a>Tools Would Be Useful——Where Do We Find Them?</h2><p>使用FADT最好的例子就是找一个优秀的游戏，从中抽离出一些概念并将其抽象化和形式化，让他可以运用到别的种类的游戏上。</p>
<hr>
<h2 id="Mario-64-Game-Play"><a href="#Mario-64-Game-Play" class="headerlink" title="Mario 64 Game Play"></a>Mario 64 Game Play</h2><blockquote>
<p>这一节是作者对于《超级马里奥64》的描述</p>
</blockquote>
<p>在《超级马里奥64》中，玩家始终有很多事去做，但他们同时被给予了大量的选择（要去探索世界的哪一块，要去拿哪个额外的星星）。因此在游戏中，玩家花了大量的时间去决定“接下来要去做什么”，而不是去“找”要做什么。</p>
<p>这个游戏还有个重要特征是，在每个世界中，玩家会同时有多个目标。通常在进入每个世界后的第一个星星，是会鼓励玩家探索世界中的绝大部分区域。</p>
<p>马里奥的游戏世界是统一且可预测的。玩家能做的基本操作很少，很简单（移动，跳跃和一些简单交互）。但是这些简单的操作可以做出非常多的交互（跳跃踩怪兽等）。更重要的是所有的结果是恒定的，如三段跳的高度是固定的，跳到怪兽头顶上，怪兽就会死。一些额外能力的引入也是缓慢但同时恒定的，如钢铁马里奥一定能在水下走。</p>
<p>这些简单，恒定操作构建出了一个可预测的的物理世界，玩家在尝试些新鲜事物前通常可以准确的猜出会发生什么。怪物和游戏环境会增加游戏的复杂度，但他们也是缓慢的被引入，而且是在已有的交互原则上。这些都会让游戏内发生的情况是可预测的，当玩家遇到高强，新的怪物，新的地形，他们都能开始如何用已有的技能去解决，并且基本能猜出结果。</p>
<p>这些也会让玩家在游戏过程中有一个复杂的游戏计划过程（sophisticated planning process）。他们被潜移默化的告知了游戏中的规律，而且也直到他们的目标是什么。因此他们通常在潜意识中就已经构建了接下来要去做什么的计划。在游戏中，玩家在没有意识到情况下就已经做出了几千个要去做什么的计划。</p>
<p>更重要的是，玩家在做出计划并得到结果后，他能理解为什么成功或失败。如果必要的话，他们可以基于前一次尝试得到的经验去做进一步的计划。</p>
<p>玩家在游戏中很少有被欺骗感（觉得游戏是假的），他们很少有想要尝试某些东西，但是游戏不支持的情况。虽然马里奥的世界中支持的行为不多，但是它们都被实现的非常完整。这个世界是简单的，但却是统一的，如果它提供给了你一些东西，那么它们就是能被使用的。因此不会有玩家做出“为什么没法在游戏中生火做饭”之类的抱怨（游戏中根本就没有火这个素材，玩家在游戏体验中不会意识到）。</p>
<hr>
<h2 id="Great-But-I’m-not-Writing-Mario-64-I-Mean-It’s-Already-Been-Written"><a href="#Great-But-I’m-not-Writing-Mario-64-I-Mean-It’s-Already-Been-Written" class="headerlink" title="Great! But I’m not Writing Mario 64. I Mean, It’s Already Been Written"></a>Great! But I’m not Writing Mario 64. I Mean, It’s Already Been Written</h2><blockquote>
<p>作者在上一节中描述了《超级马里奥64》游戏，在这一节中他会对其进行分析。即抽取出FADT</p>
</blockquote>
<p>首先，可以看到玩家在游戏中是被鼓励构建出自己的目标并且对它们做出行为的。关键点在于玩家知道在游戏世界中可以发生什么，因此他们对于发生的情况是有掌控感的。目标和控制是可以从不同的层面去实现的，从“小而快速”的目标“穿过面前的桥”到“复杂而长期的”目标“获得额外的红色星星”。</p>
<p>这个“收集目标，理解世界，做出决策，行动”的过程，是很能帮助玩家融入游戏世界的。作者在这里将这个过程形式化并抽象称为<code>目的（Intention）</code>，如之前所述，目的可以是不同层面的，从小而快速到复杂而长期。这是作者给出的第一个FDAT，定义如下：</p>
<p><code>目的</code>：玩家根据当前游戏世界的情况和已知的可选行为，做出一个可行的计划</p>
<p>马里奥世界的简单而统一，让玩家觉得他们对于自己的行为是负责的，即当一个错误情况发生时，他们也能知道其发生的原因。作者将其称为<code>可预料结果（Perceivable Consequence）</code>，这是第二个FDAT，定义如下：</p>
<p><code>可预料结果</code>：游戏世界可以对玩家的行为做出清晰的反馈。</p>
<hr>
<h2 id="Same-Tools，Different-Games"><a href="#Same-Tools，Different-Games" class="headerlink" title="Same Tools，Different Games"></a>Same Tools，Different Games</h2><blockquote>
<p>这一节作者讨论上述两个FDAT如何用在别的游戏中，如RPGs</p>
</blockquote>
<p>在RPGs中，当一个事件发生时，背后的逻辑就是“因为X，所以Y发生了”，这无疑是可预料结果的一种应用。</p>
<p>但是RPGs游戏中对于结果的展示并不如马里奥那样直接。如玩家选择在一个旅店住宿，设计师们为了避免玩家一直待在旅店中，会让某些早上玩家出旅店后遇到盗贼。对于设计师而言，玩家遇见盗贼是一个可预料的结果，但是对于玩家而言，却是一个随机事件。</p>
<p>同样的，还有些结果是玩家“认为”可预料的，但是却有不同的结果。如玩家在交叉路口选择走的方向，然后走上了一条路，但意外的遇到了盗贼。这确实是对玩家行为的结果，但并不是玩家所预想的结果，玩家选择某条路通常是认为这条路会有好处，但结果却是坏的。这种情况类似于“做X其实会导致Z，但是你并不知道”。</p>
<p>在RPG中最好的方法就是让<code>可预料结果</code>和<code>目的</code>结合在一起。如上述交叉路口选方向的例子，结果的确不是如玩家所想的一样，但是这是玩家玩家自己做出的选择，即玩家在他的<code>目的</code>中采取的行为，这同样给玩家提供了可控感。相反，如果这个结果是设计师提供的，即“你必须走这条路，然后收到盗贼的攻击”，对于玩家而言可能就是一个恼怒的事了，而且对于游戏的参与感也会明显降低。</p>
<h2 id="Same-Game，Different-Tool"><a href="#Same-Game，Different-Tool" class="headerlink" title="Same Game，Different Tool"></a>Same Game，Different Tool</h2><p>在RPGs中可能有时候会强迫玩家进入某种情况，即是这样做会让玩家失去对游戏的控制感。通常会发生这种情况，是因为设计师需要控制游戏剧情的走向。<code>故事（Story）</code>表示在游戏过程中的叙事线索。</p>
<p>这个线索可能是设计师驱动的，即设计师有一个预先存在剧本。</p>
<p>同样线索也可能是玩家驱动的，如马里奥中，玩家在游戏中的行为构成了故事，故事从游玩开始，到游玩结束。像<em>NBA live</em>这种偏竞技的游戏中，更为如此。其中还有如赛季模式等东西，一定程度上加深了玩家对于故事的把控能力。</p>
<p>故事是第三个FADT，定义如下：</p>
<p><code>故事</code>：一个将游戏中的事件结合在一起，并推动游戏进程的叙事线索，该线索可以是设计师驱动的，也可以是玩家驱动的。</p>
<hr>
<h2 id="Using-Multiple-Tools-Cooperation-Conflict-Confusion"><a href="#Using-Multiple-Tools-Cooperation-Conflict-Confusion" class="headerlink" title="Using Multiple Tools:Cooperation,Conflict,Confusion"></a>Using Multiple Tools:Cooperation,Conflict,Confusion</h2><blockquote>
<p>这一节作者谈论了多个工具之间可能造成的冲突和取舍。</p>
</blockquote>
<p>冒险游戏通常有比较少的<code>可预测结果</code>和<code>目的</code>。玩家做的是去各个地方，捡取各种东西，和人交流来找寻“设计师的目的”。在较低的层面上，玩家会有“我去拿这个东西，我认为这个东西对我有用”和足够的关于“果然有用”然后让剧情推进的反馈。但这其中不是玩家设立目标和表达欲望的过程，这行为本质上是测试设计师提供的几个选项，玩家必须找出其中工作的一个选项，否则剧情无法推进。</p>
<p>相交而言，马里奥世界中的一些行为则是纯粹的玩家目的，如“收集额外的星星”，玩家不去进行也完全不影响游戏进度。</p>
<p>而冒险游戏之所以做出较少的<code>可预测结果</code>和<code>目的</code>，是为了获得更多的<code>故事</code>。在这些游戏中，会有设计师所设计的那些激动人心的关键时刻，一些重要剧情，设计师们想要用这些来吸引玩家。</p>
<p>所以这就是<code>目的</code>和<code>故事</code>之间的冲突，当设计师越想要创建特定的<code>故事</code>，让玩家自定义<code>目的</code>的可能性就越小。</p>
<h2 id="Concrete-Cases-of-Multiple-Tool-Use"><a href="#Concrete-Cases-of-Multiple-Tool-Use" class="headerlink" title="Concrete Cases of Multiple Tool Use"></a>Concrete Cases of Multiple Tool Use</h2><blockquote>
<p>这一节作者给出了<code>故事</code>和<code>目的</code>冲突的具体例子</p>
</blockquote>
<p>例如游戏<em>最终幻想</em>中，故事的主线是由设计师决定的，在这一部分玩家并不能进行太多的计划和实现自己的目的。但是游戏中的角色和战斗策略却是完全自由的，玩家完全可以通过自己的策略，用的东西，combo来实现完全的控制。另外这探索故事的时候，探索的节奏也是玩家自我掌控的。</p>
<p>概括来说，虽然故事情节是固定的，但是其中的其他细节是玩家可控的。例如情节会强迫你与过去的盟友发生战斗，但是战斗的方式策略则是完全自定义的。</p>
<p>即在最终幻想的战斗系统中，设计师使用了<code>目的</code>和<code>结果</code>两个工具，而在情节框架中使用了<code>故事</code>和<code>结果</code>，设计师并没有盲目的尝试一下子将所有的工具都放在一起。</p>
<p>而所有的战斗和体育游戏，不太严谨地说，都是将三个元素合在了一起，但是稍微有些区别。</p>
<p>战斗和体育游戏的故事是完全交由玩家控制的。玩家的选择会导致游戏走向一个玩家自己决定的结局（大比分胜利，小比分胜利等等）。</p>
<p>两个游戏也都能看到自己行为的固定结果。当玩家学会操作后，他就会因为游戏给他的反馈（可预测的结果）做出自己的计划（目的）。</p>
<p>但两者略微不同的在于，在战斗游戏中，所有的结果都是直接的。因此当看到一个玩家比自己打的好的时候，你能明显的感受到他更优秀的原因。而在体育游戏中，还有一个数值层面（Statistical Layer），即概率或角色的能力，玩家相同的操作并不一定导致相同的结果。因此在体育游戏中，虽然玩家同样有计划，但是结果并不像战斗游戏那样的直接和可预测。</p>
<hr>
<h2 id="Tool-Based-Analysis"><a href="#Tool-Based-Analysis" class="headerlink" title="Tool-Based Analysis"></a>Tool-Based Analysis</h2><p>上述的战斗游戏，他提供了一个简单的故事，故事是由玩家完全掌握的。对于体育游戏而言，他同样有目的和结果，但不像战斗游戏那样直接和可预测。因此，战斗游戏对玩家而言产生了一个更真实的故事，但是体育游戏却提供了一个更有传奇性的故事，毕竟故事中是需要不确定因素的。很难说这两者谁更好。</p>
<h2 id="Ahhh，So-What？"><a href="#Ahhh，So-What？" class="headerlink" title="Ahhh，So What？"></a>Ahhh，So What？</h2><p>FADT是一个帮助分析的词汇工具，他帮助游戏设计师们专注于要提供玩家怎么样的体验（更精确，抽象的表达）。</p>
<p>游戏与书，电影或其他媒体不同的是，那些媒体是通过技术让观众们感受到作者想要他们感受的情感，让观众做出作者们想要他们做出的反应。而游戏一定程度上是要玩家沉浸在游戏中，做出<br>自己的决定，这一定程度上是让玩家探索自己，这也就是游戏媒体的独特性。</p>
<p>因此作者用FADT作为自己理解游戏设计每一个部分的工具，用它来最大化玩家对于游戏和自己的沉浸感。</p>
<p>作者在这篇文章中提到了<code>目的</code>,<code>可预测结果</code>,<code>故事</code>三个工具，而整个工具集应该有许许多多的其他工具，如<code>资源经济</code>，<code>玩家学习</code>、<code>玩家能力曲线</code>、<code>奖惩关系</code>等等。每一个主题都能专门写一篇文章来从特定角度对游戏进行分析。</p>
<div class="note info simple"><p>引用：</p>
<ol>
<li><a href="https://www.gamasutra.com/view/feature/3357/formal_abstract_design_tools.php?print=1">Formal Abstract Design Tool</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/26853170">怎样去设计一款优秀的现代电子游戏？</a></li>
</ol>
</div>
<hr>
]]></content>
      <categories>
        <category>博文笔记</category>
      </categories>
      <tags>
        <tag>游戏设计</tag>
        <tag>博文笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>《Game Design Workshop》 第三章笔记</title>
    <url>/GameDesignWorkshop-Chapter3-Notes/</url>
    <content><![CDATA[<p>《Game Design Workshop》 第三章笔记，这一章关于游戏中的常规元素。</p>
<p>包括，玩家、目标、流程、规则、资源、冲突、边界、结果。</p>
<span id="more"></span>
<h1 id="Chapter-3-Working-with-Formal-Elements"><a href="#Chapter-3-Working-with-Formal-Elements" class="headerlink" title="Chapter 3 Working with Formal Elements"></a>Chapter 3 Working with Formal Elements</h1><p>常规元素（Formal Elements）是那些组成游戏的元素，包含玩家，目标，流程，规则，自愿，冲突，边界和结果，这些构成了游戏的本质。</p>
<p>当充分了解这些元素后，就可以对他们进行结合来创造自己的新类型游戏。</p>
<h2 id="Players"><a href="#Players" class="headerlink" title="Players"></a>Players</h2><p>游戏是为玩家的游戏体验而设计的，玩家必须遵守游戏的规则和限定才能玩游戏。</p>
<p>以下是一些游戏中针对玩家设计可以考虑的方面。</p>
<h3 id="Invitation-to-Play"><a href="#Invitation-to-Play" class="headerlink" title="Invitation to Play"></a>Invitation to Play</h3><p>游戏中最重要的时刻之一就是游戏的<code>邀请阶段</code>。对于桌游而说，游戏的邀请是社交部分。对于电子游戏而言，邀请阶段通常只是简单的开始按钮，但是有一些游戏它们有独特的邀请方式，如吉他英雄（Guitar Hero）通过拨弄吉他开始游戏。设计一个游戏的邀请阶段能让一款游戏更加的引人注目。</p>
<h3 id="Number-of-Players"><a href="#Number-of-Players" class="headerlink" title="Number of Players"></a>Number of Players</h3><p>对于玩家人数是固定的游戏和对于玩家人数是变换的游戏，两者设计的思路是不同的。许多电子游戏仅支持一个游戏玩家，这种游戏的结构是让玩家与游戏系统竞争。也有许多游戏设计为多位玩家，如大富翁（Monopoly），EVE，WOW，但是这些游戏在一定程度上也是能支持一个玩家游玩的。如魔兽世界，即使一个人玩，游戏中的许多元素也让游戏体验足够有趣。</p>
<h3 id="Roles-of-Players"><a href="#Roles-of-Players" class="headerlink" title="Roles of  Players"></a>Roles of  Players</h3><p>一些游戏其中的所有玩家都有相同的角色（这里角色指的是玩家的任务），如大富翁，围棋。</p>
<p>还有一些游戏，不同的玩家扮演着不同的角色，如珠玑妙算（Mastermind，一个密码破解游戏），一个玩家扮演密码编写者，其他的玩家扮演密码破解者。</p>
<p>游戏的角色定义了玩家的基本能力，大部分的网络游戏都提供了多种不同的角色。对于多角色的游戏，定义核心不同的橘色和平衡各角色之间的能力是关键问题。</p>
<h3 id="Player-Interaction-Patterns"><a href="#Player-Interaction-Patterns" class="headerlink" title="Player Interaction Patterns"></a>Player Interaction Patterns</h3><p>E.M.Avedon在文章<em>The Structural Elements of Games</em>中将玩家的交互分为”玩家对抗游戏”和“多个玩家之间的对抗”。这里作者将Avedon的概念进行进一步的细分，分为如下七种：</p>
<p><img src="GameDesignWorkshop-Chapter3-Notes/image-20200311115957164.png" alt="image-20200311115957164" style="zoom:50%;" /></p>
<ol>
<li><p>Single player versus game</p>
<p>这种游戏结构是玩家与游戏系统进行对抗。因为这种架构中没有其他的玩家，所以游戏的冲突通常是通过解密或者其他的方式来表现。</p>
</li>
<li><p>Multiple individual players versus game</p>
<p>这种游戏结构是多个玩家一起与游戏系统进行对抗，但是玩家之间并不一定需要交互，甚至可以不再一个时间点。这种游戏结构在Facebook这种社交网站出现后变得流行。这种游戏本质上还是单人游戏，只不过多个玩家会一起与同一个系统进行对抗，它在不希望竞争的，但又希望有社交元素的玩家中很流行，如赌场游戏（多个人会使用一台老虎机）。</p>
</li>
<li><p>Player versus Player</p>
<p>这种游戏结构是两个玩家直接进行对抗。这在策略游戏和竞争游戏中是一个经典的结构。</p>
</li>
<li><p>Unilateral competition</p>
<p>这种结构是多个玩家一起对抗一个玩家，称为单边竞争。如桌游苏格兰场（Scotland Yard），其中一个玩家是罪犯，他了解游戏的所有信息，而其他玩家扮演侦探，他们必须一起合作找出罪犯的线索。单边竞争是一个将游戏的合作性和竞争性结合在一起的结构。</p>
</li>
<li><p>Multilateral competition</p>
<p>这种结构是三个或更多的玩家直接对抗，1v1v1，称为多边对抗。如大富翁就属于这种类型，通常提及多人游戏时就是指这种结构。许多桌游设计成玩家人数需要是三到六人，这种人数是直接对抗的理想人数。</p>
</li>
<li><p>Cooperative play</p>
<p>这种结构也是对各玩家一起与游戏系统对抗，但与第二种结构不一样的是，在这个结构中玩家需要相互合作。</p>
</li>
<li><p>Team competition</p>
<p>这种结构中，两个或更多的小组相互对抗。传统的运动如足球，篮球就是这种模式。这种模式不仅对于参与者有重大的吸引力，对于旁观者也同样如此，所以传统的运动会诞生粉丝文化。</p>
</li>
</ol>
<h2 id="Objectives"><a href="#Objectives" class="headerlink" title="Objectives"></a>Objectives</h2><p>目标是玩家需要追求的东西，它定义了玩家在游戏规则下需要完成的东西。在理想状态下，目标对于玩家而言，应该是有挑战性的同样也是可完成的。</p>
<p>目标的存在不仅为游戏提供了挑战，同样也为游戏定下了基调。目标不仅仅是游戏的基本元素，它也提供了游戏的戏剧部分，理想状态下游戏的目标应该与游戏中的故事能完美融合。</p>
<p>许多学者尝试为游戏的目标进行分类，主要分为如下几种：</p>
<ol>
<li><p>Capture</p>
<p>捕捉游戏的本质是摧毁或得到对手的某些东西，同时避免被对手捉到或杀死。从古时起，这种设计思路就深深的嵌套在游戏中，比如常玩的木头人，就是这一类的游戏。</p>
</li>
<li><p>Chase</p>
<p>追逐游戏的目标是抓住对手或者从对手手上逃离。</p>
<p>追逐游戏可以是玩家与游戏系统的对抗，玩家与玩家的对抗，或者单边对抗。</p>
<p>追逐游戏可以由速度和灵活度决定。</p>
<p>苏格兰场也算是一种追逐游戏，只不过使用的是逻辑和推导来逃离玩家的追逐。</p>
</li>
<li><p>Race</p>
<p>比赛游戏的目标是在其他玩家前达到某种目标。比赛游戏可以是基于物理的灵活性（速度等），或者是基于概率。</p>
</li>
<li><p>Alignment</p>
<p>对齐游戏的目标是将游戏中的元素按一定的空间规则排列在一起或分类游戏中的元素。俄罗斯方块就是属于这种类型。</p>
</li>
<li><p>Rescue or scape</p>
</li>
</ol>
<p>逃离游戏的目标是达到一个游戏设计的安全区域。通常这个游戏目标是与其他的游戏目标结合在一起的。</p>
<ol>
<li><p>Forbidden Act</p>
<p>禁止行为游戏的目标是通过错误的移动，谈话或者任何玩家不应该做的行为来破坏游戏规则。</p>
<p>如游戏Don’t break the ice就属于这种类型：</p>
<p><img src="GameDesignWorkshop-Chapter3-Notes/maxresdefault.jpg" alt="Image result for Don't Break the ice" style="zoom:50%;" /></p>
<p>这种游戏类型在电子游戏中很少见，可能是因为没法直接的进行物理竞赛，也很难游戏的公平性。</p>
<p>但是任天堂的switch中有许多关于这种类型的游戏</p>
</li>
<li><p>Construction</p>
<p>建造游戏的目标是建造，保持和管理物体，这种游戏可能包含直接或间接的竞争。如模拟人生就是这种类型的游戏。</p>
<p>这种类型的游戏通常是将资源管理和交易来作为游戏中的重要元素，游戏也是通过策略选择而非灵活性或概率进行比赛。</p>
</li>
<li><p>Exploration</p>
<p>探索游戏的目标是探索游戏场景。这种游戏通常是与其他更复杂的目标捆绑在一起的。例如塞尔达传说，游戏的目标不仅仅是探索世界，还要解密神庙，救出公主等。</p>
</li>
<li><p>Solution</p>
<p>解密游戏的目标是在解决一个困难或谜题。许多的游戏会被归纳与其他的游戏类型，但其中包含解密部分，如上述的塞尔达传说</p>
</li>
<li><p>Outwit</p>
<p>智慧游戏的目标是通过收集和使用知识来击败别的玩家。</p>
<p>有的智慧游戏是通过游戏外的知识来进行比赛，还有一些是利用游戏内知识，如</p>
</li>
</ol>
<p>游戏的目标并不是单独存在的，一个游戏的目标很可能是上述多个种类的目标混合在一起。游戏设计者应该尝试将不同的目标结合在一起，看是否会创造出一个更加有趣的可能。</p>
<h2 id="Procedures"><a href="#Procedures" class="headerlink" title="Procedures"></a>Procedures</h2><p>流程（Procedures）是游戏的玩法，也是“玩家”为了达到目标能采取的行为。</p>
<p>对于桌游来说，游戏的流程通常是写在纸上让玩家阅读的。对于电子游戏来说，游戏的流程通过蕴含在了游戏的操作手册中（因为流程就是玩家采取的行为，操作一定程度上代表了流程）。</p>
<p>通常来说，游戏有以下几种流程：</p>
<ol>
<li>开始的行为（Starting action）：如何让游戏开始</li>
<li>逐步进行的行为（Progression of action）：在游戏开始后，持续不断的行为。通常就是游戏进行中主体（Core loop）。</li>
<li>特殊行为（Special actions）：游戏进行中的特殊事件，因为游戏中的其他元素或状态的改变而变得可执行的行为。</li>
<li>解决的行为（Resolving actions）：让游戏走向结束的行为</li>
</ol>
<p>如对于马里奥游戏，按下游戏开始键就是<code>开始行为</code>。在游戏进行中，玩家的前进，跳跃等就是<code>逐步进行的行为</code>，而诸如马里奥在水中按下前进就会游泳，吃下花朵就可以发射火球等就是<code>特殊行为</code>，马里奥并没有一个解决的行为，因为游戏是否正常结束是由游戏本身决定，而非玩家本身。</p>
<h3 id="System-Procedures"><a href="#System-Procedures" class="headerlink" title="System Procedures"></a>System Procedures</h3><p>电子游戏相对于传统游戏而言复杂了许多，电子游戏有在后台运行的系统流程（System Procedures），这个流程会对玩家的行为和游戏的情景做出相应反应。</p>
<p>传统的桌游实际上也有相同的工作，如大富翁中，需要玩家判断踩到了别人的土地后要付多少的租金，需要通过筛子来引入随机因素。只不过因为在电子游戏的这些事件可以交由系统来进行，所以这些计算可以变得更快。</p>
<p>但这不意味着电子游戏就一定比传统的游戏更加复杂，一些简单的行为可以导致异常复杂的结果。如围棋中的行为，只是双方下棋，但是其背后的逻辑可以异常复杂。</p>
<h3 id="Defining-Procedures"><a href="#Defining-Procedures" class="headerlink" title="Defining Procedures"></a>Defining Procedures</h3><p>当设计游戏的流程时，要注意游戏环境的限制。例如设计桌游时，游戏的流程就不应该过于复杂。还要考虑游戏的交互方式，是使用手柄还是键盘鼠标等。</p>
<p>要特别注意游戏的主体（core loop）。对于电子游戏，游戏的主体包括检查游戏的状态，玩家是否碰到了某些东西，同时系统也要对玩家的输入做出相应反应，而对于非电子游戏而言，玩家需要自己去检查游戏的状态。无论是电子游戏还是非电子游戏，游戏的主体都需要设计的足够流畅，玩家可以轻松的执行流程中的每一步，让游戏正确的进行下去。</p>
<p>游戏的流程本质上是被游戏的规则还有游戏本身所限制的。设计师需要意识到这些限制，然后在限制中找到一个有创造性且优雅的方式来让游戏流程顺畅且容易被记住。</p>
<h2 id="Rules"><a href="#Rules" class="headerlink" title="Rules"></a>Rules</h2><p>游戏规则定义了游戏中的物体和玩家可以执行的行为。</p>
<p>在桌游来说，游戏规则同样是写在纸上的，对于电子游戏来说，规则可以同样写在手册中，也可以通过游戏本身来透露。</p>
<p>当设计规则时，需要考虑到规则与玩家之间的关系。如果规则太多，玩家或许很难去理解游戏，如果规则太少，玩家则可能感到困惑。即使规则制定的很好，且被游戏系统完美的运行，玩家也同样需要通过某种方法了解规则，否则当某种情况发生时，玩家将觉得被系统所欺骗了（虽然系统行为是正确的）。</p>
<h3 id="Rules-Defining-Objects-and-Concepts"><a href="#Rules-Defining-Objects-and-Concepts" class="headerlink" title="Rules Defining Objects and Concepts"></a>Rules Defining Objects and Concepts</h3><p>游戏中的物体是由规则决定的，且游戏中的物体含义是与真实世界中的含义不同的，无论这些物体是完全虚构的，还是基于真实世界创建的。</p>
<p>例如象棋中的马和车，虽然是基于真实世界创建的的物体，但他们的运行规律是由游戏决定的。即使是基于真实世界创建</p>
<p>的，其含义也会与真实世界中的模板有或多或少的差异。</p>
<p>对于桌游来说，其设定的物体作为规则中的一部分，需要显式的告知玩家，通常还是通过纸质的说明书。玩家必须理解这些规则和物体，也正因为这个原因，桌游中的物体会被限定为比较简单的元素，通常只有一到两个变量或状态，而且是由物理特性来表示。如围棋中的棋子，只有两个变量，颜色和位置。</p>
<p>但是对于电子游戏而言，物体的变量可以非常复杂，因为它是由系统进行计算，玩家甚至不会意识到这么多的变量的存在。如怪物的属性，攻击位置，攻击力，魔法值等等等等。玩家也不会”精确”的知道这些变量，即使是最专业的策略游戏玩家，也不会将游戏完全的变成一场数学运算，玩家通常是通过直觉来去获知这些变量。</p>
<p>当设计游戏中的物体时，需要特变注意玩家是如何去理解这些物体的特质的。例如如果变量过于复杂，玩家是否会造成困惑，如果变量过于简单，玩家是否有能力区分物体等。</p>
<h3 id="Rules-Restricting-Actions"><a href="#Rules-Restricting-Actions" class="headerlink" title="Rules Restricting Actions"></a>Rules Restricting Actions</h3><p>规则限定了玩家的行为，这个可以从三方面考虑：</p>
<ol>
<li><p>规则弥补了游戏的漏洞。</p>
<p>如大富翁中，“进监狱时并不会因为通过起点获得200元”，避免了这个惩罚行为实际造成了奖赏。</p>
</li>
<li><p>规则可制定游戏的基本形式。</p>
<p>如“足球是两个由11人组成的队伍在360*160英尺的场地上的竞赛”，这个规则限定了每队的玩家人数是11人，游戏的边界是360*160。</p>
<p>实际上游戏的规则和流程制定了所有其他的元素</p>
</li>
<li><p>规则提供了平衡性。</p>
<p>如魔兽争霸中，“必须要三本建筑才能造某些兵种”，避免了玩家一开始就憋钱造高级兵种带来的不平衡。</p>
</li>
</ol>
<h3 id="Rules-Determining-Effects"><a href="#Rules-Determining-Effects" class="headerlink" title="Rules Determining Effects"></a>Rules Determining Effects</h3><p>规则同时在特定情况下触发某些效果，即”如果XXX发生了，那么XXX”。</p>
<p>通过规则触发效果有以下好处：</p>
<ol>
<li>它为游戏创造了变量。条件并不是在游戏中一直存在的，所以它可以给玩家带来特殊的体验和惊喜。</li>
<li>它可以让游戏重回正轨。如塞尔达中的体力值，游戏并不希望体力值作为一个非常重要的存在，如用完了体力值林克就会死，但是也不希望体力值变成一个随意挥霍的东西，游戏需要提供一个方法让玩家知道需要节省体力值。于是游戏设置了“如果体力值用完了，那么体力值的回复会变慢”这样的设定。</li>
</ol>
<h3 id="Defining-Rules"><a href="#Defining-Rules" class="headerlink" title="Defining Rules"></a>Defining Rules</h3><p>和指定流程时一样，指定规则时也要注意游戏本身的限制。对于玩家而言，规则需要是清晰的，玩家要直接通过本能就了解游戏的规则，这样游戏才能看起来是公平的，反应良好的。</p>
<p>通常来说，指定的规则越复杂，就需要花越多的努力让玩家理解规则。玩家对于规则理解的越少，他们就越不可能做出有意义的选择，也就越不觉得对于游戏有足够的掌控。</p>
<h2 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h2><p>在现实生活中，资源是用来达成目标的资产，在游戏世界中也基本是这样。</p>
<p>管理资源和决定玩家什么时候和怎样去接触资源是游戏设计工作中的重要部分。设计师需要决定哪些资源是玩家可以掌控的，玩家又该通过怎么样的方式去用这些资源，同时保证玩家在使用资源的过程中不会破坏游戏的挑战性。</p>
<p>游戏设计师要设计玩家如何获得足够达成目标的资源，玩家或许不会像他们预期的那样获得非常多的资源，但是他们最终获得的资源一定是够他们推动游戏的，否则这个设计就是不平衡的。</p>
<p>从定义上来说，资源必须满足“实用性”和“稀缺性”。例如在暗黑破坏神中不会出现寿司这个资源，虽然寿司在这游戏中会是一个有趣的存在，但这个存在是无意义的。同时资源也不会非常非常多，否则资源也就失去了其存在的意义（不构成任何挑战）。</p>
<p>以下是游戏中通常会出现的资源：</p>
<h3 id="Lives"><a href="#Lives" class="headerlink" title="Lives"></a>Lives</h3><p>生命是动作游戏中最经典的稀缺资源，如马里奥中的生命。</p>
<p>生命这个资源采纳了最简单的模式：越多越好，更多的生命不会造成任何的副作用。</p>
<h3 id="Units"><a href="#Units" class="headerlink" title="Units"></a>Units</h3><p>在一些游戏中，玩家需要管理“单位”作为资源。如西洋棋中的棋子，炉石传说中的卡牌等。</p>
<p>有些单位是有限，有些是可再生的。</p>
<p>在游戏设计中，决定每个单位的花费，和平衡它与游戏中的其他元素是一个非常复杂的过程。最好的平衡方法，就是反复的测试。</p>
<h3 id="Health"><a href="#Health" class="headerlink" title="Health"></a>Health</h3><p>生命值可以作为一个单独的元素，或者其他元素的属性，如生命和单位就可以有生命值作为属性，来提示还有多久会失去这个元素。</p>
<p>通常来说，生命值这样的元素是有方法补充的。如在动作游戏中，玩家会通过药品来补充生命值，在角色扮演游戏中，玩家通过睡觉或者吃饭来补充生命值。不同的游戏种类适用不同的生命值补充方法，动作游戏中需要快速反应，所以补充生命值的方法更快但不真实，而角色扮演游戏则是相反。</p>
<h3 id="Currency"><a href="#Currency" class="headerlink" title="Currency"></a>Currency</h3><p>金钱也是许多游戏中的重要资源，通常游戏也会因此设计一个交易系统。如真实世界一样，金钱的存在加快了交易的进行，让玩家可以更方便的获取自己想要的资源，而不是繁琐的以物换物。</p>
<h3 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h3><p>一些游戏中，行为也是一种资源。如一些动作游戏中，会限制一些过于强大的行为，“大招”就是最好的例子，玩家需要有效的管理这种稀缺资源。</p>
<h3 id="Power-ups"><a href="#Power-ups" class="headerlink" title="Power-ups"></a>Power-ups</h3><p>游戏中的一种经典资源就是能量提升，如马里奥中的蘑菇和花朵。</p>
<p>能力提升资源通常会设计的非常稀少而且是临时性的。</p>
<h3 id="Inventory"><a href="#Inventory" class="headerlink" title="Inventory"></a>Inventory</h3><p>一些游戏中，玩家可以选择收集和管理一些资源（通常能量提升和和单位不允许被管理），将这种资源称为“库存（Inventory）”。因为玩家可以收集的资源容量是有限的，所以这种收集本身就也存在稀缺性，玩家需要做出选择决定收集哪些资源，丢弃哪些资源。</p>
<h3 id="Special-Terrain"><a href="#Special-Terrain" class="headerlink" title="Special Terrain"></a>Special Terrain</h3><p>一些游戏中的某些地形也是一种资源，如魔兽争霸Ⅲ中的黄金是从金矿中采集的，金矿作为一个地形也成为了重要的i资源。</p>
<h3 id="Time"><a href="#Time" class="headerlink" title="Time"></a>Time</h3><p>时间在一些游戏中也会称为限制和资源。如许多的动作游戏，还有快棋，每个玩家都只有固定的时常做出下棋的选择。</p>
<h2 id="Conflict"><a href="#Conflict" class="headerlink" title="Conflict"></a>Conflict</h2><p>冲突通过规则，流程还有游戏情况（如多个玩家）来阻止玩家直接达成目标，冲突通常是一个游戏的核心。</p>
<p>流程通常提供了一种低效的达成目标的方法，即强迫玩家必须使用某些方法或技能才能达成目标。</p>
<p>流程本身也提供了竞赛和玩耍的感觉，玩家在这个低效的过程中会逐渐获得成就感或其他的快乐的感觉。</p>
<p>冲突通常有以下三个表现形式：</p>
<h3 id="Obstacles"><a href="#Obstacles" class="headerlink" title="Obstacles"></a>Obstacles</h3><p>障碍在一种常用的冲突方式。无论在单机游戏还是多人游戏中，都能使用障碍作为冲突，但在多人游戏中更多一些。</p>
<p>障碍不仅仅是物理形式，如水池，山坡，也可以是智力方面的，如动作游戏中的谜题等。</p>
<h3 id="Opponents"><a href="#Opponents" class="headerlink" title="Opponents"></a>Opponents</h3><p>在多人游戏中，对手是一个最主要的冲突来源。</p>
<h3 id="Dilemmas"><a href="#Dilemmas" class="headerlink" title="Dilemmas"></a>Dilemmas</h3><p>困境作为冲突通常是用来表示那些进退两难的选择，如大富翁中选择是否要购买一块土地。</p>
<h2 id="Boundaries"><a href="#Boundaries" class="headerlink" title="Boundaries"></a>Boundaries</h2><p>边界是用来将游戏和其他非游戏的部分区分开来的。</p>
<p>Huizinga将玩家同意游戏的规则，开始游戏的行为称为，进入“Magic circle”。其中一个重要的部分，就是玩家需要有安全感，他可以在任意时间选择退出这个“Magic circle”。</p>
<p>游戏设计者必须定义游戏的边界，即玩家如何进入和退出游戏。这个边界可以是物理的，如足球场的边界，也可以是概念上的，如只是简单的放弃玩一个游戏。</p>
<p>边界的设置也决定了一款游戏的风格，因此修改边界也可以作为游戏设计的一部分。例如大富翁中能用真的金钱会怎么样？</p>
<p>边界不仅仅作为游戏中的一个元素，它也提供了情绪上的区分。边界的存在让玩家在游戏中的情绪与在现实生活中的情绪所分开，如在游戏中对朋友开一些相对过分的玩笑并不会产生在现实中说同意的话造成的影响。</p>
<p>对于大多数的游戏而言，游戏系统是一个封闭的系统，即游戏内的元素是不会与游戏外的元素进行交互的。但现在也有许多的游戏设计师尝试去打破这个边界，如Pokémon GO。</p>
<h2 id="Outcome"><a href="#Outcome" class="headerlink" title="Outcome"></a>Outcome</h2><p>游戏的结果必须是一个不确定的因素，这样才能获取玩家的注意力。通常来说游戏的结果必须是一个可测量的结果，但也有例外，如模拟游戏，和一些在线的多人游戏，并不存在分数和输赢的概念。</p>
<p>对于绝大部分的游戏而言，游戏的结果是输或赢。在特定的时间或情况下，系统回去检测是否有达成赢或输的标准，如果达到了，那么游戏就结束了。</p>
<p>一些游戏是零和的，即一个人赢就代表另一个人输，如下棋。还有一些游戏是非零和的，如魔兽世界，一个玩家获取了某些东西并不代表另一个玩家会失去某些东西。非零和游戏在本质上不是竞争游戏，所以需要有另一个系统来体现游戏中的得失，如排名系统，玩家统计，或者其他不同的目标，甚至是玩家自定义的目标，如“我需要在模拟人生中达成…”。</p>
<h2 id="Conclustion"><a href="#Conclustion" class="headerlink" title="Conclustion"></a>Conclustion</h2><p>这一章中介绍了游戏的常规元素，设计师可以通过结合这些元素来创造不同的游戏体验。</p>
<p>也可以通过分析游戏中的这些元素来学习游戏设计。</p>
<div class="note info simple"><p>引用：</p>
<p>1.<em>Game Design Workshop</em> 4th 2019 by Tracy Fullerton</p>
</div>
<hr>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>游戏设计</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>游戏设计</tag>
      </tags>
  </entry>
  <entry>
    <title>《Game Design Workshop》 第四章笔记</title>
    <url>/GameDesignWorkshop-Chapter4-Notes/</url>
    <content><![CDATA[<p>《Game Design Workshop》 第四章笔记</p>
<p>这一章主要关于游戏的戏剧元素的设计。</p>
<p>作者首先介绍的常规的与游戏概念结合比较深的两个元素，挑战和玩耍。</p>
<p>之后介绍了三个在戏剧上更为复杂的元素，前提，角色，故事。</p>
<p>之后是两个更为复杂和高级的概念，世界创建和戏剧化曲线。</p>
<span id="more"></span>
<h1 id="Chapter-4-Working-with-Dramatic-Elements"><a href="#Chapter-4-Working-with-Dramatic-Elements" class="headerlink" title="Chapter 4 Working  with Dramatic Elements"></a>Chapter 4 Working  with Dramatic Elements</h1><p>第三章中提到的常规元素构创造了玩家体验，正是常规元素构成了游戏。戏剧元素（Dramatic Elements）定义了游戏的上下文，它将常规元素融合在系统中并产生了一个更有意义的体验，让玩家有了情感上的体验。</p>
<p>常规的戏剧元素有挑战（Challenge）和玩耍（Play），更复杂的戏剧化元素包括前提（Premise）、角色（Character）、故事（Story）。</p>
<h2 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h2><p>许多人都会同意游戏吸引他们的部分就是挑战。</p>
<p>当玩家谈及挑战时，他们谈及的是那些他们乐于完成的任务，这些任务需要一定的工作，而且能给他们带来满足感和愉悦感。</p>
<p>因此挑战是一个很个人化的因素，年轻人觉得是挑战的事情，老年人并一定觉得。</p>
<p>同样挑战也是一个动态的因素，一个事情在刚开始可能很有挑战性，但随着熟练度提升就逐渐失去了难度。所以游戏设计者必须要保持游戏的挑战性，用此来吸引玩家的注意。</p>
<p>当设计游戏时，设计师考虑的是如何让玩家更愉悦，这个问题是与挑战性相关的。虽然挑战性是个人化的因素，但是愉悦感却有相同点。根据心理学家Mihaly Crikszentmihalyi的研究，无论年纪，性别，社会阶层等等区别，让人们预约的活动都有以下特点</p>
<ol>
<li>当解决人们有能力解决的问题时</li>
<li>人们必须集中于正在做的事情上</li>
<li><ol>
<li>因为任务有清晰的目标和及时的反馈，所以人们可以集中在这件事上。</li>
</ol>
</li>
<li>事物有一个深入但轻松的参与感，让人们忘记日常生活中的担忧和困扰</li>
<li>让人们对正在发生的事物有可控感</li>
<li>在事物进行时有无我的感觉，但是当事物结束后又能更加充分的感觉到自己的存在</li>
<li>感到时间的速度发生了变化，数小时可能变得像几分钟一样，几分钟又可能变得像数小时一样。</li>
</ol>
<p>Crikszentmihalyi根据发现，发明了一个理论叫做心流（Flow），如下图所示：</p>
<p><img src="GameDesignWorkshop-Chapter4-notes/image-20200311212101483.png" alt="心流" style="zoom:50%;" /></p>
<p>如果一个活动的挑战远低于人的能力，那么就会觉得无聊，而如果挑战远高于人的能力，则会感到困扰。在心流中，一个活动是在挑战和能力之间平衡地带，给人带来愉悦感和满足感。</p>
<p>在游戏设计中期望达到的就是心流的区域。以下是一些能帮助达到心流的元素</p>
<h3 id="A-Challenging-Activity-That-Requires-Skill"><a href="#A-Challenging-Activity-That-Requires-Skill" class="headerlink" title="A Challenging Activity That Requires Skill"></a>A Challenging Activity That Requires Skill</h3><p>根据Crikszentmihalyi的描述，心流发生的情况通常是一个活动是目标导向的，而且被规则所约束同时完成它需要有合适的技能。</p>
<p>如果一个人没有任务所要求的任何能力，那么这个任务对于他来说是没有意义的，只有这个人拥有部分能力，但又不足以完成这个人任务时，这个任务才能称为是有挑战性的。</p>
<h3 id="The-Merging-of-Action-and-Awareness"><a href="#The-Merging-of-Action-and-Awareness" class="headerlink" title="The Merging of Action and Awareness"></a>The Merging of Action and Awareness</h3><p>Crikszentmihalyi说，当心流发生时，人们是非常沉浸入他们正在做的事情中，因此变得非常主动，他们也不会意识到自己是作为一个个体正在“做这件事”，即行为和感知结合在了一起，变成了无我的状态。</p>
<h3 id="Clear-Goals-and-Feedback"><a href="#Clear-Goals-and-Feedback" class="headerlink" title="Clear Goals and Feedback"></a>Clear Goals and Feedback</h3><p>在心流的体验中，需要知道要达成什么，且要及时的得到该如何达成目标的反馈。</p>
<p>当一个游戏有明确的目标时，玩家知道他们要做些什么才能赢，才能前往下一关等等，而且他们也收到了明确的关于他们行动让他们离目标更近还是更远的反馈。</p>
<h3 id="Concentration-on-the-Task-at-Hand"><a href="#Concentration-on-the-Task-at-Hand" class="headerlink" title="Concentration on the Task at Hand"></a>Concentration on the Task at Hand</h3><p>另一个心流的元素是，人们只意识到此时此刻发生的事。他们不会再意识到其他的问题，出现了另一个世界，在这个世界中只有当下的事情，只有参与者在其中。</p>
<h3 id="The-Paradox-of-Control"><a href="#The-Paradox-of-Control" class="headerlink" title="The Paradox of Control"></a>The Paradox of Control</h3><p>人们享受在困难情况时候的掌控感，但是只有一个事情的结果是未知的时候，才会有掌控感。这有一定矛盾的感觉：人们只有在完全控制情况的下才会有掌控感。<br>Crikszentmihalyi说：当一个情况结果是未知时，只有这个人<code>有能力</code>去掌控结果，他才会有掌控感。</p>
<h3 id="The-Loss-of-Self-Consciousness"><a href="#The-Loss-of-Self-Consciousness" class="headerlink" title="The Loss of Self-Consciousness"></a>The Loss of Self-Consciousness</h3><p>在心流中，人们会过度的关注于正在做的事情，忘记了自己的存在。但是在心流结束时，人们又会有更强的自我意识，如音乐家感受到了自己音乐的和谐，游戏玩家对自己策略或技能的满足。</p>
<p>这一点同样乍一看同样有点矛盾，自我感觉的强化来自于自我感觉的丢失。</p>
<h3 id="The-Transformation-of-Time"><a href="#The-Transformation-of-Time" class="headerlink" title="The Transformation of Time"></a>The Transformation of Time</h3><p>在心流中，一个常发生的现象就是感觉时间流动的速度发生了变化。如人们真正沉浸在某个时期时，会觉得时间过得很快，同样有的时候又会觉得时间很慢，如芭蕾舞者在做一些高难度动作时，会觉得几秒钟的事情仿佛发生了几分钟。</p>
<h3 id="Experience-Becomes-an-End-in-Itself"><a href="#Experience-Becomes-an-End-in-Itself" class="headerlink" title="Experience Becomes an End in Itself"></a>Experience Becomes an End in Itself</h3><p>在心流中，做这件事变得是内在的，主动的。</p>
<p>生活中的大部分事情都是外在的，做那些事的原因是因为能满足某些目标。</p>
<p>但是像音乐，体育和游戏都是内在的，他们本身就是存在的意义。</p>
<p>总之在设计游戏时，需要考虑以下几个问题：</p>
<ol>
<li>希望玩家要掌握什么技能。</li>
<li>希望玩家要掌握这个技能到什么程度。</li>
<li>如果给玩家清晰的，重要的目标，有意义的选择和清晰的反馈？</li>
<li>如何将玩家需要做的事情，和他们需要思考的事情结合在一起？</li>
<li>如何消除玩家的不专心，对失败的恐惧。即如何给玩家一个足够安全的环境，让他们可能达到无我的境界。</li>
<li>如何让游戏有趣到其本身就是意义</li>
</ol>
<h2 id="Play"><a href="#Play" class="headerlink" title="Play"></a>Play</h2><p>玩是在一个限定的框架内做自由的活动，对于游戏而言这个框架就是规则和流程所限定的。</p>
<h3 id="The-Nature-of-Play"><a href="#The-Nature-of-Play" class="headerlink" title="The Nature of Play"></a>The Nature of Play</h3><p>需要知道玩耍有很多面： 它帮助人们学习技能和获取知识，让人更社交化，帮助人们解决问题，让人们放松，让人从不同的角度去思考问题。玩可以是不严肃的，让人开怀大小，玩也可能是严肃的，让其作为一个实验的存在，去尝试新鲜事物，去探索一个事物的边界。玩被认为是引导改革和创造力的方法。</p>
<p>但最重要的一点，玩是一种精神层面的东西。即使对于最严肃和最难的事情，也能用一种玩笑的方法去面对。</p>
<p>这里同样作者同样提到了关于玩的分类，即在Roger Caillois的<em>Man,Play,and Games</em>中提到的$Ag\hat{o}n$,$Alea$,$Mimicry$,$Ilinx$。</p>
<p>这部分在<code>Rules Of Play</code>的第22章有详细描述，这里就不再赘述。</p>
<p>对于游戏设计者而言，知道对于玩的分类是为了帮助他们了解对于某一种的玩耍方式什么才是核心的愉悦感，这样可以帮助他们决定在特定的系统中对玩家的体验该设定怎样的目标。</p>
<h3 id="Types-of-Players"><a href="#Types-of-Players" class="headerlink" title="Types of Players"></a>Types of Players</h3><p>如同能区分玩耍的不同类型，也能从人的角度对玩家的类型进行区分：</p>
<ol>
<li>The Competitor：<br>竞争者是无论游戏类型是什么，他们的目标都是做最出色的玩家</li>
<li>The Explorer:<br>探索者是对游戏世界感到好奇，喜欢冒险，回去探索游戏世界的边界（无论是精神层面还是物理层面的边界）。</li>
<li>The Collector:<br>收集者会喜欢收集游戏世界内的元素，或者知识，如设定，历史等。</li>
<li>The Achiever:<br>成就者关心游戏中的成就和天梯等成就系统。</li>
<li>The Joker:<br>玩笑者对游戏不会太严肃，玩游戏只是为了单纯的快乐。硬核玩家可能会被玩笑者惹怒，但是玩笑者可以让游戏更加的有社会性，会推动游戏的流行。</li>
<li>The Artist:<br>艺术家是被游戏的设计和创意所吸引。</li>
<li>The Director:<br>引领者喜欢在游戏中带领游戏故事的推动，或称为别的玩家的领袖。</li>
<li>The Storyteller:<br>故事者会被游戏的故事所吸引。</li>
<li>The Performer:<br>表现者喜欢在别人玩家前表演，例如各种游戏主播。</li>
<li>The Craftsman:<br>工匠喜欢在游戏中建造，制作东西，或者解决游戏内的难题。</li>
</ol>
<p>对于游戏玩家的分类可以帮助游戏设计师从不同的角度去思考该如何从情感上吸引玩家。</p>
<h3 id="Levels-of-Engagement"><a href="#Levels-of-Engagement" class="headerlink" title="Levels of Engagement"></a>Levels of Engagement</h3><p>除了从玩耍本身和玩家角度考虑，不同玩家对于游戏的参与度也是不一样的。</p>
<p>例如一些玩家相比于自己玩游戏，更喜欢看别人玩游戏。通常来说，游戏设计师并不会从游戏的观看者角度出发去设计游戏。但是不可否认的是有非常的多人都喜欢称为游戏的观众，而且这个对于游戏的流行会产生很大的影响，所有游戏设计者或许也应该将观察者纳入考量的范围。</p>
<p>真正的游戏参与者无疑是设计师们最应该考虑的目标。某些情况下，游戏参与者会体验转型游玩（Transformational play），即玩游戏的过程一定程度上影响了玩家的人生。一些游戏的设计师也会从希望玩家体验转型游玩的角度去设计游戏，让游戏有更深层的意义，如通过让玩家体验到现实世界中战争的残酷来反战等。</p>
<h2 id="Premise"><a href="#Premise" class="headerlink" title="Premise"></a>Premise</h2><p>除了挑战和玩耍，游戏也有一些传统戏剧中包含的元素。如果没有这些戏剧元素，游戏对玩家而言会变得过于抽象，让玩家无法从情感上融入游戏。</p>
<p>如竞赛游戏，从常规元素角度上来说就是数值的比较，谁数值更大谁就获胜。为了让玩家在情感上能融入游戏，通常需要使用情感元素来包装常规元素。</p>
<p>在传统的戏剧中，前提是用来解释一个故事的，包括故事的时间，地点，人物，关系，现状等，还有两个格外重要的元素，<code>问题（Problem）</code>和<code>攻击点（Point of attack）</code>。问题是让现状不再稳定的事件，并且问题创造了矛盾。攻击点是问题被引出的时刻，也是一场戏剧真正开始的时刻。</p>
<p>在游戏中，问题和攻击点对应常规元素中的目标（objective）和流程中的开始时刻（starting action）。</p>
<p>在游戏中，前提可以是像传统戏剧中那样复杂，如魔兽世界，也可以非常简单，只是作为一个简单的比喻来包装抽象的常规系统，例如雷电，仅仅是战机攻击外星飞船。</p>
<p>前提的首要任务就是让游戏的常规系统对于玩家而言是可玩的，而不是完全对抽象概念的操作（玩家不是发出一个无意义的射线，而是对外星飞船的开火）。</p>
<p>前提更复杂的任务就是让游戏能从情感上吸引玩家。通过用前提来将游戏的常规系统和戏剧系统结合在一起，是游戏设计师提升玩家体验的一个机会。</p>
<h2 id="Character"><a href="#Character" class="headerlink" title="Character"></a>Character</h2><p>角色是戏剧中采取行动的人。通过定义角色和他的目标，观众可以内化故事的事件，对故事的发展感同身受。</p>
<p>角色可以从很多角度去解释。最常见的是角色是心理的表现，如为了体现观众的恐惧或渴望。更深一层，角色可以是有象征意义的，代表一个远大的想法，例如美国梦，民主等。角色也可以是有历史含义的，或者描述真实世界的现象。一个角色该如何使用是由故事本身决定的，例如没必要在一个低俗戏剧中，让一个角色代表严肃深刻的含义。</p>
<p>角色是由他所说的话，他做的事，他的外貌和别人眼中的他来决定的。如果一个角色有明显的特征，有真实的人格，而且在故事的发展中人格会发生变换，那么这就是个丰满的人物（round character）。相反，如果一个人只有很少的特征和人格，那么就会认为这个人物是扁平的（Flat）。一个扁平化的人物通常不会在故事中有人格上的变化，他们只是用来作为一个象征含义，如懒惰的人，邪恶的人。</p>
<p>无论一个角色复杂与否，在设计一个角色时都需要考虑以下几个问题：</p>
<ol>
<li>角色想要什么？</li>
<li>角色需要什么？</li>
<li>观众希望看到什么?</li>
<li>观众害怕看到什么？</li>
</ol>
<p>在游戏中特殊的一点是，游戏角色的设计要考虑在代理（Agency）和同情（Empathy）间的平衡。代理指的是游戏角色完全是玩家的体现，游戏角色只是作为一个命令的执行者。而同情指的是玩家将自己的情感投射入角色中，让角色的目标成为了自己的目标。</p>
<p>对于早期的游戏角色而言，他们都是扁平的，主要区别在于角色的外观。他们的存在同样是为了包装常规系统，让一个戏剧化的目标代替游戏的常规元素，如在马里奥中，用拯救公主这个具体的目标代替抽象的“营救目标”这一常规游戏目标。但是这些角色完全是受玩家控制的，他们不会有人格上的变化。</p>
<p>而现在许多的游戏角色有了更深的背景故事和更丰富的人格特征，这些都会影响玩家的游戏体验。如战胜中的奎托斯，在游戏进度推进的过程中，可以看到角色的情感发生了变化，有自己的人格变化和发展，而不是单纯的作为玩家控制的体现。</p>
<p>还有一种角色是化身（Avatar），如魔兽世界中玩家创建的角色。玩家对于这种角色也同样有非常深得共鸣。</p>
<p>在游戏中还需要设计师考虑的一点是，自由意志和玩家控制之间的平衡（Free will vs. Player control）。</p>
<p>游戏角色是代理玩家的体现，这限定了游戏角色展示自己的个性和思考。但是在游戏过程中，并非每分每秒玩家都对角色有着控制。在这种情况下AI控制的角色在玩家的意志和游戏角色自己的意志中创建了一个灰色地带。</p>
<p>例如在早期游戏中，世嘉的游戏角色索尼克，在玩家不控制他时，他会不耐心的用脚点地。这种自由行为与索尼克抓紧每分每秒，高速移动的角色的设定是符合的。</p>
<p>同时AI的控制也能运用到非玩家控制的角色中，如NPC和敌人，这些都可以让游戏变得更加的有趣和可信。</p>
<p>现在的发展趋势是游戏角色变得越来越丰满，如何合理有效的运用传统戏剧元素和AI让游戏角色变得更加真实，是游戏设计师需要考虑的工作。</p>
<h2 id="Story"><a href="#Story" class="headerlink" title="Story"></a>Story</h2><p>如在第三章中所述，游戏的结果必须是不确定的。一个故事的结局同样是不确定的，最起码在第一遍阅读时时这样的。在电影和戏剧中，故事的不确定性是由作者或者演员来逐渐消除的，在游戏中则需要通过玩家逐渐消除。</p>
<p>在许多游戏中，故事是由背景故事限制的。背景故事给了游戏的上下文了冲突，它创造了游戏角色的动机。但是故事的推进并不是由玩家来决定的，玩家的行为只是触发要进入故事下一个片段的因素，实际上故事的走向已经是确定了的。</p>
<p>但也有一些游戏设计师希望玩家的行为能改变故事的走向。最简单的实现就是故事树，玩家的选择就让故事的走向走进预先设定的某一种可能中。故事树如下图所示：</p>
<p><img src="GameDesignWorkshop-Chapter4-notes/image-20200312112050925.png" alt="故事树" style="zoom:50%;" /></p>
<p>但这种方法下，故事仍然是被预先决定的，同样它也限定了玩家可做的选择。还有一种实现就是像模拟人生一样，玩家可以用常规系统提供的元素，来自己创造出无限可能的故事。</p>
<p>故事在游戏中，最常见的用法就是用来在单机游戏中推动玩家的冒险，如<em>最后的生还者</em>和<em>行尸走肉</em>。两者都是用故事来推动玩家的游戏，故事中的人物也同样都是饱满的，会随着故事的发展和发生情感的变化，同样能在情感上吸引玩家。但是不同的是，最后的生还者中故事的发展是完全限定了的，而行尸走肉中玩家的对话和行为会改变故事的结局。</p>
<p>对于游戏设计师，要考虑的就是在不牺牲玩家体验的情况下，让游戏中的故事更好的与游戏结合，让故事更有深度。</p>
<h2 id="World-Building"><a href="#World-Building" class="headerlink" title="World Building"></a>World Building</h2><p>世界构建（World building）是一个复杂且深入的虚拟世界创造过程，通常是由创建地图和历史开始，但也可以变得更加复杂，如包含语言，文化，宗教，政治，经济等。</p>
<p>目前最成功的世界构建可能是J.R.R Tolkien创造的中世纪这一概念。魔兽世界一定程度上就是基于这个概念创建的。</p>
<p>媒体理论学家Henry Jenkins提到，“限制越来越多的故事变成世界构建，艺术家们创建了一个复杂的世界，复杂到无法用单一的媒体来完全的展现出来。”</p>
<p>而对于游戏设计来说，最重要的是让游戏的规则与虚拟世界的规则是匹配的，无论是从交互层面还是从故事层面。</p>
<h2 id="The-Dramatic-Arc"><a href="#The-Dramatic-Arc" class="headerlink" title="The Dramatic Arc"></a>The Dramatic Arc</h2><p>对于所有的戏剧元素中，最重要的就是冲突，这一概念在常规元素中同样有出现。</p>
<p>冲突是一个优秀的剧情的核心，同样也是一个游戏系统的核心。</p>
<p>一个有意义的冲突不仅仅是防止玩家太容易的达成目标，还要让玩家对游戏的结果产生紧张感，让玩家能被游戏所吸引。</p>
<p>当从变换的角度来思考冲突时，冲突通常是通过逐渐扩大来创造紧张感。在大部分的戏剧中，紧张感会先逐渐加剧然后逐渐放缓，这就是经典的戏剧性弧线，如下图所示：</p>
<p><img src="GameDesignWorkshop-Chapter4-notes/image-20200312115742695.png" alt="戏剧性弧线" style="zoom:50%;" /></p>
<p>如之前章节中所述，在解释（Exposition）部分会介绍故事的角色，背景以及冲突等各种重要概念。而主角尝试去解决冲突的过程，构成了故事铺陈（Rising Action）。在铺陈的重点是故事的高潮（Climax），在这个时刻会有某些决定性的因素或事件发生，故事的高潮决定了故事的最终结局。高潮过后即是收尾阶段（Falling Action），在这个阶段冲突逐渐被解决。直到结尾（Resolution），冲突最终被解决。</p>
<p>在游戏中，故事铺陈的阶段会与常规系统和戏剧系统联系在一起。游戏通常会被设计成挑战逐渐增加（常规系统），这时候可以与故事的冲突（戏剧系统）逐渐加剧结合在一起。</p>
<p>一个反面例子是马里奥，在马里奥的常规系统中，每一关的难度逐渐增加，但是从戏剧角度来看，马里奥的目标从未动摇过，他也没有对救出公主有任何的内心冲突。即戏剧系统和常规系统发生了发生了割裂。</p>
<p>游戏相对于戏剧还有一个重要区别在于，推动冲突解决的是玩家自己。如马里奥中，玩家直到需要救出公主，于是玩家的常规目标——过关会为了这个戏剧社的目标结合在一起。当冲突解决后，不仅有冲突解决后情绪上紧张感的释放，还有个人成就感的提升。</p>
<p>在现代游戏中，游戏设计师会从更深刻的角度去思考玩家在游戏过程中的情绪变化。如风之旅人，是参考了Joseph Campbell的英雄之旅（Hero‘s Journey），其作者陈星汉根据英雄之旅的灵魂创造了一种情绪上的变换弧线，如下图所示：</p>
<p><img src="GameDesignWorkshop-Chapter4-notes/image-20200312121637342.png" alt="风之旅人" style="zoom:50%;" /></p>
<p>//TODO 玩风之旅人</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>所有的戏剧元素都是为了引出玩家情绪上的反应。</p>
<p>目前游戏在情绪上的影响还不够深刻，因此无法被认为是另一种戏剧艺术形式。</p>
<p>对于游戏设计师而言，要更好的设计戏剧系统，同时需要对传统戏剧的理解和对游戏本身的理解。</p>
<div class="note info simple"><p>引用：</p>
<p>1.<strong>Game Design Workshop</strong> 4th 2019 by Tracy Fullerton</p>
</div>
<hr>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>游戏设计</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>游戏设计</tag>
      </tags>
  </entry>
  <entry>
    <title>《Head First 设计模式》 笔记（一）</title>
    <url>/HeadFirstDesignPatternNotes-1/</url>
    <content><![CDATA[<p>这一系列为读《Head First 设计模式》时的笔记。</p>
<p>这一篇将会介绍策略模式，观察者模式，装饰模式，工厂模式。</p>
<p>在介绍每一个设计模式时，都会用一个简单的例子来说明，完整的测试代码可以在<a href="https://github.com/xuejiaW/Study-Notes/tree/master/Head_First_Design_Pattern">这里查看</a></p>
<span id="more"></span>
<div class="note info simple"><p>原书中的示例代码都是Java，而我在工作中C#用的较多，所以这里的测试代码使用的都是C#。</p>
</div>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>策略模式（Strategy Pattern）是使用一些独立的类来各自封装一些通用的算法，这些封装类都继承自同一个接口，该接口定义了算法。对于调用类来说，它只保存一个算法接口的对象，而这个对象所指代的特定算法则可以在运行时动态更改。</p>
<p>例如有我们有一个项目需要描述鸭子，可能有50种不同的鸭子都派生自基类<code>Duck</code>，鸭子一共有三种飞行方式。这时候我们如果将某一种特定的飞行方式写在基类中，则不是使用这个飞行方式的所有派生鸭子都需要对该方法重写。如果我们不在基类中定义，而在各个派生类中实现，则可能多个有相同飞行方式的鸭子派生类都有相同的代码定义飞行方式，这造成了代码冗余。</p>
<p>所以我们可以使用策略模式，将三种飞行方式都派生自接口<code>FlyBehavior</code>，并在鸭子基类中定义变量<code>FlyBehavior</code>，然后在派生类中选择各自需要的飞行方式即可。</p>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><h4 id="算法接口及实现类"><a href="#算法接口及实现类" class="headerlink" title="算法接口及实现类"></a>算法接口及实现类</h4><figure class="highlight cs"><figcaption><span>飞行方法接口</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IFlyBehavior</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Fly</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>飞行方法实现</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FlyNoWay</span> : <span class="title">IFlyBehavior</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fly</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Can not fly&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FlyWithRocket</span> : <span class="title">IFlyBehavior</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fly</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Fly with rocket&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FlyWithWings</span> : <span class="title">IFlyBehavior</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fly</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Fly with wings&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="环境类"><a href="#环境类" class="headerlink" title="环境类"></a>环境类</h4><figure class="highlight cs"><figcaption><span>鸭子基类</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Duck</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IFlyBehavior flyBehavior;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Duck</span>()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">disPlay</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PerformFly</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        flyBehavior.Fly();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlyBehavior</span>(<span class="params">IFlyBehavior fb</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        flyBehavior = fb;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>鸭子派生类</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BlackDuck</span> : <span class="title">Duck</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BlackDuck</span>() : <span class="title">base</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        setFlyBehavior(<span class="keyword">new</span> FlyWithWings());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">disPlay</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;I am a black duck&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RubberDuck</span> : <span class="title">Duck</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RubberDuck</span>() : <span class="title">base</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        setFlyBehavior(<span class="keyword">new</span> FlyNoWay());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">disPlay</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;I am a rubber duck&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试及结果"><a href="#测试及结果" class="headerlink" title="测试及结果"></a>测试及结果</h4><figure class="highlight cs"><figcaption><span>测试代码</span></figcaption><table><tr><td class="code"><pre><span class="line">RubberDuck rubberDuck = <span class="keyword">new</span> RubberDuck();</span><br><span class="line">rubberDuck.disPlay();</span><br><span class="line">rubberDuck.PerformFly();</span><br><span class="line"></span><br><span class="line">BlackDuck blackDuck = <span class="keyword">new</span> BlackDuck();</span><br><span class="line">blackDuck.disPlay();</span><br><span class="line">blackDuck.PerformFly();</span><br><span class="line">blackDuck.setFlyBehavior(<span class="keyword">new</span> FlyWithRocket());</span><br><span class="line">blackDuck.PerformFly();</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<p><img src="HeadFirstDesignPatternNotes-1/2019-01-15-00-12-45.png" alt="策略模式运行结果"></p>
<hr>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>观察者模式（Observer Pattern）定义了一种一对多的依赖关系，当被观察者（<code>Subject</code>）的状态发生变化时，它将会通知观察者们（<code>Observers</code>）进行某种操作。</p>
<p>例如我们希望定义温度计和压力计，在天气信息发生变化时自动更新，而非自己反复的查询是否天气信息有发生变化。这里天气信息就是被观察者，而温度计和压力计就是观察者。</p>
<h3 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h3><h4 id="观察者及被观察者接口"><a href="#观察者及被观察者接口" class="headerlink" title="观察者及被观察者接口"></a>观察者及被观察者接口</h4><figure class="highlight cs"><figcaption><span>被观察者</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ISubject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RegisterObserver</span>(<span class="params">IObserver observer</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">UnregisterObserver</span>(<span class="params">IObserver observer</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NotifyObservers</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>观察者</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IObserver</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params">ISubject subject</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="观察者实现"><a href="#观察者实现" class="headerlink" title="观察者实现"></a>观察者实现</h4><figure class="highlight cs"><figcaption><span>温度计</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TemperatureObserver</span> : <span class="title">IObserver</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> ISubject subject;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TemperatureObserver</span>(<span class="params">ISubject subject</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">        <span class="keyword">this</span>.subject.RegisterObserver(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params">ISubject subject</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        WeatherData weatherData = subject <span class="keyword">as</span> WeatherData;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注意这里我们是从主动从被观察者那里去获取数据</span></span><br><span class="line">        <span class="keyword">if</span> (weatherData != <span class="literal">null</span>)</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Temperature is &quot;</span> + weatherData.Temperature);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>压力计</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PressureObserver</span> : <span class="title">IObserver</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> ISubject subject;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PressureObserver</span>(<span class="params">ISubject subject</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">        <span class="keyword">this</span>.subject.RegisterObserver(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params">ISubject subject</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        WeatherData weatherData = subject <span class="keyword">as</span> WeatherData;</span><br><span class="line">        <span class="keyword">if</span> (weatherData != <span class="literal">null</span>)</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Pressure is &quot;</span> + weatherData.Pressure);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="被观察者实现"><a href="#被观察者实现" class="headerlink" title="被观察者实现"></a>被观察者实现</h4><figure class="highlight cs"><figcaption><span>天气数据</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WeatherData</span> : <span class="title">ISubject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;IObserver&gt; observersList;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> Temperature &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> Humidity &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> Pressure &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeatherData</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        observersList = <span class="keyword">new</span> List&lt;IObserver&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">NotifyObservers</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        observersList.ForEach(o =&gt; o.Update(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RegisterObserver</span>(<span class="params">IObserver o</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        observersList.Add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UnregisterObserver</span>(<span class="params">IObserver o</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        observersList.Remove(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">measurementsChanged</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        NotifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetMeasurements</span>(<span class="params"><span class="built_in">float</span> temperature, <span class="built_in">float</span> humidity, <span class="built_in">float</span> pressure</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.Temperature = temperature;</span><br><span class="line">        <span class="keyword">this</span>.Humidity = humidity;</span><br><span class="line">        <span class="keyword">this</span>.Pressure = pressure;</span><br><span class="line">        measurementsChanged();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试及结果-1"><a href="#测试及结果-1" class="headerlink" title="测试及结果"></a>测试及结果</h4><figure class="highlight cs"><figcaption><span>测试代码</span></figcaption><table><tr><td class="code"><pre><span class="line">WeatherData weatherData = <span class="keyword">new</span> WeatherData();</span><br><span class="line">TemperatureObserver temperatureObserver = <span class="keyword">new</span> TemperatureObserver(weatherData);</span><br><span class="line">PressureObserver pressureObserver = <span class="keyword">new</span> PressureObserver(weatherData);</span><br><span class="line"></span><br><span class="line">weatherData.SetMeasurements(<span class="number">30</span>, <span class="number">20</span>, <span class="number">10</span>);</span><br><span class="line">weatherData.SetMeasurements(<span class="number">20</span>, <span class="number">40</span>, <span class="number">5</span>);</span><br><span class="line">weatherData.UnregisterObserver(temperatureObserver);</span><br><span class="line">weatherData.SetMeasurements(<span class="number">10</span>, <span class="number">50</span>, <span class="number">15</span>);</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="HeadFirstDesignPatternNotes-1/2019-01-15-23-20-09.png" alt="观察者模式运行结果"></p>
<hr>
<h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><p>装饰模式(Decorator Pattern))提供了一个动态增加一个类功能的方法，主要实现思想是通过一个作为装饰者的类（<code>Decorators</code>）包裹被装饰类（<code>Component</code>）（装饰类以及被装饰类都有共同的基类）,<code>Decorators</code>会在<code>Component</code>类的某一个函数执行前或后进行一些操作，进而达到增加功能的作用。</p>
<p>装饰模式主要实现了“代码应该对扩展功能开放而对于修改关闭”的面向对象原则，它在增加新功能的前提下，不需要改动既有的代码，只需要增加新的<code>Decorators</code>并且包含既有的<code>Component</code>即可。</p>
<p>例如我们要计算一杯咖啡的价格，而这杯咖啡的价格还会受到额外的配料的影响，比如要加抹茶需要额外支付0.2元，加奶泡需要额外支付0.3元等。如果对各种配料都各自使用一个类来表示，则会存在较多的类需要维护，而且一旦配料发生变化等，还需要进行代码修改。而使用装饰模式则可以将原始的咖啡作为被装饰类，而所有的配料都是装饰类，则配料的更改仅需要增加或删除外部的装饰类即可。</p>
<h3 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h3><h4 id="装饰类及被装饰类基类"><a href="#装饰类及被装饰类基类" class="headerlink" title="装饰类及被装饰类基类"></a>装饰类及被装饰类基类</h4><figure class="highlight cs"><figcaption><span>被装饰类基类</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Beverage</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">string</span> description = <span class="string">&quot;UnKnown Beverage&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">string</span> <span class="title">getDescription</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">double</span> <span class="title">Cost</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>装饰类基类</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">CondimentDecorator</span> : <span class="title">Beverage</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> Beverage beverage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CondimentDecorator</span>(<span class="params">Beverage beverage</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.beverage = beverage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note info simple"><p>注意装饰类基类继承自被装饰类，并存有一个被装饰类的变量，因为装饰类需要在被装饰类操作的基础上进行一定额外的操作，所以它需要存有对被装饰类的引用，同时对外部而言调用者而言，它与被装饰类相同。</p>
</div>
<h4 id="被装饰类实现"><a href="#被装饰类实现" class="headerlink" title="被装饰类实现"></a>被装饰类实现</h4><figure class="highlight cs"><figcaption><span>浓咖啡</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Espresso</span> : <span class="title">Beverage</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Espresso</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        description = <span class="string">&quot;Espresson&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">double</span> <span class="title">Cost</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.99</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="装饰类实现"><a href="#装饰类实现" class="headerlink" title="装饰类实现"></a>装饰类实现</h4><figure class="highlight cs"><figcaption><span>酱油</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Soy</span> : <span class="title">CondimentDecorator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Soy</span>(<span class="params">Beverage beverage</span>) : <span class="title">base</span>(<span class="params">beverage</span>)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">getDescription</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> beverage.getDescription() + <span class="string">&quot;, Soy&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">double</span> <span class="title">Cost</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.30</span> + beverage.Cost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>奶泡</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Whip</span> : <span class="title">CondimentDecorator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Whip</span>(<span class="params">Beverage beverage</span>) : <span class="title">base</span>(<span class="params">beverage</span>)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">getDescription</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> beverage.getDescription() + <span class="string">&quot;, Whip&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">double</span> <span class="title">Cost</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.30</span> + beverage.Cost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>抹茶</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Mocha</span> : <span class="title">CondimentDecorator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mocha</span>(<span class="params">Beverage beverage</span>) : <span class="title">base</span>(<span class="params">beverage</span>)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">getDescription</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> beverage.getDescription() + <span class="string">&quot;, Mocha&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">double</span> <span class="title">Cost</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.20</span> + beverage.Cost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试及结果-2"><a href="#测试及结果-2" class="headerlink" title="测试及结果"></a>测试及结果</h4><figure class="highlight cs"><figcaption><span>测试代码</span></figcaption><table><tr><td class="code"><pre><span class="line">Espresso espresso = <span class="keyword">new</span> Espresso();</span><br><span class="line">Console.WriteLine(espresso.getDescription() + <span class="string">&quot; Cost: &quot;</span> + espresso.Cost());</span><br><span class="line"></span><br><span class="line">Beverage doubleMochaWhipEspresso = <span class="keyword">new</span> Mocha(<span class="keyword">new</span> Mocha(<span class="keyword">new</span> Whip(espresso)));</span><br><span class="line">Console.WriteLine(doubleMochaWhipEspresso.getDescription() + <span class="string">&quot; Cost: &quot;</span> + doubleMochaWhipEspresso.Cost());</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="HeadFirstDesignPatternNotes-1/2019-01-15-23-43-20.png" alt="装饰模式运行结果"></p>
<hr>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>工厂模式是为了将对象的实例化与对对象的操作解耦。因为有时我们会根据情况的不同，实例化出对象的不同版本，而我们不希望这种对于情况的判断与逻辑代码耦合在一起。</p>
<p>工厂模式有三个较为常见的变种，简单工厂模式，工厂方法模式，抽象工厂模式，下面会以创建披萨为例子来具体说明。</p>
<h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>简单工厂模式严格意义上并不是一个设计模式，只是它被太多人的使用，所以需要单独进行说明。</p>
<p>简单工厂模式会定义一个工厂类来进行对象的实例化。</p>
<p>我们定义一个披萨商店，他将会管理披萨产出的整个流程。我们为了将披萨的生产与之后的操作（如切披萨）拆分开，需要定义一个简单披萨工厂。</p>
<h4 id="披萨类及其实例化"><a href="#披萨类及其实例化" class="headerlink" title="披萨类及其实例化"></a>披萨类及其实例化</h4><figure class="highlight cs"><figcaption><span>披萨基类</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Pizza</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> Cheese cheese = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">protected</span> Sauce sauce = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">protected</span> Onion onion = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">prepare</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Bake for 25 minutes at 350&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cut</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Cutting the pizza into diagonal slices&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">box</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Place pizza in official PizzaStore box&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Debug</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">        Console.WriteLine(name);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Cheese is &quot;</span> + (cheese != <span class="literal">null</span> ? cheese.ToString() : <span class="string">&quot;Null&quot;</span>));</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Sauce is &quot;</span> + (sauce != <span class="literal">null</span> ? sauce.ToString() : <span class="string">&quot;Null&quot;</span>));</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Onion is &quot;</span> + (onion != <span class="literal">null</span> ? onion.ToString() : <span class="string">&quot;Null&quot;</span>));</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>披萨实现</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CheesePizza</span> : <span class="title">Pizza</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">prepare</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cheese = <span class="keyword">new</span> Cheese();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SaucePizza</span> : <span class="title">Pizza</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">prepare</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        sauce = <span class="keyword">new</span> Sauce();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="披萨商店与简单披萨工厂"><a href="#披萨商店与简单披萨工厂" class="headerlink" title="披萨商店与简单披萨工厂"></a>披萨商店与简单披萨工厂</h4><figure class="highlight cs"><figcaption><span>披萨商店</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PizzaStore</span></span><br><span class="line">&#123;</span><br><span class="line">    SimplePizzaFactory simpleFactory;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PizzaStore</span>(<span class="params">SimplePizzaFactory factory</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.simpleFactory = factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">orderPizza</span>(<span class="params"><span class="built_in">string</span> type</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Pizza pizza = simpleFactory.createPizza(type);</span><br><span class="line">        pizza.prepare();</span><br><span class="line">        pizza.bake();</span><br><span class="line">        pizza.cut();</span><br><span class="line">        pizza.box();</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>简单披萨工厂</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SimplePizzaFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">createPizza</span>(<span class="params"><span class="built_in">string</span> type</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Pizza pizza = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (type.Equals(<span class="string">&quot;cheese&quot;</span>))</span><br><span class="line">            pizza = <span class="keyword">new</span> CheesePizza();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (type.Equals(<span class="string">&quot;sauce&quot;</span>))</span><br><span class="line">            pizza = <span class="keyword">new</span> SaucePizza();</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试及结果-3"><a href="#测试及结果-3" class="headerlink" title="测试及结果"></a>测试及结果</h4><figure class="highlight cs"><figcaption><span>测试代码</span></figcaption><table><tr><td class="code"><pre><span class="line">PizzaStore store = <span class="keyword">new</span> PizzaStore(<span class="keyword">new</span> SimplePizzaFactory());</span><br><span class="line">Pizza pizza = store.orderPizza(<span class="string">&quot;cheese&quot;</span>);</span><br><span class="line">pizza.Debug();</span><br></pre></td></tr></table></figure>
<p>运行结果:<br><img src="HeadFirstDesignPatternNotes-1/2019-01-20-21-24-34.png" alt="简单工厂运行结果"></p>
<h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>简单工厂提供了一个类来作为对象实例化的工厂，它解决了对象实例化与逻辑代码耦合的问题，但没有提供扩写这个工厂的方法。例如上例中，我们需要在工厂中增加新的产品只能扩写原先的工厂类，但这可能会造成单个工厂类的逻辑过于复杂。<br>而工厂方法模式则是通过一个抽象函数来作为工厂，在各派生类中重写该函数，达到工厂的扩写。</p>
<p>我们定义一个抽象的披萨商店，并在其中定义一个抽象函数<code>createPizza</code>，并在披萨商店的继承类中重写这个方法来演示工厂方法模式。</p>
<div class="note warning simple"><p>注意这个例子完全可以通过建立多个简单工厂来实现，这里只是为了说明工厂方法模式的结构。</p>
</div>
<h4 id="抽象披萨商店及实例化"><a href="#抽象披萨商店及实例化" class="headerlink" title="抽象披萨商店及实例化"></a>抽象披萨商店及实例化</h4><figure class="highlight cs"><figcaption><span>抽象披萨商店</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">PizzaStore</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">orderPizza</span>(<span class="params"><span class="built_in">string</span> type</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Pizza pizza = createPizza(type);</span><br><span class="line">        pizza.prepare();</span><br><span class="line">        pizza.bake();</span><br><span class="line">        pizza.cut();</span><br><span class="line">        pizza.box();</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Pizza <span class="title">createPizza</span>(<span class="params"><span class="built_in">string</span> type</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>纽约披萨商店</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NYPizzaStore</span> : <span class="title">PizzaStore</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> Pizza <span class="title">createPizza</span>(<span class="params"><span class="built_in">string</span> type</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Pizza pizza = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (type.Equals(<span class="string">&quot;cheese&quot;</span>))</span><br><span class="line">            pizza = <span class="keyword">new</span> NYStyleCheesePizza();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (type.Equals(<span class="string">&quot;sauce&quot;</span>))</span><br><span class="line">            pizza = <span class="keyword">new</span> NYStyleSausePizza();</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>芝加哥披萨商店</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ChicagoPizzaStore</span> : <span class="title">PizzaStore</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> Pizza <span class="title">createPizza</span>(<span class="params"><span class="built_in">string</span> type</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Pizza pizza = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (type.Equals(<span class="string">&quot;cheese&quot;</span>))</span><br><span class="line">            pizza = <span class="keyword">new</span> ChicagoStyleCheesePizza();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (type.Equals(<span class="string">&quot;sauce&quot;</span>))</span><br><span class="line">            pizza = <span class="keyword">new</span> ChicagoStyleSaucePizza();</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="不同风格的披萨实现"><a href="#不同风格的披萨实现" class="headerlink" title="不同风格的披萨实现"></a>不同风格的披萨实现</h4><figure class="highlight cs"><figcaption><span>纽约风格的披萨</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NYStyleCheesePizza</span> : <span class="title">Pizza</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">prepare</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cheese = <span class="keyword">new</span> NYCheese();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NYStyleSausePizza</span> : <span class="title">Pizza</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">prepare</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        sauce = <span class="keyword">new</span> NYSauce();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>芝加哥风格的披萨</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ChicagoStyleCheesePizza</span> : <span class="title">Pizza</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">prepare</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cheese = <span class="keyword">new</span> ChicagoCheese();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ChicagoStyleSaucePizza</span> : <span class="title">Pizza</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">prepare</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        sauce = <span class="keyword">new</span> ChicagoSauce();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试及结果-4"><a href="#测试及结果-4" class="headerlink" title="测试及结果"></a>测试及结果</h4><figure class="highlight cs"><figcaption><span>测试代码</span></figcaption><table><tr><td class="code"><pre><span class="line">PizzaStore store = <span class="keyword">new</span> ChicagoPizzaStore();</span><br><span class="line">Pizza pizza = store.orderPizza(<span class="string">&quot;cheese&quot;</span>);</span><br><span class="line">pizza.Debug();</span><br><span class="line">store = <span class="keyword">new</span> NYPizzaStore();</span><br><span class="line">pizza=store.orderPizza(<span class="string">&quot;cheese&quot;</span>);</span><br><span class="line">pizza.Debug();</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="HeadFirstDesignPatternNotes-1/2019-01-23-00-29-35.png" alt="工厂方法模式运行结果"></p>
<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>工厂方法模式中的工厂的多态性依赖于继承，比如我们定义的<code>PizzaStore</code>中有个抽象函数<code>createPizza</code>，这个抽象函数即为一个工厂，在各个派生类中我们去重写这个抽象函数，通过继承来实现不同的工厂。而在抽象工厂模式中，我们将定义一个工厂接口，在需要工厂的接口中类中存储这个接口，并在不同的情况下用这个接口不同的实现，来达到工厂的多态性。</p>
<p>另外在工厂方法模式中，因为是通过重写函数的方法来实现，所以一个工厂只能产出一个产品。而在抽象工厂模式中，在一个抽象工厂中却能定义多个制造产品的函数，进而一个抽象工厂可以提供多个产品。</p>
<div class="note info simple"><p>生产出一个产品还是多个产品并不是抽象工厂模式和工厂方法模式的主要区别，他们的主要区别在于工厂方法模式是通过继承来实现工厂的多态，而抽象工厂模式是通过组合。</p>
</div>
<p>我们定义一个披萨原料工厂，来体现抽象工厂模式。</p>
<h4 id="披萨原料工厂接口及实现"><a href="#披萨原料工厂接口及实现" class="headerlink" title="披萨原料工厂接口及实现"></a>披萨原料工厂接口及实现</h4><figure class="highlight cs"><figcaption><span>披萨原料工厂接口</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">PizzaIngredientFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Onion <span class="title">createOnion</span>()</span>;</span><br><span class="line">    <span class="function">Sauce <span class="title">createSauce</span>()</span>;</span><br><span class="line">    <span class="function">Cheese <span class="title">createCheese</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>纽约披萨原料商店</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NYPizzaIngredientFactory</span> : <span class="title">PizzaIngredientFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cheese <span class="title">createCheese</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NYCheese();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Onion <span class="title">createOnion</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NYOnion();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sauce <span class="title">createSauce</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NYSauce();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>芝加哥披萨原料商店</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ChicagoPizzaIngredientFactory</span> : <span class="title">PizzaIngredientFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cheese <span class="title">createCheese</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ChicagoCheese();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Onion <span class="title">createOnion</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ChicagoOnion();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sauce <span class="title">createSauce</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ChicagoSauce();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note info simple"><p>可以看到在抽象工厂的实现时，用到了工厂方法模式。抽象工厂模式与工厂方法模式并非互斥的两种模式，工厂方法模式实际上内嵌与抽象工厂模式中</p>
</div>
<h4 id="抽象披萨商店及实例化-1"><a href="#抽象披萨商店及实例化-1" class="headerlink" title="抽象披萨商店及实例化"></a>抽象披萨商店及实例化</h4><figure class="highlight cs"><figcaption><span>抽象披萨商店</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">PizzaStore</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">orderPizza</span>(<span class="params"><span class="built_in">string</span> type</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Pizza pizza = createPizza(type);</span><br><span class="line">        pizza.prepare();</span><br><span class="line">        pizza.bake();</span><br><span class="line">        pizza.cut();</span><br><span class="line">        pizza.box();</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Pizza <span class="title">createPizza</span>(<span class="params"><span class="built_in">string</span> type</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>纽约披萨商店</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> Pizza <span class="title">createPizza</span>(<span class="params"><span class="built_in">string</span> item</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Pizza pizza = <span class="literal">null</span>;</span><br><span class="line">    PizzaIngredientFactory ingredientFactory = <span class="keyword">new</span> NYPizzaIngredientFactory();</span><br><span class="line">    <span class="keyword">if</span> (item == <span class="string">&quot;cheese&quot;</span>)</span><br><span class="line">        pizza = <span class="keyword">new</span> CheesePizza(ingredientFactory);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (item == <span class="string">&quot;sauce&quot;</span>)</span><br><span class="line">        pizza = <span class="keyword">new</span> SaucePizza(ingredientFactory);</span><br><span class="line">    <span class="keyword">return</span> pizza;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>芝加哥披萨商店</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ChicagoPizzaStore</span> : <span class="title">PizzaStore</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> Pizza <span class="title">createPizza</span>(<span class="params"><span class="built_in">string</span> item</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Pizza pizza = <span class="literal">null</span>;</span><br><span class="line">        PizzaIngredientFactory ingredientFactory = <span class="keyword">new</span> ChicagoPizzaIngredientFactory();</span><br><span class="line">        <span class="keyword">if</span> (item == <span class="string">&quot;cheese&quot;</span>)</span><br><span class="line">            pizza = <span class="keyword">new</span> CheesePizza(ingredientFactory);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (item == <span class="string">&quot;sauce&quot;</span>)</span><br><span class="line">            pizza = <span class="keyword">new</span> SaucePizza(ingredientFactory);</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note info simple"><p>注意，这里披萨商店的实现，仍然是通过工厂方法模式。只是在<code>createPizza</code>函数中会实例化一个抽象工厂，并将其传递给对应的<code>Pizza</code>对象</p>
</div>
<h4 id="披萨类及其实例化-1"><a href="#披萨类及其实例化-1" class="headerlink" title="披萨类及其实例化"></a>披萨类及其实例化</h4><p>在披萨类的实例化中，我们使用了抽象工厂模式，披萨的实例化会包含一个披萨原料的抽象工厂，通过不同的披萨原料工厂来取得不同风味的披萨</p>
<figure class="highlight cs"><figcaption><span>披萨基类</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Pizza</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> Cheese cheese = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">protected</span> Sauce sauce = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">protected</span> Onion onion = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">prepare</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Bake for 25 minutes at 350&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cut</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Cutting the pizza into diagonal slices&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">box</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Place pizza in official PizzaStore box&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Debug</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">        Console.WriteLine(name);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Cheese is &quot;</span> + (cheese != <span class="literal">null</span> ? cheese.ToString() : <span class="string">&quot;Null&quot;</span>));</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Sauce is &quot;</span> + (sauce != <span class="literal">null</span> ? sauce.ToString() : <span class="string">&quot;Null&quot;</span>));</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Onion is &quot;</span> + (onion != <span class="literal">null</span> ? onion.ToString() : <span class="string">&quot;Null&quot;</span>));</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>披萨实现</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CheesePizza</span> : <span class="title">Pizza</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> PizzaIngredientFactory ingredientFactory = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CheesePizza</span>(<span class="params">PizzaIngredientFactory ingredientFactory</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.ingredientFactory = ingredientFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">prepare</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cheese = ingredientFactory.createCheese();</span><br><span class="line">        onion = ingredientFactory.createOnion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SaucePizza</span> : <span class="title">Pizza</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> PizzaIngredientFactory ingredientFactory = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SaucePizza</span>(<span class="params">PizzaIngredientFactory ingredientFactory</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.ingredientFactory = ingredientFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">prepare</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        sauce = ingredientFactory.createSauce();</span><br><span class="line">        onion = ingredientFactory.createOnion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试及结果-5"><a href="#测试及结果-5" class="headerlink" title="测试及结果"></a>测试及结果</h4><figure class="highlight cs"><figcaption><span>测试代码</span></figcaption><table><tr><td class="code"><pre><span class="line">PizzaStore pizzaStore = <span class="keyword">new</span> NYPizzaStore();</span><br><span class="line">Pizza pizza = pizzaStore.OrderPizza(<span class="string">&quot;cheese&quot;</span>);</span><br><span class="line">pizza.Debug();</span><br><span class="line">Console.WriteLine(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line">pizzaStore = <span class="keyword">new</span> ChicagoPizzaStore();</span><br><span class="line">pizza = pizzaStore.OrderPizza(<span class="string">&quot;cheese&quot;</span>);</span><br><span class="line">pizza.Debug();</span><br></pre></td></tr></table></figure>
<p>运行结果：<br><img src="HeadFirstDesignPatternNotes-1/2019-01-24-01-01-50.png" alt="抽象工厂模式运行结果"></p>
<div class="note info simple"><p>引用：</p>
<ol>
<li><a href="https://design-patterns.readthedocs.io/zh_CN/latest/">https://design-patterns.readthedocs.io/zh_CN/latest/</a></li>
<li><a href="https://dzone.com/articles/factory-method-vs-abstract">https://dzone.com/articles/factory-method-vs-abstract</a></li>
<li><a href="https://stackoverflow.com/questions/5739611/differences-between-abstract-factory-pattern-and-factory-method">https://stackoverflow.com/questions/5739611/differences-between-abstract-factory-pattern-and-factory-method</a></li>
</ol>
</div>
<hr>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>《Head First 设计模式》 笔记（二）</title>
    <url>/HeadFirstDesignPatternNotes-2/</url>
    <content><![CDATA[<p>这一篇将会介绍单例模式，命令模式，适配器模式，外观模式，迭代器模式及组合模式。</p>
<span id="more"></span>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式(Singleton Pattern)可能是最简单，也是被应用最为广泛的设计模式。单例模式保证一个类只会存在一个实例，并且提供了一个公共的接口来访问该实例。</p>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight cs"><figcaption><span>单例模式</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">object</span> lockObj = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">lock</span> (lockObj)</span><br><span class="line">                    <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">                        instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Constructor the Singleton&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里使用一个<code>lockObj</code>是为了保证多线程安全，如果有多个线程在同一时间第一次调用<code>Instance</code>，则可能存在两个线程都进入了<code>instance == null</code>的分支，这就会造成两次实例化，所以我们需要通过加锁来保证线程安全。但如果我们将锁直接加在第一个<code>If</code>外，则每次调用<code>Instance</code>都有一个加锁的过程，所以这里选择在第一个If内加锁，锁内再次检查保证只会有一次实例化。</p>
<hr>
<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>命令模式(Command Pattern)将一个请求封装为一个对象，进而将拥有不同的请求的物体参数化，并且还可以请求排队，打印请求日志，支持可逆操作。</p>
<p>命令模式由抽象命令类、具体命令类、接受者、调用者、客户类，五部分组成。其中接受者为被命令封装的类，调用者存放需要执行的类。</p>
<p>我们以一个远程控制装置作为例子，远程控制装置有两个按钮和一个撤回按钮。我们通过命令模式来将远程控制类与具体需要做的操作（如开灯）解耦。在例子中程序入口即为客户端，远程装置为调用者，灯为接受者，有开灯与关灯两个命令</p>
<h3 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h3><h4 id="抽象命令类及实现"><a href="#抽象命令类及实现" class="headerlink" title="抽象命令类及实现"></a>抽象命令类及实现</h4><figure class="highlight cs"><figcaption><span>抽象命令类</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Command</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Execute</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Undo</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>命令类实现</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LightOffCommand</span> : <span class="title">Command</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Light light;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LightOffCommand</span>(<span class="params">Light light</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.light = light;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        light.Off();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Undo</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        light.On();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LightOnCommand</span> : <span class="title">Command</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Light light;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LightOnCommand</span>(<span class="params">Light light</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.light = light;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        light.On();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Undo</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        light.Off();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NoCommand</span> : <span class="title">Command</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;No command execute&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Undo</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;No command undo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="接受者"><a href="#接受者" class="headerlink" title="接受者"></a>接受者</h4><figure class="highlight cs"><figcaption><span>灯</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Light</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">On</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;The light is on&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Off</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;The light is off&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="调用者"><a href="#调用者" class="headerlink" title="调用者"></a>调用者</h4><figure class="highlight cs"><figcaption><span>远程控制</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">RemoteControl</span></span><br><span class="line">&#123;</span><br><span class="line">    Command[] commands;</span><br><span class="line">    Command lastCommond;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RemoteControl</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        commands = <span class="keyword">new</span> Command[<span class="number">2</span>] &#123; <span class="keyword">new</span> NoCommand(), <span class="keyword">new</span> NoCommand() &#125;;</span><br><span class="line">        lastCommond = <span class="keyword">new</span> NoCommand();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetCommand</span>(<span class="params"><span class="built_in">int</span> index, Command command</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        commands[index] = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnButtonClick</span>(<span class="params"><span class="built_in">int</span> index</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        commands[index].Execute();</span><br><span class="line">        lastCommond = commands[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnClickUndo</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        lastCommond.Undo();</span><br><span class="line">        lastCommond = <span class="keyword">new</span> NoCommand();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="客户类"><a href="#客户类" class="headerlink" title="客户类"></a>客户类</h4><figure class="highlight cs"><figcaption><span>函数入口</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Light light = <span class="keyword">new</span> Light();</span><br><span class="line">    RemoteControl remoteControl = <span class="keyword">new</span> RemoteControl();</span><br><span class="line">    remoteControl.SetCommand(<span class="number">0</span>, <span class="keyword">new</span> LightOnCommand(light));</span><br><span class="line">    remoteControl.SetCommand(<span class="number">1</span>, <span class="keyword">new</span> LightOffCommand(light));</span><br><span class="line">    remoteControl.OnButtonClick(<span class="number">0</span>);</span><br><span class="line">    remoteControl.OnButtonClick(<span class="number">1</span>);</span><br><span class="line">    remoteControl.OnClickUndo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试及结果"><a href="#测试及结果" class="headerlink" title="测试及结果"></a>测试及结果</h3><p>运行结果：</p>
<p><img src="HeadFirstDesignPatternNotes-2/2019-02-02-23-26-25.png" alt="命令模式测试结果"></p>
<hr>
<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>适配器模式（Adapter Pattern）将一个类的接口转换为用户想要的另一个接口。适配器模式将原先因为接口不兼容的一些类可以一起工作。</p>
<p>例如我们有已经实现的火鸡类和鸭子类，其中鸭子的鸣叫我们使用<code>Quack</code>，火鸡的鸣叫我们用<code>Goggle</code>，两个接口不相同，但在某些情况下，我们不希望具体区分是火鸡还是鸭子，只希望他们都能叫，这时候就需要用适配器模式，将火鸡或鸭子伪装成同一个类。</p>
<h3 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h3><h4 id="鸭子及火鸡抽象接口及实现"><a href="#鸭子及火鸡抽象接口及实现" class="headerlink" title="鸭子及火鸡抽象接口及实现"></a>鸭子及火鸡抽象接口及实现</h4><figure class="highlight cs"><figcaption><span>鸭子接口</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Duck</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Quack</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Fly</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>鸭子实现</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MallardDuck</span> : <span class="title">Duck</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fly</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;MallardDuck Fly&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Quack</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;MallardDuck Quack&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>火鸡接口</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Turkey</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Gobble</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Fly</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>火鸡实现</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WildTurkey</span> : <span class="title">Turkey</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fly</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;WildTurkey Fly&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Gobble</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;WildTurkey Gobble&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="适配器类"><a href="#适配器类" class="headerlink" title="适配器类"></a>适配器类</h4><figure class="highlight cs"><figcaption><span>火鸡适配器</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TurkeyAdapter</span> : <span class="title">Duck</span></span><br><span class="line">&#123;</span><br><span class="line">    Turkey turkey;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TurkeyAdapter</span>(<span class="params">Turkey turkey</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.turkey = turkey;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fly</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i != <span class="number">5</span>; ++i)</span><br><span class="line">            turkey.Fly();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Quack</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        turkey.Gobble();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试代码及结果"><a href="#测试代码及结果" class="headerlink" title="测试代码及结果"></a>测试代码及结果</h3><figure class="highlight cs"><figcaption><span>测试代码</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    MallardDuck duck = <span class="keyword">new</span> MallardDuck();</span><br><span class="line">    WildTurkey turkey = <span class="keyword">new</span> WildTurkey();</span><br><span class="line">    TestDuck(duck);</span><br><span class="line">    TestDuck(<span class="keyword">new</span> TurkeyAdapter(turkey));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">TestDuck</span>(<span class="params">Duck duck</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    duck.Fly();</span><br><span class="line">    duck.Quack();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="HeadFirstDesignPatternNotes-2/2019-02-03-00-10-27.png" alt="适配器模式运行结果"></p>
<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p>外观模式(Facade Pattern)为子系统的一系列接口提供了一个统一的，更高级别的接口以简化外部的调用。</p>
<p>外观模式实际上是遵从于<code>最小知识原则</code>，对一些上层的类来说，它不需要了解下面子系统的具体构成，那么我们就用一个中间层（Facade）来将封装这些子系统，形成一个软解耦。</p>
<p>例如我们有一个家庭影院，在播放电影时我们需要打开DVD机，打开投影仪，打开放大器，打开音频协调器等，我们可以用一个<code>Facade</code>来将这些操作都封装起来，对于外部调用者来说仅有开始播放电影及关闭播放电影两步。</p>
<h3 id="代码示例-3"><a href="#代码示例-3" class="headerlink" title="代码示例"></a>代码示例</h3><h4 id="子系统"><a href="#子系统" class="headerlink" title="子系统"></a>子系统</h4><figure class="highlight cs"><figcaption><span>DVD机器</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DvdPlayer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">On</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="keyword">this</span>.GetType().ToString() + <span class="string">&quot; On&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Off</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="keyword">this</span>.GetType().ToString() + <span class="string">&quot; Off&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>投影仪</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Projector</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">On</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="keyword">this</span>.GetType().ToString() + <span class="string">&quot; On&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Off</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="keyword">this</span>.GetType().ToString() + <span class="string">&quot; Off&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>放大器</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Amplifier</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">On</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="keyword">this</span>.GetType().ToString() + <span class="string">&quot; On&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Off</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="keyword">this</span>.GetType().ToString() + <span class="string">&quot; Off&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>音频协调器</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Tuner</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">On</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="keyword">this</span>.GetType().ToString() + <span class="string">&quot; On&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Off</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="keyword">this</span>.GetType().ToString() + <span class="string">&quot; Off&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Facade"><a href="#Facade" class="headerlink" title="Facade"></a>Facade</h4><figure class="highlight cs"><figcaption><span>家庭影院外观者</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">HomeTheaderFacade</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Amplifier amplifier = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Tuner tuner = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> DvdPlayer dvdPlayer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Projector projector = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HomeTheaderFacade</span>(<span class="params">Amplifier amplifier, Tuner tuner, DvdPlayer dvdPlayer, Projector projector</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.amplifier = amplifier;</span><br><span class="line">        <span class="keyword">this</span>.tuner = tuner;</span><br><span class="line">        <span class="keyword">this</span>.dvdPlayer = dvdPlayer;</span><br><span class="line">        <span class="keyword">this</span>.projector = projector;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">WatchMovie</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        amplifier.On();</span><br><span class="line">        tuner.On();</span><br><span class="line">        dvdPlayer.On();</span><br><span class="line">        projector.On();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endMovie</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        amplifier.Off();</span><br><span class="line">        tuner.Off();</span><br><span class="line">        dvdPlayer.Off();</span><br><span class="line">        projector.Off();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试代码及结果-1"><a href="#测试代码及结果-1" class="headerlink" title="测试代码及结果"></a>测试代码及结果</h3><figure class="highlight cs"><figcaption><span>测试代码</span></figcaption><table><tr><td class="code"><pre><span class="line">HomeTheaderFacade facade = <span class="keyword">new</span> HomeTheaderFacade(<span class="keyword">new</span> Amplifier(), <span class="keyword">new</span> Tuner(), <span class="keyword">new</span> DvdPlayer(), <span class="keyword">new</span> Projector());</span><br><span class="line">facade.WatchMovie();</span><br><span class="line">Console.WriteLine();</span><br><span class="line">facade.endMovie();</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="HeadFirstDesignPatternNotes-2/2019-02-03-13-53-18.png" alt="外观模式运行结果"></p>
<hr>
<h2 id="模版方法模式"><a href="#模版方法模式" class="headerlink" title="模版方法模式"></a>模版方法模式</h2><p>模版方法模式（Template Method Pattern）定义了一个算法的操作步骤，但其中的某些步骤需要派生来对应实现。</p>
<ul>
<li><p>工厂方法&gt;模式就是模版方法模式的一种运用。</p>
</li>
<li><p>策略模式和模版方法模式都是将算法的实现抽象出来，不同的是策略模式的实现依靠组成，而模版方法模式依靠继承。</p>
</li>
</ul>
<p>例如我们需要准备咖啡和茶，准备咖啡基本步骤为烧开水，加入咖啡粉，将咖啡倒入杯子，增加牛奶或糖（可选），准备茶的基本步骤为烧开水，加入茶粉，将茶倒入杯子，增加柠檬（可选）。我们发现在制作两个饮料的过程中，烧开水和倒入杯子这两个步骤是一样的，剩下的两个步骤，向烧开的水中增加相应的粉和增加配料，这两部分也是类似的，于是我们可以用模版方法模式，将这两步骤作为抽象方法。</p>
<h3 id="代码示例-4"><a href="#代码示例-4" class="headerlink" title="代码示例"></a>代码示例</h3><h4 id="算法模版基类"><a href="#算法模版基类" class="headerlink" title="算法模版基类"></a>算法模版基类</h4><figure class="highlight cs"><figcaption><span>咖啡因饮料模版</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">CaffeineBeverage</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrepareRecipe</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        boilWater();</span><br><span class="line">        brew();</span><br><span class="line">        pourInCup();</span><br><span class="line">        <span class="keyword">if</span> (NeedCondiments())</span><br><span class="line">            addCondiments();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">brew</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">addCondiments</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">boilWater</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Boiling Water&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pourInCup</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Pouring Water&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">bool</span> <span class="title">NeedCondiments</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note info simple"><p>例子中<code>brew</code>和<code>addCondiments</code>即为模版函数，而<code>NeedCondiments</code>这种提供了基本实现，但派生类中仍然可以重写的函数被称为钩子（<code>Hook</code>）。</p>
</div>
<h4 id="咖啡因饮料实现"><a href="#咖啡因饮料实现" class="headerlink" title="咖啡因饮料实现"></a>咖啡因饮料实现</h4><figure class="highlight cs"><figcaption><span>咖啡</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Coffee</span> : <span class="title">CaffeineBeverage</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">addCondiments</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Add sugar and Milk&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">brew</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Dripping coffee through filter&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> <span class="title">NeedCondiments</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>茶</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Tea</span> : <span class="title">CaffeineBeverage</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">addCondiments</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Adding lemon&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">brew</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Steeping the tea&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试代码及结果-2"><a href="#测试代码及结果-2" class="headerlink" title="测试代码及结果"></a>测试代码及结果</h3><figure class="highlight cs"><figcaption><span>测试代码</span></figcaption><table><tr><td class="code"><pre><span class="line">Coffee coffee = <span class="keyword">new</span> Coffee();</span><br><span class="line">Tea tea = <span class="keyword">new</span> Tea();</span><br><span class="line">coffee.PrepareRecipe();</span><br><span class="line">Console.WriteLine();</span><br><span class="line">tea.PrepareRecipe();</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<p><img src="HeadFirstDesignPatternNotes-2/2019-02-03-15-59-58.png" alt="模版方法模式运行结果"></p>
<hr>
<h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>迭代器模式(Iterator Pattern)提供了一种访问聚合对象但不需要关心其内部实现方法的方式。</p>
<p>例如我们存在两个菜单，第一个菜单表示早餐，第二个表示晚餐，第一个菜单其中的菜品用<code>List</code>来存储，第二个菜单其中的菜品用<code>Array</code>来存储。在这种情况下就需要使用迭代器模式，为两个菜单提供一个供外部调用的访问菜品的接口。</p>
<h3 id="代码示例-5"><a href="#代码示例-5" class="headerlink" title="代码示例"></a>代码示例</h3><p>我们在两个菜单类中添加<code>createIterator</code>函数来返回迭代器，对于外部调用者，如测试代码中的<code>PrintMenu</code>,它只需要调用<code>hasNext</code>及<code>next</code>即可而不需要关心菜单中的具体实现。</p>
<h4 id="菜单"><a href="#菜单" class="headerlink" title="菜单"></a>菜单</h4><figure class="highlight cs"><figcaption><span>Pancake菜单</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PancakeHouseMenu</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;MenuItem&gt; menuItemsList = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PancakeHouseMenu</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        menuItemsList = <span class="keyword">new</span> List&lt;MenuItem&gt;();</span><br><span class="line">        addItem(<span class="string">&quot;K&amp;B&#x27;s Pancake Breakfast&quot;</span>, <span class="string">&quot;Pancake with eggs and toast&quot;</span>, <span class="literal">true</span>, <span class="number">2.99f</span>);</span><br><span class="line">        addItem(<span class="string">&quot;Regular&#x27;s Pancake Breakfast&quot;</span>, <span class="string">&quot;Pancake with eggs and sausags&quot;</span>, <span class="literal">true</span>, <span class="number">2.99f</span>);</span><br><span class="line">        addItem(<span class="string">&quot;Blueberry&#x27;s Pancake Breakfast&quot;</span>, <span class="string">&quot;Pancake with eggs and fresh blueberries&quot;</span>, <span class="literal">true</span>, <span class="number">2.99f</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">createIterator</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PancakeIterator(menuItemsList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addItem</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">string</span> description, <span class="built_in">bool</span> vegetarian, <span class="built_in">float</span> price</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        MenuItem menuItem = <span class="keyword">new</span> MenuItem(name, description, vegetarian, price);</span><br><span class="line">        menuItemsList.Add(menuItem);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>Diner菜单</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DinerMenu</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">int</span> MaxItemsCount = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">private</span> MenuItem[] menuItemsArray = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> numberOfItems = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DinerMenu</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        menuItemsArray = <span class="keyword">new</span> MenuItem[MaxItemsCount];</span><br><span class="line">        addItem(<span class="string">&quot;Vegetarian BLT&quot;</span>, <span class="string">&quot;Fakin Bacon with tomato&quot;</span>, <span class="literal">true</span>, <span class="number">2.99f</span>);</span><br><span class="line">        addItem(<span class="string">&quot;BLT&quot;</span>, <span class="string">&quot;Bacon with tomato&quot;</span>, <span class="literal">true</span>, <span class="number">3.99f</span>);</span><br><span class="line">        addItem(<span class="string">&quot;Soup of the day&quot;</span>, <span class="string">&quot;Soup of the day and salad&quot;</span>, <span class="literal">false</span>, <span class="number">3.29f</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addItem</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">string</span> description, <span class="built_in">bool</span> vegetarian, <span class="built_in">float</span> price</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (numberOfItems &gt;= MaxItemsCount)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        MenuItem menuItem = <span class="keyword">new</span> MenuItem(name, description, vegetarian, price);</span><br><span class="line">        menuItemsArray[numberOfItems++] = menuItem;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">createIterator</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DinerMenuIterator(menuItemsArray);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="迭代器接口及实现"><a href="#迭代器接口及实现" class="headerlink" title="迭代器接口及实现"></a>迭代器接口及实现</h4><figure class="highlight cs"><figcaption><span>迭代器接口</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Iterator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">bool</span> <span class="title">hasNext</span>()</span>;</span><br><span class="line">    <span class="function"><span class="built_in">object</span> <span class="title">next</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>迭代器实现</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PancakeIterator</span> : <span class="title">Iterator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;MenuItem&gt; itemsList = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> currentPosition = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PancakeIterator</span>(<span class="params">List&lt;MenuItem&gt; itemsList</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.itemsList = itemsList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">hasNext</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> currentPosition &lt; itemsList.Count &amp;&amp; itemsList[currentPosition] != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">next</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> itemsList[currentPosition++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DinerMenuIterator</span> : <span class="title">Iterator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> MenuItem[] itemsArray = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> currentPosition = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DinerMenuIterator</span>(<span class="params">MenuItem[] items</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.itemsArray = items;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">hasNext</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> currentPosition &lt; itemsArray.Length &amp;&amp; itemsArray[currentPosition] != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">next</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> itemsArray[currentPosition++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试代码及结果-3"><a href="#测试代码及结果-3" class="headerlink" title="测试代码及结果"></a>测试代码及结果</h3><figure class="highlight cs"><figcaption><span>测试代码</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    DinerMenu dinerMenu = <span class="keyword">new</span> DinerMenu();</span><br><span class="line">    PancakeHouseMenu pancakeHouseMenu = <span class="keyword">new</span> PancakeHouseMenu();</span><br><span class="line"></span><br><span class="line">    PrintMenu(dinerMenu.createIterator());</span><br><span class="line">    Console.WriteLine();</span><br><span class="line">    PrintMenu(pancakeHouseMenu.createIterator());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintMenu</span>(<span class="params">Iterator iterator</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())</span><br><span class="line">    &#123;</span><br><span class="line">        ((MenuItem)iterator.next()).Debug();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="HeadFirstDesignPatternNotes-2/2019-02-03-23-36-01.png" alt="迭代器模式运行结果"></p>
<hr>
<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>组合模式（Composite Pattern）是用树形结构来组合对象进而体现一种局部-整体的层次结构。组合模式可以让调用者以统一的方式对待单个物体和多个物体的组合。</p>
<p>例如我们需要打印一个菜单上的所有菜品，但菜单中可能还包含子菜单，子菜单中又可能包含子菜单等等，但对于外部调用者而言则不希望关注这些细节。我们可以通过定义一个基类，无论是菜品还是菜单都继承自这个基类，这样对于菜单而言，无论是子菜单还是菜品都是同一个基类，可一起管理。对于外部调者而言只x需要关心这个基类即可。</p>
<h3 id="代码示例-6"><a href="#代码示例-6" class="headerlink" title="代码示例"></a>代码示例</h3><h4 id="共同抽象类基类"><a href="#共同抽象类基类" class="headerlink" title="共同抽象类基类"></a>共同抽象类基类</h4><figure class="highlight cs"><figcaption><span>菜单元素</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">MenuComponent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params">MenuComponent menuComponent</span>)</span> &#123; <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Remove</span>(<span class="params">MenuComponent menuComponent</span>)</span> &#123; <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> MenuComponent <span class="title">GetChild</span>(<span class="params"><span class="built_in">int</span> i</span>)</span> &#123; <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">protected</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">string</span> Description &#123; <span class="keyword">get</span>; <span class="keyword">protected</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">float</span> Price &#123; <span class="keyword">get</span>; <span class="keyword">protected</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">bool</span> Vegetarian &#123; <span class="keyword">get</span>; <span class="keyword">protected</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Debug</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(Name + <span class="string">&quot; , &quot;</span> + Description + <span class="string">&quot; , &quot;</span> + Vegetarian + <span class="string">&quot; , &quot;</span> + Price);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="菜单及菜品实现"><a href="#菜单及菜品实现" class="headerlink" title="菜单及菜品实现"></a>菜单及菜品实现</h4><figure class="highlight cs"><figcaption><span>菜单</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Menu</span> : <span class="title">MenuComponent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;MenuComponent&gt; menuComponetsList = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Menu</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">string</span> description</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        menuComponetsList = <span class="keyword">new</span> List&lt;MenuComponent&gt;();</span><br><span class="line">        Name = name;</span><br><span class="line">        Description = description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params">MenuComponent menuComponent</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        menuComponetsList.Add(menuComponent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Remove</span>(<span class="params">MenuComponent menuComponent</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        menuComponent.Remove(menuComponent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> MenuComponent <span class="title">GetChild</span>(<span class="params"><span class="built_in">int</span> i</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> menuComponetsList[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Debug</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(Name + <span class="string">&quot; , &quot;</span> + Description);</span><br><span class="line">        menuComponetsList.ForEach(menuComponent =&gt; menuComponent.Debug());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>菜品</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MenuItem</span> : <span class="title">MenuComponent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MenuItem</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">string</span> description, <span class="built_in">bool</span> vegetarian, <span class="built_in">float</span> price</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Name = name;</span><br><span class="line">        Description = description;</span><br><span class="line">        Vegetarian = vegetarian;</span><br><span class="line">        Price = price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试代码及结果-4"><a href="#测试代码及结果-4" class="headerlink" title="测试代码及结果"></a>测试代码及结果</h3><figure class="highlight cs"><figcaption><span>测试代码</span></figcaption><table><tr><td class="code"><pre><span class="line">Menu menu = <span class="keyword">new</span> Menu(<span class="string">&quot;General Menu&quot;</span>, <span class="string">&quot;Holds all menus and menu items&quot;</span>);</span><br><span class="line">Menu dinnerMenu = <span class="keyword">new</span> Menu(<span class="string">&quot;Dinner Menu&quot;</span>, <span class="string">&quot;Holds dinner menu items&quot;</span>);</span><br><span class="line">Menu breakfastMenu = <span class="keyword">new</span> Menu(<span class="string">&quot;Breakfast Menu&quot;</span>, <span class="string">&quot;Holds Breakfast menu items&quot;</span>);</span><br><span class="line">menu.Add(dinnerMenu);</span><br><span class="line">menu.Add(breakfastMenu);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">breakfastMenu.Add(<span class="keyword">new</span> MenuItem(<span class="string">&quot;K&amp;B&#x27;s Pancake Breakfast&quot;</span>, <span class="string">&quot;Pancake with eggs and toast&quot;</span>, <span class="literal">true</span>, <span class="number">2.99f</span>));</span><br><span class="line">breakfastMenu.Add(<span class="keyword">new</span> MenuItem(<span class="string">&quot;Regular&#x27;s Pancake Breakfast&quot;</span>, <span class="string">&quot;Pancake with eggs and sausags&quot;</span>, <span class="literal">true</span>, <span class="number">2.99f</span>));</span><br><span class="line">breakfastMenu.Add(<span class="keyword">new</span> MenuItem(<span class="string">&quot;Blueberry&#x27;s Pancake Breakfast&quot;</span>, <span class="string">&quot;Pancake with eggs and fresh blueberries&quot;</span>, <span class="literal">true</span>, <span class="number">2.99f</span>));</span><br><span class="line"></span><br><span class="line">dinnerMenu.Add(<span class="keyword">new</span> MenuItem(<span class="string">&quot;Vegetarian BLT&quot;</span>, <span class="string">&quot;Fakin Bacon with tomato&quot;</span>, <span class="literal">true</span>, <span class="number">2.99f</span>));</span><br><span class="line">dinnerMenu.Add(<span class="keyword">new</span> MenuItem(<span class="string">&quot;BLT&quot;</span>, <span class="string">&quot;Bacon with tomato&quot;</span>, <span class="literal">true</span>, <span class="number">3.99f</span>));</span><br><span class="line">dinnerMenu.Add(<span class="keyword">new</span> MenuItem(<span class="string">&quot;Soup of the day&quot;</span>, <span class="string">&quot;Soup of the day and salad&quot;</span>, <span class="literal">false</span>, <span class="number">3.29f</span>));</span><br><span class="line"></span><br><span class="line">menu.Debug();</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="HeadFirstDesignPatternNotes-2/2019-02-06-16-23-58.png" alt="组合模式运行结果"></p>
<div class="note info simple"><p>引用：</p>
<ol>
<li><a href="https://design-patterns.readthedocs.io/zh_CN/latest/behavioral_patterns/behavioral.html">https://design-patterns.readthedocs.io/zh_CN/latest/behavioral_patterns/behavioral.html</a></li>
</ol>
</div>
<hr>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>《Head First 设计模式》 笔记（三）</title>
    <url>/HeadFirstDesignPatternNotes-3/</url>
    <content><![CDATA[<p>这一篇将会介绍状态模式，代理模式和复合模式并整理了书中提到了9个设计原则。</p>
<span id="more"></span>
<h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><p>状态模式(State Pattern)允许一个对象根据其内部状态的变化来选择需要执行的操作。这个对象会看起来像是改变了它的类。</p>
<p>状态模式定义听起来有些奇怪，实际上就是将不同状态的行为定义在不同的状态类中，然后根据状态的不同切换这些状态类，进而达到不同的行为。</p>
<p>例如我们需要做一个口香糖贩卖机需要处理，投钱、退钱、旋转出货按钮这三个操作，然后机器有未投钱、投钱、货物卖出、货物卖完四个状态。我们可以将不同状态下对三个操作的处理定义在各自的状态类中。</p>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><h4 id="状态类接口"><a href="#状态类接口" class="headerlink" title="状态类接口"></a>状态类接口</h4><figure class="highlight cs"><figcaption><span>状态类接口</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">State</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InsertQuarter</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">EjectQuarter</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TurnCrank</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Dispense</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="状态类实现"><a href="#状态类实现" class="headerlink" title="状态类实现"></a>状态类实现</h4><figure class="highlight cs"><figcaption><span>未投钱状态</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NoQuarterState</span> : <span class="title">State</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> GumballMachine gumballMachine = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NoQuarterState</span>(<span class="params">GumballMachine gumballMachine</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.gumballMachine = gumballMachine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispense</span>()</span> &#123; Console.WriteLine(<span class="string">&quot;You need to pay first&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">EjectQuarter</span>()</span> &#123; Console.WriteLine(<span class="string">&quot;You haven&#x27;t inserted a quarter&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InsertQuarter</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        gumballMachine.SetState(gumballMachine.HasQuarterState);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;You inserted a quarter&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TurnCrank</span>()</span> &#123; Console.WriteLine(<span class="string">&quot;You turned,but there&#x27;s no quarter&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>投钱状态</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HasQuarterState</span> : <span class="title">State</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> GumballMachine gumballMachine = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HasQuarterState</span>(<span class="params">GumballMachine gumballMachine</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.gumballMachine = gumballMachine;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispense</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;No gumball dispensed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">EjectQuarter</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Quarter returned&quot;</span>);</span><br><span class="line">        gumballMachine.SetState(gumballMachine.NoQuarterState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InsertQuarter</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;You can&#x27;t insert another quater&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TurnCrank</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;You turned&quot;</span>);</span><br><span class="line">        gumballMachine.SetState(gumballMachine.SoldState);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>货物卖出状态</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SoldState</span> : <span class="title">State</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> GumballMachine gumballMachine = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SoldState</span>(<span class="params">GumballMachine gumballMachine</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.gumballMachine = gumballMachine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispense</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        gumballMachine.ReleaseBall();</span><br><span class="line">        <span class="keyword">if</span> (gumballMachine.remainGumballsNum &gt; <span class="number">0</span>)</span><br><span class="line">            gumballMachine.SetState(gumballMachine.NoQuarterState);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Opps,out of gumballs&quot;</span>);</span><br><span class="line">            gumballMachine.SetState(gumballMachine.SoldOutState);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">EjectQuarter</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Sorry,you already turned the crank&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InsertQuarter</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Please wait,we are already giving you a gumball&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TurnCrank</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Turning twice dones&#x27;t get you another gumball&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>货物售完状态</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SoldOutState</span> : <span class="title">State</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> GumballMachine gumballMachine = <span class="literal">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SoldOutState</span>(<span class="params">GumballMachine gumballMachine</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.gumballMachine = gumballMachine;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispense</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;No gumball dispensed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">EjectQuarter</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;You can&#x27;t eject,you haven&#x27;t inserted a quarter yet&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InsertQuarter</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;You can&#x27;t insert a quarter,the machine is sold out&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TurnCrank</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;You turned,but there are no gumballs&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试代码及结果"><a href="#测试代码及结果" class="headerlink" title="测试代码及结果"></a>测试代码及结果</h3><figure class="highlight cs"><figcaption><span>测试代码</span></figcaption><table><tr><td class="code"><pre><span class="line">GumballMachine gumballMachine = <span class="keyword">new</span> GumballMachine(<span class="number">5</span>);</span><br><span class="line">gumballMachine.TurnCrank();</span><br><span class="line">gumballMachine.InsertQuarter();</span><br><span class="line">gumballMachine.EjectQuarter();</span><br><span class="line">gumballMachine.TurnCrank();</span><br><span class="line">gumballMachine.InsertQuarter();</span><br><span class="line">gumballMachine.TurnCrank();</span><br><span class="line">gumballMachine.TurnCrank();</span><br><span class="line">gumballMachine.EjectQuarter();</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="HeadFirstDesignPatternNotes-3/2019-02-06-20-10-15.png" alt="状态模式运行结果"></p>
<hr>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理模式（Proxy Pattern）为对象提供一个代理进而控制对其的访问。</p>
<p>例如我们需要加载一张图片，但加载图片是个访问网络或IO的操作，我们不希望这个这个操作阻塞UI线程，于是我们可以定义一个代理来进行多线程的加载，并在加载完成后显示图片。</p>
<h3 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h3><h4 id="抽象接口"><a href="#抽象接口" class="headerlink" title="抽象接口"></a>抽象接口</h4><figure class="highlight cs"><figcaption><span>图片接口</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Icon</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrintIconWidthAndHeight</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="抽象接口实现"><a href="#抽象接口实现" class="headerlink" title="抽象接口实现"></a>抽象接口实现</h4><figure class="highlight cs"><figcaption><span>真实图片类</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ImageIcon</span> : <span class="title">Icon</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> width, height;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImageIcon</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Thread.Sleep(<span class="number">5000</span>);<span class="comment">//Pretend there is some hard work to load the image</span></span><br><span class="line">        width = <span class="number">800</span>;</span><br><span class="line">        height = <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintIconWidthAndHeight</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(DateTime.Now.ToLongTimeString() + <span class="string">&quot;: Width is &quot;</span> + width + <span class="string">&quot;,height is &quot;</span> + height);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>代理图片类</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ImageProxyIcon</span> : <span class="title">Icon</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> ImageIcon icon = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> isLoading = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImageProxyIcon</span>()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintIconWidthAndHeight</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (icon != <span class="literal">null</span>)</span><br><span class="line">            icon.PrintIconWidthAndHeight();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!isLoading)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(DateTime.Now.ToLongTimeString() + <span class="string">&quot;: Is Loading Image...&quot;</span>);</span><br><span class="line">            isLoading = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">new</span> Thread(() =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                icon = <span class="keyword">new</span> ImageIcon();</span><br><span class="line">                icon.PrintIconWidthAndHeight();</span><br><span class="line">            &#125;).Start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试代码及结果-1"><a href="#测试代码及结果-1" class="headerlink" title="测试代码及结果"></a>测试代码及结果</h3><figure class="highlight cs"><figcaption><span>测试代码</span></figcaption><table><tr><td class="code"><pre><span class="line">ImageProxyIcon proxyIcon = <span class="keyword">new</span> ImageProxyIcon();</span><br><span class="line">proxyIcon.PrintIconWidthAndHeight();</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="HeadFirstDesignPatternNotes-3/2019-02-07-14-10-11.png" alt="代理模式运行结果"></p>
<div class="note info simple"><p>代理模式与装饰模式很像，不同的是装饰模式的目的是在原先的类外扩展某些功能，而代理模式只是控制原先类中某些接口的访问。例如上例子中，<code>ImageProxyIcon</code>并没有为<code>ImageIcon</code>拓展什么功能，只是用了多线程来访问访问其中的函数。</p>
</div>
<hr>
<h2 id="复合模式"><a href="#复合模式" class="headerlink" title="复合模式"></a>复合模式</h2><p>复合模式（Compound Pattern）是通过两个或以上的设计模式形成一个可以解决一般性问题的通用框架。</p>
<p>MVC框架就是一种组合模式，<code>Controller</code>和<code>View</code>之间使用了策略模式， <code>View</code>中只存<code>Controller</code>的接口，进而达到可以随时切换不同<code>Controller</code>的目的。<code>Model</code>和<code>View</code>之间使用了观察者模式，<code>View</code>作为观察者，<code>Model</code>作为被观察者，当<code>Model</code>的数据发生变化时，<code>View</code>相应改变。而<code>View</code>本身使用了组合模式，比如按钮中可能存在子按钮，窗口中存在子窗口等等。</p>
<p>我们以音量调节作为一个最简的MVC框架示例。</p>
<h3 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h3><h4 id="框架接口"><a href="#框架接口" class="headerlink" title="框架接口"></a>框架接口</h4><figure class="highlight cs"><figcaption><span>观察者接口</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IVolumeObserver</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">VolumeUpdated</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>Model接口</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IVolumeModel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> Volume &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RegisterObserver</span>(<span class="params">IVolumeObserver observer</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">UnRegisterObserver</span>(<span class="params">IVolumeObserver observer</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>Controller接口</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IViewController</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">VolumeUp</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">VolumeDown</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetVolume</span>(<span class="params"><span class="built_in">int</span> volume</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="接口实现"><a href="#接口实现" class="headerlink" title="接口实现"></a>接口实现</h4><figure class="highlight cs"><figcaption><span>Model</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">VolumeModel</span> : <span class="title">IVolumeModel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> volume = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Volume</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> volume; &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            volume = <span class="keyword">value</span>;</span><br><span class="line">            observersList.ForEach(observer =&gt; observer.VolumeUpdated());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> List&lt;IVolumeObserver&gt; observersList = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VolumeModel</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        observersList = <span class="keyword">new</span> List&lt;IVolumeObserver&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RegisterObserver</span>(<span class="params">IVolumeObserver observer</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        observersList.Add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UnRegisterObserver</span>(<span class="params">IVolumeObserver observer</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        observersList.Remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>View</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">VolumeView</span> : <span class="title">IVolumeObserver</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IViewController controller = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> IVolumeModel model = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VolumeView</span>(<span class="params">IViewController controller, IVolumeModel model</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.controller = controller;</span><br><span class="line">        <span class="keyword">this</span>.model = model;</span><br><span class="line">        <span class="keyword">this</span>.model.RegisterObserver(<span class="keyword">this</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;View: volume init is &quot;</span> + model.Volume);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnVolumeUpButtonClick</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        controller.VolumeUp();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnVolumeDownButtonClick</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        controller.VolumeDown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">VolumeUpdated</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;View: volume updated &quot;</span> + model.Volume);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~VolumeView()</span><br><span class="line">    &#123;</span><br><span class="line">        model.UnRegisterObserver(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>Controller</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">VolumeController</span> : <span class="title">IViewController</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> VolumeModel model = <span class="literal">null</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">VolumeController</span>(<span class="params">VolumeModel model</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.model = model;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetVolume</span>(<span class="params"><span class="built_in">int</span> volume</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            model.Volume = volume;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">VolumeDown</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            --model.Volume;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">VolumeUp</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            ++model.Volume;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试代码及结果-2"><a href="#测试代码及结果-2" class="headerlink" title="测试代码及结果"></a>测试代码及结果</h3><figure class="highlight cs"><figcaption><span>测试代码</span></figcaption><table><tr><td class="code"><pre><span class="line">VolumeModel model = <span class="keyword">new</span> VolumeModel();</span><br><span class="line">VolumeView view = <span class="keyword">new</span> VolumeView(<span class="keyword">new</span> VolumeController(model), model);</span><br><span class="line">view.OnVolumeUpButtonClick();</span><br><span class="line">view.OnVolumeUpButtonClick();</span><br><span class="line">view.OnVolumeDownButtonClick();</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="HeadFirstDesignPatternNotes-3/2019-02-07-15-53-23.png" alt="复合模式运行结果"></p>
<hr>
<h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><ol>
<li>将变化的部分封装起来（Encapsulate what varies)</li>
<li>组合优于继承（Favor composition over inheritance）</li>
<li>面向接口编程而非实现（Program to interfaces, not implementations.）</li>
<li>减少需要交互的类之间的耦合（Strive for loosely coupled designs between objects that interact）</li>
<li>对拓展开放，对修改关闭（Classes should be open for extension but closed for modification.）</li>
<li>依赖于抽象而非具体的类（    Depend on abstraction.Do not depend on concrete classes）</li>
<li>暴露最少的信息给其他类（最少知识原则）（Talk only to your immediate friends）</li>
<li>高层有对底层的管理，而底层不需要关心高层何时会调用自己（好莱坞原则）（Don’t call us ,we’ll call you）</li>
<li>一个类应该有且只有一个被改变的理由（A class should have only one reason to change）</li>
</ol>
<div class="note info simple"><p>引用：</p>
<ol>
<li><a href="https://design-patterns.readthedocs.io/zh_CN/latest/behavioral_patterns/behavioral.html">https://design-patterns.readthedocs.io/zh_CN/latest/behavioral_patterns/behavioral.html</a></li>
</ol>
</div>
<hr>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo教程（一）</title>
    <url>/HexoTutorial-1/</url>
    <content><![CDATA[<p>从大学开始就有通过Onenote整理笔记的习惯，也多次想过将自己的笔记分享出去。曾尝试过微信的公众号，但公众号的编辑器没法完全保存Onenote笔记的格式，发现每次发布都需要大量的时间去调整格式后便做了罢。之后想要建立个人博客，但苦于完全没有网站前端的开发经验便一拖再拖。最近也是才发现有Hexo这么一个搭建网站的框架便开始了再次尝试。这篇及之后的关于Hexo的文章与其说是教程更像是笔记，只是在学习Hexo时的一些记录罢了。</p>
<p>这一篇将包括Hexo环境安装，本地博客的创建，上传至Github域名三部分的介绍</p>
<span id="more"></span>
<h2 id="Hexo环境安装"><a href="#Hexo环境安装" class="headerlink" title="Hexo环境安装"></a>Hexo环境安装</h2><ol>
<li>安装<a href="https://nodejs.org/en/">Node.js</a></li>
<li>安装<a href="https://git-scm.com/">Git</a></li>
<li>安装Hexo cmd运行 <code>npm install -g hexo-cli</code></li>
</ol>
<p>这里不做关于Git的介绍。</p>
<h2 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h2><ol>
<li><p>新建Hexo网站文件夹</p>
<p>在需要保存Hexo网站文件夹的地方，运行<code>git bash</code>,输入<code>hexo init &lt;folderName&gt;</code>。Hexo会通过<code>git</code>自动拉去需要的文件，如果在安装过程中有错误显示，<code>cd</code>进创建出来的文件夹目录下，然后运行<code>npm install</code>补安装缺少的文件。</p>
</li>
<li><p>新建出来的文件夹目录如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成网站页面</p>
<p>运行<code>hexo generate</code>，运行后在目录下会新生成<code>public</code>文件夹,该文件夹即为网页的数据文件夹</p>
</li>
<li><p>测试网站</p>
<p>运行<code>Hexo server</code>,将生成一个本地的Hexo Host，将<code>http://localhost:4000</code>复制到游览器即可预览</p>
<p>也可以通过<code>Hexo server -p &lt;port&gt;</code>来指定生成本地Host的端口</p>
<p><img src="HexoTutorial-1/2018-12-17-00-29-25.png" alt="Hexo Server 运行后结果"></p>
</li>
<li><p>创建草稿</p>
<p> 在正式的发布文章前，我们可以先创建草稿</p>
<p> 运行<code>hexo new draft &#39;draftName&#39;</code>在<code>_draft</code>文件夹下创建名字为’draftName’的草稿文本。</p>
</li>
<li><p>测试草稿</p>
<p> <code>hexo server</code>创建的测试网站，默认是不渲染草稿的，如果需要渲染草稿需要加上后缀<code>hexo server --draft</code></p>
</li>
<li><p>发布草稿</p>
<p> <code>hexo publish post &#39;draftName&#39;</code>将名为’draftName’的草稿发布为文章，所有的文章存储与<code>_posts</code>文件夹下。</p>
</li>
<li><p>创建文章</p>
<p> 如果需要直接创建文章，可使用命令<code>hexo new post &#39;PostsName&#39;</code></p>
</li>
</ol>
<h2 id="文件夹及目录介绍"><a href="#文件夹及目录介绍" class="headerlink" title="文件夹及目录介绍"></a>文件夹及目录介绍</h2><ol>
<li><p>scaffolds 文件夹</p>
<p>模版文件夹，当用Hexo新建一个md文件时，Hexo会根据这个文件夹下的模版决定新生成的md文件默认有哪些内容。</p>
</li>
<li><p>source 文件夹</p>
<p>资源文件夹，在网站上显示的内容都在这个文件夹下，在刚生成的目录下，只有一个<code>_posts</code>，其中存放提交的文章</p>
</li>
<li><p>themes 文件夹</p>
<p>主题文件夹</p>
</li>
<li><p>_config.yml</p>
<p>配置文件</p>
</li>
</ol>
<h2 id="Github上传博客"><a href="#Github上传博客" class="headerlink" title="Github上传博客"></a>Github上传博客</h2><ol>
<li><p>新建工程以生成外网路径</p>
<p>注意工程的名字必须为<code>&lt;Owner&gt;.github.io</code><br><img src="HexoTutorial-1/2018-12-17-23-45-06.png" alt="新建工程"></p>
<p>新工程会自动生成一个外部访问的网址，点开Setting即可看到</p>
<p><img src="HexoTutorial-1/2018-12-17-23-48-14.png" alt="点开Setting"></p>
<p>下图红框地址即为最终博客的地址</p>
<p><img src="HexoTutorial-1/2018-12-17-23-48-35.png" alt="地址"></p>
</li>
<li><p>配置Hexo至Github工程</p>
<p>在<code>_config.xml</code>文件下添加</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"> <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line"> <span class="attr">repository:</span> <span class="string">git@github.com:xuejiaW/xuejiaW.github.io.git</span></span><br><span class="line"> <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>
<ul>
<li>注意page页面只能是master，hexo源码可以保存在自己新建的任意分支</li>
</ul>
</li>
<li><p>运行<code>npm install hexo-deployer-git --save</code>安装部署插件</p>
</li>
<li><p>运行<code>hexo deploy</code>将数据部署到网站</p>
<ul>
<li>注意：有时候部署后，发现本地发生了变化，但是网站上没有变化，此时运行先运行 <code>hexo clean</code>再<code>hexo deploy</code></li>
</ul>
</li>
<li><p>访问地址</p>
<p> 将上面看到的路径复制到游览器中即可看到自己的博客效果。</p>
<p> <img src="HexoTutorial-1/2018-12-31-14-35-49.png" alt="搭建效果"></p>
</li>
</ol>
<hr>
]]></content>
      <categories>
        <category>教程</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo教程（二）</title>
    <url>/HexoTutorial-2/</url>
    <content><![CDATA[<p>这一篇我们将学习使用主题，<code>themes</code>文件夹即为主题文件存在的路径。Hexo安装后自带了<code>landscape</code>主题，在Hexo官网上也有多个主题供选择，这里我选择了较为经典的模版<code>nexT</code>，<code>nexT</code>的<a href="http://theme-next.iissnan.com/">官网文档</a>可能因为较长时间未更新，文档的中的一些配置已经无法在最新（本文创建时为V6.7.0）的<code>nexT</code>中生效，所以本文的一些内容会与官网文档不同。</p>
<span id="more"></span>
<p>Hexo工程中一般存在多个<code>_config.yml</code>文件在Hexo目录下会存在一个，在每一个主题的文件夹下还有一个。我们将存在于Hexo目录下的配置文件叫做 <strong>站点配置文件</strong>,存在于主题文件夹下的叫做 <strong>主题配置文件</strong> 。</p>
<h2 id="安装nexT主题"><a href="#安装nexT主题" class="headerlink" title="安装nexT主题"></a>安装nexT主题</h2><p>在Hexo目录下，运行<code>git clone https://github.com/iissnan/hexo-theme-next themes/next</code>命令即可下载nexT工程，在下载完成后，打开站点配置文件，并找到<code>theme</code>字段，将其属性改为next即表示开始使用nexT主题</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure>
<h2 id="选择主题模版"><a href="#选择主题模版" class="headerlink" title="选择主题模版"></a>选择主题模版</h2><p>nexT自带有四个模版<code>Muse</code>,<code>Mist</code>,<code>Pisces</code>,<code>Gemini</code>,可以在主题配置文件中找到字段<code>scheme</code>，并进行相应的修改</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">scheme:</span> <span class="string">Pisces</span></span><br></pre></td></tr></table></figure>
<h2 id="配置站点语言"><a href="#配置站点语言" class="headerlink" title="配置站点语言"></a>配置站点语言</h2><p>我们可以修改博客的语言版本，在站点配置文件中找到<code>language</code>字段，并修改为自己想要的语言版本。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br></pre></td></tr></table></figure>
<p>支持的语言版本由主题文件来决定，在主题文件夹下存在<code>languages</code>文件夹，下面存放了该主题所支持的语言。如nexT所支持的语言为：</p>
<p><img src="HexoTutorial-2/2019-01-05-17-32-08.png" alt="nexT支持语言"></p>
<h2 id="Menu菜单"><a href="#Menu菜单" class="headerlink" title="Menu菜单"></a>Menu菜单</h2><p>默认的Menu菜单只有归档和首页两个页面，如果要增加更多的页面，在主题配置文件的<code>menu</code>字段中加入即可，字段的格式如下。其中Icon为<a href="http://fontawesome.dashgame.com/">Font Awesome</a>图标，名字与<code>Font Awesome</code>对应即可</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line"><span class="comment"># &lt;KEY&gt; : &lt;Link&gt; || &lt;Icon&gt;</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br></pre></td></tr></table></figure>
<h2 id="侧边栏"><a href="#侧边栏" class="headerlink" title="侧边栏"></a>侧边栏</h2><p>在主题配置文件中修改<code>sidebar</code>字段开控制侧边栏行为，比如<code>position</code>表示显示的位置，<code>display</code>表示显示的时机</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">sidebar:</span></span><br><span class="line">  <span class="comment"># 侧边栏显示在左侧</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">left</span></span><br><span class="line">  <span class="comment">#只在文章存在目录的情况下显示侧边栏</span></span><br><span class="line">  <span class="attr">display:</span> <span class="string">post</span></span><br></pre></td></tr></table></figure>
<p>侧边栏中的头像可在主题配置文件中的<code>avatar</code>字段中修改</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="comment"># 使用本地图片时，将图片放在source目录下的uploads或images目录下（必须是这两个目录名字）</span></span><br><span class="line">  <span class="comment">#网络图片，直接将图片的url赋值即可</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">/uploads/blackCat.jpg</span></span><br></pre></td></tr></table></figure>
<p>侧边栏的作者昵称和站点描述可分别在站点配置文件中的<code>author</code>和<code>description</code>中修改</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">description:</span> <span class="string">To</span> <span class="string">see</span> <span class="string">the</span> <span class="string">world</span> <span class="string">as</span> <span class="string">it</span> <span class="string">is,</span> <span class="string">and</span> <span class="string">to</span> <span class="string">love</span> <span class="string">it.</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">三叔</span></span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>教程</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo教程（三）</title>
    <url>/HexoTutorial-3/</url>
    <content><![CDATA[<p>这一篇主要是说明标签页面和分类页面如何创建以及一些针对主题的细枝末节的修改。本篇文章也将持续更新，在每次网站主题修改后，都将在本篇中记录修改方法。</p>
<span id="more"></span>
<h2 id="创建标签页面"><a href="#创建标签页面" class="headerlink" title="创建标签页面"></a>创建标签页面</h2><p>先运行<code>hexo new post tags</code>创建tag页面资源，再在主题配置文件中找到<code>menu</code>字段，并启用tags</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">tags</span></span><br></pre></td></tr></table></figure>
<p>之后在刚新生成在source文件夹的tags文件夹中找到<code>index.md</code>，在其中增加<code>type: &quot;tags&quot;</code>，并修改<code>Title</code>为自己想要的文字</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">标签</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2019-01-06 00:21:31</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;tags&quot;</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>
<p>在下图的红框及黄框处都会自动链接到Tags页面，Tags页面也将自动统计目前所使用的标签数<br><img src="HexoTutorial-3/2019-01-06-13-43-18.png" alt="标签显示效果"></p>
<h2 id="创建分类页面"><a href="#创建分类页面" class="headerlink" title="创建分类页面"></a>创建分类页面</h2><p>运行<code>hexo new page categories</code>创建分类页面，之后的操作与创建标签页面类似，这里不做赘述。</p>
<h2 id="设置代码风格"><a href="#设置代码风格" class="headerlink" title="设置代码风格"></a>设置代码风格</h2><p>在主题配置文件中修改<code>highlight_theme</code>字段，目前共有<code>normal</code>,<code>night</code>,<code>night eighties</code>,<code>night blue</code>,<code>night bright</code>，五种选项</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">highlight_theme:</span> <span class="string">night</span></span><br></pre></td></tr></table></figure>
<h2 id="社交链接"><a href="#社交链接" class="headerlink" title="社交链接"></a>社交链接</h2><p>在主题配置文件中修改<code>social</code>字段，其格式与<code>menu</code>字段相同，|| 前为链接，后为<code>Font Awesome</code>图标</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">GitHub:</span> <span class="string">https://github.com/xuejiaW</span> <span class="string">||</span> <span class="string">github</span></span><br></pre></td></tr></table></figure>
<h2 id="打赏功能-订阅微信公众号"><a href="#打赏功能-订阅微信公众号" class="headerlink" title="打赏功能/订阅微信公众号"></a>打赏功能/订阅微信公众号</h2><p>分别在主题配置文件中修改<code>reward</code>及<code>wechat_subscriber</code>字段</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">reward:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">comment:</span> <span class="string">Donate</span> <span class="string">comment</span> <span class="string">here</span></span><br><span class="line">  <span class="attr">wechatpay:</span> <span class="string">/images/wechatpay.jpg</span></span><br><span class="line"></span><br><span class="line"><span class="attr">wechat_subscriber:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">qcode:</span> <span class="string">/path/to/your/wechatqcode</span> <span class="string">e.g.</span> <span class="string">/uploads/wechat-qcode.jpg</span></span><br><span class="line">  <span class="attr">description:</span> <span class="string">e.g.</span> <span class="string">subscribe</span> <span class="string">to</span> <span class="string">my</span> <span class="string">blog</span> <span class="string">by</span> <span class="string">scanning</span> <span class="string">my</span> <span class="string">public</span> <span class="string">wechat</span> <span class="string">account</span></span><br></pre></td></tr></table></figure>
<h2 id="动画效果修改"><a href="#动画效果修改" class="headerlink" title="动画效果修改"></a>动画效果修改</h2><p>在配置文件中修改<code>motion</code>字段下的相应设置即可。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">motion:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h2 id="修改文末-符号"><a href="#修改文末-符号" class="headerlink" title="修改文末#符号"></a>修改文末#符号</h2><p>每一篇文章如果打上了Tag，则会在文末显示<code>#&lt;tag&gt;</code>这样的标记，但#显得不太美观，而且无法直接的表现出其标签的含义，所以这里想将其替换为图标</p>
<p>找到<code>themes/next/layout/_macro/post.swig</code>文件，并在其中搜索<code>rel=&quot;tag&quot;</code>字段，并将其后的<code>#</code>修改为<code>&lt;i class=&quot;fa fa-&lt;FontAwesome icon&gt;&quot;&gt; &lt;/i&gt;</code>即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;&#123;&#123; url_for(tag.path) &#125;&#125;&quot; rel=&quot;tag&quot;&gt;&lt;i class=&quot;fa fa-tags&quot;&gt; &lt;/i&gt; &#123;&#123; tag.name &#125;&#125;&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<p>上例中的tags即为<a href="https://fontawesome.com/icons?d=gallery">FontAwesome图标</a></p>
<h2 id="首页增加阅读全文功能"><a href="#首页增加阅读全文功能" class="headerlink" title="首页增加阅读全文功能"></a>首页增加阅读全文功能</h2><p>在文章想要出现在首页的内容之后加入<code>&lt;!--more--&gt;</code>即可</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">这一篇主要是说明标签页面和分类页面如何创建以及一些针对主题的细枝末节的修改。本篇文章也将持续更新，在每次网站主题修改后，都将在本篇中记录修改方法。</span><br><span class="line"></span><br><span class="line">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure>
<p><img src="HexoTutorial-3/2019-01-06-20-13-28.png" alt="阅读全文效果"></p>
<p>在点击了阅读全文按钮进入文章后会发现，文章自动跳转到了首页显示内容之后的地方，如果要关闭这个功能，在主题配置文件中修改<code>scroll_to_more</code>字段</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">scroll_to_more:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h2 id="关闭归档页面Cheers"><a href="#关闭归档页面Cheers" class="headerlink" title="关闭归档页面Cheers"></a>关闭归档页面Cheers</h2><p>进入归档页面后会发现默认有以下效果</p>
<p><img src="HexoTutorial-3/2019-01-06-20-23-04.png" alt="归档页面Cheers"></p>
<p>如果需要关闭的话，在主题配置文件中找到<code>cheers_enabled</code>字段</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cheers_enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h2 id="文章及站点字数统计"><a href="#文章及站点字数统计" class="headerlink" title="文章及站点字数统计"></a>文章及站点字数统计</h2><blockquote>
<p>Github支持地址：<a href="https://github.com/theme-next/hexo-symbols-count-time">https://github.com/theme-next/hexo-symbols-count-time</a></p>
</blockquote>
<p>首先在Hexo目录下运行<code>npm install hexo-symbols-count-time --save</code>安装需要的插件，后在站点配置文件中添加</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">symbols:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">time:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_symbols:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_time:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>再在主题配置文件中修改<code>symbols_count_time</code>字段</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">separated_meta:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">item_text_post:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">item_text_total:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">awl:</span> <span class="number">2</span> <span class="comment"># 统计的语言 中文为2，英语为5，俄语为6</span></span><br><span class="line">  <span class="attr">wpm:</span> <span class="number">275</span> <span class="comment"># 每分钟估计的阅读字符数</span></span><br></pre></td></tr></table></figure>
<h2 id="增加本地搜索功能"><a href="#增加本地搜索功能" class="headerlink" title="增加本地搜索功能"></a>增加本地搜索功能</h2><blockquote>
<p>Github支持地址 <a href="https://github.com/theme-next/hexo-generator-searchdb">https://github.com/theme-next/hexo-generator-searchdb</a></p>
</blockquote>
<p>首先在Hexo目录下运行<code>npm install hexo-generator-searchdb --save</code>安装需要的插件，后在站点配置文件中添加</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">10000</span> <span class="comment">#最大搜索的文章数，10000即为在最新的10000篇文章中搜索</span></span><br></pre></td></tr></table></figure>
<p>再在主题文件中配置修改<code>local_search</code>字段</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">trigger:</span> <span class="string">auto</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">unescape:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h2 id="修改背景"><a href="#修改背景" class="headerlink" title="修改背景"></a>修改背景</h2><p>在<code>\themes\next\source\css\_custom\custom.styl</code>文件下增加</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>:<span class="built_in">url</span>(<span class="string">&quot;background url&quot;</span>);</span><br><span class="line">    <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">    <span class="attribute">background-attachment</span>:fixed;</span><br><span class="line">    <span class="attribute">background-size</span>: cover;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="修改页面其他元素"><a href="#修改页面其他元素" class="headerlink" title="修改页面其他元素"></a>修改页面其他元素</h2><p>实际上next自定义的修改都可放在<code>\themes\next\source\css\_custom\custom.styl</code>下，想要修改某一部分时，可以先打开博客网页（以Chrome游览器为例），然后按F12，唤出调试界面。<br><img src="HexoTutorial-3/2019-01-09-01-02-13.png" alt="修改页面元素"><br>当在Element情况下选择部分代码，左侧页面相关部分会高亮，这部分类也会相应的显示出来，如上图中为<code>.sidebar-inner</code>，只要把最右侧的相关代码</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.sidebar-inner</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span> <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#999</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改动后复制到<code>custom.styl</code>即可。</p>
<p>由于我不懂CSS，所以这部分的修改也是摸石头过河，就不多说了。</p>
<h2 id="增加Valine评论系统"><a href="#增加Valine评论系统" class="headerlink" title="增加Valine评论系统"></a>增加Valine评论系统</h2><p><a href="https://valine.js.org/quickstart.html">Valine</a>是一个轻量级，无后端的评论系统，它完全依赖于<a href="https://leancloud.cn/">Leancloud</a>运行，配置起来也十分便捷。<br>在<code>Leancloud</code>上完成账号的注册登录，并创建完应用后。如下图进入应用界面，并进入设置找到AppID与AppKey。</p>
<p><img src="HexoTutorial-3/2019-01-09-01-16-01.png" alt="LeanCloud界面"></p>
<p>在主题配置文件中开启Valine并填入相应参数即可</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">appid:</span>  <span class="string">APPID</span></span><br><span class="line">  <span class="attr">appkey:</span>  <span class="string">APPKEY</span></span><br><span class="line">  <span class="attr">notify:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">verify:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="string">匿名的！不需要注册！想说啥直接说吧！</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">mm</span></span><br><span class="line">  <span class="attr">guest_info:</span> <span class="string">nick,mail,link</span></span><br><span class="line">  <span class="attr">pageSize:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">visitor:</span> <span class="literal">true</span> <span class="comment">#这里开启后注意该文件中还有一个leancloud_visitors字段，这两个功能相同，选一个开启就好，否则会有冲突</span></span><br></pre></td></tr></table></figure>
<p>完成配置后刷新页面，每篇文章下便会出现评论，之前的分类及标签页面也会出现，如果不想在这两个页面显示评论，可以修改对应的<code>index.md</code>文件，如</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">标签</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2019-01-06 00:21:31</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;tags&quot;</span></span><br><span class="line"><span class="attr">comments:</span> <span class="literal">false</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>
<h2 id="增加角标功能"><a href="#增加角标功能" class="headerlink" title="增加角标功能"></a>增加角标功能</h2><p>运行命令安装角标插件</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">npm install hexo-footnotes --save</span><br></pre></td></tr></table></figure>
<p>在主题配置文件中启用插件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">plugins:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo-footnotes</span></span><br></pre></td></tr></table></figure>
<p>角标语法如下<br><figure class="highlight md"><table><tr><td class="code"><pre><span class="line">basic footnote[^1]</span><br><span class="line">here is an inline footnote[<span class="string">^2</span>](<span class="link">inline footnote</span>)</span><br><span class="line">and another one[^3]</span><br><span class="line">and another one[^4]</span><br><span class="line"></span><br><span class="line">[<span class="symbol">^1</span>]: <span class="link">basic footnote content</span></span><br><span class="line">[<span class="symbol">^3</span>]: <span class="link">paragraph</span></span><br><span class="line">footnote</span><br><span class="line">content</span><br><span class="line">[<span class="symbol">^4</span>]: <span class="link">footnote content with some [markdown](https://en.wikipedia.org/wiki/Markdown</span></span><br></pre></td></tr></table></figure></p>
<h2 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h2><p>…</p>
<hr>
]]></content>
      <categories>
        <category>教程</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>《算法导论》 第一、二章笔记</title>
    <url>/IA-Chapter1-Chapter2-Notes/</url>
    <content><![CDATA[<p>《算法导论》中第一章与第二章阅读笔记。</p>
<p>介绍了插入排序即归并排序的算法及复杂度。</p>
<span id="more"></span>
<h2 id="Chapter-1-The-Role-of-Algorithms-in-Computing"><a href="#Chapter-1-The-Role-of-Algorithms-in-Computing" class="headerlink" title="Chapter 1. The Role of Algorithms in Computing"></a>Chapter 1. The Role of Algorithms in Computing</h2><h3 id="Algorithms"><a href="#Algorithms" class="headerlink" title="Algorithms"></a>Algorithms</h3><ol>
<li>算法是一系列将输入转换为输出的操作步骤。</li>
<li>数据结构是存储和管理数据的一种方式，这种方式要考虑到方便设备访问和修改数据。</li>
<li>这本书也介绍了一些设计和分析算法的技术。如设计算法时需要的分治法，动态规划和如何分析算法是否准确是否高效等。</li>
<li>算法在大多数情况下是找寻高效的方法，但在某些问题无法找到高效的解决方法，如NP问题。目前无人知道对于NP究竟是否存在一个高效的方法，而且NP问题有个特性，一旦找到了一个NP问题的高效解决方案，剩下的也就同样找到了。</li>
<li>现代芯片的设计已经从提高时钟频率到了提高并行效率，因为芯片的功率提升与时钟频率的提升是一个超线性关系，如果一味的增高频率，很可能芯片就会过热。为了提升计算效率，现在考虑的就是使用多核芯片进行并行运算，书中也会引入一些多线程的算法。</li>
</ol>
<h3 id="Algorithms-as-a-technology"><a href="#Algorithms-as-a-technology" class="headerlink" title="Algorithms as a technology"></a>Algorithms as a technology</h3><p>不同的算法一般有不同的效率，如插入排序和合并排序，插入排序的效率为$C_1 n^2$,而合并排序的效率为$C_2 n \log n$，虽然$C_1&lt;C_2$，但是在n较大的情况下，$\log ⁡n$ 远小于$n^2$，所以对于大数据来说合并排序更为高效。</p>
<h2 id="Chapter-2-Getting-Started"><a href="#Chapter-2-Getting-Started" class="headerlink" title="Chapter 2. Getting Started"></a>Chapter 2. Getting Started</h2><h3 id="Insertion-Sort"><a href="#Insertion-Sort" class="headerlink" title="Insertion Sort"></a>Insertion Sort</h3><ol>
<li><p>插入排序，在对数量较小的元素排序时是一个很高效的算法。</p>
</li>
<li><p>插入排序类似于打牌整理手牌的过程，下为图解<br> <img src="IA-Chapter1-Chapter2-Notes/2019-10-15-09-32-30.png" alt="插入排序排列"></p>
<p> 1) 首先将数组的某一项作为Key值，然后Key值从右至左的与每一项比较，如果该项的数值比Key值大，则将该值像右侧拷贝 A[i+1]=A[i] ，这相当于牌向右移的过程。</p>
<p> 2) 如果某一项比Key值小，则将Key值插入在他后方，A[i+1]=key</p>
<p> 3) 从数组的第二项开始从左至右的作为Key值，重复a,b的操作</p>
</li>
<li><p>伪代码实现</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for j=2 to A.length</span><br><span class="line"> key=A[j]</span><br><span class="line"> i=j-1</span><br><span class="line"> while i&gt;0 &amp;&amp; A[i]&gt;key</span><br><span class="line">  A[i+1]=A[i]</span><br><span class="line">  i--;</span><br><span class="line">    A[i+1]=key</span><br></pre></td></tr></table></figure>
</li>
<li><p>C++实现</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertationSort</span><span class="params">(<span class="type">int</span>* array, <span class="type">int</span> arraySize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; arraySize; i++)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="type">int</span> key = array[i];</span><br><span class="line">  <span class="type">int</span> startIndex = i - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (startIndex &gt;= <span class="number">0</span> &amp;&amp; array[startIndex] &gt; key)</span><br><span class="line">  &#123;</span><br><span class="line">   array[startIndex + <span class="number">1</span>] = array[startIndex];</span><br><span class="line">   startIndex--;</span><br><span class="line">  &#125;</span><br><span class="line">  array[++startIndex] = key;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>一些书中伪代码需要注意的点</p>
<p> 1) for循环的变量，在退出循环后，保持最后一个超越循环边界的值</p>
<pre><code>如 for j=2 to A.length，在退出循环后，j = A.length +1
</code></pre><p> 2) A[ 1…..j] 表示A[1]、A[2]…A[j]</p>
<p> 3) 函数的形参是值传递的</p>
</li>
</ol>
<h3 id="Analyzing-algorithms"><a href="#Analyzing-algorithms" class="headerlink" title="Analyzing algorithms"></a>Analyzing algorithms</h3><ol>
<li><p>分析算法主要是预测算法需要花费的资源，资源通常包括内存、带宽、但我们最关心的还是时间。</p>
</li>
<li><p>书中的分析都是基于单核的随机访问机器(random-access machine)。在这个模型中，所有的操作都看作花费一个固定时长，而且我们不考虑内存操作（如分配内存）所占用的时间。</p>
</li>
</ol>
<h4 id="Analysis-of-insertion-sort"><a href="#Analysis-of-insertion-sort" class="headerlink" title="Analysis of insertion sort"></a>Analysis of insertion sort</h4><ol>
<li><p>通常描述一个算法的运行时间都是一个关于输入数据大小的函数。</p>
<p> 1) 关于输入数据大小的定义根据问题的不同会发生改变。</p>
<pre><code> a. 对于排序问题，数据的大小通常就是需要排列的数的大小

 b. 对于两个整数相乘问题，数据大小就是这两个整数需要占据的bit数

 c. 有些时候还需要两个数字来描述问题，如关于图的问题就需要顶点数和边数。
</code></pre><p> 2) 关于算法的运行时间通常是关于算法究竟有多少步骤需要执行。在RAM模型中，我们简化每一步所花费的时间都是同样长且都为一个固定值。</p>
<p> 3) 循环语句本身比循环体要多一次执行，因为循环语句本身在越界的时候仍然会进行一次判断。</p>
</li>
<li><p>插入算法时间复杂度分析</p>
<p> | 插入排序步骤                        | 时间花费 | 运行次数              | 说明                                                                                                                                 |<br> | —————————————————- | ———— | ——————————- | —————————————————————————————————————————————————————————————————— |<br> | for j=2 to A.length                 | $c<em>1$    | $n$                   | 将A.Length看作n，因为循环语句本身多执行一次，所以总运行次数为$n$                                                                     |<br> | &emsp;&emsp;key=A[j]                | $c_2$    | $n-1$                 | 2-&gt;n，运行$n-1$次                                                                                                                    |<br> | &emsp;&emsp;i=j-1                   | $c_3$    | $n-1$                 | 2-&gt;n，运行$n-1$次                                                                                                                    |<br> | &emsp;&emsp;while i&gt;0 &amp;&amp; A[i]&gt;key   | $c_4$    | $\sum</em>{j=2}^nt<em>j$     | 因为运行次数收到while判断影响，所以不定为$t_j$<br>最好情况下直接满足，只需要判断一次，$t_j=1$<br>最坏情况运行到i=0，运行j次，$t_j=j$ |<br> | &emsp;&emsp;&emsp;&emsp;A[i+1]=A[i] | $c_5$    | $\sum</em>{j=2}^n(t<em>j-1)$ | 比循环判断少运行一次，运行次数为$t_j-1$                                                                                              |<br> | &emsp;&emsp;&emsp;&emsp;i—;        | $c_6$    | $\sum</em>{j=2}^n(t_j-1)$ | 比循环判断少运行一次,运行次数为$t_j-1$                                                                                               |<br> | &emsp;&emsp;A[i+1]=key              | $c_7$    | $n-1$                 | 2-&gt;n，运行$n-1$次                                                                                                                    |</p>
</li>
</ol>
<p>如表中所示，在最好情况下，$t_j=1$，最坏情况下运行$j$次。通常计算算法的复杂度，我们只考虑算法的最坏情况，因为往往在实际运算中，最坏情况就是最多的情况（如搜索算法，常常搜索的内容不在列表中，那就要搜索整个列表，即最坏情况）。而且纵使我们取平均值，在本例中，我们取运行次数为$j/2$，最终代入式子中计算，结果的最高次幂并不会改变。</p>
<p>我们以最坏情况计算整个表达式的时间</p>
<script type="math/tex; mode=display">
T(n)=c_1n+c_2(n-1)+c_3(n-1)+c_4\sum_{j=2}^nj+c_5\sum_{j=2}^n(j-1)\\\\+c_6\sum_{j=2}^n(j-1)+c_7(n-1)</script><p>又有</p>
<script type="math/tex; mode=display">
\sum_{j=2}^nj=\frac{(2+n)(n-1)}{2}=\frac{n(n+1)}{2}-1 \\\\
\sum_{j=2}^nj-1=\frac{(1+n-1)(n-1)}{2}=\frac{n(n-1)}{2}</script><p>代入上式得</p>
<script type="math/tex; mode=display">
T(n)=c_1n+c_2(n-1)+c_3(n-1)+c_4\frac{n(n+1)}{2}-c_4+\\\\
c_5\frac{n(n-1)}{2}+c_6\frac{n(n-1)}{2}+c_7(n-1)
\\\\
=\frac{c_4+c_5+c_6}{2}n^2+(c_1+c_2+c_3+\frac{c_4}{2}
-\frac{c_5}{2}-\frac{c_6}{2}+c_7)n-(c_2+c_3+c_4+c_7)\\\\
=an^2+bn+c</script><p>所以最坏的运行时间可以表达为$an^2+bn+c$，这是个二次幂方程.</p>
<h4 id="Order-of-growth"><a href="#Order-of-growth" class="headerlink" title="Order of growth"></a>Order of growth</h4><p>一个函数的增长极受最高次幂的影响最大，所以我我们也只关注运算时间的最高次幂，在上例中即为$n_2$。我们将最坏情况运行时间成为$\Theta(n_2)$</p>
<h3 id="Designing-algorithms"><a href="#Designing-algorithms" class="headerlink" title="Designing algorithms"></a>Designing algorithms</h3><p>这节中简略介绍了分治法（divide-and-conquer），分治法的一大好处是运算时间比较好估计。</p>
<h4 id="The-divide-and-conquer-approach"><a href="#The-divide-and-conquer-approach" class="headerlink" title="The divide-and-conquer approach"></a>The divide-and-conquer approach</h4><ol>
<li><p>许多算法都使用了递归，递归算法就是典型的分治法。将一个大问题分解为几个类似的小问题，然后递归的解决各个小问题，然后把结果合并在一起就得到了最终的答案。</p>
</li>
<li><p>分治法的解决分为三个步骤：<br>1) 分解：将大问题分解为几个小问题<br>2) 解决：迭代解决小问题<br>3) 合并：将小问题的答案结合成为原始问题的答案。</p>
</li>
<li><p>归并排序（Merge sort algorithms）就是一个典型的分治法算法。排序算法的思想是将需要排序的数组二分，先对左半部分进行排序，再对右半部分进行排序，最有把左右半部分合并在一起获得完整的排序好的数组。</p>
</li>
<li><p>归并排序算法的伪代码</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Merge-sort(A,p,r)</span><br><span class="line"></span><br><span class="line">//A-&gt;需要排序的数组，p-&gt;需要排序部分的左起点，r-&gt;需要排序部分的右终点</span><br><span class="line"></span><br><span class="line">如果出现了p=r，说明被拆分出的子数组只有一个元素，则不需要计算。只计算p &lt; r的情况</span><br><span class="line"></span><br><span class="line">if p &lt; r </span><br><span class="line">    q = [(p+r)/2] //除不尽的话向下取整</span><br><span class="line"></span><br><span class="line">    //将需要排序的部分等分为两部分，各自进行排序</span><br><span class="line"></span><br><span class="line">    Merge-sort(A,p,q)</span><br><span class="line">    Merge-sort(A,q+1,r)</span><br><span class="line">    Merge(A,p,q,r)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 下图为归并排序图解，先将序列逐渐二分直到最后成为单个元素（单个元素不需要合并），然后再进行合并操作。</p>
<p> <img src="IA-Chapter1-Chapter2-Notes/2019-10-15-23-14-44.png" alt="归并排序图解"></p>
</li>
</ol>
<ol>
<li><p>归并排序中，最重要的就是最终合并的部分。在之前合并函数前，我们假定两个需要被合并的数组已经排序完毕。合并部分的伪代码如下</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Merge(A,p,q,r)</span><br><span class="line"></span><br><span class="line">// A-&gt; 需要排序的数组</span><br><span class="line">//p,q,r-&gt;数组中的Index，p&lt;q&lt;r，A[p,q]表示一个子数组（下称为左半部分），A[q+1,r]表示另一个子数组（下称为右半部分），左右部分都已经排序完毕。</span><br><span class="line"></span><br><span class="line">n1=q-p+1 //左半部分长度</span><br><span class="line">n2=r-q //右半部分长度</span><br><span class="line"></span><br><span class="line">Make L[1...n1+1],R[1...n2+1] //创建两个新的数组，长度与左右部分长度+1，防止之后遍历时越界。</span><br><span class="line"></span><br><span class="line">for i=1 to n1</span><br><span class="line">    L[i]=A[p+i-1] //将左半部分内容对应拷贝到新建立的左数组中</span><br><span class="line"></span><br><span class="line">for j-1 to n2</span><br><span class="line">    R[i]=A[q+j]  //将右半部分内容对应拷贝到新建立的右数组中</span><br><span class="line"></span><br><span class="line">//将左右数组的最后一个数值都设为无限大，如果遍历时达到了最后一个数值，说明这个数组已经完全装填回了原数组。因为最后的数值为无限大，所以另一个数组的数值始终小于等于这个数值，因此会一直装填另一个数组。</span><br><span class="line"></span><br><span class="line">L[n1+1]=Max </span><br><span class="line">R[n2+1]=Max</span><br><span class="line"></span><br><span class="line">i,j=1</span><br><span class="line"></span><br><span class="line">for k=p to r</span><br><span class="line">    if(L[i]&lt;= R[j]&gt;)</span><br><span class="line">        A[k]=L[i]</span><br><span class="line">        i++</span><br><span class="line">    else</span><br><span class="line">        A[k]=R[j]</span><br><span class="line">        j++</span><br></pre></td></tr></table></figure>
<p> 合并部分算法的图解</p>
<p> <img src="IA-Chapter1-Chapter2-Notes/2019-10-15-15-16-31.png" alt="合并部分算法图解"></p>
</li>
<li><p>C++实现</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(<span class="type">int</span>* array, <span class="type">int</span> leftStartIndex, <span class="type">int</span> rightEndIndex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (leftStartIndex == rightEndIndex)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> centerIndex = (leftStartIndex + rightEndIndex) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">MergeSort</span>(array, leftStartIndex, centerIndex);</span><br><span class="line">    <span class="built_in">MergeSort</span>(array, centerIndex + <span class="number">1</span>, rightEndIndex);</span><br><span class="line">    <span class="built_in">Merge</span>(array, leftStartIndex, centerIndex, rightEndIndex);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(<span class="type">int</span>* array, <span class="type">int</span> leftStartIndex, <span class="type">int</span> middleIndex, <span class="type">int</span> rightEndIndex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> leftPartLength = middleIndex - leftStartIndex + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> rightPartLength = rightEndIndex - middleIndex;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* leftArray = <span class="keyword">new</span> <span class="type">int</span>[leftPartLength + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span>* rightArray = <span class="keyword">new</span> <span class="type">int</span>[rightPartLength + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; leftPartLength; i++)</span><br><span class="line">        leftArray[i] = array[leftStartIndex + i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rightPartLength; i++)</span><br><span class="line">        rightArray[i] = array[middleIndex + <span class="number">1</span> + i];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Make the last index to be max</span></span><br><span class="line">    leftArray[leftPartLength] = INT_MAX;</span><br><span class="line">    rightArray[rightPartLength] = INT_MAX;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> leftArrayIndex = <span class="number">0</span>, rightArrayIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = leftStartIndex; i &lt;= rightEndIndex; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (leftArray[leftArrayIndex] &lt; rightArray[rightArrayIndex])</span><br><span class="line">            array[i] = leftArray[leftArrayIndex++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            array[i] = rightArray[rightArrayIndex++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] leftArray;</span><br><span class="line">    <span class="keyword">delete</span>[] rightArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="Analyzing-divide-and-conquer-algorithms"><a href="#Analyzing-divide-and-conquer-algorithms" class="headerlink" title="Analyzing divide-and-conquer algorithms"></a>Analyzing divide-and-conquer algorithms</h4><p>当计算一个迭代问题的时间复杂度时，我们也常用迭代表达式来表示。</p>
<p>我们假定将原问题拆分为$a$个子问题，每个子问题有$\frac{1}{b}$个数据，那么所有这些子问题的花费时间为$aT(\frac{1}{b})$。并且拆分子问题需要$D(n)$的时间，合并子问题需要$C(n)$时间。另外我们需要考虑到如果子问题的输入数据足够小，可能在固定时间内子问题就能解决，例如排序的子问题，如果子数组只有一个变量，那么直接返回即可（固定时间）。所以整体的时间花费为：</p>
<script type="math/tex; mode=display">
T(n)=\begin{cases}
    \Theta(1) & \text{if } n \leq c\\\\
    aT(\frac{1}{b})+D(n)+C(n) & 其他情况条件
\end{cases}</script><h4 id="Analysis-of-merge-sort"><a href="#Analysis-of-merge-sort" class="headerlink" title="Analysis of merge sort"></a>Analysis of merge sort</h4><p>这里着重讨论归并排序的时间复杂度。</p>
<p><strong>分解时间</strong>：归并排序将数组分为两部分，这一操作只是单纯的二分，所以花费时间为固定值，即$D(n)=\Theta(1)$</p>
<p><strong>解决时间</strong>：将数组平分为两个部分，所以每一份的数据为$n/2$且有两部分，所以子问题解决时间为$2T(\frac{n}{2})$</p>
<p><strong>合并时间</strong>： 由合并算法的伪代码可知，整个计算过程只有单层循环，所以时间复杂度$C(n)=\Theta(n)$</p>
<p>综上，归并排序的时间复杂度为</p>
<script type="math/tex; mode=display">
T(n)=\begin{cases}
    \Theta(1) & \text{if } n=1\\\\
    2T(\frac{n}{2})+\Theta(n) & \text{if } n\geq 1
\end{cases}</script><p>目前$T(n)$的表达式是一个递归表达，我们需要根据这个解出$n\geq 1$情况下的$T(n)$单纯对于$n$的表达式。</p>
<p>我们将$T(n)$用树形结构表示，每个节点都代表一部分时间，所有节点的时间累计即为$T(n)$</p>
<p>例如式子$T(n)=2T(\frac{n}{2})+\Theta(n)$，使用树形结构表达即为从下图的(a)树转换为(b)树，(b)树中的每个节点即代表等式右边的每小部分。而$T(\frac{n}{2})$又可进一步表达为$2T(\frac{n}{4})+\Theta(\frac{n}{2})$，即为下图中(b)图的叶子进一步转换，变成(c)图的样子。</p>
<p><img src="IA-Chapter1-Chapter2-Notes/2019-10-16-00-45-05.png" alt="归并排序时间复杂度分析1"></p>
<p>我们可以重复递归这样的操作，直到属性结构变成下图所示：</p>
<p><img src="IA-Chapter1-Chapter2-Notes/2019-10-16-00-46-41.png" alt="归并排序时间复杂度分析2"></p>
<p>整棵树所有叶子所代表的时间总和即为$T(n)$，可以看到每一层叶子的总和都为$cn$。最下一层一共有$n$个节点，每个节点时间花费为$c$，即代表归并排序中分解子数组到数组的元素只有一个的情况，这时候直接返回（花费时间固定）。</p>
<p>现在问题的解决到了求树一共有多少层，我们知道最下面一层有$n$个元素，每层的数量都是2的次幂，且第一层为一个元素，所以我们设层数为$x$，计算表达式应该为：</p>
<script type="math/tex; mode=display">
2^(x-1)=n \\\\
x=\lg n+1</script><p>那么整棵树所有叶子的时间花费总和即为，每层的时间（$cn$）乘以层数($\lg n+1$)，即$T(n)=cn\lg n+cn$。</p>
<p>所以归并排序最差情况时间复杂度标识为$\Theta(n\lg n)$</p>
<ul>
<li>书中的$\lg n$表示$\log<em>2n$，而非一般数学书中的$\log</em>{10}n$，因为计算机讨论的是二进制而非现实生活中常用的十进制。</li>
</ul>
<div class="note info simple"><p>引用：</p>
<ol>
<li><em>Introduction to Algorithms</em> 3rd Sep.2009</li>
</ol>
</div>
<hr>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>《算法导论》 第十章笔记</title>
    <url>/IA-Chapter10-Notes/</url>
    <content><![CDATA[<p>《算法导论》第十章笔记，包括栈，队列，链表的实现。</p>
<span id="more"></span>
<h2 id="Chapter-10-Elementary-Data-Structures"><a href="#Chapter-10-Elementary-Data-Structures" class="headerlink" title="Chapter 10. Elementary Data Structures"></a>Chapter 10. Elementary Data Structures</h2><p>集合<code>Set</code>作为计算机科学的基础，重要性与数学中的集合相同。但数学中的集合是不可变的，计算机中的集合可在任意时刻扩张，收缩和更改，称之为<code>动态集合（dynamic set）</code>。一般动态集合需要实现如下操作中的一部分：</p>
<p><code>Search</code>，<code>Insert</code>，<code>DELETE</code>，<code>MINIMUM</code>，<code>MAXIMUM</code>，<code>SUCCESSOR</code>，<code>PREDECESSOR</code></p>
<p>这些操作可以分为两种，<code>查询操作(Queries)</code>和<code>修改操作(Modifying operations)</code>，如<code>Search</code>，<code>MINIMUM</code>，<code>MAXIMUM</code>，<code>SUCCESSOR</code>，<code>PREDECESSOR</code>都属于前者，<code>Insert</code>，<code>DELETE</code>属于后者</p>
<h3 id="Stacks-and-queues"><a href="#Stacks-and-queues" class="headerlink" title="Stacks and queues"></a>Stacks and queues</h3><p><code>堆栈(Stacks)</code>是后进先出，<code>队列(Queues)</code>是先进先出。</p>
<h4 id="Stacks"><a href="#Stacks" class="headerlink" title="Stacks"></a>Stacks</h4><p>在堆栈上的插入操作一般成为<code>Push</code>，删除操作一般称为<code>Pop</code>。堆栈有一个<code>top</code>指针指向队列中的第一个元素，在<code>Pop</code>时返回该元素，在<code>Push</code>时top指针向前移动一格，并在新的地方插入新值，当<code>top</code>为0则说明队列为空。</p>
<p>堆栈的图解如下图，(a)为原始样子，(b)为执行了<code>Push(17)和Push(3)</code>后的样子，(c)为执行了<code>Pop</code>后的样子。图中的<code>S.top</code>表示当前指针的索引值。</p>
<p><img src="IA-Chapter10-Notes/2019-10-25-12-31-40.png" alt="堆栈图解"></p>
<p>堆栈操作微数据实现，每个步骤的复杂度都为<code>O(1)</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">STACK_EMPTY(S):</span><br><span class="line"></span><br><span class="line">if s.top==0;</span><br><span class="line">    return true;</span><br><span class="line">else</span><br><span class="line">    return false;</span><br><span class="line"></span><br><span class="line">Push(S,x):</span><br><span class="line"></span><br><span class="line">S.top=S.top+1;</span><br><span class="line">S[S.top]=x;</span><br><span class="line"></span><br><span class="line">Pop(S):</span><br><span class="line"></span><br><span class="line">if STACK_EMPTY(S)</span><br><span class="line">    error&quot;underflow&quot;</span><br><span class="line">else</span><br><span class="line">    S.top=S.top-1;</span><br><span class="line">    return S[S.top+1]</span><br></pre></td></tr></table></figure>
<p>c++的数组实现，不支持运行时扩大队列大小。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> data[MAX];</span><br><span class="line">	~<span class="built_in">Stack</span>() &#123;&#125;</span><br><span class="line">	<span class="built_in">Stack</span>() &#123; top = <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (top &gt; (MAX - <span class="number">1</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;Stack Overflow&quot;</span>&lt;&lt;endl;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		data[++top] = value;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">isEmpty</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;Stack is empty&quot;</span>&lt;&lt;endl;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> data[top--];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> top &lt; <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> top;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="Queues"><a href="#Queues" class="headerlink" title="Queues"></a>Queues</h4><p>队列的插入操作称为<code>ENQUEUE</code>，删除操作称为<code>DEQUEUE</code>。队列的图解如下图，队列存在一个<code>head</code>指针和一个<code>tail</code>指针，两指针间的数据为队列保存的数据。当进行插入操作时，<code>tail</code>指针前移并在新地方插入数据，当进行删除操作时，<code>head</code>指针返回指着的值，并前移。</p>
<p>图解如下图，使用一个大小为12的数组表示队列</p>
<p>(a) 为初始状态，索引7-11为原始数据</p>
<p>(b) 为执行了Enqueue(17),Enqueue(3),Enqueue(5)后的样子，每一步执行时tail指针先向前，再插入新值。当抵达数组边界时，返回数组的开头处继续执行插入操作</p>
<p>(c) 为执行了Dequeue（）操作的样子</p>
<p><img src="IA-Chapter10-Notes/2019-10-25-12-30-32.png" alt="队列图解"></p>
<p>队列伪代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ENQUEUE(Q,X):</span><br><span class="line">Q[Q..tail] = x</span><br><span class="line">if [Q.tail == Q.length]</span><br><span class="line">	Q.tail = 1;</span><br><span class="line">else</span><br><span class="line">	Q.tail = Q.tail + 1</span><br><span class="line"></span><br><span class="line">DEQUEUE(Q):</span><br><span class="line"></span><br><span class="line">x=Q[Q.head]</span><br><span class="line"></span><br><span class="line">if [Q.head == Q.length]</span><br><span class="line">	Q.head = 1;</span><br><span class="line">else</span><br><span class="line">	Q.head = Q.head + 1</span><br><span class="line">return x</span><br></pre></td></tr></table></figure>
<p>c++的循环数组实现</p>
<p>当<code>top == head</code>时认为队列为空，当<code>(top+1) % size == head</code>时，认为队列已满。所以在队列插满的情况下永远会有一个空的值（因为top不等于head）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Queue</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		head = tail = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Queue</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		head = tail = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">Enqueue</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> ((tail + <span class="number">1</span>) % QUEUESIZE == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;Queue is full&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		data[tail] = value;</span><br><span class="line"></span><br><span class="line">		tail = (tail == QUEUESIZE - <span class="number">1</span>) ? <span class="number">0</span> : tail + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Dequeue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">Empty</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;Queue is empty&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> value = data[head];</span><br><span class="line"></span><br><span class="line">		head = (head == QUEUESIZE - <span class="number">1</span>) ? <span class="number">0</span> : head + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> head == tail;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> data[QUEUESIZE];</span><br><span class="line">	<span class="type">int</span> head;</span><br><span class="line">	<span class="type">int</span> tail;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Linked-lists"><a href="#Linked-lists" class="headerlink" title="Linked lists"></a>Linked lists</h3><p><code>链表(linked list)</code>是一种对象线性排列的数据结构。</p>
<p>对于<code>双向链表(Doubly linked list)</code>来说，每个结点都保留有三个对象，表示属性的<code>key</code>，以及两个指针<code>next</code>和<code>prev</code>。如果对于结点<code>x</code>来说,<code>x.prev==Null</code>，则说明<code>x</code>是头结点，如果<code>x.next==Null</code>，则说明<code>x</code>是尾结点。另外还有存有一个变量<code>head</code>来指向头结点，如果<code>head</code>为空，则说明列表为空。</p>
<p>对于<code>单链表（Singly linked list）</code>，删除<code>双向链表</code>中的<code>prev</code>对象即可。</p>
<p>对于<code>循环链表（Circular list）</code>，尾结点的<code>next</code>指向头结点，头结点的<code>prev</code>指向尾结点。</p>
<p>下图是<code>非循环双向链表</code>的图解</p>
<p>(a) 为存有数据{1,4,9,16}的列表</p>
<p>(b) 为插入了数据25之后的列表</p>
<p>(c) 为删除了数据4之后的列表</p>
<p><img src="IA-Chapter10-Notes/2019-10-25-16-24-36.png" alt="双向链表"></p>
<p>链表通常需要支持<code>Search</code>，<code>Insert</code>和<code>Delete</code>操作，三者的伪代码分别为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SEARCH(L,k):</span><br><span class="line"></span><br><span class="line">x=L.head</span><br><span class="line">while x!=null and x.key!=k</span><br><span class="line">	x=x.next</span><br><span class="line">return x</span><br><span class="line"></span><br><span class="line">INSERT(L,k):</span><br><span class="line"></span><br><span class="line">x.next=L.head</span><br><span class="line">if L.head!=null</span><br><span class="line">	L.head.prev=x;</span><br><span class="line">x.prev=null;</span><br><span class="line">L.head=x;</span><br><span class="line"></span><br><span class="line">DELETE(L,x)</span><br><span class="line"></span><br><span class="line">if(x.prev!=Null)</span><br><span class="line">	x.prev.next=x.next</span><br><span class="line">else</span><br><span class="line">	L.head=x.next</span><br><span class="line"></span><br><span class="line">if x.next!=null</span><br><span class="line">	x.next.prev=x.prev</span><br></pre></td></tr></table></figure>
<p><code>Search</code>的复杂度为$\Theta(n)$，<code>Insert</code>的复杂度为$O(1)$，<code>Delete</code>的复杂度本身为$O(1)$，但是通常删除操作前需要先找到该元素，所以整体复杂度为$\Theta(n)$</p>
<p>列表的C++实现如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> value;</span><br><span class="line">	Node* next;</span><br><span class="line">	Node* prev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">List</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">List</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		head = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">List</span>()</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		Node* node = (Node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Node));</span><br><span class="line">		node-&gt;value = value;</span><br><span class="line"></span><br><span class="line">		node-&gt;next = head;</span><br><span class="line">		node-&gt;prev = <span class="literal">nullptr</span>;</span><br><span class="line">		<span class="keyword">if</span> (head != <span class="literal">nullptr</span>)</span><br><span class="line">			head-&gt;prev = node;</span><br><span class="line"></span><br><span class="line">		head = node;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		Node* toDelete = <span class="built_in">Search</span>(value);</span><br><span class="line">		<span class="keyword">if</span> (toDelete == <span class="literal">nullptr</span>)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (toDelete-&gt;prev != <span class="literal">nullptr</span>)</span><br><span class="line">			toDelete-&gt;prev-&gt;next = toDelete-&gt;next;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			head = toDelete-&gt;next;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (toDelete-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">			toDelete-&gt;next-&gt;prev = toDelete-&gt;prev;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">free</span>(toDelete);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">Node* <span class="title">Search</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		Node* begin = head;</span><br><span class="line">		<span class="keyword">while</span> (begin != <span class="literal">nullptr</span> &amp;&amp; begin-&gt;next != <span class="literal">nullptr</span> &amp;&amp; begin-&gt;value != value)</span><br><span class="line">		&#123;</span><br><span class="line">			begin = begin-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (begin-&gt;value == value)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;Find the value &quot;</span> &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">return</span> begin;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		Node* begin = head;</span><br><span class="line">		<span class="keyword">while</span> (begin != <span class="literal">nullptr</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;List element value is &quot;</span> &lt;&lt; begin-&gt;value &lt;&lt; endl;</span><br><span class="line">			begin = begin-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Print is over&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Node* head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="Sentinels"><a href="#Sentinels" class="headerlink" title="Sentinels"></a>Sentinels</h4><p>可以使用一个哨兵结点来将列表变为循环列表，将哨兵结点命名为<code>nil</code>，<code>nil.next=head</code>且<code>nil.prev=tail</code>，这时候列表中就不需要存储<code>head</code>结点了，因为通过<code>nil</code>即可找到<code>head</code>。</p>
<p>使用了哨兵结点后，搜索，插入以及删除伪代码变为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SEARCH(L,k):</span><br><span class="line"></span><br><span class="line">x=L.nil.next</span><br><span class="line">while x!=L.nil and x.key!=k</span><br><span class="line">	x=x.next</span><br><span class="line">return x</span><br><span class="line"></span><br><span class="line">INSERT(L,k):</span><br><span class="line"></span><br><span class="line">x.next=L.nil.next</span><br><span class="line">x.prev=L.nil</span><br><span class="line">L.nil.next.prev=x;</span><br><span class="line">L.nil.next=x</span><br><span class="line"></span><br><span class="line">DELETE(L,x)</span><br><span class="line">x.next.prev=x.prev;</span><br><span class="line">x.prev.next=x.next</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>哨兵循环双链表的C++实现为</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> value;</span><br><span class="line">	Node* next;</span><br><span class="line">	Node* prev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">List_Sentinels</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">List_Sentinels</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		sentials = (Node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Node));</span><br><span class="line">		sentials-&gt;next = sentials;</span><br><span class="line">		sentials-&gt;prev = sentials;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">List_Sentinels</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">free</span>(sentials);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		Node* node = (Node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Node));</span><br><span class="line">		node-&gt;value = value;</span><br><span class="line"></span><br><span class="line">		node-&gt;next = sentials-&gt;next;</span><br><span class="line">		node-&gt;prev = sentials;</span><br><span class="line">		sentials-&gt;next-&gt;prev = node;</span><br><span class="line">		sentials-&gt;next = node;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		Node* toDelete = <span class="built_in">Search</span>(value);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (toDelete == <span class="literal">nullptr</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;return for value == null&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		toDelete-&gt;prev-&gt;next = toDelete-&gt;next;</span><br><span class="line">		toDelete-&gt;next-&gt;prev = toDelete-&gt;prev;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">free</span>(toDelete);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">Node* <span class="title">Search</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		Node* node = sentials-&gt;next;</span><br><span class="line">		<span class="keyword">while</span> (node-&gt;value != value &amp;&amp; node-&gt;next != sentials)</span><br><span class="line">		&#123;</span><br><span class="line">			node = node-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> node-&gt;value == value ? node : <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		Node* node = sentials-&gt;next;</span><br><span class="line">		<span class="keyword">while</span> (node != sentials)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;value is &quot;</span> &lt;&lt; node-&gt;value &lt;&lt; endl;</span><br><span class="line">			node = node-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Node* sentials;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Implementing-pointers-and-objects"><a href="#Implementing-pointers-and-objects" class="headerlink" title="Implementing pointers and objects"></a>Implementing pointers and objects</h3><p>在上一节的实现线性列表的过程中，需要用到指针来表示上一个结点或下一个结点。但在某些语言中，并没有提供指针的概念，如C#和Java，这一节介绍了在这些语言中如何来实现列表。</p>
<h4 id="A-multiple-array-representation-of-objects"><a href="#A-multiple-array-representation-of-objects" class="headerlink" title="A multiple-array representation of objects"></a>A multiple-array representation of objects</h4><p>第一种方法是使用三个大小相同的数组来分别表示<code>next</code>，<code>key</code>和<code>prev</code>，如下两图实际上是实现了同一种结构。</p>
<p><img src="IA-Chapter10-Notes/2019-10-26-14-41-54.png" alt="指针形式表现列表"><br><img src="IA-Chapter10-Notes/2019-10-26-14-42-13.png" alt="多数组形式表现列表"></p>
<p>图二是将三个数组并排显示的效果，另外有一个变量<code>L</code>来保存列表的第一个结点的索引值，在这里第一个结点的<code>Key</code>值为9，索引值为7，所以<code>L</code>中保存的值为7。</p>
<p>以索引值为7为例，<code>key</code>值为9,<code>next</code>值为5,<code>prev</code>值为/。表示这个结点没有前一个结点，即为头结点，且后一个结点的索引值为5，数组索引值为5的地方，<code>key</code>值为16,<code>next</code>为2，<code>prev</code>为7。以此类推,可得到所有的结点。</p>
<h4 id="A-single-array-representation-of-objects"><a href="#A-single-array-representation-of-objects" class="headerlink" title="A single-array representation of objects"></a>A single-array representation of objects</h4><p>第二种方法是只用一个数组来表示<code>next</code>，<code>key</code>和<code>prev</code>。每一个结点占数组中的三个位置，如一个结点的Key值在数组中的位置<code>A[i]</code>，则<code>next</code>位置为<code>A[i+1]</code>,<code>prev</code>位置为<code>A[i+2]</code></p>
<p><img src="IA-Chapter10-Notes/2019-10-26-14-41-54.png" alt="指针形式表现列表"><br><img src="IA-Chapter10-Notes/2019-10-26-14-52-00.png" alt="单数组形式表现列表"></p>
<p>同理，这里仍然需要一个变量<code>L</code>来保存头结点的索引，这里的头结点索引为19，所有头结点的<code>Key</code>值为9，<code>next</code>结点为13，表示下一个结点的从索引值13开始，<code>prev</code>结点为/，表示没有前结点，该结点为头结点。</p>
<h4 id="Allocating-and-freeing-objects"><a href="#Allocating-and-freeing-objects" class="headerlink" title="Allocating and freeing objects"></a>Allocating and freeing objects</h4><p>这里以多数组表示法进行说明。为了可以释放和分配结点，我们需要另一个变量<code>free</code>来记录数组的哪个索引值为空结点。我们可以将多个空结点们看作也是一个链表，但是只是一个单链表，只需要知道下一个空结点在哪即可，所以在多数组方法中也仅只需要用到<code>next</code>数组即可。</p>
<p>分配和释放对象的过程如下图所示：</p>
<p><img src="IA-Chapter10-Notes/2019-10-26-14-41-54.png" alt="指针形式表现列表"><br><img src="IA-Chapter10-Notes/2019-10-26-14-58-40.png" alt="分配和释放对象"></p>
<p>下图中的图(a)即为用多数组方式表示上图的数据，唯一与之前说明不同的是，这里需要一个变量<code>free</code>来表示第一个空结点在哪，这里显示第一个空结点的索引值为4，而在<code>next</code>数组的索引4处，值为8，说明下一个空结点在索引8的地方。</p>
<p>图(b)是插入了一个<code>key</code>值为25的结点。因为之前第一个空结点的位置在索引值为<code>4</code>的地方，所以这个结点现在插入在索引为4的地方。此时行结点成为了头结点，所以变量<code>L</code>值变为4,也因为索引4的地方有了值，所以第一个空结点变成之前的第一个空结点中保存的索引值的地方，即索引值为8的地方，因此<code>free</code>变量变为8.</p>
<p>图(c)是删除了<code>key</code>值为16的结点，该结点在索引值为5的地方。删除后，将他作为空结点插入空结点链表，即第一个空结点为索引值为5的地方，所以变量<code>free</code>值为5。且第一个空结点的<code>next</code>需要指向下一个空姐点，即索引值为8的地方。</p>
<p>多数组方法中，分配和删除的伪代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALLOCATE-OBJECT()</span><br><span class="line"></span><br><span class="line">if free == NULL</span><br><span class="line">	error &quot;out of free&quot;</span><br><span class="line">else </span><br><span class="line">	x=free;</span><br><span class="line">	free=x.next</span><br><span class="line">	return x</span><br><span class="line"></span><br><span class="line">FREE-OBJECT()</span><br><span class="line"></span><br><span class="line">x.next=free;</span><br><span class="line">free=x;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这两步操作的复杂度都为<code>O(1)</code></p>
<p>另外多个链表可以共用同三个数组，且共用一个free链表，如下图所示。存在两个链表，分别以$L_2$和$L_1$作为头结点。</p>
<p><img src="IA-Chapter10-Notes/2019-10-26-15-23-27.png" alt="多个链表共享数组和空链表"></p>
<h3 id="Representing-rooted-trees"><a href="#Representing-rooted-trees" class="headerlink" title="Representing rooted trees"></a>Representing rooted trees</h3><p>可以用表示链表的方法可以用在其他的类似的数据结构中，这一节将用列表的方法来表示有根树形结构。树的每一个结点都作为对象，如链表一样，结点中也有一个类似与<code>Key</code>值的存在，不同的是根据树的类型不同，结点中的指针会有不同的表示。</p>
<h4 id="Binary-Tree"><a href="#Binary-Tree" class="headerlink" title="Binary Tree"></a>Binary Tree</h4><p>在二叉树中，每个结点都有三个变量$p$，$left$和$right$，分别表示结点的父结点，左子结点和右子结点。如没有左子结点，则<code>left=null</code>，右子结点同理。</p>
<p>二叉树实例图如下：</p>
<p><img src="IA-Chapter10-Notes/2019-10-26-15-39-21.png" alt="二叉树"></p>
<h4 id="Rooted-trees-with-unbounded-branching"><a href="#Rooted-trees-with-unbounded-branching" class="headerlink" title="Rooted trees with unbounded branching"></a>Rooted trees with unbounded branching</h4><p>对于分支没有限制的有根树，可以使用变量$child_1$，$child_2$，$child_3$….来替代$left$和$right$。</p>
<p>但是这种方法存在一个弊端，首先如果子结点的个数没有限制，那我们无法预先直到该为每个结点分配多少的子结点。其次如果我们用一个非常大的数值来作为子结点的个数，在多数结点的子结点个数都小于这个设定数值时，就会造成很严重的内存浪费。</p>
<p>但是可以通过<code>左孩子和右兄弟表示法(left-child,right-sibling representation)</code>来解决这种情况，<code>x.left-child</code>表示所有子结点中，最靠左的那一个，<code>x.right-sibling</code>表示同级的结点中，最靠近<code>x</code>结点右边的那一个。</p>
<p>分支无限制有根树实例图如下</p>
<p><img src="IA-Chapter10-Notes/2019-10-26-15-40-32.png" alt="分支无限制有根树"></p>
<div class="note info simple"><p>引用：</p>
<ol>
<li><em>Introduction to Algorithms</em> 3rd Sep.2009</li>
</ol>
</div>
<hr>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>《算法导论》 第十二章笔记</title>
    <url>/IA-Chapter12-Notes/</url>
    <content><![CDATA[<p>《算法导论》 第十二章笔记，线性二叉树的实现。</p>
<p>12.4节尚未整理</p>
<span id="more"></span>
<h2 id="Chapter-12-Binary-Search-Trees"><a href="#Chapter-12-Binary-Search-Trees" class="headerlink" title="Chapter 12. Binary Search Trees"></a>Chapter 12. Binary Search Trees</h2><p><code>搜索树(Search tree)</code>结构支持许多动态数组的操作，包括SEARCH，MINIMUM，MAXIMUM，PREDESCESSOR，SUCESSOR，INSERT和DELETE。</p>
<p>对于一个有$n$个结点的完全二叉树，这些操作在最坏情况下的时间复杂度应该为$\Theta(n)$，而如果是一个随机建立的二叉树，复杂度应该为$\Theta(\lg n)$</p>
<h3 id="What-is-a-binary-search-tree"><a href="#What-is-a-binary-search-tree" class="headerlink" title="What is a binary search tree?"></a>What is a binary search tree?</h3><p>二叉搜索树的每一个结点（下使用<code>x</code>来表示）都包含一个$key$值以及三个指针$p$、$left$和$right$分别表示结点的父结点，左子结点和右子结点。</p>
<p>对于一个二叉搜索树而言，一个结点的所有左子结点一定小于等于该结点值，结点的所有右子结点一定大于等于该结点值。</p>
<p>大部分搜索树的操作都与树的高度有关，下图是两个搜索二叉树的情况：</p>
<p><img src="IA-Chapter12-Notes/2019-10-26-16-21-45.png" alt="二叉搜索树"></p>
<p>可以看到两个树都有8个结点，但(a)中的树较为平衡，树的深度较低，(b)树则很不平衡都集中在了右树上，树的深度较深。</p>
<p>二叉搜索树可以通过简单的递归按顺序打印出所有结点的数值，称为<code>中序树遍历(inorder tree walk)</code>，这个方法是先打印左树的值，再打印中间结点的值，最后打印右树的值。同理，还有<code>前序树遍历(preorder tree walk)</code>和<code>后序树遍历(postorder tree walk)</code>。</p>
<p>中序树遍历的伪代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INORDER-TREE-WALK(x)</span><br><span class="line"></span><br><span class="line">if x!=NULL</span><br><span class="line">	INORDER-TREE-WALK(x.left)</span><br><span class="line">	print x.key</span><br><span class="line">	INORDER-TREE-WALK(x.right)</span><br></pre></td></tr></table></figure>
<p>中序树遍历的时间复杂度为$\Theta(n)$。</p>
<p>证明如下：首先因为中序遍历需要访问所有n个结点，所以时间复杂度最少为$\Omega(n)$，所以只要证明时间复杂度为$T(n)=O(n)$即能满足情况。</p>
<p>在空树的情况下，因为需要判断<code>x!=null</code>，所以也是存在一些时间花费的，以$T(0)=c$来表示。设左树有$k$个结点，则右树有$n-k-1$个结点，那么遍历时间可表达为$T(n)\leq T(k) + T(n-k+1) +d$。这个$d$表示是一个常数，用来控制右式为遍历时间的上限。</p>
<p>后面我们可以通过<code>4.3</code>节中的替代法来证明，为了证明$T(n)=O(n)$，假设$T(n)\leq (c+d)n+c$。对于$n=0$,$(c+d)0+c=c=T(n)$，满足情况，对于$n&gt;0$来说</p>
<script type="math/tex; mode=display">
T(n)\leq T(k) + T(n-k+1) +d \\\\
=( (c+d)k + c ) + ( (c+d)(n-k-1) +c ) +d \\\\
=c + (c+d)n  -(c+d) +c +d\\\\
=(c+d)n +c</script><p>满足猜测，所以证明得$T(n)=O(n)$。因此结合$T(n)=\Omega(n)$可得$T(n)=\Theta(n)$</p>
<h3 id="Querying-a-binary-search-tree"><a href="#Querying-a-binary-search-tree" class="headerlink" title="Querying a binary search tree"></a>Querying a binary search tree</h3><p>二叉树的一系列操作，如<code>MINIMUM</code>，<code>MAXIMUM</code>,<code>SUCCESSOR</code>,<code>PREDECESSOR</code>的时间复杂度都与树的高度有关，对一个高度为$h$的数，这些操作的复杂度为$O(h)$</p>
<h4 id="Searching"><a href="#Searching" class="headerlink" title="Searching"></a>Searching</h4><p>根据二叉搜索树的特性，我们只要判断目标值是否与当前值相同，如果相同则返回当前节点，如果小于则在当前节点的左树搜索，否则在右树搜索</p>
<p>搜索递归伪代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TREE-SEARCH(x,k)</span><br><span class="line"></span><br><span class="line">if x==NULL or k==x.key</span><br><span class="line">    return x</span><br><span class="line"></span><br><span class="line">if k &lt; x.key</span><br><span class="line">    return TREE-SEARCH(x.left,k)</span><br><span class="line"></span><br><span class="line">return TREE-SEARCH(x.right,k)</span><br></pre></td></tr></table></figure>
<p>这个递归代码也可以通过循环方式来写，通常来说通过循环迭代方法实现的效率更高，因为少了函数的压栈与出栈操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">TREE-SEARCH(x,k)</span><br><span class="line"></span><br><span class="line">while(x != NULl and k != x.key)</span><br><span class="line">&#123;</span><br><span class="line">    if k &lt; x.key</span><br><span class="line">        x = x.left</span><br><span class="line">    else</span><br><span class="line">        x= x.right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return x</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>两种方法的C++实现如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">BinarySearchTree::Search</span><span class="params">(TreeNode* rootNode, <span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (rootNode == <span class="literal">nullptr</span> || rootNode-&gt;value == value)</span><br><span class="line">		<span class="keyword">return</span> rootNode;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> value &lt; rootNode-&gt;value ? <span class="built_in">Search</span>(rootNode-&gt;leftChild, value) : <span class="built_in">Search</span>(rootNode-&gt;rightChild, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">BinarySearchTree::Search</span><span class="params">(TreeNode* rootNode, <span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (rootNode != <span class="literal">nullptr</span> &amp;&amp; rootNode-&gt;value != value)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (value &lt; rootNode-&gt;value)</span><br><span class="line">			rootNode = rootNode-&gt;leftChild;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			rootNode = rootNode-&gt;rightChild;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> rootNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Minimum-and-Maximum"><a href="#Minimum-and-Maximum" class="headerlink" title="Minimum and Maximum"></a>Minimum and Maximum</h4><p>最大最小值的获取很简单，找到最左的节点即为最小值，找到最右的节点即为最大值，伪代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TREE-MINIMUM(x)</span><br><span class="line"></span><br><span class="line">while x.left != NULL</span><br><span class="line">    x = x.left</span><br><span class="line">return x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TREE-MAXIMUM(x)</span><br><span class="line"></span><br><span class="line">while x.right !=NULL</span><br><span class="line">    x = x.right</span><br><span class="line">return x</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>c++ 实现如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">BinarySearchTree::Maximum</span><span class="params">(TreeNode* node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (node == <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Tree is empty&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (node-&gt;rightChild != <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		node = node-&gt;rightChild;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">BinarySearchTree::Minimum</span><span class="params">(TreeNode* node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (node == <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Tree is empty&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (node-&gt;leftChild != <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		node = node-&gt;leftChild;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Successor-and-predecessor"><a href="#Successor-and-predecessor" class="headerlink" title="Successor and predecessor"></a>Successor and predecessor</h4><p><code>Successor</code>函数是找比当前结点值大的所有结点中，最小的一个<br><code>Predecessor</code>函数值找比当前结点值小的所有结点中，最大的一个</p>
<p><code>Successor</code>算法的思路是：</p>
<p>（1） 如果一个节点的右子树不为空，那么右子树中的最小值即为比当前结点值刚好大的节点。</p>
<p>（2） 如果右子树为空，则需要从父节点中找寻比自己刚好大的节点，使用x.p遍历逐渐向上寻找祖先节点，直到遇到第一个祖先结点让当前结点或当前节点的祖先是它的左子树，这个父结点就是刚好大的节点。如下图中，我们以结点13为例子，7是13的父节点，但13是是它的右子树，所以不满足。继续向上找到6结点，但结点7是结点6的右子树，所以仍然不满足。再向上找到结点15，结点6是他的左子树，所以满足条件。即15为节点13的Successoor。</p>
<p><code>Predecessor</code>算法的思路可以看出是<code>Successor</code>的镜像，即</p>
<p>（1） 如果一个节点的左子树不为空，那么左子树中的最大值即为比当前结点值刚好小的节点。</p>
<p>（2） 如果左子树为空，则需要从父节点中找寻比自己刚好小的节点，使用x.p遍历逐渐向上寻找祖先节点，直到遇到第一个祖先结点让当前结点或当前节点的祖先是它的右子树，这个父结点就是刚好小的节点。</p>
<p><img src="IA-Chapter12-Notes/2019-11-05-17-12-58.png" alt="二叉搜索树"></p>
<p><code>Successor</code>和<code>Predecessor</code>伪代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">TREE-SUCCESSOR(x)</span><br><span class="line"></span><br><span class="line">if x.right != NULL</span><br><span class="line">    return TREE-MINIMUM(x.right)</span><br><span class="line"></span><br><span class="line">y = x.p</span><br><span class="line"></span><br><span class="line">while( y != NULL &amp;&amp; x == y.right )</span><br><span class="line">    x = y;</span><br><span class="line">    y = y.p;</span><br><span class="line"></span><br><span class="line">return y;</span><br><span class="line"></span><br><span class="line">TREE-PREDECESSOR(x)</span><br><span class="line"></span><br><span class="line">if x.left != NULL</span><br><span class="line">    return TREE-MAXIMUM(x.left)</span><br><span class="line"></span><br><span class="line">y = x.p</span><br><span class="line"></span><br><span class="line">while( y != NULL &amp;&amp; x == y.left )</span><br><span class="line">    x = y;</span><br><span class="line">    y = y.p;</span><br><span class="line"></span><br><span class="line">return y;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>c++实现如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BSTreeNode* <span class="title">BinarySearchTree::Successor</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BSTreeNode* node = <span class="built_in">Search</span>(root, value);</span><br><span class="line">	<span class="keyword">if</span> (node == <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Can&#x27;t find node with &quot;</span> &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (node-&gt;rightChild != <span class="literal">nullptr</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Minimum</span>(node-&gt;rightChild);</span><br><span class="line"></span><br><span class="line">	BSTreeNode* nodeParent = node-&gt;parent;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (nodeParent != <span class="literal">nullptr</span> &amp;&amp; node == nodeParent-&gt;rightChild)</span><br><span class="line">	&#123;</span><br><span class="line">		node = nodeParent;</span><br><span class="line">		nodeParent = node-&gt;parent;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> nodeParent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BSTreeNode* <span class="title">BinarySearchTree::Predecessor</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BSTreeNode* node = <span class="built_in">Search</span>(root, value);</span><br><span class="line">	<span class="keyword">if</span> (node == <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Can&#x27;t find node with &quot;</span> &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (node-&gt;leftChild != <span class="literal">nullptr</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Maximum</span>(node-&gt;leftChild);</span><br><span class="line"></span><br><span class="line">	BSTreeNode* nodeParent = node-&gt;parent;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (nodeParent != <span class="literal">nullptr</span> &amp;&amp; node == nodeParent-&gt;leftChild)</span><br><span class="line">	&#123;</span><br><span class="line">		node = nodeParent;</span><br><span class="line">		nodeParent = node-&gt;parent;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> nodeParent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note info simple"><p>可以看到，无论是Search,Minimum,Maximum,Successor,Predecessor，在最坏的情况下，都是遍历树的每一层，所以时间复杂度为$O(h)$</p>
</div>
<h3 id="Insertion-and-deletion"><a href="#Insertion-and-deletion" class="headerlink" title="Insertion and deletion"></a>Insertion and deletion</h3><p>二叉搜索树的插入和删除操作都需要保证改变的结点不会影响二叉搜索树的特性。</p>
<h4 id="Insertion"><a href="#Insertion" class="headerlink" title="Insertion"></a>Insertion</h4><p>插入算法的思想是用一个变量（伪代码中是变量$x$）来找寻插入结点(伪代码中被插入结点为$z$)的位置，用另一个变量（伪代码中为$y$）来记录第一个变量的父节点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TREE-INSERT(T,z)</span><br><span class="line"></span><br><span class="line">//T-&gt;被插入树，z-&gt;需要插入的结点</span><br><span class="line"></span><br><span class="line">y = NULL</span><br><span class="line">x = T.root</span><br><span class="line">//出循环时，X为空，即为z将要插入的位置，y是x的父节点</span><br><span class="line">while x != NULL </span><br><span class="line">    y = x</span><br><span class="line">    if z.key &lt; x.key</span><br><span class="line">        x = x.left</span><br><span class="line">    else</span><br><span class="line">        x = x.right</span><br><span class="line">z.p = y;</span><br><span class="line">if (y == NULL)</span><br><span class="line">    T.root = z;</span><br><span class="line">else if ( z.key &lt; y.key)</span><br><span class="line">    y.left = z</span><br><span class="line">else</span><br><span class="line">    y.right = z</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>c++实现为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BinarySearchTree::Insert</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BSTreeNode* node = (BSTreeNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BSTreeNode));</span><br><span class="line">	node-&gt;value = value;</span><br><span class="line">	node-&gt;leftChild = <span class="literal">nullptr</span>;</span><br><span class="line">	node-&gt;rightChild = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	BSTreeNode* target = root;</span><br><span class="line">	BSTreeNode* targetParent = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (target != <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		targetParent = target;</span><br><span class="line">		target = value &lt; target-&gt;value ? target-&gt;leftChild : target-&gt;rightChild;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (targetParent == <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		root = node;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (value &lt; targetParent-&gt;value)</span><br><span class="line">		targetParent-&gt;leftChild = node;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		targetParent-&gt;rightChild = node;</span><br><span class="line"></span><br><span class="line">	node-&gt;parent = targetParent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>插入算法需要从上到下遍历整棵树，所以时间复杂度为$O(h)$</p>
<h4 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h4><p>删除操作相比插入操作更复杂一些，需要考虑三种情况。将需要删除的结点称为$z$</p>
<ol>
<li><p>$z$没有子结点</p>
<p>可直接删除</p>
</li>
<li><p>$z$只有一个子结点</p>
<p> 用存在的节点<code>替换</code>$z$</p>
</li>
<li><p>$z$有两个子结点</p>
<p> 找到$z$的<code>Successor</code>，这里称为$y$，然后需要再细分为两种情况讨论。</p>
<p> 注意这两种情况下$y$的左树不需要管，因为左树必然为空，否则<code>Successor</code>将出现在$y$的左树中。</p>
<p> (1) $y$是$z$的右子节点</p>
<p> 用$y$替换$z$</p>
<p> (2) $y$不是$z$的右子节点</p>
<p> 用$y$的右树替换$y$的位置。将$z$的右树作为$y$的右树，再用$y$替换$z$</p>
</li>
</ol>
<ul>
<li>因为$z$有两个子节点，所以<code>Successor</code>必然是$z$右子树中的最小值</li>
</ul>
<p>删除的示意图如下，其中图(a)(b)表示$z$只有一个子结点的情况，(c)(d)表示存在两个子结点的情况，其中(c)表示$y$即为$z$的右子树，(d)表示$y$不是$z$的右子树。</p>
<ul>
<li>$z$没有子结点的情况，也可以用(a)(b)表示，即将存在的结点看作为空。</li>
</ul>
<p><img src="IA-Chapter12-Notes/2019-11-06-13-46-14.png" alt="删除示意图"></p>
<p>在实现DELETE算法前，需要先实现被反复用到的<code>替换</code>算法，伪代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//u为被替换节点，v为替换节点</span><br><span class="line">TRANSPLANT(T,u,v)</span><br><span class="line"></span><br><span class="line">if u.p == NULL //将v设为u的parnet的新子节点</span><br><span class="line">    T.root = v;</span><br><span class="line">else if u == u.p.left</span><br><span class="line">    u.p.left = v</span><br><span class="line">else</span><br><span class="line">    u.p.right = v</span><br><span class="line">if v != NULL //将v的parent设为u的parent</span><br><span class="line">    v.p = u.p</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>c++实现如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BinarySearchTree::transplant</span><span class="params">(BSTreeNode* originNode, BSTreeNode* newNode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (originNode-&gt;parent == <span class="literal">nullptr</span>)</span><br><span class="line">		root = newNode;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (originNode == originNode-&gt;parent-&gt;leftChild)</span><br><span class="line">		originNode-&gt;parent-&gt;leftChild = newNode;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		originNode-&gt;parent-&gt;rightChild = newNode;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (newNode != <span class="literal">nullptr</span>)</span><br><span class="line">		newNode-&gt;parent = originNode-&gt;parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>注意TRANSPART算法并没有处理u的子结点。替换后u的子节点处于没有追踪的状态</li>
</ul>
<p>Delete算法的伪代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TREE-DELETE(T,z)</span><br><span class="line"></span><br><span class="line">if z.left == NULL //只有一种节点的情况，用另一个节点替换z</span><br><span class="line">    TRANSPLANT(T , z , z.right)</span><br><span class="line">else if z.right == NULL //只有一种节点的情况，用另一个节点替换z</span><br><span class="line">    TRANSPLANT(T , z , z.left)</span><br><span class="line">else</span><br><span class="line">    y = MINIMUM(y.right) //求得Successor</span><br><span class="line">    if y.p != z // y不是z的右子树的情况，</span><br><span class="line">        TRANSPLANT(T, y, y.right) //y的右子树替换y的位置</span><br><span class="line">        y.right = z.right //z的右子树作为y的右子树</span><br><span class="line">        y.right.p = y</span><br><span class="line">    TRANSPLANT(T,z,y) //用y替换z</span><br><span class="line">    y.left = z.left //TRANSPLANT算法并没有处理z的子树情况，所以这里需要处理</span><br><span class="line">    y.left.p = y</span><br></pre></td></tr></table></figure>
<p>c++代码实现如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BinarySearchTree::Delete</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BSTreeNode* toDeleteNode = <span class="built_in">Search</span>(root, value);</span><br><span class="line">	<span class="keyword">if</span> (toDeleteNode == <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; &quot;There is no node with value &quot; &lt;&lt; value &lt;&lt; endl;</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (toDeleteNode-&gt;leftChild == <span class="literal">nullptr</span>)</span><br><span class="line">		<span class="built_in">transplant</span>(toDeleteNode, toDeleteNode-&gt;rightChild);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (toDeleteNode-&gt;rightChild == <span class="literal">nullptr</span>)</span><br><span class="line">		<span class="built_in">transplant</span>(toDeleteNode, toDeleteNode-&gt;leftChild);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		BSTreeNode* successorNode = <span class="built_in">Minimum</span>(toDeleteNode-&gt;rightChild);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (successorNode-&gt;parent != toDeleteNode)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">transplant</span>(successorNode, successorNode-&gt;rightChild);</span><br><span class="line">			<span class="comment">//Handle toDeleteNode&#x27;s right child</span></span><br><span class="line">			<span class="comment">//因为successorNode不是toDelete的子节点，所以toDeleteNode的右节点一定比他大，所以作为它的右子树。</span></span><br><span class="line">			successorNode-&gt;rightChild = toDeleteNode-&gt;rightChild;</span><br><span class="line">			toDeleteNode-&gt;rightChild-&gt;parent = successorNode;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">transplant</span>(toDeleteNode, successorNode);</span><br><span class="line">		<span class="comment">//Handle toDeleteNode&#x27;s left child</span></span><br><span class="line">		successorNode-&gt;leftChild = toDeleteNode-&gt;leftChild;</span><br><span class="line">		toDeleteNode-&gt;leftChild-&gt;parent = successorNode;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">free</span>(toDeleteNode);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除操作算法并不存在循环，所以大部分操作都是固定时间，除了用来找<code>Successor</code>的MINIMUM算法，因为MINIMUM算法的复杂度为$O(h)$，所以删除算法的复杂度也为$O(h)$</p>
<h3 id="Randomly-built-binary-search-trees"><a href="#Randomly-built-binary-search-trees" class="headerlink" title="Randomly built binary search trees"></a>Randomly built binary search trees</h3><p>//TODO</p>
<div class="note info simple"><p>引用：</p>
<ol>
<li><em>Introduction to Algorithms</em> 3rd Sep.2009</li>
</ol>
</div>
<hr>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>《如何阅读一本书》 笔记</title>
    <url>/HowToReadABookNotes/</url>
    <content><![CDATA[<p>《如何阅读一本书》思维导图、简评、笔记与摘要。</p>
<span id="more"></span>
<h1 id="简评"><a href="#简评" class="headerlink" title="简评"></a>简评</h1><p>反思了下自己2018年的读书或许自己太注重读书的量而没有关心读书的质，以至于许多的书看过后并没有留下什么印象。想起了曾经在Kindle上读过的《如何阅读一本书》，这本书在当时给自己留下了很深的印象，但没有付诸于实践。在春节假期的后半段决定重写阅读这本书来帮助自己在新的一年提高阅读的质量。</p>
<p>读书过程中按照书的章节做了完整的笔记与摘要，笔记与摘要内容很长，没必要完整阅读，主要是为了以后如果需要复习可以回忆起特定章节的内容。同时为了以后可以快速回忆起整本书的主要建议，整理了对应的思维导图。</p>
<p>合格的阅读应该是带有主动思考的阅读，作者认为主动阅读需要回答四个基本问题：</p>
<ol>
<li>整体而言，这本书到底在谈些什么？</li>
<li>作者局部细说了什么？怎么说的？</li>
<li>这本书说的有道理吗，是全部有有道理还是部分有道理？</li>
<li>这本书跟你有什么关系？如果这本书给了你一些资讯，你一定要问问这些资讯有什么意义。</li>
</ol>
<p>作者提出要通过三个层次的阅读来回答这四个问题：检视阅读、分析阅读、主题阅读，并分别讲解了每个层次中需要遵循的规则或要点。</p>
<p>作者还分别解析了面对不同种类的书籍该如何调整这些规则与要点，并给出了阅读特定种类书籍的建议。</p>
<p>全书主要关注的是主动阅读中该如何去有效的思考，这样的一个较高层次的指导，针对于读书过程中<code>如何做笔记</code>以及<code>如何整理书中的内容</code>这样更实践性的指导仅是一笔带过。</p>
<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="HowToReadABookNotes/HowToReadABook_MindMaps.png" alt="思维导图"></p>
<h1 id="笔记与摘要"><a href="#笔记与摘要" class="headerlink" title="笔记与摘要"></a>笔记与摘要</h1><h2 id="阅读的层次"><a href="#阅读的层次" class="headerlink" title="阅读的层次"></a>阅读的层次</h2><h3 id="阅读的活力与艺术"><a href="#阅读的活力与艺术" class="headerlink" title="阅读的活力与艺术"></a>阅读的活力与艺术</h3><p>信息时代使得人们可以轻易的获取大量的知识，这些知识也包括了媒体人经过设计和包装后再次传递出来的知识。但这样的行为实际上让平常人失去了独自思考的能力，并且将他人的结论误认为是“自己”的成果。</p>
<blockquote>
<ol>
<li>太多的资讯就如同太少的资讯一样，都是一种对理解力的阻碍。换句话说，现代的媒体正以压倒性的泛滥资讯阻碍了我们的理解力。</li>
<li>如何将知识分子的态度与观点包装起来，是当今最有才智的人在做的最活跃的事业之一。</li>
</ol>
</blockquote>
<h4 id="主动阅读"><a href="#主动阅读" class="headerlink" title="主动阅读"></a>主动阅读</h4><p>读书或多或少是一个主动的行为，人总不能眼神呆滞放空大脑还能进行有效的阅读。作者和读者的关系如同投手和打击手，读书是一个作者和读者配合的工作。作者在写书时会考虑该怎样让读者理解，而读者则要学会如何理解作者的各种表达方式和内容。</p>
<blockquote>
<ol>
<li>第一提醒读者，阅读可以是一件多少主动的事。第二要指出的是，阅读越主动，效果越好。</li>
<li>其实完全相反，听众或读者的“接收”，应该像是棒球赛中的捕手 才对。 捕手在接球时所发挥的主动是跟投手或打击手一样的。</li>
<li>捕手的艺术就在能接住任何球的技巧—— 快速球、曲线球、变化球、慢速球等等。同样地，阅读的艺术也在尽可能掌握住每一种讯息的技巧。</li>
</ol>
</blockquote>
<h4 id="阅读的目标：为获取资讯而读，以及为增进理解而读"><a href="#阅读的目标：为获取资讯而读，以及为增进理解而读" class="headerlink" title="阅读的目标：为获取资讯而读，以及为增进理解而读"></a>阅读的目标：为获取资讯而读，以及为增进理解而读</h4><p>阅读的目标分为两种，一是为获取资讯而读，二是为增进理解而阅读。</p>
<p>例如一个人对于美国历史已经有了一部分的了解，也有一些自己的理解。当一份新的资料，他用自己原先的理解角度完全可以解释的话，那这份资料的阅读就只是第一种阅读，而如果在新资料中他获得了新的理解，那就是第二种阅读了。</p>
<h4 id="为获取资讯而读"><a href="#为获取资讯而读" class="headerlink" title="为获取资讯而读"></a>为获取资讯而读</h4><blockquote>
<p>如果很了解，你就获得了资讯（但你的理解力不一定增强）。…这本书的讯息只是将你还没读这本书之前你们便共同了解的东西传达出来而已。…这样的读物能增加我们的资讯，却不能增进我们的理解力，因为在开始阅读之前，我们的理解力就已经与他们完全相当了。</p>
</blockquote>
<h4 id="为增进理解而读"><a href="#为增进理解而读" class="headerlink" title="为增进理解而读"></a>为增进理解而读</h4><blockquote>
<ol>
<li>只有一种方式是真正地在阅读。没有任何外力的帮助，你就是要读这本书。你什么都没有，只凭着内心的力量，玩味着眼前的字句，慢慢地提升自己，从只有模糊的概念到更清楚地理解为止。这样的一种提升，是在阅读时的一种脑力活动，也是更高的阅读技巧。</li>
<li>这是一个凭借着头脑运作，除了玩味读物中的一些字句之外，不假任何外助，以一己之力来提升自我的过程。</li>
<li>这个东西的水平就是比阅读的人高上一截。这个作者想要表达的东西，能增进阅读者的理解力。</li>
</ol>
</blockquote>
<h4 id="阅读就是学习：指导型的学习，以及自我发现型学习之间的差异"><a href="#阅读就是学习：指导型的学习，以及自我发现型学习之间的差异" class="headerlink" title="阅读就是学习：指导型的学习，以及自我发现型学习之间的差异"></a>阅读就是学习：指导型的学习，以及自我发现型学习之间的差异</h4><p>学习的过程，首先是吸收资讯，之后是被这些资讯启示进而提升理解力。</p>
<blockquote>
<ol>
<li>如果你运用的只是你的记忆力，其实你除了那些讯息之外一无所获。你并没有被启发。要能被启发，除了知道作者所说的话之外，还要明白他的意思，懂得他为什么会这么</li>
<li>初学者的无知在于未学，而学者的无知在于学后。”第一种的无知是连字母都没学过，当然无法阅读。第二种的无知却是读错了许多书。英国诗人亚历山大·蒲伯（Alexander Pope）称这种人是书呆子，无知的阅读者。总有一些书呆子读的太广，却读不通。</li>
</ol>
</blockquote>
<p>指导型学习和自我发现型学习的区别并非指导型学习是被动的，自我发现型学习是主动的，两者都是主动的，没有一种学习是死气沉沉的，指导型学习更确切的可以表达为“辅助型的自我发现学习。”</p>
<blockquote>
<p>事实上，要区分得更清楚一些的话，我们可以称指导型的学习是“辅助型的自我发现学习”。</p>
</blockquote>
<p>两者的主要区别实际在于教材，前者是基于他们传递的讯息，后者则是自我和世界。</p>
<blockquote>
<ol>
<li>当他被指导时，在老师帮助下自我发现时，学习者的行动立足于传达给他的讯息。</li>
<li>当学习者在没有任何老师指导帮助下开始学习时，学习者则是立足于自然或世界，而不是教导来行动。</li>
<li>非辅助型的自我发现学习——是阅读自我或世界的学习。就像指导型学习（被教导或辅助型学习）是阅读一本书，包括倾听，从讲解中学习的一种艺术。</li>
</ol>
</blockquote>
<p>两种学习方法都需要用到思考。不同的是，在自我发现型的学习中在思考后还会凭借自己的感觉去运用想象，而这是在指导型学习中被遗忘或忽略的过程。</p>
<blockquote>
<ol>
<li>思考只是主动阅读的一部分。一个人还必须运用他的感觉与想象力。一个人必须观察，记忆，在看不到的地方运用想象力。我们要再提醒一次，这就是在非辅助型的学习中经常想要强调的任务，而在指导型的任务，或倾听学习中被遗忘或忽略的过程。</li>
<li>阅读的艺术包括了所有非辅助型自我发现学习的技巧：敏锐的观察、灵敏可靠的记忆、想象的空间，再者当然就是训练有素的分析、省思能力。</li>
</ol>
</blockquote>
<h4 id="老师的出席与缺席"><a href="#老师的出席与缺席" class="headerlink" title="老师的出席与缺席"></a>老师的出席与缺席</h4><p>上一节阐述指导型学习的过程中，举了阅读和倾听两个例子，倾听存在有活生生的老师教导，而阅读往往只能靠自己。</p>
<blockquote>
<ol>
<li>倾听是从一位出现在你面前的老师学习——一位活生生的老师——而阅读确实跟一位缺席的老师学习。</li>
<li>如果一本书就是你的老师的话，你就得一切靠自己。</li>
</ol>
</blockquote>
<p>本书的目的就是教导读者如何靠自己更好的阅读一本书。</p>
<h3 id="阅读的层次-1"><a href="#阅读的层次-1" class="headerlink" title="阅读的层次"></a>阅读的层次</h3><h4 id="第一层阅读：基础阅读"><a href="#第一层阅读：基础阅读" class="headerlink" title="第一层阅读：基础阅读"></a>第一层阅读：基础阅读</h4><p>基础阅读解决的是认出书中所有的字符和知道这些话在说什么。基础阅读基本在小学阶段就已经训练完毕。这一层阅读的熟练与否也影响阅读的速度。</p>
<blockquote>
<p>大部分的困难都是技术性的问题，有些可以追溯到早起阅读教育的问题。因此，大部分的速度课程都着眼在这个层次的阅读上。</p>
</blockquote>
<h4 id="第二个阅读：检视阅读"><a href="#第二个阅读：检视阅读" class="headerlink" title="第二个阅读：检视阅读"></a>第二个阅读：检视阅读</h4><p>这个层次也称为略读或预读，检视阅读解决的问题是在一段时间内了解到一本书的重点。在这个层次阅读中需要从表面观察这本书，了解到这本书在谈些什么，框架是怎样的。大部分人往往都忽略了检视阅读的重要性。</p>
<blockquote>
<ol>
<li>因此，用另一种方式来形容这个层次的阅读，就是在一定的时间之内，抓出一本书的重点</li>
<li>我们想要强调的是，大多数人，即使是许多优秀的阅读者，都忽略了检视阅读的价值。他们打开一本书，从第一页开始读起，孜孜不倦，甚至连目录都不看一眼。因此，他们在只需要粗浅翻阅一本书的时候，却拿出了仔细阅读、理解一本书的时间。</li>
</ol>
</blockquote>
<h4 id="第三层阅读：分析阅读"><a href="#第三层阅读：分析阅读" class="headerlink" title="第三层阅读：分析阅读"></a>第三层阅读：分析阅读</h4><p>分析阅读就是全盘、完整、仔细的阅读。</p>
<blockquote>
<ol>
<li>如果说检视阅读是在有限的时间内，最好也最完整的阅读，那么分析阅读就是在无限的时间里，最好也最完整的阅读。</li>
<li>弗兰西斯·培根曾经说过：“有些书可以浅尝即止，有些书是要生吞活剥，只有少数的书是要咀嚼与消化的。”分析阅读就是要咀嚼与消化一本书。</li>
</ol>
</blockquote>
<h4 id="第四层阅读：主题阅读"><a href="#第四层阅读：主题阅读" class="headerlink" title="第四层阅读：主题阅读"></a>第四层阅读：主题阅读</h4><p>主题阅读是最复杂、最系统化、最主动、最花力气的阅读。主题阅读需要读者在不同的书之间找到相关之处，甚至于得出一个哪本书中都没有提过的结论。</p>
<blockquote>
<ol>
<li>在做主题阅读时，阅读者会读很多的书，而不是一本书，并列举出这些书之间相关之处，提出一个所有的书都谈到的主题。</li>
<li>借助他所阅读的书籍，主题阅读者要能架构出一个可能在哪一本书中都没有提到的主题分析。</li>
</ol>
</blockquote>
<h3 id="阅读的第一个层次：基础阅读"><a href="#阅读的第一个层次：基础阅读" class="headerlink" title="阅读的第一个层次：基础阅读"></a>阅读的第一个层次：基础阅读</h3><h4 id="学习阅读的阶段"><a href="#学习阅读的阶段" class="headerlink" title="学习阅读的阶段"></a>学习阅读的阶段</h4><p>第一个阶段为阅读准备阶段，这一阶段从出生开始到6-7岁为止，包括身体和智力方面的准备，如有良好的视力和听力，有基本的认知能力等。<br>第二个阶段，孩子会阅读一些简单的读物，在这个阶段中，孩子会有一些基本的阅读技巧如字句的使用，字句的含义等。<br>第三个阶段，孩子会拥有快速建立字汇的能力，通过上下文提供的线索，去猜测不熟悉的字眼。同时在这个阶段孩子也会自发性的去阅读<br>第四个阶段，精炼与增进前面所学的技巧。在这个阶段学生开始消化他的阅读经验，可以对作者提出的观点进行比较。</p>
<p>这通常一个完成了正常学业的成年人都是已经通过了这四个阶段的。</p>
<h4 id="阅读的阶段与层次"><a href="#阅读的阶段与层次" class="headerlink" title="阅读的阶段与层次"></a>阅读的阶段与层次</h4><p>当一个人通过了上述四个阶段时，他便已经精通了第一个层次的阅读，但也仅此而已。<br>一般而言，在度过四个阶段时，都有老师相伴，都是辅助型的自我发现阅读。而之后的阅读便会开始非辅助型自我发现阅读。</p>
<h4 id="更高层次的阅读与高等教育"><a href="#更高层次的阅读与高等教育" class="headerlink" title="更高层次的阅读与高等教育"></a>更高层次的阅读与高等教育</h4><blockquote>
<p>一个人文素养优良的高中，就算什么也没做，也该培养出能达到分析阅读的读者。一个优秀的大学，就算什么也没贡献，也该培养出能进行主题阅读的读者。</p>
</blockquote>
<h4 id="阅读与民主教育的理念"><a href="#阅读与民主教育的理念" class="headerlink" title="阅读与民主教育的理念"></a>阅读与民主教育的理念</h4><blockquote>
<p>我们一定要比一个人人识字的国家更进一步。我们的国人应该变成一个个真正“有能力”的阅读者，能够真正认知“有能力”这个字眼的含义。</p>
</blockquote>
<h3 id="阅读的第二个层次：检视阅读"><a href="#阅读的第二个层次：检视阅读" class="headerlink" title="阅读的第二个层次：检视阅读"></a>阅读的第二个层次：检视阅读</h3><h4 id="检视阅读一：有系统的略读或粗读"><a href="#检视阅读一：有系统的略读或粗读" class="headerlink" title="检视阅读一：有系统的略读或粗读"></a>检视阅读一：有系统的略读或粗读</h4><p>略读的步骤：</p>
<ol>
<li>看书名页，有序就先看序，对书的主题有个概念。</li>
<li>研究目录页，对书的基本架构做概括性的理解。</li>
<li>检阅书的缩影，快速评估这本书涵盖了哪些议题。</li>
<li>如果是新书，看下书衣上出版者的介绍。</li>
</ol>
<p>上述四个步骤完成后，基本对于一本书已经有了基本的资讯。如果是决定要仔细读或者决定不读，这时将书放在一边，否则便继续做一下的略读。</p>
<ol>
<li>在第二步看完目录页后，挑些认为和主题息息相关的篇章看看。</li>
<li>把书随便翻翻，任意读个一两段，以这样的方式把全书翻阅一遍，寻找主要论点的讯号，留意主题的基本脉动。也可以直接看书的最后几页，因为往往作者会在最后几页中整理自己的观点。</li>
</ol>
<p>上述的六个步骤应该在一小时内完成。</p>
<blockquote>
<p>你可以把自己想做一个侦探，在寻找一本书的主题或思想的线索。随时保持敏感，就很容易让一切状况清楚。</p>
</blockquote>
<h4 id="检视阅读二：粗浅的阅读"><a href="#检视阅读二：粗浅的阅读" class="headerlink" title="检视阅读二：粗浅的阅读"></a>检视阅读二：粗浅的阅读</h4><p>粗浅的阅读即在阅读过程中发现自己理解不了的部分，就略过继续读下去，读到能读懂的部分就继续看下去，这样先对书有一个了解。在之后的阅读中，这部分的了解会帮助理解那些难懂的部分。</p>
<blockquote>
<p>头一次面对一本难读的书的时候，从头到尾先读一遍，碰到不同的地方不要停下来查询或思索。</p>
</blockquote>
<h4 id="阅读的速度"><a href="#阅读的速度" class="headerlink" title="阅读的速度"></a>阅读的速度</h4><p>速读和检视阅读都是加快读书的速度，但速读更多层面上时解决基础阅读层面的困难。检视阅读之所以快是因为读者只读了书中一小部分，而且是用不同的方式去读，不同的目标去读。</p>
<blockquote>
<ol>
<li>检视阅读的两个方式都需要快速的阅读，一个熟练的检视阅读者想要读一本书时，无论碰到多难读或多长的书，都能很快的运用者两种方式读完。</li>
<li>许多书其实是连略读都不值得的，另外一些书只需要快速读过就可以了。有少数的书需要用某种速度，通常是相当慢的速度，才能完全理解。</li>
</ol>
</blockquote>
<h4 id="逗留与倒退"><a href="#逗留与倒退" class="headerlink" title="逗留与倒退"></a>逗留与倒退</h4><p>速读解决了基础阅读的两个问题，逗留和倒退，我们可以用手引导眼睛来解决问题。</p>
<blockquote>
<ol>
<li>许多人在阅读时会用半出声的方式阅读，在阅读一行字的时候在五六个地方发生逗留，而且常在每阅读两三行之后，眼睛就自然地“倒退”。这些都很大程度影响了阅读的速度。</li>
<li>纠正的方法也很简单，用手指着段落且手移动的速度大于眼睛看的速度，这样持续的增加手的速度，阅读的速度也就相应地提高了。</li>
</ol>
</blockquote>
<h4 id="理解的问题"><a href="#理解的问题" class="headerlink" title="理解的问题"></a>理解的问题</h4><p>速读课程在增加阅读速度的同时也增加了理解力，因为要保证快速的阅读速度，读者也只能专注于阅读的东西上。但理解力也不仅仅等同于专注力，它往往还有超越了基础阅读的部分，这也是这本书需要讨论的部分。</p>
<h4 id="检视阅读的摘要"><a href="#检视阅读的摘要" class="headerlink" title="检视阅读的摘要"></a>检视阅读的摘要</h4><p>检视阅读的两个步骤都是分析阅读之前的预备动作。</p>
<h3 id="如何做一个自我要求的读者"><a href="#如何做一个自我要求的读者" class="headerlink" title="如何做一个自我要求的读者"></a>如何做一个自我要求的读者</h3><p>在阅读时保持清醒或昏昏欲睡取决的于阅读的目标是否是获得利益，如果是则就会保持清醒，也会在阅读时尽可能的保持主动。</p>
<h4 id="主动阅读的基础：一个阅读者要提出的四个基本问题"><a href="#主动阅读的基础：一个阅读者要提出的四个基本问题" class="headerlink" title="主动阅读的基础：一个阅读者要提出的四个基本问题"></a>主动阅读的基础：一个阅读者要提出的四个基本问题</h4><ol>
<li>整体而言，这本书到底在谈些什么？</li>
<li>作者局部细说了什么？怎么说的？</li>
<li>这本书说的有道理吗，是全部有有道理还是部分有道理？</li>
<li>这本书跟你有什么关系？如果这本书给了你一些资讯，你一定要问问这些资讯有什么意义。</li>
</ol>
<p>这四个问题是阅读的基本规则，也是在分析阅读中要讨论的主要议题。</p>
<blockquote>
<ol>
<li>任何一种超越基础阅读的阅读层次，核心就在你要努力提出问题。这也是有自我要求的阅读者与没有自我要求的阅读者之间，有天壤之别的原因。</li>
<li>在阅读的过程中，要记得提出这些问题。除此之外，你还要知道如何精准、正确地回答这些问题。如此训练而来的能力，就是阅读的艺术。</li>
</ol>
</blockquote>
<p>检视阅读可以给出前两个问题的一部分答案，同时也对后两个问题有帮助。分析阅读则要回答第三个问题，最后一个问题是主题阅读中最重要的部分。</p>
<h4 id="如何让一本书真正属于你自己"><a href="#如何让一本书真正属于你自己" class="headerlink" title="如何让一本书真正属于你自己"></a>如何让一本书真正属于你自己</h4><blockquote>
<p>要完全拥有一本书，必须把书的一部分变成自己的一部分，而这个最好的方法就是写下来。<br>为什么对阅读而言，在书上做笔记是不可或缺的事</p>
<ol>
<li>那会让你保持清醒</li>
<li>阅读如果是主动的，便会有思考，而思考的表现就是用语言表达出来——无论是说出来还是写出来</li>
<li>将自己的感想写下来，能帮助理解作者的思想</li>
</ol>
</blockquote>
<p>有以下几种记笔记的方法</p>
<blockquote>
<ol>
<li>画底线 强调</li>
<li>在底线处外的栏外再加画一道线 再次强调</li>
<li>在空白处做星号或其他符号。要慎用，只用来强调书中十来个最重要的声明或段落即可。</li>
<li>在空白处编号，记录下作者某个论点的一连串论述</li>
<li>在空白处记下其他的页码。把相关的要点集中在一起。</li>
<li>将关键字或句子圈起来——这与画底线的功能是一样的</li>
<li>在空白处做笔记。写下问题或者自己想法</li>
</ol>
</blockquote>
<p>也可以在书前面的空白页上写下自己的想法或整理全书的大纲。</p>
<h4 id="三种做笔记的方法"><a href="#三种做笔记的方法" class="headerlink" title="三种做笔记的方法"></a>三种做笔记的方法</h4><p>结构笔记</p>
<blockquote>
<p>在检视阅读的过程中，要回答的问题是：第一，这是本什么样的书？第二，整本书在谈的是什么？第三，作者是借着怎样的整体框架来发展他的观点或陈述他对这个主题的理解？你应该做笔记把这些答案写下来。</p>
</blockquote>
<p>检视阅读时做的结构笔记在之后的分析阅读中将会派上用处。</p>
<p>概念笔记</p>
<blockquote>
<p>等你做分析阅读时，关于这本书准确性与意义的问题，你就要提出答案了。在这个层次的阅读里，你做的笔记就不再是跟结构有关，而是跟概念有关了。</p>
</blockquote>
<p>辩证笔记</p>
<blockquote>
<p>对一个已经熟练同时读好几本相同主题书籍的专业阅读者来说，还有一个更高层次的记笔记的方法，那就是针对一场讨论情境的笔记。</p>
</blockquote>
<h4 id="培养阅读的习惯"><a href="#培养阅读的习惯" class="headerlink" title="培养阅读的习惯"></a>培养阅读的习惯</h4><p>各种阅读方法都是一种规则，而将规则变化为习惯需要大量的练习。这些规则在现在看来是割裂的，但当我们真正熟练时，规则便会融为一体。这就如同学习滑雪的过程，一开始也需要学习一个个单一的动作，但最终这些动作都会连接在一起。</p>
<blockquote>
<ol>
<li>要养成习惯，除了不断的运作联系之外，别无他法。</li>
<li>知道一项艺术的规则，跟养成习惯是不同的。</li>
<li>而你不能照规则来做，就不可能养成一种艺术或任何技能的习惯</li>
<li>换句话说，你一定要学会忘掉哪些分开的步骤，才能表现出整体的动作，而每一个单一的步骤都还要确实表现的很好。但是为了要忘掉这些单一的动作，一开始你必须先分别学会每一个单一的动作。只有这样，你才能将所有的动作连接在一起。</li>
<li>一开始是，学习者只会注意到自己与那些分开来的动作。等所有分开的动作不再分离，渐渐融为一体时，学习者便能将注意力转移到目标上，而他也具备了达成目标的能力了。</li>
</ol>
</blockquote>
<h2 id="阅读的第三个层次：分析阅读"><a href="#阅读的第三个层次：分析阅读" class="headerlink" title="阅读的第三个层次：分析阅读"></a>阅读的第三个层次：分析阅读</h2><h3 id="一本书的分类"><a href="#一本书的分类" class="headerlink" title="一本书的分类"></a>一本书的分类</h3><h4 id="书籍分类的重要性"><a href="#书籍分类的重要性" class="headerlink" title="书籍分类的重要性"></a>书籍分类的重要性</h4><p>分析阅读的第一步需要知道自己读的是什么种类的书。</p>
<blockquote>
<ol>
<li>分析阅读的第一个规则可以这么说：规则一，你一定要知道自己在读的是哪一类书，而且要越早知道越好。最好早在你开始阅读之前就先知道。</li>
<li>一本论说性的书的主要目的是在传达知识。</li>
<li>分析阅读的第一个规则，虽然适用于所有的书籍，却特别适合用来阅读非小说，论说性的书。</li>
</ol>
</blockquote>
<p>通过之前的检视阅读来完成这一规则</p>
<blockquote>
<p>之前我们已经建议过，一开始时，你要先检视这本书——用检视阅读先浏览一遍。</p>
</blockquote>
<h4 id="从一本书的书名中你能学到什么"><a href="#从一本书的书名中你能学到什么" class="headerlink" title="从一本书的书名中你能学到什么"></a>从一本书的书名中你能学到什么</h4><p>许多人常不去看书名的原因是因为觉得书籍的分类是没有必要的。但书籍的分类并不是最终目的，最终目的是了解到这一种类的书具体在谈些什么。</p>
<p>书籍分类存在有一些标准，首先可以分为虚构的<code>小说类</code>和传递知识的<code>论述类</code>，而论述类又可以再细分。</p>
<blockquote>
<ol>
<li>我们会指出这个普遍的错误，是因为许多人以为他们知道这本书的书名，而事实上只有少之又少的人真的用心读过书名，也想过其中的含意。</li>
<li>许多人会忽略书名或序言的原因之一是，他们认为要将手边阅读的这本书做分类是毫无必要的。</li>
<li>只有当你在不同的书籍之间能找出区别，并且定出一些合理又经得起时间考验的分类时，这个规则才会更简单明白一些。</li>
<li>光是将书籍分类到某一个种类中还是不够的。要跟随第一个阅读步骤，你一定要知道这个种类的书到底是在谈些什么？</li>
<li>除了实用手册与（广义的）道德论述之外，另一种实用型的作品也要提一下。任何一种演说，不论是政治演说或道德规劝，都是想告诉你该做些什么，或你该对什么事有什么样的反应。</li>
</ol>
</blockquote>
<h5 id="实用性vs理论性作品"><a href="#实用性vs理论性作品" class="headerlink" title="实用性vs理论性作品"></a>实用性vs理论性作品</h5><p>理论性书籍教导知识，实用性书籍引导行动。</p>
<blockquote>
<ol>
<li>实用是与某种有效的做法有关，不管是立即或长程的功效。而理论所关注的却是去明白或了解某件事。如果我们仔细想想这里所提出来的粗略的道理，就会明白知识与行动之间的区别。</li>
<li>理论性的作品是在教你这是什么，实用性的作品在教你如何去做你想要做的事，或你认为应该做的事。</li>
<li>严格来说，任何一本教我们如何生活，该做什么，不该做什么，同时说明做了会有什么奖赏，不做会有什么惩罚的伦理的书，不论我们是否同意他的结论，都得认定这是一本实用的书。</li>
</ol>
</blockquote>
<h5 id="理论性作品的分类"><a href="#理论性作品的分类" class="headerlink" title="理论性作品的分类"></a>理论性作品的分类</h5><blockquote>
<ol>
<li>如果一本理论的书所强调的内容，超乎你日常、例行、正常生活的经验，那就是科学的书。否则就是一本哲学的书。</li>
<li>既然书本所要传达给我们的知识不同，对我们的指导方式也会不同。</li>
</ol>
</blockquote>
<h3 id="透视一本书"><a href="#透视一本书" class="headerlink" title="透视一本书"></a>透视一本书</h3><p>书的架构如同人的骨架，分析阅读的目的就在意找出这个骨架。无论什么书存在架构，即使是小说、诗集。</p>
<p>分析阅读的第二个规则：使用一小段文字来叙述整本书的内容。书籍的分类让读者明白了这是本怎么样的书，这里我们要进一步知道这本书要干什么。</p>
<p>分析阅读的第三个规则：将书中重要的篇章列举出来，说明他们如何按照顺序组成一个整体的架构。</p>
<blockquote>
<ol>
<li>每一本书的封面之下都有一套自己的骨架。作为一个分析阅读的读者，你的责任就是要找出这个骨架。</li>
<li>但是，任何一本值得读的书，都会有一个整体性与组织架构。否则这本书会显得乱七八糟，根本没法阅读。而烂书就是如此。</li>
<li>分析阅读的第二个规则是：使用一个单一的句子，或最多几句话（一小段文字）来叙述整本书的内容。</li>
<li>必须能用几句话，告诉你自己，或别人，这整本书在说的是什么。（如果你要说的话太多，表示你还没有将整体的内容看清楚，而只是看到了多样的内容。）</li>
<li>第三个规则可以说成是：将书中重要篇章列举出来，说明它们如何按照顺序组成一个整体的架构。</li>
<li>一本好书，就像一栋好房子，每个部分都要很有秩序地排列起来。每个重要部分都要有一定的独立性。</li>
<li>但是却一定要跟其他部分连接起来——这是与功能相关——否则这个部分便无法对整体的智能架构作出任何贡献了。</li>
</ol>
</blockquote>
<h4 id="结果与规划：叙述整本书的大意"><a href="#结果与规划：叙述整本书的大意" class="headerlink" title="结果与规划：叙述整本书的大意"></a>结果与规划：叙述整本书的大意</h4><p>关于第二个规则的两个建议：一是书的作者本身很可能已经整理的书的重点，通常在序言中，二是我们不需要把作者整理的重点作为唯一的说明。</p>
<blockquote>
<ol>
<li>首先，一位作者，特别是好的作者，会经常想要帮助你整理出他书中的重点。</li>
<li>其次，是要小心，不要把我们提供给你的那些书的重点摘要，当作是它们绝对又唯一的说明。</li>
</ol>
</blockquote>
<h4 id="驾驭复杂的内容：为一本书拟大纲的技巧"><a href="#驾驭复杂的内容：为一本书拟大纲的技巧" class="headerlink" title="驾驭复杂的内容：为一本书拟大纲的技巧"></a>驾驭复杂的内容：为一本书拟大纲的技巧</h4><p>第二规则和第三规则的联系在于，第二规则着重与整体，而第三规则强调复杂度，且运用第二规则抓住整体后会有助于我们用第三规则对重要部分进行透视。</p>
<p>可以参考这个公式来进行大纲的罗列。</p>
<blockquote>
<p>我们可以依照第三个规则，将内容大纲排列如下：（1）作者将全书分成五个部分，第一部分谈的是什么，第二部分谈的是什么，第三部分谈的是别的事，第四部分则是另外的观点，第五部分又是另一些事。（2）第一个主要的部分又分成三个段落，第一段落为X，第二段落为Y，第三段落为Z。（3）在第一部分的第一阶段，作者有四个重点，第一个重点是A，第二个重点是B，第三个重点是C，第四个重点是D等等。</p>
</blockquote>
<p>第三规则对于第二规则的重要性在于：除非遵循规则三，否则无法有效的运用规则二。如果读者没有用规则三理解整本书的框架，那么规则二得出的整体性结论又如何保证正确呢？</p>
<blockquote>
<ol>
<li>第二个规则在指导你注意一本书的整体性，第三个则在强调一本书的复杂度。要这样区分还有另一个理由。当你掌握住一本书的整体性时，便会立刻抓住其中一些重要的部分。但是这每个部分的本身通常是很复杂，各有各的内在结构需要你去透视。</li>
<li>你只要尽力而为就行了。毕竟，这个规则并没有要你将作者没有放进去的东西加在里面。你的大纲是关于作品本身的纲要，而不是这本书要谈的主题的纲要。</li>
<li>用另一种方法来说，就是除非你遵循规则三——要求你说明组成整体的各个部分——否则就没有办法有效地运用规则二——要求你作全书的重点摘要。</li>
</ol>
</blockquote>
<h4 id="阅读与写作的互惠技巧"><a href="#阅读与写作的互惠技巧" class="headerlink" title="阅读与写作的互惠技巧"></a>阅读与写作的互惠技巧</h4><p>运用规则三实际上就是去透视一本书的骨架。对于写作者而言，对于骨架和血肉的理解也同样重要，写作者应该先有了一本书的骨架后再往上添加血肉。</p>
<blockquote>
<ol>
<li>如果作者跟老师无法将自己要传达的东西整理出架构，不能整合出要讲的各个部分的顺序，他们就无法指导读者和学生去找出他们要讲的重点，也没法发现全书的整体架构。</li>
<li>如果他是个好作者，就不会将一个发育不良的骨架埋藏在一堆肥肉里，同样的，也不会瘦得皮包骨，让人一眼就看穿。</li>
<li>书，真的就跟人或动物是一模一样的。——血肉，就是为纲要所作的进一步详细解释，或是我们有时候所说的“解读”（read out）。</li>
</ol>
</blockquote>
<h4 id="发现作者的意图"><a href="#发现作者的意图" class="headerlink" title="发现作者的意图"></a>发现作者的意图</h4><p>在这一节阐述了第四个规则：找出写作者问的问题。第四个规则和前两条规则实际上是前后呼应的关系，在做规则二、三 时实际上就会完成规则四，而规则四则会帮助更好的完成规则二、三。</p>
<blockquote>
<ol>
<li>这第四个规则可以说是：找出作者要问的问题。一本书的作者在开始写作时，都是有一个问题或一连串的问题，而这本书的内容就是一个答案，或许多答案。</li>
<li>你应该有办法说出整本书想要解答的问题是什么。如果主要的问题很复杂，又分成很多部分，你还要能说出次要的问题是什么。你应该不只是有办法完全掌握住所有相关的问题，还要能明智地将这些问题整合出顺序来。哪一个是主要的，哪个是次要的？哪个问题要先回答，哪些是后来才要回答的？</li>
</ol>
</blockquote>
<h4 id="分析阅读的第一个阶段"><a href="#分析阅读的第一个阶段" class="headerlink" title="分析阅读的第一个阶段"></a>分析阅读的第一个阶段</h4><p>四个规则将会提供读者对于一本书架构的认识。当完成了四个规则后，实际上我们就完成了分析阅读的第一个阶段，这一阶段主要探究的是一本书在谈些什么的问题（一本书的骨架）。要注意这里的阶段并非一个前后顺序的概念，没必要为了四个规则将一本书读一遍后又为了完全其他规则读一遍又一遍。</p>
<blockquote>
<p>这四个规则在一起，能提供读者对一本书架构的认识。当你运用这四个规则来阅读一本书，或任何又长又难读的书时，你就完成了分析阅读的第一个阶段。除非你是刚开始练习使用分析阅读，否则你不该将“阶段”一词当作一个前后顺序的概念。</p>
</blockquote>
<h3 id="与作者找出共通的词义"><a href="#与作者找出共通的词义" class="headerlink" title="与作者找出共通的词义"></a>与作者找出共通的词义</h3><p>从这里开始阐述分析阅读第二阶段，这个阶段也有四个规则。</p>
<p>第一个规则：找出共通的词义，找出单字，并且确认这些单字在使用时最精确的意义</p>
<blockquote>
<p>1.只要模糊地带还存在，就表示作者和读者之间对这些单字的意义还没有共识。为了要达成完全的沟通，最重要的是双方必须要使用意义相同的单字——简单来说，就是，找出共通的词义达成共识。</p>
</blockquote>
<h4 id="单字VS-词义"><a href="#单字VS-词义" class="headerlink" title="单字VS.词义"></a>单字VS.词义</h4><p>每一个单字都有多种不同的解释，但单字在一段话中往往只有一个解释（论述书基本如此，小说和诗词会有例外），这就是词义。我们需要知道一本书的作者在这段话的中点的词义。</p>
<h4 id="找出关键字"><a href="#找出关键字" class="headerlink" title="找出关键字"></a>找出关键字</h4><p>关键字很可能是让你头疼无法理解的词。</p>
<blockquote>
<ol>
<li>如果你把觉得有困扰的字圈出来，很可能就找出了作者有特定用法的那些字了。之所以会如此，是因为如果作者所用的都只是一般日常用语的含义，对你来说就根本不存在有困扰的问题了。</li>
<li>从一个读者的角度来看，最重要的字就是那些让你头痛的字。这些字很可能对作者来说也很重要。</li>
</ol>
</blockquote>
<h4 id="专业用于及特殊词汇"><a href="#专业用于及特殊词汇" class="headerlink" title="专业用于及特殊词汇"></a>专业用于及特殊词汇</h4><p>一些在特定的专业词汇如<code>点</code>、<code>线</code>、<code>面</code>等，又如经济中<code>财富</code>，<code>资本</code>，<code>土地</code>这样的词汇。</p>
<blockquote>
<ol>
<li>事实上，你也会发现一些对你来说并不是日常用语的字，因而发现那是一些重要的字眼。</li>
<li>某些知识领域有一套完整的专门用语，在一本这种主题的书中找出重要的单字，相形之下就很容易了。</li>
<li>另外一个线索是，作者与其他作者争执的某个用语就是重要的字。</li>
<li>如果读者碰到一个不了解的字不愿意深思，或至少作个记号，那他不了解的这个字就一定会给他带来麻烦。</li>
<li>大多数人都习惯于没有主动的阅读。没有主动的阅读或是毫无要求的阅读，最大的问题就在读者对字句毫不用心，结果自然无法跟作者达成共识了。</li>
</ol>
</blockquote>
<h4 id="找出字义"><a href="#找出字义" class="headerlink" title="找出字义"></a>找出字义</h4><p>通过上下文的联系找出正确的词义。</p>
<blockquote>
<ol>
<li>首先，要判断这个字是有一个还是多重意义。如果有多重意义，要看这些意义之间的关系如何。最后，要注意这些字在某个地方出现时，使用的是其中哪一种意义。看看上下文是否有任何线索，可以让你明白变换意义的理由。最后这一步，能让你跟得上字义的变化，也就是跟作者在使用这些字眼时一样变化自如。</li>
<li>你一定要利用上下文自己已经了解的所有字句，来推敲出你所不了解的那个字的意义。</li>
<li>整个过程有点像是在玩拼图时尝试错误的方法。你所拼起来的部分越多，越容易找到还没拼的部分，原因只不过剩下的部分减少了。</li>
</ol>
</blockquote>
<h3 id="判断作者的主旨"><a href="#判断作者的主旨" class="headerlink" title="判断作者的主旨"></a>判断作者的主旨</h3><p>第五个规则与单字和词义有关，第六个规则与句子有关，我们要找到作者的主旨。而第七个规则与论述有关，我们需要通过一连串的句子来了解作者的论述过程。可以看到五六七规则是有逻辑联系的，从单字（或词）到句子再到一连串的句子。</p>
<blockquote>
<ol>
<li>书里的提案，也就是主旨，也是一种声明。那是作者在表达他对某件事的判断。</li>
<li>但是读者却要先与作者达成共识，才能明白作者的主旨是什么，以及他所声明的是什么样的判断。</li>
<li>第六个，也就是我们现在要讨论的，是与句子及提案有关的规则。</li>
<li>我们从共识谈到主旨，再谈到论点，表达的方法是从字（与词）到一个句子，再到一连串的句子（或段落）来作说明。</li>
</ol>
</blockquote>
<h4 id="句子与主旨。"><a href="#句子与主旨。" class="headerlink" title="句子与主旨。"></a>句子与主旨。</h4><p>如同单字与词义一样，句子和主旨同样不是一一对应的。</p>
<blockquote>
<ol>
<li>在区分句子与主旨之间，我们已经说得够清楚了。它们并不是一对一的关系。不只是一个单一的句子可以表达出不同的主旨，不管是有歧义的句子或复合句都可以，而且同一个主旨也能用两个或更多不同的句子来说明。</li>
<li>第六个规则可以说是：将一本书中最重要的句子圈出来，找出其中的主旨。第七个规则是：从相关文句的关联中，设法架构出一本书的基本论述。</li>
</ol>
</blockquote>
<h4 id="找出关键句"><a href="#找出关键句" class="headerlink" title="找出关键句"></a>找出关键句</h4><p>关键句的标志：首先是阐述作者判断的句子，其次是找到在规则五中遇到的关键字组成的句子。</p>
<blockquote>
<ol>
<li>从作者的观点来看，最重要的句子就是在整个论述中，阐述作者判断的部分。</li>
<li>找出组成关键句的文字来。如果你已经将重要的字圈出来了，它一定会引导你看到值得注意的句子。</li>
<li>但是当你想要在阅读中获得理解时，你要追寻的就不是那种新奇的感觉了。</li>
<li>就因为有这些原因，我们所讨论的规则是要帮助你理解一本书，而不是满足你的好奇心。</li>
</ol>
</blockquote>
<h4 id="找出主旨"><a href="#找出主旨" class="headerlink" title="找出主旨"></a>找出主旨</h4><p>从关键句中找出主旨和找出关键字中的词义两者都需要从上下文中推导出作者真正的含义，但也有两个不同点。一是后者牵扯的内容比较多，二是一个复杂的句子往往包含了多个主旨。</p>
<p>测试是否真的懂了句子主旨的方法，一是用自己的话来将主旨重写表达一遍，二是举出一个自己所经历的主旨所描述的尽力。</p>
<blockquote>
<ol>
<li>在找出文字所表达的意思与句子所阐述的主旨之间，只有两个不同之处。一个是后者所牵涉的内容比较多。就像你要用周边的其他字来解释一个特殊的字一样，你也要借助前后相关的句子来了解那个问题句。</li>
<li>另一个不同是，复杂的句子通常要说明的不只一个主旨。除非你能分析出所有不同，或相关的主旨，否则你还是没有办法完全诠释一个重要的句子。</li>
<li>如果要求你针对作者所写的某个句子作解释，而你只会重复他的话，或在前后顺序上作一些小小的改变，你最好怀疑自己是否真的了解了这句话。</li>
<li>你能不能举出一个自己所经历过的主旨所形容的经验，或与主旨有某种相关的经验？</li>
</ol>
</blockquote>
<h4 id="找出论述"><a href="#找出论述" class="headerlink" title="找出论述"></a>找出论述</h4><p>论述的基本单位是一系列先后有序，有时还带有例证和理由的主旨。分析阅读的第七个规则为：——找出论述的段落，如果没有则需要自己从不同的段落中找出关键句子，然后整理前后顺序的主旨进而形成论述。</p>
<p>论述的标志，一是所有的论述都包含声明，二是要记住有两种论述：以事例证明的归纳法和通过连串通则证明的演绎法，三是找到作者哪些事情认为是假设，哪些是能证明的，哪些是不证自明的。</p>
<blockquote>
<ol>
<li>指导我们阅读的第七个规则的逻辑单位，是“论述”——一系列先后有序，其中某些还带有提出例证与理由作用的主旨。</li>
<li>如果可以，找出书中说明重要论述的段落。但是，如果这个论述并没有这样表达出来，你就要去架构出来。你要从这一段或那一段中挑选句子出来，然后整理出前后顺序的主旨，以及其组成的论述。</li>
<li>首先，要记住所有的论述都包含了一些声明。其次，要区别出两种论述的不同之处。一种是以一个或多个特殊的事实证明某种共通的概念，另一种是以连串的通则来证明更进一步的共通概念。前者是归纳法，后者是演绎法。再次，找出作者认为哪些事情是假设，哪些是能证实的或有根据的，</li>
</ol>
</blockquote>
<h4 id="找出解答"><a href="#找出解答" class="headerlink" title="找出解答"></a>找出解答</h4><p>分析阅读的第一阶段（整理内容大纲）和第二阶段（诠释内容）后就是诠释一本书的最后步骤———找出解答。在第二阶段与作者达成共识，抓到他的主旨与论述后，我们应该提出更进一步的问题（在阶段四我们已经提出了基本问题——作者的问题是什么？），作者想要的问题哪些解决了？为了解决问题，他又引出了哪些问题？无论是新问题还是旧问题，哪些他知道自己还没有解决。第八个步骤便是找出这些问题的解答。</p>
<p>至此分析阅读的第二阶段已经完成，这一个阶段通过四个规则解决了一本书到底在说什么的问题（诠释一本书的内容，一本书的血肉）。</p>
<blockquote>
<ol>
<li>这也是诠释一本书的内容的最后一个步骤。除此之外，那也将分析阅读的第一个阶段（整理内容大纲）与第二阶段（诠释内容）连接起来了。</li>
<li>分析阅读的第二个阶段，或找出一本书到底在说什么的规则</li>
</ol>
</blockquote>
<h3 id="公正的评断一本书"><a href="#公正的评断一本书" class="headerlink" title="公正的评断一本书"></a>公正的评断一本书</h3><p>主动的阅读必须在懂得书之后评论并提出批评。评论及批评便是分析阅读的第三阶段也是最后一个阶段。</p>
<blockquote>
<ol>
<li>主动的阅读不会为了已经了解一本书在说些什么而停顿下来，必须能评论，提出批评，才算真正完成了这件事。</li>
</ol>
</blockquote>
<h4 id="受教是一种美德"><a href="#受教是一种美德" class="headerlink" title="受教是一种美德"></a>受教是一种美德</h4><p>最能批评的读者往往是最能学习的读者，因为受教也是一种美德，当读者完全读懂一本书后，他便与这本书的作者有了平等的地位，这时候他应该整理出自己的想法，让书的作者受教。</p>
<blockquote>
<ol>
<li>受教或是能学习是一种极为主动的美德。一个人如果不能自动自发地运用独立的判断力，他根本就不可能学习到任何东西。</li>
<li>最能学习的读者，也就是最能批评的读者。这样的读者在最后终于能对一本书提出回应，对于作者所讨论的问题，会努力整理出自己的想法。</li>
</ol>
</blockquote>
<h4 id="修辞的作用"><a href="#修辞的作用" class="headerlink" title="修辞的作用"></a>修辞的作用</h4><p>一本书的写作过程中会有修辞让读者能更好的理解，作为读者修辞的作用则是知道别人尝试说服我们时该如何的回应及评论。</p>
<blockquote>
<ol>
<li>相对的，在读者或听者的立场，修辞的技巧是知道当别人想要说服我们时，我们该如何反应。同样的，文法及逻辑的技巧能让我们了解对方在说什么，并准备作出评论。</li>
</ol>
</blockquote>
<h4 id="暂缓评论的重要性"><a href="#暂缓评论的重要性" class="headerlink" title="暂缓评论的重要性"></a>暂缓评论的重要性</h4><p>分析阅读的第九规则：在评论前必须能肯定的说“我了解了”。所以对于一本书评价有“我同意”、“我不同意”和“我暂缓评论”，因为有些书籍需要读者有了相关的背景或读了其他的书后才能给出中肯的平价。</p>
<blockquote>
<ol>
<li>我们会认为这些原则代表一种礼节，让读者不只是有礼貌，还能有效地回话的礼节。</li>
<li>第九个规则：在你说出“我同意”，“我不同意”，或“我暂缓评论”之前，你一定要能肯定地说：“我了解了。”</li>
</ol>
</blockquote>
<h4 id="避免争强好辩的重要性"><a href="#避免争强好辩的重要性" class="headerlink" title="避免争强好辩的重要性"></a>避免争强好辩的重要性</h4><p>分析阅读的第十原则：当不同意作者观点时，要理性表达自己的意见，不要无礼的辩驳或争论。</p>
<blockquote>
<ol>
<li>规则十：当你不同意作者的观点时，要理性地表达自己的意见，不要无理地辩驳或争论。</li>
</ol>
</blockquote>
<h4 id="化解争议"><a href="#化解争议" class="headerlink" title="化解争议"></a>化解争议</h4><p>把不同意见当做是有可能解决的问题。上一个原则时提醒不要争强好辩，这一个原则则是提醒不要绝望的与不同的意见抗争。因为不同的意见可能来自于情绪或者知识水平的不相当。所以与人对话时，即使有不同的意见，最终还是有希望达成共识。</p>
<p>真正的只是和个人的观点间是存在差异的，读者应当专注于真正知识。分析阅读规则十一：尊重知识与个人观点的不同，相信不同意见大体上是可解决的，读者要为自己的不同意见找到理论基础。</p>
<p>至此分析阅读的第三阶段完成，这一阶段通过三个规则教导读者如何在阅读后与作者进行“辩论”，探究作者是否正确与作者的论述是否完整。</p>
<blockquote>
<ol>
<li>第二个规则是敦促你不要争强好辩，这一个规则是提醒你不要绝望地与不同的意见对抗。</li>
<li>一个人在与别人对话时，就算有不同的意见，最后还是有希望达成共识。他应该准备好改变自己的想法，才能改变别人的想法。他永远要先想到自己可能误解了，或是在某一个问题上有盲点。</li>
<li>他们认为任何事都只是一个观点问题。我有我的观点，你也有你的，我们对自己的观点都有神圣不可侵犯的权利，就像我们对自己的财产也有同样的权利。如果沟通是为了增进知识，从这个角度出发的沟通是不会有收获的。</li>
<li>一个读者如果不能区别出知识的理论说明与个人观点的阐述，那他就无法从阅读中学到东西。他感兴趣的顶多只是作者个人，把这本书当作是个人传记来读而已。当然，这样的读者无所谓同意或不同意，他不是在评断这本书，而是作者本身。</li>
<li>读者要就真正的知识与他个人观点以及作者个人观点之不同之处，作出区分。</li>
<li>必须为自己的观点找出理由来。当然，如果他赞同作者的观点，就是他与作者分享同样的理论。但是如果他不赞同，他一定要有这么做的理论基础。否则他就只是把知识当作个人观点来看待了。</li>
<li>规则十一，尊重知识与个人观点的不同，在作任何评断之前，都要找出理论基础。</li>
<li>这三个规则在一起所说明的是批评式阅读的条件，而在这样的阅读中，读者应该能够与作者“辩论”。</li>
</ol>
</blockquote>
<h3 id="赞同或反对作者"><a href="#赞同或反对作者" class="headerlink" title="赞同或反对作者"></a>赞同或反对作者</h3><p>在赞同或反对作者前首先要做到的都是理解作者。</p>
<blockquote>
<p>当你透过对一本书的诠释理解，与作者达成了共识之后，才可以决定同意他的论点，或是不同意他的立场。</p>
</blockquote>
<h4 id="偏见与公正"><a href="#偏见与公正" class="headerlink" title="偏见与公正"></a>偏见与公正</h4><p>要与作者理想化的辩证就必须满足以下三种条件：</p>
<ol>
<li>不要情绪化</li>
<li>把自己的前提和假设摊出来。因为一场好的辩论是不会为了假设而争吵的，对假设的争论往往是存在偏见的。</li>
<li>派别之争必然存在盲点，要解决这些盲点，应尽量做到不偏不倚。</li>
</ol>
<p>作者给出了一套站在对立角度来评论一本书的方法：</p>
<ol>
<li>书作者的知识不足</li>
<li>书作者的知识有错误</li>
<li>书作者的推论无法令人信服</li>
<li>书作者的分析不够完整</li>
</ol>
<blockquote>
<p>要作到理想化的辩论就必须满足以下三种条件：</p>
<p>第一点，因为人有理性的一面，又有动物的一面，所以在争辩时就要注意你会带进去的情绪，或是在当场引发的脾气。否则你的争论会流于情绪化，而不是在说理了。当你的情绪很强烈时，你可能会认为自己很有道理。</p>
<p>第二点，你要把自己的前提或假设摊出来。你要知道你的偏见是什么——这也是你的预先评断。否则你就不容易接受对手也有不同假设的权利。</p>
<p>第三点也是最后一点，派别之争几乎难以避免地会造成一些盲点，要化解这些盲点，应尽力尝试不偏不倚。</p>
<p>这套方法指出四种站在对立角度来评论一本书之道。我们希望即使读者想要提出这四种评论时，也不会陷入情绪化或偏见的状态中。 以下是这四点的摘要说明。</p>
<p>他可以用以下的概念向作者说明：（1）你的知识不足（uninformed）。（2）你的知识有错误（misinformed）。（3）你不合逻辑——你的推论无法令人信服。（4）你的分析不够完整。</p>
</blockquote>
<h4 id="判断作者的论点是否正确"><a href="#判断作者的论点是否正确" class="headerlink" title="判断作者的论点是否正确"></a>判断作者的论点是否正确</h4><p>上述批评的前两个角度都是在阐述书的作者的前提是有缺陷的，作者需要补充知识，第三个角度是说书的作者不合逻辑推论荒缪。</p>
<blockquote>
<ol>
<li>说一位作者知识不足，就是在说他缺少某些与他想要解决的问题相关的知识。</li>
<li>说一位作者的知识错误，就是说他的理念不正确。这样的错误可能来自缺乏知识，但也可能远不止于此。不论是哪一种，他的论点就是与事实相反。</li>
<li>这两个评论合在一起，指出的是作者的前提有缺陷。他需要充实知识。他的证据与论点无论在质与量上都还不够好。</li>
<li>说一位作者是不合逻辑的，就是说他的推论荒谬。一般来说，荒谬有两种形态。一种是缺乏连贯，也就是结论冒出来了，却跟前面所说的理论连不起来。另一种是事件变化的前后不一致，也就是作者所说的两件事是前后矛盾的。</li>
</ol>
</blockquote>
<h4 id="判断作者论述的完整性"><a href="#判断作者论述的完整性" class="headerlink" title="判断作者论述的完整性"></a>判断作者论述的完整性</h4><p>前三个批评角度是与作者的声明与论述相关的，如果读者读懂了一本书，而且无法找到证据来支持前三个批评点的话，那就只能同意作者的观点，你所能表达的最多是<code>不喜欢</code>。</p>
<p>第四个批评点是说整本书不完整架构存在问题，但一本书不能做到尽善尽美，所以批评者要指出哪些部分存在问题，不然这个问题就是毫无意义的。</p>
<blockquote>
<ol>
<li>我们刚谈过的前面三个批评点，是与作者的声明与论述有关的。</li>
<li>如果你说你读懂了，而你却找不出证据来支持前面任何一个批评点的话，这时你就有义务要同意作者的任何论点。这时你完全没有自主权。你没有什么神圣的权利可以决定同意或不同意。这时候你唯一能说的可能只是你“不喜欢”这个结论。你并不是在反对。你只在表达你的情绪或偏见。如果你已经被说服了，就该承认。（如果你无法提出证据来支持前三项批评点，但仍然觉得没有被作者说服，可能在一开始时你就不该说你已经读懂了这本书。）</li>
<li>第四点——这本书是否完整了——与整本书的架构有关。</li>
<li>说一位作者的分析是不完整的，就是说他并没有解决他一开始提出来的所有问题，或是他并没有尽可能善用他手边的资料，或是他并没有看出其间的含意与纵横交错的关系，或是他没法让自己的想法与众不同。…因此，作这样的评论是毫无意义的。除非读者能精确地指出书中的问题点。</li>
</ol>
</blockquote>
<h4 id="分析阅读的三个阶段"><a href="#分析阅读的三个阶段" class="headerlink" title="分析阅读的三个阶段"></a>分析阅读的三个阶段</h4><p>前四个规则帮助回答第一个问题：这本书在谈些什么。后四个规则帮助回答第二个问题：作者是如何阐述的？剩下的三个阅读规则以及批评观点的特点解决了第三个与第四个问题，这本书是真实的吗？有意义吗？</p>
<p>前三个问题都与人类语言的沟通特性有关，都是帮助我们更好的了解讯息和判断信息的准确，第四个问题则是区分了讯息与理解之间的差异。</p>
<p>上述的阅读规则等只是衡量阅读层次的理想标准，当我们评论一个人读得很好时，我们需要有一个标准来作为衡量依据。</p>
<blockquote>
<ol>
<li>本书在第七章结尾时，已经提出分析阅读的前四个规则，以便帮助你回答对一本书提出来的一个基本问题：这本书大体上来说是在谈些什么？同样的，在第九章的结尾，诠释一本书的四个规则能帮助你回答第二个问题，这也是你一定会问的问题：这本书详细的内容是什么？作者是如何写出来的？很清楚，剩下来的七个阅读规则——评论的智慧礼节、批评观点的特别标准——能帮助你回答第三与第四个基本问题。你一定还记得这两个问题：这是真实的吗？有意义吗？</li>
<li>无论如何，这些规则只是衡量阅读层次的理想标准。</li>
<li>我们心中应该要有这些标准来作衡量的依据。太多时候，我们是用这样的句子来形容一个人阅读的量，而非阅读的质。</li>
</ol>
</blockquote>
<h3 id="辅助阅读"><a href="#辅助阅读" class="headerlink" title="辅助阅读"></a>辅助阅读</h3><p>前面提到的规则都是聚焦在书本身，这可以称为“内在阅读”，而辅助阅读或称外在阅读则是借助其他人来阅读一本书。我们免不了会把作者对某件事的声明与结论拿来和我们已知的进行比较，所以外在阅读是不可避免的，但有些读者太过于依赖外在阅读，所以这里要做些特殊说明。</p>
<p>辅助阅读的来源可以分为四个部分：</p>
<ol>
<li>相关经验</li>
<li>其他的书</li>
<li>导论与摘要</li>
<li>工具书</li>
</ol>
<blockquote>
<ol>
<li>我们免不了会把某一位作者对某件事的声明与结论，拿来跟我们所知的，许多不同来源的经验作比较。这也就是俗话说的，我们不应该，也不可能完全孤立地阅读一本书。</li>
<li>许多读者太依赖外在的辅助了，我们希望你了解这是毫无必要的。</li>
<li>外在的辅助来源可以分成四个部分。在这一章中，我们会依照以下的顺序讨论出来：第一，相关经验。第二，其他的书。第三，导论与摘要。第四，工具书。</li>
</ol>
</blockquote>
<h4 id="相关经验的角色"><a href="#相关经验的角色" class="headerlink" title="相关经验的角色"></a>相关经验的角色</h4><p>有两种相关经验可以帮助我们阅读有困难的书，一般经验与特殊经验。一般经验来自于生活，他对一方面对阅读小说有关，一方面与阅读哲学书籍有关。特殊经验则来自于特殊经历或实验，一般与阅读科学性作品有关。而历史作品因其掺杂着科学与虚构，所以与两种经验都相关。</p>
<blockquote>
<ol>
<li>一般经验在一方面与阅读小说有关，另一方面与阅读哲学书籍有关。</li>
<li>特殊经验主要是与阅读科学性作品有关。</li>
<li>阅读历史作品，同时与一般经验及特殊经验都有关。这是因为历史掺杂着虚构与科学的部分。</li>
</ol>
</blockquote>
<h4 id="其他的书可以当做阅读时的外在助力"><a href="#其他的书可以当做阅读时的外在助力" class="headerlink" title="其他的书可以当做阅读时的外在助力"></a>其他的书可以当做阅读时的外在助力</h4><p>许多伟大的作品都是有相互关联且存在先后顺序的，我们在读一本书时不能忽略这样的关系。在之前有提到看一本书时需要整理出书的脉络以帮助我们理解书，而相关性的书可以提供一个更大的脉络网。</p>
<blockquote>
<ol>
<li>许多伟大的作品不只是互相有关联，而且在写作时还有特定的先后顺序，这都是不该忽略的事。</li>
<li>外在辅助阅读的主要功用在于延伸与一本书相关的内容脉络。</li>
<li>就像一整本书的脉络是由各个部分贯穿起来一样，相关的书籍也能提供一个大型的脉络，以帮助你诠释你正在阅读的书。</li>
</ol>
</blockquote>
<h4 id="如何运用导读和摘要"><a href="#如何运用导读和摘要" class="headerlink" title="如何运用导读和摘要"></a>如何运用导读和摘要</h4><p>我们要尽量少用导读与摘要因为导读并不一定都是对的，而且导读会限制读者的想法，应该在完整阅读一本书后再阅读一本书的导读，否在你的思路很可能被导读带着走。</p>
<p>而摘要的作用一是可以唤醒读书时的记忆，二是在做主题阅读时，可以知道某些特定的议题与主题的相关性。但摘要是绝不能代替真正的阅读。</p>
<blockquote>
<ol>
<li><p>在运用这些资料时要特别聪明，也就是要尽量少用。这么说有两个理由。</p>
<p>第一，一本书的导读并不一定都是对的。</p>
<p>尽量少用导读的第二个原因是，就算他们写对了，可能也不完整。…阅读这类导读，尤其是自以为是的导读，会限制你对一本书的理解，就算你的理解是对的。</p>
</li>
<li><p>外在的阅读规则是除非你看完了一本书，否则不要看某个人的导读。这个规则尤其适用于一些学者或评论家的导言。</p>
</li>
<li><p>如果你已经看过全书，知道这些导读如果有错，是错在哪里，那么这样的导读就不会对你造成伤害。但是如果你完全依赖这样的书，根本没读过原书，你的麻烦就大了。</p>
</li>
<li><p>摘要的用途： 敌意，如果你已经读过一本书，这些摘要能唤醒你的记忆。…第二，在主题阅读时，摘要的用处很大，你可以因此知道某些特定的议题与你的主题密切相关。摘要绝不能代替真正的阅读，但有时却能告诉你，你想不想或需不需要读这本书。</p>
</li>
</ol>
</blockquote>
<h4 id="如何运用工具书"><a href="#如何运用工具书" class="headerlink" title="如何运用工具书"></a>如何运用工具书</h4><p>工具书对矫正无知的功能是有限的，在使用工具书前必须要有一些自己的想法，其次还需要知道自己的问题属于哪一类，需要找哪一类的工具书。在正式工具书前，还要知道工具书是如何使用的。</p>
<blockquote>
<ol>
<li>工具书对矫正无知的功能是有限的。那并不能帮助文盲，也不能代替你思考。</li>
<li>首先你必须有一些想法，不管是多模糊的想法，那就是你想要知道些什么？你的无知就像是被光圈围绕着的黑暗。…其次，你一定要知道在哪里找到你要找的答案。你要知道自己问的是哪一类的问题，而哪一类的工具书是回答这类问题的。…你还必须有第三种知识。你必须要知道这本书是怎么组织的。</li>
<li>对一无所知的人来说，工具书可说是毫无用处。</li>
</ol>
</blockquote>
<h4 id="如何使用字典"><a href="#如何使用字典" class="headerlink" title="如何使用字典"></a>如何使用字典</h4><blockquote>
<ol>
<li>从一开始，教育的动机便左右了字典的编排，当然，保留语言的纯粹与条理是另一个原因。</li>
<li>即使如此，在你第一次阅读一本好书时，也不要急着使用字典，除非是那个字与作者的主旨有很大的关联，才可以查证一下。</li>
</ol>
</blockquote>
<h4 id="如何使用百科全书"><a href="#如何使用百科全书" class="headerlink" title="如何使用百科全书"></a>如何使用百科全书</h4><p>使用百科全书时不仅要找特定的知识，还要通过索引看彼此相关联的事实。</p>
<blockquote>
<ol>
<li>他基本上要找的是真实的知识，但他不能单独只看一种事实。百科全书所呈现给他的是经过安排的一整套的事实——一整套彼此相关的事实。</li>
<li>在这里，索引的功能就跟目录一样，不过并不十分理想。因为索引是在同一个标题下，把百科全书中分散得很广，但是和某一个相关主题有关的讨论都集中起来。</li>
</ol>
</blockquote>
<h2 id="阅读不同读物的方法"><a href="#阅读不同读物的方法" class="headerlink" title="阅读不同读物的方法"></a>阅读不同读物的方法</h2><h3 id="如何阅读实用型的书"><a href="#如何阅读实用型的书" class="headerlink" title="如何阅读实用型的书"></a>如何阅读实用型的书</h3><p> 之前在分析阅读中提到的规则主要是以理论性的书作为模版探究出来的所以并不一定完全适用于任何书籍，特别是小说会有较大的出入。</p>
<h4 id="两种实用性的书"><a href="#两种实用性的书" class="headerlink" title="两种实用性的书"></a>两种实用性的书</h4><p> 任何实用性的书都不能解决书中提到的问题，理论性的书可以回答自己的提出问题，而实用性的书则必须依靠读者的行动才能完成。</p>
<p> 实用性的书可以分为两类，一是在说明规则的书，如本书，二是阐述形成规则原理的书。</p>
<p> 无论哪一种的试用书，我们都要找出规则该如何运用在实际中，这应当是了解任何一种实用性书籍的最高原则。所以评判实用性书籍不仅仅要判断作者的观点是否准确，还需要判断他的目标与自身的目标是否一致。</p>
<blockquote>
<ol>
<li>无论如何，你还是看得出来它是实用性的书。它要处理的那些问题的本质会露底。这样的书所谈的总是人类行为领域中，怎样可能做得更好或更糟。</li>
<li>你的判断主要是与结果达成共识，而非方法。就算方法非常真实有用，如果所达到的目的是我们不关心或不期望的结果，我们也不会有半点兴趣的。</li>
</ol>
</blockquote>
<h4 id="说服的角色"><a href="#说服的角色" class="headerlink" title="说服的角色"></a>说服的角色</h4><p> 实用性书籍的作者通常是一个雄辩家，因为他要作者相信他给出的建议。作为读者我们要能觉察出作者的雄辩，对他的推销存有抵抗力。</p>
<blockquote>
<ol>
<li>当你在阅读任何一种实用书时，一定要问你自己两个主要的问题。第一：作者的目的是什么？第二：他建议用什么方法达到这个目的？</li>
<li>你可以知道为什么实用书的作者多少都是个雄辩家或宣传家。因为你对他作品最终的评断是来自你是否接受他的结论，与他提议的方法。这完全要看作者能不能将你引导到他的结论上。</li>
<li>不想被宣传所困惑，就得了解宣传的内容是什么。难以察觉的隐藏式雄辩是最狡猾的。那会直接打动你的心，而不经过你的头脑，就像是从背后吓你一跳，把你吓得魂不附体一样。</li>
</ol>
</blockquote>
<h4 id="赞同实用书之后"><a href="#赞同实用书之后" class="headerlink" title="赞同实用书之后"></a>赞同实用书之后</h4><p> 读一本书时需要的四个问题，在阅读实用性书籍时需要一些调整。</p>
<p> 第一个问题：这本书在谈些什么？</p>
<p> 并没有太大改变，仍然需要回答，并作出书的框架。</p>
<p> 第二个问题：作者是如何表达的</p>
<p> 改变也不大，我们仍然要找到作者的共识，主旨与论述。但规则四与规则八应调整为“找出作者想要你做什么”和“了解他要你这么做的目的”。</p>
<p> 第三个问题：内容真实吗？</p>
<p> 这一条要改动的较多，实用性的书籍虽然也需对真实性做确认，判断作者的论述是否正确，但更重要的是判断是否接受作者最终的目的</p>
<p> 第四个问题：这本书的意义？</p>
<p>这一条完全改变了。理论性的书阅读后，我们对于主题的观点或许会存在改变，这便是理论书的意义，而这个改变并不需要采取行动。而赞同一本实用性的书，则需要确实的采取行动。</p>
<blockquote>
<ol>
<li>你在读一本书时要提出的四个问题，到了读实用性的书时有了一点变化。</li>
<li>赞同一本实用性的书，却确实需要你采取行动。如果你被作者说服了，他所提议的结论是有价值的，甚至进一步相信他的方法真的能达到目的，那就很难拒接作者对你的要求了。你会照着作者希望你做的方式来行动。</li>
</ol>
</blockquote>
<h3 id="如何阅读想象文学"><a href="#如何阅读想象文学" class="headerlink" title="如何阅读想象文学"></a>如何阅读想象文学</h3><h4 id="读想象文学的“不要”"><a href="#读想象文学的“不要”" class="headerlink" title="读想象文学的“不要”"></a>读想象文学的“不要”</h4><p>作者首先阐述了论述性作品与文学作品的差异，通过这些来解释为何不能像读哲学作品般读小说。</p>
<p>首先论述性作品要传达的是知识，而文学作品要传达的是经验。文学作品通过描述和读者的想象力来增加读者的经验，所以我们<code>不要抗拒想象文学带给你的影响力</code>。</p>
<p>第二文学作品常会使用文字的多重字义而论述性作品则完全清晰没有其他含义。所以我们在想象作品中<code>不要去找共识、主旨和论述</code>。</p>
<p>最后我们<code>不要用适用于传递知识，与真理一致的标准来批判小说</code>，只要小说能够自圆其说就可以了。</p>
<blockquote>
<ol>
<li>不要抗拒想象文学带给你的影响力。</li>
<li>阅读一部伟大的文学作品的规则应该以达成某种深沉的经验为目标。这些规则应该尽可能去除我们体验这种深刻感受的阻碍。</li>
<li>在想象文学中，不要去找共识、主旨或论述。</li>
<li>我们也可以从小说在我们想象中所创造出来的经验中学习</li>
<li>不要用适用于传递知识的，与真理一致的标准来批评小说。</li>
</ol>
</blockquote>
<h4 id="想象文学的一般规则"><a href="#想象文学的一般规则" class="headerlink" title="想象文学的一般规则"></a>想象文学的一般规则</h4><p>想象文学的规则也与其他书籍一样可分为三组：一是找到作品整体与部分的架构，二是定义和诠释书籍的内容，三是评论书籍。</p>
<p>对于第一组规则，想象文学需要首先将文学作品分类，如抒情诗，戏剧，小说等。二是要能抓住整本书的大意，看是否能用几句话概括情节。三是要能知道整本书是如何架构的，了解故事发展的脉络。</p>
<p>对于第二组规则：</p>
<p>前面说了小说不要去找共识、主旨和论述，但对于第二组规则，这三个元素是根本所在，所以想象文学的第二组规则需要进行对应的替换。</p>
<p>首先共识的载体是字词，小说则是插曲、事件、角色与他们的思想、语言、感觉及行动。如同在逻辑作品中需要和作者达成共识一样，阅读想象文学时需要对这些元素非常熟悉。</p>
<p>第二，共识与主旨的载体是句子，小说中则是场景与背景。读者要能在这个想象的场景中身临其境。</p>
<p>第三，论述对应了一系列的主旨，在小说中则是情节。</p>
<p>对于第三组规则：</p>
<p>在论述性作品中，这里的规则是在完全理解一本书之前不要表达同意或反对。在这里，规则应该对应改为——在由衷感激作者试着为你创造的经验之前，不要批评一本想象的作品。</p>
<p>因此在批评一本想象文学时，要客观的指出书中的哪些时间造成了方案。在表达喜好时也要表明理由。</p>
<blockquote>
<ol>
<li>除非你能简要地说明剧情——不是主旨或论述——否则你还是没有抓住重点。在情节中就有大意。</li>
<li>在小说中，这些部分就是不同的阶段，作者借此发展出情节来——角色与事件的细节。在安排各个部分的架构上，这两种类型的书各有巧妙。在科学或哲学的作品中，各个部分必须有条理，符合逻辑。在故事中，这些部分必须要在适当的时机与规划中出现，也就是从开头、中间到结尾的一个过程。</li>
<li>你要知道带来高潮的各种不同的关键是什么，高潮是在哪里、又如何发生的，在这之后的影响又是什么？</li>
<li>这些要素就是逻辑作品中的共识。就像你要跟逻辑作品的作者达成共识一样，你也要能熟知每个事件与人物的细节。如果你对角色并不熟悉，也无法对事件感同身受，你就是还没有掌握到故事的精髓。</li>
<li>共识与主旨有关。小说的要素与整个表现的场景或背景有关。…阅读小说时类似指导你找出作者主旨的规则，可以说明如下：在这个想象的世界中宾至如归。知道一切事件的进行，就像你亲临现场，身历其境。</li>
<li>这些场景或背景，社会的组合，是小说中各个要素之间静态的联系（如同主旨一样）。而情节的披露（如同论述或推论）是动态的联系。亚里士多德说情节是一个故事的灵魂。</li>
<li>在你还不了解一本书之前，不要评论一本书——不要说你同意或反对这个论点。所以在这里，类似的规则是：在你衷心感激作者试着为你创造的经验之前，不要批评一本想象的作品。</li>
<li>亨利·詹姆斯（HenryJames）在《小说的艺术》（TheArtofFiction）中曾说道：“我们要接纳作者的主题、想法与前提。我们所能批评的只是他所创造出来的结果。”</li>
<li>如果你只是被动地阅读一本小说（事实上，我们强调过，要热情地阅读），是没法欣赏一本小说的。</li>
<li>要完成批评这件事，你要客观地指出书中某些事件造成你的反感。你不只要能说明你自己为什么喜欢或不喜欢，还要能表达出这本书中哪些地方是好的，哪些是不好的，并说明理由才行。</li>
</ol>
</blockquote>
<h3 id="阅读故事、戏剧与诗的一些建议"><a href="#阅读故事、戏剧与诗的一些建议" class="headerlink" title="阅读故事、戏剧与诗的一些建议"></a>阅读故事、戏剧与诗的一些建议</h3><p>阅读一本书的四个问题，前三个问题在之前已经阐述了，关于第四个问题，这本书与我何关？作者在这里给出了答案，想象文学往往并不能让论述性书一样直接引导出行为，它只是给读者带来经验，经验可能会引导出行动，但这与书本身已经无关了。所以读想象文学唯一要做的就是感受与体验。</p>
<p>然后作者给出了各种想象文学的阅读建议。</p>
<blockquote>
<ol>
<li>暴君并不怕唠叨的作家宣扬自由的思想——他害怕一个醉酒的诗人说了一个笑话，吸引了全民的注意力。”</li>
<li>所谓“纯”艺术，并不是因为“精致”或“完美”，而是因为作品本身就是一个结束，不再与其他的影响有关。就如同爱默生所说的，美的本身就是存在的唯一理由。因此，要将最后一个问题应用在想象文学中，就要特别注意。如果你受到一本书的影响，而走出户外进行任何行动时，要问问你自己，那本书是否包含了激励你的宣言，让你产生行动力？</li>
</ol>
</blockquote>
<h4 id="如何阅读故事书"><a href="#如何阅读故事书" class="headerlink" title="如何阅读故事书"></a>如何阅读故事书</h4><p>第一个建议：一口气读完<br>第二个建议：批评故事前区分故事是满足了我们个人潜意识的需求，还是满足大多数人潜意识的需求。</p>
<p>之所以谈到潜意识是因为，小说之所以是人类不可或缺的，是因为它能满足我们潜意识或者意识中的许多需求。</p>
<blockquote>
<ol>
<li>理想上来说，一个故事应该一口气读完，</li>
<li>小说能满足我们潜意识或意识中许多的需要。</li>
<li>我们喜欢某种人，或讨厌某种人，但却并不很清楚为什么。如果是在小说中，某个人受到奖励或处罚，我们都会有强烈的反应。我们会甚至因而对这本书有艺术评价之外的正面或负面的印象。</li>
<li>其实，在每个人的面具之下，潜意识里都可能有些虐待狂或被虐狂。这些通常在小说中获得了满足，我们会认同那位征服者或被虐者，或是两者皆可。</li>
<li>因此，在批评小说时，我们要小心区别这两种作品的差异：一种是满足我们个人特殊潜意识需求的小说——那会让我们说：“我喜欢这本书，虽然我并不知道为什么。”另一种则是满足大多数人潜意识需求的小说。用不着</li>
</ol>
</blockquote>
<h4 id="关于史诗的重点"><a href="#关于史诗的重点" class="headerlink" title="关于史诗的重点"></a>关于史诗的重点</h4><p>史诗的阅读较为困难，要求集中注意力全心参与并运用想象力。</p>
<h4 id="如何阅读戏剧"><a href="#如何阅读戏剧" class="headerlink" title="如何阅读戏剧"></a>如何阅读戏剧</h4><p>剧本不像小说能将背景描述的非常清楚，而且剧本并非一个完整的作品，完整的剧本只能出现在舞台上。所以剧本的阅读要读者假装可以看到舞台的实景，</p>
<blockquote>
<p>要阅读萧伯纳式的剧本，却不读萧伯纳所写的前言，就等于是拒绝了作者最重要的帮助，不让他辅助你理解这出戏。</p>
</blockquote>
<h4 id="关于悲剧的重点"><a href="#关于悲剧的重点" class="headerlink" title="关于悲剧的重点"></a>关于悲剧的重点</h4><p>阅读悲剧时有两点建议，一是悲剧的精髓在于时间，二是读悲剧时，旁边的台词要想象是一个和自己身高差不多的人念出，而悲剧人物的台词则是出自一个高大的人。这样才更符合悲剧演出时的场景。</p>
<blockquote>
<ol>
<li>第一，记住悲剧的精髓在时间，或是说缺乏时间。如果在希腊悲剧中有足够的时间，就没有解决不了的事。问题是时间永远不够。决定或选择都要在一定的时刻完成，没有时间去思考，衡量轻重。</li>
<li>在读旁白的部分时，你要想象这些台词是跟你一般身高的人所说出来的话，而在读悲剧人物的台词时，你要想象这是出自一个大人物的口中，</li>
</ol>
</blockquote>
<h4 id="如何阅读抒情诗"><a href="#如何阅读抒情诗" class="headerlink" title="如何阅读抒情诗"></a>如何阅读抒情诗</h4><p>阅读抒情诗第一是无论自己懂不懂都要一口气读完，二是读完后重读一遍大声的念出来，三是大部分的抒情诗都存在一些冲突，尝试去寻找，四是不要太依赖于作者和背景资料。</p>
<blockquote>
<ol>
<li>诗仍是由文字组成的，而且是以条理分明，精巧熟练的方式所组合出来的。</li>
<li>阅读抒情诗的第一个规则是：不论你觉得自己懂不懂，都要一口气读完，不要停。</li>
<li>他们没法立即了解这行诗，便以为整首诗都是如此了。他们在字谜间穿梭，想重新组合混乱的语法，很快地他们放弃了，并下结论说：他们怀疑现代诗对他们而言是太难理解了。</li>
<li>任何一首诗都有个整体大意。除非我们一次读完，否则无法理解大意是什么，也很难发现诗中隐藏的基本感觉与经验是什么。</li>
<li>阅读抒情诗的第二个规则是：重读一遍——大声读出来。…你的耳朵会抗议你的眼睛所忽略的地方。</li>
<li>这可能只是因为我们怀疑自己的阅读能力。只要一个人愿意努力，几乎任何人都能读任何诗。</li>
<li>伟大的抒情诗值得再三玩味。而在放下这首诗的时候，我们对这首诗所有的体会，可能更超过我们的认知。</li>
</ol>
</blockquote>
<h3 id="如何阅读历史书"><a href="#如何阅读历史书" class="headerlink" title="如何阅读历史书"></a>如何阅读历史书</h3><h4 id="难以捉摸的史实"><a href="#难以捉摸的史实" class="headerlink" title="难以捉摸的史实"></a>难以捉摸的史实</h4><p>历史学家关心的是过去发生的事，而且也很难有一个严格的检验标准，所以了解历史书真正发生了什么事是极为困难的。</p>
<h4 id="历史的理论"><a href="#历史的理论" class="headerlink" title="历史的理论"></a>历史的理论</h4><p>历史如果非要在科学和小说间做出个选择，更接近于小说。历史学家个人对的理论会很大程度上影响对于历史的描述，所以真正想要了解一个事件或时期的历史，就很有必要多看一些相关的论著，从多个角度观察。</p>
<blockquote>
<ol>
<li>他可能有一套理论或哲学，像是上帝掌管人间的事物一样，编纂出适合他理论的历史。或者，他会放弃任何置身事外或置身其上的模式，强调他只是在如实报导所发生过的事件。</li>
<li>因为关于历史的理论不同，因为历史家的理论会影响到他对历史事件的描述，</li>
<li>为了追求真相，我们必须从更多不同的角度来观察才行。</li>
</ol>
</blockquote>
<h4 id="历史的普遍性"><a href="#历史的普遍性" class="headerlink" title="历史的普遍性"></a>历史的普遍性</h4><p>阅读历史的目的并不在于了解历史所处的那个时代，而是为了了解目前发生的事，历史是存在普遍性的。</p>
<p>阅读历史的要点在于：一是对于感兴趣的历史或时期，要阅读一种以上的历史书。二是阅读历史时不仅要知道历史本身更要了解背后的动机。</p>
<blockquote>
<ol>
<li>希望经由他所观察到的错误，以及他个人受到的灾难与国家所受到的苦楚，将来的人们不会重蹈覆辙。</li>
<li>阅读历史的两个要点是：第一，对你感兴趣的事件或时期，尽可能阅读一种以上的历史书。第二，阅读历史时，不只要关心在过去某个时间、地点真正发生了什么事，还要读懂在任何时空之中，尤其是现在，人们为什么会有如此这般行动的原因。</li>
</ol>
</blockquote>
<h4 id="阅读历史书要提出的问题"><a href="#阅读历史书要提出的问题" class="headerlink" title="阅读历史书要提出的问题"></a>阅读历史书要提出的问题</h4><p>这里仍然是每一本书都需要回答的四个问题。</p>
<p>第一个问题是要了解历史书描写的特殊且限定范围的主题。第二个问题是要知道历史书是按照怎么样的方法来架构的，是按照年代还是地区或者其他方法。第三个问题是历史书是否准确，这可以从两个方向去考虑，一是这本书是否逼真，二是作者是否误用了材料。最后一个问题是与我何干，历史总会提供一些可行性，因为我们可以根据历史去做一些事或者规避一些事。</p>
<h4 id="如何阅读传记与自传"><a href="#如何阅读传记与自传" class="headerlink" title="如何阅读传记与自传"></a>如何阅读传记与自传</h4><p>传记有很多种，第一种是定案本，这类书有很高的权威性，应该用读历史书的方法来阅读，第二种是授权本，是由继承人或重要的朋友来写的，所以读者必须要了解到授权本的作者存在的偏见。介于这两种传记中间的是一般传记，我们可以当一般的小说来读。</p>
<p>但无论是哪种传记，我们要牢记的是，传记本身都存在作者自身的影响，所以对于任何传记都要存有怀疑心。</p>
<blockquote>
<ol>
<li>定案本的传记绝不能用来写活着的人。</li>
<li>一本定案本的传记是历史的一部分——这是一个人和他生活的那个时代的历史，就像从他本人的眼中所看到的一样。应该用读历史的方法来读这种传记。“授权本”（authorized）传记又是另一回事了。这样的工作通常是由继承人，或是某个重要人物的朋友来负责的。因为他们的写作态度很小心，因此这个人所犯的错，或是达到的成就都会经过润饰。</li>
<li>没有人能反驳你的时候，你可能会掩盖事实，或夸大事实，这是无可避免的事。</li>
<li>对于任何自传都要有一点怀疑心，同时别忘了，在你还不了解一本书之前，不要妄下论断。至于“这本书与我何干？”这个问题，我们只能说：传记，就跟历史一样，可能会导引出某个实际的、良心的行动。</li>
</ol>
</blockquote>
<h4 id="如何阅读关于当前的事件"><a href="#如何阅读关于当前的事件" class="headerlink" title="如何阅读关于当前的事件"></a>如何阅读关于当前的事件</h4><p>人的大脑会不可避免如过滤器一样排除掉自认为不准确的信息，所以我们在阅读当前事件时需要关心作者本身的情况，要知道他带着怎样的过滤器，并提出一系列问题：（1）作者想要证明什么？（2）他想要说服谁？（3）他具有的特殊知识（或者说偏见）是什么？（4）他使用的特殊语言是什么？（5）他真的知道自己在说什么吗（作者本身也可能在不知情的情况下存在知识不足而写出错误的东西）？</p>
<blockquote>
<ol>
<li>一个记者尽管可能抱持着最大的善意，一心想提供读者真实的资料，在一些秘密的行动或协议上仍然可能“知识不足”。他自己可能知道这一点，也可能不知道。当然，如果是后者，对读者来说就非常危险了。</li>
<li>写作当代事件的作者却可能（虽然不见得一定）在希望你用某一种方式了解这件事的过程中，有他自己的利益考虑。就算他不这么想，他的消息来源也会这么想。你要搞清楚他们的利益考虑，阅读任何东西都要小心翼翼。</li>
</ol>
</blockquote>
<h4 id="关于文摘的注意事项"><a href="#关于文摘的注意事项" class="headerlink" title="关于文摘的注意事项"></a>关于文摘的注意事项</h4><p>一些新闻报刊会浓缩新闻形成最基本要素的资讯，作为读者我们要尝试读出言外之意，并选择合适的部分去阅读原著。</p>
<h3 id="如何阅读科学与数学"><a href="#如何阅读科学与数学" class="headerlink" title="如何阅读科学与数学"></a>如何阅读科学与数学</h3><p>作者首先在这里限定了讨论的范围是科学与数学的经典之作及现代科普著作，排除了专业的研究论文。</p>
<blockquote>
<p>通常不是这个领域中的读者根本无法阅读这类文章。这样的倾向有明显的好处，这使科学的进步更加快速。</p>
</blockquote>
<h4 id="了解科学这一门行业"><a href="#了解科学这一门行业" class="headerlink" title="了解科学这一门行业"></a>了解科学这一门行业</h4><p>作为一个门外汉阅读上述的两种书并非要成为专业领域人士，相反只是为了了解科学的历史与哲学。作为一个门外汉我们也应当了解伟大的科学家们想要解决的是什么问题。</p>
<blockquote>
<ol>
<li>这样的态度可以用萧伯纳的一句名言来作总结：“有能力的人，就去做。没有能力的人，就去教。”</li>
<li>其中没有一本真的很难读，就算牛顿的《自然哲学的数学原理》（MathematicalPrinciplesofNaturalPhilosophy），只要你真的肯努力，也是可以读得通的。</li>
</ol>
</blockquote>
<h4 id="阅读科学经典名著的建议"><a href="#阅读科学经典名著的建议" class="headerlink" title="阅读科学经典名著的建议"></a>阅读科学经典名著的建议</h4><p>科学作品的论述一般是两种方法，一是归纳法，二是演绎法。归纳法需要了解理论基础，而门外汉往往没有，这就需要依靠实验。二是推论，推论就常需要用到数学。</p>
<blockquote>
<ol>
<li>伟大的科学作品，尽管最初的假设不免个人偏见，但不会有夸大或宣传。你要注意作者最初的假设，放在心上，然后把他的假设与经过论证之后的结论作个区别。一个越“客观”的科学作者，越会明白地要求你接受这个、接受那个假设。科学的客观不在于没有最初的偏见，而在于坦白承认。</li>
<li>科学不是编年史，科学家跟历史学家刚好相反，他们要摆脱时间与地点的限制。他要说的是一般的现象，事物变化的一般规则。</li>
</ol>
</blockquote>
<h4 id="面对数学的问题"><a href="#面对数学的问题" class="headerlink" title="面对数学的问题"></a>面对数学的问题</h4><p>把数学当做是一种语言来学习即可，数学的演绎过程同样具有架构与脉络，而且数学还不存在歧义。</p>
<blockquote>
<ol>
<li>原因是当我们的话题牵涉到情绪时，我们很难理解一些言外之意。数学却能让我们避免这样的问题。只要能适当地运用数学的共识、主旨与等式，就不会有情绪上言外之意的问题。</li>
<li>我们在这里所谈的只是针对一个真正有范围限制的问题，作出真正逻辑的解释。在解释的清晰与问题范围有限制的特质之中，有一种特别的吸引力。在一般的谈话中，就算是非常好的哲学家在讨论，也没法将问题如此这般说得一清二楚。</li>
</ol>
</blockquote>
<h4 id="掌握科学作品中的数学问题"><a href="#掌握科学作品中的数学问题" class="headerlink" title="掌握科学作品中的数学问题"></a>掌握科学作品中的数学问题</h4><p>关于数学成为阅读科学作品中的障碍有两点需要说明，一是读者至少可以把基础程度的数学读的更明白，二是如果你读一本书的目的是为了了解数学本身，那你需要从头读到尾并且伴随着纸笔的运算，否则可以选择略读或跳过，只需要关心定理的说明和推论的结果即可。</p>
<h4 id="关于科普书的重点"><a href="#关于科普书的重点" class="headerlink" title="关于科普书的重点"></a>关于科普书的重点</h4><p>阅读科普书与阅读科学作品类似，而且更为简单。科普性的科学书籍虽然是理论性的书，但往往也会带来些实用性的结果，如该如何面对环保问题，如何看待核等。</p>
<h3 id="如何阅读哲学书"><a href="#如何阅读哲学书" class="headerlink" title="如何阅读哲学书"></a>如何阅读哲学书</h3><h4 id="哲学家提出的问题"><a href="#哲学家提出的问题" class="headerlink" title="哲学家提出的问题"></a>哲学家提出的问题</h4><p>哲学家提出的问题分为两类，第一类是关于存在与变化，这类问题属于理论或思辩型的部分。第二部分关于善与恶，好与坏，这类属于哲学中的实用部分。</p>
<blockquote>
<ol>
<li>根据亚里士多德的说法，哲学来自怀疑。那必然是从孩提时代就开始的疑问，只是大多数人的疑惑也就止于孩提时代。</li>
<li>就算有答案，我们也常告诉孩子说没有答案，或是要他们不要再问问题了。碰到那些看来回答不了的问题时，我们觉得困窘，便想用这样的方法掩盖我们的不自在。所有这些都在打击一个孩子的好奇心。他可能会以为问问题是很不礼貌的行为。</li>
<li>能够保留孩子看世界的眼光，又能成熟地了解到保留这些问题的意义，确实是非常稀有的能力——拥有这种能力的人也才可能对我们的思想有重大的贡献。<br>成人复杂的生活阻碍了寻找真理的途径。</li>
<li>如果思辨或理论型的哲学主要在探讨存在的问题，那就属于形上学。如果问题与变化有关——关于特质与种类的演变，变化的条件与原因——就是属于自然哲学的。如果主要探讨的是知识的问题——关于我们的认知，人类知识的起因、范围与限制，确定与不确定的问题——那就属于认识论（epistemology）的部分，也称作知识论。就理论与规范哲学的区分而言，如果是关于如何过好生活，个人行为中善与恶的标准，这都与伦理学有关，也就是理论哲学的领域；如果是关于良好的社会，个人与群体之间的行为问题，则是政治学或政治哲学的范畴，也就是规范哲学的领域。</li>
</ol>
</blockquote>
<h4 id="现代哲学与传承"><a href="#现代哲学与传承" class="headerlink" title="现代哲学与传承"></a>现代哲学与传承</h4><p>把存在与改变，人类该做什么该追求什么的问题看作为第一顺位的问题，把关于第一顺位问题中的知识，回答第一问题时的思考模式，该如何表达回答等问题称为第二顺位问题。现代哲学已经不相信第一顺位问题可以被哲学家解决，都将注意力投入于第二哲学中。</p>
<blockquote>
<p>今天的哲学，就像当前的科学或数学一样，已经不再为门外汉写作了。第二顺位的问题，几乎可以顾名思义，都是些诉求比较窄的问题，而专业的哲学家，就像科学家一样，他们唯一关心的只有其他专家的意见。</p>
</blockquote>
<h4 id="哲学方法"><a href="#哲学方法" class="headerlink" title="哲学方法"></a>哲学方法</h4><p>哲学问题没有实验可以做，没有特殊现象可以观察，唯一能做的只有思考，哲学问题的检验标准就是人的一般经验。</p>
<p>哲学家对于问题答案的探究也并非寻找更多的经验，只是比一般人更深入的思考问题。但有着一种情况需要避免，即哲学家误将科学性问题当做哲学问题进行思考，如古代的哲学家会去思考天体的运动等。</p>
<blockquote>
<p>要避免这样的困难，读者必须有能力把哲学家所处理真正哲学性的问题，和他们可能处理，但事实上应该留给后来科学家来寻找答案的其他问题作一区别。</p>
</blockquote>
<h4 id="哲学家的分类"><a href="#哲学家的分类" class="headerlink" title="哲学家的分类"></a>哲学家的分类</h4><p>哲学的方法只有思考以这种，但哲学家们最少用了五种方法来论述哲学。第一种是以柏拉图为典型的<code>哲学对话</code>，第二种是以康德和亚里士多德为典型的<code>哲学论文或散文</code>，第三种是以阿奎那为典型的<code>面对异议型</code>，这种会先对异议的观点进行批判，再提出自己的观点并加以论证。第四种是<code>系统化哲学</code>，这是以笛卡尔和斯宾诺莎为典型的，他们常识用数学这样的组织方式将哲学整理出来。第五种是尼采这样的<code>格言形式</code></p>
<blockquote>
<ol>
<li>从对立与冲突中，让真理逐渐浮现，这是中世纪非常盛行的想法。</li>
<li>数学的方法还是比较适合几何或其他的数学问题，而不适合用在哲学问题上。当你阅读斯宾诺莎的时候，可以像你在阅读牛顿的时候那样略过很多地方，在阅读康德或亚里士多德时，你什么也不能略过。</li>
</ol>
</blockquote>
<h4 id="阅读哲学的提示"><a href="#阅读哲学的提示" class="headerlink" title="阅读哲学的提示"></a>阅读哲学的提示</h4><p>阅读哲学最为关键的是找到哲学家在作品背后隐藏的中心思想和原则，这个很难，或许要花费许多年的时间，而且很难给出恰当的建议。</p>
<blockquote>
<ol>
<li>所谓你对某件事“有了概念”，也就是你对自己具体经验到的某些事情的普遍性层面有了了解。</li>
<li>假装相信一些其实你并不相信的事，是很好的心智训练。当你越清楚自己的偏见时，你就越不会误判别人的偏见了。</li>
<li>读者在面对一本哲学书时，除了阅读以外，什么也不能做——那也就是说，要运用你的思考。除了思考本身外，没有任何其他的帮助。</li>
</ol>
</blockquote>
<h4 id="厘清你的思绪"><a href="#厘清你的思绪" class="headerlink" title="厘清你的思绪"></a>厘清你的思绪</h4><p>哲学家彼此的意见常常不合一但这不应该成为阅读哲学书的困扰，一是因为有些问题尚未被解决，二是厘清自己的思绪才重要，用别人的意见并没有解决问题，只是逃避问题。</p>
<h4 id="关于神学的重点"><a href="#关于神学的重点" class="headerlink" title="关于神学的重点"></a>关于神学的重点</h4><p>神学分为自然神学和教义神学。自然神学是哲学的一种，可当做哲学书来观看。教义神学则是信徒所信奉的经文，在阅读这类书时常会犯两个错误，一是拒绝接受，阅读时应该要记住，经文对于有信仰的人来说是一种知识而非假设。二是认为原则是教义的，那么其论证、推论、结果也是教义的。这里要做区分，原则是教义的，但如果推论存在错误，那么也会得出无效的结论。</p>
<blockquote>
<p>谈到这里，你该明白一个没有信仰的读者要阅读神学书时有多困难了。在阅读这样的书时，他要做的就是接受首要原则是成立的，然后用阅读任何一本好的论说性作品都该有的精神来阅读。</p>
</blockquote>
<h4 id="如何阅读“经书”"><a href="#如何阅读“经书”" class="headerlink" title="如何阅读“经书”"></a>如何阅读“经书”</h4><p>对于信徒而言，经书中不会存在错误，这是前提，并且有义务从中找到意义，并能从其他的事实中举证其真实性。</p>
<h3 id="如何阅读社会科学"><a href="#如何阅读社会科学" class="headerlink" title="如何阅读社会科学"></a>如何阅读社会科学</h3><h4 id="什么是社会科学"><a href="#什么是社会科学" class="headerlink" title="什么是社会科学"></a>什么是社会科学</h4><p>社会科学包含了很多其他的学科，如人类学、经济学、政治学与社会学，社会科学关心的是文化、制度与环境因素。</p>
<h4 id="阅读社会科学的容易处"><a href="#阅读社会科学的容易处" class="headerlink" title="阅读社会科学的容易处"></a>阅读社会科学的容易处</h4><p>一是作品的内容通常取自于读者熟悉的经验，二是我们熟悉社会科学的术语，三是社会科学讨论的问题，我们通常已经有了一些思考与意见。</p>
<h4 id="阅读社会科学的困难处"><a href="#阅读社会科学的困难处" class="headerlink" title="阅读社会科学的困难处"></a>阅读社会科学的困难处</h4><p>让阅读社会科学阅读简单的元素也造成了它的困难，一是因为我们对社会科学讨论的问题已有自己的意见，所以我们常会拒绝作者的观点。二是因为对于许多记者和专栏作家让某些社会科学的术语承担了太多的责任，已经超出了其本身应该覆盖的范围，这就造成了术语意义的不明确。三是因为社会科学混杂了太多的不同学科，所以很难区分书的元素。</p>
<blockquote>
<ol>
<li>如果你要回答阅读任何作品都该提出的头两个问题，你一定要先检查一下你自己的意见是什么。如果你拒绝倾听一位作者所说的话，你就无法了解这本书了。</li>
<li>其中一个理由是，社会科学并不能数学化，另一个理由是在社会或行为科学中，要说明用语比较困难。</li>
<li>阅读社会科学作品最困难的地方在于：事实上，在这个领域中的作品是混杂的，而不是纯粹的论说性作品。</li>
</ol>
</blockquote>
<h4 id="阅读社会科学作品"><a href="#阅读社会科学作品" class="headerlink" title="阅读社会科学作品"></a>阅读社会科学作品</h4><p>阅读社会科学时常常要读好几本书，而非一本，一是因为社会科学存在一定的时效性，作品要不断的推陈出新，二是社会科学是一个较新的学科，经典作品还不多。这也就引出了之后要讨论的主题阅读。</p>
<h2 id="阅读的最终目标"><a href="#阅读的最终目标" class="headerlink" title="阅读的最终目标"></a>阅读的最终目标</h2><h3 id="阅读的第四个层次：主题阅读"><a href="#阅读的第四个层次：主题阅读" class="headerlink" title="阅读的第四个层次：主题阅读"></a>阅读的第四个层次：主题阅读</h3><p>主题阅读是要读多本书，但确定一个主题究竟牵扯到哪些书是一个困难的事，往往在一开始我们确定的书目会非常的庞大，我们要将其删减至一个合理的范围。</p>
<h4 id="在主题阅读中，检视阅读所扮演的角色"><a href="#在主题阅读中，检视阅读所扮演的角色" class="headerlink" title="在主题阅读中，检视阅读所扮演的角色"></a>在主题阅读中，检视阅读所扮演的角色</h4><p>收集到主题的书目后，首先要通过检视阅读检视上面所有的书，这样第一会帮助你对主题有个清晰的概念，第二它可以简化书目。</p>
<blockquote>
<p>他们阅读每一本书或每一篇文章都花上同样的时间与努力，结果他们该花精神好好阅读的书却没有读好，倒把时间花在那些不太值得注意的书上了。</p>
</blockquote>
<h4 id="主题阅读的五个步骤"><a href="#主题阅读的五个步骤" class="headerlink" title="主题阅读的五个步骤"></a>主题阅读的五个步骤</h4><p>步骤一：找到相关的章节，这仍然依靠检视阅读，通常建议再次检视删减后的书目，找到相关的章节，所以主题阅读并不是完整的阅读一本书目。<br>步骤二：带领作者与你达成共识。在主题阅读时，我们要建立自己的一套词汇，然后将各个作者的观点，用我们自己的词语进行表达。<br>步骤三：厘清问题。步骤二中我们建立了词汇，步骤三则是要建立一套主旨，最好的方法就是列出一系列可以讲问题说明白的问题。问题可以从概念的存在与特质、概念如何发现，如何表达，有什么影响等角度出发。<br>步骤四：界定议题。当有了问题后会发现各个作者用了不同的方式去表达，这时候我们就要将观点分类形成议题。<br>步骤五：分析讨论。我们需要说明问题的不同答案并说明原因以及我们将答案分类的依据。</p>
<h4 id="客观的必要性"><a href="#客观的必要性" class="headerlink" title="客观的必要性"></a>客观的必要性</h4><p>注意在上述步骤五中，我们并非要通过主题阅读去找到一个问题的确切答案，因为这样就失去了讨论的客观性。主题阅读需要的是自己不预设立场，即使在最终的总结部分，也要有作者原文的支持。</p>
<blockquote>
<ol>
<li>换句话说，主题阅读的目的，并不是给阅读过程中发展出来的问题提供最终答案，也不是给这个计划开始时候的问题提供最终解答。</li>
<li>主题阅读所追求的这种特质，可以用这句话来作总结：“辩证的客观。”简单来说，主题阅读就是要能面面俱到，而自己并不预设立场。当然，这是个严格的理想，一般人是没法做到的。</li>
<li>在分析问题时必须先建立一套中立的词汇。这样的中立语言还是必要的，而且在总结一个作者的论述时，一定要用这套中立的语言，而不是作者的语言。但是伴随着总结，一定要有仔细引用的作者原文，以免对文意有所扭曲，这样阅读者才能自己判断你对作者所作的诠释是否正确。</li>
</ol>
</blockquote>
<h4 id="主题工具书"><a href="#主题工具书" class="headerlink" title="主题工具书"></a>主题工具书</h4><p>一些工具书已经整理了某个主题的书目甚至章节，他们可以引导我们进行主题阅读。</p>
<h4 id="构成主题阅读原则"><a href="#构成主题阅读原则" class="headerlink" title="构成主题阅读原则"></a>构成主题阅读原则</h4><p>主题阅读的原则即是将作者的话用自己的语言表示，将不同作者拉到一起讨论一个问题。</p>
<h3 id="阅读与心智的成长"><a href="#阅读与心智的成长" class="headerlink" title="阅读与心智的成长"></a>阅读与心智的成长</h3><h4 id="好书能给我们什么帮助"><a href="#好书能给我们什么帮助" class="headerlink" title="好书能给我们什么帮助"></a>好书能给我们什么帮助</h4><p>阅读超越自己头脑的书能带来思想的增长否则就只有资讯的提升，一本好书也能让人更好的了解自己和世界。</p>
<blockquote>
<ol>
<li>你必须能操纵超越你能力的书，或像我们所说的，阅读超越你头脑的书。只有那样的书能帮助你的思想增长。除非你能增长心智，否则你学不到东西。</li>
<li>伟大的经典就是在帮助你把这些问题想得更清楚一点，因为这些书的作者都是比一般人思想更深刻的人。</li>
</ol>
</blockquote>
<h4 id="书的金字塔"><a href="#书的金字塔" class="headerlink" title="书的金字塔"></a>书的金字塔</h4><p>世间的书大部分都是对阅读技巧毫无帮助，因为他们已经在你的能力之类。有些书在你的能力之外值得值得做分析阅读，但<br>在第一次的阅读后，你就不再需要再次去读他们，因为这本书已经增长了你的理解力，你的能力已经和这本书持平了。还有一小部分书，在你阅读后仍然存有疑问，如果你知道疑惑在哪，那你可以马上再次进行阅读，但有些你无法理解，且每次的重写阅读都能让你看到新的东西，这是因为你的每次重新阅读都让你的能力增长了些许，而提升的理解力会让你产生新的感受。</p>
<blockquote>
<p>如果这本书是属于前面我们所说第二种类型的书，重读的时候，你会发现书中的内容好像比你记忆中的少了许多。当然，原因是在这个阶段中你的心智成长了许多。你的头脑充实了，理解力也增进了。书籍本身并没有改变，改变的是你自己。</p>
</blockquote>
<h4 id="生命与心智的成长"><a href="#生命与心智的成长" class="headerlink" title="生命与心智的成长"></a>生命与心智的成长</h4><p>人有内在的生命力量，主动阅读能让我们的心智保持活力和成长。</p>
<blockquote>
<p>除此之外，似乎也没法说明为什么许多工作忙碌的人一旦退休之后就会立刻死亡。他们活着是因为工作对他们的心智上有所要求，那是一种人为的支撑力量，也就是外界的力量。一旦外界要求的力量消失之后，他们又没有内在的心智活动，他们便停止了思考，死亡也跟着来了。</p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>《算法导论》 第十三章笔记</title>
    <url>/IA-Chapter13-Notes/</url>
    <content><![CDATA[<p>《算法导论》 第十三章笔记 红黑树实现</p>
<span id="more"></span>
<h1 id="Chapter-13-Red-Black-Trees"><a href="#Chapter-13-Red-Black-Trees" class="headerlink" title="Chapter 13. Red-Black Trees"></a>Chapter 13. Red-Black Trees</h1><p>红黑树是众多让二叉搜索树达到平衡的树形结构之一。树达到平衡可以保证动态操作，如删除，插入，搜索等，复杂度都为$O(lgn)$。</p>
<h2 id="Properties-of-red-black-trees"><a href="#Properties-of-red-black-trees" class="headerlink" title="Properties of red-black trees"></a>Properties of red-black trees</h2><p>红黑树是一种特殊的二叉搜索树，每个结点需要花费额外一个bit来存储结点的颜色信息，颜色为红或者黑。红黑树保证了整棵树，不会有一个路径是另一个路径的两倍长。</p>
<p>红黑树满足以下五个特性：</p>
<ol>
<li>所有结点要么是黑要么是红</li>
<li>根节点是黑色的</li>
<li>每个叶子（这里指NULL结点）是黑色的</li>
<li>如果一个结点是红色的，那么他的两个子结点是黑色的（即不会有连续的两层是红）</li>
<li>所有结点到任意叶子的简单路径上（不存在绕行）有相同的黑色结点数</li>
</ol>
<p>将任意结点到叶子的路径上黑色结点的数目成为<code>黑高(black-height)</code>，表达为$bh(x)$。将一棵树的黑高定义为：根节点到叶子的黑高。</p>
<ul>
<li>黑高的计算并不包含结点自己。例如，根节点必然是黑色的，但如果一棵树，只有根节点，那么他的黑高是0，因为根节点并不纳入黑高的计算。</li>
</ul>
<p>用一个哨兵（用<code>T.nil</code>表示）来指代叶子结点（NULL），这样所有的叶子和根节点的父节点都为<code>T.nil</code>。</p>
<p>将除了叶子结点外的所有结点成为<code>内部结点(internal nodes)</code>，否则为外部结点<code>external nodes</code></p>
<div class="note info simple"><p>定理：一个有$n$个内部结点的红黑树，其高度最多为$2\lg (n+1)$</p>
</div>
<p>定理证明如下：</p>
<ol>
<li><p>首先需要证明定理：对于任意一个结点$x$，至少有$2^{bh(x)}-1$个内部子结点</p>
<p>用推导法证明该定理：</p>
<p>(1)如果结点<code>x</code>的高度是0，则<code>x</code>一定是叶子结点。其黑高为0，那么内部子节点为$2^0-1=0$，即0个内部子节点，满足</p>
<p>(2) 如果结点<code>x</code>的高度不为0，且有两个子结点。根据特性5，可以推得如果这个子结点是红色，则这个子结点的黑高为$bh(x)$，如果子结点是黑色，则子结点的黑高为$bh(x)-1$。</p>
<p>因为$x$的黑高为$bh(x)$，如果子结点是黑色的，则这个子结点本身提供了一个黑色结点，所以它的黑高只能为父结点黑高减1，即$bh(x)-1$，反之子结点是红色的，那么这个结点不提供黑色结点，他的黑高和父结点一样，为$bh(x)$</p>
<p>所以结点$x$至少有 $2*(2^{bh(x)-1}-1) +1$个结点，这里两个子结点的各自内部子结点数计算都取更小的黑高数$bh(x)-1$，式子最后实际上应该是+2的，即$x$的两个子结点，但这里取更小的1，式子计算得$2^{bh(x)}-1$，即满足定理。</p>
</li>
<li><p>根据红黑树的特性4，红色结点的子结点必为黑色。所以红色结点出现最多的情况也只能是红黑相间，红色结点不可能连续出现而黑色结点可以。因此一个节点的黑高数最起码是其高度的一半，即$bh(x)&gt;\frac{h}{2}$。</p>
</li>
<li><p>结合1和2中得出的结论。1中得出了</p>
<script type="math/tex; mode=display">
n \geq 2^{bh(x)}-1</script><p>2中得出了</p>
<script type="math/tex; mode=display">
bh(x)>\frac{h}{2}</script><p>所以</p>
<script type="math/tex; mode=display">
n \geq 2^{bh(x)}-1 \geq 2^{\frac{h}{2}} -1</script><p>即</p>
<script type="math/tex; mode=display">
2^{\frac{h}{2}} \leq n+1</script><p>即</p>
<script type="math/tex; mode=display">
h \leq 2 \lg (n+1)</script><p>得证。</p>
</li>
</ol>
<p>因为一个有$n$个结点的红黑树，其高度$h$最多为$2\lg (n+1)$，且二叉搜索树的操作时间复杂度都为$O(h)$，所以红黑树操作的时间复杂度为$O(\lg n)$</p>
<h2 id="Rotations"><a href="#Rotations" class="headerlink" title="Rotations"></a>Rotations</h2><p>红黑树的插入和删除操作都可能破坏红黑树特性。为了保证红黑树的特性，可以在两个操作后通过修改结点的颜色，和改变树的部分结构保证其仍然满足红黑树的特性。</p>
<p>通过<code>Rotate</code>操作来修改树的部分结构，这个操作要保证修改树结构的同时<strong>不会影响二叉搜索树的特性</strong>。<code>Rotate</code>分为<code>leftRotate</code>和<code>rightRotate</code>，因为两个操作基本是镜像的，所以这里只对<code>leftRotate</code>作具体分析。</p>
<p>在对于一个结点$x$进行左旋时，$x$必须含有右子树，将$x$的右子树称为$y$。左旋操作的支点可以看作是$x$和$y$的交界点，左旋操作为：用y替换x的位置，将$y$原先的左子树变为$x$的右子树,将$x$变为$y$的左子树，。</p>
<p>左旋和右旋的示意图如下：从左到右是对于y的右旋，从右到左是对x的左旋</p>
<ul>
<li>无论是左旋还是右旋，被旋转的节点深度都+1，（变得更靠下）</li>
</ul>
<p><img src="IA-Chapter13-Notes/2019-11-06-16-54-51.png" alt="左旋及右旋操作"></p>
<p>左旋操作的伪代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TREE-ROTATE(T,x)</span><br><span class="line"></span><br><span class="line">y = x.right;</span><br><span class="line"></span><br><span class="line">//用y替换x的位置</span><br><span class="line">y.p = x.p</span><br><span class="line">if( x.p == NULL)</span><br><span class="line">    T.root = y</span><br><span class="line">else if ( x == x.p.left )</span><br><span class="line">    x.p.left = y</span><br><span class="line">else</span><br><span class="line">    x.p.right = y</span><br><span class="line"></span><br><span class="line">//将y的左结点变为x的右结点</span><br><span class="line">x.right = y.left</span><br><span class="line">if y.left != NULL</span><br><span class="line">y.left.p = x</span><br><span class="line"></span><br><span class="line">//将x作为y的左子树</span><br><span class="line">y.left = x</span><br><span class="line">x.p = y</span><br></pre></td></tr></table></figure>
<p>c++代码的实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">RBTree::LeftRotate</span><span class="params">(RBTreeNode* node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (node == nullNode || node-&gt;right == nullNode)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Invalid operation: LeftRotate&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	RBTreeNode* lowerRight = node-&gt;right;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//lowerRight replace node&#x27;s place</span></span><br><span class="line">	lowerRight-&gt;parent = node-&gt;parent;</span><br><span class="line">	<span class="keyword">if</span> (node-&gt;parent == nullNode)</span><br><span class="line">	&#123;</span><br><span class="line">		rootNode = lowerRight;</span><br><span class="line">		nullNode-&gt;right = rootNode;</span><br><span class="line">		nullNode-&gt;left = rootNode;</span><br><span class="line">		nullNode-&gt;parent = rootNode;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (node == node-&gt;parent-&gt;left)</span><br><span class="line">	&#123;</span><br><span class="line">		node-&gt;parent-&gt;left = lowerRight;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		node-&gt;parent-&gt;right = lowerRight;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//lowerRight&#x27;s left subtree become node&#x27;s right subtree</span></span><br><span class="line">	node-&gt;right = lowerRight-&gt;left;</span><br><span class="line">	<span class="keyword">if</span> (lowerRight-&gt;left != nullNode)</span><br><span class="line">	&#123;</span><br><span class="line">		lowerRight-&gt;left-&gt;parent = node;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//node as lowerRight&#x27;s left subtree</span></span><br><span class="line">	node-&gt;parent = lowerRight;</span><br><span class="line">	lowerRight-&gt;left = node;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>右旋操作与左旋操作对称，只要将左旋操作中的left都换为right,right都换为left即可。</p>
<p>这里直接给出右旋操作的c++代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">RBTree::RightRotate</span><span class="params">(RBTreeNode* node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//As the symmetry of LeftRotate</span></span><br><span class="line">	<span class="keyword">if</span> (node == nullNode || node-&gt;left == nullNode)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	RBTreeNode* lowerLeft = node-&gt;left;</span><br><span class="line"></span><br><span class="line">	lowerLeft-&gt;parent = node-&gt;parent;</span><br><span class="line">	<span class="keyword">if</span> (node-&gt;parent == nullNode)</span><br><span class="line">	&#123;</span><br><span class="line">		rootNode = lowerLeft;</span><br><span class="line">		nullNode-&gt;left = rootNode;</span><br><span class="line">		nullNode-&gt;right = rootNode;</span><br><span class="line">		nullNode-&gt;parent = rootNode;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (node == node-&gt;parent-&gt;right)</span><br><span class="line">	&#123;</span><br><span class="line">		node-&gt;parent-&gt;right = lowerLeft;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		node-&gt;parent-&gt;left = lowerLeft;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	node-&gt;left = lowerLeft-&gt;right;</span><br><span class="line">	<span class="keyword">if</span> (lowerLeft-&gt;right != nullNode)</span><br><span class="line">	&#123;</span><br><span class="line">		lowerLeft-&gt;right-&gt;parent = node;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	node-&gt;parent = lowerLeft;</span><br><span class="line">	lowerLeft-&gt;right = node;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>左旋及右旋操作的时间复杂度都为$O(1)$</p>
<h2 id="Insertion"><a href="#Insertion" class="headerlink" title="Insertion"></a>Insertion</h2><p>红黑树插入算法的思想为，先像普通的二叉搜索树一样插入结点，然后调用<code>RB-INSERT-FIXUP</code>函数调整树使其满足红黑树特性。</p>
<p>红黑树插入算法与普通的二叉搜索树插入算法主要有四个区别：</p>
<ol>
<li>用<code>T.nil</code>替代<code>NULL</code></li>
<li>将<code>T.nil</code>设为新插入结点的子结点</li>
<li><p>新插入结点的颜色为红色</p>
<p>这是为了保证性质5。如果新插入的结点设为黑色，那么新结点所在路径黑高则会增加，而另一条路径不变，则违背了性质5）。</p>
</li>
<li>插入后，调用<code>RB-INSERT-FIXUP</code>函数</li>
</ol>
<p>Insert伪代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RB-INSERT(T,z)</span><br><span class="line"></span><br><span class="line">z.left = T.nil</span><br><span class="line">z.right = T.nil</span><br><span class="line">z. color = RED</span><br><span class="line"></span><br><span class="line">y = T.nil</span><br><span class="line">x = T.root</span><br><span class="line">while x != T.nil</span><br><span class="line">    y = x</span><br><span class="line">    if z.key &lt; x.key</span><br><span class="line">        x = x.left</span><br><span class="line">    else</span><br><span class="line">        x= x.right</span><br><span class="line">z.p = y</span><br><span class="line">if y == T.nil</span><br><span class="line">    T.root = z</span><br><span class="line">else if z.key &lt; y.key</span><br><span class="line">    y.left = z</span><br><span class="line">else</span><br><span class="line">    y.right = z</span><br><span class="line"></span><br><span class="line">RB-INSERT-FIXUP(T,z)</span><br></pre></td></tr></table></figure>
<p>c++ 实现如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">RBTree::Insert</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	RBTreeNode* toInsert = <span class="keyword">new</span> <span class="built_in">RBTreeNode</span>();</span><br><span class="line">	toInsert-&gt;value = value;</span><br><span class="line">	toInsert-&gt;color = RED;</span><br><span class="line">	toInsert-&gt;right = nullNode;</span><br><span class="line">	toInsert-&gt;left = nullNode;</span><br><span class="line"></span><br><span class="line">	RBTreeNode* targetNode = rootNode;</span><br><span class="line">	RBTreeNode* targetNodeParent = nullNode;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (targetNode != nullNode)</span><br><span class="line">	&#123;</span><br><span class="line">		targetNodeParent = targetNode;</span><br><span class="line">		<span class="keyword">if</span> (value &lt; targetNode-&gt;value)</span><br><span class="line">		&#123;</span><br><span class="line">			targetNode = targetNode-&gt;left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (value &gt; targetNode-&gt;value)</span><br><span class="line">		&#123;</span><br><span class="line">			targetNode = targetNode-&gt;right;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (targetNodeParent == nullNode)<span class="comment">//Tree is empty</span></span><br><span class="line">	&#123;</span><br><span class="line">		rootNode = toInsert;</span><br><span class="line">		rootNode-&gt;parent = nullNode;</span><br><span class="line">		nullNode-&gt;left = rootNode;</span><br><span class="line">		nullNode-&gt;right = rootNode;</span><br><span class="line">		nullNode-&gt;parent = rootNode;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (value &lt; targetNodeParent-&gt;value)</span><br><span class="line">		&#123;</span><br><span class="line">			targetNodeParent-&gt;left = toInsert;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			targetNodeParent-&gt;right = toInsert;</span><br><span class="line">		&#125;</span><br><span class="line">		toInsert-&gt;parent = targetNodeParent;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">InsertFixUp</span>(toInsert);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后面要解决的问题就是函数<code>RB-INSERT-FIXUP(T,z)</code>的实现，在进入讨论前，需要先明确几点</p>
<ol>
<li>性质1不可能违背，因为新插入的结点是红色</li>
<li>性质3不可能违背，因为新插入的结点两个叶子设为了黑色</li>
<li>性质5不可能违背，因为新插入的结点为红色，且替换的是原来NULL的地方</li>
<li><p>可能违背的只有性质2和性质4。</p>
<p> 当新插入的结点$z$是根节点时，违背性质2</p>
<p> 当新插入的结点父节点是红色时，违背性质4</p>
</li>
<li><p>在每次插入新结点前，树的状态一定是满足红黑树的，这意味着同时性质2和性质4最多被违背一个。</p>
<p> 如果违背了性质2，那么说明新插入的$z$是树中唯一的结点，那么不可能违背性质4</p>
<p> 如果违背了性质4，那么说明$z$和$z.p$都为红色。$z.p$不可能是根节点，不然在插入$z$前就已经为违背了红黑树特性2，$z.p.p$必然为黑色，否则也是在插入前就违背了性质4。因此违背性质4的情况下，不可能违背性质2。</p>
</li>
</ol>
<p>这里算法更多的是关注违背性质4时的处理方式，因为性质2比较好修复，只要将根节点的颜色改变即可。</p>
<p><code>RB-INSERT-FIXUP(T,z)</code>算法一共对插入新结点后，可能出现的违背红黑树原则的6种情况进行修复。前三种情况出现在$z.p$是$z.p.p$的左结点，后三种情况是$z.p$是$z.p.p$的右结点。前三种与后三种情况的修复是对称的，将前三种修复时的左旋操作改成右旋操作即为后三种情况的修复。因此这里只关注于前三种情况的讲解。</p>
<p>前三种(z.p = z.p.p.left )情况的区分在于$z$的$uncle$的颜色，即$z.p.p.right$的颜色。</p>
<ol>
<li>如果$z.p.p.right$为红色，无论$z$是$z.p$的哪科子树，都为情况1。</li>
<li>如果$z.p.p.right$为黑色，且$z$是$z.p$是右子树，则为情况2。</li>
<li>如果$z.p.p.right$为黑色，且$z$是$z.p$是左子树，则为情况3。</li>
</ol>
<p><img src="IA-Chapter13-Notes/2019-11-07-00-05-44.png" alt="三种情况的示意图"></p>
<p>对于情况1的修复：</p>
<p>如图示，$z$为红色，$z.p$和$z.uncle$都是红色。情况1的修复步骤为：</p>
<ol>
<li><p>将$z.p$和$z.uncle$都变为黑色</p>
<p> 这样违背性质4的连续红色结点就消失了。</p>
</li>
<li><p>将$z.p.p$变为红色</p>
<p> 因为$z.p$和$z.uncle$都变成了黑色，所有包含他们的通路，黑高都+1。考虑到包含了$z.p$和$z.uncle$的通路必然都包含$z.p.p$，所以为了保证通路上的黑高不变，将$z.p.p$变为红，这样增加的黑高就弥补了。</p>
</li>
<li><p>将$z$指针指向$z.p.p$</p>
<p> 因为将$z.p.p$变为了红色，所以可能$z.p.p$和$z.p.p.p$会出现违背性质4的情况。将$z$指针指向$z.p.p$即可重新通过<code>RB-INSERT-FIXUP(T,z)</code>算法进行判断。</p>
</li>
</ol>
<p>情况1修复的图解如下：</p>
<p><img src="IA-Chapter13-Notes/2019-11-07-10-52-42.png" alt="情况1的修复"></p>
<p>对于情况2、3的修复：</p>
<p>在情况2和3下，$z.uncle$是黑色，因此$z.uncle$和$z.p$的颜色不同，也就不能像情况1的修复一样统一改成黑色，不然会影响他们子树的黑高。因此这两种情况需要用到旋转来修复。</p>
<p>情况2下$z$作为$z.p$的右子树，因此可以对$z.p$进行左旋。于$z.p$进行左旋后，将原先$z.p$定义为$z$即转换为了情况3，如下图所示</p>
<p><img src="IA-Chapter13-Notes/2019-11-09-20-08-02.png" alt="情况2转换为情况3"></p>
<p>对于情况3，我们对$z.p.p$，即上图中的$C$进行右旋。旋转后如下图所示。</p>
<p><img src="IA-Chapter13-Notes/2019-11-09-20-30-37.png" alt="情况3对于z.p.p右旋"></p>
<p>可以看到路径存在$A$结点的树的黑高都减一（原先父结点是黑色的$C$,现在变成了红色的$B$），而包含$C$结点的路径黑高是不变的。而且此时$A$和$B$还是不满足性质4。这里再将原先的$B$调整为黑色，原先的$C$调整为红色。对于包含$A$的路径而言，黑高+1，对于包含$C$的路径而言，黑高不变，因为路径上一个结点变成了红，一个结点变成了黑。因此情况三的最终变化如下：</p>
<p><img src="IA-Chapter13-Notes/2019-11-09-20-35-41.png" alt="情况3变化"></p>
<p>情况3调整后性质4和5都满足了，而不像情况1调整后仍然可能存在违背性质4的可能。</p>
<p>另外对于情况2和3的处理，不能是情况3通过右旋$z.p$来转换为情况2再进行修复。因为如果在情况2下对$C$进行右旋，会出现如下情况。</p>
<p><img src="IA-Chapter13-Notes/2019-11-09-20-44-24.png" alt="对情况2进行直接修复"></p>
<p>此时满足了性质4，但是包含$\alpha$结点路径的黑高少了1，如果为了满足性质5将$A$结点和$C$结点调整颜色，那么$C$结点和$B$结点又会违背性质4。</p>
<p>情况4，5，6的调整与情况1，2，3是镜像这里就不复述了。</p>
<p>整个给出<code>RB-INSERT-FIXUP(T,z)</code>的伪代码实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RB-INSERT-FIXUP(T,z)</span><br><span class="line"></span><br><span class="line">while z.p.color == RED</span><br><span class="line">	if z.p == z.p.p.left // Case 1,2,3</span><br><span class="line">		y= z.p.p.right</span><br><span class="line">		if (y.color == RED) //Case 1</span><br><span class="line">			z.p.color = BLACK</span><br><span class="line">			y.color = BLACK</span><br><span class="line">			z.p.p.color = RED</span><br><span class="line">			z = z.p.p</span><br><span class="line">		else</span><br><span class="line">			if z == z.p.right //Case 2</span><br><span class="line">				z = z.p</span><br><span class="line">				LEFT-ROTATE(T,z)</span><br><span class="line">			z.p.color = BLACK // Case 3,下一次循环将直接退出</span><br><span class="line">			z.p.p.color = RED</span><br><span class="line">			RIGHT-ROTATE(T,z.p.p)</span><br><span class="line">	else //Case 4,5,6</span><br><span class="line">		...</span><br><span class="line">		//和情况1,2,3类似，将right和left对调即可</span><br><span class="line">T.root.color = BLACK //保证性质2</span><br></pre></td></tr></table></figure>
<p>c++代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RBTree::InsertFixUp</span><span class="params">(RBTreeNode* node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (node-&gt;parent-&gt;color == RED)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (node-&gt;parent == node-&gt;parent-&gt;parent-&gt;left)<span class="comment">//The first three cases</span></span><br><span class="line">		&#123;</span><br><span class="line">			RBTreeNode* uncle = node-&gt;parent-&gt;parent-&gt;right;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (uncle-&gt;color == RED) <span class="comment">//Case 1</span></span><br><span class="line">			&#123;</span><br><span class="line">				node-&gt;parent-&gt;color = BLACK;</span><br><span class="line">				uncle-&gt;color = BLACK;</span><br><span class="line">				node-&gt;parent-&gt;parent-&gt;color = RED;</span><br><span class="line">				node = node-&gt;parent-&gt;parent;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (node == node-&gt;parent-&gt;right) <span class="comment">//Case 2</span></span><br><span class="line">				&#123;</span><br><span class="line">					node = node-&gt;parent;</span><br><span class="line">					<span class="built_in">LeftRotate</span>(node);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">//Case3</span></span><br><span class="line">				node-&gt;parent-&gt;color = BLACK;</span><br><span class="line">				node-&gt;parent-&gt;parent-&gt;color = RED;</span><br><span class="line">				<span class="built_in">RightRotate</span>(node-&gt;parent-&gt;parent);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//The remainging three cases, as the symmetry of the first three</span></span><br><span class="line"></span><br><span class="line">			RBTreeNode* uncle = node-&gt;parent-&gt;parent-&gt;left;</span><br><span class="line">			<span class="keyword">if</span> (uncle-&gt;color == RED)</span><br><span class="line">			&#123;</span><br><span class="line">				node-&gt;parent-&gt;color = BLACK;</span><br><span class="line">				uncle-&gt;color = BLACK;</span><br><span class="line">				node-&gt;parent-&gt;parent-&gt;color = RED;</span><br><span class="line">				node = node-&gt;parent-&gt;parent;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (node == node-&gt;parent-&gt;left)</span><br><span class="line">				&#123;</span><br><span class="line">					node = node-&gt;parent;</span><br><span class="line">					<span class="built_in">RightRotate</span>(node);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				node-&gt;parent-&gt;color = BLACK;</span><br><span class="line">				node-&gt;parent-&gt;parent-&gt;color = RED;</span><br><span class="line">				<span class="built_in">LeftRotate</span>(node-&gt;parent-&gt;parent);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	rootNode-&gt;color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为<code>RB-INSERT</code>操作是一层层的向下搜索可以插入的点，所以复杂度与树的高度有关，即为$O(\lg n)$，<code>RB-INSERT-FIXUP</code>操作只有在情况1的情况下会继续循环，且每次循环前都将$z$向上移两位，因此执行次数是层数的一半，时间复杂度也为$O(\lg n)$。综上，红黑树插入操作总体的时间复杂度为$O(\lg n)$。</p>
<h2 id="Deletion"><a href="#Deletion" class="headerlink" title="Deletion"></a>Deletion</h2><p>如二叉搜索树一样，红黑树的删除操作同样需要<code>Transplant</code>操作来用一个结点替换另一个，这里与二叉搜索树不同的只是将<code>Null</code>变为了<code>T.nil</code>，以及在设置$v.p$时不需要额外的判断，因为即使$v$是哨兵，访问$v.p$也不会出错</p>
<p>伪代码如下<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RB-TRANSPLANT(T,u,v)</span><br><span class="line">if u.p == T.nil</span><br><span class="line">	T.root = v</span><br><span class="line">else if u == u.p.left</span><br><span class="line">	u.p.left = v</span><br><span class="line">else</span><br><span class="line">	u.p.right = v</span><br><span class="line">v.p=u.p</span><br></pre></td></tr></table></figure></p>
<p>c++代码实现如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RBTree::TransPlant</span><span class="params">(RBTreeNode* originNode, RBTreeNode* newNode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (originNode-&gt;parent == nullNode)</span><br><span class="line">	&#123;</span><br><span class="line">		rootNode = newNode;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (originNode == originNode-&gt;parent-&gt;left)</span><br><span class="line">	&#123;</span><br><span class="line">		originNode-&gt;parent-&gt;left = newNode;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		originNode-&gt;parent-&gt;right = newNode;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	newNode-&gt;parent = originNode-&gt;parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在二叉搜索树的删除操作中，最复杂的情况，即被删除节点$z$有两个子树，且他的<code>successor</code>不是$z$的右子树。</p>
<p>这时候需要执行的操作是，将$successor.right$替换$successnor$的位置，再用$successor$替换$z$的位置。因为整个操作牵扯到三个节点$succcessor.right,successor,z$的变化，所以在红黑树的操作下，这三个结点都需要被确认是否会造成红黑树性质的破坏。</p>
<p>在删除算法中，将需要移进或者移出原先$z$位置的结点命名为$y$，需要记录$y$结点的位置，因为如果他是黑色的，那么他的移动会破坏红黑树的性质5。需要替代$y$位置的点用$x$表示。</p>
<p>删除操作的伪代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">y = z //这里y表示要移除z位置的结点，即z自己</span><br><span class="line">y-original-code = y.color</span><br><span class="line">if z.left == T.nil</span><br><span class="line">	x = z.right</span><br><span class="line">	RB-TRANSPLANT(T,y,x) //用z的右树替代z，即用x替代z，即用x替代y</span><br><span class="line">else if z.right = T.nil</span><br><span class="line">	x = z.left</span><br><span class="line">	RB-TRANSPLANT(T,y,x) //用z的左树替代z，即用x替代z，即用x替代y</span><br><span class="line">else</span><br><span class="line">	y = TREE-MINIMUM(z.right) //y表示z.successor，这里y表示需要移进z位置的结点</span><br><span class="line">	x = y.right //如普通的搜索二叉树一样，用y的右子树替代y的位置</span><br><span class="line">	if y.p == z</span><br><span class="line">		x.p = z //在普通二叉搜索树中，y.p == z的情况不需要任何操作，这里因为设置了x，所以需要为x指定父节点</span><br><span class="line">	else</span><br><span class="line">		RB-TRANSPLANT(T,y,x) //TRANSPLANT操作同时也为x设置了父结点，即x.p = y.p</span><br><span class="line">		y.right = z.right</span><br><span class="line">		y.right.p = y</span><br><span class="line">	RB-TRANSPLANT(T,z,y)</span><br><span class="line">	y.left = z.left</span><br><span class="line">	y.left.p = y</span><br><span class="line">	y.colour = z.clour //在y移动到了z的位置后，用z的颜色表示y的颜色，这样就保证了y有原先z.p不会违背性质4</span><br><span class="line">if(y-original-color == Black)//在原先的y结点是黑色的情况下，会引发问题（后面会解释），所以需要修复</span><br><span class="line">	RB-DELETE-FIXUP(T,x)</span><br></pre></td></tr></table></figure>
<p>在伪代码的最后，仅在原$y$结点颜色为黑色的时候调用修复函数<code>RB_DELETE_FIXUP</code>,因为$y$结点如果原先为红色，则不会违反任何的红黑树性质</p>
<ol>
<li>因为$y$是红的，所以移动$y$不会造成树的黑高的变化，性质5也就不会被破坏</li>
<li>因为在代码的20行将$z$的颜色赋给了$y$，所以不会发生$y$与$z.p$=破坏性质4的情况。</li>
<li>$x$作为替代$y$的结点，如果$y$是红的,$x$就是黑色的，移动$x$也不会造成破坏性质4的情况</li>
<li>$y$是红色的，$y$不可能是树的根，所以根也不会发生变化，性质2也不会被破坏</li>
<li>性质1，3在操作中根本没有相关改动的地方，肯定不会被破坏</li>
</ol>
<p>而$y$结点如果是黑色的，则可能会存在以下情况</p>
<ol>
<li>如果$y$根节点，而且$y$的子结点是红色，那么破坏性质2。</li>
</ol>
<ul>
<li>这种情况只有$y$表示的是移出$z$位置的结点时($y=z$)才可能发生。否则$y$移入$z$的位置，且$y$是黑色的，不可能破坏性质2。如果$y$表示是移出$z$位置，说明$z$最多只有一个子树，这种情况下$y$的子结点即为$x$。</li>
</ul>
<ol>
<li><p>如果$x$和$x.p$都为红色，那么破坏性质4。</p>
<p> 首先分析$x$和$x.p$的可能取值。</p>
<p> （1） $x$可能是$y.left$（在$z$只有左结点）或者$y.right$（在$z$有两种结点的情况或$z$只有右结点）。</p>
<p> （2） $x.p$在大部分情况下都为$y.p$，除了$x$在$z$有两个结点，且$y$是$z.right$的情况下，$x.p$=$y$。</p>
<p> 因为$x$和$x.p$都是红色，且$y$是黑的，所以$x.p$不能等于$y$。因此发生的情况一定是$z$有两个结点，且$y$不等于$z.right$或$y$只有右结点。即如下图所示的两种情况：</p>
<p> <img src="IA-Chapter13-Notes/2019-11-16-15-17-38.png" alt="删除z违背性质4的情况"><br> <img src="IA-Chapter13-Notes/2019-11-16-17-09-19.png" alt="删除z违背性质4的情况2"></p>
</li>
<li><p>任意包含了$y$的路径都会出现黑高减一的情况，违背性质5</p>
<p> (1) 在$y$表示移出$z$位置的结点的情况下(即 $y$ = $z$ )，因为$z$和$y$都是黑色，所以删除$z$结点必然会出现黑高减一</p>
<p> (2) 在$y$表示移入$z$位置的结点的情况下(即 $y$ = $z.successor$ )，仍然会出现黑高减一。如果$z$是黑色的，那么同样是$y$和$z$都是黑色，删除$z$结点出现黑高减一。如果$z$是红色的，删除$z$不会造成黑高减一，但是因为在算法的最后为了保证新移入的$y$不会与树的上层发生冲突，所以将$y$设为了原先$z$的颜色，即将$y$变为了黑色，因此同样黑高减一。</p>
</li>
</ol>
<p>在这里为了解决包含$y$的路径出现的黑高减一现象，将额外的一个黑色给予$x$结点，因为包含有$y$的路径一定包含$x$（因为$x$=$y$或者$y.right$）。因为修复了黑高减一的问题，性质5满足了，但因为$x$现在是拥有两个黑色，或者是一黑一红，因此违背了性质1，即所有结点要么是红色，要么是黑色。</p>
<ul>
<li>这里给$x$一个额外黑的操作并没有在代码中体现，只是一个思路。因此$x$的颜色在代码中判断，依然按$x$之前的颜色判断。</li>
</ul>
<p>因此RB-DELETE-FIXUP一共需要解决三个性质的问题即，性质1，2，4。且性质1是针对$x$结点，所以传递的参数为$x$结点。</p>
<p>RB-DELETE-FIXUP的伪代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while x != T.root and x.color == BLACK</span><br><span class="line">	if x == x.p.left</span><br><span class="line">		w = x.p.right</span><br><span class="line">		if w.color == RED // 情况1</span><br><span class="line">			w. color = BLACK</span><br><span class="line">			x.p.color = RED</span><br><span class="line">			LEFT-ROTATE(T,x.p)</span><br><span class="line">			w = x.p.right // 新的w，因为新的w必然是黑色，所以情况1转换为1情况2/3/4</span><br><span class="line">		if w.left.color == BLACK and w.right.color == BLACK</span><br><span class="line">			w.color = RED</span><br><span class="line">			x = x.p</span><br><span class="line">		else</span><br><span class="line">			if w.right.color == BLACK</span><br><span class="line">				w.left.color = BLACK</span><br><span class="line">				w.color = RED</span><br><span class="line">				RIGHT-ROTATE(T,w)</span><br><span class="line">				w = x.p.right</span><br><span class="line">			w.color = x.p.color</span><br><span class="line">			x.p.color = BLACK</span><br><span class="line">			w.right.color = BLACK</span><br><span class="line">			LEFT-ROTATE(T,x.p)</span><br><span class="line">			x = T.root</span><br><span class="line">	else</span><br><span class="line">		....</span><br><span class="line">		//和情况1,2,3,4类似，将right和left对调即可</span><br><span class="line">x.color = BLACK</span><br></pre></td></tr></table></figure>
<p>这里的删除修复如同插入修复一样，有很多种情况，这里一共是8种情况。但是可以分为前四种和后四种，分割标准是$x$是$x.p$的左结点，还是右结点。这里我们只讨论$x$是左结点的情况，即前四种。后四种为前四种的对称，如同插入修复的对称一样,解法只要将前四种中的$left$改为$right$，反之亦然。</p>
<p>整个算法是一个循环和一个将x.color设为Black的语句。退出循环的条件是$x$是红色（实际上$x$有红-黑两个颜色属性）或$x$是根。</p>
<p>在这种情况下将$x$设为单一黑色（即x.color = Black）可以<strong>修复性质1</strong>，且不会破坏性质5，因为</p>
<pre><code>(1) 如果$x$是根，那么删除一个黑色，是整棵树的黑高都减一，依然满足性质5

(2) 如果$x$是红-黑，即贡献了一个黑高，设为黑色后，依然是贡献一个黑高，满足性质5
</code></pre><p>将$x.color$设为黑色，因为$x$和$x.p$都为红色而造成的<strong>性质4的破坏也会被修复</strong>。</p>
<p>而且如上讨论，违背性质2的情况，必然是$z$最多只有一颗子树，即$y=z$，$x$作为$y$的子结点且为红色的情况，那么将$x$设为黑色，同样<strong>修复了性质2</strong>。这种情况下$x$就是根结点，并不会进入循环，将直接执行最后一句。</p>
<p>因此退出循环后的<code>x.color = BLACK</code>语句将同时修复性质1,2,4。现在需要关心的是该如何退出循环。</p>
<p>现在先分析前四种情况。这四种情况的分类是根据$x$的兄弟$w$（在$x$=$x.p.left$的情况下$w$即为$x.p.right$）。</p>
<ul>
<li>因为进入循环是$x$是两个黑色属性，所以$w$必然存在且一定有两个子结点。不然通过$x$抵达叶子的黑高一定大于到达$w$的黑高。$w$的子结点也必然有两个子结点，因为只有$w$与$w.left$或$w.right$都为黑色，才能刚好与$x$的两个黑色相抵。如果其中一个为红色，那么则需要更深的树才能抵消。</li>
</ul>
<ol>
<li>$w$是红色为情况1。</li>
</ol>
<p>如果$w$是黑色的，再细分为三个情况</p>
<ol>
<li><p>$w$是黑色，且右结点是黑色，左结点是黑色为情况2</p>
</li>
<li><p>$w$是黑色，且右结点是黑色，左结点是红色，为情况3</p>
</li>
<li><p>$w$是黑色，且右结点是红色，左结点是红色或黑色，为情况4</p>
</li>
</ol>
<p>对于情况1的修复：</p>
<p>因为$w$是红色，所以$w.p$即$w.p$必然是黑色的。将$w.p$与$w$的颜色对调，且对$w.p$进行左旋，如下图所示，不会违背任何的红黑树性质。</p>
<p><img src="IA-Chapter13-Notes/2019-11-16-16-28-06.png" alt="情况1修复"></p>
<ul>
<li>上图以及之后其他的对于各种情况的修复图中，黑色结点表示黑色，深灰色结点，如上图中的$D$表示红色，浅灰色结点表示可能是黑可能是红。</li>
</ul>
<p>同样因为$w$是红色的，$w$的两个子结点也必然是黑色的，在上述的操作后，原$w$的左结点将会成为$x$的新兄弟，即成为新的$w$，为黑色。</p>
<p>如之前所述，$w$也必然有两个子结点，根据子结点的情况，情况1会变为情况2或3或4。</p>
<p>对于情况2的修复：</p>
<p>在情况2下，因为$x$是双重黑色，$w$是黑色，所以从他们两个结点中都取出一个黑色，即$x$变为单个黑色，$w$变为红色。将这个取出的黑色给予$x.p$。</p>
<p>这个操作只有在$w$的两个结点都是黑色的情况下（即情况2）才能执行，不然当$w$变为红色，将会与它的子结点违背性质4。</p>
<p>因为$x$和$w$都为黑色，所以$x.p$的颜色并不能确定（下图中由浅灰色表示），增加了额外黑色后，可能为黑-黑也可能为红-黑。</p>
<ul>
<li>从$x$和$w$中都取出一个黑色，相当于将$x.p$的两个子树的黑高都减一，而此时将黑色给予$x.p$相当于将将失去的黑高补了回来。</li>
</ul>
<p>此时$x.p$成为了破坏性质1的结点，因此将他设为新的$x$并再次进入循环。</p>
<ul>
<li>如果是由情况1转换为的情况2，那么再次进入循环后，将不满足循环条件直接退出循环。因为在情况1修复后$x.p$为红色，在情况2修复后被给予了额外的黑色后，变为红-黑，不满足循环条件，因此退出。</li>
</ul>
<p><img src="IA-Chapter13-Notes/2019-11-16-17-31-28.png" alt="情况2的修复"></p>
<p>对于情况3的修复：</p>
<p>情况3通过降$w$（黑色）与$w.left$（红色）的颜色对换，并对$w$执行右旋，再将原$w.left$设为新$w$转换为情况4。如下图所示。</p>
<p><img src="IA-Chapter13-Notes/2019-11-16-17-39-14.png" alt="情况3的修复"></p>
<p>对于情况4的修复：</p>
<p>在情况4中，先将$w$与$w.p$的颜色互换，然后对$w.p$进行左旋，$w$取代原先$w.p$的位置。如下图所示</p>
<p><img src="IA-Chapter13-Notes/2019-11-16-18-16-43.png" alt="情况4修复1"></p>
<p>分析三个结点$A$,$C$和$E$的黑高，发现$A$的黑高多了1，$C$的黑高不变，$E$的黑高少了1。因此我们将$A$的一个黑高给$E$，这样三个结点的黑高都不变。$A$结点即为$x$，原先有两个黑色，现在减去一个变成单独的黑色结点，满足性质1。$E$原先为红色，现在多了一个黑色，变为黑色结点。</p>
<p>因此情况4的最终修复效果如下</p>
<p><img src="IA-Chapter13-Notes/2019-11-16-18-20-17.png" alt="情况4修复2"></p>
<p>在这个情况下，所有的结点都满足了性质1。所以将$x$直接指向$T.root$来退出循环即可。</p>
<ul>
<li>之所以情况2无法直接退出循环，是因为在情况2的修复后，原$x.p$仍然破坏了性质1，所以需要进入循环继续修复。</li>
</ul>
<p>后四种情况的修复与前四种对称，这里不在赘述。</p>
<p><code>RB-DELETE</code>操作本身没有循环，所以时间复杂度由<code>TREE-MINIMUM</code>和<code>RB-DELETE-FIXUP</code>共同决定。</p>
<p>如同普通二叉搜索树，<code>TREE-MINIMUM</code>时间复杂度为$O(\lg n )$。</p>
<p>而<code>RB-DELETE-FIXUP</code>，只有情况2会再次进入循环，剩下的三种情况都是转换为其他情况或者在下一次直接退出循环。而情况2每次都会将$x$上移，所以在最坏情况下时间复杂度也为$O(\lg n)$。</p>
<p>综上<code>RB-DELETE</code>的时间复杂度为$O(\lg n ) + O(\lg n)$，即$O(\lg n)$。</p>
<p><code>RB-DELETE</code>与<code>RB-DELETE-FIXUP</code>的c++代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">RBTree::Delete</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	RBTreeNode* toDelete = <span class="built_in">Search</span>(value);</span><br><span class="line">	<span class="keyword">if</span> (toDelete == nullNode)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	RBTreeNode* toDeleteTrack = toDelete;<span class="comment">//this track will be removed from the tree</span></span><br><span class="line">	NodeColor originDeleteTrackColor = toDeleteTrack-&gt;color;</span><br><span class="line"></span><br><span class="line">	RBTreeNode* toReplaceTrack;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (toDelete-&gt;left == nullNode)</span><br><span class="line">	&#123;</span><br><span class="line">		toReplaceTrack = toDelete-&gt;right;</span><br><span class="line">		<span class="built_in">TransPlant</span>(toDelete, toReplaceTrack);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (toDelete-&gt;right == nullNode)</span><br><span class="line">	&#123;</span><br><span class="line">		toReplaceTrack = toDelete-&gt;left;</span><br><span class="line">		<span class="built_in">TransPlant</span>(toDelete, toReplaceTrack);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="comment">//Both children are not nullNode</span></span><br><span class="line">	&#123;</span><br><span class="line">		toDeleteTrack = <span class="built_in">GetMinimum</span>(toDelete-&gt;right);<span class="comment">//The track is Successor</span></span><br><span class="line">		<span class="comment">//This track will moved in toDelete&#x27;s postion</span></span><br><span class="line">		originDeleteTrackColor = toDeleteTrack-&gt;color;</span><br><span class="line"></span><br><span class="line">		toReplaceTrack = toDeleteTrack-&gt;right;</span><br><span class="line">		<span class="keyword">if</span> (toDeleteTrack-&gt;parent == toDelete)<span class="comment">//Track is toDelete&#x27;s rightChild</span></span><br><span class="line">		&#123;</span><br><span class="line">			toReplaceTrack-&gt;parent = toDeleteTrack;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">TransPlant</span>(toDeleteTrack, toReplaceTrack);</span><br><span class="line">			toDeleteTrack-&gt;right = toDelete-&gt;right;</span><br><span class="line">			toDeleteTrack-&gt;right-&gt;parent = toDeleteTrack;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">TransPlant</span>(toDelete, toDeleteTrack);</span><br><span class="line">		toDeleteTrack-&gt;left = toDelete-&gt;left;</span><br><span class="line">		toDeleteTrack-&gt;left-&gt;parent = toDeleteTrack;</span><br><span class="line">		toDeleteTrack-&gt;color = toDelete-&gt;color;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//set the pointer be null to ensure children and parent won&#x27;t be released</span></span><br><span class="line">		toDelete-&gt;parent = <span class="literal">nullptr</span>;</span><br><span class="line">		toDelete-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">		toDelete-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">		<span class="keyword">delete</span> toDelete;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (originDeleteTrackColor == BLACK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">DeleteFixUp</span>(toReplaceTrack);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RBTree::DeleteFixUp</span><span class="params">(RBTreeNode* toReplaceTrack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (toReplaceTrack != rootNode &amp;&amp; toReplaceTrack-&gt;color == BLACK)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (toReplaceTrack == toReplaceTrack-&gt;parent-&gt;left) <span class="comment">//The first four cases</span></span><br><span class="line">		&#123;</span><br><span class="line">			RBTreeNode* uncle = toReplaceTrack-&gt;parent-&gt;right;</span><br><span class="line">			<span class="keyword">if</span> (uncle-&gt;color == RED)   <span class="comment">//case1</span></span><br><span class="line">			&#123;</span><br><span class="line">				uncle-&gt;color = BLACK;</span><br><span class="line">				toReplaceTrack-&gt;parent-&gt;color = RED;</span><br><span class="line">				<span class="built_in">LeftRotate</span>(toReplaceTrack-&gt;parent);</span><br><span class="line">				uncle = toReplaceTrack-&gt;parent-&gt;right;   <span class="comment">//to case 2/3/4</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (uncle-&gt;left-&gt;color == BLACK &amp;&amp; uncle-&gt;right-&gt;color == BLACK)</span><br><span class="line">			&#123;</span><br><span class="line">				uncle-&gt;color = RED;    <span class="comment">//case2</span></span><br><span class="line">				toReplaceTrack = toReplaceTrack-&gt;parent;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (uncle-&gt;right-&gt;color == BLACK)</span><br><span class="line">				&#123;</span><br><span class="line">					uncle-&gt;left-&gt;color = BLACK;</span><br><span class="line">					uncle-&gt;color = RED;</span><br><span class="line">					<span class="built_in">RightRotate</span>(uncle);   <span class="comment">// to case4</span></span><br><span class="line">					uncle = toReplaceTrack-&gt;parent-&gt;right;</span><br><span class="line">				&#125;</span><br><span class="line">				uncle-&gt;color = toReplaceTrack-&gt;parent-&gt;color;</span><br><span class="line">				toReplaceTrack-&gt;parent-&gt;color = BLACK;          <span class="comment">//case4;</span></span><br><span class="line">				uncle-&gt;right-&gt;color = BLACK;</span><br><span class="line">				<span class="built_in">RightRotate</span>(toReplaceTrack-&gt;parent);</span><br><span class="line">				toReplaceTrack = rootNode;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span><span class="comment">//The remaining four cases,as the symetry of the first four</span></span><br><span class="line">		&#123;</span><br><span class="line">			RBTreeNode* uncle = toReplaceTrack-&gt;parent-&gt;left;</span><br><span class="line">			<span class="keyword">if</span> (uncle-&gt;color == RED)</span><br><span class="line">			&#123;</span><br><span class="line">				uncle-&gt;color = BLACK;</span><br><span class="line">				toReplaceTrack-&gt;parent-&gt;color = RED;</span><br><span class="line">				<span class="built_in">RightRotate</span>(toReplaceTrack-&gt;parent);</span><br><span class="line">				uncle = toReplaceTrack-&gt;parent-&gt;left;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (uncle-&gt;right-&gt;color == BLACK &amp;&amp; uncle-&gt;left-&gt;color == BLACK)</span><br><span class="line">			&#123;</span><br><span class="line">				uncle-&gt;color = RED;</span><br><span class="line">				toReplaceTrack = toReplaceTrack-&gt;parent;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (uncle-&gt;left-&gt;color == BLACK)</span><br><span class="line">				&#123;</span><br><span class="line">					uncle-&gt;right-&gt;color = BLACK;</span><br><span class="line">					uncle-&gt;color = RED;</span><br><span class="line">					<span class="built_in">LeftRotate</span>(uncle);</span><br><span class="line">					uncle = toReplaceTrack-&gt;parent-&gt;left;</span><br><span class="line">				&#125;</span><br><span class="line">				uncle-&gt;color = toReplaceTrack-&gt;parent-&gt;color;</span><br><span class="line">				toReplaceTrack-&gt;parent-&gt;color = BLACK;</span><br><span class="line">				uncle-&gt;left-&gt;color = BLACK;</span><br><span class="line">				<span class="built_in">RightRotate</span>(toReplaceTrack-&gt;parent);</span><br><span class="line">				toReplaceTrack = rootNode;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	toReplaceTrack-&gt;color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note info simple"><p>引用：</p>
<ol>
<li><em>Introduction to Algorithms</em> 3rd Sep.2009</li>
</ol>
</div>
<hr>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>《算法导论》 第十五章笔记</title>
    <url>/IA-Chapter15-Notes/</url>
    <content><![CDATA[<p>《算法导论》 第十五章笔记，介绍动态规划的概念及一些运用了动态规划的算法。</p>
<p>15.4及15.5节尚未整理</p>
<span id="more"></span>
<h1 id="Chapter-15-Dynamic-Programming"><a href="#Chapter-15-Dynamic-Programming" class="headerlink" title="Chapter 15. Dynamic Programming"></a>Chapter 15. Dynamic Programming</h1><p>动态规划(Dynamic Programming)如分治法(divide-and-conquer method)一样都是通过组合子问题的解答来解决问题。两者的区别在于：</p>
<ol>
<li>分治法的子问题是互相独立的，不存在重叠</li>
<li>动态规划的子问题是相互重叠的，不同的子问题可能存在重叠子问题。若对于每个子问题都求解一次，则会出现重复计算</li>
</ol>
<p>动态规划常被用来解决最优问题（optimization problems），这种问题通常有许多可能的解答，动态规划的目标是求得一个最优解（通常是众多解答中的最大值或最小值）。</p>
<p>动态规划的步骤如下：</p>
<ol>
<li>找到最优解的结构</li>
<li>递归定义最优解的值</li>
<li>计算出最优解的值，通常是通过一个自下而上的递归方式解决</li>
<li>使用计算得出的数据构建出最优解</li>
</ol>
<p>步骤1-3是动态规划解决问题的基础，如果只需要求得最优解的值而非最优解本身，可以忽略步骤4。</p>
<h2 id="Rod-cutting"><a href="#Rod-cutting" class="headerlink" title="Rod cutting"></a>Rod cutting</h2><p>钢条切割问题(Rod cutting)是假设存在一个钢条，切割成不同长度可以卖不同的钱，设切割出的长度为$i$，对应这一段长度的卖价为$P_i$。假设钢条长度从1-10的卖价如下</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>长度</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
</tr>
</thead>
<tbody>
<tr>
<td>价格</td>
<td>1</td>
<td>5</td>
<td>8</td>
<td>9</td>
<td>10</td>
<td>17</td>
<td>17</td>
<td>20</td>
<td>24</td>
<td>30</td>
</tr>
</tbody>
</table>
</div>
<p>一段长度为$i$的钢条，一共有$2^{n-1}$个切割方法。因为将长度为$i$的钢条看作是有$i$个长度为1的结点进行分类，一共有$n-1$个连接点，每个连接点都可以选择切或者不切，所以有$2^{n-1}$个可能。</p>
<ul>
<li>如有3个结点，1-2的切分和2-1的切分看作是两种可能。</li>
</ul>
<p>设一段钢条在卖价最大化的情况下要切分成$k$块，则总长度为$n$的钢条可以表示为 $n=i<em>1+i_2+…+i_k$，最大化的总价为为$r_n$，可表示为$r_n=p</em>{i<em>1}+p</em>{i<em>2}+…+p</em>{i_k}$</p>
<p>对于上面假设的卖价，对应钢条的长度从1-10，各自的最佳卖价和切割方法如下</p>
<ul>
<li>如切割方式$2+2$表示写成两半，一块为长度为2，另一块也为2.如果切割方式与总长度相同，如都为3,则表示不切割即为最佳切割方式。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>钢条总长度</th>
<th>最大化卖价</th>
<th>最佳切割方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>5</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>8</td>
<td>3</td>
</tr>
<tr>
<td>4</td>
<td>10</td>
<td>2+2</td>
</tr>
<tr>
<td>5</td>
<td>13</td>
<td>2+3</td>
<td>p</td>
</tr>
<tr>
<td>6</td>
<td>17</td>
<td>6</td>
</tr>
<tr>
<td>7</td>
<td>18</td>
<td>1+6 / 2+2+3</td>
</tr>
<tr>
<td>8</td>
<td>22</td>
<td>2+6</td>
</tr>
<tr>
<td>9</td>
<td>25</td>
<td>3+6</td>
</tr>
<tr>
<td>10</td>
<td>30</td>
<td>10</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>表格中的最佳切割方式是钢条切割问题的最佳解，而最大化卖价是最佳切割方式的数值。</li>
</ul>
<p>可以把求得$r_n$，即整个钢条的最大化过程看作先切割一刀，这时候钢条变成了两部分，左部分就不再动了，对右部分继续切割，找到右部分的最佳切割方式，即对右部分求最佳解。数学可表示为</p>
<script type="math/tex; mode=display">
r_n= \max_{1\leq i \leq n}(p_i + r_{n-i})</script><p>这就是钢条切割问题的最佳解结构：整个问题的最佳解是与子问题的最佳解相关的。如上式中，最佳解的值是依赖于子问题的最佳解的值得到的。</p>
<h3 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h3><p>递归解法的伪代码如下，这个方法就是对式子$r<em>n=\max</em>{1\leq i \leq n}(p<em>i + r</em>{n-i})$的实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CUT-ROD(p,n)</span><br><span class="line">if n == 0</span><br><span class="line">    return 0</span><br><span class="line"></span><br><span class="line">q = -MAX</span><br><span class="line">for i = 1 to n</span><br><span class="line">    q = max (q, p[i] + CUT-ROD(p,n-i))</span><br><span class="line">return q</span><br></pre></td></tr></table></figure>
<p>但这个运算是非常低效的，因为它存在许多的重复计算，如对于$n=4$，算法会在循环中分别以$n=0,n=1,n=2,n=3$调用CUT-ROD算法，而在以$n=3$调用时又会在循环中以$n=0,n=1,n=2$调用，这就造成了重复运算。调用时的计算如下图</p>
<p><img src="IA-Chapter15-Notes/2020-01-20-02-17-36.png" alt="递归解法图解"></p>
<p>图中的每个结点表示一次调用，结点中的数值表示$n$的取值，可以看到有非常多重复的结点。</p>
<p>设$T(n)$为该算法的执行时间，可以表示为</p>
<script type="math/tex; mode=display">
T(n)= 1 + \sum _{i=1}^{n} T(n-i)</script><p>可取$j=n-1$，将式子转换为</p>
<script type="math/tex; mode=display">
T(n)= 1 + \sum _{j=0}^{n-1} T(j)</script><p>可通过数学归纳法证明该式子的时间复杂度为$T(n)=2^n$，是一个指数型增长的式子，所以该算法的效率十分低下。</p>
<p>$T(n)=1 + \sum _{j=0}^{n-1} T(j)=2^n$的证明如下：</p>
<ol>
<li>当n=0时$T(0)=2^0=1$，满足式子，得证</li>
<li><p>当n&gt;0时</p>
<script type="math/tex; mode=display">
T(n)=1+\sum _{j=0}^{n-1} 2^{j} \\\\
=1 + 2^0 \cdot \frac{1-2^{n}}{1-2} \\\\
= 1 + (2^n -1) \\\\
= 2^n</script><p> 满足原式子，得证。</p>
</li>
</ol>
<p>递归解法的c++实现如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">CutRod</span><span class="params">(<span class="type">int</span>* priceTable, <span class="type">int</span> rodLength)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (rodLength == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> price = INT_MIN;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= rodLength; i++) <span class="comment">//cut from 1 to length(equals to no cuts)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> tempPrice = priceTable[i] + <span class="built_in">CutRod</span>(priceTable, rodLength - i);</span><br><span class="line">		<span class="keyword">if</span> (tempPrice &gt; price)</span><br><span class="line">			price = tempPrice;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="using-dynamic-programming-for-optimal-rod-cutting"><a href="#using-dynamic-programming-for-optimal-rod-cutting" class="headerlink" title="using dynamic programming for optimal rod cutting"></a>using dynamic programming for optimal rod cutting</h3><p>在上一节的递归算法中，因为大量重复的计算导致了算法的低效。在动态规划的解法中，实际上是通过将计算过的子问题的解存储下来，之后再次遇到直接返回结果即可，所以动态规划本质上是一个空间与时间的权衡(time-memory trade-off)。</p>
<p>通过动态规划，基本可以将一个时间复杂度为指数型的算法（如$2^n$）转换为一个多项式型的算法（如$n^2$）</p>
<p>动态规划一般有两种解法，一种是<code>自顶向下备忘录法（top-down with memoization）</code>，一种是<code>自底而上法(bottom-up method)</code>。下面会以钢铁切割问题分别说明两种方法：</p>
<ol>
<li><p>自顶向下备忘录法</p>
<p> 这种方法与之前的递归法结构几乎相同，也是严格按照动态规划解法的定义，即将运算过的子问题答案记录下来。切割钢条问题使用自顶向下的备忘录法伪代码如下：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MEMOIZED-CUT-ROD(p,n):</span><br><span class="line"></span><br><span class="line">r = new array[n+1]</span><br><span class="line">for i =0 to n</span><br><span class="line">    r[i] = -MAX</span><br><span class="line">return MEMOIZED-CUT-ROD-AUX(p,r,n)</span><br><span class="line"></span><br><span class="line">MEMOIZED-CUT-ROD-AUX(p,r,n):</span><br><span class="line"></span><br><span class="line">if r[n] &gt; 0 //means there are record for this subproblem</span><br><span class="line">    return r[n]</span><br><span class="line">if n == 0</span><br><span class="line">    q = 0</span><br><span class="line">else</span><br><span class="line">    q = -MAX</span><br><span class="line">    for i = 1 to n</span><br><span class="line">    q = max (q, p[i] + MEMOIZED-CUT-ROD-AUX(p,r,n-i))</span><br><span class="line">r[n] = q</span><br><span class="line">return q</span><br></pre></td></tr></table></figure>
<p> <code>MEMOIZED-CUT-ROD</code>主要功能是初始化一个数组$r$，这个数组存储了所有计算过的子问题的答案，<code>MEMOIZED-CUT-ROD-AUX</code>实际对应之前的递归算法<code>CUTROD</code>，不同点只是当发现答案记录过就直接返回。</p>
<p> c++ 代码如下:</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MemoizedCutRod</span><span class="params">(<span class="type">int</span>* priceTable, <span class="type">int</span> rodLength)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//create an array from 0 to rodLength, array length is (rodLength+1)</span></span><br><span class="line">    <span class="comment">//array[0] = 0, array[rodLength] means the max PriceMemo for rod of rodLength</span></span><br><span class="line">    <span class="type">int</span>* maxPriceMemo = <span class="keyword">new</span> <span class="type">int</span>[rodLength + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rodLength + <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        maxPriceMemo[i] = INT_MIN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> maxPrice = <span class="built_in">MemoizedCutRodAux</span>(priceTable, maxPriceMemo, rodLength);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//for (int i = 1; i &lt; rodLength + 1; i++)</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//    cout &lt;&lt; &quot;Max price for &quot; &lt;&lt; i &lt;&lt; &quot; is &quot; &lt;&lt; maxPriceMemo[i] &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="keyword">return</span> maxPrice;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MemoizedCutRodAux</span><span class="params">(<span class="type">int</span>* priceTable, <span class="type">int</span>* maxPriceMemo, <span class="type">int</span> rodLength)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (maxPriceMemo[rodLength] &gt; <span class="number">0</span>)<span class="comment">//has record</span></span><br><span class="line">        <span class="keyword">return</span> maxPriceMemo[rodLength];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> price = INT_MIN;</span><br><span class="line">    <span class="keyword">if</span> (rodLength == <span class="number">0</span>)</span><br><span class="line">        price = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= rodLength; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> tempPrice = priceTable[i] + <span class="built_in">MemoizedCutRodAux</span>(priceTable, maxPriceMemo, rodLength - i);</span><br><span class="line">            <span class="keyword">if</span> (tempPrice &gt; price)</span><br><span class="line">                price = tempPrice;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    maxPriceMemo[rodLength] = price;</span><br><span class="line">    <span class="keyword">return</span> price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <code>priceTable</code>表示不同长度的钢条的价格数组，初始化定义为：</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> priceTable[] = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">17</span>,<span class="number">17</span>,<span class="number">20</span>,<span class="number">24</span>,<span class="number">30</span> &#125;;</span><br></pre></td></tr></table></figure>
<p> 注意这里的数组长度都为$rodLength+1$，这是为了将长度与Index对齐，如长度为1的钢板的最大售价，则使用$maxPriceMemo[1]$即可。</p>
</li>
<li><p>自底而上法</p>
<p> 自底而上法形式上更为简单，但它利用了动态规划的一个特性：较大的子问题包含较小的子问题。</p>
<p> 因此如果从最小的子问题开始解决，那么在解决后面更大的子问题时，它所依赖的所有小子问题都已经有了解答，也就不需要像自顶向下备忘法那样去检查是否子问题已经有了答案。</p>
<p> 所以如果要求长度为$n$的钢条的最大售价，只要从长度为1开始求起，依次求到长度为$n$</p>
<p> 伪代码如下：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BOTTOM-UP-CUT-ROD(p,n)</span><br><span class="line"></span><br><span class="line">r = new array[n+1]</span><br><span class="line">for i =0 to n</span><br><span class="line">    r[i] = -MAX</span><br><span class="line">r[0] = 0</span><br><span class="line"></span><br><span class="line">for i = 1 to n</span><br><span class="line">    q = -MAX</span><br><span class="line">    for j = 1 to i</span><br><span class="line">        q = MAX(q , p[j] + r[i-j])</span><br><span class="line">    r[i]=q</span><br><span class="line"></span><br><span class="line">return r[n]</span><br></pre></td></tr></table></figure>
<p> c++代码如下：</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">BottomUpCutRod</span><span class="params">(<span class="type">int</span>* priceTable, <span class="type">int</span> rodLength)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//Init for maxPriceMemo</span></span><br><span class="line">    <span class="type">int</span>* maxPriceMemo = <span class="keyword">new</span> <span class="type">int</span>[rodLength + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rodLength + <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        maxPriceMemo[i] = INT_MIN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    maxPriceMemo[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Calculate the MaxPriceMemo for length from 1 to length</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= rodLength; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Calculate cutRod for length = i</span></span><br><span class="line">        <span class="type">int</span> price = INT_MIN;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> tempPrice = priceTable[j] + maxPriceMemo[i - j];</span><br><span class="line">            <span class="keyword">if</span> (tempPrice &gt; price)</span><br><span class="line">                price = tempPrice;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        maxPriceMemo[i] = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; rodLength + <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Max price for &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; maxPriceMemo[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxPriceMemo[rodLength];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>两个方法的时间复杂度实际上都是$\Theta(n^2)$。<code>BOTTOM-UP-CUT-ROD</code>中因为有个双重循环，所以时间复杂度为$\Theta(n^2)$，<code>MemoizedCutRod</code>中虽然只有一个循环，但在每次的循环中，可能会递归调用并需要解决子问题，子问题并不会重复调用，因此一共解决$n$个子问题，循环加上解决子问题的时间可得到时间复杂度同样为$\Theta(n^2)$。</p>
<p>虽然两个方法的时间复杂度都是$\Theta(n^2)$，但是<code>BOTTOM-UP-CUT-ROD</code>在实际使用中因为减少了函数的递归调用时间，所以更为高效。</p>
<h3 id="Subproblem-graphs"><a href="#Subproblem-graphs" class="headerlink" title="Subproblem graphs"></a>Subproblem graphs</h3><p>子问题图（subproblem graphs）是一个有向图，每一个顶点都对应一个子问题。如果代表子问题$x$的结点指向代表子结点$y$的结点，则说明$x$问题的解依赖于$y$。</p>
<p>子问题图如下,它可以看作是表示递归解法的图的精简版，删除了所有重复的点，也表示子问题并不会被重复的计算：</p>
<p><img src="IA-Chapter15-Notes/2019-11-19-19-33-22.png" alt="子问题图"></p>
<p>子问题图可以用来获知动态规划问题的时间复杂度，因为图中的一个结点表示一个子问题，图中连接结点的边表示用来组合两个子问题答案的时间，因此用来解决整个动态规划问题的时间基本上与子问题图的顶点数+边数是呈线性关系的。</p>
<h3 id="Reconstructing-a-solution"><a href="#Reconstructing-a-solution" class="headerlink" title="Reconstructing a solution"></a>Reconstructing a solution</h3><p>上面的所有关于钢条切割问题的算法都只计算了钢条的最大售价（最佳解的值），而对于这个问题真正的解，如何切割钢条（最后钢条要切成几块，每块多长），并没有得出。所以上面的所有步骤都只完成了解动态规划问题四步骤的前三步。</p>
<p>为了得到最佳解需要对上面的步骤进行调整，调整有非常简单，在计算中再多保留一些数据即可。</p>
<p>以自底向上的<code>BOTTOM-UP-CUT-ROD</code>为例，在算法中，在算法中用了<code>p[j] + r[i-j]</code>来表示第一刀砍的长度$j$与剩下部分$i-j$。在售价最大的情况下，记录下第一刀砍的长度$j$即能获得动态规划的最佳解，因为在每一次的循环中，都将当前长度下第一刀砍的长度保存了下来，那么在剩下的长度越来越小的过程中，整个切割过程的每一刀长度都被记录了下来。</p>
<p>伪代码如下，这里的数组$s$即为记录第一刀长度的数组：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXTENDED-BOTTOM-UP-CUT-ROD(p,n)</span><br><span class="line"></span><br><span class="line">r = new array[n+1]</span><br><span class="line">s = new array[n+1]</span><br><span class="line"></span><br><span class="line">for i =0 to n</span><br><span class="line">    r[i] = -MAX</span><br><span class="line">r[0] = 0</span><br><span class="line"></span><br><span class="line">for i = 1 to n</span><br><span class="line">    q = -MAX</span><br><span class="line">    for j = 1 to i</span><br><span class="line">        q = MAX(q , p[j] + r[i-j])</span><br><span class="line">    r[i]=q</span><br><span class="line">    s[i]=j</span><br><span class="line"></span><br><span class="line">return s and s</span><br></pre></td></tr></table></figure>
<p>c++代码如下，形参中的<code>cutLength</code>即表示不同长度下第一刀要砍的距离：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ExtendedBottomUpCutRod</span><span class="params">(<span class="type">int</span>* priceTable, <span class="type">int</span> rodLength, <span class="type">int</span>* maxPriceMemo, <span class="type">int</span>* cutLength)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rodLength + <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		maxPriceMemo[i] = INT_MIN;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	maxPriceMemo[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Calculate the MaxPriceMemo for length from 1 to length</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= rodLength; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//Calculate cutRod for length = i</span></span><br><span class="line">		<span class="type">int</span> price = INT_MIN;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> tempPrice = priceTable[j] + maxPriceMemo[i - j];</span><br><span class="line">			<span class="keyword">if</span> (tempPrice &gt; price)</span><br><span class="line">			&#123;</span><br><span class="line">				price = tempPrice;</span><br><span class="line">				cutLength[i] = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		maxPriceMemo[i] = price;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//for (int i = 1; i &lt; rodLength + 1; i++)</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	//cout &lt;&lt; &quot;Max price for &quot; &lt;&lt; i &lt;&lt; &quot; is &quot; &lt;&lt; maxPriceMemo[i] &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; &quot;First cut length for &quot; &lt;&lt; i &lt;&lt; &quot; is &quot; &lt;&lt; cutLength[i] &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获得了最佳解后就可打印出对于长度为$n$的钢条，每一刀需要砍的长度，伪代码算法如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PRINT-CUT-ROD-SOLUTION(p,n)</span><br><span class="line"></span><br><span class="line">(r,s) = EXTENDED-EXTENDED-BOTTOM-UP-CUT-ROD(p,n)</span><br><span class="line">while n &gt; 0</span><br><span class="line">    print s[n]</span><br><span class="line">    n = s - n</span><br></pre></td></tr></table></figure>
<p>c++实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">CutRodSolution</span><span class="params">(<span class="type">int</span>* priceTable, <span class="type">int</span> rodLength)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>* maxPriceMemo = <span class="keyword">new</span> <span class="type">int</span>[rodLength + <span class="number">1</span>];</span><br><span class="line">	<span class="type">int</span>* cutLength = <span class="keyword">new</span> <span class="type">int</span>[rodLength + <span class="number">1</span>];</span><br><span class="line">	<span class="built_in">ExtendedBottomUpCutRod</span>(priceTable, rodLength, maxPriceMemo, cutLength);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> remainLength = rodLength;</span><br><span class="line">	<span class="keyword">while</span> (remainLength &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> length = cutLength[remainLength];</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;to Cut &quot;</span> &lt;&lt; length &lt;&lt; endl;</span><br><span class="line">		remainLength = remainLength - length;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> maxPriceMemo[rodLength];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Matrix-chain-multiplication"><a href="#Matrix-chain-multiplication" class="headerlink" title="Matrix-chain multiplication"></a>Matrix-chain multiplication</h2><p>定义有一系列的矩阵$<A_1,A_2,...,A_n>$，要计算这一些矩阵的乘积即$A_1A_2…A_n$。因为矩阵满足乘法合并律，所以可以决定哪一部分先相乘。</p>
<p>如一共有三个矩阵$<A_1,A_2,A_3>$，则$((A_1A_2)A_3)$与$(A_1(A_2A_3))$两种计算顺序最后得到的结果是相同的，但是这两种顺序花费的时间是不同的。</p>
<p>这里先给出矩阵相乘的算法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MATRIX-MULTIPLY(A,B)</span><br><span class="line"></span><br><span class="line">if A.columns != B.rows</span><br><span class="line">    error &quot;incompatible dimensions&quot;</span><br><span class="line">else</span><br><span class="line">    let C be a new A.rows X B.columns matrix</span><br><span class="line">    for i = 1 to A.rows</span><br><span class="line">        for j = 1 to B.columns</span><br><span class="line">            c[i][j] = 0 </span><br><span class="line">            for k = 1 to A.columns</span><br><span class="line">                c[i][j] = c[i][j] + a[i][k] * b[k][j]</span><br><span class="line">    return C</span><br></pre></td></tr></table></figure>
<p>c++实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Matrix* <span class="title">Matrix::multiply</span><span class="params">(Matrix* mat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> matColumn = mat-&gt;column;</span><br><span class="line">	Matrix* result = <span class="keyword">new</span> <span class="built_in">Matrix</span>(row, matColumn);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; matColumn; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			result-&gt;data[i][j] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; column; k++)</span><br><span class="line">			&#123;</span><br><span class="line">				result-&gt;data[i][j] = result-&gt;data[i][j] + data[i][k] * mat-&gt;data[k][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设两个相乘的矩阵分别为$A$和$B$，从上面的算法实现中可以看出，矩阵相乘的时间复杂度为$O(A.row\times B.column\times A.column)$。</p>
<p>在三个矩阵$<A_1,A_2,A_3>$的例子中,假设$A_1$的大小为$10\times100$，$100\times 5$，$5\times50$。</p>
<ol>
<li><p>如果计算顺序为$((A_1A_2)A_3)$，则整个计算需要进行的操作数为$10\times5\times100 +10\times50\times5=7500$。</p>
</li>
<li><p>如果计算顺序为$(A_1(A_2A_3))$，则整个计算需要进行的操作数为$100\times50\times5+10\times50\times100=75000$</p>
</li>
</ol>
<p>两种计算顺序的计算量差距在10倍。</p>
<p><code>将矩阵乘法问题（matrix-chain multiplication problem）</code>定义为：对于数目为$n$的一些列矩阵$<A_1,A_2,...,A_n>$，为了满足矩阵相乘的要求，矩阵$A<em>i$的大小都为$p</em>{i-1}\times p_i$，要求的使相乘计算量最小的矩阵相乘顺序。</p>
<h3 id="Counting-the-number-of-parenthesizations"><a href="#Counting-the-number-of-parenthesizations" class="headerlink" title="Counting the number of parenthesizations"></a>Counting the number of parenthesizations</h3><p>首先确认暴力枚举所有可能的顺序这个方法是很低效的，用$P(n)$来表示所有可能的计算顺序。设有$n$个矩阵，当$n=1$的情况下，只有一种可能，当$n\geq 2$的情况下，可以将$n$拆成两部分，$k$和$n-k$，所有的可能为这两部分可能的乘积，即$P(k)P(n-k)$。所以,</p>
<script type="math/tex; mode=display">
P(n)=
\begin{cases}
    1 & \text{ if } n=1 \\\\
    \sum_{k=1}^{n-1} P(k)P(n-k) &\text{ if } n \geq 2
\end{cases}</script><p>可以用数学归纳法证明$P(n)$的时间复杂度为$\Omega(2^n)$：</p>
<ol>
<li><p>在$n=1$的情况下，$P(n)=1$，得证</p>
</li>
<li><p>在$n\geq2$的情况下，假设$p(n)=c2^n$代入式子得</p>
<script type="math/tex; mode=display">
 P(n)=\sum_{k=1}^{n-1} c2^k\cdot c2^{n-k} \\\\
 =\sum_{k=1}^{n-1} c^2 2^n\\\\
 =c^2(n-1)2^n\\\\
 \geq c_1 2^n</script><p> 即$P(n)\geq c_1 2^n$，也得证。</p>
</li>
</ol>
<p>因此暴力枚举所有可能的顺序时间复杂度是一个指数型的函数， 效率是十分低下的。</p>
<h3 id="Applying-dynamic-programming"><a href="#Applying-dynamic-programming" class="headerlink" title="Applying dynamic programming"></a>Applying dynamic programming</h3><p>可以用动态规划来解决这个问题，这里根据之前定义的动态规划四步骤来解决答案：</p>
<ol>
<li>找到最优解的结构</li>
<li>递归定义最优解的值</li>
<li>计算出最优解的值，通常是通过一个自下而上的递归方式解决</li>
<li>使用计算得出的数据构建出最优解</li>
</ol>
<h4 id="Step-1-The-structure-of-an-optimal-parethesization"><a href="#Step-1-The-structure-of-an-optimal-parethesization" class="headerlink" title="Step 1:The structure of an optimal parethesization"></a>Step 1:The structure of an optimal parethesization</h4><p>用符号$A<em>{i…j}$表示矩阵序列$A_i,A</em>{i+1},…,A<em>{j}$的乘积，在$i\neq j$的情况下，可以将矩阵序列拆成两部分，$A_i,A</em>{i+1},…,A<em>{k}$和$A</em>{k+1},A<em>{k+2},…,A</em>{j}$，其中$i\leq k &lt; j$。</p>
<p>整个$A<em>{i…j}$的花费变成了$A</em>{i…k}$的花费加上$A_{k+1…j}$的花费再加上将两部分结果相乘的时间。</p>
<p>在按两部分分割下，如果$A<em>{i…j}$是最佳解，那么分出的$A</em>{i…k}$和$A<em>{k+1…j}$两部分也必然是各自的最佳解，因为如果其中一个可以更优的话，那么$A</em>{i…j}$则也可以变得更优。</p>
<p>因此矩阵相乘问题的最优解也变为了先求得两个子问题的最优解，再将两个最优解合并起来。</p>
<h4 id="Step2-A-recursive-solution"><a href="#Step2-A-recursive-solution" class="headerlink" title="Step2: A recursive solution"></a>Step2: A recursive solution</h4><p>用$m[i,j]$来表示$A<em>{i…j}$的操作量，根据Step1中的解释，$A</em>{i…j}$的花费变成了$A<em>{i…k}$的花费加上$A</em>{k+1…j}$的花费再加上将两部分结果相乘的时间。</p>
<p>因为矩阵$A<em>i$的尺寸为$p</em>{i-1}\times p<em>i$，所以矩阵$A</em>{i…k}$为$p<em>{i-1}\times p_k$，矩阵$A</em>{k+1…j}$的尺寸为$p<em>{k}\times p_j$。因此将两部分合并的操作数为$p</em>{i-1}p_kp_j$。</p>
<p>当$i=j$时，只有一个矩阵即不需要相乘，这种情况下$m[i,j]$为0，综上</p>
<script type="math/tex; mode=display">
m[i,j] = \begin{cases}
    0 & \text{ if } i=j \\\\
    \min_{i\leq k <j} {m[i,k]+m[k+1,j]+p_{i-1}p_kp_j} & \text { if } i <j
\end{cases}</script><p>但$m[i,j]$表示的只是最佳解的值，为了获得最佳解，需要定义一个$s[i,j]$，它记录每个子问题的最佳解时$k$的值。</p>
<h4 id="Step-3-Computing-the-optimal-costs"><a href="#Step-3-Computing-the-optimal-costs" class="headerlink" title="Step 3: Computing the optimal costs"></a>Step 3: Computing the optimal costs</h4><p>$m[i,j]$的计算依赖于矩阵的尺寸$p_{i-1} \times p_i$，如果存在$n$个矩阵，则表示数据尺寸的数组有$n+1$个元素，因为对于$A_1$而言，尺寸为$p_0 \times p_1$，所以$p$的数组是从0到$n$。</p>
<p>使用数组$m[i,j]$来表示$A_i…A_j$的最少操作数。其中$i$的取值范围是$1\sim n$，$j$的取值范围是$1\sim n$。当$i=j$时，$m[i,j]=0$</p>
<p>使用数组$s[i,j]$表示$A_i…A_j$有最少操作数时，$k$的取值。其中$i$的取值范围是$1\sim {n-1}$，$j$的取值范围是$2\sim n$。这是因为如果$i$必须小于$j$，如果$i=j$，那么根本就没有$k$的存在。</p>
<p>对于矩阵序列$A_i…A_j$，一共有$l$个元素，$l=i-j+1$</p>
<p>计算矩阵序列最佳解的算法伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MATRIX-CHAIN-ORDER(p)</span><br><span class="line"></span><br><span class="line">n = p.length -1</span><br><span class="line">m = new matrix[1~n][1~n]</span><br><span class="line">s = new matrix[1~n-1][2~n]</span><br><span class="line">for i = 1 to n //matrix chain only has one matrix</span><br><span class="line">    m[i,i] = 0</span><br><span class="line">for l = 2 to n</span><br><span class="line">    for i = 1 to n-l+1 // set i&#x27;s arrange according to the length</span><br><span class="line">         j = i + l -1 //we can calculated the j according to the i and l</span><br><span class="line">         m[i,j]= MAX</span><br><span class="line">        for k = i to j-1</span><br><span class="line">            q = m[j,k] + m[k+1,j] + p[i-1]p[k]p[j]</span><br><span class="line">            if q &lt; m[j,k]</span><br><span class="line">                m[i,j] = q</span><br><span class="line">                s[i,j] = k </span><br><span class="line">return m and s</span><br></pre></td></tr></table></figure>
<p>上述伪代码的第6-7行，即对于<code>m[i,i] = 0</code>的处理，实际上就是表示整个矩阵序列只有一个矩阵的情况。</p>
<p>算法的核心是从第八行开始的三重循环，最外层循环<code>l = 2 to n</code>，表示矩阵序列中的矩阵数量从$2\sim n$的情况。因为算法使用了自底向上的方法，所以从矩阵数量为$2$开始计算直到矩阵数量为$n$。</p>
<p>第二层循环<code>i =1 to n-l+1</code>，是对于$i$数值的循环，因为矩阵序列的长度为$l$，所以$i$最大为$n-l+1$，否则$j=i+l-1$会大于$n$。</p>
<p>因为$l$和$i$都已经确认，所以在第二层循环中，可以算出$j=i+l-1$，至此$m[i,j]$中的$i$和$j$都已经确认，剩下要求的就是分割点$k$。</p>
<p>第三层循环<code>k=i to j-1</code>是循环$k$取值的每一个可能，并检查其是否是最佳值，如果是则填入$m[i,j]$和$s[i,j]$</p>
<p>c++实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MatrixChainOrder</span><span class="params">(<span class="type">int</span>* matrixSizeArray, Matrix* minMultiplications, Matrix* minMultiplicationCut)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> totalMatrixLength = minMultiplications-&gt;row;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; totalMatrixLength; i++)</span><br><span class="line">			minMultiplications-&gt;data[i][i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> matrixLength = <span class="number">2</span>; matrixLength &lt;= totalMatrixLength; matrixLength++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; totalMatrixLength - matrixLength + <span class="number">1</span>; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> j = matrixLength + i - <span class="number">1</span>;</span><br><span class="line">				minMultiplications-&gt;data[i][j] = INT_MAX;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt;= j - <span class="number">1</span>; k++)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="type">int</span> tempMin = minMultiplications-&gt;data[i][k] + minMultiplications-&gt;data[k + <span class="number">1</span>][j] +</span><br><span class="line">						matrixSizeArray[i] * matrixSizeArray[k + <span class="number">1</span>] * matrixSizeArray[j + <span class="number">1</span>];</span><br><span class="line">					<span class="keyword">if</span> (tempMin &lt; minMultiplications-&gt;data[i][j])</span><br><span class="line">					&#123;</span><br><span class="line">						minMultiplications-&gt;data[i][j] = tempMin;</span><br><span class="line">						minMultiplicationCut-&gt;data[i][j] = k;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		minMultiplications-&gt;<span class="built_in">PrintMatrix</span>(<span class="number">15</span>);</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">		minMultiplicationCut-&gt;<span class="built_in">PrintMatrix</span>(<span class="number">15</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>c++实现中，<code>matrixSizeArray</code>表示存有矩阵尺寸的数组，如有$n$个矩阵，则该数组大小为$n+1$。<code>minMultiplications</code>等同于伪代码中的$m[i,j]$，<code>minMultiplicationCut</code>等同于伪代码中的$s[i,j]$。这两个都用了<code>Matrix</code>进行表示，两个<code>Matrix</code>尺寸都为$n$。虽然在伪代码中，$s[i,j]$的尺寸只要是$n-1$即可，但这里为了实现方便，还是用了$n$。</p>
<p>如果输入的<code>matrixSizeArray</code>数据有7个数据，即表示有6个矩阵，且初始化为:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> matrixSizeArray[] = &#123; <span class="number">30</span>,<span class="number">35</span>,<span class="number">15</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">20</span>,<span class="number">25</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>则C++运算结果如下：</p>
<p><img src="IA-Chapter15-Notes/2019-11-22-11-25-54.png" alt="MatrixChainMultiplicationResult"></p>
<p>结果中的<code>-842150451</code>是<code>Int</code>数值的默认值，在不同电脑上可能不一样。</p>
<p><code>minMultiplications</code>的对角线表示长度为1的情况，这时候不需要操作了，即为0。从对角线向右上角，每一条都长度+1的情况。右上角顶点$15125$即表示长度为6时的结果。</p>
<p>同理，<code>minMultiplicationCut</code>的对角线有表示长度为<code>1</code>的情况，但因为长度只有1，所以没法分割，也就是没法定义<code>k</code>，因此这个矩阵的对角线值是未定义的即<code>-842450451</code>。同样的从对角线向右上角，每一条都长度+1的情况。</p>
<p>将两个矩阵结果的未定义部分删去，并进行一个旋转，让对角线变成水平，则结果如下图所示，左边是$m[i,j]$，右边是$s[i,j]$：</p>
<p><img src="IA-Chapter15-Notes/2019-11-22-11-32-00.png" alt="旋转后的运行结果"></p>
<p>算法是从最底部逐渐向上运行。</p>
<ul>
<li>图中的$s[i,j]$与代码运行的结果不同，每一个数值都大了1，这是因为代码中矩阵位置是从0开始，而图解中是从1开始。</li>
</ul>
<p>因为算法有三种循环，所以时间复杂度为$O(n^3)$，且算法需要$\Theta(n^2)$的空间复杂度。</p>
<h4 id="Step-4-Constructing-an-optimal-solution"><a href="#Step-4-Constructing-an-optimal-solution" class="headerlink" title="Step 4: Constructing an optimal solution"></a>Step 4: Constructing an optimal solution</h4><p>在步骤三中求得的$m[i,j]$只是最佳解的值。如例子中如果要求6个矩阵的最小工作量，可以从$m[i,j]$的最顶部获得，为$15125$。但如果要求6个矩阵最佳情况下该以怎样的顺序进行计算，步骤三并没有直接给出。这里可以通过步骤三中获得的$s[i,j]$矩阵获取矩阵相乘最佳情况下的顺序。</p>
<p>伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PRINT-OPTIMAL-PARENS(s,i,j)</span><br><span class="line"></span><br><span class="line">if i == j</span><br><span class="line">    print &quot;A_&quot;i</span><br><span class="line">else</span><br><span class="line">    print &quot;(&quot;</span><br><span class="line">    PRINT-OPTIMAL-PARENS(s,i,s[i,j])</span><br><span class="line">    PRINT-OPTIMAL-PARENS(s,s[i,j]+1,j)</span><br><span class="line">    print &quot;)&quot;</span><br></pre></td></tr></table></figure>
<p>这里利用了步骤三中求得的$s[i,j]$，如果输入值为$0 \sim 5$（以C++实现的数据为准，所以不是$1\sim6$），则算法的图解如下：</p>
<p><img src="IA-Chapter15-Notes/2019-11-22-12-00-59.png" alt="打印矩阵最佳解图解"></p>
<p>黑色表示$(i,j)$，蓝色表示$s[i,j]$的取值，红色表示算法中的输出。</p>
<p>最后树以中序打印则为结果(因为算法中都是在递归左树和右树前先打印了数据，所以是中序)</p>
<p>c++实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintOptimalParens</span><span class="params">(Matrix* minMultiplicationsCut, <span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i == j)</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;A_&quot;</span> &lt;&lt; i;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;(&quot;</span>;</span><br><span class="line">		<span class="type">int</span> k = minMultiplicationsCut-&gt;data[i][j];</span><br><span class="line">		<span class="built_in">PrintOptimalParens</span>(minMultiplicationsCut, i, k);</span><br><span class="line">		<span class="built_in">PrintOptimalParens</span>(minMultiplicationsCut, k + <span class="number">1</span>, j);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入值为$0\sim5$的话，最终结果为$((A_0(A_1A_2))((A_3A_4)A_5))$。</p>
<h2 id="Elements-of-dynamic-programming"><a href="#Elements-of-dynamic-programming" class="headerlink" title="Elements of dynamic programming"></a>Elements of dynamic programming</h2><p>一个优化问题可以用动态规划解决必须有两个关键因素：<code>最优子结构（Optimal substructure）</code>和<code>重叠的子问题（overlapping subproblems）</code>。</p>
<h3 id="Optimal-substructure"><a href="#Optimal-substructure" class="headerlink" title="Optimal substructure"></a>Optimal substructure</h3><p>如果一个问题具有最优子结构，那么这个问题的最优解一定是伴随着他的子问题的最优解。</p>
<p>可以从以下步骤找寻问题的最优结构：</p>
<ol>
<li><p>问题的第一部分首先可以通过一个选择进行切分。切分后会产生一个或多个子问题。</p>
<p>这一步相当于先确定最内层的循环表达形式，如在切割钢条问题中是选择第一刀切割的长度$l$，矩阵乘法问题中是分割矩阵的位置(求$k$)。</p>
</li>
<li><p>在步骤一的选择中，假设已经知道最优解的选择是什么。</p>
<p>步骤一中的值是需要一个循环来遍历每个可能的值并找到最佳值的，步骤二即假设已经找到了最佳解。</p>
</li>
<li><p>限定子问题空间，即运用最优解的子问题（在步骤二中假设已经知道了解决每个问题的最优解）。限定子问题空间时尽可能简单。</p>
<p>例如对于钢条切割问题，子问题空间包含的问题是长度为$i$的钢条的最优切割问题，$i$取值从$1\sim n$。因此钢条切割问题外部只有一层循环。</p>
<p>但对于矩阵乘法问题，求$A_1A_2…A_n$的最佳分割方式，分割并不一定是从$A_1$开始的，所以需要子问题的两端都需要变化，即$A_i…A_j$，其中$i$的取值是$1\sim n$，$j$的取值是$i$到$n$。（$i$和$j$决定了矩阵序列的长度，在实际算法中，取$i$和长度$l$变量，$j$根据$i$和$l$算出）。因此矩阵乘法问题的子问题空间包含两个变量，外部有双层循环。</p>
</li>
<li><p>证明用来构成问题最优解的子问题本身必须是最优解。可以通过反证法，如果子问题不是最优解，那么将问题中的这一部分子问题替换为最优解，原问题能获取到更优的解。这个证明方法称为<code>“剪切-黏贴”（Cut-and-Paste）</code>方法</p>
</li>
</ol>
<p>对于不同的问题，最优子结构的不同体现在两个方面（这里关注的是循环最内层的表达式）</p>
<ol>
<li><p>原问题的最优解包含多少个子问题</p>
</li>
<li><p>在确定最优解使用哪些子问题时，要考察多少种可能。</p>
</li>
</ol>
<p>对于钢条切割问题，最优解只需要包含一个子问题，求钢条切割一刀后，剩下部分的最佳切割方式。对于长度为$n$的钢条，第一刀长度一共有$n$种可能性。</p>
<p>对于矩阵乘法问题，最优解需要包含两个子问题，切割后的$A_i..A_k$与$A_k..A_j$各自的最佳切分方式。对于$A_i…A_j$，$k$的取值一共有$j-i$种可能性。</p>
<p>可以从一个问题一共可能的子问题个数和每个子问题需要考察的可能性数量两方面来确定一个问题的时间复杂度。</p>
<p>例如钢条切割问题，长度为$n$的钢条，一共有$\Theta(n)$个子问题，每个子问题最多有$n$个可能性，所以时间复杂度为$O(n^2)$。对于矩阵乘法问题，因为$i$和$j$的变化，一共有$\Theta(n^2)$个子问题，每个子问题最多有$n-1$个可能性，所以时间复杂度为$O(n^3)$。</p>
<h4 id="Subtitles"><a href="#Subtitles" class="headerlink" title="Subtitles"></a>Subtitles</h4><p>需要注意不要在不是最优子结构的时候使用动态规划。</p>
<p>如求有向图的最短路径可以使用动态规划，但求最长路径就无法使用动态规划。这里的最长路径限定没有闭环，不然可以通过无限次闭环来增加路径。</p>
<p>以结点$u$到结点$v$为例子，在最短路径问题下是<strong>存在</strong>最佳子结构的。假设在$u$到$v$的最短路径上存在结点$w$，$u$到$w$和$w$到$v$都必然是最短路径。否则应用剪切黏贴法，如果有$u$到$w$的更短路径，那么用更短的路径替换则能得到$u$到$v$的更优解。</p>
<p>但在最长路径问题下是<strong>不存在</strong>最佳子结构的，即$u$到$v$的最长路径上存在结点$w$，$u$到$w$和$w$到$v$不一定是各自的最长路径。以下图为例</p>
<p><img src="IA-Chapter15-Notes/2019-11-26-10-35-55.png" alt="最长路径反例">。</p>
<p>如果求$q$到$t$的的最长路径，那么应该是$q\rightarrow r \rightarrow t$。但是$q\rightarrow r$并不是$q$到$r$的最长路径，其最长路径为$q \rightarrow s \rightarrow t \rightarrow r$，$r$到$t$的最长路径为$r \rightarrow q \rightarrow s \rightarrow t$。而$q$到$r$和$r$到$t$不能取各自最长路径的原因是，如果这么做了就会形成闭环回路。</p>
<p>虽然最长路径和最短路径都是将原问题拆分为了两个子问题，但是因为最长路径的两个子问题是<strong>相关</strong>的，所以不能用动态规划。例如在求$q$到$r$的最长路径的子问题时，因为用了$q \rightarrow s \rightarrow t$,在求$r$到$t$的时候就不能使用$q \rightarrow s \rightarrow t$，否则就存在了闭。即一个子问题的解会干扰到另一个子问题的求解，这就是<code>子问题相关</code>。</p>
<p>在最短路径问题下，不存在子问题相关，在两个子问题中也不会出现相同的结点。证明如下：</p>
<p>如果从$u$到$w$和从$w$到$v$两个子问题中都需要经过结点$x$，即路径时$u\rightarrow x\rightarrow w$和$w \rightarrow x \rightarrow v$，那么$x \rightarrow w$和$w \rightarrow x$可以相互抵消，最终路径为$u \rightarrow x \rightarrow v$。这又与经过$w$的假设不匹配，所以两端路径不可能都经过$x$。</p>
<h3 id="Overlapping-subproblems"><a href="#Overlapping-subproblems" class="headerlink" title="Overlapping subproblems"></a>Overlapping subproblems</h3><p>另一个动态规划需要满足的要求是重叠子问题，即在递归子问题空间中的问题时，子问题是需要是重复出现的，而不是一直出现新的子问题。与动态规划相对的是分治法，在分治法中，解决的每个的子问题都是全新的子问题，其中也不包含已经解决的小子问题。</p>
<p>如矩阵乘法问题中，$m[3,4]$这个子问题的求解，在求$m[2,4]$,$m[1,4]$,$m[3,5]$等中都会出现。下图展示了在求解$m[1,4]$的过程中，出现的子问题，其中深色部分为已经出现过的子问题。</p>
<p><img src="IA-Chapter15-Notes/2019-11-26-11-28-09.png" alt="重叠子问题"></p>
<p>因为使用了自底向上法或者备忘录法来规避了子问题的重复计算时间，动态规划的时间复杂度才能是多项式级别的，否则是指数形式。</p>
<p>在切割钢条问题的一节中，已经从数学上证明了迭代求解切割钢条问题复杂度为$O(2^n)$，也可证明矩阵乘法问题，迭代求解的复杂度也为$O(2^n)$。迭代法的伪代码为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RECURSIVE-MATRIX-CHAIN(p,i,j)</span><br><span class="line">if i == j</span><br><span class="line">    return 0</span><br><span class="line"></span><br><span class="line">m[i,j] = MAX</span><br><span class="line"></span><br><span class="line">for k = i to j-1</span><br><span class="line">    q = RECURSIVE-MATRIX-CHAIN(p,i,k) + RECURSIVE-MATRIX-CHAIN(p,k+1,j) +</span><br><span class="line">        p[i-1]p[k]p[j]</span><br><span class="line">    if q &lt; m[i,j]</span><br><span class="line">        m[i,j] = q</span><br><span class="line"></span><br><span class="line">return m[i,j]</span><br></pre></td></tr></table></figure>
<p>c++代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">RecursiveMatrixChain</span><span class="params">(<span class="type">int</span>* matrixSizeArray, Matrix* minMultiplications, <span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i == j)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	minMultiplications-&gt;data[i][j] = INT_MAX;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; j; k++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> tempMin = <span class="built_in">RecursiveMatrixChain</span>(matrixSizeArray, minMultiplications, i, k) +</span><br><span class="line">			<span class="built_in">RecursiveMatrixChain</span>(matrixSizeArray, minMultiplications, k + <span class="number">1</span>, j) + matrixSizeArray[i] * matrixSizeArray[k + <span class="number">1</span>] * matrixSizeArray[j + <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span> (tempMin &lt; minMultiplications-&gt;data[i][j])</span><br><span class="line">			minMultiplications-&gt;data[i][j] = tempMin;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> minMultiplications-&gt;data[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂为</p>
<script type="math/tex; mode=display">
T(n)\geq
\begin{cases}
    1 & n=1 \\\\
    1 + \sum_{k=1}^{n-1}(T(k)+T(n-k)+1) & n > 1
\end{cases}</script><p>可以用数学归纳法证明$T(n)=O(2^n)$</p>
<p>假设$T(n)=\Omega(2^n)$，可取$T(n)\geq 2^{n-1}，$当$n=1$时，$T(n)\geq 1 = 2^0$，得证。</p>
<p>当$n\geq 2$时，</p>
<script type="math/tex; mode=display">
T(n) \geq 1 + \sum_{k=1}^{n-1}(T(k)+T(n-k)+1) \\\\ 
= 1 +  \sum_{k=1}^{n-1} T(k) +\sum_{k=1}^{n-1}T(n-k) +\sum_{k=1}^{n-1} 1 \\\\
= 1 +  \sum_{k=1}^{n-1} T(k) + \sum_{i = n-1}^{1} T(i) +(n-1) \\\\
= 2\sum_{i=1}^{n-1}2^{i-1}+n \\\\
= 2(2^{n-1}-1)+n \\\\
= 2^n -2 +n \\\\
\geq 2^{n-1}</script><p>得证。而使用动态递归的方法，将时间复杂度变味了$n^3$，大幅提升了算法的效率。</p>
<h3 id="Reconstructing-an-optimal-solution"><a href="#Reconstructing-an-optimal-solution" class="headerlink" title="Reconstructing an optimal solution"></a>Reconstructing an optimal solution</h3><p>为了重构出最佳解（在写算法时，关注的是最佳解的值），需要在计算过程中保留一些关键数据，如在矩阵乘法问题中保存每一步的$k$值，即矩阵$s[i,j]$</p>
<h3 id="Memoization"><a href="#Memoization" class="headerlink" title="Memoization"></a>Memoization</h3><p>如在求解钢条切割问题一样，矩阵乘法问题也可以通过自顶向下的备忘录法解决，伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MEMOIZED-MATRIX-CHAIN(p)</span><br><span class="line">n = p.length - 1</span><br><span class="line">m = new matrix[1~n][1~n]</span><br><span class="line">for i = 1 to n</span><br><span class="line">    for j = i to n</span><br><span class="line">        m[i,j] = MAX</span><br><span class="line">return LOOKUP-CHAIN(m,p,1,n)</span><br><span class="line"></span><br><span class="line">LOOKUP-CHAIN(m,p,i,j)</span><br><span class="line"></span><br><span class="line">if m[i,j] &lt; MAX</span><br><span class="line">    return m[i,j]</span><br><span class="line">else</span><br><span class="line">    for k = i to j-1</span><br><span class="line">        q = LOOKUP-CHAIN(m,p,i,k) + LOOKUP-CHAIN(m,p,k+1,j)</span><br><span class="line">        + p[i-1]p[k]p[j]</span><br><span class="line">    if q &lt; m[i,j]</span><br><span class="line">        m[i,j] = q</span><br><span class="line">return m[i,j]</span><br></pre></td></tr></table></figure>
<p>c++代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MemoizedMatrixChain</span><span class="params">(<span class="type">int</span>* matrixSizeArray, Matrix* minMultiplications)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; minMultiplications-&gt;row; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; minMultiplications-&gt;column; j++)</span><br><span class="line">			minMultiplications-&gt;data[i][j] = INT_MAX;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">LookupChain</span>(matrixSizeArray, minMultiplications, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LookupChain</span><span class="params">(<span class="type">int</span>* matrixSizeArray, Matrix* minMultiplications, <span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (minMultiplications-&gt;data[i][j] &lt; INT_MAX)</span><br><span class="line">		<span class="keyword">return</span> minMultiplications-&gt;data[i][j];</span><br><span class="line">	<span class="keyword">if</span> (i == j)</span><br><span class="line">		minMultiplications-&gt;data[i][j] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		minMultiplications-&gt;data[i][j] = INT_MAX;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; j; k++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> tempMin = <span class="built_in">RecursiveMatrixChain</span>(matrixSizeArray, minMultiplications, i, k) +</span><br><span class="line">				<span class="built_in">RecursiveMatrixChain</span>(matrixSizeArray, minMultiplications, k + <span class="number">1</span>, j) + matrixSizeArray[i] * matrixSizeArray[k + <span class="number">1</span>] * matrixSizeArray[j + <span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span> (tempMin &lt; minMultiplications-&gt;data[i][j])</span><br><span class="line">				minMultiplications-&gt;data[i][j] = tempMin;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> minMultiplications-&gt;data[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该算法的时间复杂度同样为$O(n^3)$</p>
<p>如果一个问题的子问题空间中的所有问题都必须被解决，那么自底向上法的效率更高，因为它减少了函数调用堆栈的花销。但如果子问题空间的问题并一定需要全部被解决，那么自顶向下备忘法可能效率更高，因为他只会计算需要用到的子问题。</p>
<h2 id="Longest-common-subsequence"><a href="#Longest-common-subsequence" class="headerlink" title="Longest common subsequence"></a>Longest common subsequence</h2><p>//TODO</p>
<h2 id="Optimal-binary-search-trees"><a href="#Optimal-binary-search-trees" class="headerlink" title="Optimal binary search trees"></a>Optimal binary search trees</h2><p>//TODO</p>
<div class="note info simple"><p>引用：</p>
<ol>
<li><em>Introduction to Algorithms</em> 3rd Sep.2009</li>
</ol>
</div>
<hr>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>《算法导论》 第十七章笔记</title>
    <url>/IA-Chapter17-Notes/</url>
    <content><![CDATA[<p>《算法导论》 第十七章笔记，关于平摊分析。</p>
<p>第17.4节尚未整理</p>
<span id="more"></span>
<h1 id="Chapter-17-Amortized-Analysis"><a href="#Chapter-17-Amortized-Analysis" class="headerlink" title="Chapter 17 Amortized Analysis"></a>Chapter 17 Amortized Analysis</h1><p>平摊算法是计算一系列对数据结构的操作的平均时间，平摊算法分析保证了最坏情况下每个操作的平均性能。</p>
<p>这一节中会首先介绍三个平摊分析的方法：</p>
<p>17.1节介绍聚集分析，这个分析可以知道N个操作的累计花费时间的上限。</p>
<p>17.2节介绍记账方法，这个分析可以知道N个操作中，不同类型的操作的平均花费。</p>
<p>17.3节介绍势能方法，这个分许也可以知道N个操作中，不同类型的操作的平均花费。</p>
<p>势能方法与记账方法不同的是，记账操作是对每一个操作进行分析，如有的操作计算的时间比实际要花的时间更长，这些称之为预付，而有些操作计算的时间比实际时间更短，这些操作就是在使用之前的预付。而势能方法本质上也是预付和使用预付，但他的统计是针对于整个一系列操作，而不是针对每个操作，所以在势能方法中的预付是整体的。</p>
<h2 id="Aggregrate-analysis"><a href="#Aggregrate-analysis" class="headerlink" title="Aggregrate analysis"></a>Aggregrate analysis</h2><p>在聚集分析（Aggregrate analysis）中，对一系列（n个）操作在最坏情况下总共花费的时间称为$T(n)$，因此对每个操作的平摊花费（amortized cost）为$T(n)/n$。</p>
<h3 id="Stack-operation"><a href="#Stack-operation" class="headerlink" title="Stack operation"></a>Stack operation</h3><p>以栈操作为例，对于一个栈而言，Push和Pop的操作时间复杂度都是$O(1)$。定义一个新函数$Multipop(S,k)$，该操作会弹出栈上头K个元素，<code>S</code>为需要操作的堆栈，$K$为需要弹出的元素个数。如果栈上的元素数小于$k$，则该操作弹出所有的元素。</p>
<p>如下图所示：</p>
<p><img src="IA-Chapter17-Notes/2020-01-18-17-19-30.png" alt="Multipop展示"></p>
<p>MultiPop函数的伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MULTIPOP(S,k)</span><br><span class="line">while not STACK_EMPTY(S) and k &gt; 0</span><br><span class="line">    POP(S)</span><br><span class="line">    k = k-1</span><br></pre></td></tr></table></figure>
<p>MultiPop函数的时间复杂度与它真正执行的Pop函数数量成线性关系。</p>
<p>如果对栈有n个操作。那么最差情况下，MultiPop的时间复杂度为$O(n)$，即前面所有的操作都是Push，最后调用Multipop时它需要弹出所有的操作。最差情况下n个操作的时间复杂度为$nO(n)=O(n^2)$。尽管$O(n^2)$的确是n个操作的时间上限，但这个上限并不是紧密的。</p>
<p>使用聚合分析可以得到一个更紧密的上限。实际上对于一个栈而言，如果有n个操作，那么pop的数量最多和push一样，即n个操作的时间复杂度总和为$O(n)$，因此每个操作的平摊花费为$O(n)/n$。在聚合分析分析中，不关心不同类型的操作，因此将每个操作的平摊花费定义为$O(n)/n$即$O(1)$。</p>
<h3 id="Incrementing-a-binary-counter"><a href="#Incrementing-a-binary-counter" class="headerlink" title="Incrementing a binary counter"></a>Incrementing a binary counter</h3><p>这里举另外一个例子来讨论聚合分析。如使用一个二进制数的数组来做计数器，将数组命名为A，设数组中一共有k个元素，将A[0]定义为最低位，将A[k-1]定义为最高位。整个数组表示一个十进制数，则这个数的值为$x=\sum^{k-1}_{i=0}A[i]\dot{2^i}$。</p>
<p>Increment(A)的伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i = 0;</span><br><span class="line">while i &lt; A.length and A[i] == 1</span><br><span class="line">    A[i] = 0;</span><br><span class="line">    i++</span><br><span class="line">if i &lt; A.length</span><br><span class="line">    A[i] = 1</span><br></pre></td></tr></table></figure>
<p>While循环中处理的是进位问题，从最低位开始，如果是1则将其变为0（进位），直到发现某一位是0（出循环）后加1。所以Increment函数的时间复杂度与翻转（1变0或0变1）的位数有关。</p>
<p>在最坏的情况下，加1前，数组中的每个元素都是1，因此所有的元素值都需要反转（1变0，这种情况下是超过了数组所能累加的上线）。这种情况下时间复杂度为$O(k)$。一系列有n个操作，所以总体时间复杂度为$O(nk)$。但这样分析出来的时间复杂度同样也是不紧密的。</p>
<p>下图，展示了累加时数组每一位的变化情况。</p>
<p><img src="IA-Chapter17-Notes/2020-01-18-18-08-28.png" alt="Increment展示"></p>
<p>可以看到，A[0]每次操作都发生变化，A[1]每两次操作发生变化，A[2]每四次操作发生变化….A[i]每$2^i$次操作发生变化。所以对于n次操作而言，A[i]发生了$n/2^i$次变化。因此，从第0位到第k-1位，反转的总计为：</p>
<script type="math/tex; mode=display">
\sum_{i=0}^{k-1}\lfloor \frac{n}{2^i} \rfloor \\\\
< n \sum_{i=0}^{\infty}\frac{1}{2^i} \\\\
=2n</script><p>因此，整个操作的时间复杂度为$O(n)$，每个操作的平摊花费为$O(n)/n=O(1)$</p>
<h2 id="The-accounting-method"><a href="#The-accounting-method" class="headerlink" title="The accounting method"></a>The accounting method</h2><p>记账方法（Accounting method），对不同的操作计算不同的时间，这个时间称为平摊花费(amortized cost)。如果某一个操作，计算的时间大于其真实的运行时间，对于操作的对象，存放一个特殊的数据称为<code>credit</code>。</p>
<p>对于一系列n个操作，操作平摊花费的累加是要大于等于操作真实花费的累加，这样平摊花费的总和才能表示一系列操作的时间上限。</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{n}\hat{c_i}\geq\sum_{i=1}^{n} c_i</script><p>所有操作的credit总和即为$\sum<em>{i=1}^{n} \hat{c_i} - \sum</em>{i=1}^{n} c_i$。为了保证平摊花费的总和代表上限，这个值必须是非负的。</p>
<h3 id="Stack-Operations"><a href="#Stack-Operations" class="headerlink" title="Stack Operations"></a>Stack Operations</h3><div class="table-container">
<table>
<thead>
<tr>
<th>操作</th>
<th>真实花费</th>
<th>平摊花费</th>
</tr>
</thead>
<tbody>
<tr>
<td>Push</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>Pop</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>MultiPop</td>
<td>min(k,s)</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<p>其中$min(k,s)$中，$k$表示Multipop传入的$k$值，$s$表示目标数组的大小。</p>
<p>可以看到对于Push操作，平摊花费比真实花费要多1，这个1即使<code>credit</code>。即栈中的每个元素都有一个值为1的credit，之后的Pop操作和Multipop操作平摊花费都为0，相当于是使用一个<code>credit</code>。因为在Pop前都必须调用了相应数量的Push，所以总和的<code>credit</code>永远不会小于0</p>
<p>因此对于一系列n个操作而言，其总共的平摊花费也是$O(n)$。</p>
<h3 id="Incrementing-a-binary-counter-1"><a href="#Incrementing-a-binary-counter-1" class="headerlink" title="Incrementing a binary counter"></a>Incrementing a binary counter</h3><p>如之前所述，Increment函数的时间复杂度与翻转（1变0或0变1）的位数有关。实际上无论是从0变成1，还是从1变成0，其真实花费都是1。但是在这里认为对从0变成1，平摊花费为2，对与从1变成0，平摊花费为0。因为如果进行从1变为0的操作，这一位在之前一定经历过从0变为1，所以总和的<code>credit</code>也永远不会小于0。</p>
<p>因此对于n个Increment操作，其总平摊花费为$O(n)$。</p>
<h2 id="The-potential-method"><a href="#The-potential-method" class="headerlink" title="The potential method"></a>The potential method</h2><p>势能方法（potential method）中势能是对整个一系列操作而言的，即一些操作会增加整体势能，而一些操作会减少整体的势能。</p>
<p>我们假设数据$D<em>{i-1}$在进行了第$i$个操作后，变为了数据$D</em>{i}$，其中第$i$个操作的真实花费为$c<em>i$，数据$D</em>{i}$的势能为$\Phi(D<em>{i})$，数据$D</em>{i-1}$的势能为$\Phi(D_{i-1})$。定义第$i$个操作的平摊花费为</p>
<script type="math/tex; mode=display">
\hat{c_i} = c_i + \Phi(D_{i})-\Phi(D_{i-1})</script><p>即真实的操作花费加上势能的变化，这个变化可能是正数，也可能是负数。</p>
<p>那么对于一系列操作而言，其总体的平均花费为</p>
<script type="math/tex; mode=display">
\sum_{i=0}^{n} \hat{c_i} \\\\
=\sum_{i=0}^{n}(c_i+\Phi(D_{i})-\Phi(D_{i-1})) \\\\
=\sum_{i=0}^{n}c_i + \Phi(D_{n}) - \Phi(D_{0})</script><p>为了平均花费的总和是真实花费总和的上界限，必须保证$\Phi(D<em>{n})\geq \Phi(D</em>{0})$。在实际中，并不能知道$n$的值是多少，所以我们要保证$\Phi(D<em>{i})\geq \Phi(D</em>{0})$。</p>
<p>为了满足这个式子，经常在定义势能函数时保证，$\Phi(D<em>{0})=0$而且$\Phi(D</em>{i})\geq0$。</p>
<p>势能分析的关键在于定义势能的计算函数。</p>
<h3 id="Stack-Operation"><a href="#Stack-Operation" class="headerlink" title="Stack Operation"></a>Stack Operation</h3><p>在栈操作中，定义势能函数为栈中元素的个数，则对于Push操作，操作后势能的变化为</p>
<script type="math/tex; mode=display">
\Phi(D_{i})- \Phi(D_{i-1})\\\\
(s+1) -s \\\\
=1</script><p>因此Push操作的平摊花费为</p>
<script type="math/tex; mode=display">
\hat{c_i} = c_i + \Phi(D_{i})-\Phi(D_{i-1})\\\\
= 1 +1 \\\\
=2</script><p>而对于Multipop函数而言，操作后的势能变化为</p>
<script type="math/tex; mode=display">
\Phi(D_{i})- \Phi(D_{i-1})\\\\
=(s-k^{'}) -s \\\\
=-k^{'}</script><p>其中$k^{‘}$为$min(k,s)$。因此Multipop的平摊花费为</p>
<script type="math/tex; mode=display">
\hat{c_i} = c_i + \Phi(D_{i})-\Phi(D_{i-1})\\\\
= k^{'} -k^{'} \\\\
=0</script><p>同理可证明$\hat{c_i}=0$，因此三个操作的均摊时间复杂度都是$O(1)$，总体的均摊时间复杂度为$O(n)$。</p>
<h3 id="Incrementing-a-binary-counter-2"><a href="#Incrementing-a-binary-counter-2" class="headerlink" title="Incrementing a binary counter"></a>Incrementing a binary counter</h3><p>这里，定义势能为操作后数组中值为1的元素数，表达为$b_i$。假设第$i$个操作，把$t_i$位从1变为0，其真实花费最多为$t_i+1$，即再加上一个退出循环后的从0到1的操作（也可能在退出循环后，已经大于了数组的边界，也就不会有从0到1的操作了）。</p>
<p>如果操作后$b<em>i$=0，说明上一个累加操作时超越了边界的，即操作前整个数组都是1，进行了$k$个从1到0，k为数组长度，即$b</em>{i-1}=t<em>i=k$。如果操作后$b_i&gt;0$，则$b_i=b</em>{i-1}-t<em>i+1$，总之$b_i\leq b</em>{i-1}-t_i+1$。</p>
<p>因此势能的变化为:</p>
<script type="math/tex; mode=display">
\Phi(D_{i})- \Phi(D_{i-1})\\\\
\leq (b_{i-1}-t_i+1) - b_{i-1}\\\\
=1-t_i</script><p>平摊花费为</p>
<script type="math/tex; mode=display">
\hat{c_i} = c_i + \Phi(D_{i})-\Phi(D_{i-1})\\\\
\leq t_i +1 +1 - t_i \\\\
=2</script><p>如果计数器从0开始，即$\Phi(D<em>{0})=0$，且有$\Phi(D</em>{i})\geq 0$，因此一系列n个操作的总共平摊时间复杂度为$O(n)$。</p>
<p>如果计数器不是从0开始，一开始有$b_0$个1，最后有$b_n$个1，这两个数满足$0\leq b_0$和$b_n \leq k$。势能方法的表达式可变形为：</p>
<script type="math/tex; mode=display">
\sum_{i=0}^{n}c_i \\\\
=\sum_{i=0}^{n}\hat{c_i}-\Phi(D_{n})+\Phi(D_{0})</script><p>因为已经证明了$\hat{c_i} \leq 2$，所以可得</p>
<script type="math/tex; mode=display">
\sum_{i=0}^{n}c_i
\leq 2n-b_n+b_o</script><p>所以实际操作的总体花费复杂度为$O(n)$。</p>
<div class="note info simple"><p>引用：</p>
<ol>
<li><em>Introduction to Algorithms</em> 3rd Sep.2009</li>
</ol>
</div>
<hr>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>《算法导论》 第三章笔记</title>
    <url>/IA-Chapter3-Notes/</url>
    <content><![CDATA[<p>《算法导论》 第三章笔记，包括时间复杂度符号即一些基本的数学公式</p>
<span id="more"></span>
<h2 id="Chapter-3-Growth-of-Functions"><a href="#Chapter-3-Growth-of-Functions" class="headerlink" title="Chapter 3. Growth of Functions"></a>Chapter 3. Growth of Functions</h2><h3 id="Asymptotic-notation"><a href="#Asymptotic-notation" class="headerlink" title="Asymptotic notation"></a>Asymptotic notation</h3><h4 id="Asymptotic-notation-functions-and-running-time"><a href="#Asymptotic-notation-functions-and-running-time" class="headerlink" title="Asymptotic notation,functions,and running time"></a>Asymptotic notation,functions,and running time</h4><p>书中所有的渐进符号都是用来用来表达算法的运算时间的，虽然渐进符号也能用来表示算法的其他资源，如内存，硬盘空间等。</p>
<h4 id="Theta-notation"><a href="#Theta-notation" class="headerlink" title="$\Theta$-notation"></a>$\Theta$-notation</h4><p>在第二章中，描述插入算法的最坏情况下$T(n)=\Theta(n^2)$，但没有详细解释$\Theta$含义，<br>这一节给出了定义。</p>
<p>对函数$f(n)$，如果存在常数$c_1$，$c_2$和$n_0$使得对于任意$n\geq n_0$，满足</p>
<script type="math/tex; mode=display">
0\leq c_1g(n)\leq f(n) \leq c_2g(n)</script><p>则称$f(n)=\Theta(g(n))$，$g(n)$称为$f(b)$的渐进紧确界，函数下图表示</p>
<p><img src="IA-Chapter3-Notes/2019-10-18-13-43-15.png" alt="渐进函数_1"></p>
<div class="note info simple"><p>注意$\Theta(g(n))$实际上是一系列函数的集合，所以严格意义上来说应该表达为$f(n)\in \Theta(g(n))$，但在书中为了表达方便，都写为$f(n)=\Theta(g(n))$</p>
</div>
<div class="note info simple"><p>这里的所有函数都约定为非负的</p>
</div>
<p>数学证明如下：</p>
<p>如我们要证明函数$\frac{1}{2}n^2-3n=\Theta(n^2)$，那么按定义，应该证明</p>
<script type="math/tex; mode=display">
0\leq c_1n^2\leq \frac{1}{2}n^2-3n \leq c_2n^2</script><p>不等式各边都除去$n^2$，得到</p>
<script type="math/tex; mode=display">
c_1 \leq \frac{1}{2}-\frac{3}{n} \leq c_2</script><p>那么当$n$足够大时（大于$n_0$）,则逼近于$c_1 \leq \frac{1}{2}\leq c_2$，明显可以可以找到$c_1$和$c_2$满足该不等式是。这里的$c_1$和$c_2$取值可以有无数种组合。</p>
<h4 id="O-notation"><a href="#O-notation" class="headerlink" title="$O$-notation"></a>$O$-notation</h4><p>$O$标记表示渐进上边界，定义为对函数$f(n)$，如果存在常数$c$和$n_0$使得对于任意$n\geq n_0$，满足</p>
<script type="math/tex; mode=display">
0\leq f(n) \leq cg(n)</script><p>函数图如下：</p>
<p><img src="IA-Chapter3-Notes/2019-10-18-14-22-25.png" alt="渐进函数_2"></p>
<p>因为$O$标记定义的表达式实际上是$\Theta$标记表达式的一部分，所以可以用同样的方法证明$O$标记的合理性。</p>
<p>要注意的是，按照定义，$O$标记仅仅是定义了上边界，而没有具体的确认这个边界与原函数需要多么的紧密。如$n=O(n^2)$仍然也是成立的，即使对于函数$f(n)=n$来说，紧密的上边界应该为$O(n)$。</p>
<p>也正是因为如此，对于算法来说，无论输入情况是什么样的，都可以用$O$标记来描述。以插入函数举例：我们针对插入函数的最差输入情况（每次插入的数都需要插入到已有列表的第一个），紧密上边界表达式为$O(n^2)$；对于最佳输入情况（每次插入的数都可直接插入已有列表的最后），紧密的上边界应该表达为$O(n)$，但是表达式$O(n^2)$按定义仍然是可以用来描述最好情况的。</p>
<p>而渐进紧确界$\Theta$则不满足上述情况，在插入算法中，最坏和最好情况下，表达式分别为$\Theta(n^2)$和$\Theta(n)$。这里不同的是$\Theta(n^2)$不能用于描述最好情况，因为你无法找到一个常量$c$，在$n$足够大的情况下，仍然满足$n^2&lt;cn$。</p>
<h4 id="Omega-notation"><a href="#Omega-notation" class="headerlink" title="$\Omega$-notation"></a>$\Omega$-notation</h4><p>$\Omega$标记提供了符号渐进下边界，定义为存在常数$c$和$n_0$使得对于任意$n\geq n_0$，满足</p>
<script type="math/tex; mode=display">
0\leq cg(n)\leq f(n)</script><p>函数图像如下：</p>
<p><img src="IA-Chapter3-Notes/2019-10-18-15-44-11.png" alt="逼近函数_3"></p>
<p>$\Omega$标记的证明与$\Theta$类似，且与$O$一样都能描述算法的任何输入。只不过$\Omega$关注的是算法的最好情况，$O$关注的是算法的最差情况，所以通常我们对于$O$的使用较多。</p>
<div class="note info simple"><p>定理3.1：<br>对任意两个函数$f(n)$和$g(n)$，当且仅当$f(n)=O(g(n)$和$f(n)=\Omega(g(n))$时，存在$f(n)=\Theta(g(n))$</p>
</div>
<h4 id="Asymoptotic-notation-in-equations-and-inequalities"><a href="#Asymoptotic-notation-in-equations-and-inequalities" class="headerlink" title="Asymoptotic notation in equations and inequalities"></a>Asymoptotic notation in equations and inequalities</h4><p>在书中，有时会在表达式和不等式中用渐进表达式来省去一些不关注的细节，如表达式$2n^2+3n+1=2n^2+\Theta(n)$表示$2n^2+3n+1=2n^2+f(n)$，其中$f(n)\in \Theta(n)$</p>
<h4 id="o-notation"><a href="#o-notation" class="headerlink" title="$o$-notation"></a>$o$-notation</h4><p>如之前在$O$标记一节中描述的，$O$标记可以表示紧密上边界和非紧密上边界，如对于函数$2n^2$,$O(n^2)$即为紧密上边界，而$O(n^3)$则不是。</p>
<p>这里我们定义$o$标记来单独表示非紧密上边界：对于任意正常量$c$，都存在一个对应的常量$n_0$使得在$n\geq n_0$时满足</p>
<script type="math/tex; mode=display">
0\leq f(n) < cg(n)</script><p>则称$f(n)=o(g(n))$</p>
<p>$o$标记和$O$标记在定义上的区别在于，$O$是存在常量$c$和$n_0$使表达式成立即可，而$o$定义是对于任意常量$c$，都要存在$n_0$使得表达式成立(且表达式为&lt;而非$\leq$)，例如$2n=o(n^2)$但$2n\neq o(n)$。如果后者成立，那么当$c$取2时，无论$n_0$取值为多少，都无法满足$f(n)&lt;2n$。</p>
<p>关于$o$标记还有一个等效的定义表达式：因为是$o$标记非紧密的上边界，所以当$n$足够大，$g(n)$会远大于$f(n)$</p>
<script type="math/tex; mode=display">
\lim_{n\rightarrow \infty}\frac{f(n)}{g(n)}=0</script><h4 id="omega-notation"><a href="#omega-notation" class="headerlink" title="$\omega$ -notation"></a>$\omega$ -notation</h4><p>$\omega$标记对于$\Omega$标记就如同$o$标记对于$O$标记。$\omega$标记的定义为，对于任意正常量$c$，都存在一个对应的常量$n_0$使得在$n\geq n_0$时满足</p>
<script type="math/tex; mode=display">
0\leq cg(n) < f(n)</script><p>则称$f(n)=\omega(g(n))$。例如，$n^2/2=\omega(n)$但$n^2/2 \neq \omega(n^2)$。且同样存在另一个定义。</p>
<script type="math/tex; mode=display">
\lim_{n\rightarrow \infty}\frac{f(n)}{g(n)}=\infty</script><p>$o$标记和$\omega$标记的关系可以表达为：当且仅当$g(n)\in o(f(n))$时，$f(n)\in \omega(g(n))$</p>
<h4 id="Comparing-functions"><a href="#Comparing-functions" class="headerlink" title="Comparing functions"></a>Comparing functions</h4><p>渐进标记与数学中的不等式有点类似，同样都满足传递法，如a&lt;b，b&lt;c，则a&lt;c。</p>
<p>$f(n)=O(g(n))$ 类似于 $a\leq b$</p>
<p>$f(n)=\Omega(g(n))$ 类似于 $a\geq b$</p>
<p>$f(n)=\Theta(g(n))$ 类似于 $a= b$</p>
<p>$f(n)=o(g(n))$ 类似于 $a &lt; b$</p>
<p>$f(n)=\omega(g(n))$ 类似于 $a &gt; b$</p>
<p>但与不等式不同的是，对于两个数字，关系要么满足大于等于，要么满足小于等于。但对于渐进标记，存在两个函数$f(n)$和$g(n)$，可能即不满足$f(n)=O(g(n))$，也不满足$f(n)=\Omega(g(n))$，如函数$n$与$n^{1+\sin n}$，因为$n^{1+\sin n}$的次幂始终在变化，在0-2之间摇摆。</p>
<h3 id="Standard-notations-and-common-functions"><a href="#Standard-notations-and-common-functions" class="headerlink" title="Standard notations and common functions"></a>Standard notations and common functions</h3><p>这一节主要是介绍一些数学内容，这里只列出关键的结论，定理和公式，并没有完整证明。</p>
<h4 id="Floors-and-ceilings（向上取整与向下取整）"><a href="#Floors-and-ceilings（向上取整与向下取整）" class="headerlink" title="Floors and ceilings（向上取整与向下取整）"></a>Floors and ceilings（向上取整与向下取整）</h4><p>一些定理及公式</p>
<script type="math/tex; mode=display">\lceil n/2 \rceil + \lfloor n/2 \rfloor = n</script><script type="math/tex; mode=display">\lceil \frac{\lceil x/a \rceil}{b} \rceil = \lceil \frac{x}{ab} \rceil</script><script type="math/tex; mode=display">\lfloor \frac{\lfloor x/a \rfloor}{b} \rfloor = \lfloor \frac{x}{ab} \rfloor</script><script type="math/tex; mode=display">\lceil \frac{a}{b} \rceil \leq \frac{a+(b-1)}{b}</script><script type="math/tex; mode=display">\lfloor \frac{a}{b} \rfloor \geq \frac{a-(b-1)}{b}</script><h4 id="Modular-arithmetic（求余）"><a href="#Modular-arithmetic（求余）" class="headerlink" title="Modular arithmetic（求余）"></a>Modular arithmetic（求余）</h4><script type="math/tex; mode=display">a mod n =a -n\lfloor a/n \rfloor</script><p>如果存在$(a mod n ) = (b mod n)$，可写作$a\equiv b \text { (mod n)}$</p>
<h4 id="Polunomials-多项式"><a href="#Polunomials-多项式" class="headerlink" title="Polunomials(多项式)"></a>Polunomials(多项式)</h4><p>对于某个常量$k$，如果有$f(n)=O(n^k)$则称函数$f(n)$是多项式有界的</p>
<h4 id="Exponentials（指数）"><a href="#Exponentials（指数）" class="headerlink" title="Exponentials（指数）"></a>Exponentials（指数）</h4><script type="math/tex; mode=display">(a^m)^n=a^{mn}</script><script type="math/tex; mode=display">(a^m)+a^n=a^{m+n}</script><p>对所有实数有，</p>
<script type="math/tex; mode=display">e^x=\sum_{i=0}^{\infty}\frac{x^i}{i!}</script><script type="math/tex; mode=display">e^x\geq1+x</script><script type="math/tex; mode=display">e^x=\lim_{n\rightarrow \infty}(1+\frac{x}{n})^n</script><p>指数增长速度比多项式快得多，可表达为</p>
<script type="math/tex; mode=display">\lim_{n\rightarrow \infty}\frac{n^b}{a^n}=0</script><p>用渐进标记，则表达为</p>
<script type="math/tex; mode=display">n^b=o(a^n)</script><h4 id="Logarithms（对数）"><a href="#Logarithms（对数）" class="headerlink" title="Logarithms（对数）"></a>Logarithms（对数）</h4><script type="math/tex; mode=display">\lg ^kn=(\lg n)^k</script><script type="math/tex; mode=display">a=b^{\log_ba}</script><script type="math/tex; mode=display">\log_c(ab)=\log_ca+\log_cb</script><script type="math/tex; mode=display">\log_ba^n=n\log_ba</script><script type="math/tex; mode=display">\log_ba= \frac{\log_ca}{\log_cb}</script><script type="math/tex; mode=display">\log_b(1/a)=-\log_ba</script><script type="math/tex; mode=display">\log_ba=\frac{1}{\log_ab}</script><script type="math/tex; mode=display">a^{\log_bc}=c^{\log_ba}</script><p>如果满足$f(n)=O(\lg^kn)$，则称$f(n)$是多对数有界的。</p>
<p>多项式的增长速度比对数快得多，可以表达为</p>
<script type="math/tex; mode=display">\lim_{n\rightarrow \infty}\frac{\lg^bn}{n^a}=0</script><p>用渐进标记，则表达为</p>
<script type="math/tex; mode=display">\lg^bn=o(n^a)</script><h4 id="Factorials-阶乘"><a href="#Factorials-阶乘" class="headerlink" title="Factorials(阶乘)"></a>Factorials(阶乘)</h4><script type="math/tex; mode=display">n!\leq n^n \text{ 即 }n!=o(n^n)</script><script type="math/tex; mode=display">n!=\omega 2^n</script><script type="math/tex; mode=display">\lg(n^!)=\Theta(n\lg n)</script><h4 id="Functional-iteration-多重函数"><a href="#Functional-iteration-多重函数" class="headerlink" title="Functional iteration (多重函数)"></a>Functional iteration (多重函数)</h4><p>可看作是函数的递归嵌套，递归次数用括号包裹的次幂表示，如$f^{(i)}(n)$，表示递归$i$次</p>
<script type="math/tex; mode=display">
f^{(i)}(n)=
\begin{cases}
    n & \text{if }i=0 \\\\
    f(f^{(i-1)}(n)) & \text{if } i >0
\end{cases}</script><p>如函数$f(n)=2n$，$f^{(i)}(n)=2^in$</p>
<p>注意区分$\lg^in$与$\lg^{(i)}n$，前者是$\lg n$的$i$次幂，后者是对$n$连续使用$i$次对数函数。</p>
<h4 id="The-iterated-logarithm-function-多重对数函数"><a href="#The-iterated-logarithm-function-多重对数函数" class="headerlink" title="The iterated logarithm function (多重对数函数)"></a>The iterated logarithm function (多重对数函数)</h4><p>使用$lg*n$表示多重对数函数，定义为</p>
<script type="math/tex; mode=display">\lg^*n=min\{i\geq 0:lg^{(i)}n\leq 1\}</script><p>意思是求得最小的可以满足$lg^{(i)}n\leq 1$的$i$是多少</p>
<p>如$lg^<em>16=3$、$lg^</em>65536=4$，因为</p>
<script type="math/tex; mode=display">\log_216=4 \rightarrow \log_24=2 \rightarrow \log_22=1</script><script type="math/tex; mode=display">\log_265536=16 \rightarrow \log_216=4 \rightarrow \log_24=2 \rightarrow \log_22=1</script><p>即分别需要三次和四次运算才能满足条件。</p>
<h4 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h4><p>斐波那契数列定义为：</p>
<script type="math/tex; mode=display">F_0=0</script><script type="math/tex; mode=display">F_1=1</script><script type="math/tex; mode=display">F_i=F_{i-1}+F_{i-2}</script><p>还有一个定义</p>
<script type="math/tex; mode=display">
F_i=\frac{\phi ^ i - \hat{\phi}^i}{\sqrt{5}}</script><p>其中$\phi$和$\hat{\phi}$为方程$x^2=x+1$的两个解。</p>
<ul>
<li>斐波那契数列以指数速率增长。</li>
</ul>
<div class="note info simple"><p>引用：</p>
<ol>
<li><em>Introduction to Algorithms</em> 3rd Sep.2009</li>
</ol>
</div>
<hr>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>《算法导论》 第四章笔记</title>
    <url>/IA-Chapter4-Notes/</url>
    <content><![CDATA[<p>《算法导论》第四章笔记。包括分治法的介绍，最大子数组问题算法与分析，矩阵相乘问题问题算法与分析，代入法、递归树法、主方法求时间复杂度。<br>4.6节尚未整理。</p>
<span id="more"></span>
<h1 id="Chapter-4-Divide-and-Conquer"><a href="#Chapter-4-Divide-and-Conquer" class="headerlink" title="Chapter 4. Divide-and-Conquer"></a>Chapter 4. Divide-and-Conquer</h1><p>在分析分治法的时候一般无视了许多细节，例如在分析归并排序时，如果考虑到$n$存在奇、偶情况，那么表达式应该写成</p>
<script type="math/tex; mode=display">
T(n)=\begin{cases}
     \Theta(1) & \text{ if }  n=1
     \\\\
     T(\lceil n/2 \rceil)+T(\lfloor n/2 \rfloor)+\Theta(n) & \text{ if }  n>1
\end{cases}</script><p>但在实际中，通常会无视向上取整，向下取整和一些边界条件，所以在归并排序分析时写成</p>
<script type="math/tex; mode=display">T(n)=2T(n/2)+\Theta(n)</script><h2 id="The-Maximum-subarray-problem"><a href="#The-Maximum-subarray-problem" class="headerlink" title="The Maximum-subarray problem"></a>The Maximum-subarray problem</h2><p>从一个整数数组中找寻出值最大的子数组。如下图所示的数组中，$A[8..11]$即为最大数组，和为43</p>
<p><img src="IA-Chapter4-Notes/2019-10-20-10-30-15.png" alt="最大子数组"></p>
<h3 id="A-brute-force-solution"><a href="#A-brute-force-solution" class="headerlink" title="A brute-force solution"></a>A brute-force solution</h3><p>暴力破解法：通过双重循环遍寻所有的子数组情况，找出最大的数组。通过上一个子数组的和加上当前元素即可求得当前子数组的和，所以计算子数组和的花费为$O(1)$，遍历所有子数组需要的时间花费为$O(n^2)$，所以总体算法时间为$O(n^2)$</p>
<p>暴力破解的代码实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">FindMaximumSubarray_BruteForce</span><span class="params">(<span class="type">int</span>* originArray, <span class="type">int</span> arrayLength, <span class="type">int</span>&amp; leftIndex, <span class="type">int</span>&amp; rightIndex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> maxSum = -INT_MAX, sum = <span class="number">0</span>;</span><br><span class="line">	leftIndex = rightIndex = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arrayLength; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; arrayLength; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			sum += originArray[j];</span><br><span class="line">			<span class="keyword">if</span> (sum &gt; maxSum)</span><br><span class="line">			&#123;</span><br><span class="line">				maxSum = sum;</span><br><span class="line">				leftIndex = i;</span><br><span class="line">				rightIndex = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="A-solution-using-divide-and-conquer"><a href="#A-solution-using-divide-and-conquer" class="headerlink" title="A solution using divide-and-conquer"></a>A solution using divide-and-conquer</h3><p>分治法求最大子数组问题的思路为，把原数组等分为两个部分，左半数组和右半数组。这时候求得的最大数组只可能是三种情况：完全在左半数组中，完全在右半数组中，处在左右半数组交界的地方。</p>
<p>所以分治法求最大子数组的伪代码如下，代码中依次求三种情况的最大子数组，然后比较求得原数组的最大子数组。（在求左右半边的最大子数组时使用了迭代）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FIND-MAXIMUM_SUBARRAY(A,low,high)</span><br><span class="line">//A为原数组，low，high分别表示拆分出的左或右数组的左右Index</span><br><span class="line"></span><br><span class="line">if high==low //只有一个元素时，即为最大子数组</span><br><span class="line">    return [low,high,A[low]]</span><br><span class="line">else </span><br><span class="line">    mid=[(low + high)/2]</span><br><span class="line">    (left-low, left-high, left-sum)= FIND-MAXIMUM_SUBARRAY(A,low,mid)</span><br><span class="line">    (right-low, right-high, right-sum)= FIND-MAXIMUM_SUBARRAY(A,mid+1,high)</span><br><span class="line">    (cross-low, cross-high,cross-sum)=FIND-MAX-CROSSING-SUBARRAY(A,low,mid,high)</span><br><span class="line"></span><br><span class="line">    if left-sum &gt;=right-sum &amp;&amp; left-sum&gt;=cross-sum</span><br><span class="line">        return [left-low,left-high,left-sum]</span><br><span class="line">    else if right-sum&gt;=left-sum &amp;&amp; right-sum &gt;= cross-sum</span><br><span class="line">        return [right-low,right-high,right-sum]</span><br><span class="line">    else</span><br><span class="line">        return [cross-low,cross-high,cross-sum]</span><br></pre></td></tr></table></figure>
<p>在求左右半边的最大子数组时使用了迭代，现在还要解决的就是求交叉最大子数组FIND-MAX-CROSSING-SUBARRAY函数的定义。</p>
<p>交叉最大子数组一定一部分处于左半数组，一部分处于右半。从Index mid处向左和向右各寻找最大的左部分，然后将左右部分结合便形成了最大的交叉子数组。</p>
<p>求交叉最大子数组伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FIND-MAX-CROSSING-SUBARRAY(A,low,mid,high)</span><br><span class="line"></span><br><span class="line">left-sum= -MAX</span><br><span class="line">sum=0;</span><br><span class="line"></span><br><span class="line">for i= mid downto low</span><br><span class="line">    sum = sum + A[i]</span><br><span class="line">    if sum &gt; left-sum</span><br><span class="line">        left-sum=sum;</span><br><span class="line">        max-left-Index=i</span><br><span class="line"></span><br><span class="line">right-sum= -MAX</span><br><span class="line">sum=0;</span><br><span class="line"></span><br><span class="line">for i= mid to high</span><br><span class="line">    sum = sum + A[i]</span><br><span class="line">    if sum &gt; right-sum</span><br><span class="line">        right-sum=sum;</span><br><span class="line">        max-right-Index=i</span><br><span class="line"></span><br><span class="line">return (max-left-index,max-right-index,left-sum + right-sum)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>完整C++实现代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">FindMaximumSubarray_DivideAConquer</span><span class="params">(<span class="type">int</span>* originArray, <span class="type">int</span> leftIndex, <span class="type">int</span> rightIndex, <span class="type">int</span>&amp; maxLeftIndex, <span class="type">int</span>&amp; maxRightIndex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (leftIndex == rightIndex)</span><br><span class="line">	&#123;</span><br><span class="line">		maxLeftIndex = maxRightIndex = leftIndex;</span><br><span class="line">		<span class="keyword">return</span> originArray[leftIndex];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> midIndex = (leftIndex + rightIndex) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> sumLeft = <span class="number">0</span>, leftMaxLeftIndex = <span class="number">0</span>, leftMaxRightIndex = <span class="number">0</span>;</span><br><span class="line">	sumLeft = <span class="built_in">FindMaximumSubarray_DivideAConquer</span>(originArray, leftIndex, midIndex, leftMaxLeftIndex, leftMaxRightIndex);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> sumRight = <span class="number">0</span>, rightMaxLeftIndex = <span class="number">0</span>, rightMaxRightIndex = <span class="number">0</span>;</span><br><span class="line">	sumRight = <span class="built_in">FindMaximumSubarray_DivideAConquer</span>(originArray, midIndex + <span class="number">1</span>, rightIndex, rightMaxLeftIndex, rightMaxRightIndex);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> sumCross = <span class="number">0</span>, crossMaxLeftIndex = <span class="number">0</span>, crossMaxRightIndex = <span class="number">0</span>;</span><br><span class="line">	sumCross = <span class="built_in">FindCrossingMaximumSubarray</span>(originArray, leftIndex, midIndex, rightIndex, crossMaxLeftIndex, crossMaxRightIndex);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sumLeft &gt;= sumRight &amp;&amp; sumLeft &gt;= sumCross)</span><br><span class="line">	&#123;</span><br><span class="line">		maxLeftIndex = leftMaxLeftIndex;</span><br><span class="line">		maxRightIndex = leftMaxRightIndex;</span><br><span class="line">		<span class="keyword">return</span> sumLeft;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (sumRight &gt;= sumLeft &amp;&amp; sumRight &gt;= sumCross)</span><br><span class="line">	&#123;</span><br><span class="line">		maxLeftIndex = rightMaxLeftIndex;</span><br><span class="line">		maxRightIndex = rightMaxRightIndex;</span><br><span class="line">		<span class="keyword">return</span> sumRight;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		maxLeftIndex = crossMaxLeftIndex;</span><br><span class="line">		maxRightIndex = crossMaxRightIndex;</span><br><span class="line">		<span class="keyword">return</span> sumCross;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FindCrossingMaximumSubarray</span><span class="params">(<span class="type">int</span>* originArray, <span class="type">int</span> leftIndex, <span class="type">int</span> midIndex, <span class="type">int</span> rightIndex, <span class="type">int</span>&amp; maxLeftIndex, <span class="type">int</span>&amp; maxRightIndex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> maxSumLeft = -INT_MAX;</span><br><span class="line">	<span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = midIndex; i &gt;= leftIndex; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		sum += originArray[i];</span><br><span class="line">		<span class="keyword">if</span> (sum &gt; maxSumLeft)</span><br><span class="line">		&#123;</span><br><span class="line">			maxLeftIndex = i;</span><br><span class="line">			maxSumLeft = sum;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> maxSumRight = -INT_MAX;</span><br><span class="line">	sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = midIndex + <span class="number">1</span>; i &lt;= rightIndex; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		sum += originArray[i];</span><br><span class="line">		<span class="keyword">if</span> (sum &gt; maxSumRight)</span><br><span class="line">		&#123;</span><br><span class="line">			maxRightIndex = i;</span><br><span class="line">			maxSumRight = sum;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> maxSumLeft + maxSumRight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Analyzing-the-divide-and-conquer-algorithm"><a href="#Analyzing-the-divide-and-conquer-algorithm" class="headerlink" title="Analyzing the divide-and-conquer algorithm"></a>Analyzing the divide-and-conquer algorithm</h3><p>分治法求最大子数组的是将原问题拆分为三个部分，（1）求左半部分的最大子数组 （2）求右半部分的最大子数组（3）求交叉部分的最大子数组，所以我们可以将原问题的时间花费$T(n)$改写为</p>
<script type="math/tex; mode=display">
T(n)=\Theta(1)+2T(n/2)+\Theta(n)+\Theta(1) \\\\
    =2T(n/2)+\Theta(n)</script><p>其中两个$\Theta(1)$分别表示拆分问题和合并答案的时间，$\Theta(n)$表示求交叉最大子数组的时间。</p>
<p>这个表达式与归并排序的表达式相同，所以我们可以得出求最大子数组的分治法复杂度为$T(n)=\Theta(n\lg(n))$</p>
<h2 id="Strassen’s-algorithms-for-matrix-multiplication"><a href="#Strassen’s-algorithms-for-matrix-multiplication" class="headerlink" title="Strassen’s algorithms for matrix multiplication"></a>Strassen’s algorithms for matrix multiplication</h2><p>对于两个大小为$n\times n$的矩阵$A$和$B$，它们的乘积$C=A\cdot B$中的每个元素$c_{ij}, i,j = 1,2,\dotsc n$，可表示为：</p>
<script type="math/tex; mode=display">
c_{ij}=\sum_{k=1}^{n}a_{ik}\cdot b_{kj}</script><p>该方法用伪代码可表示为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SQUARE-MATRIX-MULTIPLY(A,B)</span><br><span class="line">n= A.rows</span><br><span class="line">let C be a new n*n matrix</span><br><span class="line">for i = 1 to n</span><br><span class="line">	for j = 1 to n</span><br><span class="line">		c_ij = 0</span><br><span class="line">		for k = 1 to n</span><br><span class="line">			c_ij=c_ij+a_ik*b_kj</span><br><span class="line">return C</span><br></pre></td></tr></table></figure>
<p>c++实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Matrix <span class="title">MatrixMultiply</span><span class="params">(<span class="type">const</span> Matrix&amp; A, <span class="type">const</span> Matrix&amp; B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Matrix <span class="title">result</span><span class="params">(A.row, B.column)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.row; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; B.column; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; A.column; k++)</span><br><span class="line">			&#123;</span><br><span class="line">				result.data[i][j] = result.data[i][j] + A.data[i][k] * B.data[k][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>伪代码实现假设相乘的两个矩阵大小都是$n\times n$，在c++实现中可以是任意满足矩阵相乘的条件的矩阵大小。</li>
</ul>
<p>可以很容易的看出，<code>SQUARE-MATRIX-MULTIPLY</code>的复杂度为$O(n^3)$</p>
<h3 id="A-simple-dividea-and-conquer-algorithm"><a href="#A-simple-dividea-and-conquer-algorithm" class="headerlink" title="A simple dividea-and-conquer algorithm"></a>A simple dividea-and-conquer algorithm</h3><p>可以用分治法来解决矩阵相乘问题，为了简化问题，假设两个相乘的矩阵大小都是$n\times n$，且$n$的值为某个2的次幂。</p>
<p>首先将两个相乘的矩阵都拆成四部分，即每部分的长度为$n/2$，可以将每部分都看作是一个简单元素，于是问题转换为了两个$2\times2$矩阵的运算（两个$2\times2$矩阵中的每个元素都是一个子矩阵）。对于其中子矩阵相乘的计算可使用相同策略，即再进一步拆分成四个更小的子矩阵。</p>
<p>数学说明如下，A和B为两个相乘的矩阵，C为结果矩阵：</p>
<script type="math/tex; mode=display">
A=\begin{pmatrix}
    A_{11} & A_{12}\\\\
    A_{21} & A_{22}
\end{pmatrix}</script><script type="math/tex; mode=display">
B=\begin{pmatrix}
    B_{11} & B_{12}\\\\
    B_{21} & B_{22}
\end{pmatrix},</script><script type="math/tex; mode=display">
C=\begin{pmatrix}
    C_{11} & C_{12}\\\\
    C_{21} & C_{22}
\end{pmatrix}</script><script type="math/tex; mode=display">

C=A \cdot B =\begin{pmatrix}
    C_{11} & C_{12}\\\\
    C_{21} & C_{22}
\end{pmatrix}=\begin{pmatrix}
    A_{11} & A_{12}\\\\
    A_{21} & A_{22}
\end{pmatrix}\cdot \begin{pmatrix}
    B_{11} & B_{12}\\\\
    B_{21} & B_{22}
\end{pmatrix}</script><p>C中的各子矩阵的计算可以看作是普通元素的计算，即满足：</p>
<script type="math/tex; mode=display">
C_{11}=A_{11}\cdot B_{11} +A_{12} \cdot B_{21}\\\\
C_{12}=A_{11}\cdot B_{12} +A_{12} \cdot B_{22}\\\\
C_{21}=A_{21}\cdot B_{11} +A_{22} \cdot B_{21}\\\\
C_{22}=A_{21}\cdot B_{12} +A_{22} \cdot B_{22}\\\\</script><p>可以看到，需要8个子矩阵的相乘，每个子矩阵的大小是$n/2$，即将问题拆分成了8个子问题。</p>
<p>分治计算矩阵相乘的伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SQUARE-MATRIX-MULTIPLY-RECURSIVE(A,B)</span><br><span class="line"></span><br><span class="line">n = a.rows;</span><br><span class="line">let C be a new n*n matrix</span><br><span class="line">if n == 1</span><br><span class="line">	c_11=a_11 * b_11</span><br><span class="line">else</span><br><span class="line">	divide A,B,C into 4 submatrix</span><br><span class="line">	C_11 = SQUARE-MATRIX-MULTIPLY-RECURSIVE(A_11,B_11)+</span><br><span class="line">		SQUARE-MATRIX-MULTIPLY-RECURSIVE(A_12,B_21)</span><br><span class="line">	C_12 = SQUARE-MATRIX-MULTIPLY-RECURSIVE(A_11,B_22)+</span><br><span class="line">		SQUARE-MATRIX-MULTIPLY-RECURSIVE(A_12,B_22)</span><br><span class="line">	C_21 = SQUARE-MATRIX-MULTIPLY-RECURSIVE(A_21,B_11)+</span><br><span class="line">		SQUARE-MATRIX-MULTIPLY-RECURSIVE(A_22,B_21)</span><br><span class="line">	C_12 = SQUARE-MATRIX-MULTIPLY-RECURSIVE(A_21,B_12)+</span><br><span class="line">		SQUARE-MATRIX-MULTIPLY-RECURSIVE(A_22,B_22)</span><br><span class="line">return C</span><br></pre></td></tr></table></figure>
<p>其中<code>divide A,B,C into 4 submatrix</code>将产生3*4个子矩阵，每个子矩阵的大小为$n/2$，创建子矩阵时需要拷贝数据，即这操作的总时间复杂度为$\Theta(n^2)$。</p>
<p>另外计算$C$的各部分时，需要将迭代得到的数据进行累加，每次累加的对象都是一个大小为$n/2$的子矩阵，因此这些累加操作的时间复杂度也为$\Theta(n^2)$。</p>
<p>综上，这个分治法的时间表达式为$T(n)=8T(n/2)+\Theta(n^2)$。根据之后的章节可得知，该式子符合主方法的第一个情况，因此复杂度为$O(n^3)$。</p>
<p>伪代码中的创建子矩阵和数据拷贝的相关操作实际上是可以通过指针操作来省掉的，如以下C++实现，通过函数的形参来标识子矩阵的位置和大小：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Matrix* <span class="title">MatrixMultiply_Recursive</span><span class="params">(Matrix* A, Matrix* B, Matrix* result, <span class="type">int</span> resultStartRow, <span class="type">int</span> resultStartCol,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">int</span> aStartRow, <span class="type">int</span> aStartCol, <span class="type">int</span> bStartRow, <span class="type">int</span> bStartColumn, <span class="type">int</span> subMatSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//This method assume that the size of Matrix is n*n where n is an exact power of 2</span></span><br><span class="line">	<span class="comment">//StartRow and startColumn indicate where subMatrix starts, three pairs of value individually for A,B and result</span></span><br><span class="line">	<span class="comment">//The subMatrix of A and B should be the same size, so there is only on subMatrixSize value</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (result == <span class="literal">nullptr</span>)</span><br><span class="line">		result = <span class="keyword">new</span> <span class="built_in">Matrix</span>(A-&gt;row, B-&gt;column);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (subMatSize == <span class="number">1</span>)</span><br><span class="line">		result-&gt;data[resultStartRow][resultStartCol] = result-&gt;data[resultStartRow][resultStartCol] + A-&gt;data[aStartRow][aStartCol] * B-&gt;data[bStartRow][bStartColumn];</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		subMatSize /= <span class="number">2</span>;</span><br><span class="line">		<span class="comment">//result 11</span></span><br><span class="line">		<span class="built_in">MatrixMultiply_Recursive</span>(A, B, result, resultStartRow, resultStartCol, aStartRow, aStartCol, bStartRow, bStartColumn, subMatSize);<span class="comment">//A11*B11</span></span><br><span class="line">		<span class="built_in">MatrixMultiply_Recursive</span>(A, B, result, resultStartRow, resultStartCol, aStartRow, aStartCol + subMatSize, bStartRow + subMatSize, bStartColumn, subMatSize);<span class="comment">//A12*B21;</span></span><br><span class="line">		<span class="comment">//result 12</span></span><br><span class="line">		<span class="built_in">MatrixMultiply_Recursive</span>(A, B, result, resultStartRow, resultStartCol + subMatSize, aStartRow, aStartCol, bStartRow, bStartColumn + subMatSize, subMatSize);<span class="comment">//A11*B12</span></span><br><span class="line">		<span class="built_in">MatrixMultiply_Recursive</span>(A, B, result, resultStartRow, resultStartCol + subMatSize, aStartRow, aStartCol + subMatSize, bStartRow + subMatSize, bStartColumn + subMatSize, subMatSize);<span class="comment">//A12*B22</span></span><br><span class="line">		<span class="comment">//result 21</span></span><br><span class="line">		<span class="built_in">MatrixMultiply_Recursive</span>(A, B, result, resultStartRow + subMatSize, resultStartCol, aStartRow + subMatSize, aStartCol, bStartRow, bStartColumn, subMatSize);<span class="comment">//A21*B11</span></span><br><span class="line">		<span class="built_in">MatrixMultiply_Recursive</span>(A, B, result, resultStartRow + subMatSize, resultStartCol, aStartRow + subMatSize, aStartCol + subMatSize, bStartRow + subMatSize, bStartColumn, subMatSize);<span class="comment">//A22*B21</span></span><br><span class="line">		<span class="comment">//result 22</span></span><br><span class="line">		<span class="built_in">MatrixMultiply_Recursive</span>(A, B, result, resultStartRow + subMatSize, resultStartCol + subMatSize, aStartRow + subMatSize, aStartCol, bStartRow, bStartColumn + subMatSize, subMatSize);<span class="comment">//A21*B12</span></span><br><span class="line">		<span class="built_in">MatrixMultiply_Recursive</span>(A, B, result, resultStartRow + subMatSize, resultStartCol + subMatSize, aStartRow + subMatSize, aStartCol + subMatSize, bStartRow + subMatSize, bStartColumn + subMatSize, subMatSize);<span class="comment">//A22*B22</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意上述C++实现中，子矩阵结果的累加也放到了$n==1$情况下处理，因此整个算法的时间复杂度可表示为$T=8T(n/2)$</p>
<p>虽然少了后置项$\Theta(n^2)$，但此式仍然是满足主方法的第一种情况，且结果仍然是$T=\Theta(n^3)$</p>
<h3 id="Strassen’s-method"><a href="#Strassen’s-method" class="headerlink" title="Strassen’s method"></a>Strassen’s method</h3><p>在上述的分治法中，一共需要8次子矩阵的相乘才能得到最终结果。而在施特拉森方法（Stressen’s method）中，仅需要7次子矩阵的相乘。</p>
<p>如上节一样，将A，B视作两个需要相乘的矩阵，矩阵大小都是$n\times n$，且$n$的值为某个2的次幂。C为相乘的结果。</p>
<p>施特拉森方法的步骤如下：</p>
<ol>
<li>将A，B，C各拆分成四部分。</li>
<li>创建10个矩阵 $S<em>1 \dotsc S</em>{10}$，每个子矩阵的大小都是$n/2$。这10个矩阵的值都可以通过A，B的子矩阵相互加减得到。</li>
<li>创建7个矩阵，$P_1 \dotsc P_7$，每个子矩阵的值都可以通过步骤2的10个矩阵与A，B的子矩阵相乘得到。</li>
<li>结果C的4个子矩阵，可以通过步骤3中的7个矩阵加减得到。</li>
</ol>
<p>步骤1如果通过拷贝，则时间复杂度为$\Theta(n^2)$，如果通过指针操作，时间复杂度为$\Theta(1)$<br>步骤2是加减操作，所以时间复杂度为$\Theta(n^2)$<br>步骤3是子矩阵的相乘，但是与分治法不同的是，这里只需要7个矩阵的相乘操作，即原问题拆分为了7个子问题。<br>步骤3是加减操作，所以时间复杂度为$\Theta(n^2)$。</p>
<p>可以看出，施特拉森方法的时间复杂度表达式为：</p>
<p>$T(n)=7T(n/2)+\Theta(n^2)$</p>
<p>符合主方法的第一种情况，可得出时间复杂度为$T(n)=O(n^{\lg 7})$，比递归法求解矩阵相乘效率更高。</p>
<p>步骤2的10个矩阵的值具体计算如下：</p>
<script type="math/tex; mode=display">
S_1=B_{12}-B_{22} \\\\
S_2 = A_{11} +A_{12} \\\\
S_3 = A_{21}+A_{22} \\\\ 
S_4 = B_{21}-B_{11} \\\\
S_5 = A_{11}+A_{22} \\\\
S_6 = B_{11}+B_{22} \\\\
S_7 = A_{12}-A_{22} \\\\ 
S_8 = B_{21}+B_{22} \\\\
S_9 = A_{11}-A_{21} \\\\
S_{10} = B_{11}+B_{12} :</script><p>步骤3的7个矩阵的值具体计算如下：</p>
<script type="math/tex; mode=display">
P_{1} = A_{11} \cdot S_{1} =  A_{11} \cdot B_{12} - A_{11} \cdot B_{22}\\\\
P_{2} = S_{2}  \cdot B_{22} = A_{11} \cdot B_{22} + A_{12} \cdot B_{22}\\\\
P_{3} = S_{3}  \cdot B_{11} = A_{21} \cdot B_{11} + A_{22} \cdot B_{11}\\\\
P_{4} = A_{22} \cdot S_{4} =  A_{22} \cdot B_{21} - A_{22} \cdot B_{11}\\\\
P_{5} = S_{5}  \cdot S_{6} =  A_{11} \cdot B_{11} + A_{11} \cdot B_{22} + A_{22} \cdot B_{11} + A_{22} \cdot B_{22}\\\\
P_{6} = S_{7}  \cdot S_{8} =  A_{12} \cdot B_{21} + A_{12} \cdot B_{22} - A_{22} \cdot B_{21} - A_{22} \cdot B_{22}\\\\
P_{7} = S_{9}  \cdot S_{10} = A_{11} \cdot B_{11} + A_{11} \cdot B_{12} - A_{21} \cdot B_{11} - A_{21} \cdot B_{12}</script><p>可以发现最终7个矩阵的计算都可以通过A和B的子矩阵获得，即在实际算法的实现中，可以跳过步骤2中关于$S_1 \dotsc S_10$的实现。</p>
<p>步骤4的C子矩阵值计算如下：</p>
<script type="math/tex; mode=display">
C_{11}=P_{5} +P_{4}-P_{2}+P_{6} \\\\
C_{12}=P_{1} +P_{2} \\\\
C_{21}=P_{3} +P_{4} \\\\
C_{22}=P_{5} +P_{1}-P_{3}+P_{7} \\\\</script><p>完整的C++实现如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Matrix <span class="title">MatrixMultiply_Strassen</span><span class="params">(<span class="type">const</span> Matrix&amp; A, <span class="type">const</span> Matrix&amp; B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (A.row == <span class="number">1</span> &amp;&amp; A.column == <span class="number">1</span> &amp;&amp; B.row == <span class="number">1</span> &amp;&amp; B.column == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">Matrix <span class="title">result</span><span class="params">(A.row, B.column)</span></span>;</span><br><span class="line">		result.data[<span class="number">0</span>][<span class="number">0</span>] += A.data[<span class="number">0</span>][<span class="number">0</span>] * B.data[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		Matrix A_11 = <span class="built_in">createSubMatrix</span>(A, <span class="number">0</span>, <span class="number">0</span>, A.row / <span class="number">2</span>), A_12 = <span class="built_in">createSubMatrix</span>(A, <span class="number">0</span>, A.column / <span class="number">2</span>, A.row / <span class="number">2</span>);</span><br><span class="line">		Matrix A_21 = <span class="built_in">createSubMatrix</span>(A, A.row / <span class="number">2</span>, <span class="number">0</span>, A.row / <span class="number">2</span>), A_22 = <span class="built_in">createSubMatrix</span>(A, A.row / <span class="number">2</span>, A.column / <span class="number">2</span>, A.row / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">		Matrix B_11 = <span class="built_in">createSubMatrix</span>(B, <span class="number">0</span>, <span class="number">0</span>, B.row / <span class="number">2</span>), B_12 = <span class="built_in">createSubMatrix</span>(B, <span class="number">0</span>, B.column / <span class="number">2</span>, B.row / <span class="number">2</span>);</span><br><span class="line">		Matrix B_21 = <span class="built_in">createSubMatrix</span>(B, B.row / <span class="number">2</span>, <span class="number">0</span>, B.row / <span class="number">2</span>), B_22 = <span class="built_in">createSubMatrix</span>(B, B.row / <span class="number">2</span>, B.column / <span class="number">2</span>, B.row / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">		Matrix P_1 = <span class="built_in">MatrixMultiply_Strassen</span>(A_11, B_12) - (<span class="built_in">MatrixMultiply_Strassen</span>(A_11, B_22));</span><br><span class="line">		Matrix P_2 = <span class="built_in">MatrixMultiply_Strassen</span>(A_11, B_22) + (<span class="built_in">MatrixMultiply_Strassen</span>(A_12, B_22));</span><br><span class="line">		Matrix P_3 = <span class="built_in">MatrixMultiply_Strassen</span>(A_21, B_11) + (<span class="built_in">MatrixMultiply_Strassen</span>(A_22, B_11));</span><br><span class="line">		Matrix P_4 = <span class="built_in">MatrixMultiply_Strassen</span>(A_22, B_21) - (<span class="built_in">MatrixMultiply_Strassen</span>(A_22, B_11));</span><br><span class="line">		Matrix P_5 = <span class="built_in">MatrixMultiply_Strassen</span>(A_11, B_11) + (<span class="built_in">MatrixMultiply_Strassen</span>(A_11, B_22)) + (<span class="built_in">MatrixMultiply_Strassen</span>(A_22, B_11)) + (<span class="built_in">MatrixMultiply_Strassen</span>(A_22, B_22));</span><br><span class="line">		Matrix P_6 = <span class="built_in">MatrixMultiply_Strassen</span>(A_12, B_21) + (<span class="built_in">MatrixMultiply_Strassen</span>(A_12, B_22)) - (<span class="built_in">MatrixMultiply_Strassen</span>(A_22, B_21)) - (<span class="built_in">MatrixMultiply_Strassen</span>(A_22, B_22));</span><br><span class="line">		Matrix P_7 = <span class="built_in">MatrixMultiply_Strassen</span>(A_11, B_11) + (<span class="built_in">MatrixMultiply_Strassen</span>(A_11, B_12)) - (<span class="built_in">MatrixMultiply_Strassen</span>(A_21, B_11)) - (<span class="built_in">MatrixMultiply_Strassen</span>(A_21, B_12));</span><br><span class="line"></span><br><span class="line">		Matrix C_11 = P_5 + (P_4)-(P_2)+(P_6);</span><br><span class="line">		Matrix C_12 = P_1 + (P_2);</span><br><span class="line">		Matrix C_21 = P_3 + (P_4);</span><br><span class="line">		Matrix C_22 = P_5 + (P_1)-(P_3)-(P_7);</span><br><span class="line"></span><br><span class="line">		<span class="function">Matrix <span class="title">result</span><span class="params">(C_11, C_12, C_21, C_22)</span></span>;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="The-substitution-method-for-solving-recurrences"><a href="#The-substitution-method-for-solving-recurrences" class="headerlink" title="The substitution method for solving recurrences"></a>The substitution method for solving recurrences</h2><p>代入法求迭代复杂度分为两步：</p>
<ol>
<li>猜出解的表达形式</li>
<li>用数学归纳法找出解的常数并证明解是正确的。</li>
</ol>
<p>如有表达式</p>
<script type="math/tex; mode=display">T(n)=2T(\lfloor n/2 \rfloor)+n</script><p>表达式的形式与归并排序算法很类似，所以我们时间复杂度为$T(n)=O(n\lg n)$。需要证明的是，存在某正常数$c$使得$T(n)\leq cn\lg n$。</p>
<p>根据数学归纳法，先假设存在一个$m&lt;n$，对于$m$表达式成立，在这里将$m$取$\lfloor n/2 \rfloor$，如果上述表达式对于$\lfloor n/2 \rfloor$成立，所以$T(\lfloor n/2 \rfloor)\leq \lfloor n/2\rfloor \lg(\lfloor n/2\rfloor)$，代入原表达式，原表达式为</p>
<script type="math/tex; mode=display">
T(n)\leq 2(c\lfloor n/2\rfloor \lg(\lfloor n/2\rfloor))+n \\\\
\leq cn \lg(n/2)+n \\\\
= cn\lg n-cn\lg 2+n \\\\
= cn\lg n +(1-c)n</script><p>所以只要取$c\leq1$即能满足$n$也符合猜测。</p>
<p>注意，在数学归纳法中，边界条件也要符合猜测，在本例中，如果$T(1)$即为第一个表达式，那么需要满足$T(1)\leq 1\lg(1)=0$，但往往在$T(1)$情况下，时间为常量，于是这就存在了矛盾。为了解决这个矛盾，我们可以假设式子是在大于一个常数$n_0$情况下才满足，那么边界条件也就成为了$n_0$。</p>
<h3 id="Subtleties"><a href="#Subtleties" class="headerlink" title="Subtleties"></a>Subtleties</h3><p>有的时候，我们可以猜出正确的表达式，但是无法正确的证明，如表达式</p>
<script type="math/tex; mode=display">
T(n)=T(\lfloor n/2 \rfloor)+T(\lceil n/2 \rceil)+1</script><p>猜测时间复杂度为$T(n)=O(n)$，于是尝试想证明$T(n) \leq cn$，同样我们假设在$&lt;n$的情况下条件满足，即</p>
<script type="math/tex; mode=display">
T(n) \leq c\lfloor n/2 \rfloor + c \lceil n/2 \rceil+1 \\\\
=cn+1</script><p>这只能表明，$T(n)\leq cn+1$但不能证明想要的$T(n)\leq cn$。</p>
<p>但可以通过一个有更低项的表达式来证明我猜测，如$T(n)=cn-d$，$d$为大于0的常数，代入上式得，</p>
<script type="math/tex; mode=display">
T(n) \leq (c\lfloor n/2 \rfloor -d)+ (c \lceil n/2 \rceil -d )+1 \\\\
=cn-2d+1\\\\
=cd -d -(1-d)</script><p>那么只要取$d\geq 1$就能满足猜测表达式。</p>
<p>这与通常的直觉相反，因为我们在证明$T(n)=cn$时失败了，那在再次尝试时，应该猜一个值更大的函数，但是我们用了一个值更小（减去了一个更小项）的函数却证明成功了。这是因为通常猜测的表达式越接近答案，证明过程也就越严格，所以我们取了一个相离较远相对宽松的值反而容易证明。</p>
<h3 id="Avoiding-pitfalls"><a href="#Avoiding-pitfalls" class="headerlink" title="Avoiding pitfalls"></a>Avoiding pitfalls</h3><p>避免跌入证明的陷阱里，我们在证明时要确认最终的表达式确实是我们想要的式子。例如在猜测式子$T(n)=2T(\lfloor n/2 \rfloor)+n$的复杂度，猜测$T(n)=O(n)$，即需要证明$T(n)\leq cn$，代入式子可得</p>
<script type="math/tex; mode=display">
T(n)\leq 2(c\lfloor n/2 \rfloor)+n \\\\
\leq cn+n \\\\
= (c+1)n</script><p>这时候很容易错误的认为$\leq (c+1)n$即满足了$\leq cn$，但$c$是我们指定的常量，小于$c+1$并不一定小于$c$，所以猜测并不成立。</p>
<h3 id="Changing-variables"><a href="#Changing-variables" class="headerlink" title="Changing variables"></a>Changing variables</h3><p>有时候一些代数变换可以帮助猜测出解，如有式子</p>
<script type="math/tex; mode=display">
T(n)=2T(\lfloor \sqrt{n} \rfloor)+\lg n</script><p>可以将$m=\lg n$即$n=2^m$代入上式，得</p>
<script type="math/tex; mode=display">
T(2^m)=2T(2^{m/2})+m</script><p>再将$T(2^m)$的关系表示为$S(m)$，得</p>
<script type="math/tex; mode=display">
S(m)=2S(\frac{m}{2})+m</script><p>此时，式子的表达与归并排序相同，所以可得$S(m)=O(m\lg m)$，将$m= \lg n$带回式子，得</p>
<script type="math/tex; mode=display">
S(\lg n)=O(\lg n \lg \lg n)</script><p>又$S(m)=T(2^m)$所以$S(\lg n)=T(2^{\lg n})=T(n)$</p>
<p>所以</p>
<script type="math/tex; mode=display">
T(n)=O(\lg n \lg \lg n)</script><h2 id="The-recursion-tree-method-for-solving-recurrences"><a href="#The-recursion-tree-method-for-solving-recurrences" class="headerlink" title="The recursion-tree method for solving recurrences"></a>The recursion-tree method for solving recurrences</h2><p>在递归树中，每一个节点都表示一个子问题的花费，整个问题的时间花费即为所有节点的花费总和。在计算时我们通常计算树的每一层的花费，然后再将所有的层数花费累加进而得到整棵树的花费。</p>
<p>通常在使用递归树时，我们会<strong>忽略一些细节</strong>，得到一个近似的答案作为猜测，再使用代入法去验证。当然也可以事无巨细的使用递归树来作为时间复杂度的证明。</p>
<p>如需要求得式子$T(n)=3T(\lfloor n/4 \rfloor)+\Theta(n^2)$的时间复杂度，我们首先忽略向下取整，变为求式子$T(n)=3T(n/4)+cn^2$</p>
<p>这个式子可以拆分为下图所示</p>
<p><img src="IA-Chapter4-Notes/2019-10-21-00-14-20.png" alt="递归树_1"></p>
<p>$T(\frac{n}{4})$又可以表达为$T(\frac{n}{4})=3T(\frac{n}{16})+c(\frac{n}{4})^2$，于是树可以进一步拆分为：</p>
<p><img src="IA-Chapter4-Notes/2019-10-21-00-16-06.png" alt="递归树_2"></p>
<p>同理类推，最终树可以拆分为:</p>
<p><img src="IA-Chapter4-Notes/2019-10-21-00-17-03.png" alt="递归树_3"></p>
<p>每一层都对需要平方的$n$除以4，直到最后变为1，设最后一层（数值为1）的层数为$i$，则有表达式</p>
<script type="math/tex; mode=display">\frac{n}{4^i}=1</script><p>注意，这里的x取值是从0，所以第一层的数值为$n(\frac{1}{4})^0=n$，求得最后一层的层数为</p>
<script type="math/tex; mode=display">i=\log_4n</script><ul>
<li>因为是从0开始，所以总层数为$\log_4n+1$</li>
</ul>
<p>设行数为$i$，则每一层的节点数为$3^i$，每个节点为$c(\frac{n}{4^i})^2$，所以每一层的值为</p>
<script type="math/tex; mode=display">
3^ic(\frac{n}{4^i})^2\\\\
=(\frac{3}{16})^icn^2</script><p>所以整棵树的时间为</p>
<script type="math/tex; mode=display">
T(n)=\sum_{i=0}^{\log_4n-1}(\frac{3}{16})^icn^2+3^ {\log_4n}\Theta(1)\\\\
    =\sum_{i=0}^{\log_4n-1}(\frac{3}{16})^icn^2+ n\log_43\Theta(1)\\\\
    =\sum_{i=0}^{\log_4n-1}(\frac{3}{16})^icn^2+ \Theta(n\log_43)</script><p>上式为等比数列，可以套等比数列公式求得，但我们可以先进一步简化</p>
<script type="math/tex; mode=display">
T(n)=\sum_{i=0}^{\log_4n-1}(\frac{3}{16})^icn^2+ \Theta(n\log_43) \\\\
\leq \sum_{i=0}^{\infty}(\frac{3}{16})^icn^2+ \Theta(n\log_43) \\\\</script><p>这时套入等比公式</p>
<script type="math/tex; mode=display">\sum _{k=0}^{\infty}x^k=\frac{1}{1-x}</script><p>可得</p>
<script type="math/tex; mode=display">
T(n)\leq \sum_{i=0}^{\infty}(\frac{3}{16})^icn^2+ \Theta(n\log_43) \\\\
    =\frac{1}{1-{\frac{3}{16}}}cn^2+\Theta(n\log_43) \\\\
    =\frac{16}{13}n^2+\Theta(n\log_43)\\\\
    =0(n^2)</script><p><strong>之后可以用代入法来验证结果</strong></p>
<p>需要证明的就是$T(n)\leq dn^2$</p>
<script type="math/tex; mode=display">
T(n^2)\leq 3d(n/4)^2+cn^2////
=\frac{3}{16}dn^2+cn^2</script><p>只要$\frac{3}{16}d+c$&lt;$d$，即可满足条件，即$d\geq \frac{16}{13}c$即可</p>
<h2 id="The-Master-method-for-solving-recurrences"><a href="#The-Master-method-for-solving-recurrences" class="headerlink" title="The Master method for solving recurrences"></a>The Master method for solving recurrences</h2><p>主方法提供了针对形如$T(n)=aT(n/b)+f(n)$的一系列迭代算法的复杂度计算套用公式。</p>
<p>主方法定理存在三个情况：</p>
<ol>
<li>如果存在常量$\epsilon$满足$f(n)=O(n^{\log_ba-\epsilon})$，则$T(n)=\Theta(n^{\log _ba})$</li>
<li>如果有$f(n)=\Theta(n^{\log_ba})$，则$T(n)=\Theta(n^{\log_ba}\lg n)$</li>
<li>如果存在常量满足$f(n)=\Omega(n^{\log_ba+\epsilon})$，且对于足够大的$n$，存在常量$c&lt;1$满足$af(n/b)\leq cf(n)$，则$T(n)=\Theta(f(n))$</li>
</ol>
<p>可以发现定理的三个情况都是$f(n)$对$n^{\log_ba}$的比较。而且要注意$\epsilon$的存在，他表示关系式都必须是多项式渐进大于或多项式渐进小于。需要“即使相差一个因子$n^\epsilon$，不等式仍然成立“。</p>
<h3 id="Using-the-master-method"><a href="#Using-the-master-method" class="headerlink" title="Using the master method"></a>Using the master method</h3><ol>
<li><p>式子$T(n)=9T(n/3)+n$</p>
<p> 可知$a=9,b=3,f(n)=n$，$n^{\log_ba}=n^2$，只要$\epsilon&lt;=1$，都可满足$f(n)=O(n^{\log_ba-\epsilon})$，符合条件一，时间复杂度为$T(n)=\Theta(n^2)$</p>
</li>
<li><p>式子$T(n)=T(2n/3)+1$</p>
<p> 可知$a=1,b=3/2,f(n)=1$，$n^{\log_ba}=n^{\log_3/21}=n^0=1$，即$f(n)=1=\Theta(1)=\Theta(n^{\log_ba})$，所以满足条件二，时间复杂度为$T(n)=\Theta(\lg n)$</p>
</li>
<li><p>式子$T(n)=3T(n/4)+n\lg n$</p>
<p> 可知$a=3,b=4,f(n)=n\lg n,n^{\log_ba}=n^{\log_43}=n^{0.793}$，取$\epsilon$足够小，如取0.1则满足$f(n)=n\lg n=\Omega (n^{0.89})$</p>
<p> 如果要满足条件三，仍然需要满足，存在$c$使得$af(n/b)\leq cf(n)$，即需要满足$\frac{3n}{4}\lg \frac{n}{4}\leq cn\lg n$</p>
<script type="math/tex; mode=display">\frac{3n}{4}\lg \frac{n}{4}=\frac{3n}{4}\lg n -\frac{3}{2}n</script><p> 如果取$c=3/4$，则不等式可以转换为</p>
<script type="math/tex; mode=display">
 \frac{3n}{4}\lg n -\frac{3}{2}n \leq \frac{3n}{4}\lg n</script><p> 条件满足，所以原式子满足条件三，所以结果为$T(n)=\Theta(n\lg n)$</p>
</li>
<li><p>式子$T(n)=2T(n/2)+n\lg n$</p>
<p> 可知$a=2,b=2,f(n)=n\lg n,n^{\log_ba}=n$</p>
<p> 因为$f(n)=n\lg n$大于$n^{\log_ba}=n$，所以很容易误以为这个式子满足条件三，但实际上条件需要满足多项式渐进大于，在本例子中需要存在一个$\epsilon$，使得$\lg n$渐进大于$n^{\epsilon}$，但对于任意$\epsilon &gt;0$，这个式子都不满足。所以这个式子并不满足条件三，不能使用主方法来求得时间复杂度。</p>
</li>
</ol>
<h2 id="Proof-of-the-master-theorem"><a href="#Proof-of-the-master-theorem" class="headerlink" title="Proof of the master theorem"></a>Proof of the master theorem</h2><p>//TODO</p>
<div class="note info simple"><p>引用：</p>
<ol>
<li><em>Introduction to Algorithms</em> 3rd Sep.2009</li>
</ol>
</div>
<hr>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>《算法导论》 第五章笔记</title>
    <url>/IA-Chapter5-Notes/</url>
    <content><![CDATA[<p>《算法导论》 第五章笔记。</p>
<p>5.1节介绍了整章中作为例子的雇佣问题，并简单介绍了两个分析随机问题的方法，概率分析和随机化算法。</p>
<p>5.2节介绍了分析随机问题中的重要工具，指标随机变量，并使用概率分析方法分析了雇佣问题的平均花费。</p>
<p>5.3节使用随机化算法分析雇佣问题的期望花费，并且介绍了两种实现随机值产生器的方法。</p>
<p>5.4节尚未整理。</p>
<span id="more"></span>
<h1 id="Chapter-5-Probabilistic-Analysis-and-Randomized-Algorithms"><a href="#Chapter-5-Probabilistic-Analysis-and-Randomized-Algorithms" class="headerlink" title="Chapter 5 Probabilistic Analysis and Randomized Algorithms"></a>Chapter 5 Probabilistic Analysis and Randomized Algorithms</h1><h2 id="The-hiring-problem"><a href="#The-hiring-problem" class="headerlink" title="The hiring problem"></a>The hiring problem</h2><p>雇佣问题（Hiring Problem）是假设一个雇佣公司与一家HR服务公司签订协议帮助它雇佣一位秘书。HR服务公司会每天向雇佣公司提供一个候选人，雇佣公司将面试该候选人，如果候选人比现在的秘书优秀，则解雇现在的秘书，雇佣候选人。这个操作是每天都在进行的，即如果每天来的候选人都比前一天的更优秀，则会每天解雇昨天雇佣的人，然后再雇佣新的候选人。整个过程的伪代码实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HIRE-ASSISTANT(n)</span><br><span class="line">best = 0;</span><br><span class="line">for i = 1 to n</span><br><span class="line">    interview candidate i</span><br><span class="line">    if candidate i better than candidate best</span><br><span class="line">        best = i</span><br><span class="line">        hire candidate i</span><br></pre></td></tr></table></figure>
<p>雇佣公司需要为每一个候选人向HR服务公司付一笔钱，记为$C_i$，在正式雇佣员工时需要再额外付给HR服务公司一笔钱，这笔钱款项较大，记为$C_h$。在这个算法中，关心的复杂度<strong>不再是时间复杂度</strong>而是最终需要付给HR服务公司的钱的多少，如果候选人一共有$n$人，一共雇佣过其中$m$人，则算法的复杂度为$O(C_in+C_hm)$，其中$C_in$是固定的，主要需要关心的就是$C_hm$。</p>
<p>可以明显看出，$m$越大，即雇佣过的人越多，复杂度越高。而$m$的大小是与候选人的情况相关的。</p>
<h3 id="Worst-case-analysis"><a href="#Worst-case-analysis" class="headerlink" title="Worst-case analysis"></a>Worst-case analysis</h3><p>最坏情况下，即候选人是从最差到最好的顺序给的，那么$m=n$。在最好情况下，即候选人是从最好到最坏的顺序下给的，那么$m=1$。</p>
<p>但是最好和最差情况是很少出现的，所以需要真正关心的是通常情况下的花费，或者说各个情况下平均需要的花费。</p>
<p>这里先简单的阐述下概率分析方法和随机化算法方法，在6.2和6.3节会进行更详细的分析。</p>
<h3 id="Probabilistic-analysis"><a href="#Probabilistic-analysis" class="headerlink" title="Probabilistic analysis"></a>Probabilistic analysis</h3><p>概率分析（Probabilistic analysis）是通过概率来分析问题，通常使用概率分析来分析算法的运行时间，但这里用概率分析来分析雇佣的花费。</p>
<p>为了实施概率分析，需要知道所有输入情况的概率分布，或者猜测出一个所有输入情况的概率分布，然后根据这些输入情况的分布来计算出所有情况下的平均花费，将其称为<code>平均情况运行时间（Average-case running time）</code>。</p>
<p>对于雇佣问题而言，所有输入可能的概率是相同的，即这是个<code>均匀概率分布（Unifrom random permutation）</code>。对于一共有$n$个候选人，第一个候选人一共$n$种可能，第二个候选人有$n-1$种…依次类推，最后一个候选人就只有1种可能，综合起来看，$n$个候选人的排列组合有$n!$种可能，因此每个排列的可能性为$1/n!$</p>
<h3 id="Randomized-algorithms"><a href="#Randomized-algorithms" class="headerlink" title="Randomized algorithms"></a>Randomized algorithms</h3><p>为了使用概率分析的方法，需要知道输入的分布可能或者对分布可能进行一个猜测，在<code>随机化算法（Randomized algorithms）</code>中则不需要。可以使用随机函数<em>主动</em>的让算法中的一部分成为随机。</p>
<p>在雇佣问题中，无论输入是什么情况，每天都是随机的从输入中抽取一个候选人，这样无论输入是什么情况，算法的结果都由算法中随机函数部分决定。</p>
<p>称一个算法被<code>随机化（Randomized）</code>了，如果算法的结果不仅由输入决定，还由一个被<code>随机数生成器（Random-Nunmber generator）</code>产生的数值决定。</p>
<p>对于随机化算法的复杂度分析，是根据随机数生成器生成的数值的概率分布来计算出运行时间，将其称为<code>期望运行时间（Expected running time）</code>。</p>
<h2 id="Indicator-random-variables"><a href="#Indicator-random-variables" class="headerlink" title="Indicator random variables"></a>Indicator random variables</h2><p>指标随机变量（Indicator random variables）提供一个在概率（probabilities）和期望（expectations）之间转换的方法。事件$A$的指标随机变量$I{A}$定义为：</p>
<script type="math/tex; mode=display">
I\{A\}=\begin{cases}
    1 & \text{if A occurs,}\\\\
    0 & \text{if A does not occur.}
\end{cases}</script><p>举一个简单的例子说明指标随机变量与期望值的关系。假设翻转一枚硬币，将结果是正面称为事件$H$，是反面称为事件$T$，即样本空间为$S={H,T}$，其中两个事件的概率都为0.5，即$Pr{H}=Pr{T}=1/2$。</p>
<p>将事件$H$的指标随机变量定义为$X_H$，即</p>
<script type="math/tex; mode=display">
X_H=I\{H\}= \begin{cases}
    1 & \text{if H occurs,}\\\\
    0 & \text{if T occurs.}
\end{cases}</script><p>事件$H$的期望值为$E[X_H]$：</p>
<script type="math/tex; mode=display">
E[X_H]=E[I\{H\}]\\\\
= 1 \cdot Pr\{H\} + 0\cdot Pr\{T\} \\\\
= 1\cdot (1/2)+0\cdot(1/2)\\\\
=1/2</script><p>定理5.1： 给定一个样本空间$S$和一个事件$A$在样本空间中，定义$X_A=I{A}$，则$E[X_A]=Pr{A}$</p>
<p>证明如下：</p>
<script type="math/tex; mode=display">
E[X_A]=E[I\{A\}]\\\\
= 1 \cdot Pr\{A\} + 0\cdot Pr\{\bar{A}\} \\\\
= Pr\{A\}</script><h3 id="Analysis-of-hiring-problem-using-indicator-random-variables"><a href="#Analysis-of-hiring-problem-using-indicator-random-variables" class="headerlink" title="Analysis of hiring problem using indicator random variables"></a>Analysis of hiring problem using indicator random variables</h3><p>为了使用概率分析，假设候选人都是以一个随机的顺序出现（在5.3节使用随机化算法的话将不再需要这个假设）。将X作为随机变量，其值表示为整个面试过程中总计录用的次数。</p>
<p>根据期望随机变量的定义，可X的期望值可表示为：</p>
<script type="math/tex; mode=display">
E[X]=\sum_{x=1}^{n} x \cdot Pr\{\ X=x\}</script><p>该式子需要计算，$x=1,x=2\dotsc x=n$情况下的概率。这个概率的计算较为复杂，可以使用指标随机变量来简化上式。</p>
<p>将第$i$位候选人被录用的随机变量定义为$X_i$，则</p>
<script type="math/tex; mode=display">
X_i = I\{\text{candidate i is hired} \} =\\\\
=\begin{cases}
    1 & \text{if candidate i is hired} \\\\
    0 & \text{if candidate i is not hired}
\end{cases}</script><p>可知所有候选人录取的总次数是各个候选人被录取随机变量的总和，即$X=X_1+X_2+\dotsc + X_n$。</p>
<p>由根据定理5.1可知，$E[X_i]=Pr{\text{candidate i is hired} }$</p>
<p>第$i$个候选人前已经出现了$i-1$个候选人，加上第$i$个自己，一共有$i$个候选人且每个候选人被录取的概率相同，因此第$i$个候选人被录取的概率为$1/i$。</p>
<p>综上，可得</p>
<script type="math/tex; mode=display">
E[X] = E[\sum_{i=1}^{n}X_i] \\\\
= \sum_{i=1}^{n} E[X_i] \\\\
= \sum_{i=1}^{n} 1/i \\\\
= \ln n + O(1)</script><p>因此，使用概率分析可得平均情况下录取候选人的成本为$O(C_h \ln n)$</p>
<h2 id="Randomized-algorithms-1"><a href="#Randomized-algorithms-1" class="headerlink" title="Randomized algorithms"></a>Randomized algorithms</h2><p>随机化算法与概率分析两个方法的不同点在于，概率分析是假设一个输入的分布，而随机化算法是<strong>引入</strong>输入的分布。</p>
<p>概率分析下，对于一个算法，如果输入值是不变的，则结果也是不变的，不同的输入产生不同的值。</p>
<p>但是在随机化算法下，输入值不变也可能产生不同的结果，因为算法内部有随机生成器。也因此，没有特定的输入会产生最差情况。</p>
<p>随机化算法的伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RANDOMIZED-HIRE-ASSISTANT(n)</span><br><span class="line"></span><br><span class="line">randomly permute the list of candidates</span><br><span class="line">best = 0</span><br><span class="line">for i = 1 to n</span><br><span class="line">    interview candidate i</span><br><span class="line">    if candidate i is better than candidate best</span><br><span class="line">        best = i</span><br><span class="line">        hire candidate i</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>与之前算法的唯一不同就是引入了<code>randomly permute the list of candidates</code>。在执行了该语句，产生了随机输入后，剩余部分的分析如上节的概率分析一样。</p>
<ul>
<li>上节的输入分布是猜测出来的，而这里的输入分布则是通过该语句生成出来的。</li>
</ul>
<p>因此通过随机化算法也同样可以得到结论，录取候选人的成本为$O(C_h \ln n)$。但使用概率分析的时候，将结果称为<code>平均情况下的结果</code>，在使用随机化算法的时候，将结果称为<code>期望结果</code>。两者实际上非常相似，更多的是命名方面的区分。</p>
<h3 id="Randomly-permuting-arrays"><a href="#Randomly-permuting-arrays" class="headerlink" title="Randomly permuting arrays"></a>Randomly permuting arrays</h3><p>许多随机化算法都是通过随机排列输入数组来引入随机化的。</p>
<p>一个通常的随机排列数组的方法是给数组中的每个元素$A[i]$一个随机的优先级值$P[i]$，然后根据优先级值排列元素次序。如原始数组为${1,2,3,4}$，随即优先级值为${36,3,62,29}$，则原始数组排列为${2,4,1,3}$。</p>
<p>该方法伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PERMUTE-BY_SORTING(A)</span><br><span class="line">n = A.length</span><br><span class="line">let P[1..n] be a new array</span><br><span class="line">for i = 1 to n</span><br><span class="line">    P[i] = RANDOM(1,n^3)</span><br><span class="line">sort A using P as sort keys</span><br></pre></td></tr></table></figure>
<ul>
<li>在伪代码中，将$1\sim n^3$作为范围选取优先级值，是为了保证每个优先级值大概率是不一样的。在实际代码中，这样实现可能会产生问题。</li>
</ul>
<p>上述算法中<code>sort A using P as sort keys</code>的复杂度由所使用的排列算法决定，通常时间复杂度为$O(n\lg n)$。</p>
<p>还需要证明该算法产生的是均匀随机排列(<code>unifrom random permutation</code>)。在雇佣问题下，即证明每个排列的可能性是$1/n!$。</p>
<p>假设需要求所有候选人水平是递增的排列，第一个候选人有$n$种可能，他水平最低的可能性为$1/n$，第二个候选人在剩下的人（$n-1$）中水平最低的概率为$1/(n-1)$，之后的候选人概率依次类推。</p>
<p>将$E_i$定义为事件，第$i$个候选人水平第$i$低，则所有候选人水平是递增的概率为：</p>
<script type="math/tex; mode=display">
Pr\{E_1 \cap E_2 \cap E_3 \cap \dotsi \cap E_n\}\\\\
= Pr\{E_1\} \cdot Pr\{ E_2 | E_1\} \cdot Pr\{E3 | E_2 \cap E_1\} \cdot \dotsb Pr\{E_i | E_{i-1} \cap E_{i-1} \cap \dotsb \cap E_1 \}\\\\\dotsb Pr\{E_n | E_{n-1} \cap E_{i-1} \cap \dotsb \cap E_1 \} \\\\
= \frac{1}{n} \cdot \frac{1}{n-1} \cdot \dotsb \cdot \frac{1}{1}\\\\
= \frac{1}{n!}</script><p>这里是证明了所有候选人水平递增的排列出现概率为$1/n!$，用同样的方法可以证明其他的排列下概率也都为$1/n!$，因此得证。</p>
<p>还由一种随机排列的方法，是通过将$A[i]$与$A[i]\sim A[n]$间的一个元素互换生成随机数组排列，伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RANDOMIZE-IN-PLACE(A)</span><br><span class="line">n = A.length</span><br><span class="line">for i = 1 to n</span><br><span class="line">    swap A[i] with A[RaNDOM(i,n)]</span><br></pre></td></tr></table></figure>
<p>该算法的时间复杂度为$O(n)$。</p>
<p>同样需要证明该算法的输出结果满足均匀随机排列。</p>
<p>在一个有$n$个值的均匀随机排列中取连续$k$个值，取第一个值有$n$种可能，第二个有$n-1$种可能，第$k$个有$n-k+1$种可能。因此连续k个值的排列一共有$n!/(n-k)!$种可能性。</p>
<p>需要检测该算法是否满足此特性。</p>
<p>根据上式，对于第$i$个候选人，前面$i-1$个候选人的排列有$n!/(n-i+1)!$种可能，将前$i-1$个候选人的排列称为事件$E_1$。将第$i$个候选人的选人概率定义为$E_2$，因为第$i$个候选人是从$A[i \dotsb n]$中选取的，所以概率为$1/(n-i+1)$。</p>
<p>前$i$的候选人的排列是在事件$E_1$和事件$E_2$同时发生的情况下产生的，即</p>
<script type="math/tex; mode=display">
Pr\{E_2 \cap E_1 \} = Pr\{E_2 |E_1 \} \cdot Pr\{E_1 \} \\\\
= \frac{1}{n-i+1} \cdot \frac{n-i+1}{n!} \\\\
= \frac{(n-i)!}{n!}</script><p>满足均匀随机排列特性，因此得证。</p>
<p>当取$i=n$时，即$n$个候选人时某个排列组合的概率，可得$(n-i)!/n!=1/n!$，与概率分析的结果相同。</p>
<h2 id="Probabilistic-analysis-and-further-uses-of-indicator-random-variables"><a href="#Probabilistic-analysis-and-further-uses-of-indicator-random-variables" class="headerlink" title="Probabilistic analysis and further uses of indicator random variables"></a>Probabilistic analysis and further uses of indicator random variables</h2><p>//TODO </p>
<div class="note info simple"><p>引用：</p>
<ol>
<li><em>Introduction to Algorithms</em> 3rd Sep.2009</li>
</ol>
</div>
<hr>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>《算法导论》 第六章笔记</title>
    <url>/IA-Chapter6-Notes/</url>
    <content><![CDATA[<p>《算法导论》中第六章笔记。</p>
<p>关于堆与堆排序。</p>
<span id="more"></span>
<h1 id="Chapter-6-Heapsort"><a href="#Chapter-6-Heapsort" class="headerlink" title="Chapter 6 Heapsort"></a>Chapter 6 Heapsort</h1><p>如归并排序一样，堆排序的时间复杂度为$O(nlgn)$，但与归并排序不同的是，堆排序在运行过程中仅需要固定大小的外部空间，即运行时所需的内存不会因为输入规模的上升而上升，这一点与插入排序一样。</p>
<p>所以堆排序是结合了插入排序和归并排序两者的优点。</p>
<p>“堆”（Heap）这一称呼最早就是针对于堆排序的，但是在一些语言的垃圾回收概念中存在堆栈的概念。这两者虽然名字相同，但实际上是完全不同的存在。</p>
<h2 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h2><p><code>堆（Heap）</code>或称<code>二叉堆（Binary Heap）</code>是一种用数组来表示近似完全二叉树的数据结构。树中的每一个元素都对应数组中的一个元素，树除了最下面一层，其余层都是满的。</p>
<p>二叉堆与二叉树如下图所示：</p>
<p><img src="IA-Chapter6-Notes/2020-01-28-00-04-02.png" alt="二叉树与二叉堆"></p>
<p>在数组中，用一个变量<code>heap-size</code>来表示数组中真正元素的个数。如一个数组可能长度为10，但其中真正的元素个数为5，剩下的都为空，即$0\leq A.heap-size \leq A.length$。</p>
<p>树的根节点用$A[1]$表示，所有结点可根据以下伪代码计算其父结点，左子树以及右子树。这些操作都是单纯的乘二或除二，因此可以用位运算来实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PARENT(i)</span><br><span class="line">return i/2</span><br><span class="line"></span><br><span class="line">LEFT(i)</span><br><span class="line">return 2i</span><br><span class="line"></span><br><span class="line">RIGHT(i)</span><br><span class="line">return 2i+1</span><br></pre></td></tr></table></figure>
<p>c++ 实现如下，注意因为c++中的索引是从0开始，所以index值需要做相应调整：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">parent</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">ceil</span>(index / <span class="number">2.0</span>) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">left</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">right</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> index * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有两种二叉堆：<code>最大堆（max-heaps）</code>与<code>最小堆（min-heaps）</code>。对于最大堆，每个结点都需要满足<code>最大特性（max-heap property）</code>，即</p>
<script type="math/tex; mode=display">
A[Parent(i)] \geq A[i]</script><p>可以因此判断出在最大堆中最大的元素存储在根结点。同理最小堆需要满足$A[Parent(i)] \leq A[i]$，最小的元素存储在根结点。</p>
<ul>
<li>之后的几个章节都默认以最大堆作为对象进行分析</li>
</ul>
<p>将一个堆看作一棵树后，将一个结点的高度定义为这个结点到叶子的最长单一路径，一棵树的高度定义为根节点的高度。因为堆是近似完全二叉树，所以对于有$n$个结点的堆来说，其高度为$\Omega(\log n)$。</p>
<h2 id="Maintaining-the-heap-property"><a href="#Maintaining-the-heap-property" class="headerlink" title="Maintaining the heap property"></a>Maintaining the heap property</h2><p>通过函数<code>MAX-HEAPIFY</code>来保持堆的特性，该函数需要传入需要处理的数组$A$和需要进行处理的元素索引值$i$。</p>
<p>调用前默认元素$i$的左树$LEFT(i)$和右树$RIGHT(i)$都满足最大特性，但元素$i$本身可能违背，即元素$i$可能小于它的子结点。</p>
<p><code>MAX-HEAPIFY</code>操作是将值$A[i]$“向下沉”，即将更小的$A[i]$值向树的更底层传递，伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MAX-HEAPIFY(A,i)</span><br><span class="line">l = LEFT(i)</span><br><span class="line">r = RIGHT(i)</span><br><span class="line">if l &lt;= A.heapSize and A[l] &gt; A[i]</span><br><span class="line">    largest = l;</span><br><span class="line">else</span><br><span class="line">    largest = i;</span><br><span class="line">if r &lt;= A.heapSize and A[r] &gt; A[largest]</span><br><span class="line">    largest = r;</span><br><span class="line"></span><br><span class="line">if (largest != i)</span><br><span class="line">    exchange A[i] with A[largest]</span><br><span class="line">    MAX-HEAPIFY(A,largest)</span><br></pre></td></tr></table></figure>
<p>c++代码实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MaxHeapify</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> dataLength)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (index &gt;= dataLength)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Invalid index &quot;</span> &lt;&lt; index &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> largest = index;</span><br><span class="line">	<span class="type">int</span> lIndex = <span class="built_in">left</span>(index);</span><br><span class="line">	<span class="type">int</span> rIndex = <span class="built_in">right</span>(index);</span><br><span class="line">	<span class="keyword">if</span> (lIndex &lt; dataLength)</span><br><span class="line">		largest = dataArray[index] &gt; dataArray[lIndex] ? index : lIndex;</span><br><span class="line">	<span class="keyword">if</span> (rIndex &lt; dataLength)</span><br><span class="line">		largest = dataArray[rIndex] &gt; dataArray[largest] ? rIndex :largest;</span><br><span class="line">	<span class="keyword">if</span> (largest != index)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> temp = dataArray[index];</span><br><span class="line">		dataArray[index] = dataArray[largest];</span><br><span class="line">		dataArray[largest] = temp;</span><br><span class="line">		<span class="built_in">MaxHeapify</span>(largest, dataLength);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>伪代码中的<code>exchange</code>操作的结果就是值更大的结点向树的上方传递，值小的结点向树的下方下沉。</p>
<p>算法的图解如下：</p>
<p><img src="IA-Chapter6-Notes/2020-01-28-14-00-33.png" alt="MAX-HEAPIFY算法图解"></p>
<p>(a)图到(b)中，值为14的结点向上移动，值为4的结点向下移动。(b)到(c)图，值为8的结点向上移动，值为4的结点向下移动。</p>
<p>该算法实际上是一个递归，对结点(i)调用后，会对原先拥有最大结点的子树进一步调用（<code>MAX-HEAPIFY（A，largest）</code>）。</p>
<p>如果一个树的结点数目为$n$，其子树最多拥有$2n/3$个结点。首先因为二叉堆需要满足近似完全二叉树，即只有最下一层的结点可能是不满的。因此最大比例情况发生在最下层结点一半是空的时候，此时非空另一半的子树拥有最大比例的子结点。</p>
<p>如下图所示，此时树中一共有11个结点，根节点的左子树此时拥有的结点比例是最大的，为7/11。</p>
<p><img src="IA-Chapter6-Notes/2020-01-28-14-10-18.png" alt="最大比例子树"></p>
<p>一个树的结点数目为$n$，其子树最多拥有$2n/3$个结点。证明如下：</p>
<p>首先如果树的每一层结点数是上一层的两倍，根据等比数列公式可以求得，高度为$h$的树，其结点总数为：</p>
<script type="math/tex; mode=display">
\frac{a_1-a_nq}{1-q} \\\\
=\frac{1- 2^{h-1}2}{1-2} \\\\
=2^h-1</script><p>最大比例情况下，即最底层的结点一半为空的情况下，最大子树所占结点数目的比例计算如下：</p>
<script type="math/tex; mode=display">
\frac{2^{h-1}-1}{2^h-1 - \frac{2^{h-1}}{2}}</script><p>该式子的分子是子树的结点总数，在最大情况下子树可以看作是一颗层数小1的满树($2^{h-1}-1$)。分母是整棵树的结点数，为满树($2^h-1$)减去最下一层结点的一半（$\frac{2^{h-1}}{2}$）.</p>
<p>对上式求极限可得：</p>
<script type="math/tex; mode=display">
\lim_{n\rightarrow \infty} \frac{2^{h-1}-1}{2^h-1 - \frac{2^{h-1}}{2}} \\\\
=\lim_{n\rightarrow \infty} \frac{2^{-1}-\frac{1}{2^h}}{1-\frac{1}{2^h}-2^{-2}}\\\\
=\frac{\frac{1}{2}-0}{1-0-\frac{1}{4}} \\\\
= \frac{2}{3}</script><p>因此<code>MAX-HEAPIFY(A,i)</code>的时间复杂度递归表达式可以写作</p>
<script type="math/tex; mode=display">
T(n)\leq T(2n/3) +\Theta(1)</script><p>该式子满足主方法的第二种情况，因此可以算出时间复杂度为$T(n)=O(\lg n)$</p>
<h2 id="Building-a-heap"><a href="#Building-a-heap" class="headerlink" title="Building a heap"></a>Building a heap</h2><p>可以通过自底向上（即从树的第一个非叶子结点开始向上调用直到根结点）的调用<code>MAX_HEAPIFY</code>方法将一个普通数组转换为满足最大特性的数组。将这个方法称为<code>BUILD-MAX-HEAP(A)</code></p>
<p>对于一个数组$A$，索引值从$\lfloor n/2 \rfloor +1$到$n$都是这个树的叶子。</p>
<p>证明如下：</p>
<p>如果一个结点的索引值为$\lfloor n/2 \rfloor +1$，求这个结点的左结点，可得：</p>
<script type="math/tex; mode=display">
LEFT(\lfloor n/2 \rfloor +1)\\\\
=2(\lfloor n/2 \rfloor +1)\\\\>2( (\frac{n}{2}-1)+1)\\\\
=n-2+2 =n</script><p>即他的左子树的结点索引值已经大于了$n$，所以他的左子树是不存在的。</p>
<p>使用的同样的方法，也可以证明对于索引值为$\lfloor n/2 \rfloor$的结点，其左结点是存在的。</p>
<p><code>BUILD-MAX-HEAP(A)</code>的伪代码如下，其核心为自底向上对所有的非叶子结点进行MAX-HEAPIFY</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BUILD-MAX-HEAP(A)</span><br><span class="line">A.heap-size=A.length</span><br><span class="line">for i = A.length/2 downto 1</span><br><span class="line">    MAX-HEAPIFY(A,i)</span><br></pre></td></tr></table></figure>
<p>c++代码实现如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuildMaxHeap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = dataLength / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">		<span class="built_in">MaxHeapify</span>(i, dataLength);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>算法图解如下，从(a)到(e)分别表示每一次的循环，(f)为最终结果。</p>
<p><img src="IA-Chapter6-Notes/2020-01-28-15-53-17.png" alt="BUILD-MAX-HEAP算法"></p>
<p>该算法会调用$O(n)$次MAX-HEAPIFY算法，所以复杂度为$O(n\lg n)$。但这个复杂度并不是紧密的上限。</p>
<p>考虑到对于一个拥有$n$个结点的树，其树高为$\lfloor \lg n \rfloor$。</p>
<p>且可以证明对于高度为$h$的层（这里的高度0是指最下面一层，高度1为倒数第二层，依次类推），节点数最多为$\lceil n/2^{h+1}\rceil$。</p>
<p>证明如下：</p>
<p>在前面已经得知，对于一个数组$A$，索引值从$\lfloor n/2 \rfloor +1$到$n$都是这个树的叶子。那么可以计算出，一棵树的叶子结点个数为$n-(\lfloor n/2 \rfloor +1)+1=\lceil n/2 \rceil$。非叶子结点个数为$n-\lceil n/2 \rceil= \lfloor n/2 \rfloor$</p>
<p>用数学归纳法证明</p>
<p>对于高度为0的层，即叶子层，其结点个数为$\lceil n/2 \rceil$，满足$\lceil n/2^{h+1}\rceil$。</p>
<p>对于高度为h-1的层，条件满足。对于高度为$h-1$的层到顶部的结点个数即为一棵树非叶子结点的个数，即$\lfloor n/2 \rfloor$。</p>
<p>因此式子为</p>
<script type="math/tex; mode=display">
\lceil \frac{\lfloor n/2 \rfloor}{2^{h-1+1}} \rceil \\\\
< \lceil \frac{n/2}{2^{h-1+1}} \rceil \\\\
= \lceil \frac{n}{2^{h+1}} \rceil</script><p>即可推导出原式，因此原式得证。</p>
<p>对于<code>BUILD-MAX-HEAP(A)</code>而言，每一次调用<code>MAX-HEAPIFY</code>都与调用时的高度相关，即每个<code>MAX-HEAPIFY</code>的时间复杂度为$O(h)$。</p>
<p>因此整个算法的时间复杂度可表示为</p>
<script type="math/tex; mode=display">
\sum_{h=0} ^{\lfloor \lg n \rfloor} \lceil \frac{n}{2^{h+1}} O(h) \rceil \\\\
= O( n \sum_{h=0} ^{\lfloor \lg n \rfloor}\frac{h}{2^h} )\\\\
=  O( n \sum_{h=0} ^{\infty}\frac{h}{2^h} )</script><p>套用公式</p>
<script type="math/tex; mode=display">
\sum_{k=0}^{\infty} kx^k=\frac{x}{(1-x)^2}</script><p>得</p>
<script type="math/tex; mode=display">
O( n \sum_{h=0} ^{\infty}\frac{h}{2^h} \\\\
=O(2n)=O(n)</script><p>所以<code>BUILD-MAX-HEAP(A)</code>的紧密时间复杂度为$O(n)$</p>
<h2 id="The-heapsort-algorithm"><a href="#The-heapsort-algorithm" class="headerlink" title="The heapsort algorithm"></a>The heapsort algorithm</h2><p>对排序算法，首先需要调用<code>BUILD-MAX-HEAP(A)</code>算法将数组转换为满足最大特性的数组。满足最大特性后，数组的第一个元素即为最大值，将数组的最后一个值与第一个值进行交换，然后将数组的有效大小缩小（相当于不再追踪最后一个元素，因为此时最后一个元素是原第一个元素即最大元素）。然后再针对新的第一个元素调用<code>MAX-HEAPIFY(A,1)</code>即可。</p>
<p>伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HEAPSORT(A)</span><br><span class="line">BUILD-MAX-HEAP(A)</span><br><span class="line">for i = A.length downto 2</span><br><span class="line">    exchange A[1] with A[i]</span><br><span class="line">    A.heapSize = A.heapSize - 1</span><br><span class="line">    MAX-HEAPIFY(A,1)</span><br></pre></td></tr></table></figure>
<p>c++代码实现如下<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">BuildMaxHeap</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> tempDataLength = dataLength; tempDataLength &gt; <span class="number">1</span>;tempDataLength--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> temp = dataArray[<span class="number">0</span>];</span><br><span class="line">		dataArray[<span class="number">0</span>] = dataArray[tempDataLength - <span class="number">1</span>];</span><br><span class="line">		dataArray[tempDataLength - <span class="number">1</span>] = temp;</span><br><span class="line">		<span class="built_in">MaxHeapify</span>(<span class="number">0</span>, tempDataLength - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//This part is not related to the heapsort</span></span><br><span class="line">	<span class="comment">//Output the sort result and recover the heap </span></span><br><span class="line">	<span class="built_in">HeapDebug</span>();</span><br><span class="line">	<span class="built_in">BuildMaxHeap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>算法图解如下，(a)为初始状态，(b)到(j)每次循环调用完MAX-HEAPIFY后的结果，(k)为最终结果：</p>
<p><img src="IA-Chapter6-Notes/2020-01-28-15-55-14.png" alt="HEAPSORT图解"></p>
<p>该算法的时间复杂度为$O(n\lg n)$。因为BUILD-MAX-HEAP的复杂度为$O(n)$，且调用了$O(n)$次复杂度为$O(\lg n)$的<code>MAX-HEAPIFY</code>算法。</p>
<h2 id="Priority-Queue"><a href="#Priority-Queue" class="headerlink" title="Priority Queue"></a>Priority Queue</h2><p><code>优先队列（Priority queues）</code>是二叉堆排序的一个应用。</p>
<p>如有一系列任务，每个任务有不同的优先级，每次任务处理完后需要在剩下的任务中选取优先级最高的任务进行处理。可以将一个任务看作是一个结点，任务的优先级看作是结点的值，因此每次选取任务时只要从<code>最大堆</code>中取第一个元素即可。存放这些任务的队列即为优先队列。</p>
<p>也可以通过二叉堆来实现事件的回放，每一个事件作为树中的一个结点，事件的时间作为结点的值。因此在回放事件时，每次只要取<code>最小堆</code>中的第一个元素即可。</p>
<p>一个优先队列需要实现如下几个命令：</p>
<ol>
<li>INSERT(S,x) 将元素x插入队列S中</li>
<li>MAXIMUM（S）返回S中的最大元素</li>
<li>EXTRACT—MAX(S)返回并取出S中的最大元素</li>
<li>INCREASE-KEY(S,x,k)增加S中的元素x的值至k，k必须大于原先x的值。</li>
</ol>
<p>MAXIMUM伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HEAP-MAXIMUM(A)</span><br><span class="line">return A[1]</span><br></pre></td></tr></table></figure>
<p>c++代码实现如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Maximum</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> dataArray[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>EXTRACT-MAX(S)的伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HEAP-EXTRACT-MAX(A)</span><br><span class="line">if A.heap-size &lt; 1</span><br><span class="line">    error &quot;heap under flow&quot;</span><br><span class="line">max = A[1]</span><br><span class="line">A[1] = A[A.heapSize]</span><br><span class="line">A.heapSize--</span><br><span class="line">MAX-HEAPIFY(A,1)</span><br><span class="line">return max;</span><br></pre></td></tr></table></figure>
<p>c++代码实现如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ExtractMaximum</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> max = dataArray[<span class="number">0</span>];</span><br><span class="line">	dataArray[<span class="number">0</span>] = dataArray[--dataLength];</span><br><span class="line">	<span class="keyword">if</span> (dataLength != <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">MaxHeapify</span>(<span class="number">0</span>, dataLength);</span><br><span class="line">	<span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>EXTRACT-MAX的时间复杂度为$O(\lg n)$</p>
<p>INCREASE-KEY的伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HEAP-INCREASE-KEY(A,i,key)</span><br><span class="line">if key &lt; A[i]</span><br><span class="line">    error &quot;new key is smaller than current key&quot;</span><br><span class="line">A[i] = key</span><br><span class="line">while i &gt; 1 and A[PARENT(i)] &lt; A[i]</span><br><span class="line">    exchange A[i] with A[PARENT(i)]</span><br><span class="line">    i = PARENT(i)</span><br></pre></td></tr></table></figure>
<p>c++代码实现如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">IncreaseKey</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> newValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (index &gt;= dataLength)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Invalid index in IncreaseKey&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (dataArray[index] &gt;= newValue)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;No need to update&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	dataArray[index] = newValue;</span><br><span class="line">	<span class="type">int</span> parentIndex = <span class="built_in">parent</span>(index);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;parent index is &quot;</span> &lt;&lt; parentIndex &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">while</span> (index &gt; <span class="number">0</span> &amp;&amp; dataArray[parentIndex] &lt; newValue)</span><br><span class="line">	&#123;</span><br><span class="line">		dataArray[index] = dataArray[parentIndex];</span><br><span class="line">		dataArray[parentIndex] = newValue;</span><br><span class="line">		index = <span class="built_in">parent</span>(index);</span><br><span class="line">		parentIndex = <span class="built_in">parent</span>(index);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>INCREASE-KEY的算法主要思想是将更大数值的结点与父结点比较，如果更大则向上移动。这里的操作与MAX-HEAPIFY实际上是相反的，MAX-HEAPIFY是将更小的数值向下沉。最坏情况下循环的次数与堆的高度相同，即时间复杂度为$O(\lg n)$</p>
<p>算法图解如下,(a)图是原先的值，(b)图是将值改为15后，(c)和(d)为循环过程：</p>
<p><img src="IA-Chapter6-Notes/2020-01-28-16-25-30.png" alt="INCREASE-KEY图解"></p>
<p>INSERT的伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MAX-HEAP-INSERT(A.key)</span><br><span class="line">A.heapSize = A.heapSize+1</span><br><span class="line">A[A.heapSize] = -MAX</span><br><span class="line">HEAP-INCREASE-KEY(A,A.heapSize,key)</span><br></pre></td></tr></table></figure>
<p>c++代码实现如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dataLength++;</span><br><span class="line">	<span class="keyword">if</span> (dataLength &gt; arrayLength)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;The heap is full&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	dataArray[dataLength - <span class="number">1</span>] = -INT_MAX;</span><br><span class="line">	<span class="built_in">IncreaseKey</span>(dataLength - <span class="number">1</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>INSERT算法是先加入一个无限小的结点，再通过INCREASE-KEY方法将这个结点的值改为需要的值。该算法的时间复杂度与INCREASE-KEY相同，即$O(\lg n)$</p>
<div class="note info simple"><p>引用：</p>
<ol>
<li><em>Introduction to Algorithms</em> 3rd Sep.2009</li>
</ol>
</div>
<hr>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>《LearnOpenGL》 笔记 (一)</title>
    <url>/LearnOpenGL-Notes-1/</url>
    <content><![CDATA[<p><img src="LearnOpenGL-Notes-1/CreatingaWindow.png" alt="Creating a Window" style="zoom:50%;" /></p>
<span id="more"></span>
<h1 id="Creating-a-Window"><a href="#Creating-a-Window" class="headerlink" title="Creating a Window"></a>Creating a Window</h1><p>在OpenGL前，首先需要创建OpenGL的上下文和用于绘制的窗口等，这些内容是与操作系统相关的，而OpenGL则是希望成为一个夸平台的工具，因此OpenGL本身并不复杂这些内容的处理，需要用户自己来进行相关的环境配置。好在一些现有的库以及帮助完成了工作，这里首先需要进行的就是相关库的配置。</p>
<h2 id="GLFW"><a href="#GLFW" class="headerlink" title="GLFW"></a>GLFW</h2><p>GLFW是一个开源的OpenGL库，主要为创建窗口，OpenGL上下文，处理用户输入等功能提供了简单的API。</p>
<p>从<a href="https://www.glfw.org/download.html">官网</a>中下载GLFW源文件，然后再下载并安装<a href="https://cmake.org/download/">CMake</a>软件推荐，windows平台下推荐下载msi版本。</p>
<p>安装Cmake后，按下图进行配置，从上到下三个红框分别表示，GLFW的源代码地址，编译后结果的输出地址以及编译对象，这里因为想搭建的是VSCode环境下的地址，所以选择了<code>MinGW Makefiles</code>。其中第三个红框的窗口时通过按左下角的<code>Configure</code>按钮呼出的。</p>
<p><img src="LearnOpenGL-Notes-1/2020-05-25-16-02-22.png" alt="Cmake配置"></p>
<p>配置完成后，勾选上最上面的<code>BUILD_SHARD_LIBS</code>选项后点积<code>Generate</code>按钮。</p>
<p><img src="LearnOpenGL-Notes-1/2020-05-25-16-09-15.png" alt="配置完成后"></p>
<p>输出后，进入输出结果的地址，并通过<code>mingw32-make</code>命令进行编译，如下：</p>
<p><img src="LearnOpenGL-Notes-1/2020-05-25-16-10-05.png" alt="mingw32编译"></p>
<p>注意这一步需要安装<a href="https://osdn.net/projects/mingw/releases/">mingw</a>工具。</p>
<p>完成后进入<code>src</code>文件夹，其中的<code>glfw3.dll</code>和<code>libglfw3dll.a</code>即为所需要的静态链接文件。</p>
<p><img src="LearnOpenGL-Notes-1/2020-05-25-16-13-02.png" alt="Lib文件"></p>
<p>而需要的头文件，则在<code>glfw3</code>的源代码路径下的<code>include</code>文件夹中</p>
<p><img src="LearnOpenGL-Notes-1/2020-05-25-16-14-48.png" alt="头文件"></p>
<h2 id="GLAD"><a href="#GLAD" class="headerlink" title="GLAD"></a>GLAD</h2><p>OpenGL实质上是一个标准，因此对于不同的显卡厂商而言，会做出不同的OpenGL相关驱动，也因此OpenGL函数的地址并不能在编译时刻确定，只能在Runtime时找到相关的函数指针地址再使用该指针进行操作，无疑这是一个很繁琐的功能。</p>
<p>而<code>GLAD</code>库简化了相关操作，并且<code>GLAD</code>库使用了网络服务来简化了编译过程，只要在其<a href="https://glad.dav1d.de/">网站</a>上选择目标语言和相关OpenGL类型之后，就可以直接生成出想要的内容并直接下载，网站上的相关设置如下：</p>
<p><img src="LearnOpenGL-Notes-1/2020-05-25-16-27-36.png" alt="GLAD下载"></p>
<p>当下载<code>GLAD</code>内容后，进入文件夹，并通过命令行运行如下两个命令来生成需要的静态链接文件。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">gcc .\src\glad.c -c -I.\include\</span><br><span class="line">ar -rc libglad.a glad.o</span><br></pre></td></tr></table></figure>
<p>第一条命令时将<code>.c</code>文件编译为<code>.o</code>文件，第二条命令是将<code>.o</code>文件转换为静态链接<code>.a</code>文件。生成的<code>libglad.a</code>文件即为需要的静态链接文件。</p>
<p><code>GLAD</code>需要的头文件在<code>include</code>文件夹下。</p>
<h2 id="配置VS-Code"><a href="#配置VS-Code" class="headerlink" title="配置VS Code"></a>配置VS Code</h2><p>首先安装<code>C/C++ Project Generator</code>插件帮助创建相关的文件夹，安装插件并运行<code>Create C++ Project</code>后，将之前生成的<code>GLFW</code>和<code>GLAW</code>的静态链接文件和头文件分别拷贝至<code>lib</code>和<code>include</code>文件夹下，如下所示：</p>
<p><img src="LearnOpenGL-Notes-1/2020-05-25-16-43-42.png" alt="VSCode文件夹结构"></p>
<p>还需要对Makefile文件进行修改，修改后的结果如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CC		:= g++</span><br><span class="line">CFLAGS	:= -std=c++17 -Wall -Wextra -g</span><br><span class="line"></span><br><span class="line">BIN		:= bin</span><br><span class="line">SRC		:= src</span><br><span class="line">INCLUDE	:= <span class="keyword">include</span></span><br><span class="line">LIB		:= lib</span><br><span class="line"></span><br><span class="line">LIBRARIES	:= -lglad -lglfw3dll <span class="comment"># Add Lib file</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(OS)</span>,Windows_NT)</span><br><span class="line">EXECUTABLE	:= main.exe</span><br><span class="line">SOURCEDIRS	:= <span class="variable">$(SRC)</span></span><br><span class="line">INCLUDEDIRS	:= <span class="variable">$(INCLUDE)</span></span><br><span class="line">LIBDIRS		:= <span class="variable">$(LIB)</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">EXECUTABLE	:= main</span><br><span class="line">SOURCEDIRS	:= <span class="variable">$(<span class="built_in">shell</span> find <span class="variable">$(SRC)</span> -type d)</span></span><br><span class="line">INCLUDEDIRS	:= <span class="variable">$(<span class="built_in">shell</span> find <span class="variable">$(INCLUDE)</span> -type d)</span></span><br><span class="line">LIBDIRS		:= <span class="variable">$(<span class="built_in">shell</span> find <span class="variable">$(LIB)</span> -type d)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line">CINCLUDES	:= <span class="variable">$(<span class="built_in">patsubst</span> %,-I%, $(INCLUDEDIRS:%/=%)</span>)</span><br><span class="line">CLIBS		:= <span class="variable">$(<span class="built_in">patsubst</span> %,-L%, $(LIBDIRS:%/=%)</span>)</span><br><span class="line"></span><br><span class="line">SOURCES		:= <span class="variable">$(<span class="built_in">wildcard</span> $(<span class="built_in">patsubst</span> %,%/*.cpp, <span class="variable">$(SOURCEDIRS)</span>)</span>)</span><br><span class="line">OBJECTS		:= $(SOURCES:.cpp=.o)</span><br><span class="line"></span><br><span class="line"><span class="section">all: <span class="variable">$(BIN)</span>/<span class="variable">$(EXECUTABLE)</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	-<span class="variable">$(RM)</span> <span class="variable">$(BIN)</span>/<span class="variable">$(EXECUTABLE)</span></span><br><span class="line">	-<span class="variable">$(RM)</span> <span class="variable">$(OBJECTS)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">run: all</span></span><br><span class="line">	./<span class="variable">$(BIN)</span>/<span class="variable">$(EXECUTABLE)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(BIN)</span>/<span class="variable">$(EXECUTABLE)</span>: <span class="variable">$(SOURCES)</span> <span class="comment"># Use SOURCES instead of OBJECTS to avoid complile without include/lib</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(CINCLUDES)</span> <span class="variable">$(CLIBS)</span> <span class="variable">$^</span> -o <span class="variable">$@</span> <span class="variable">$(LIBRARIES)</span></span><br></pre></td></tr></table></figure>
<p>主要的修改点如上注释所示，一是添加了静态文件的链接，原MakeFile文件只是制定了lib文件夹，但需要链接文件夹中的哪些文件并没有说明，需要修改<code>LIBRARIES</code>文件进行说明。其中的<code>-lglad</code>表示链接<code>libglad.a</code>文件，<code>-lglfw3dll</code>表示链接<code>libglfw3dll.a</code>文件。二是将原最后编译步骤中的<code>OBJECTS</code>对象改成了<code>SOURCES</code>。这是因为如果设定了<code>OBJECTS</code>则会隐式的进行一步<code>cpp</code>文件到<code>.o</code>文件的编译，而这次编译并没有指定include和lib目录，则会造成编译失败。</p>
<p>lib文件夹中的<code>glfw.dll</code>文件需要手动的复制到与最后生成的<code>exe</code>文件同目录下，这里即是<code>bin</code>文件夹。</p>
<p>可将如下代码拷贝至<code>main.cpp</code>文件中，并按下F5自动编译运行，或在<code>Makefile</code>所在目录下通过命令行命令<code>mingw32-make run</code>编译运行。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">glfwInit</span>();</span><br><span class="line">	<span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">	<span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">	<span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line">	GLFWwindow *window = <span class="built_in">glfwCreateWindow</span>(SCR_WIDTH, SCR_HEIGHT, <span class="string">&quot;LearnOpenGL&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="built_in">glfwTerminate</span>();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">glClearColor</span>(<span class="number">0.0f</span>, <span class="number">1.f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">		<span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line">		<span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">		<span class="built_in">glfwPollEvents</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">glfwTerminate</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果应该为一个绿色的窗口，如下所示：</p>
<p><img src="LearnOpenGL-Notes-1/2020-05-25-17-17-33.png" alt="运行结果"></p>
<p>至此整个学习OpenGL的环境设置完成。</p>
<div class="note info simple"><p>引用：</p>
<ol>
<li><a href="https://blog.csdn.net/sarono/article/details/86564726">vscode OpenGL环境搭建</a></li>
<li><a href="https://learnopengl.com/Getting-started/Creating-a-window">Creating a window</a></li>
</ol>
</div>
<hr>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>图形学</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>《LearnOpenGL》 笔记（二）</title>
    <url>/LearnOpenGL-Notes-2/</url>
    <content><![CDATA[<p><img src="LearnOpenGL-Notes-2/2020-09-24-23-08-27.png" alt="Hello Window" style="zoom:50%;" /></p>
<span id="more"></span>
<h1 id="Hello-Window"><a href="#Hello-Window" class="headerlink" title="Hello Window"></a>Hello Window</h1><h2 id="引入相关库"><a href="#引入相关库" class="headerlink" title="引入相关库"></a>引入相关库</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="初始化GLFW"><a href="#初始化GLFW" class="headerlink" title="初始化GLFW"></a>初始化GLFW</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glfwInit</span>();</span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br></pre></td></tr></table></figure>
<p><code>glfwWindowHint</code>函数的第一个参数用来表示要设定的参数，所有参数都是以<code>GLFW_</code>开头，函数的第二个参数是需要设定的值。<br><code>glfwWindowHint</code>接受的参数与参数值，可以在<a href="&quot;https://www.glfw.org/docs/latest/window.html#window_hints&quot;">GLFW文档</a>中设置。</p>
<h2 id="创建GLFW窗口"><a href="#创建GLFW窗口" class="headerlink" title="创建GLFW窗口"></a>创建GLFW窗口</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">GLFWwindow *window = <span class="built_in">glfwCreateWindow</span>(SCR_WIDTH, SCR_HEIGHT, <span class="string">&quot;LearnOpenGL&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">glfwMakeContextCurrent</span>(window);</span><br></pre></td></tr></table></figure>
<p>通过<code>glfwCreateWindow</code>函数创建窗口，前两个参数设置窗口的宽和高，第三个参数设置窗口名，最后两个参数教程中未做解释。该函数会返回一个<code>GLFWWINDOW</code>类型的指针。</p>
<p><code>glfwMakeContextCurrent</code>将<code>glfwCreateWindow</code>返回的表示窗口的指针绑定给当前线程环境。</p>
<h2 id="初始化GLAD"><a href="#初始化GLAD" class="headerlink" title="初始化GLAD"></a>初始化GLAD</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>GLAD</code>用来管理OpenGL函数的地址，因此在调用任何的OpenGL函数前需要先对<code>GLAD</code>进行初始化。</p>
<p>需要给<code>gladLoadGLLoader</code>指定读取函数地址的函数，函数地址是系统相关的。在绑定了窗口后，可以通过<code>glfwGetProcAddress</code>函数获取到相应系统给出的函数地址。</p>
<p>因此需要先初始化<code>GLFW</code>，绑定<code>GLFW</code>窗口，再初始化<code>GLAD</code>，然后才能使用OpenGL相应的函数。</p>
<h2 id="渲染循环"><a href="#渲染循环" class="headerlink" title="渲染循环"></a>渲染循环</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">    <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">    <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>glClearColor</code>设置<code>ClearColor</code>的颜色。<br><code>glClear</code>设置需要清理的对象，这里仅清理颜色缓存。<br><code>glfwSwapBuffers</code>设置双缓冲。如果仅使用单缓存时可能会有图像闪烁的原因，因为图像并不是瞬间被画出，而是从左至右，从下至上逐像素画出。为避免这种情况的发生，可以用双缓存，当前缓存在显示时，后缓存进行读取，当后缓存读完，交换前后缓存，如此，图像可瞬间画出。<br><code>glfwPollEvents</code>用来检查是否有事件触发，包括键盘事件，鼠标事件，和窗口事件等。（即使不需要处理输入，也仍然要设定该函数）。</p>
<h2 id="按键处理"><a href="#按键处理" class="headerlink" title="按键处理"></a>按键处理</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)</span><br><span class="line">        <span class="built_in">glfwSetWindowShouldClose</span>(window, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>glfwGetKey</code>用来获取当前窗口按下的按键。<br><code>glfwSetWindowShouldClose</code>设置当前窗口需要被关闭，调用该函数后，窗口会被关闭。</p>
<p><code>processInput</code>函数需要在函数主循环中被调用，保证一直检查输入状态。</p>
<h2 id="Viewport设置"><a href="#Viewport设置" class="headerlink" title="Viewport设置"></a>Viewport设置</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glfwSetFramebufferSizeCallback</span>(window, framebuffer_size_callback);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow *window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置在窗口尺寸改变时，设置回调，并在回调中，调用<code>glViewport</code>函数更改viewport。</p>
<h2 id="终止GLFW"><a href="#终止GLFW" class="headerlink" title="终止GLFW"></a>终止GLFW</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glfwTerminate</span>();</span><br></pre></td></tr></table></figure>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><a href="&quot;https://raw.githubusercontent.com/xuejiaW/Study-Notes/master/LearnOpenGL_VSCode/src/1.HelloWindow/main.cpp&quot;">CPP</a></p>
<div class="note info simple"><p>引用：</p>
<ol>
<li><a href="https://learnopengl.com/Getting-started/Creating-a-window">Hello Window</a></li>
</ol>
</div>
<hr>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>图形学</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown教程</title>
    <url>/MarkdownTutorial/</url>
    <content><![CDATA[<p>Hexo、Github的项目介绍，简书，有道云笔记，EverNote等等软件和博客网站都支持Markdown语言。</p>
<p>Markdown语言的设计目标是让编写者可以注重文章的内容，以一种较为简单高效的方法完成文章格式的编写。</p>
<p>本篇文章会介绍Markdown比较常见的语法，并介绍一些Markdown的编写工具。</p>
<span id="more"></span>
<h2 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br></pre></td></tr></table></figure>
<p>最多可以到六级标题为止</p>
<div class="note warning simple"><p>markdown语法符号，比如<code>#</code>，后都需要加上一个空格确保生效</p>
</div>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; 引用内容</span></span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">&gt; 引用内容换行</span></span><br><span class="line">//这里空了一行就会引起让引用标记中断</span><br><span class="line"><span class="quote">&gt; 引用内容</span></span><br><span class="line"><span class="quote">&gt; 这样没法换行</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>引用内容</p>
<p>引用内容换行</p>
<p>引用内容<br>这样没法换行</p>
</blockquote>
<div class="note warning simple"><p>根据markdown语法，所有都需要中间空一行，但上例中没有空行，在Next上仍然换行了。这可能是Next的Bug或Feature，但仍然推荐严格安装markdown语法规则添加空行。</p>
</div>
<p>在引用之中我们仍然可以使用Markdown语言，比如</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; 引用内容</span></span><br><span class="line">&gt;&gt; 引用中的引用</span><br></pre></td></tr></table></figure>
<blockquote>
<p>引用内容</p>
<blockquote>
<p>引用中的引用</p>
</blockquote>
</blockquote>
<h3 id="清单"><a href="#清单" class="headerlink" title="清单"></a>清单</h3><figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*</span> 一号</span><br><span class="line"><span class="bullet">*</span> 二号</span><br><span class="line"><span class="bullet">*</span> 三号</span><br></pre></td></tr></table></figure>
<ul>
<li>一号</li>
<li>二号</li>
<li>三号</li>
</ul>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 一号</span><br><span class="line"><span class="bullet">2.</span> 二号</span><br><span class="line"><span class="bullet">3.</span> 三号</span><br></pre></td></tr></table></figure>
<ol>
<li>一号</li>
<li>二号</li>
<li>三号</li>
</ol>
<p>在清单内如果需要有段落，则要在新的一段前加入tab。</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 一号清单</span><br><span class="line"><span class="bullet">2.</span> 二号清单</span><br><span class="line"></span><br><span class="line"><span class="code">    二号清单段落段落段落段落二号清单段落段落段落段落二号清单段落段落段落段落二号清单段落段落段落段落二号清单段落段落段落段落二号清单段落段落段落段落</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="bullet">3.</span> 三号清单</span><br></pre></td></tr></table></figure>
<ol>
<li>一号清单</li>
<li><p>二号清单</p>
<p> 二号清单段落段落段落段落二号清单段落段落段落段落二号清单段落段落段落段落二号清单段落段落段落段落二号清单段落段落段落段落二号清单段落段落段落段落</p>
</li>
<li><p>三号清单</p>
</li>
</ol>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>用前后两段三个`来表示一个代码块</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">/<span class="code">```cs 演示</span></span><br><span class="line"><span class="code"> Debug.Log(&quot;这是一段代码&quot;);</span></span><br><span class="line"><span class="code">```</span>/</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>演示</span></figcaption><table><tr><td class="code"><pre><span class="line">Debug.Log(<span class="string">&quot;这是一段代码&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>为了防止演示代码被误认为是一个新的代码块，在演示行前后加了/，实际使用时不需要</p>
<h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>用三个<em>*</em>或—-或<em>_</em>来表示一段分割线，在分割符号所在行内不能有其他东西</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="strong">**<span class="emphasis">*</span></span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><p>超链接的实现有两种方式,<code>inline</code>和<code>reference</code></p>
<p>inline方式，是用[]包裹住需要加入超链接的文字，用()包裹住超链接地址</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">[<span class="string">百度</span>](<span class="link">www.baidu.com</span>)</span><br></pre></td></tr></table></figure>
<p><a href="www.baidu.com">百度</a></p>
<p>refernece方式，是用[]包裹住需要加入超链接的文字，再接一个[]包裹住超链接文字的Tag，再文章的其他地方（最少需要在下一行），通过[]:()来标记tag的地址，以简化多段文字指向同一个超链接的情况的编写。</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">[<span class="string">谷歌</span>][<span class="symbol">google</span>]</span><br><span class="line"></span><br><span class="line">[<span class="symbol">google</span>]:<span class="link">(www.google.com)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a href="(www.google.com)">谷歌</a></p>
<div class="note info simple"><p>超链接的[]和()符号后都不需要跟空格</p>
</div>
<h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>图片与超链接语法相似，只不过在包裹超链接前的[]前加入一个感叹号即可</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">![<span class="string">头像地址</span>](<span class="link">https://xuejiaw.github.io/uploads/blackCat.jpg</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://xuejiaw.github.io/uploads/blackCat.jpg" alt="头像地址"></p>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><figure class="highlight md"><table><tr><td class="code"><pre><span class="line">| 分类1 | 分类2 |</span><br><span class="line">| ------- | ------- |</span><br><span class="line">| 数据1 | 数据2 |</span><br><span class="line">| 数据3 | 数据4 |</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>分类1</th>
<th>分类2</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据1</td>
<td>数据2</td>
</tr>
<tr>
<td>数据3</td>
<td>数据4</td>
</tr>
</tbody>
</table>
</div>
<div class="note info simple"><p>如果表格中的元素需要换行，可加入<code>&lt;br&gt;</code>作为\n</p>
</div>
<h2 id="Next特定标签"><a href="#Next特定标签" class="headerlink" title="Next特定标签"></a>Next特定标签</h2><p>使用Next编写博客时，可以在文章的md文件中使用一些特定的标记来增加文章样式。</p>
<h3 id="居中简介"><a href="#居中简介" class="headerlink" title="居中简介"></a>居中简介</h3><p>在使用了<code>&lt;!--more--&gt;</code>标记后，可以在文章首页增加文章的简介并添加阅读全文按钮，使用<code>cq</code>标记则可以在文章简介前后加入双引号，并居中显示简介。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">文章简介。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>文章简介。</p>
<h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>加入更多样式的Note，可以在主题配置文件的<code>note</code>字段修改样式</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">note:</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">simple</span></span><br><span class="line">  <span class="attr">icons:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">border_radius:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">light_bg_offset:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% note [class] %&#125;</span><br><span class="line">内容内容</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>
 <div class="note info simple"><p>内容内容</p>
</div>
<p>支持的class有<code>default</code>,<code>primary</code>,<code>success</code>,<code>info</code>,<code>warning</code>,<code>danger</code></p>
<h3 id="颜色高亮"><a href="#颜色高亮" class="headerlink" title="颜色高亮"></a>颜色高亮</h3><p>将部分文字修改颜色</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">style</span>=<span class="string">&quot;color:red&quot;</span>&gt;</span> 红色文字 <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>
<label style="color:red"> 红色文字 </label>

<h3 id="Tab"><a href="#Tab" class="headerlink" title="Tab"></a>Tab</h3><p>加入可切换的tab页面</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% tabs Tab名字 , 2 %&#125;<span class="comment">&lt;!--格式 &lt;tabs 名字,初始状态点第几个tab&gt; --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- tab --&gt;</span> <span class="comment">&lt;!-- 这里tab后也能跟名字，这样可以改写每个Tab各自的名字，否则使用上面定义的名字--&gt;</span></span><br><span class="line">第一个Tab</span><br><span class="line"><span class="comment">&lt;!-- endtab --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- tab --&gt;</span></span><br><span class="line">第二个Tab</span><br><span class="line"><span class="comment">&lt;!-- endtab --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- tab --&gt;</span></span><br><span class="line">第三个Tab</span><br><span class="line"><span class="comment">&lt;!-- endtab --&gt;</span></span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure>
<div class="tabs" id="tab名字"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#tab名字-1">Tab名字 1</button></li><li class="tab active"><button type="button" data-href="#tab名字-2">Tab名字 2</button></li><li class="tab"><button type="button" data-href="#tab名字-3">Tab名字 3</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="tab名字-1"><p>第一个Tab</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content active" id="tab名字-2"><p>第二个Tab</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="tab名字-3"><p>第三个Tab</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<p>注意在Tabs中插入代码块存在<a href="https://theme-next.org/docs/troubleshooting/">Bug</a>，如果要插入代码，可以使用Hexo的<a href="https://hexo.io/zh-cn/docs/tag-plugins.html">Code Tags</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% codeblock 测试 lang:csharp %&#125;</span><br><span class="line">Debug.Log(&quot;ABC&quot;)</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight csharp"><figcaption><span>测试</span></figcaption><table><tr><td class="code"><pre><span class="line">Debug.Log(<span class="string">&quot;ABC&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="Markdown编辑工具"><a href="#Markdown编辑工具" class="headerlink" title="Markdown编辑工具"></a>Markdown编辑工具</h2><h3 id="VSCode"><a href="#VSCode" class="headerlink" title="VSCode"></a>VSCode</h3><p>现在我编写Markdown时主要使用的就是VSCode，VSCode本身即支持Markdown的实时预览，在运行<code>Markdown: 打开侧边预览</code>功能后即可，默认快捷键时<code>Ctrl K +V</code></p>
<p><img src="MarkdownTutorial/2019-01-13-14-25-36.png" alt="Markdown实时预览"></p>
<p>如果使用VSCode编写Markdown，推荐安装<code>Paste Image</code>插件，该插件可以直接将截图复制进md文件，并且下载到本地。</p>
<p><img src="MarkdownTutorial/2019-01-13-14-33-17.png" alt="Paste Image"></p>
<h3 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h3><p><a href="https://www.typora.io/">Typora</a>是一个轻量级的专门的Markdown编写工具，我从Typora换为VSCode的主要原因也就是觉得没必要多装一个应用，并非Typora本身存在什么缺陷。</p>
<p><img src="MarkdownTutorial/2019-01-13-15-04-17.png" alt="Typora"></p>
<h3 id="Onenote-OneMarkdown"><a href="#Onenote-OneMarkdown" class="headerlink" title="Onenote + OneMarkdown"></a>Onenote + OneMarkdown</h3><p>我从大学开始是一个OneNote的重度使用者，但无奈目前OneNote不支持Markdown，于是只能寻找一些曲线救国的方法。]OneNoteGem](<a href="https://www.onenotegem.com/addins.html)是一个付费的OneNote插件，其中有一个模块叫做`OneMarkdown`。">https://www.onenotegem.com/addins.html)是一个付费的OneNote插件，其中有一个模块叫做`OneMarkdown`。</a></p>
<p><img src="MarkdownTutorial/2019-01-13-14-57-00.png" alt="OneMarkdown"></p>
<p>当使用付费版之后，在OneMarkdown上编辑的页面会自动同步到OneNote上。</p>
<p><img src="MarkdownTutorial/2019-01-13-14-58-08.png" alt="自动同步至OneNote"></p>
<p>OneMarkdown最终的显示效果并不是太理想，所以<code>Onenote+OneMakeDown</code>最好只作为数据的归档使用。OneNoteGem在淘宝上有相应的店家，但OneMakeDown因为销量太低没有上架，所以要购买需要单独找店家资讯。</p>
<h3 id="段落首行缩进"><a href="#段落首行缩进" class="headerlink" title="段落首行缩进"></a>段落首行缩进</h3><p>Markdown本身是一个基于英文设计的标记语言，所以本身对于中文习惯的段落首行缩进并没有支持，如果直接使用空格会发现整个段落都进行了缩进。我们可以通过将中文输入法切换为全角（一般快捷键为<code>Shift+Space</code>）后再输入两个空格解决。</p>
<h3 id="HTML缩进"><a href="#HTML缩进" class="headerlink" title="HTML缩进"></a>HTML缩进</h3><p>表格中的内容如果需要缩进，直接输入空格或者tab会被MD忽视。所以需要借助HTML转义符<code>&amp;ensp;</code>或<code>&amp;emsp;</code>，前者是半角转义符，后者是全角转义符。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&amp;emsp;&amp;emsp;缩进的文字</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;缩进的文字</p>
<div class="note info simple"><p>参考</p>
<ol>
<li><a href="https://markdown.tw/">https://markdown.tw/</a></li>
<li><a href="https://almostover.ru/2016-01/hexo-theme-next-test/">https://almostover.ru/2016-01/hexo-theme-next-test/</a></li>
</ol>
</div>
<hr>
]]></content>
      <categories>
        <category>教程</category>
        <category>标记语言</category>
      </categories>
      <tags>
        <tag>标记语言</tag>
        <tag>效率提升</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式教程</title>
    <url>/RegularExpressionTutorial/</url>
    <content><![CDATA[<p>介绍了正则表达式的元字符、缩写、前后预查、标记位、贪婪与惰性匹配和捕捉模式一系列概念。</p>
<p>主要是<a href="https://github.com/ziishaned/learn-regex#learn-regex">Github</a>上教程的学习笔记。</p>
<span id="more"></span>
<h2 id="正则表达式简介"><a href="#正则表达式简介" class="headerlink" title="正则表达式简介"></a>正则表达式简介</h2><p>正则表达式（Regular Expression）是一种用来搜索特定字符的表达式。在一些语言的字符串的模式匹配中可以使用正则表达式来找寻子字符串，在Unix系统中也可以用正则表达式来搜索文件。熟练运用正则表达式可以减少寻找子字符串的逻辑判断。</p>
<p>例如 <code>^[a-z0-9_-]&#123;3-15&#125;$</code> 表示可以用来判断一个字符串是否满足以下条件</p>
<ol>
<li><p>由小写字母、数字、或者_-组成</p>
</li>
<li><p>位数在3-15位</p>
</li>
</ol>
<p>所以字符串 <code>john_doe</code> 满足搜索条件而字符串 <code>Jo</code> 不满足。</p>
<h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><div class="table-container">
<table>
<thead>
<tr>
<th>元字符</th>
<th>介绍</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>.</td>
<td>匹配除了换行符外的所有符号</td>
<td>“.ar” =&gt; The <label style="color:red">car</label> <label style="color:red">par</label>ked in the <label style="color:red">gar</label>age.</td>
</tr>
<tr>
<td>[]</td>
<td>匹配在该方括号内的所有字符</td>
<td>“[Tt]he”=&gt;<label style="color:red">The</label> car parked in <label style="color:red">the</label> garage.</td>
</tr>
<tr>
<td><sup><a href="#fn_ " id="reffn_ "> </a></sup></td>
<td>匹配除了在该方括号内的所有字符</td>
<td>“<sup><a href="#fn_c" id="reffn_c">c</a></sup>ar”=&gt;The car <label style="color:red">par</label>ked in the <label style="color:red">gar</label>age.</td>
</tr>
<tr>
<td>*</td>
<td>匹配大于等于0个*号前的字符</td>
<td>“[a-z]*“=&gt;T<label style="color:red">he car parked in the garage</label>.<br>“\s*car\s*“=&gt;The<label style="color:red"> car </label>parked in the garage.</td>
</tr>
<tr>
<td>+</td>
<td>匹配大于等于1个+号前的字符</td>
<td>“c.+t”=&gt;The <label style="color:red">car parked in t</label>he garage.</td>
</tr>
<tr>
<td>?</td>
<td>标记? 之前的字符为可选</td>
<td>“[T]?he”=&gt;<label style="color:red">The</label> car parked in t<label style="color:red">he</label> garage.</td>
</tr>
<tr>
<td>{n, m}</td>
<td>num个字符，n&lt;=num&lt;=m。<br>可以不指定n或者m，则只约束一边的大小</td>
<td>“[0-9]{2, 3}”=&gt;The number was 9.<label style="color:red">999</label>7 but we rounded it off to <label style="color:red">10</label>.0<br>“[0-9]{2, }”=&gt;The number was 9.<label style="color:red">9997</label> but we rounded it off to <label style="color:red">10</label>.0<br>“[0-9]{3}”=&gt;The number was 9.<label style="color:red">999</label>7 but we rounded it off to 10.0</td>
</tr>
<tr>
<td>(xyz)</td>
<td>严格匹配字符xyz</td>
<td>(was)=&gt;The number <label style="color:red">was</label> 9.9997 but we rounded it off to 10.0</td>
</tr>
<tr>
<td>\</td>
<td></td>
<td>或运算符，匹配 \</td>
<td>前或后的字符</td>
<td>“(c\</td>
<td>g)ar”=&gt;The <label style="color:red">car</label> parked in the <label style="color:red">gar</label>age.<br>“(T\</td>
<td>t)he\</td>
<td>car”=&gt;<label style="color:red">The</label> <label style="color:red">car</label> parked in <label style="color:red">the</label> garage.</td>
</tr>
<tr>
<td>\</td>
<td>转义符，用来匹配 [ ] *这样的元字符</td>
<td>“(f\</td>
<td>m)at.?”=&gt;The <label style="color:red">fat</label> cat sat on the <label style="color:red">mat.</label></td>
</tr>
<tr>
<td>^</td>
<td>匹配输入的开头</td>
<td>“(T\</td>
<td>t)he”=&gt;<label style="color:red">The</label> car parked in <label style="color:red">the</label> garage.<br>“^(T\</td>
<td>t)he”=&gt;<label style="color:red">The</label> car parked in the garage.</td>
</tr>
<tr>
<td>$</td>
<td>匹配输入的结尾</td>
<td>“(at.)”=&gt;The fat c<label style="color:red">at.</label>s<label style="color:red">at.</label>on the m<label style="color:red">at.</label><br>“(at.)$”=&gt;The fat cat.sat.on the m<label style="color:red">at.</label></td>
</tr>
</tbody>
</table>
</div>
<h2 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h2><p>正则表达式也提供了一些常见的匹配模式的缩写</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>缩写</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>\w</td>
<td>[a-zA-Z0-9_]</td>
</tr>
<tr>
<td>\W</td>
<td><sup><a href="#fn_\w_" id="reffn_\w_">\w_</a></sup></td>
</tr>
<tr>
<td>\d</td>
<td>[0-9]</td>
</tr>
<tr>
<td>\D</td>
<td><sup><a href="#fn_\d" id="reffn_\d">\d</a></sup></td>
</tr>
<tr>
<td>\s</td>
<td>空白字符[\t\n\f\r\p]</td>
</tr>
<tr>
<td>\S</td>
<td><sup><a href="#fn_\s" id="reffn_\s">\s</a></sup></td>
</tr>
<tr>
<td>\t</td>
<td>制表符</td>
</tr>
<tr>
<td>\n</td>
<td>换行符</td>
</tr>
<tr>
<td>\f</td>
<td>换页符</td>
</tr>
<tr>
<td>\r</td>
<td>回车符</td>
</tr>
<tr>
<td>\p</td>
<td>\r\n</td>
</tr>
</tbody>
</table>
</div>
<h2 id="前后预查"><a href="#前后预查" class="headerlink" title="前后预查"></a>前后预查</h2><p>前后预查是用来选择匹配出来的字符中的某一部分，例如有字符串 <code>$ 3.22 $4.44 $10.88</code> ，只想获取跟在$后的数字和小数点，所以应该只匹配4.44和10.88。我们将$称为预查表达式，我们将通过$来定位我们想要的特定数字。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>预查字符</th>
<th>介绍</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>?=</td>
<td>正前向预查，?=前是需要匹配的内容，?=后跟着预查表达式，匹配之后必须跟着预查表达式</td>
<td>$(?=[0-9.]+) =&gt; $ 3.22 <label style="color:red">$</label>4.44 and <label style="color:red">$</label>10.88 <br>匹配的内容是$，预查表达式是[0-9.]+</td>
</tr>
<tr>
<td>?!</td>
<td>负前向预查，?! 前是需要匹配的内容，?! 后跟着预查表达式，匹配之后必须不跟着预查表达式</td>
<td>$(?![0-9.]+) =&gt; <label style="color:red">$</label> 3.22 $4.44 and $10.88</td>
</tr>
<tr>
<td>?&lt;=</td>
<td>正后向预查，?&lt;=后跟着预查表达式，再之后是需要匹配的内容，匹配内容之前必须跟着预查表达式</td>
<td>(?&lt;=$)[0-9.]+ =&gt; $ 3.22 $<label style="color:red">4.44</label> and $<label style="color:red">10.88</label><br>匹配的内容是[0-9.]+，预查表达式是$</td>
</tr>
<tr>
<td>?&lt;!</td>
<td>负后向预查，?&lt;! 后跟着预查表达式，再之后是需要匹配的内容，匹配内容之前必须不跟着预查表达式</td>
<td>(?&lt;!$)[0-9.]+ =&gt; $ <label style="color:red">3.22</label> $4<label style="color:red">.44</label> and $10<label style="color:red">.88</label></td>
</tr>
</tbody>
</table>
</div>
<h2 id="标记位"><a href="#标记位" class="headerlink" title="标记位"></a>标记位</h2><div class="table-container">
<table>
<thead>
<tr>
<th>标记位</th>
<th>介绍</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>i</td>
<td>无视大小写</td>
<td>/The/ =&gt; <label style="color:red">The</label> fat cat sat on the mat.<br>/The/gi =&gt;<label style="color:red">The</label> fat cat sat on <label style="color:red">the</label> mat.</td>
</tr>
<tr>
<td>g</td>
<td>全局搜索（如果这个flag没有开启，则只匹配第一个搜索到的结果）</td>
<td>/.(at)/ =&gt; The <label style="color:red">fat</label> cat sat on the mat.<br>/.(at)/g/ =&gt; The <label style="color:red">fat</label> <label style="color:red">cat</label> <label style="color:red">sat</label> on the <label style="color:red">mat</label>.</td>
</tr>
<tr>
<td>m</td>
<td>多行匹配锚点，将^,&amp;的工作范围从全文变成每行</td>
<td>/.at(.)?$/ =&gt; The fat<br>cat sat<br>on the <label style="color:red">mat.</label><br><br>/.at(.)?$/gm =&gt; The <label style="color:red">fat</label><br>cat <label style="color:red">sat</label><br>on the <label style="color:red">mat.</label></td>
</tr>
</tbody>
</table>
</div>
<h2 id="贪婪匹配和惰性匹配"><a href="#贪婪匹配和惰性匹配" class="headerlink" title="贪婪匹配和惰性匹配"></a>贪婪匹配和惰性匹配</h2><p>像*和+默认都是贪婪模式，这意味着模式会尽可能的匹配更长的字符。可以在*和+后跟上?字符转换为惰性匹配模式。</p>
<p>/(.*at)/ =&gt; <label style="color:red">The fat cat sat on the mat.</label></p>
<p>/(.*?at)/ =&gt; <label style="color:red">The fat</label> cat sat on the mat.</p>
<h2 id="捕捉模式"><a href="#捕捉模式" class="headerlink" title="捕捉模式"></a>捕捉模式</h2><p>捕捉模式相当于将模式匹配的字符组保存到内存中，方便之后引用。这个严格意义上超脱了正则表达式本身的功能，是在其他语言使用正则表达式时的一个功能。默认的<code>(&lt;Pattern&gt;)</code>操作符就是开启了捕捉模式，如要关闭的话，在括号后跟上?:即可，如<code>(?:&lt;Pattern&gt;)</code></p>
<div class="note info simple"><ol>
<li><p>Github正则表达式教程 ： <a href="https://github.com/ziishaned/learn-regex#learn-regex">https://github.com/ziishaned/learn-regex#learn-regex</a></p>
</li>
<li><p>在线模式匹配测试 : <a href="https://regex101.com/r/ahfiuh/1">https://regex101.com/r/ahfiuh/1</a></p>
</li>
<li><p>模式匹配图解 :  <a href="https://regexper.com/">https://regexper.com/</a></p>
</li>
</ol>
</div>
<hr>
]]></content>
      <categories>
        <category>教程</category>
        <category>标记语言</category>
      </categories>
      <tags>
        <tag>标记语言</tag>
        <tag>效率提升</tag>
      </tags>
  </entry>
  <entry>
    <title>《Andrew Rollings and Ernest Adams on Game Design chapters》 第七章笔记</title>
    <url>/RollingAndAdams-Chapter7-Notes/</url>
    <content><![CDATA[<p>《Andrew Rollings and Ernest Adams on Game Design chapters》 第七章笔记</p>
<p>作者在这一章表明了游戏性最重要的是挑战。</p>
<p>作者给出了一系列纯粹的挑战类型，和应用挑战的方法。</p>
<span id="more"></span>
<h1 id="Chapter-7-GamePlay"><a href="#Chapter-7-GamePlay" class="headerlink" title="Chapter 7 GamePlay"></a>Chapter 7 GamePlay</h1><h2 id="Use-of-Language"><a href="#Use-of-Language" class="headerlink" title="Use of Language"></a>Use of Language</h2><p>这里作者同样提出了游戏设计语言缺乏的问题，关于这个问题，可以见<code>《Formal ABstract Design Tools》 笔记</code></p>
<h2 id="Defining-GamePlay"><a href="#Defining-GamePlay" class="headerlink" title="Defining GamePlay"></a>Defining GamePlay</h2><p>作者将玩游戏性定义为：在模拟环境下一个或多个相关联的挑战。</p>
<p>关于这个定义，作者要强调的是：</p>
<ol>
<li>基本元素是挑战，如一系列相关的选择并不是游戏（看哪部电影，吃哪个口味的爆米花）</li>
<li>游戏中的挑战是相互关联的，存在因果关系</li>
<li>挑战存在的环境应该是一个自洽的模拟环境</li>
</ol>
<h2 id="Pure-Challenges"><a href="#Pure-Challenges" class="headerlink" title="Pure Challenges"></a>Pure Challenges</h2><p>这里作者先定义了纯粹的挑战，纯粹的挑战是所有游戏挑战的原型。</p>
<p>许多种类的挑战都能被运用在游戏中，但是游戏中的挑战大多数是心理性质的，但也包含一部分身体上的挑战（如反应速度，眼手协调）。</p>
<p>游戏中的挑战可以分为显式挑战（Explicit Challenge）和隐式挑战（Implicit Challenge）。显示挑战是设计师故意设计的挑战，如时间限制。隐式挑战是由游戏中的元素自然形成的挑战，如一个多人的RPG游戏，自然而言会形成让玩家决定该如何分配资源的挑战。通常而言，显示挑战更直接和有紧迫感，隐式挑战更有吸引力。</p>
<p>接下来的都是作者定义的不同类型的<em>纯粹挑战</em>，并没有限定是游戏中存在的挑战。</p>
<h3 id="Logic-and-inference-Challenge"><a href="#Logic-and-inference-Challenge" class="headerlink" title="Logic and inference Challenge"></a>Logic and inference Challenge</h3><p>逻辑（Logic）和推理（Inference）挑战考验是测试玩家洗手信息并运用信息来做决策的能力。</p>
<p>逻辑主要在玩家拥有完整信息的时候使用，如围棋。<br>而当信息不完整的时候，逻辑就相对来说没有那么必要，信息的缺口必须通过推理能力来填充。推理是用已知的信息来推导，猜测未知信息的能力。如扑克牌中，熟练的玩家可以根据其他玩家丢出的牌，猜测他们手上持有的牌。</p>
<p>而例如星际争霸这样的游戏，玩家获得的也是不完整的信息。在游戏中，玩家需要根据不完整的信息推理出当前整个地图正在发生的情况（对手在干嘛），这对于玩家而言是个重要的挑战。</p>
<p>有完整信息的游戏通常存在一个问题：游戏元素太过于简单，当有完整信息的时候，游戏的挑战很容易就局限在逻辑上，如大部分的桌游。</p>
<p>而不完整信息对人来说是一个正常现象，因为人所处的真实世界就是不完整信息，且人有基本的好奇。所以不完整信息反而会更有吸引力。</p>
<h3 id="Lateral-Thinking-Challenges"><a href="#Lateral-Thinking-Challenges" class="headerlink" title="Lateral-Thinking Challenges"></a>Lateral-Thinking Challenges</h3><p>横向思考（Lateral-Thinking）挑战可以说是另一种推理挑战。横向思考能力是要玩家可以<strong>结合</strong>过去的经验和知识来完成任务。</p>
<p>这些经验和知识可以是内在的（Intrinsic），也可以是外在的（Extrinsic）。内在表示知识是从游戏世界中获取的，外在表示知识是从游戏外的世界获得的。</p>
<h3 id="Memory-Challenges"><a href="#Memory-Challenges" class="headerlink" title="Memory Challenges"></a>Memory Challenges</h3><p>记忆（Memory）挑战是要玩家可以回忆起以往的游戏。这是个纯粹内在的过程，即玩家需要回忆的信息完全是在游戏世界中的，不需要回忆正式世界中与游戏无关的其他信息。</p>
<h3 id="Intelligence-Based-Challenges"><a href="#Intelligence-Based-Challenges" class="headerlink" title="Intelligence-Based Challenges"></a>Intelligence-Based Challenges</h3><p>智力（Intelligence-Based）挑战是完全依赖于玩家智力的挑战。这种挑战在现实生活中和在游戏世界中都很少出现。通常而言，只有IQ测试数以一个完全依赖智力的挑战。</p>
<p>但是智力挑战常常与其他的挑战结合在一起。</p>
<h3 id="Knowledge-Based-Challenges"><a href="#Knowledge-Based-Challenges" class="headerlink" title="Knowledge-Based Challenges"></a>Knowledge-Based Challenges</h3><p>知识（Knowledge-Based）挑战依赖于玩家的知识。</p>
<p>同样如在横向思考挑战中提到的，这些知识可以是内在的，可以是外在的。</p>
<p>注意横向思考挑战考研的是结合过往知识的能力，而知识挑战是纯粹的挑战过去知识储备量，如问答。</p>
<p>但实际上大部分的知识挑战也是与横向思考挑战结合在一起的，同时内在的知识挑战几乎在所有游戏中都能找到。但是RPG游戏和冒险游戏中内在的知识挑战最为明显，如果说删除一个玩家的内在知识，如突然给他一个游戏中途的记录，玩家几乎很难玩下去，因为他缺乏了之前的内在知识，他无法了解游戏的进行。</p>
<h3 id="Pattern-Recognition-Challenges"><a href="#Pattern-Recognition-Challenges" class="headerlink" title="Pattern-Recognition Challenges"></a>Pattern-Recognition Challenges</h3><p>模式识别（Pattern-Recognition）挑战依赖人的大脑的基本能力就是模式识别。人的大脑会隐式的去构造一个对象的原型，然后将新遇到的事物与生成的原型们进行比较，来判断他们是属于哪个种类。</p>
<p>但是有的时候，人的模式识别能力又会错误的运行，出现了空想式的错误（Pareidolia）。如人长时间的看着云，就会觉得云像某个形状。</p>
<p>一些简单的游戏会利用人的模式识别能力，如俄罗斯方块。俄罗斯方块一局时间足够长后，方块下落的速度会非常快，这时候玩家已经很难识别出每个方块的具体形状，此时更多的依靠的是本能，即看到一个方块就知道他属于方块中的某一个。</p>
<p>模式识别处理信息会很快，但它要求信息足够的简单。通常模式识别会和一些反应速度挑战结合在一起，如游戏<em>德国心脏病</em>。</p>
<p>大部分的游戏实际或多或少都有模式识别，这让游戏对于玩家而言更可控（manageable）。如在游戏中，当看到一个门是可以打开的后，看到其他的长得不一样的门时玩家也会觉得他能被打开。马里奥游戏中，每个Boss的行为习惯通常和关卡与其他的Boss类似，所以玩家也能够将其归于某个模式中，能快速的猜测出正确的打法。</p>
<h3 id="Moral-Challenges"><a href="#Moral-Challenges" class="headerlink" title="Moral Challenges"></a>Moral Challenges</h3><p>道德（Moral）挑战是一个更高层次的挑战，道德通常由<code>universal</code>,<code>cultural</code>,<code>triibal</code>,<code>personal</code>四个层面，每个层面都比前一个层面范围要小一些。</p>
<p>通常来说，道德挑战并没有绝对的对错，如为了救饿死的老人去偷东西，到底是对还是错呢？同时玩家做出道德挑战时也会收到自己在现实生活中的影响。</p>
<p>游戏中的道德挑战应该是限定于游戏环境中的，如游戏世界中的<code>universal</code>就是游戏世界本身，需要注意的是，这个世界是由游戏设计师创建的，所以这个世界的逻辑，元素也是受限于设计师自己的能力。<code>culture</code>通常是指一个大区域的影响，如东方西方，<code>culture</code>也可以进一步被细分，如<code>美国</code>，<code>中国</code>，而文化层面的选择可以是“是否要接纳一个宗教”等。<code>tribal</code>是一个更小的层面，如家庭，队伍。小队层面的道德挑战最经典就是是否要去救某一个队友。<code>personal</code>层面的道德挑战即只影响做出抉择的个体自己。</p>
<p>道德挑战很少被认为是非黑即白的，玩家在一个道德困境中被迫做出决策通常是一个meaningful play的体现。</p>
<h3 id="Spatial-Awareness-Challenges"><a href="#Spatial-Awareness-Challenges" class="headerlink" title="Spatial-Awareness Challenges"></a>Spatial-Awareness Challenges</h3><p>空间认知（Spatial-Awareness）挑战通常是一个隐式的挑战。</p>
<p>目前绝大部分的电子游戏都是显示在2D平面上的，玩家需要根据2D平面的现实来想象出3D空间。在一些模拟游戏中，如飞行模拟，这种空间挑战更为明显，如玩家需要判断离地距离等。</p>
<h3 id="Coordination-Challenges"><a href="#Coordination-Challenges" class="headerlink" title="Coordination Challenges"></a>Coordination Challenges</h3><p>协调挑战通常是需要玩家执行一个模拟的行为，如跳跃，设计，躲避等，这个行为通常需要多个细小的操作结合在一起（鼠标决定访问，一个按键决定前进方向，另一个按键决定向上跳跃）。</p>
<p>同时协调挑战也常与时间元素结合在一起，如马里奥游戏中，跳跃的长短决定于玩家根据按键的时间，或玩家需要在确切的时间按下跳跃才能跳过障碍物。</p>
<p>协调条找的平衡很难，因为这个一定程度上与玩家的身体能力有关。</p>
<h3 id="Reflect-Reaction-Time-Challenges"><a href="#Reflect-Reaction-Time-Challenges" class="headerlink" title="Reflect/Reaction Time Challenges"></a>Reflect/Reaction Time Challenges</h3><p>反应速度挑战测试玩家对时间的把控能力，这个挑战通常会与其他的挑战结合在一起。</p>
<h3 id="Physical-Challenges"><a href="#Physical-Challenges" class="headerlink" title="Physical Challenges"></a>Physical Challenges</h3><p>生理挑战很少出现在游戏中。</p>
<p>但目前也有一些引用，如跳舞毯，Kinect。</p>
<h2 id="Applied-Challenges"><a href="#Applied-Challenges" class="headerlink" title="Applied Challenges"></a>Applied Challenges</h2><p>游戏中的挑战通常是上述的多个挑战的结合，一个游戏的挑战觉得了游戏玩家的反应，即决定了游戏的目标。</p>
<p>以下是几种挑战应用的例子。</p>
<h3 id="Races"><a href="#Races" class="headerlink" title="Races"></a>Races</h3><p>一种比其他的玩家更快获得胜利的形式，这种形式应用的挑战与游戏形式有关，可以是协调能力，可以是反应速度。</p>
<h3 id="Puzzles"><a href="#Puzzles" class="headerlink" title="Puzzles"></a>Puzzles</h3><p>谜题主要是是一种精神层面上的挑战，谜题需要玩家了解游戏内元素的关系，并做出实验并观察结果（推理，横向思考，识别等挑战）。</p>
<p>对于游戏设计而言，一个谜题不应该让玩家纯粹的去做实验和观察，需要给玩家足够的信息让玩家对于该如何进行有一定的思路。不然游戏本身就完全变成了无意义的盲猜。</p>
<h3 id="Exploration"><a href="#Exploration" class="headerlink" title="Exploration"></a>Exploration</h3><p>玩家通常会很喜欢新鲜事物和探索，但是如果只有探索元素，那么游戏就会变成观光，变得很无聊。所以通常的方法是将探索与挑战结合在一起。</p>
<p>如探索过程中有锁住的门，这样就结合了解密挑战。或者陷阱，但要注意陷阱必须以某种方式可以被玩家规避，否则这个陷阱的存在就是没有意义的（玩家的行为不造成任何的区别）。或者迷宫，一个优秀的迷宫应该结合谜题或者模式识别，让玩家可以从迷宫中获得走出去的线索，同时迷宫也需要玩家在闹钟包含有一个地图的信息，这又是记忆挑战。</p>
<h3 id="Conflict"><a href="#Conflict" class="headerlink" title="Conflict"></a>Conflict</h3><p>冲突是很多游戏的核心元素，通常冲突意味着某一方需要打败其他人获得胜利。</p>
<p>冲突的形式也可以是多种多样的，如策略上的冲突，道德层面上的冲突。</p>
<p>通常而言，小范围的冲突，即人与人之间的冲突，是更快速，让人激动和本能的（Visceral）。</p>
<h3 id="Economies"><a href="#Economies" class="headerlink" title="Economies"></a>Economies</h3><p>经济是指一个系统中资源可以被移动或交换，无论是物理上的移动位置，还是概念上的所有权改变。</p>
<p>大部分的游戏都包含有经济，如FPS中的，弹药（可以从别的玩家身上获取），生命值（被别的人家的行为消耗）。</p>
<p>经济上的挑战大多是要玩家理解游戏中的元素并知道该如何优化他们，如大富翁中理解房产意味着什么，并决定是否该购买，该升级的等。</p>
<p>许多游戏还会给玩家多个元素，让他们在元素之间获取平衡。如有些生存游戏，包含面包和水，玩家可以决定面包换水或水换面包，这种决策会引入meaningful play。</p>
<h3 id="Conceptual-Challenges"><a href="#Conceptual-Challenges" class="headerlink" title="Conceptual Challenges"></a>Conceptual Challenges</h3><p>概念上的挑战是要玩家可以理解新鲜事物。</p>
<p>对于游戏设计师而言，概念调整是最有趣的设计，因为它的自由度最高</p>
<p>侦探游戏可以看作是一种概念上挑战的游戏，玩家收集到的新证据就是新事物，而玩家需要能理解其背后隐藏的信息。</p>
<div class="note info simple"><p>引用：</p>
<ol>
<li>Andrew Rollings and Ernest Adams on Game Design. Andrew Rollings and Ernest Adams (2003)</li>
</ol>
</div>
<hr>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>游戏设计</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>游戏设计</tag>
      </tags>
  </entry>
  <entry>
    <title>《Andrew Rollings and Ernest Adams on Game Design chapters》 第八章笔记</title>
    <url>/RollingAndAdams-Chapter8-Notes/</url>
    <content><![CDATA[<p>《Andrew Rollings and Ernest Adams on Game Design chapters》 第八章笔记</p>
<span id="more"></span>
<h1 id="Chapter-8-The-Internal-Economy-of-Games-and-Game-Balacning"><a href="#Chapter-8-The-Internal-Economy-of-Games-and-Game-Balacning" class="headerlink" title="Chapter 8. The Internal Economy of Games and Game Balacning"></a>Chapter 8. The Internal Economy of Games and Game Balacning</h1><p>对于游戏平衡的问题很难有确切的答案，因为游戏平衡中需要牵扯到一个人为因素，即玩家本身。</p>
<p>设计师所考虑的游戏平衡是对于玩家的平均水平而言的，因为游戏很难对于各种水平的玩家都是平衡的。但这也就造成了设计游戏平衡时的一个常见问题，即设计师认为自己的水平即是平均水平，最后制作出一款自己很满意，但是玩家不满意的游戏。</p>
<h2 id="What-is-Game-balance"><a href="#What-is-Game-balance" class="headerlink" title="What is Game balance"></a>What is Game balance</h2><p>一个平衡的游戏，其获胜的主要因素应该是玩家的水平，这不是说平衡的游戏不能有意外因素，但技术好的玩家应该有更大的几率获胜，除非他这局的运气特别特别差。</p>
<p>游戏平衡就是个不断的实验-&gt;纠正（Trial-and-error）错误的过程。</p>
<p>对于电子游戏而言，存在太多的变量会影响玩家的体验，即它是一个N维空间的优化问题。一些传统的游戏研究可能并不适合于电子游戏，因为他们太过于简单。在一些其他学科中，有现成的N维空间优化解决技术，但是电子游戏与其他学科不同的点在于它有玩家这个人为因素，即各种变量的平衡并不是一个完全客观理性的数学问题。</p>
<p>反复的实验-&gt;纠正很可能是平衡电子游戏唯一的方法。但这个方法很浪费资源和时间，并且有个更严重的问题是，很难定义什么到底平衡的。</p>
<p>这里作者将平衡分为两种静态平衡（Static balance）和动态平衡（Dynamic balance）。</p>
<h2 id="STATIC-BALANCE"><a href="#STATIC-BALANCE" class="headerlink" title="STATIC BALANCE"></a>STATIC BALANCE</h2><p>静态平衡时关于游戏规则的，即这些规则时如何相互联系，如战争游戏中单位的战斗力，动作游戏中跳跃的距离等等。通常玩家们提及游戏平衡时，它们指的就是静态平衡。</p>
<p>在静态平衡游戏的过程中，设计师需要保证游戏是公平的，所有的元素都是无缝的相互联系，且不会有主导的或者一些隐藏的策略毁坏整个游戏的体验。</p>
<h3 id="Randomness-and-Average-Values"><a href="#Randomness-and-Average-Values" class="headerlink" title="Randomness and Average Values"></a>Randomness and Average Values</h3><p>通常可使用回报矩阵（Payoff matrices）来展示各个元素之间的平衡。如果有B1,B2,R1,R2四个元素，且它们的回报矩阵如下所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>B1</th>
<th>B2</th>
</tr>
</thead>
<tbody>
<tr>
<td>R1</td>
<td>0</td>
<td>-2</td>
</tr>
<tr>
<td>R2</td>
<td>3</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<p>这表示当R1遇到B1时，两者可能谁都不会占到便宜。当R1遇到B2时，则通常R1会损失2的数值。R2的分析同理。</p>
<p>回报矩阵的关键是，它是一个统计学意义上的值，即上表中的数值并不是针对于一个特定的事件，它是分析多个相似事件后得到的平均情况。</p>
<h3 id="Dominant-Strategies"><a href="#Dominant-Strategies" class="headerlink" title="Dominant Strategies"></a>Dominant Strategies</h3><p>占优策略（Dominant Strategies）是传统游戏理论中的术语。占优策略指的是指一个策略在所有情况下都能比其他策略更好。其中占有策略还可以进一步分为<code>强占优策略</code>和<code>弱占优策略</code>，前者是保证这个策略一定会赢，后者是保证这个策略一定不会输。</p>
<p>对于游戏而言，在大多数的情况下要避免占有策略的发生。</p>
<p>下面为作者举得一个占优策略的例子：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>Wife’s Birthady</th>
<th>No Wife’s Birthday</th>
</tr>
</thead>
<tbody>
<tr>
<td>Buy Flowers</td>
<td>10</td>
<td>20</td>
</tr>
<tr>
<td>Don’t but Flowers</td>
<td>-100</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<p>可以看出，无论那种情况下（是妻子生日或者不是），买花都是一个更好的策略，即买花是占优策略。</p>
<p>如果将这个例子运用到游戏中，就需要通过加上其他的限制来避免其成为占优策略，如给花一个昂贵的售价，那么在非妻子生日时买花就会有一个负得分。</p>
<p>但如之前所述，电子游戏中有太多的变量，对于一个玩家的占优策略可能对于另一个玩家就不是。</p>
<p>一个理想化的解决方法是模拟一个完美的玩家，这个玩家只会做出最优的解，然后用来完美玩家进行测试，避免占优策略的出现。但是这个方法还是与现实有误差，这个方法是一个数学层面上的解决方案，但因为几乎所有的玩家都不会是“完美玩家”，因此对于实际游戏的参考价值并不是很大，大多数的游戏都无法列出一个完整的回报矩阵。</p>
<p>在游戏中，通常会有三个原因造成占优策略的发生：</p>
<ol>
<li>战术导致，如RTS游戏中，当近点时Rush通常会有很好的收益</li>
<li>不平衡的单位，如一个单位设计的过强，只要生产该单位就大概率能获得胜利</li>
<li>Bug，金手指之类的方法，将直接破坏游戏平衡</li>
</ol>
<p>游戏中的占优策略能让玩家更容易的获得胜利，但是对于大部分的玩家而言，游戏是为了乐趣而不是为了赢。</p>
<h3 id="Symmetry"><a href="#Symmetry" class="headerlink" title="Symmetry"></a>Symmetry</h3><p>对称（Symmetry）是最简单的平衡游戏的方法。</p>
<p>如象棋，开局时双方的棋子类型，位置是完全一样的，这造就了游戏的平衡。但是像象棋这样的镜像对称通常只能运用于一些抽象概念的游戏中，因为这种对称会让玩家觉得不自然和一定程度上的无聊。</p>
<p>但是体育模拟游戏又是一个例外，因为即是在现实生活中，很多体育游戏都是对称的（同意的人数，同意的人员分配）。</p>
<p>要注意的是，游戏中的对称指的是功能上的对称，而不是完全的一样，如体育游戏中，双方都有2个后卫，但这两个后卫的能力可能是不一样。</p>
<p>RTS游戏中对称平衡，如一个玩家开局被山包围，另一个玩家开局被水包围等等。</p>
<p>对称的平衡方式消灭了平衡中的许多变量，简化了平衡工作，但是这也容易导致玩家的行为受限于某种方式，让游戏不再有趣。</p>
<h3 id="Transitive-Relationships"><a href="#Transitive-Relationships" class="headerlink" title="Transitive Relationships"></a>Transitive Relationships</h3><p>传递关系（Transitive Relationships）定义了多个元素之间一种单向的关系。如下图所示，A能打败B，B能打败C</p>
<p><img src="RollingAndAdams-Chapter8-Notes/2020-03-22-14-53-57.png" alt="传递关系"></p>
<p>这种关系的回报矩阵如下：</p>
<p><img src="RollingAndAdams-Chapter8-Notes/2020-03-22-14-54-19.png" alt="传递关系回报矩阵"></p>
<p>传递关系在游戏中非常常见，如FPS单机游戏中，玩家的装备越来越好，怪越来越强。这些装备之间形成了传递关系，怪物之间也形成了传递关系，即游戏后段的武器和怪物无疑可以轻易打败游戏初期的武器和怪物。</p>
<p>传递关系在游戏中主要是为了鼓励玩家持续的推进游戏进度。在游戏的过程中，玩家会越来越强，但这个传递关系也会有一个重点，如玩家的死亡或游戏结束。</p>
<p>还有一种三元的非传递关系（three-way intransitive relationship），最简单的例子就是游戏<em>石头剪刀布</em>，如下所示：</p>
<p><img src="RollingAndAdams-Chapter8-Notes/2020-03-22-16-23-16.png" alt="石头剪刀布"></p>
<p>回报矩阵：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>Scissors</th>
<th>Paper</th>
<th>Rock</th>
</tr>
</thead>
<tbody>
<tr>
<td>Scissors</td>
<td>0</td>
<td>1</td>
<td>-1</td>
</tr>
<tr>
<td>Paper</td>
<td>-1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>Rock</td>
<td>1</td>
<td>-1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<p>石头剪刀布是一个零和的游戏，但是游戏也可以设计为非零和的游戏。</p>
<p>这种非传递关系相较于传递关系更有趣。但是它很容易被玩家找出规律所在，然后玩家可能就会通过某些策略来规避这种关系，所以通常在游戏中需要用其他元素来包装这个关系，或者说关系在游戏中可以动态的发生变换。</p>
<h3 id="Trade-Offs"><a href="#Trade-Offs" class="headerlink" title="Trade-Offs"></a>Trade-Offs</h3><p>权衡（Trade—Offs）在游戏中也是一个非常常见的元素。它是指某一个元素一方面比另一个元素好，但是另一方面又不如另一个元素。</p>
<p>如游戏中常出现的数显就是权衡的设计，就是力量，敏捷，智力三个属性。玩家在升级后，可以选择其中一个属性进行加点。</p>
<p>通常来说，设置用来进行权衡的元素是需要相互独立（orthogonal）的，否则玩家的选择就没有意义。如一个属性表示质量，另一个属性表示浮动力，这两个属性实际上是相关的，玩家选了其中一个就会很大程度上影响另一个。</p>
<p>同时，也要保证多个用来权衡的元素，相互之间的收益的相等的，虽然它们的收益体现在不同的方面。</p>
<h3 id="Combination"><a href="#Combination" class="headerlink" title="Combination"></a>Combination</h3><p>有些情况下，当平衡游戏时，多个单独的元素可以组合在一起视作同一个元素，一起来平衡，如RTS游戏中的兵种组合。</p>
<p>通常来说，如果每个单独元素在设计时平衡的很好，那么它们组合在一起后，平衡也不会太差。</p>
<h3 id="Emergence"><a href="#Emergence" class="headerlink" title="Emergence"></a>Emergence</h3><p>出现（Emergence）是一系列简单的规则组合成一个复杂的结果。在现实生活中，也有许多Emergence的元素，看，听，触摸这些简单的规则构成了生活中大部分的复杂行为。</p>
<p>如在第八章中作者定义的，游戏是一个模拟环境，受限于硬件和软件的实现，游戏世界不可能将现实生活中所有元素都包含进来，通常游戏只会包含一部分的元素。</p>
<p>但是优秀的游戏，应该让这些被包含进的元素可以被完美的运用，让它们能组合成一个复杂的情况，这就是Emergence的魅力。如塞尔达传说，马里奥都是很好的运用Emgerence的例子。</p>
<p>当然Emergence也有缺点，如果被包含进来的元素并没有完全被利用，那么这些仅含的元素就会变成玩家仅有的玩法，游戏就会变得无趣。另外如果某一个元素不平衡， 则很可能导致占优策略。</p>
<h3 id="Feedback-Loops"><a href="#Feedback-Loops" class="headerlink" title="Feedback Loops"></a>Feedback Loops</h3><p>关于反馈系统，在<code>《Rules of Play》 第十八章笔记</code>有详细说明。</p>
<p>反馈系统是静态平衡与动态平衡的交界线，它开始时的状态是静态平衡的，但是运行后就是动态平衡了。</p>
<h3 id="Summary-of-Static-Balance"><a href="#Summary-of-Static-Balance" class="headerlink" title="Summary of Static Balance"></a>Summary of Static Balance</h3><p>静态平衡时关于游戏规则，游戏初始状态下的平衡。</p>
<p>动态平衡则是关于玩家与游戏系统交互的平衡。</p>
<h2 id="DYNAMIC-BALANCE"><a href="#DYNAMIC-BALANCE" class="headerlink" title="DYNAMIC BALANCE"></a>DYNAMIC BALANCE</h2><p>动态平衡可以分为两种，第一种是消极平衡，第二种是主动平衡。</p>
<ol>
<li>消极平衡是指修改系统，让系统始终对于玩家而言是平衡的，而且平衡点不会改变</li>
<li>主动平衡是指针对于玩家的行为，动态的修改平衡点。</li>
</ol>
<h3 id="What-are-we-balancing？"><a href="#What-are-we-balancing？" class="headerlink" title="What are we balancing？"></a>What are we balancing？</h3><p>但无论是哪种平衡，其关键都是重新在平衡点处构成平衡。</p>
<p>平衡游戏的目的是让游戏公平且统一，不会允许玩家去找出错误或游戏的弱点来获取额外的优势。</p>
<p>一个游戏应该保证在初始时是平衡的（通过静态平衡设置的各种规则，在运行时通过动态平衡也保证平衡。</p>
<p>通常动态平衡有以下三种平衡方式：</p>
<ol>
<li>恢复平衡</li>
<li>保持平衡</li>
<li>摧毁平衡构建新平衡点</li>
</ol>
<h3 id="Restoring-a-Balance"><a href="#Restoring-a-Balance" class="headerlink" title="Restoring a Balance"></a>Restoring a Balance</h3><p>如果玩家的目标是恢复平衡，那么游戏的目标就是让游戏系统重回平衡点。游戏系统中会有力量创造出不平衡状态，但是当玩家介入后，这个力量应该消失或者变得微弱，让玩家可以重新将系统变为平衡。</p>
<p>如拼图游戏，就是一个从混乱状态（不平衡），通过玩家的操作逐渐恢复平衡的过程。</p>
<h3 id="Maintaining-Balance"><a href="#Maintaining-Balance" class="headerlink" title="Maintaining Balance"></a>Maintaining Balance</h3><p>如果玩家的目标是保持平衡，那么游戏的目标就是阻止让游戏不平衡的力量。</p>
<p>如俄罗斯方块，在一开始的游戏状态是整洁的，玩家的行为就是不要让新出来的方块破坏平衡。在游戏的过程中，破坏平衡的力量会越来越强（方块下落越来越快），这就对玩家构成了挑战。</p>
<h3 id="Destroying-a-Balance"><a href="#Destroying-a-Balance" class="headerlink" title="Destroying a Balance"></a>Destroying a Balance</h3><p>如果玩家的目标是破坏平衡，那么游戏系统就会尝试去恢复平衡（玩家和系统的角色与在<code>恢复平衡</code>时的角色相反）。</p>
<p>注意这个破坏平衡，并一定指从平衡状态变为混乱状态，它也可以是从一个平衡状态变为另一个平衡状态。</p>
<p>如一个RPG游戏，游戏开始的设定是外星人统治了世界，这已经是一个平衡的状态了，玩家的任务就是让这个世界变为人类统治的世界（变为另一个平衡状态）。</p>
<h2 id="Balanced-Systems"><a href="#Balanced-Systems" class="headerlink" title="Balanced Systems"></a>Balanced Systems</h2><p>游戏平衡的目标是为了保证玩家的游戏体验，可以从以下几个角度分析：</p>
<ol>
<li>提供一个恒定的挑战</li>
<li>给玩家一个可预料的，公平的游戏体验</li>
<li>防止停滞（Stagnation）</li>
<li>防止琐事（Trivialities）</li>
<li>允许设置不同难度（可选）。</li>
</ol>
<h3 id="Providing-a-Consistent-Challenge"><a href="#Providing-a-Consistent-Challenge" class="headerlink" title="Providing a Consistent Challenge"></a>Providing a Consistent Challenge</h3><p>一个游戏的难度应该在玩家进行时平缓的增加，但有些游戏违背了这个规则，游戏的难度在中途比游戏后期更难，这种设计很容易让玩家在中途过后，突然觉得游戏变的无聊。</p>
<h3 id="Providing-a-Perceivably-Faip-Playing-Experience"><a href="#Providing-a-Perceivably-Faip-Playing-Experience" class="headerlink" title="Providing a Perceivably Faip Playing Experience"></a>Providing a Perceivably Faip Playing Experience</h3><p>玩家享受游戏的一个重要原因就是玩家是否觉得这个游戏是公平的，可预测的。这里的公平指的是玩家觉得是否公平，而不是要求游戏本身绝对公平。</p>
<p>游戏中可以设计一些欺骗的行为，如当玩家处于最后一名时，倒数几名的赛车速度会慢下来。但是这种欺骗行为不要让玩家意识到。</p>
<p>另外游戏中，如果某些事情会让玩家没有胜利可能，那么这些事情应该在早期就让玩家知道，或者透露出足够的线索。如游戏最后需要一把钥匙开门，在游戏前期就需要通过某些方法告诉玩家要去寻找钥匙，而不是到了最后玩家发现自己只能重新读档。或者玩家知道最后需要某个东西开门，但是设计并没有给出这个东西的线索，需要玩家自己去猜是需要钥匙，还是魔法书，一旦猜错只能读档重来。</p>
<p>这里的关键就是让游戏的推进是利用玩家已知的知识和信息。如果一个游戏，玩家必须通过攻略或重新读档这样的方式才能进行，那么这个游戏的设计是失败的。</p>
<p>另一个重要的保证玩家觉得游戏公平的因素，就是保住新玩家。当新玩家加入游戏，并被有经验的玩家屠杀时，很容易就觉得这个游戏不公平。通常很多游戏提供的单人模式就是为了保护新人玩家，给新玩家一个练习自己技术的地方。</p>
<p>游戏中的死亡也是一样的道理，通常来说，如果一个玩家失败了，他应该要明确的知道自己死亡的原因，即这个原因是可控的，即玩家需要有方法可以避免死亡。</p>
<h3 id="Avoiding-Stagnation"><a href="#Avoiding-Stagnation" class="headerlink" title="Avoiding Stagnation"></a>Avoiding Stagnation</h3><p>停滞在游戏中是一个很恼怒的状态，指的是当玩家在游戏中抵达了一个进度，然后不知道自己该如何推进。</p>
<p>在很多情况下，停滞是很难被避免的，因为不同玩家的思考能力，探索能力是不同的。但这个可以通过平衡来解决，如当游戏发现玩家在一个地方停留了太久后，给出多余的提示等。</p>
<h3 id="Avoiding-Trivialities"><a href="#Avoiding-Trivialities" class="headerlink" title="Avoiding Trivialities"></a>Avoiding Trivialities</h3><p>琐事指的是，玩家需要做出大量的零碎的决定，而且这些决定对于游戏的最终结果没有明确的影响。</p>
<p>的确有的游戏会通过零碎的决定让玩家更有参与感，但是这些选择应该是可选的，即玩家是自愿去做琐碎的决定，而不是被强迫去做。</p>
<p>RTS游戏中也存在许多细小的决定，如决定每个单位如何行走等。但是这些决定对于最终的游戏结果是有影响的，所以不算是琐事。</p>
<h3 id="Setting-the-Difficulty-Level"><a href="#Setting-the-Difficulty-Level" class="headerlink" title="Setting the Difficulty Level"></a>Setting the Difficulty Level</h3><p>游戏玩家第一次接触游戏的平衡工作，就是选择难度。通常来说，难度会分为四个等级，简单，正常，困难，噩梦。</p>
<p>网络游戏中通常没有难度选择，它们通过将不同的玩家进行分割来处理难度水平（处于不同的地图，处于不同的天梯等级）。</p>
<p>还有一些游戏会通过动态调节游戏难度，如当玩家表现很差时，降低游戏难度，让表现很好时增加游戏难度。但这个方法有两个缺点。第一，会给玩家造成被欺骗感，第二，玩家可能利用这个规则，如故意表现得很差降低游戏难度。</p>
<p>通常来说，单机游戏中的难度选择会通过两种方式改变难度，敌人更强或者敌人更多。如简单难度每过一关，敌人数目增加5%，正常难度每过一关，敌人数量增加10%。</p>
<p>现在的一些单机游戏，还会通过让敌人更聪明来增加难度，即修改AI的表现。</p>
<h2 id="Tools-For-BALANCING"><a href="#Tools-For-BALANCING" class="headerlink" title="Tools For BALANCING"></a>Tools For BALANCING</h2><h3 id="Design-for-Modification"><a href="#Design-for-Modification" class="headerlink" title="Design for Modification"></a>Design for Modification</h3><p>当设计游戏时，应该是面向修改设计的。</p>
<p>为了能更好的修改，通常先设计游戏规则，再设计游戏运用这些规则的元素。一旦规则被平衡了，修改其中的元素不会让平衡效果偏差的太过于严重，在规则的限制下，这些元素也不会相互干扰。</p>
<p>如之前所述，游戏平衡工作是一个反复试错的过程，在修改元素或规则来进行平衡时，要记得控制变量法</p>
<h3 id="Design-Prototyping"><a href="#Design-Prototyping" class="headerlink" title="Design Prototyping"></a>Design Prototyping</h3><p>在开发一款游戏前，应该先开发一个游戏的模板，最好用一个简单的程序语言进行开发。</p>
<h3 id="Future-Potential"><a href="#Future-Potential" class="headerlink" title="Future Potential"></a>Future Potential</h3><p>因为手动的进行参数的平衡并不高效，未来可能会有自动手机玩家数据，然后进行参数调整的平衡方法。如发现某一个英雄被玩家使用的过多，且胜率很高，自动下调这个英雄的一些属性。</p>
<div class="note info simple"><p>引用：</p>
<p>1.<em>Rules of Play</em> 2003</p>
</div>
<hr>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>游戏设计</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>游戏设计</tag>
      </tags>
  </entry>
  <entry>
    <title>《Rules of Play》 第十五章笔记</title>
    <url>/RulesOfPlay-Chapter15-Notes/</url>
    <content><![CDATA[<p>《Rules of Play》 第十五章笔记</p>
<p>这一章中，作者区分了宏观层面和微观层面的不确定性。</p>
<p>再将不确定性分为三种<code>certain</code>，<code>uncertain</code>，<code>risk</code>。</p>
<p>之后通过两个例子说明，不确定性如何结合到游戏中。</p>
<p>最后提出了数学层面上的概率与玩家体会到的概率之间是存在差距的。</p>
<span id="more"></span>
<h1 id="Chapter-15-Games-as-Systems-of-Uncertainty"><a href="#Chapter-15-Games-as-Systems-of-Uncertainty" class="headerlink" title="Chapter 15: Games as Systems of Uncertainty"></a>Chapter 15: Games as Systems of Uncertainty</h1><h2 id="Introducing-Uncertainty"><a href="#Introducing-Uncertainty" class="headerlink" title="Introducing Uncertainty"></a>Introducing Uncertainty</h2><p>不确定性是每个游戏的核心特征。正是有位对游戏结果的不确定性，才能给玩家目的感，如果游戏的结果是确定的，那么玩家何必要玩呢？玩家的行为并没有造成任何的区别，换句话来说，不确定性一定程度上提供了游戏的意义。</p>
<p>游戏的不确定性可以从两个层面表达：</p>
<ol>
<li>宏观层面（Macro-level）：游戏总体的结果的不确定性</li>
<li>微观层面（Micro-level）：游戏中设计的特定行为的结果</li>
</ol>
<p>“不确定性”这个词本身表示了随机性和机会，但这并不意味着只有那些包含随机性（如色子）的游戏才有不确定性，由技能主导的游戏同样有不确定性（围棋的胜负是不确定的）。</p>
<p>所有游戏在宏观层面都提供了不确定性，但是在微观层面并不是都提供了（如围棋）。</p>
<h2 id="Certainty，Uncertainty，and-Risk"><a href="#Certainty，Uncertainty，and-Risk" class="headerlink" title="Certainty，Uncertainty，and Risk"></a>Certainty，Uncertainty，and Risk</h2><p>数学家Richard Epstein在<em>The Theory of Gambling and Statistical Logic</em>一书中将所有的赌博行为都描述为是一种决策，而决策又可根据行为与结果之间的关系，分为三种：<code>不确定（uncertainty）</code>，<code>冒险（risk）</code>，<code>确定（certainty）</code>。</p>
<ol>
<li>确定<br>一个完全是<code>确定</code>的游戏很难称作为游戏，因为结局已定，玩家的行为没有任何影响，玩家也很难感受到快乐。</li>
<li>冒险<br><code>冒险</code>也是用来描述不确定的情况的，只不过在这个情况，玩家对于不确定性的信息是了解的，如知道概率等。如丢硬币游戏就是冒险游戏，虽然最后的结果不知道，但是玩家知道每个结果发生的概率都是50%。</li>
<li>不确定<br>剩下的<code>不确定</code>分类中，玩家对于当前的不确定情况不知道任何信息。如随机加入一场网上的围棋比赛，在比赛前对手的实力是完全不确定的，他可能是一个职业选手，也可能是个完全的菜鸟。</li>
</ol>
<p>大部分的游戏都是<code>冒险</code>和<code>不确定</code>的结合。</p>
<h2 id="The-Feeling-of-Randomness"><a href="#The-Feeling-of-Randomness" class="headerlink" title="The Feeling of Randomness"></a>The Feeling of Randomness</h2><p>玩家的不确定感并一定来自于游戏中的随机事件。</p>
<p>如跳棋，虽然游戏中的每一步都是玩家自己的选择，但是如果你在别人的回合时闭上眼镜，然后只在自己的回合睁开。<br>    a. 对于经验不丰富的玩家，睁眼时的场景会有不确定感，因为他无法从游戏的场景中抽取出逻辑，当前的情况对他而言就如同是随机的。<br>    b. 对于经验足够丰富的玩家，他或许就可以从这个场景中猜测出前面的其他玩家做出了什么行为，对于他而言这个实验就没有不确定感。</p>
<p>上述例子中，玩家的不确定感是来自于玩家自己的经验，而不是游戏中的随机设计。</p>
<p>游戏中是否让玩家有随机感比游戏中是否真的有随机因素更重要。如果一个游戏完全没有随机感，那么玩家可能会觉得很无聊，或者觉得竞技性过强。如果一个游戏随机感过多，玩家可能就会觉得游戏很混乱。但无论是什么情况，最重要的都是让玩家的选择是有意义的，即使没有随机感，也要让玩家能通过技巧改变结果，即使很混乱，也要让玩家觉得可以通过某个策略来改变结果。</p>
<h2 id="Probability-in-Games"><a href="#Probability-in-Games" class="headerlink" title="Probability in Games"></a>Probability in Games</h2><p>这一节是针对微观层面机会的研究。数学上对于不确定性的描述为“概率（Probability）”。</p>
<p>对于概率的研究，有一定的矛盾感：</p>
<ol>
<li>概率本身给游戏带来了随机感和混乱，即增加了不确定性</li>
<li>对于概率的研究却让玩家知道了不确定性的本质，即从uncertain像risk转变，减少了不确定性</li>
</ol>
<h2 id="Dice-Probability"><a href="#Dice-Probability" class="headerlink" title="Dice Probability"></a>Dice Probability</h2><p>这一节作者首先推导了一个色子筛出各点数的概率，又推到了两个色子筛出各点数的概率，这里不赘述。</p>
<p>之所以要求得不同情况的概率，是因为对于概率的了解与玩家的决定与玩家游戏时的结果是相关的。</p>
<p>如两个色子筛出7的概率最大，通常大富翁棋盘有40格。这意味着6轮游戏后很可能就有玩家走到了第二圈，这时候游戏就会出现踩到别人财产付租金的情况了。</p>
<h2 id="Change-and-Game-Play"><a href="#Change-and-Game-Play" class="headerlink" title="Change and Game Play"></a>Change and Game Play</h2><p>对于那些完全由概率决定的游戏，玩家对于游戏的结果本质上是没有任何控制性的，游戏的结果纯粹由概率决定，玩家只能被动的接受游戏的结果。Rogor Caillois认为这样的游戏是没有意义的，但实际上许多完全由概率决定的游戏很有趣，最简单的就是丢硬币。</p>
<p>这里作者给出了两个具体的例子帮助分析，第一个是蛇梯棋（Chutes and Ladders），如下图所示：</p>
<p><img src="RulesOfPlay-Chapter15-Notes/2020-03-20-22-00-01.png" alt="蛇梯棋"></p>
<p>在蛇梯棋中，玩家不需要做任何决策，他要做的只是扔色子，然后移动相应的步数（碰到梯子的下段，则自动移动到顶端，碰到蛇的头部则自动滑落到蛇的底部）。</p>
<p>虽然游戏是完全由概率决定的，但是梯子和蛇这两个元素的存在，让玩家前进的速度不再是只有色子决定，即增加了许多的意外因素，而玩家对于意外因素的渴望就构成了乐趣，掷色子的意义变为了“遇到梯子，避免蛇”。</p>
<p>同样的还有彩票，彩票本质上也是个纯粹概率游戏。玩家需要选取一个彩票形式（刮刮卡还是双色球），以及选取一个数字。虽然这个选取过程严格意义上来说是没有意义的，无论怎么选结果都是完全由概率决定。但是这个选取的过程，让玩家对于纯粹的概率游戏有了“参与感”，会有寄托于自己好运的感觉。</p>
<p>因此meaningful play也不一定完全来自于玩家的策略选择与对应的结果，也可能来自于运气的假象。</p>
<p>这里作者给出了两个使用概率来增添游戏趣味性的例子，第一个是<em>雷暴</em>，第二个是<em>小猪</em></p>
<h3 id="Case-Study-One：-Thunderstorm"><a href="#Case-Study-One：-Thunderstorm" class="headerlink" title="Case Study One： Thunderstorm"></a>Case Study One： Thunderstorm</h3><p><em>雷暴（Thunderstorm）</em>是德国很著名的家庭游戏。</p>
<p>这个游戏是多人参加，通常4-8人比较合适，需要六个色子。<br>    a. 第一个玩家丢出所有的色子，如果其中出现了1，则安全通过，将所有是1的色子取出，将剩下的色子顺时针给下一位玩家。如果玩家丢除的色子中没有1，则在自己面前画一笔房子，然后将色子传给下一位玩家。<br>    b. 如果某个玩家面前的房子已经完成，且又遇到了没有丢出1的情况，则该玩家被淘汰。<br>    c. 当只有一个玩家时，游戏结束，剩下的玩家为胜者。</p>
<p>房子如下所示：</p>
<p><img src="RulesOfPlay-Chapter15-Notes/2020-03-20-22-51-55.png" alt="雷暴游戏"></p>
<p>雷暴这个游戏也是个纯粹的运气游戏。但是这个有趣的点在于每一轮玩家拿到的色子数量是不确定的，第一个玩家有6个色子，所以色出1的概率很高。之后随着游戏的进行，将色出过1的色子逐渐拿走，很可能之后的玩家只有一个色子，此时色出1就很困难了。</p>
<p>在游戏中，每个玩家的概率是由之前玩家的结果决定的，这提供了一定的戏剧性并且会有紧张的气氛在（每个人都不希望他前面的玩家色出很多1）。这种戏剧性和紧张氛围赋予了游戏的意义。</p>
<h3 id="Case-Study-Two：Pig"><a href="#Case-Study-Two：Pig" class="headerlink" title="Case Study Two：Pig"></a>Case Study Two：Pig</h3><p>小猪（Pig）也是多人参与，通常3-5人比较合适，需要一个色子。<br>    a. 第一个玩家丢出色子，色子的点数即为获取的分数。玩家可以选择继续丢色子，然后累加获取的分数。但如果丢出了1，则这一轮累加的所有分数清零。玩家也可以选择不丢色子，那么这一轮获取的分数就会记录在本子上。<br>    b. 当上一个玩家选择不丢色子后，色子顺时针给下一个玩家，重复上述操作。<br>    c. 直到某一个玩家分数到达100分，游戏结束。该玩家会获胜者。</p>
<p>小猪游戏中玩家需要做出决策（继续丢色子，还是放弃），每个决策的结果是不可控的，是由概率（玩家可以算出概率）决定的，选择继续丢可能加分也可能失去这一轮所有分数。</p>
<p>游戏的趣味性来源于玩家的决策和概率之间的抗衡，随着丢色子的次数越来越多，丢出1的概率也就越大。玩家此时的决策也会更加的困难，这也会增加紧张气氛。这种抉择和紧张气氛赋予了游戏的意义。</p>
<h2 id="Breakdowns-in-Uncertainty"><a href="#Breakdowns-in-Uncertainty" class="headerlink" title="Breakdowns in Uncertainty"></a>Breakdowns in Uncertainty</h2><p>这一部分作者讨论了一些概率元素最终并不没有像设计师预想的那样工作的情况。</p>
<h3 id="Breakdown-1-Computer-Randomness"><a href="#Breakdown-1-Computer-Randomness" class="headerlink" title="Breakdown 1: Computer Randomness"></a>Breakdown 1: Computer Randomness</h3><p>实际上计算机并不能产生随机数字，所有产生随机数的程序都是伪随机。但是对于大部分的游戏设计来说，计算机产生的伪随机数也足够用了。只是设计师要记住，计算机生成的随机数有时是会出错的。</p>
<p>比如理想上1-100的随机数，出现的数字是均匀的分布在1-100之中的，但可能因为程序的出错，在每个区间的数组出现的概率特别大。</p>
<h3 id="Breakdown-2：Strategizing-Change"><a href="#Breakdown-2：Strategizing-Change" class="headerlink" title="Breakdown 2：Strategizing Change"></a>Breakdown 2：Strategizing Change</h3><p>第二个要注意的是，玩家会不会通过某种策略将改变了原先的随机事件想要达成的效果。例如小队中的成员在个特定时间段随机一位受到伤害，玩家会不会通过在特定时间前踢出一些弱小玩家，来避免他们收到伤害。</p>
<h3 id="Breakdown-3：-Probability-Fallacies"><a href="#Breakdown-3：-Probability-Fallacies" class="headerlink" title="Breakdown 3： Probability Fallacies"></a>Breakdown 3： Probability Fallacies</h3><p>概率存在一些谬论（Fallacies），即玩家理解中的概率，和真实的概率可能是不一样的。</p>
<p>以下是一些常规的谬论：</p>
<ol>
<li>高估大赌注（Overvaluing the long shot）：即对于低可能，但是高回报的项目会有过多的自信，即会更倾向于选择低可能高回报的项目，而不是选择一个更安全的项目。</li>
<li>认为概率是累加的（The tendency to think of successive chance events as additive）：一个色子时丢出1的概率是1/6，但是丢出2个色子时出现1的概率，并不是2/6,而是11/36。</li>
<li>蒙特卡洛现象（The Monte Carlo Syndrome）：即认为上一次的事件会影响下一次的事件。但实际上多次没有丢出6，和下一次丢不丢出6并没有关系。</li>
<li>过度关心好结果（Overemphasis on good outcomes）：人们会高估一个好结果事件发生的概率。中彩票和被车撞实际上概率时差不多的，但是人们会更相信自己能中彩票而不是被车撞。</li>
<li>雷击两次现象（Lightning striking twice）：和蒙特卡洛现象类似，人们也会倾向于认为好事成双和低概率坏事不会多次发生（连续被雷击中），但实际上一个事件发生的概率和之前事件并没有联系。</li>
<li>好运（Luck）：纯粹从数学角度来说，并没有好运这个东西。</li>
</ol>
<p>上述的每个谬论对于设计而言都是一个重要提示，比如设计师给了玩家两个选择，一个是低可能高回报，一个是低回报高可能，设计师就要预见到玩家会更倾向于选择前者。设计师的设计目标玩家感受到的随机性，而不是真实数学意义上的随机性。</p>
<p>同时上述提及的三个概率方面的破坏（Breakdown），实际上也可以被运用。针对电脑伪随机，是否可以以此作为灵感，故意设计一个不是那个平衡的随机方法。针对策略规避概率，是否故意的允许玩家去采取某些策略。针对谬论，是否故意设计一个运气系统，虽然运气在理性层面上是不存在的。</p>
<h2 id="Meaningful-Chance"><a href="#Meaningful-Chance" class="headerlink" title="Meaningful Chance"></a>Meaningful Chance</h2><p>几率存在的意义并不是单纯的增加不确定性。它是要给玩家好处，或者坏处，或者某种信念，如“我希望得到xxx”，“我猜我能得到XXX”等等。</p>
<div class="note info simple"><p>引用：</p>
<p>1.<em>Rules of Play</em> 2003</p>
</div>
<hr>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>游戏设计</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>游戏设计</tag>
      </tags>
  </entry>
  <entry>
    <title>《Rules of Play》 第十七章笔记</title>
    <url>/RulesOfPlay-Chapter17-Notes/</url>
    <content><![CDATA[<p>《Rules of Play》 第十七章笔记</p>
<p>这一章中，作者将信息看作游戏中可以被交互的一部分，玩家通过对于信息的交互获得meaningful play。</p>
<p>信息可以分为完整信息和不完整信息。</p>
<p>信息也可以根据了解的对象被分为四种：被所有玩家知道，只被一个玩家知道，只被游戏知道，随机产生。</p>
<p>同时，作者用桌游<em>魔法森林</em>作为例子，讲述了信息是如何运用在游戏中的。</p>
<span id="more"></span>
<h1 id="Chapter-17-Games-as-Systems-of-Information"><a href="#Chapter-17-Games-as-Systems-of-Information" class="headerlink" title="Chapter 17: Games as Systems of Information"></a>Chapter 17: Games as Systems of Information</h1><h2 id="Introducing-a-Different-Kind-of-Information"><a href="#Introducing-a-Different-Kind-of-Information" class="headerlink" title="Introducing a Different Kind of Information"></a>Introducing a Different Kind of Information</h2><p>这一章中，将游戏看作是一个交互系统，信息是其中一个用来玩的元素。针对不同的游戏，信息可以获取，可以被隐藏，或重新安排，被遗忘等等。如游戏扑克牌，玩家要考虑的就是如何隐藏信息（自己手上的牌），和推测出别人的信息（别人手上的牌）。</p>
<h2 id="Prefect-and-Imperfect-Information"><a href="#Prefect-and-Imperfect-Information" class="headerlink" title="Prefect and Imperfect Information"></a>Prefect and Imperfect Information</h2><p>完整信息（Perfecc Information）是指所有玩家在任意时刻都知道的元素，如下围棋时，棋盘上棋子的位置。<br>不完整信息（Imprefect Information）是指在游戏过程中，一部分的信息对于玩家而言是隐藏的。</p>
<p>一个游戏中的信息，无论是完整的还是不完整的，都不影响其成为一个meaningful play的游戏。只是信息的情况不同，设计的思路也需要相应变化。如对于完整信息的游戏，它更适合做对抗性的游戏。而不完整的游戏，更适合包含一些神秘故事，或者背叛，诡计，策略等设计元素</p>
<p>设计师Celia Pearce在他的书<em>The interactive Book</em>中将游戏信息分为了四种：</p>
<ol>
<li>所有玩家都知道的信息：被丢出的牌</li>
<li>只有一个玩家知道的信息：玩家自己手中的牌</li>
<li>只有游戏知道的信息，如扑克牌中还没有被发给任一玩家的牌</li>
<li>随机产生的信息：如色子</li>
</ol>
<p>在游戏中，信息所处的类别是在发生变化的，如一张牌在还未发出时，是<code>只有游戏知道的信息</code>，当发给一个玩家后，就成为了<code>只有一个玩家知道的信息</code>，当被使用时，就成为了<code>所有玩家都知道的信息</code>。</p>
<h2 id="Enchanted-Information"><a href="#Enchanted-Information" class="headerlink" title="Enchanted Information"></a>Enchanted Information</h2><p>时刻要注意的是，无论如何，游戏中操作信息的设计其目的都是产生meaningful play。</p>
<p>这里作者以桌游<em>魔法森林（Enchanted Forest）</em>作为例子进行说明。</p>
<blockquote>
<p>在游戏中，卡堆上翻出第一张卡片，作为城堡需要寻找的宝藏，每棵树下随机藏有各种宝藏。玩家通过色子进行移动（但可以自己选择前进的方向），如果达到一棵树下，玩家可以自己查看这棵树下的宝藏（不给其他玩家看），当抵达城堡时，玩家需要指出哪颗树下藏有宝藏，玩家自己翻开所指的树下宝藏，如果是对的，则将牌展示给所有的其他玩家，并将此宝藏收入囊中。如果是错的，则牌不会被展示给其他玩家，同时玩家自己回到原点。</p>
</blockquote>
<p>可以看出，在游戏中，信息是逐渐被揭露给玩家的，玩家可以通过翻看树下的宝藏来获取信息，当某一个玩家猜对卡片后，树下的宝藏也会被展示给所有人。游戏过程中玩家首先需要记住信息，即已经翻看的卡片下的宝藏是什么，同时还需要主动的构建自己的信息系统，如玩家可以选择优先看哪条路上的树。</p>
<h2 id="Each-turn，Enchanted"><a href="#Each-turn，Enchanted" class="headerlink" title="Each turn，Enchanted"></a>Each turn，Enchanted</h2><p>如上节所述，在魔法森林的游戏中，玩家需要自己决定查看哪条路上的树，这种抉择就是meaningful play的信号。在游玩的过程中，充斥着玩家对于信息的处理，探索哪部分信息的决策（选择探索的路），信息记忆的挑战（记住已经翻看的宝藏），以及猜测（如果到达城堡时，需要找到的宝藏自己并没有见过）。</p>
<p>当游戏进程发生变化，玩家的这些信息处理也会相应的发生变化，如选择探索的路可能会受别的玩家影响（要不要和别人探索一样的路），猜测的准确性（当探索的牌越多，猜测的准确性就越高，因为剩下的为未探索牌越来越少）。</p>
<p>同时游戏中的信息也不是割裂的，它一定程度上是玩家共享的，即存在<code>信息经济（economy of information）</code>。如某一个玩家达到城堡后，却无法准确的猜出宝藏的位置，可能就意味着这个玩家探索的道路上没有宝藏。</p>
<p>可以看出信息存在两个形态，游戏中本身存在的客观信息（Object information，数据层面的意义），和玩家获取到的信息（Perceived Information）。</p>
<p>在游戏中，信息从客观信息到获取信息的过程创造了游戏的意义，这个过程并不是一个等价的转换。优秀的玩家获取的信息是大于客观信息的存在的，如虽然他只翻阅了五张牌，但他可以通过别的玩家的行为分析出其他信息，因此获取的信息是大于翻阅五张牌所揭露的客观信息。</p>
<p>作为设计师在设计游戏时要考虑到这两种信息的转换。</p>
<h2 id="Hiding-and-Revealing-Systems"><a href="#Hiding-and-Revealing-Systems" class="headerlink" title="Hiding and Revealing Systems"></a>Hiding and Revealing Systems</h2><p>电子游戏中有许多隐藏或揭露信息的游戏元素：</p>
<ol>
<li>战争迷雾（The Fog of War）：<br>只有自己单位附近的地图才能被揭露真实状态。</li>
<li>秘密地点或隐藏的位置（Secret Locations and Hidden Moves）：<br>许多游戏中一些地点或元素在游戏一开始对于玩家是隐藏的（不完整信息），即玩家需要在游戏过程中逐渐发现。如马里奥奥德赛中，游戏的地图是逐渐探索的，这种逐渐发现的节奏可以给玩家带来代入感。</li>
<li>物品交易（Item Econonies）：<br>一些游戏中，一些物品虽然暂时没法被玩家获得，但它却展示给玩家看（完整信息）。这种展示所有信息的方法让玩家对于未来的游戏进度可以做计划。</li>
<li>规则作为信息（Rules as Information）：如很多模拟游戏中，一开始只能做一些非常简单的操作，但随着对于游戏理解的加深，能做的操作也越来越多（规则越来越多）。</li>
</ol>
<p>对于设计师而言，信息不能隐藏太多，不然玩家可能会觉得困扰。同样的信息也不能太多，出现在游戏中的信息应该是要能从玩家的交互中获取意义的，如果一个信息并不能被理解或者不能被融入到游戏中，这个信息就是没有意义的。</p>
<p>同时信息应该是逐渐被揭露给玩家的，否则玩家会一下子突如其来的信息吓到，而且无从下手。</p>
<div class="note info simple"><p>引用：</p>
<p>1.<em>Rules of Play</em> 2003</p>
</div>
<hr>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>游戏设计</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>游戏设计</tag>
      </tags>
  </entry>
  <entry>
    <title>《Rules of Play》 第十八章笔记</title>
    <url>/RulesOfPlay-Chapter18-Notes/</url>
    <content><![CDATA[<p>《Rules of Play》 第十八章笔记</p>
<p>这一章作者将游戏看作是一个控制系统。</p>
<p>主要介绍了游戏中的正反馈和负反馈。</p>
<span id="more"></span>
<h1 id="Chapter-18-Games-as-Cybernetic-Systems"><a href="#Chapter-18-Games-as-Cybernetic-Systems" class="headerlink" title="Chapter 18: Games as Cybernetic Systems"></a>Chapter 18: Games as Cybernetic Systems</h1><h2 id="Introducing-Cybernetic-Systems"><a href="#Introducing-Cybernetic-Systems" class="headerlink" title="Introducing Cybernetic Systems"></a>Introducing Cybernetic Systems</h2><p>这一章回简单的介绍控制论（Cybernetic），主要关注于游戏运行时系统的变换，和游戏中哪些形式上的结构让这些改变发生。</p>
<h2 id="Elements-of-a-Cybernetic-System"><a href="#Elements-of-a-Cybernetic-System" class="headerlink" title="Elements of a Cybernetic System"></a>Elements of a Cybernetic System</h2><p>控制系统的概念是指一个系统的输入和输出会由系统内部的结构自行调整。通常的系统的输入是对于环境的检测，而输出是系统做出的行为，即如何去改变环境。</p>
<p>一个控制系统包含三个元素：传感器（Sensor），比较器（Comparator）和催化器（Activator）。一个控制系统由这三个元素构成一个闭环，传感器接受环境信息，比较器比较环境环境信息决定要做什么改动，催化器做出具体的改动影响环境，环境由会进一步被接收器感知，即构成了一个闭环。也因此控制系统有时也会被成为反馈系统（Feedback Systems）和反馈循环（Feedback Loops）。</p>
<p>控制系统最常见的应用就是温度控制器，如下所示：</p>
<p><img src="RulesOfPlay-Chapter18-Notes/2020-03-21-16-39-19.png" alt="温度控制器"></p>
<p>一个控制系统可以是正反馈的，也可以是负反馈的。</p>
<ol>
<li>正反馈系统（Positive）：<br> 系统持续性的向一个方向变换。如传感器接收到温度后，比较是否大于30°，如果大于则加热。这样房间的温度就会越来越热。<br> 正反馈系统的效果是累加的（Cumulative）。</li>
<li>负反馈系统（Negative）：<br>负反馈系统是朝相反方向变换。如传感器接收到温度后，比较是否大于30°，如果大于则开始降温，如果小于10°则开始加热，这样房间的温度保持在一个区间之内。<br>负反馈系统的效果是平衡（Equilbrium）。</li>
</ol>
<h2 id="Feedback-Systems-in-Games"><a href="#Feedback-Systems-in-Games" class="headerlink" title="Feedback Systems in Games"></a>Feedback Systems in Games</h2><p>在游戏中，控制系统如下所示：</p>
<p><img src="RulesOfPlay-Chapter18-Notes/2020-03-21-16-50-28.png" alt="游戏的反馈系统"></p>
<p>其中</p>
<ol>
<li>游戏状态（Game state）表示游戏当前的状态，如格斗游戏中的血量，玩家的位置，战斗的地图等等。这是一个完全的游戏常规元素的理解，即不会包含玩家的技能，情绪，经验等等信息。</li>
<li>评分方法（scoring function）表示状态改如何被测量，如玩家的血量如何体现是长度还是数字。评分方法等同于传统控制系统中的传感器。</li>
<li>控制器（Controller）表示系统中查看评分方法的结果，并决定要采取什么操作，等同于传统控制系统中的比较器。</li>
<li>游戏调整方法（Game mechanical bias）表示游戏中调节状态的方法，等同于传统控制系统的催化器。</li>
</ol>
<p>如在一个赛车游戏中，可以通过嵌入反馈系统来决定下一轮时的发车位，如果前一轮的第一名处于最前方的发车位，那么就是正反馈系统，反之如果成绩越差的车手发车位越靠前就是负反馈系统。</p>
<h2 id="Positive-and-Negative-Basketball"><a href="#Positive-and-Negative-Basketball" class="headerlink" title="Positive and Negative Basketball"></a>Positive and Negative Basketball</h2><p>这里作者以篮球游戏作为例子来帮助分析正反馈系统和负反馈系统。</p>
<p>在正反馈系统的实现下，如果两个队伍的分值每相差5分，分数高的队伍会增加一名球员。这样随着比赛的进行，分数高的队伍球员会越来越多，即优势越来越大，比分差距会扩大。<br>在负反馈系统的实现下，如果两个队伍的分值每相差5分，分数高的队伍会失去一名球员。这样随着比赛的进行，分数高的队伍球员会越来越少，他们也就越来越难打，这样比分差距会收拢。</p>
<h2 id="Racing-Loops"><a href="#Racing-Loops" class="headerlink" title="Racing Loops"></a>Racing Loops</h2><p>这里作者以两个实际的游戏例子说明通过不同思路实现的负反馈系统。</p>
<p>第一个是索尼平台上的赛车游戏<em>Wipeout</em>，这个游戏实现负反馈是通过修改游戏元素的属性。</p>
<p>在游戏中电脑控制的赛车速度是会被调整的，如果玩家处于第一名，那么第二名的赛车速度会上升尝试追上玩家。如果玩家处于最后一名，那么最后面的几辆车速度会降低，让玩家可以追上。</p>
<p>这样的负反馈系统，保证玩家与电脑控制的赛车之间差距不会过大。</p>
<p>另一个例子是任天堂的<em>Super Monkey</em>，这个游戏是通过玩家的能力。</p>
<p>在游戏中，玩家可以减去道具干扰其他玩家。跑在前方的玩家更有可能收到其他玩家的攻击，而跑在后面的玩家则有更高的几率捡到加速道具。</p>
<p>这个负反馈系统同样保证了玩家之间的差距不会过大。</p>
<p>如之前所述，游戏的结果需要是不确定的，这样游玩才有意义。这上述两个例子通过负反馈缩小玩家之间的差距，都是让游戏的结果不确定，不然的话跑在前面的玩家大概率就是获胜者，对于之后的玩家而言游戏就是无意义的。</p>
<h2 id="Positive-Feedback-in-a-Game"><a href="#Positive-Feedback-in-a-Game" class="headerlink" title="Positive Feedback in a Game"></a>Positive Feedback in a Game</h2><p>正反馈系统出现在许多格斗游戏中。如被攻击的对象会出现硬直，这样就会收到更多的攻击。</p>
<p>正反馈会提供一个戏剧性的结果，一个细微的差距可能就会导致巨大的差异，因此让游戏更为紧张。</p>
<p>但是正反馈必须有终止条件，不然玩家在开局收到一次攻击后，就会硬直，并不断的收到攻击，那么游戏就没法进行了。</p>
<p>在格斗游戏中的击飞效果，就是这个终止条件。当收到攻击的对象承受了足够大的伤害后，就会被击飞，击飞时攻击的玩家就无法继续攻击，这样一次正反馈就结束了。</p>
<p>还有的游戏是通过策略等方法来补偿正反馈。如魔兽争霸中，拥有更多金矿的玩家会有更多的经济收入，那么就会有更多的士兵，也就导致优势会不断的扩大。但是弱势的一方却可以通过战术来终止优势方的优势扩大，如进攻分矿。</p>
<h2 id="Dynamic-Difficulty-Adjustment"><a href="#Dynamic-Difficulty-Adjustment" class="headerlink" title="Dynamic Difficulty Adjustment"></a>Dynamic Difficulty Adjustment</h2><p>动态难度调节（Dynamic Difficult Adjustment，DDA）根据玩家的表现使用反馈系统来调整游戏难度。</p>
<p>游戏难度在不同的玩家之间很难平衡，经验丰富的玩家对于同一个难度可能觉得无聊，而这个难度对于新手又可能觉得无法突破。</p>
<p>顽皮狗的游戏<em>古惑狼（Crash Bandicoot）</em>中使用了DDA来动态的调整游戏难度。即当玩家在一个点反反复复死去后，游戏会自动做出调整，如出现更多的帮助道具，出现更少的怪物等。同理，但玩家的游玩过程过于顺畅，游戏也会相应变难。</p>
<p>但是DDA是一个非常刻意的调整，很可能会损害玩家的游戏体验。玩家经过了反反复复的练习，变得更加数量，想要快速的通过游戏，结果游戏却相应的变得更难，这对于玩家而言有一种欺骗感，感觉自己是在“被游戏玩”。</p>
<h2 id="A-Simple-Die-Roll"><a href="#A-Simple-Die-Roll" class="headerlink" title="A Simple Die Roll"></a>A Simple Die Roll</h2><p>游戏的反馈系统，也可以仅仅通过一个规则来实现。</p>
<p>如在游戏<em>蛇梯棋</em>中，接近重点的玩家，必须准确的丢出距离终点步数的色子数。</p>
<p>这个规则就是一个负反馈系统，它潜在缩短了落后玩家与第一名玩家的距离。只要第一名玩家不色出那个确切的点数，他就永远无法获胜。</p>
<p>如果没有这个负反馈系统，那么蛇梯棋在某些时间点就会变得没有意义。例如第一名玩家距离重点只有两步，而落后玩家距离重点还有20步，此时游戏的结果就已经是确定的了。即使第一名玩家每次都色出1，两回合后也能胜利，而两回合的时候对于落后20步的玩家，是不可能追上的。</p>
<p>注意，这个严格意义上不是一个控制系统，因为没有传感器，比较器，催化器的元素存在。但它的思想仍然是控制系统其中负反馈的思想。</p>
<h2 id="Putting-Feedback-to-Use"><a href="#Putting-Feedback-to-Use" class="headerlink" title="Putting Feedback to Use"></a>Putting Feedback to Use</h2><p>反馈系统可以帮助平衡游戏。以下是正负反馈特点的总结：</p>
<ol>
<li>正反馈系统<br>a. 让游戏结果不稳定<br>b. 让游戏时间缩短<br>c. 放大胜利果实</li>
<li>负反馈系统<br>a. 让游戏结果稳定<br>b. 让游戏时间延长<br>c. 缩小胜利果实</li>
</ol>
<p>太多的正反馈会让一个游戏结果失控，一旦玩家获取到了一点优势，优势会不可控制的持续扩大，直到游戏结束。<br>太多的负反馈让游戏太过无聊，玩家获取到的优势会因为各种原因丧失，这样双方的差距始终无法拉开。</p>
<p>平衡正反馈和负反馈是创造meaningful play的关键。一个优秀的游戏设计应该让游戏过程自始自种都是有意义的，即优秀的玩家其优秀的行为是有意义的，能获取到回报，但是对于落后的玩家而言，他们同样有机会去翻盘，让他们在落后时的努力也存在意义。</p>
<p>同时要注意的是，不要过多的加入反馈系统，如之前所述，它可能会造成玩家的被欺骗感。例如如果一个玩家的赛车无论跑的多快，由电脑控制的第二名的赛车都能跟在玩家背后，那玩家的努力的意义在哪？</p>
<p>控制系统会一定程度上剥夺玩家对于游戏的控制，而控制感又是玩家游戏乐趣的一大来源。但实际上这两者并不矛盾，玩家的控制感和玩家是否真的完全控制游戏并不存在必然关系。如同之前章节中，不确定感也不一定来自不确定的随机一样。Meaningful Play针对的是玩家的感受，而不是游戏的规则。</p>
<h2 id="Afterword：-Don’t-Forget-the-Participant"><a href="#Afterword：-Don’t-Forget-the-Participant" class="headerlink" title="Afterword： Don’t Forget the Participant"></a>Afterword： Don’t Forget the Participant</h2><p>控制系统在学术上还分为，第一类控制系统和第二类控制系统。其中第一类控制系统完全由自身决定，而第二类控制系统还由旁观者决定。</p>
<p>这一章中提到的控制系统为第一类控制系统，但如果考虑到了游戏的文化层面或其他社会层面，则控制系统可能会受外界因素的干扰，成为第二类控制系统。</p>
<div class="note info simple"><p>引用：</p>
<p>1.<em>Rules of Play</em> 2003</p>
</div>
<hr>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>游戏设计</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>游戏设计</tag>
      </tags>
  </entry>
  <entry>
    <title>《Rules of Play》 第二十二章笔记</title>
    <url>/RulesOfPlay-Chapter22-Notes/</url>
    <content><![CDATA[<p>《Rules of Play》 第二十二章笔记</p>
<p>22.1节作者规则和玩在游戏中的关系。<br>22.2节作者尝试解释玩是什么，并给出了玩的三个分类：<br>22.3节作者给出了玩的定义<br>22.4节作者解释了Transformative Play的概念<br>22.5-22.7节，作者分别对玩的三个定义进行分析。</p>
<span id="more"></span>
<h1 id="Defining-Play"><a href="#Defining-Play" class="headerlink" title="Defining Play"></a>Defining Play</h1><h2 id="Introducing-Play"><a href="#Introducing-Play" class="headerlink" title="Introducing Play"></a>Introducing Play</h2><p><code>玩游戏</code>这个操作在玩家体验到游戏的规则时就发生了。</p>
<p>从形式角度来看，游戏中的规则构成了游戏内核的关键。但是把游戏仅看作是形式系统是很危险的事，游戏设计者要意识到设计游戏的最终目的并不是设计游戏规则，即使这些规则很有创意或者很优雅。</p>
<p>游戏规则仅仅是用来创建玩这个过程的，如果游戏设计者拘泥于去设计优雅的游戏规则而忽略了玩家的感受，那么这个设计者就是走错了方向。玩游戏的时的体验才是游戏的灵魂。</p>
<p>在玩游戏时，应该是将游戏作为一个体验和获得快乐的系统。</p>
<h2 id="What-Is-Play"><a href="#What-Is-Play" class="headerlink" title="What Is Play"></a>What Is Play</h2><p>作者在这一节尝试解释玩是什么。</p>
<p>心理学家J.Barnard Gilmore在<em>Child’s Play</em>一书中说，“即使不是所有人都能在什么是玩耍上达成共识，但是所有人都在准确的知道什么不是玩耍。”</p>
<p>首先作者回顾了在第七章中定义的游戏和玩的两个可能关系：</p>
<ol>
<li>游戏是玩的子集：如扮演医生或追逐打闹就不属于游戏的范畴</li>
<li>玩是游戏的一部分：除了规则和文化，玩是游戏的重要部分。</li>
</ol>
<p>这两个关系都是正确的，第一个是个描述性的区分，把游戏作为正式世界中所有的关于玩的集合的一部分。第二个是为概念性的区分，把玩描述为游戏中的一部分。</p>
<p>作者之后又提出，在英文中，<code>Play</code>一词覆盖的范围是非常广的，还有些情况都不适合于玩耍或游戏这两个范围。因此作者将<code>Play</code>一词描述的活动分为三类：</p>
<ol>
<li>游戏（Game Play）<br>玩游戏是一个比较狭窄的分类，是那些符合第七章中定义的活动。</li>
<li>玩耍活动（Ludic Activities）<br>Ludic一词来源于拉丁语Ludus,即意为玩。玩耍活动包括的不仅仅是游戏，如小猫玩毛球，两个人互相丢飞盘等都是玩耍活动。这种活动并没有一个可量化的结果系统，因此不能算是游戏。</li>
<li>好玩的（Being Playful）<br>这是一个最广的分类范围，它不仅仅是包含传统意义上的玩耍活动，还包括脑海中好玩的想法，而这种想法最终会投射入某种活动。如取外号或打油诗，就是一种对文字的玩耍。</li>
</ol>
<p>上述三个活动分类的结构如下：</p>
<p><img src="RulesOfPlay-Chapter22-Notes/2020-03-02-23-52-23.png" alt="玩的分类"></p>
<h2 id="A-General-Definition-of-Play"><a href="#A-General-Definition-of-Play" class="headerlink" title="A General Definition of Play"></a>A General Definition of Play</h2><p>这里作者给出了玩的定义，上述三个定义的活动都能套入这个定义：</p>
<p><strong>玩是在一个严格结构内的自由活动</strong></p>
<p>即玩是一个系统的体现，它体现了这个系统结构下还能自由活动的范围。</p>
<p>对于上述的三个分类来说：</p>
<ol>
<li>游戏<br>玩游戏过程无疑是在游戏所设定的框架（游戏规则）下</li>
<li>玩耍活动<br>玩耍活动实际上也是存在限定的，如玩抛飞盘就有关于物理规则和参与人员的身体素质等。玩的过程就是就是在反复测试这个限制的边界，抛的更高，更快等</li>
<li>好玩的<br>外号，打油诗这种实际上也是在语言的语法限定下，去做词汇和短语的自由调整。</li>
</ol>
<p>玩之所以能存在就是因为有严格的结构，但也是因为做出了一些反结构的行为。如俚语和打油诗虽然符合语法的规则，但是与官方的使用时不同的。像墙壁上丢球能进行，是因为物理规律和墙壁的存在，但丢球这个行为却又不是墙设计的目的。总之，玩这个行为体现出一种反结构和抵抗，但这个行为又是有趣的，它用现有存在的结构发明了一些新的事物（外号→新的语言，丢球→新的行为）。</p>
<h2 id="Transformative-Play"><a href="#Transformative-Play" class="headerlink" title="Transformative Play"></a>Transformative Play</h2><p>当玩耍发生时，它可能可以改变现有的严格结构。如哲学家James S.Hans说，“玩的目的不是在现有的结构下舒适的活动，而是为了通过玩来发展结构”。比如一个好玩的俚语可能最终变成了谚语，成为了正式语言中的一部分。</p>
<p>将这种形式的玩耍称为Transformative play。Transformative Play是玩耍的一种特例，它在现有结构中自由活动会改变当前的结构。Transformative Play在三种玩耍分类中都可能发生：</p>
<ol>
<li>游戏：<br>在比赛中，规则会进行调整来让游戏保持挑战性和趣味性</li>
<li>玩耍活动：<br>儿童的玩耍活动的规则一直会发生变化，甚至会根据玩耍时的情况即兴修改。</li>
<li>好玩的：<br>如艺术的一些边缘风格最早就是处于玩乐性质，但最后可能就发展成了潮流。</li>
</ol>
<h2 id="Being-Playful"><a href="#Being-Playful" class="headerlink" title="Being Playful"></a>Being Playful</h2><p>好玩是玩的最广泛的定义。</p>
<ol>
<li>玩的存在是同时来源于结构和反结构。<br>如谐音梗的行为，仅在语言本身存在的情况下才有意义，而谐音梗又是与语言本身的定义是违背的。</li>
<li>每个玩耍都有可能成为Transformative Play<br>与在饭桌上说了一个谐音梗，或许整个饭桌的话题就变成了谐音梗，于是产生谐音梗的语境就发生了变化。</li>
</ol>
<p>好玩对于游戏设计的提示在于，生活中的普通行为都可以通过加入适当的灵感变成好玩的事。比如排队，开车，看新闻等等行为都可以通过加入一些元素变成一个好玩的事件。</p>
<p>玩是人类活动的一个潜在行为，任何事物都可以称为玩的灵感来源。</p>
<h2 id="Ludic-Activities"><a href="#Ludic-Activities" class="headerlink" title="Ludic Activities"></a>Ludic Activities</h2><p>区分游戏和其他活动的主要点在于是否有可量化结果。</p>
<p>在Roger Caillois的<em>Man,Play,and Games</em>一书中对于玩耍活动有进一步的分类：</p>
<ol>
<li>$Ag\hat{o}n$：竞争游戏（Competitive Play）</li>
<li>$Alea$：几率游戏（Chance-based play）。游戏的结果与玩家无关，更多是因为运气。</li>
<li>$Mimicry$：角色扮演游戏和假装游戏（Role-Playing and make-believe play）。玩家有一种自己就是假象人物的感受，在过程中遗忘和隐藏自己的特性来假装是另一个人。</li>
<li>$Ilinx$：与物理眩晕感相关的玩耍（Playing with the physical sensation of vertigo）。如小孩子原地告诉旋转，然后眩晕的走路玩</li>
</ol>
<p>Coilois的四个分类都适用于作者给出的对于玩的定义：</p>
<ol>
<li>竞争游戏和几率游戏：这两个游戏都有系统的规则限定，即使是几率游戏，也是有玩家自己参与，只是希望系统能给出一个更好运的结果。</li>
<li>角色扮演游戏和假装游戏：都是在现有的现实框架下，通过想象做一些自由的移动</li>
<li>眩晕感相关游戏：是基于感官和物理系统的，只不过是利用旋转来获得一种与平常行为不同的感受。</li>
</ol>
<p>同时Coilois又进一步通过两个分类，将上述的四个分类进行扩展。这两个分类是<code>Paida</code>，表示一种无规则的，即兴的玩耍，<code>Ludus</code>表示一种受规则约束，规范化的玩耍。因此，一共又8个分类，如下所示：</p>
<p><img src="RulesOfPlay-Chapter22-Notes/2020-03-03-00-51-32.png" alt="Coilois八大分类"></p>
<p>大部分的游戏都使用了多个属于上表中不同分类的元素，如一个角色扮演游戏（Mimicry）可以在玩家快速移动时加入眩晕效果（Ilinx）。</p>
<p>Coilois的分类方法可以成为一个有价值的游戏设计工具，因为它帮助分类了游戏设计中的问题。</p>
<h2 id="Game-Play"><a href="#Game-Play" class="headerlink" title="Game Play"></a>Game Play</h2><p>游戏的体验，是通过玩家的参与来获得的。好玩和玩耍活动包含了许许多多的玩耍形式，而游戏只是其中的一小部分。</p>
<p>游戏无疑是在系统设定的规则内运行的。玩游戏的喜好是玩家游戏规则的直接体现。</p>
<p>在这一章讨论其他的玩，其目的是想找寻如何做出有意义的玩，而不是去调查社会或心理学上对于游戏的存在意义的讨论。</p>
<p>之后的章节会讨论游戏的体验品质，包括玩的心理学，对于情感的表达，游戏促进个人玩耍风格方式等。</p>
<div class="note info simple"><p>引用：</p>
<p>1.<em>Rules of Play</em> 2003</p>
</div>
<hr>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>游戏设计</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>游戏设计</tag>
      </tags>
  </entry>
  <entry>
    <title>《Rules of Play》 第三章笔记</title>
    <url>/RulesOfPlay-Chapter3-Notes/</url>
    <content><![CDATA[<p>《Rules of Play》 第三章笔记</p>
<p>主要介绍Meaningful Play的概念</p>
<p>可以从两方面来评判Meaningful play，描述性和评价性。</p>
<p>其中评价性又可以从可感知性和协调性两方面进行评价。</p>
<span id="more"></span>
<h1 id="Chapter-3-Meaningful-Play"><a href="#Chapter-3-Meaningful-Play" class="headerlink" title="Chapter 3: Meaningful Play"></a>Chapter 3: Meaningful Play</h1><h2 id="Introducing-Meaningful-Play"><a href="#Introducing-Meaningful-Play" class="headerlink" title="Introducing Meaningful Play"></a>Introducing Meaningful Play</h2><p>Huizinga在他的书<em>Homo Ludens</em>中提到玩耍是比文化更古老的存在。</p>
<p>Huizinga在很多方面去尝试重新定义玩耍，并找出玩耍的重要意义。</p>
<h2 id="Meaning-and-Play"><a href="#Meaning-and-Play" class="headerlink" title="Meaning and Play"></a>Meaning and Play</h2><p>创建一个对于玩家而言有意义的良好游戏体验，是成功的游戏设计中一个重要的目标，或许还是最重要的一个。可以将这种设计目标称为<code>meaningful play</code>。</p>
<p>玩耍并不仅仅是从游戏本身诞生的，它还和玩家是如何与游戏交互有关。例如象棋的规则，棋盘，棋子等这些并不能构成meaningful play。meaningful play是从玩家和游戏系统的交互中诞生的，同时也要考虑游戏当前的状态中，如下棋子这个行为之所以有意义，是因为它处在一个棋局中。</p>
<p>玩家在游戏中每做出一个选择，实施这个选择的行为就会产出一个结果。玩游戏的过程就是不断的做选择和实施行为。在一个游戏系统中，所有的事件都被设计成要能支撑一个有意义的选择（如下棋子，如何打回球等），实施这些选择的行为产生的结果也会影响游戏系统。即玩家在游戏中每个行为都会改变游戏的状态，也就让这个游戏系统有了新的意义。</p>
<h2 id="Two-Kinds-of-Meaningful-Play"><a href="#Two-Kinds-of-Meaningful-Play" class="headerlink" title="Two Kinds of Meaningful Play"></a>Two Kinds of Meaningful Play</h2><p>定义Meaningful Play有两方面的考虑。</p>
<p>第一方面是描述性（descriptive）的考虑，即考虑play是否有意义。一个游戏行为导致了一个游戏结果这种交互方式创造了玩耍的意义。</p>
<p>每个游戏都让玩家采取某些行为，然后再为这些行为设定了相应的产出，因为这种设计描述了每个游戏中会发生什么，所以将这种定义称为描述性的定义。</p>
<p>第二方面是评价性（evluateive）的考虑，即考虑play是否有足够的意义？或者怎么样的play是更有意义的？这个方面可以再细分为两个方面</p>
<p>首先是游戏行为是否是<strong>可感知的（Discernable）</strong>，即游戏对于玩家行为给出的结果，对于玩家而言是否能感知到。</p>
<p>如对一个陨石进行炮击，如果没有任何的反馈，如爆炸，陨石改变了运动轨迹，炮击与陨石擦过等，那么玩家无法确定自己是否真的命中了陨石，也就会怀疑之前的操作究竟有没有意义。</p>
<p>又比如一个桌游，如果玩家采取了行动后，无法得知这个行为的结果是让自己离成功更进一步还是更加遥远，那么这个行为对于玩家而言用于是没有意义的。</p>
<p>一个游戏的可感知性（Discernability）就是让玩家知道他们采取的行为究竟产生了怎么样的结果。</p>
<p>另外还能判断游戏行为是否是<strong>整体化的，协调的（Integrated）</strong>。一个整体的，协调的游戏行为产生的结果是要能结合在游戏更大的情景中，即游戏的行为不仅仅在当下能产出一个玩家可感知的结果，也要同样能影响游戏后续的发展。</p>
<p>可感知的游戏行为，是让玩家知道自己的导弹有没有打中陨石，整体化的游戏行为是决定玩家打中陨石与否这个行为本身又产生了什么深远的影响（陨石轨道改变了一些，所以不会撞到地球等）。</p>
<p>meaningful play可以在游戏的多个方面同时运用，在各种层面上提升玩家的体验。如可以在学科上，如围棋中的一步在数学上的考虑，或在社会层面上，如多个玩家组成了一个游戏论坛，甚至在文化层面上，如围棋冠军可以形成一个围棋热潮等。</p>
<div class="note info simple"><p>引用：</p>
<p>1.<em>Rules of Play</em> 2003</p>
</div>
<hr>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>游戏设计</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>游戏设计</tag>
      </tags>
  </entry>
  <entry>
    <title>《Rules of Play》 第六章笔记</title>
    <url>/RulesOfPlay-Chapter6-Notes/</url>
    <content><![CDATA[<p>《Rules of Play》 第六章笔记</p>
<p>这一章中主要讨论了游戏的交互。</p>
<p>作者首先罗列了不同人对于交互的定义，然后推导出自己对于交互的多价模型，并强调这一章将重点讨论其中的显式交互。</p>
<p>然后作者区分了设计者所能设计的是让交互变得有意义的环境。</p>
<p>之后作者谈论了交互中的关键部分“选择”，先是给出了交互结构中的最小微粒”行为-&gt;结果”单元，再通过五个问题对应的五个步骤剖析了选择的过程，</p>
<p>最后阐述游戏设计者并不能直接的限定所有的交互可能，而是通过设计的规则创建一个“可能性空间”。</p>
<span id="more"></span>
<h1 id="Chapter-6：-Interactivity"><a href="#Chapter-6：-Interactivity" class="headerlink" title="Chapter 6： Interactivity"></a>Chapter 6： Interactivity</h1><h2 id="Introducing-Interactivity"><a href="#Introducing-Interactivity" class="headerlink" title="Introducing Interactivity"></a>Introducing Interactivity</h2><p>玩的过程就暗示了存在交互性：玩游戏，玩玩具，与人玩，都是与被玩的对象进行交互。</p>
<p>这种交互也发生在玩的各种层面上，从游戏本身的交互，到社会中与玩家的交互，还有游戏所诞生的文化的交互。</p>
<h2 id="Defining-Interactivity"><a href="#Defining-Interactivity" class="headerlink" title="Defining Interactivity"></a>Defining Interactivity</h2><p>首先需要定义交互是什么，如果任何事物都可以是交互的对象，那么这个概念也就不再能帮助解决设计问题，因为它实在是太过于宽泛。</p>
<p>传播理论学家Stephen W.Littlejohn把“系统中存在有相互关系的元素称为是可交互的”。</p>
<p>数字媒体理论家Brenda Laurel强调了交互体验的可描述性，将交互系统定义为是个表征空间。这个空间描述了一些事物，人们可以参与在这个空间中去理解事物，这个行为就是交互。</p>
<p>理论学家Andy Cameron在表征空间的基础上强调了直接干预（Direct intervention）的概念，即“交互是需要有能力以有意义的方式干预表征本身，而不是简单的从不同角度去理解。”</p>
<p>游戏设计师Chris Crawdord认为交互是一个周期性的活动，两个参与者需要轮流的进行倾听，思考和反馈。交互的质量取决于每个子活动（倾听，思考和反馈）的质量。</p>
<p>但所有的这些解释都没有解释交互应该如何发生以及在何处发生。而这俩问题才是设计游戏交互的关键点。</p>
<h2 id="A-Multivalent-Model-of-Interaction"><a href="#A-Multivalent-Model-of-Interaction" class="headerlink" title="A Multivalent Model of Interaction"></a>A Multivalent Model of Interaction</h2><p>作者设计了一个多价模型来描述交互，该模型将上述的所有对交互的定义蕴含在其中，且定义了四种交互的类型或者说是四种交互的参与程度，其中每个类型都有可能与其他类型同时发生。</p>
<ol>
<li><p>Mode 1：认知交互（Cognitive interactivity; or interpretive participation）</p>
<p>认知交互是一种心理学，情绪上和智能上的人与系统的交互。如当一个玩家玩一款冒险游戏时，他对于游戏世界的复杂想象就是一种认知交互。</p>
</li>
<li><p>Mode 2：功能性交互（Functional interactivity；or utilitarian participation ）</p>
<p>功能性交互是与系统组件（无论是真实的还是虚拟的）的交互。如游戏的交互界面是怎么样的？按钮多硬？系统的反应延迟是怎么样的？在高分辨率的显示器上字体显示效果如何等</p>
</li>
<li><p>Mode 3：显式互动（Explicit interactivity;or participation with designed choices and procedures）</p>
<p>显式互动是关于玩家在游戏规则限定下做出的选择，遇到的随机事件，游戏的动态模拟等等构成的玩家交互体验。</p>
</li>
<li><p>Mode 4：超越对象互动（Beyond-the-object-interactivity；or participation within the culture of the object）</p>
<p>超越对象交互，是超过了设计系统本身体验的交互。如粉丝文化。</p>
</li>
</ol>
<p>这章之后的章节将主要关注显式互动。但需要注意的是四种互动是相互联系的，如玩扑克牌，选择是否切牌是显式互动，牌的质量和大小影响了功能性互动，牌上印的花纹则又是超越对象互动（不同国家扑克牌的花纹通常是与其文化相关的）。</p>
<h2 id="But-Is-it-“Designed-Interaction”"><a href="#But-Is-it-“Designed-Interaction”" class="headerlink" title="But Is it “Designed Interaction”"></a>But Is it “Designed Interaction”</h2><p>为了设计交互性，首先需要了解设计师需要设计哪种交互。</p>
<p>需要记住的是在第三章所述的，meaningful play不仅仅与玩家行为以及系统反馈有关（Descriptive），还与行为执行时的情景有关（Evaluative）。</p>
<p>“某人丢出了一个苹果”是一个交互，但不是一个设计的交互。“丢出苹果”在系统中包含了多个元素的交互，如手，苹果，地面。但是它并不存在于一个上下文中，即这个交互行为是没有意义的。</p>
<p>但如果为这交互设计一个上下文，如两个人在互相丢苹果，并且记录丢出的数量。这样通过一个简单的设计，交互就有了意义。</p>
<h2 id="Interaction-and-Choice"><a href="#Interaction-and-Choice" class="headerlink" title="Interaction and Choice"></a>Interaction and Choice</h2><p>在游戏中，玩家需要做出选择，系统会根据选择的行为做出相应的回应。选择和回应中的关系一定程度上决定了游戏交互的深度和质量。</p>
<p>考虑游戏中的选择时，可以从两个层次考虑游戏的选择设计：微观（Micro）和宏观（Macro）。微观角度代表了小，实时反馈的选择；宏观角度是这些微观的选择如何结合在一起构成一个更大的游戏体验变换的轨迹。</p>
<p>微观和宏观的选择设计是交织在一起的，无疑有些设计很难判断它到底是微观的还是宏观的。</p>
<p>例如在文字冒险游戏中（输入文字指令，系统同样会以文字告知结果）。在命令行中输入指令就是微观选择，而这些选择在宏观层面上最终或许会构成多种不同的结局。即使在输入行中输入错误的指令（如指令是<code>get rock</code>，而输入是<code>grab rock</code>），也是有意义的，因为系统对于错误输入的提示，也帮助了玩家进一步了解系统规则的边界。</p>
<p>又例如在Black jack（21点）游戏中，每一次选择是否加牌都是微观选择，但这些选择的结果构成了宏观选择（每一次微观的选择都增加了牌一共的点数）。</p>
<p>上面两个例子都说明了微观和宏观上选择是可以很自然的切换，它们将作为一个协调的整体展现给玩家。如果每个行为的结果都是可感知的且整体性的，那么选择就会构成meaningful play。</p>
<p>游戏设计师Doug Church在文章<em>Formal Abstract Design Tools</em>中描述了，在格斗游戏中，玩家的每个控制指令都是统一的，且可以通过屏幕上的角色体现出来（可感知性，同时也是微观的选择）。而且看别人玩游戏，可以看出为什么别人打的比自己更好（整体协调性，同时也是宏观选择的体现）。</p>
<p>可以看出，宏观选择不仅包括在整个游戏过程中该做什么，它还包括是否要继续玩游戏这款游戏和与谁竞争。如果在格斗游戏中，并没有足够的meaningful play，玩家将不知道为什么输，也就会失去对游戏的兴趣。相反，如果每次都能知道为什么对手比自己做的更好，那么输这个行为就是有意义的。</p>
<h2 id="Choice-Molecules"><a href="#Choice-Molecules" class="headerlink" title="Choice Molecules"></a>Choice Molecules</h2><p>构建一个大的有意义的交互结构，其中最小的微粒就是<code>行为-&gt;结果</code>单元。</p>
<p>如在游戏Asteroids中一共有五个按键：左转，右转，前进，开火，跳跃。每个行为-&gt;结果单元就是由这五个按键和他们对于的结果构成的。在游戏进行过程中，每个行为-&gt;结果单元都会形成后一个单元的选择时的情景，单元直接的连接是非常顺畅的，所以玩家根本意识不到自己在一分钟内会做出几百次选择。</p>
<h2 id="Anatomy-of-a-Choice"><a href="#Anatomy-of-a-Choice" class="headerlink" title="Anatomy of a Choice"></a>Anatomy of a Choice</h2><p><code>选择</code>这个概念乍看起来十分的简单，但实际上是一个复杂的结构。在阐述行为-&gt;结果单元时，需要问如下五个问题，这五个问题构成了对选择的剖析（Anatomy of a Choice）。这五个问题同样也是选择时的五个步骤，这五个步骤如果可以顺畅的连接在一起，也就能产生顺畅的行为-&gt;结果单元的连接，最后meaningful play。</p>
<ol>
<li><p>在玩家做出选择前发生了什么？</p>
<p>这个问题是描述玩家做出选择时的状态。无论是微观还是宏观的选择都与这个问题相关。</p>
</li>
<li><p>可能的选项是如何传递给玩家的？</p>
<p>玩家做出选择时，需要知道可能的选项有哪些。如上述Asteroids的例子中，玩家可能的选项就是五个按键，它通过游戏面板告知了玩家</p>
</li>
<li><p>玩家如何做出选择？</p>
<p>这个问题与上个问题相关。选项告知玩家后玩家该如何做出选择，通过按按钮，还是语音，或是其他？</p>
</li>
<li><p>选择的结果是什么，会对未来造成什么影响？</p>
<p>这个问题是关于玩家行为的结果，而且这个结果是特指内在的结果。玩家的行为在游戏系统中将会怎样产生更深远的影响的，这个影响暂时不会展示给玩家。</p>
</li>
<li><p>游戏的结果是如何传递给玩家的？</p>
<p>这个问题同样是关于玩家行为的结果，这里的结果是外在的表现。如游戏画面中的角色做出了位移等。</p>
<p>第五个问题解答后将自然的回到第一个问题。因为第五个问题的答案，即产生的结果又构成了下一个选择时的状态。</p>
</li>
</ol>
<p>上述的五个问题，有些是内在的事件（Internal events），有些是外在的事件（external events）。其中问题1,3,4是内在事件，问题2,5是外在事件。</p>
<p>游戏包含内在事件的特征暗示了游戏系统实际上是会记录一部分玩家的行为的，为了在之后产生深远影响。Jesper Juul在文章<em>Play Time, Event Time, Themability</em>中将游戏描述为一台状态机。</p>
<p>下标为Asteroids和下棋两个游戏针对五个选择问题的回答：</p>
<p><img src="RulesOfPlay-Chapter6-Notes/image-20200309170936426.png" alt="选择剖析例子" style="zoom:80%;" /></p>
<p>针对选择的剖析可以帮助解决游戏设计时的问题。如觉得一款游戏没有足够的meaningful play，可能就是因为在一系列行为-&gt;结果单元的连接中出现了断档，如</p>
<ol>
<li>如果觉得游戏中的决定并没有什么大影响。问题可能出现在步骤四中，玩家的行为并没有在游戏系统内部构成一个有意义的结果。</li>
<li>如果玩家不知道下一步要做什么。这个现象在大型的冒险游戏中很普遍，问题可能处在步骤二中，问题的选项并没有很清晰的告知玩家。</li>
<li>如果玩家并不知道为什么会输。问题很可能出现在步骤五中，即游戏当前的状态并没有很好的告知玩家。玩家并不知道当前的游戏状态因此无法把握游戏的走向，也就对最终的结果感到困惑。</li>
<li>如果玩家不知道一个操作是否产生了结果。问题可能出在步骤三和四中，即玩家做出了操作，而系统并没有对操作做出相应的反应。这种情况看似很少见，但在一些新鲜的交互方式中很有可能出现，如重力感应，运动传感器等。</li>
</ol>
<h2 id="Space-of-Possibility"><a href="#Space-of-Possibility" class="headerlink" title="Space of  Possibility"></a>Space of  Possibility</h2><p>现在许多关于游戏和交互的作品并不是从一个玩家的视角出发，而是作为一个外在的观察者。但是游戏交互需要的是体验，而不是观察。</p>
<p>创造一个游戏意味着创造一个复杂的系统，这个系统可能会以意想不到的方式被玩家所使用。作为一个游戏设计者，应该让游戏中的各种行为都变得有意义，而不是去打断或者限制玩家的行为。</p>
<p>游戏设计者的工作并不是设计玩家该如何玩，他们的设计工作是去创建一个玩耍可以发生的环境，间接的引导玩家的行为。将玩家未来的所有行动所构成的空间，称为可能性空间（Space of Possibility）。这个概念将游戏设计（design），含义（meaning），系统（system），可交互性（interactive）连接在了一起。</p>
<p>这空间中的所有可能性的意义都来自于游戏设计。游戏设计者也不是直接的去构建这个空间，而是通过设计的游戏规则间接的产生这个空间。</p>
<p>游戏设计是对自己设计的规则，对玩家，对游戏本身产生信心，期望他们能共同创造meaningful play。但最终是否成功，永远无法预先得知，了解游戏设计的关键只是帮助你去接近这个期待。</p>
<blockquote>
<p> Game design is an act of faith-in your rules, in your players, in your game itself. Will your game create meaningful play? You can never know for sure.</p>
</blockquote>
<h2 id="Further-Reading"><a href="#Further-Reading" class="headerlink" title="Further Reading"></a>Further Reading</h2><ol>
<li><em>The Design of Everyday Things</em> by Donald Norman</li>
<li><em>Formal Abstract Design Tools</em> by Doug Church</li>
<li><em>The Art of Interactive Design: A Euphorious and Illuminating Guide to Building Successful Software</em>  by Chris Crawford</li>
</ol>
<div class="note info simple"><p>引用：</p>
<p>1.<em>Rules of Play</em> 2003</p>
</div>
<hr>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>游戏设计</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>游戏设计</tag>
      </tags>
  </entry>
  <entry>
    <title>《Rules of Play》 第七章笔记</title>
    <url>/RulesOfPlay-Chapter7-Notes/</url>
    <content><![CDATA[<p>《Rules of Play》 第七章笔记</p>
<p>本章首先区分了游戏和玩的概念</p>
<p>然后从八种不同的游戏定义角度出发推导出作者对于游戏的定义。</p>
<p>最后介绍了两种看似与游戏定义不符的特例，智力游戏与角色扮演类游戏。</p>
<span id="more"></span>
<h1 id="Chapter-7：Defining-Games"><a href="#Chapter-7：Defining-Games" class="headerlink" title="Chapter 7：Defining Games"></a>Chapter 7：Defining Games</h1><p>对于游戏的定义不仅仅是帮助将游戏设计与其他的设计区分开来，更可以帮助人们对于什么是有意义的玩有更深的理解</p>
<h2 id="Play-and-Game"><a href="#Play-and-Game" class="headerlink" title="Play and Game"></a>Play and Game</h2><p>第一步要区分玩和游戏这两个概念。根据定义方式的不同，玩可以是比游戏更大的概念，也可以是更小的概念</p>
<h3 id="Relationship-one：-Games-are-a-subset-of-play"><a href="#Relationship-one：-Games-are-a-subset-of-play" class="headerlink" title="Relationship one： Games are a subset of play"></a>Relationship one： Games are a subset of play</h3><p>一些玩可以称作为游戏，如躲避球，在这种玩耍下，玩家要遵循一个规则，并且尽量获得胜利。</p>
<p>而另一些玩耍则很难称之为游戏，如在海滩上追逐嬉闹。</p>
<p>实际上大部分的玩都不够有组织化，所以无法称之为游戏。</p>
<p>从类型学方法上来说，游戏是玩的子集，如图：</p>
<p><img src="RulesOfPlay-Chapter7-Notes/2020-03-01-17-48-10.png" alt="游戏是玩的子集"></p>
<h3 id="Relationship-two：Play-is-a-component-of-games"><a href="#Relationship-two：Play-is-a-component-of-games" class="headerlink" title="Relationship two：Play is a component of games"></a>Relationship two：Play is a component of games</h3><p>在另一些思考角度下，游戏可以视作包含了玩这个概念，玩只是游戏中众多观察和理解角度之一。</p>
<p>从概念方法上来说，玩时游戏的子集，如图：</p>
<p><img src="RulesOfPlay-Chapter7-Notes/2020-03-01-17-50-39.png" alt="玩是游戏的子集"></p>
<h2 id="Comparing-Definitions"><a href="#Comparing-Definitions" class="headerlink" title="Comparing Definitions"></a>Comparing Definitions</h2><p>可以看出定义玩和定义游戏是不同的。</p>
<p>作者尝试通过比较前人对游戏的定义来归纳出游戏的定义。但需要提及的一点是在许多的语言中，玩和游戏是使用同一个词汇的，因此在定义过程中，玩和游戏便混合在了一起。作者在这一章对于这种混合的定义仍然会采纳，只不过侧重点在于游戏。</p>
<h3 id="Definition-1：David-Parlett"><a href="#Definition-1：David-Parlett" class="headerlink" title="Definition 1：David Parlett"></a>Definition 1：David Parlett</h3><p>Pelett首先区分了正式游戏和非正式游戏的区别。非正式游戏是那些没有明确目标的游戏，如孩子与玩偶的玩耍。</p>
<p>对于正式游戏Pelett给出了二元结构：</p>
<ol>
<li>终结性：正式游戏从定义上来说有一个获胜者，获胜即是游戏的结束，也是游戏的目标。</li>
<li>意义：正式有游戏有一系列各方都同意的规则和可以使用的设备，可以使用这些设备去获胜。</li>
</ol>
<p>在Pelett的定义下，非正式游戏其实就是普通的玩，而正式游戏中的<code>获胜目标</code>和<code>规则</code>是关键部分。</p>
<h3 id="Definition-2：Clark-C-Abt"><a href="#Definition-2：Clark-C-Abt" class="headerlink" title="Definition 2：Clark C.Abt"></a>Definition 2：Clark C.Abt</h3><p>Abt定义游戏为：游戏是两个或多个独立的决策者参与的活动，在活动中它们在限定条件下去寻找达到目标的方法。或者说是在一系列竞争者和规则的限定下，去赢得目标。</p>
<p>Abt的定义在一定程度上太狭隘：游戏并不一定是竞争环境，也可能是合作的。</p>
<p>同时Abt的定义又在一定程度上太宽泛：按照定义，政治活动等也能算是游戏。</p>
<h3 id="Definition-3：Johann-Huizinga"><a href="#Definition-3：Johann-Huizinga" class="headerlink" title="Definition 3：Johann Huizinga"></a>Definition 3：Johann Huizinga</h3><p>Huizinga定义的是玩，他的定义是：玩是一种脱离原本的生活的免费且不严肃的活动，但同时又能完全的吸引玩家。它同时也是个和物质利益无关的的活动，它限定在自己根据一系列规则设定的空间时间框架内。玩也可以促进社会团体的形成，将团队与外界世界区分开来。</p>
<p>Huizinga的定义更加的抽象，他来描述了游玩时的感受，比如吸引但不严肃。但是这些特征并不能很好的定义游戏，一个设计差到无法吸引人的游戏难道就不是游戏了吗？</p>
<p>但这个定义最大的问题还是在于没有明显区分玩和游戏的概念。</p>
<h3 id="Definition-4：Roger-Caillois"><a href="#Definition-4：Roger-Caillois" class="headerlink" title="Definition 4：Roger Caillois"></a>Definition 4：Roger Caillois</h3><p>Caillois同样给出了玩的定义:</p>
<ol>
<li>自由：玩并不是强制性的</li>
<li>独立性：游戏的环境是一个预先定义和设定好的优先空间和时间</li>
<li>不确定性：过程和结果都无法确定</li>
<li>无产出：游戏不会产生货物或者财富。对于玩家而言，游戏开始时和结束时的情况是一样的。</li>
<li>被规则管理：有自己的独立规则</li>
<li>虚构的：构造一个与现实不同的世界，或者一个与现实完全相反的世界</li>
</ol>
<p>但Caillois的一些定义与游戏似乎是不相关的。如他提到了自由性，但如果一个游戏是被朋友逼着玩的，它就不是游戏了吗？还有不确定性，一个游戏的老手和游戏的新手一起竞赛，其结果几乎是必然的，难道这就不是游戏了吗？</p>
<h3 id="Definition-5：Benard-Suits"><a href="#Definition-5：Benard-Suits" class="headerlink" title="Definition 5：Benard Suits"></a>Definition 5：Benard Suits</h3><p>Suits的对于游戏的定义主要是以下几点：</p>
<ol>
<li>活动：游戏是个活动</li>
<li>自愿性：游戏可以自由加入</li>
<li>游戏有明确的目标：</li>
<li>规则：规则是游戏的一部分</li>
<li>低效性：游戏的规则限制了行为，让它不再搞笑</li>
<li>共识：规则是被所有玩家接受的</li>
</ol>
<p>Suits在定义中第一次涉及了低效性，为此他提出了游戏态度（lusory attitude）这个概念，这是对于玩家的一种状态描述。游戏态度理论的一部分是说，游戏中的规则是让游戏变得不高效，如人需要过马路，最高效的方法就是直接穿过去，但是规则限定了人必须走斑马线。游戏态度理论的另一部分就是描述，玩家必须接纳这些规则，正是对这些没必要的障碍的接纳，才让玩游戏变成了可能。</p>
<h3 id="Definition-6：Chris-Crawford"><a href="#Definition-6：Chris-Crawford" class="headerlink" title="Definition 6：Chris Crawford"></a>Definition 6：Chris Crawford</h3><p>Crawford提出了四个分类游戏的重要特征：</p>
<ol>
<li>体现性（Representation）：游戏是一个封闭的正式系统，它体现了正式世界的一个子集。封闭是指游戏是一个完全的自给自足的结构。正式是指游戏有自己的一套规则。游戏创造了一个主观的对现实情感世界的简单体现。</li>
<li>相互影响(Interaction):游戏提供了相互影响元素，这是它们有吸引性的一个重要理由。它体现了游戏世界是如何结合在一起的，改变是如何发生的。</li>
<li>冲突（Conflict）：有相互影响就自然而然就会有冲突。同时游戏还存在障碍，让玩家不会轻易的完成目标。</li>
<li>安全性（Safety）：游戏让人体验心理上的冲突和危险，但保证了物理上的安全。游戏是一个安全的体验现实的方法。</li>
</ol>
<p>Crawford是第一个将游戏称为系统的人，他也是第一个从电子游戏角度来定义游戏的人。</p>
<h3 id="Definition-7：Greg-Gostikyan"><a href="#Definition-7：Greg-Gostikyan" class="headerlink" title="Definition 7：Greg Gostikyan"></a>Definition 7：Greg Gostikyan</h3><p>Gostikyan定义游戏为：游戏一种艺术形式，在其中玩家为管理资源做出一系列决策，并通过游戏代币（Game token，这里的含义不仅仅是钱）来达成目标。</p>
<p>Gostikyan是唯一一个没有将规则纳入游戏定义的人，他也是唯一一个将游戏视作为艺术文化的人。</p>
<h3 id="Definition-8：Elliot-Avedon-and-Brian-Sutton-Smith"><a href="#Definition-8：Elliot-Avedon-and-Brian-Sutton-Smith" class="headerlink" title="Definition 8：Elliot Avedon and Brian Sutton-Smith"></a>Definition 8：Elliot Avedon and Brian Sutton-Smith</h3><p>在Sutton-Smith和Avedon对于游戏的定义为：游戏是一个自愿参加的练习控制的系统，其中会有竞争，同时还有一系列为了获得不同结果而定义的规则。</p>
<h2 id="A-Comparsion"><a href="#A-Comparsion" class="headerlink" title="A Comparsion"></a>A Comparsion</h2><p>下图是上述所有定义提到的点：</p>
<p><img src="RulesOfPlay-Chapter7-Notes/2020-03-01-23-14-15.png" alt="定义总结"></p>
<p>只有规则和目标这两项是大部分人都同意的。</p>
<h2 id="Our-Definition"><a href="#Our-Definition" class="headerlink" title="Our Definition"></a>Our Definition</h2><p>作者在对游戏的定义是：<code>游戏是一个玩家参与的，有人造冲突，被规则所限定，有可量化结果的系统。</code></p>
<p>其中可量化的结果就是区分普通非正式的玩耍和游戏的体现。</p>
<p>作者同时也给出了游戏设计的定义：<code>游戏设计是游戏设计师创造游戏的过程，玩家可以通过游戏进行有意义的玩</code>。</p>
<h2 id="The-puzzle-of-Puzzles"><a href="#The-puzzle-of-Puzzles" class="headerlink" title="The puzzle of Puzzles"></a>The puzzle of Puzzles</h2><p>后面会描述两种游戏类型，这两个游戏类型看起来似乎适合游戏的定义又似乎不合适。</p>
<p>首先是各种智力游戏（Puzzles）。智力游戏是一种特殊的游戏形式，是因为它们有固定的答案。智力游戏完全符合作者对游戏的定义，其中的冲突存在于玩家和系统之间。</p>
<p>从智力游戏的角度来思考游戏，可以帮助构筑游戏。比如，当感觉一个冒险游戏太过于开放的时候，或许这个游戏应该有更多的puzzle-like的游戏因素来塑造玩家的成就感（Puzzle-like的元素是可控的）。而当感觉冒险游戏缺乏游玩的感觉时，可能就是因为有太多的Pizzle-Like的因素，让人觉得所有的可能就是限定了的。</p>
<h2 id="Role-Playing-Games"><a href="#Role-Playing-Games" class="headerlink" title="Role-Playing Games"></a>Role-Playing Games</h2><p>角色扮演类游戏（Role-Playing Games）从定义上来看缺乏可量化的结果，但其实这是一个观察角度的问题。</p>
<p>如果从整个游戏的角度来看，角色扮演类游戏确实没有一个可量化的分数之类的结果。但是从游戏中的每一部分去看，在游戏过程中有任务的完成，或角色的升级等，这些都是一个量化结果。</p>
<p>举这两个例子是想说明当遇到一个游戏似乎不满足游戏的定义，应该更多的是从扩大游戏定义的角度去思考，这才会推动游戏的发展。</p>
<h2 id="Further-Reading"><a href="#Further-Reading" class="headerlink" title="Further Reading"></a>Further Reading</h2><ol>
<li><em>Homo Ludens</em>,Johann Huizinga</li>
<li><em>Man,Play,Games</em>,Roger Caillois</li>
</ol>
<div class="note info simple"><p>引用：</p>
<p>1.<em>Rules of Play</em> 2003</p>
</div>
<hr>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>游戏设计</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>游戏设计</tag>
      </tags>
  </entry>
  <entry>
    <title>ShadowsocksR 翻墙教程</title>
    <url>/ShadowsocksRTutorial/</url>
    <content><![CDATA[<p>简单的介绍ShadowsocksR是什么及如何自己购买并搭建ShadowsocksR需要的服务器。</p>
<span id="more"></span>
<h2 id="ShadowsocksR-概述"><a href="#ShadowsocksR-概述" class="headerlink" title="ShadowsocksR 概述"></a>ShadowsocksR 概述</h2><p><code>ShadowsocksR</code>（下简称<code>SSR</code>）的前身<code>ShadowSocks</code>（下简称<code>SS</code>）,是被设计用来混淆数据，用来瞒过墙的实时流量检测，其作者在15年8月被有关部门约谈后，删除了Github上的源码及文档<sup><a href="#fn_1" id="reffn_1">1</a></sup>。</p>
<p><code>SSR</code>则是在<code>SS</code>作者停止项目更新后，由另一个作者制作的第三方的版本，加强了混淆协议和插件版本。<code>SS</code>和<code>SSR</code>的工作逻辑并不是加密数据，而是通过伪装来增加<code>GFW</code>(The Great Firewall of China)识别的难度。</p>
<blockquote>
<p>“We don’t need security. We need indistinguishability from random bytes.”<sup><a href="#fn_2" id="reffn_2">2</a></sup></p>
</blockquote>
<p><code>SS</code>只有一种混淆方式且用户无法自行选择，在作者放弃项目后，这个混淆方式逐渐被墙所识别，所以现阶段<code>SS</code>几乎已经无法正常使用。</p>
<h2 id="搭建SSR翻墙"><a href="#搭建SSR翻墙" class="headerlink" title="搭建SSR翻墙"></a>搭建SSR翻墙</h2><p>搭建<code>SSR</code>的基本流程为：</p>
<ol>
<li>购买国外服务器</li>
<li>在国外服务器上安装<code>SSR软件</code>（作为Server）</li>
<li>安装<code>SSR客户端</code>，并访问国外服务器（作为Client）</li>
</ol>
<p>市面上有很多售卖翻墙服务的，他们大部分都是自己完成了上述的1,2步骤，然后将配置好的服务器地址售卖给用户，让用户自己使用SSR客户端进行翻墙。这样服务的弊端首先在于服务器的共享会限制网速，其次由于大量的IP访问同一台服务器，增加了被<code>GFW</code>识别的概率，服务器也容易被Ban，导致服务的不稳定性。</p>
<h3 id="购买服务器"><a href="#购买服务器" class="headerlink" title="购买服务器"></a>购买服务器</h3><p>服务器可在<a href="https://bwh88.net/vps-hosting.php">Bandwagon</a>（下简称搬瓦工）上进行购买，最便宜的套餐为50美元一年，支持支付宝支付。</p>
<p><img src="ShadowsocksRTutorial/2019-04-27-23-12-10.png" alt="Bandwagon购买服务器"></p>
<p>在购买的过程中，会需要你进行注册，用邮箱即可。</p>
<p><img src="ShadowsocksRTutorial/2019-04-27-23-16-01.png" alt="购买注册"></p>
<h3 id="配置服务器"><a href="#配置服务器" class="headerlink" title="配置服务器"></a>配置服务器</h3><p>购买完成后，点击搬瓦工页面上方的，<code>ClientArea</code>按钮，进入个人管理，并依次点击Services-&gt;MyServices-&gt;KiwiVM Control Panel，进入管理面板。</p>
<p><img src="ShadowsocksRTutorial/2019-04-27-23-19-49.png" alt="进入个人管理"></p>
<p><img src="ShadowsocksRTutorial/2019-04-27-23-18-30.png" alt="进入控制面板"></p>
<p>进入管理面板后，先点击<code>Stop</code>，将当前服务禁止。注意在这个界面也显示了服务器的地址，记录下这个地址，之后需要用到。</p>
<p><img src="ShadowsocksRTutorial/2019-04-28-00-22-15.png" alt="控制面板界面"></p>
<p>点击左侧<code>Install new OS</code>安装新的操作系统，选择<code>ubuntu 12.04 X86_04</code>，同意款项，并安装。</p>
<blockquote>
<p>如果需要BBR加速的话，建议选择最高的X64版本，因为BBR依赖于4.9以上的Linux内核</p>
</blockquote>
<div class="note warning simple"><p>严格意义上，SSR服务端安装脚本并不依赖于特定系统版本，CentOS 6+，Debian 7+，Ubuntu 12+的系统均可。如果在某版本的系统上出现安装错误（如2019年4月前后，Debian服务器访问失效，导致对应依赖库无法安装），可尝试使用其他版本的系统。</p>
</div>
<p><img src="ShadowsocksRTutorial/2019-05-06-20-55-11.png" alt="安装新OS"></p>
<p>在OS安装后，会显示处<code>SSH</code>的登录密码及端口，通过截图或者其他方法将它们保存下来，之后的步骤需要用到。通常情况下，搬瓦工也会发送一封邮件到你的注册邮箱告诉你密码及端口。</p>
<p><img src="ShadowsocksRTutorial/2019-04-27-23-27-05.png" alt="控制面板显示"><br><img src="ShadowsocksRTutorial/2019-04-27-23-27-30.png" alt="邮箱显示"></p>
<h3 id="安装SSR软件"><a href="#安装SSR软件" class="headerlink" title="安装SSR软件"></a>安装SSR软件</h3><p>在服务器上安装SSR软件，首先你需要登录到服务器上，一般使用软件<a href="https://www.netsarang.com/zh/xshell/">Xshell</a>，该软件不是免费的，但有一个月的试用期。</p>
<p>在安装完并打开<code>Xshell</code>后，会自动弹出会话窗口，点击右上角新建，然后将我们在之前步骤中记录下的服务器地址及SSH端口号填入。</p>
<p><img src="ShadowsocksRTutorial/2019-04-28-00-27-42.png" alt="填入服务器地址及端口"></p>
<p>点击确认后，会自动回到会话窗口，双击刚刚建立的会话，输入用户名<code>root</code>，在连接过程中会提示<code>SSH安全警告</code>，点击<code>接受并保持</code>即可，之后会弹出<code>SSH用户省份验证</code>窗口，将之前记录下的密码填入即可。</p>
<p><img src="ShadowsocksRTutorial/2019-04-28-00-30-45.png" alt="填入密码"></p>
<p>成功登录后，界面如下。</p>
<p><img src="ShadowsocksRTutorial/2019-04-28-00-32-01.png" alt="成功登录界面"></p>
<p>之后我们就要进行SSR软件安装，复制命令</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh</span><br><span class="line">chmod +x shadowsocks-all.sh</span><br><span class="line">./shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log</span><br></pre></td></tr></table></figure>
<p>在Xshell界面，通过鼠标右键黏贴，然后回车运行，首先我们选择需要运行的脚本，在这里我们需要的是<code>ShadowsocksR</code>。之后会需要用户输入一系列信息，如密码，端口，混淆方式，加密方式等。下图中红框位置即为输入信息，这些参数都可以根据自己的情况调整（如端口号可随意设为1111），通常而言不会引发问题。</p>
<p><img src="ShadowsocksRTutorial/2019-05-06-20-57-51.png" alt="需要输入信息_1"><br><img src="ShadowsocksRTutorial/2019-04-28-01-01-07.png" alt="需要输入信息_2"><br><img src="ShadowsocksRTutorial/2019-04-28-00-39-01.png" alt="需要输入信息_3"></p>
<p><code>SSR</code>软件安装完成后，所有的设定信息都会显示出来</p>
<p><img src="ShadowsocksRTutorial/2019-04-28-01-00-00.png" alt="信息显示"></p>
<p>至此，服务器上安装<code>SSR软件</code>结束。</p>
<h3 id="安装SSR客户端"><a href="#安装SSR客户端" class="headerlink" title="安装SSR客户端"></a>安装SSR客户端</h3><p><code>SSR</code>客户端下载地址：</p>
<p>Windows/OSX：<a href="https://github.com/shadowsocks/shadowsocks-windows/releases">https://github.com/shadowsocks/shadowsocks-windows/releases</a><br>Android: <a href="https://github.com/shadowsocks/shadowsocks-android">https://github.com/shadowsocks/shadowsocks-android</a><br>OSX: <a href="https://github.com/shadowsocksr-backup/ShadowsocksX-NG/releases">https://github.com/shadowsocksr-backup/ShadowsocksX-NG/releases</a><br>IOS: Potatso Lite、shadowrocket等软件</p>
<h3 id="配置SSR客户端"><a href="#配置SSR客户端" class="headerlink" title="配置SSR客户端"></a>配置<code>SSR</code>客户端</h3><p>以<code>Windows</code>端为例，运行<code>SSR</code>程序后，右键小飞机图标，选择编辑服务器，将之前安装服务器上<code>SSR软件</code>后的一系列信息填入。</p>
<p><img src="ShadowsocksRTutorial/2019-04-28-00-51-21.png" alt="编辑服务器"></p>
<p>再右键，将模式设置为全局模式。</p>
<p><img src="ShadowsocksRTutorial/2019-04-28-00-54-17.png" alt="全局模式"></p>
<p>至此，一切步骤完成，可以打开游览器，尝试是否可以正常访问谷歌。</p>
<h2 id="BBR加速"><a href="#BBR加速" class="headerlink" title="BBR加速"></a>BBR加速</h2><p>BBR是一套TCP拥塞控制算法，由谷歌开源并提交到Linux内核，在Linux4.9以上，可以使用这套算法来加速网络访问速度。</p>
<p>先使用以下命令来检测Linux内核版本</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure>
<p>大于4.9就可以直接切换，如果小于4.9的话，可以选择安装更高版本的OS。</p>
<p>之后通过以下命令只要下载并运行脚本</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh &amp;&amp; chmod +x bbr.sh &amp;&amp; ./bbr.sh</span><br></pre></td></tr></table></figure>
<p>完成后运行以下语句验证BBR是否正常工作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sysctl net.ipv4.tcp_congestion_control net.core.default_qdisc</span><br></pre></td></tr></table></figure>
<p>显示以下结果说明运行成功</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">net.ipv4.tcp_congestion_control = bbr</span><br><span class="line">net.core.default_qdisc = fq</span><br></pre></td></tr></table></figure>
<p>如果在安装过程中遇到任何问题，可以直接在下面评论区提出。</p>
<div class="note info simple"><ol>
<li>SS原工程 <a href="https://github.com/shadowsocks/shadowsocks">https://github.com/shadowsocks/shadowsocks</a></li>
<li>SS作者关于安全性的回复 <a href="https://github.com/shadowsocks/shadowsocks/issues/169">https://github.com/shadowsocks/shadowsocks/issues/169</a></li>
<li><a href="https://sphard3.github.io/ssr/ssr.html">https://sphard3.github.io/ssr/ssr.html</a></li>
<li>SSR服务端安装脚本作者 <a href="https://teddysun.com/486.html/comment-page-60#comments">https://teddysun.com/486.html/comment-page-60#comments</a></li>
</ol>
</div>
<blockquote id="fn_1">
<sup>1</sup>. <a href="https://github.com/shadowsocks/shadowsocks">原工程</a>目前只剩下了一条Commit<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_2">
<sup>2</sup>. <a href="https://github.com/shadowsocks/shadowsocks/issues/169">https://github.com/shadowsocks/shadowsocks/issues/169</a><a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a>
</blockquote>
]]></content>
      <categories>
        <category>教程</category>
        <category>翻墙梯子</category>
      </categories>
      <tags>
        <tag>翻墙梯子</tag>
        <tag>软件推荐</tag>
      </tags>
  </entry>
  <entry>
    <title>《旅行的艺术》 笔记</title>
    <url>/TheArtOfTravelNotes/</url>
    <content><![CDATA[<p>作者：阿兰·德波顿<br>《旅行的艺术》的结构、内容笔记以及摘要</p>
<span id="more"></span>
<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="TheArtOfTravelNotes/TheArtOfTravelNotes_MindMaps.png" alt="思维导图"></p>
<h1 id="结构笔记"><a href="#结构笔记" class="headerlink" title="结构笔记"></a>结构笔记</h1><p>　　这本书并非一本旅游指南，也没有细枝末节的分析旅行中的每一个过程，相较于旅行过程这本书实际更加关心的是旅行者的内心世界。阿兰·德波顿在每一节中都会将自己旅行的感受和福楼拜、波德莱尔、梵高、霍珀等艺术家的经历相结合，来讨论旅行中的一些因素对自己的影响和意义。</p>
<p>　　本书主题包括旅行的出发、过程和回归。其中旅行的过程又探讨了动机、风景和艺术这三部分旅行要素。</p>
<p>　　在出发这一部分中，作者首先讨论了对旅行的期待，对于旅行的期待很容易被艺术作品激发，如作者自己就因为一本《冬日艳阳》而前往了巴巴多斯岛。但是旅行的真实情况会与心中的期望存在较大的差异，一是因为激发我们的艺术作品会将真实生活中无聊和琐碎隐藏，它让我们错以为存在一个没有任何杂质的生活，二是因为旅行的过程会存在身体和心灵的干扰，导致我们无法对专注于旅程中的美。</p>
<p>　　之后作者提到了旅程中的一些特定地方，包括交通工具和路边的加油站和小餐馆等。这些地方都会让人有逃离生活的感觉。作者会在他不开心的时候会前往希思罗机场，那些飞离的飞机给他带来一种前往陌生生活的渴望。查尔斯·波德莱尔是一个充满了对生活之外地方渴望的诗人，他甚至于对旅途中的交通工具也充满了兴趣，作者认为这是因为交通工具存在一些象征性的含义，如飞机的迅疾上升存在着一种人生转机的暗示，空中的云朵则带来一种宁静等等。然后作者介绍了公路边的加油站和小餐馆这些给人带来孤独感觉的地方，霍珀的许多作品描述了这种孤独。但旅途中的这些场所的孤独与我们在都市热闹中感到的孤独比不相同，在这些地方人与人之间的隔阂是一种大家都心知肚明的存在，于是也就不存在热闹中置身度外的那种痛苦，反而是一种与周围人群强烈认同的感觉。在这一节的最后描述了火车和旅馆，火车上闪过的风景和旅馆中与家中不同的装饰都是一种变化的存在，让人摆脱以往的思维定势。总之旅行出发时的这些特定地方都已经带来了与平常生活不同的感受，给人们改变日常生活中陋习的可能。</p>
<p>　　在旅行过程的部分，首先谈到的是动机，这里主要描述了两种旅行的动机，追求异国情调和满足好奇心。</p>
<p>　　一些简单但充满异国情调的东西也会让我们感到快乐，因为这些东西表明了我们已经到了另一个地方，如之前所说的，远离了原先的生活。但有时异国情调所带来的快乐也有更深层的含义——那些物品所表达的正是本国求之不得的东西。作者着重用了福楼拜的例子来阐述这个问题，埃及的骆驼，喧闹的生活，“粗俗”的表达和行为反而让福楼拜感到快乐，因为他认为这些与他所厌恶的法国虚伪的资产阶级正好相反。这种因为与日常生活不同所造就的魅力也体现在异国的异性身上，他们所展现的一些我们自己不具备的个性会让人充满魅力。</p>
<p>　　但异国情调带来的魅力很可能随着时间而渐渐流逝，因为这种魅力本质上是出于我们逃避生活的一种狂热和幻想，我们错以为与原先生活的不同就是美好。但也有可能，这些狂热的魅力也会被更理性和现实的好感所替代，如同福楼拜在埃及生活9个月后，即使存在一些失望但仍然觉得埃及的生活满足他对东方最初的幻想。</p>
<p>　　然后是满足好奇心的问题，亚历山大·冯·洪堡在南美洲的探险是一种为了获得知识的好奇心满足，如地球磁场的分布，海拔对于植物的影响等。但这样的好奇心在当下已经不再实用，我们可以通过旅游指南之类的东西得到这些知识，于是这里作者提出了一种新的好奇心的追求，针对知识来提出自己的问题，并最终让自己的生活得到升华。但提出问题也并非一件易事，这需要旅客在先前有相关的知识积累。</p>
<p>　　旅行过程中风景是非常重要的因素，书中主要谈论的是乡村与城市和壮阔的风景。</p>
<p>　　乡村与城市会对人产生不同的影响，因为人会随着周围环境的人或物的转变而变化。大自然中一些景物会给人带来某种价值的能量，如橡树代表尊严，松树代表坚毅等。诗人华兹华斯坚定的认为大自然对于人存在积极向上的作用，在一开始人们并不相信他的理论，但随着时间的推移，人们开始相信了城市会造就人的焦虑和炫耀。18世纪的后期也迎来了城市居民涌向乡村的历史运动。</p>
<p>　　壮阔的风景也同样拥有对于人道德提升的作用。壮阔并不等同于美丽，只有景致表明了人类意志所不能左右的力量，体现了人类的脆弱和渺小称之为壮阔。壮阔的景色让人意识到一种人类意志无法对抗的存在，也因此人能坦然面对自己的缺憾。同时壮阔的景象也很容易让人联想到一些远比人类强大的力量，而这很容易与宗教联系在一起，如《旧约》中的《约伯记》就是把上帝与壮阔的力量所联系的一节。</p>
<p>　　艺术不仅影响在旅行出发时会引起人们的期待，也同样会扩大游客在旅行中的眼界。每一个大师都会在真实世界中选择他认为的突出品质，并将其通过艺术表达出来。如梵高描绘的普罗旺斯的柏树，莫奈的落日等等。正是这些作品让游客发现了风景的欣赏价值，18世纪前后，英国人民对本岛旅游的逐渐热衷也是因为相关事件点关于英国风景的作品逐渐的增多。</p>
<p>　　艺术还有一个作用就是可以让游客真正的拥有美。人们会用很多方式来试图拥有美，如照相、购买纪念品等等。但是约翰·罗斯金提出了用绘画拥有美，绘画并不是最终目的，更重要的是绘画时的观察，它迫使我们去观察美，并对美产生了判断，知道是什么造就了美。</p>
<p>　　书的最后作者谈到了旅途的终点——回归。我们应当如旅行般看待回归后的日常生活，梅伊斯特的《我的卧室之旅》一书就在探讨这个事。旅行的快乐并非来自于旅行本身而是旅行时的心境，如果我们能像旅行时一样用谦卑、好奇的态度看待平常生活，自然也会发现平常忽略的有趣的地方。</p>
<h1 id="概念笔记及摘抄"><a href="#概念笔记及摘抄" class="headerlink" title="概念笔记及摘抄"></a>概念笔记及摘抄</h1><h2 id="出发"><a href="#出发" class="headerlink" title="出发"></a>出发</h2><h3 id="对旅行的期待"><a href="#对旅行的期待" class="headerlink" title="对旅行的期待"></a>对旅行的期待</h3><p>　　对于旅行的渴望很容易被激发，如作者期望前往巴巴多斯岛进行旅游，就仅是因为一本看了一本《冬日艳阳》。但在旅行的过程中我们会发现期望与现实往往存在较大的差异，这里作者举了于斯曼的《逆流》中的例子，《逆流》中的主人公德埃桑迪斯打算前往伦敦旅行，但在一家英式餐馆吃饭时，意识到对于一个地方的想象可能和实际情况之间存在令人沮丧的差异，于是便取消了旅行计划。</p>
<p>　　而这个的原因一是因为我们对于旅行的过多期待大多是由艺术作品引起的。艺术品常将生活中的琐碎与无聊省略，这造成人们对理想生活的期待，但真实世界却充满着重复、不着边际、没有条理的情节。回忆很美好的原因也在于回忆也会省略生活中不美好的部分。二是因为旅行无法如同期待一样美好还因为旅行时的身体和心灵的干扰。这里作者以自己在巴巴多斯岛旅游的经历作为例子，在巴巴多斯时会对旅行结束后的工作产生焦虑以及旅行过程中与旅伴的争斗造成了之后旅行的不愉快。</p>
<blockquote>
<ol>
<li>他说明了人生中许许多多的事件（甚至是整个人生）是如何为一些最简单、最经不起推敲的快乐图景所影响；而一次开销巨大，超出经济承受能力的旅程的起因又如何可能仅仅是因为瞥见了一张摄影照片</li>
<li>旅行还是很少迫使人去考虑一些超越实际、需要深层思索的哲学层面的问题。我们经常得到应该到何处旅行的劝告，但很少有人告诉我们为什么要到那个地方</li>
<li>期待和艺术的想象省略、压缩，甚至切割掉生活中无聊的时段，把我们的注意力直接导向生活中的精彩时分而毋须润饰或造假，结果是，它们所展现的生活气韵生动，井然有序。这种气韵和秩序是我们纷扰错乱的现实生活所不能呈现的。</li>
<li>旅行时，置身于真实的荷兰，我们的体验也因此奇怪而平淡，全然不及在卢浮宫的荷兰化作展厅里游览一个下午来得兴奋，因为在这几间展室里，收藏有荷兰和荷兰人生活中的最美好的方面。</li>
<li>我的身体和心灵是难缠的旅伴，难以欣赏这趟旅行之美</li>
<li>只有当我们不必亲临某地去面临额外的挑战，我们方能最自如地置身其中。</li>
<li>无论是赏心悦目的事物，还是实实在在的东西，我们从中获得幸福的关键似乎取决于这样一个事实，那就是我们必须首先满足自己情感或心理上的一些更为重要的需求，诸如对理解、爱、宣泄或尊重的需求。</li>
</ol>
</blockquote>
<h3 id="旅行中的特定场所"><a href="#旅行中的特定场所" class="headerlink" title="旅行中的特定场所"></a>旅行中的特定场所</h3><p>　　这一节中作者用作家作家查尔斯·波德莱尔和画家爱德华·霍珀的作品来阐述旅行中的特定场所。查尔斯·波德莱尔是一个充满了对于生活之外地方的向往的人，他认为自己真正的愿望就是离开现在的地方，任何地方即可。类似的感情作者也同样拥有，作者在家不开心的时候，常会选择前往希思罗机场，那里的场景会让他产生对于全然陌生的地方的渴望。</p>
<p>　　波德莱尔期待的不仅仅是旅途起点和终点，如车站、码头、机场，他同样也羡慕哪些交通工具。这里作者认为这些交通工具和旅行过程中的场景会带来一些象征性的含义。如飞机的迅疾的上升是实现人生转机的极佳象征，所以飞机的起飞会带来心灵的愉悦。云朵带来的是一种宁静，因为我们恐惧和悲伤的来源，都被藏在了云朵的下方。</p>
<p>　　公路边的加油站和小餐馆给人孤独的感受，但在这些地方，孤独并不让人觉得难以忍受，因为周围的人也都彼此保持着距离，这与自己在热闹中无法融入的孤独是完全不同的。霍珀有许多的作品都展现了这种孤独，如《自动贩卖店》、《加油站》。这种孤独是温柔的，此时的孤独不是那种置身于欢笑和群闹中，让人意识到心境和环境之反差并觉得痛苦的那种孤独；它源于陌生的人群，在这里大家都明白，沟通的障碍客观存在，对爱的渴求也难以实现。</p>
<p>　　还有旅行过程中的火车和旅馆，在火车行进过程中看到一直在变化的风景有助于我们思考，而旅馆中与自己家不同的装饰则帮助我们摆脱思维定势。</p>
<blockquote>
<ol>
<li>这是一种常见的隔阂感，对任何独处者，这种感觉有助于减轻它们在孤独状态下的压抑感。在公路旁的小餐馆、午夜时分的自助餐厅、旅店的大堂和火车站的咖啡馆，我们可能不太能感觉到那种在偏僻的公共场所油然而生的孤独和疏离感、反倒重新发现一种同周围人群的强烈认同。……在这些地方，我们更容易摆脱心中的感伤——这种近乎避难所的装饰更能让我们放松</li>
<li>旅行，或者那种漫无目的的漂泊的过程，其价值在于它们能让我们体验情感上巨大的转变</li>
<li>18世纪以来，人类的同情和了解不再源自于社群活动，而是来自于人们的漂泊经验。因此一种基本的疏离、沉默和孤独已成为人性和社群的载体，对抗着普通社会阶层的苛严僵固、冷漠无情和自私自利的闲适。 ——雷蒙德·威廉斯《乡村和城市》</li>
<li>这些偏僻孤立的地方给我们提供了一种实实在在的场景，使我们能暂时摆脱因循僵滞的日常生活中难以改易的种种自私的安逸、种种陋习和拘囿</li>
</ol>
</blockquote>
<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><h3 id="异国情调"><a href="#异国情调" class="headerlink" title="异国情调"></a>异国情调</h3><p>　　在到达一个新的地方旅游时，我们可能因为一些简单的但是却充满异国情调的东西感到快乐，因为这些东西表明我们已经到了另一个地方，远离了原先的生活。</p>
<p>　　有时我们在异国会因为一些非常细小的事物引发很强的感受，这是出于我们对于生活细节的关注。对于异国情调感到快乐，往往是因为这些事物表现出的一些东西，正是我们在本国苦求而不得的东西。如作者在阿姆斯特丹看到红色的大门与白色内墙的装饰，竟然产生出想居住于此的想法，其本质是因为这些建筑表现出的现代意识，而这与作者在伦敦看到的模仿古典的建筑风格表现出的封闭保守心态相反。</p>
<p>　　作者在这一节详细介绍了福楼拜在埃及旅游及生活时的例子。</p>
<p>　　福楼拜的一些想法与他所处的法国相悖，而他又对于东方文化存在向往，于是在1849年与朋友一起前往了埃及。</p>
<p>　　福楼拜在其著作《庸见词典》中对法国的资产阶级进行了强烈的讽刺，在他眼中法国的资产阶级是一个虚伪、势利且充满着歧视的社会阶级。在法国，他自身的想法与所处的社会存在分歧，而在埃及，他的观念及想法则能大行其道。</p>
<p>　　福楼拜认为生活的本质是混乱和喧嚣的，除了艺术作品，其他制造秩序的企图都是吹毛求疵和假正经。所以对于法国的建筑他认为有太多的矫饰和做作，而埃及生活的选校和颜色缤纷的建筑则让他喜欢不已。</p>
<p>　　福楼拜思想中有个核心就是，他认为人不仅仅是有思想的动物，同时也是需要拉屎撒尿的动物，需要把这种直率的理念纳入世界观。所以他有时会认为所处的时代有伪善和假正经，他常常用人类的种种不足来警策世人。但他发现埃及则是坦然的接受了生活的双重性（粪便-理智，纯洁-性欲等），在埃及人们可以不分性别，不计身份的交流，即使最有德行、最受尊敬的女性也能用最低级、最庸俗的交谈。</p>
<p>　　福楼拜认为骆驼是最让人心动的东西之一，他认为骆驼具有恬淡韧毅和朴拙单纯的天性，在静默中表现出勇毅和谦恭，而这正与法国中产阶层的傲慢天性相反。</p>
<p>　　在异域时，本地的人也会因为他所具有的异域情调让他更有魅力。如果爱是寻找与自身的不同，那么异域的人则正好满足了这个需求。福楼拜在埃及时也爱上了一个女子库丘克，而且终其一生也没有将其忘记。</p>
<p>　　我们对于异国他乡的好感来自于它与自己生活的不同之处，但最初抵达异国他乡时的美好只是我们逃避生活的一种狂热和幻想，随着时间的推移，这些美好可能会消散，也可能会以一种更理性、现实的好感替代。福楼拜在埃及生活9个月后对埃及有了正确的认识，与最初的幻想相比，失望肯定是有的，但他认为在埃及的生活仍然满足他最初对于东方的想象，并且扩展了当初的一些狭隘观念。</p>
<blockquote>
<ol>
<li>不管这些由异国的细小（和无声）的事物所引发的强烈反应看上去是多么荒谬，这情形至少同我们的私人生活有相通之处。……如果我们因注重这些细节的东西而自责，那么我们必将忽略生活中的细节本身所具有的丰富含义</li>
<li>就福楼拜而言，对东方的凝视能帮助他从自己的生活环境中解脱出来，暂时将那种富足却委琐的生活以及世俗的思维定势抛于脑后</li>
<li>在异域，一个有吸引力的人除了具有我们本国人所具有的魅力外，他所处的国度的异域情调也让他生辉不少。如果爱是寻求那些我们自身所不具备、却让我们所爱之人独有的个性魅力，那么，当我们和异域情人相爱时，我们更有理由期待自己融入一种我们自身文化所缺失的价值和观念之中.</li>
<li>这次见面只能让福楼拜愈发伤感：“无边的悲哀……这就是结局！我将再也不能见到她。记忆中她的容颜将慢慢消失”。事实上，这以后福楼拜终其一生都未忘记库丘克的容颜。</li>
<li>尽管福楼拜希望能摆脱他所认为的欧洲现代资产阶级的那种极端的愚蠢，但他发现，不管身处何地，这种愚蠢无时不伴随着他：“愚蠢是一种顽固的东西；如果你试图从你的生活中根除这种愚蠢，那么，你的生活也就随之毁掉了……</li>
<li>他（福楼拜）对波伊特文说：“一个中产者也许会说，’你若去那里，你将会有强烈的幻灭感。’但我很少有幻觉，更少体验幻灭感。总有人给谎言以妆饰，还说一切的诗意都基于各类幻觉，这实在是一种愚蠢的滥调。</li>
<li>福楼拜：你问我，我所眼见的东方是否同原来的想象相符。是的，是相符的；而且超乎我的想象，这里的一切极大地扩展了我先前对东方的狭隘观念。以前对东方的一些模糊不清认识，现在都变得具体清晰起来。</li>
</ol>
</blockquote>
<h3 id="好奇心"><a href="#好奇心" class="headerlink" title="好奇心"></a>好奇心</h3><p>　　作者在这一节通过将自己在马德里的旅游经历与亚历山大·冯·洪堡在南美洲探险的经历做类比来讨论旅游时好奇心的问题。</p>
<p>　　好奇心首先是对于新事物的发现，如洪堡靠着新天文钟和六分仪重新绘制了南美洲的地图，研究了地球磁场，测量气温及海拔对植物的影响等，这些都是洪堡因为好奇心而去测量得到的对新事物的理解。但是对于在马德里的作者而言，并不存在什么新事物，一切的东西都已经被测量完成，只需要从旅游指南上获取即可。</p>
<p>　　好奇心也应当是针对知识提出自己的问题，一切知识应当让自己的生命得到升华。作者借尼采的表述提出了一种新的旅游方式：借历史建筑看到历史，再通过历史了解社会和身份的形成过程，让自己得到延续性和归属感。</p>
<p>　　这种新旅行方式是一种与个人息息相关的方式，但是现在的旅游指南会给个人带来一种无形的压力，因为它在潜移默化中迫使读者接受其权威性，而影响游客自己的判断。洪堡在南美洲探索时的自由，也正是因为欧洲人很少去南美洲，他者经验的缺失造就了洪堡好奇心的自由。<br>所以我们要意识到并尽量减少先入之见的指南对自己好奇心的影响。</p>
<p>　　最后作者探究了好奇心的由来，他以洪堡在秘鲁坎博拉索火山上对一个苍蝇产生浓厚兴趣的例子展开。洪堡在幼年时就对植物生长环境和气候地理如何影响动植物产生浓厚兴趣并进行过相关研究，所以在火山一万多英尺的高处见到苍蝇时，洪堡才会对此感到兴奋。</p>
<p>　　好奇是需要成长过程中通过无数小问题来积累的。大多数游客不会对景物产生质疑和欣喜正是因为我们在旅行前没有积累和具备所需要的知识积累。旅游景点的地理原因进一步加深了游客的这一问题，游客常会在一个地区接二连三的观赏一系列内核毫无相关的景物，如作者在马德里参观了18世纪的皇家宫殿后去了索菲亚王后艺术中心，而后者收藏的却是20世纪的艺术作品。如果是为了对18实际的皇家建筑风格有更深的了解，应当前往布拉格或圣彼得堡进行参观。</p>
<blockquote>
<ol>
<li>对于任何旅人来说，一个为求得真知而进行的旅程，远比一个四处观光之旅得到更多的好处。</li>
<li>尼采: 评判我所学的任何东西，都应以它是否让我受益为准则，而不是考虑它是否满足他人的利益。我对事物的发现应当让我更具活力：他们必须以某种方式使我“生命升华”</li>
<li>歌德：我厌恶所有那些只提供指示，却未能丰富或鼓动我活动的东西。</li>
<li>尼采：历史中总是一次又一次地出现一些对过往的伟大事物进行反思的人，他们从中获取力量，深深感受到人类生命的辉煌灿烂。</li>
<li>当旅游指南对一个旅游景点赞赏有加时，它无形中产生一股压力，迫使读者接受其权威性，缔造一股热忱，至于景点会使游客感受到沉默、幸福还是兴致勃勃，它则毫不关心。</li>
<li>好奇心像是由一些一连串向外拓展，并且有时延伸到深处的小问题所引起……如果环境和个人性情的发展得以配合，我们在成年的岁月中会继续探讨这些问题。人们的好奇心会涵盖更广阔的天地，最后达到什么都觉得新鲜、有趣的阶段。那些混沌的大问题便引出了更细微和深奥的问题。</li>
<li>惟有经历好奇心的漫长演化，看到沙巴提尼设计的具新古典形式外观的大教堂，才会觉得欣喜，而不会陷入无聊、沮丧。</li>
<li>洪堡:人们常说我同时对太多东西感兴趣，例如植物学、天文学和解剖比教学。但你果真能够抑制一个人的求知欲，不让他了解和拥抱周遭的一切吗？</li>
</ol>
</blockquote>
<h2 id="风景"><a href="#风景" class="headerlink" title="风景"></a>风景</h2><h3 id="乡村与城市"><a href="#乡村与城市" class="headerlink" title="乡村与城市"></a>乡村与城市</h3><p>　　作者在因私事前往英格兰湖区，在前往乡村的旅途作者联想到了18世纪后期的城市居民涌向乡村的历史运动及一位描写乡村的诗人威廉·华兹华斯。在华兹华斯前，大自然很少收到诗人们的关注，而华兹华斯则认为大自然中的各种现象有助于矫正城市人的心灵。一开始华兹华斯的主张收到了大量的质疑，有人批评他是故作幼稚，但是随着时间的推移他的主张收到越来越多的支持，在1830年左右人们开始欣赏和赞扬华兹华斯的诗歌。华兹华斯认为城市造就了人的焦虑和炫耀，而仅有乡野可以对抗城市的不良影响。</p>
<p>　　作者之后以自身的思考和华兹华斯的观点探讨了为何大自然对都市生活有纠正作用。首先我们要认同的前提是，人会随着周围的人或物的转变而变化。而大自然的中一些景物则有提示我们某种价值的能力，如橡树象征尊严，松树象征坚毅，悬崖让人产生崇高的念头。</p>
<p>　　作者认为大自然能给人带来精神的慰藉，但是往往这样的慰藉只能持续几小时。但是华兹华斯却认为存在一种“凝固的时间点”，在大自然中看到的景象可以永远的留在我们记忆中，每当遇到困境时，这些记忆就会出现与困境形成对比，带给我们慰藉。作者也曾体验过这样的凝固时间点：在一天下午，作者被困在伦敦的交通堵塞中，而他突然涌现了湖区周围的一片森林的景象，驱散了他的焦虑。</p>
<blockquote>
<ol>
<li>以前，诗人不过是很随意或习惯性地看待自然现象，但是它们在华兹华斯笔下却成了最伟大的主题。</li>
<li>诗人解释说，大自然中的各种现象，包括小鸟、小溪、水仙和绵羊，都是不可或缺的，因为它们能矫正和治疗城市人备感困顿的心灵。</li>
<li>诗人谴责城市造成的一系列窒息生命的情感，包括对我们所处社会地位的焦虑，对他人成就的羡慕，以及在陌生人面前炫耀的欲望。他直言不讳地表示，城市人毫无主见，只限于在街边或饭桌上道听途说、人云亦云。虽然他们生活舒适，却从未放弃追逐新鲜事物，即使他们什么都不缺、而幸福也与他们想要追逐的东西无关。另外，想在这样拥挤而焦躁的生活圈子里与他人建立真诚的情谊，要比在一个孤立的居住环境还要困难。</li>
<li>华兹华斯说：大自然会指引我们从生命和彼此身上寻找“一切”存在着的美好和善良的东西”，自然是“美好意念的影像”，对于扭曲、不正常的都市生活有纠正的功能。</li>
<li>华兹华斯在信中几乎明确指出自然界所包含的价值。他说“一位伟大的诗人……应该在某种程度上纠正人们的思想感情……使他们的感情更健全、纯洁和永久，也就是与大自然产生共鸣、更加和谐。”</li>
<li>如果我们对这个时代或精英的价值观感到痛心，那么思及地球生命的丰富多彩，或许会让我们感到释然，让我们记住。这个世界除了大人物的事业，还有在原野鸣叫的草地鹨。</li>
<li>我的思绪被带离了繁忙的交通和拥挤的人群，回到了那些我叫不出名字、却非常清晰可见的树木面前。这些树木成了我思绪得以休息的避风港，它们保护着我，使我免于陷入焦虑的漩涡，并且在那个下午给了我一部分生存的理由。</li>
</ol>
</blockquote>
<h3 id="壮阔"><a href="#壮阔" class="headerlink" title="壮阔"></a>壮阔</h3><p>　　作者首先探讨了壮阔的定义，壮阔一词来自于希腊作家隆基努斯的一篇名为《论壮阔》的论文。壮阔一词是用来形容那些雄壮、空旷或险峻的并能给人带来美好而充满道德的感觉的风景。</p>
<p>　　作者为了体验到自己的渺小而前往了西奈南部的沙漠，沙漠中四亿年前形成的幽谷，2300米高的花岗岩山，让作者陶醉，但也让他感到人在面对宇宙的力量和迭代时，是多么的脆弱和渺小。</p>
<p>　　英国政治家埃蒙德·伯克在他《关于壮阔和美丽理念之源的哲学探究》一书中谈到，景色的壮阔往往和感觉的脆弱有关。壮阔并不是美丽，一个景致只有让人感受到大于人类，甚至是威胁人类的力量才是壮阔，壮阔表现了人类意志说不能左右的力量。而类似于春天的草原，城市的河畔，柔美的山谷只能是美丽，而称不上壮阔。</p>
<p>　　之后作者探究了为什么人会去追求那些壮阔的场景。比我们强大的东西可能会引发我们的憎恨，也可能引起我们的敬畏，而这取决于那个东西是否具有尊贵的风度。强大却卑劣的东西会让人觉得被羞辱，而强大且尊贵之物则让人敬畏。如我们视食人鱼的力量为邪恶且充满掠夺性，而把野牛的力量看作坦率而正大光明。</p>
<p>　　那些壮阔而崇高的东西给了我们一种面对自己不足的方法，即坦然面对那些缺憾。壮阔的景象能让我们意识到一些事物是人类意志所无法对抗的，只能臣服。</p>
<p>　　最后作者提到了壮阔往往会和宗教联系到一起。壮阔的景象很容易让人联想到他是由一个远比人类强大的人所建造。西方人被壮阔景色吸引的时候正好是传统的上帝信仰式微的时候，壮阔的场景让人和宗教中超然的力量保持感情上的联系。在《旧约》中的《约伯记》是把上帝和壮阔联系最具体的一个章节，约伯心地善良从未作恶，但却落到了家庭破灭，倾家荡产且身怀重病的地步，约伯对于自己的命运感到疑惑。上帝却将他的注意力引向类似于雷电、暴雨等自然现象，告诉他发生事与愿违时不要惊讶，因为人根本不能彻底理解宇宙的逻辑。</p>
<blockquote>
<ol>
<li>“当我想到……我占有的这个小小的空间正要被无垠的空间吞噬，然而对无垠的空间，我一无所知，连空间也不知道我的存在，这个念头让我惊恐，我也惊讶于自己出现在此空间而非彼空间：我有什么理由出现在此地而非彼地，有什么理由出现在此时而非彼时？是谁让我置身于此？”——帕斯卡尔《沉思录》</li>
<li>这里的山和山谷让人很自然地联想到，这个地球是由人类双手以外的东西建构的，他的力量比我们所有人力量的总和还要强大。</li>
<li>这个世界对约伯而言可能缺乏逻辑性，但是这不表示师姐本身缺乏逻辑。我们不能用自己的人生去衡量一切，而应该通过壮阔的景致提醒我们人类的渺小和脆弱。</li>
<li>壮阔景观的雄伟和力量有其象征意义。那就是：让我们无怨无悔地接受那些无法跨越的转改，以及无法理解的事件。</li>
<li>如果我们用更长的时间与它们相伴，他们会帮助我们心服口服地接受那些无法理解而又令人苦恼的事情，并接受我们终将化为尘土这一事实。</li>
</ol>
</blockquote>
<h2 id="艺术"><a href="#艺术" class="headerlink" title="艺术"></a>艺术</h2><h3 id="令人眼界大开的艺术"><a href="#令人眼界大开的艺术" class="headerlink" title="令人眼界大开的艺术"></a>令人眼界大开的艺术</h3><p>　　作者在普罗旺斯的旅行中发现并没有像梵高作品中那样充满魅力的景致，人在看到风景后的就会迅速的产生感受，这个感受很难被改变，但是提高审美能力可以让我们发现一些被忽视的地方，发现风景的欣赏价值，而艺术是最能提升我们欣赏风景能力的方法。</p>
<p>　　作者之后举了梵高的例子来说明了艺术的本质，梵高在35岁时前往普罗旺斯的阿尔勒小镇，一是为了画南方的风景，二是希望别人可以通过自己的作品“看到南方”。梵高相信可以通过艺术来让人大开眼界，看到更广阔的世界是因为梵高自己也从之前大师中感受到了这种艺术的力量，莫奈让他了解了落日，伦勃朗让他了解了晨光，维米尔让他知道了阿尔勒镇的少女。</p>
<p>　　之所以人们可以从大师的作品中看到其他事物，是因为每一个现实主义的作品都代表了作者本身的选择，画家从真实世界中选择他所认为的突出品质并通过画笔表现出来。我们有的时候批评画家的话不像，也是因为画家做出的选择与我们认知中想要突出的品质并不符合。这里作者举了梵高的例子，有人说梵高的柏树、房子、太阳、星空等太过夸张，但这实际上是梵高选择了自己觉得最重要的东西来表达，梵高所追求的像并不等同于摄影师，更多的是一个事物的真实想法，如同诗人在描述一个事物时可能比严谨的急着更能找到事情的真相。</p>
<p>　　艺术的这个能力逐渐影响了旅行，18世纪前，英国的风景很少出现在艺术作品中，而在之后类似的作品渐渐的多了起来也让英国人民更原意游历他们自己本岛的情形。</p>
<blockquote>
<ol>
<li>衡量每一个杰出画家的标志就是他们是否能够让我们更加清楚地看到世界的某些部分。</li>
<li>世界是如此复杂并足以使两幅描绘同一个地方的现实主义作品因艺术家风格和气质的不同，而呈现出完全不同的景象。</li>
<li>在惠斯勒画出伦敦的雾之前，伦敦并没有雾。在凡·高画出普罗旺斯的柏树以前，普罗旺斯的柏树一定也少得多。——王尔德</li>
<li>凡·高向他妹妹解释的“夜晚甚至比白天更加色彩斑斓……只有你注意着它，你才会看到有些星星是淡黄色的，其他的星星有一种粉红色的光芒，或者泛着绿色、蓝色，和勿忘我的光辉。不用说，只有在蓝黑背景上放置白色的小点，显然是不够的。</li>
<li>凡·高告诉他弟弟，他追求的“像”不同于虔诚的摄影师所追求的逼真。他所关注现实中的那一部分，有的时候需要加以扭曲、省略或者更换颜色，方能在画面上表现出来，但是依旧使他感兴趣的是真实——“相似性”。他愿意牺牲一种幼稚的现实主义来成就一种更加深刻的现实主义。</li>
<li>绘画是多么地虚伪，它使我们不在赞美事物本身，而兴奋地赞美绘画所表现出来的与事物的相似性。——沉思录</li>
<li>如果这些画家是精确地再现他们眼前的图景，那么在一幅画中我们将要赞叹的对象便只是画家的技巧和他本人的声名了。这样说来，或许帕斯卡尔说的绘画无用论确实没错。但是，如同尼采所言，画家并不单纯地再现，他们有所选择，有所强调，同时他们还致力于表现他们眼中的真实，因而值得让人真心喝彩。</li>
<li>只有那些世界的角落已经被艺术家们描画或描写之后，我们才会有兴趣去探索它们。</li>
</ol>
</blockquote>
<h3 id="对美的拥有"><a href="#对美的拥有" class="headerlink" title="对美的拥有"></a>对美的拥有</h3><p>　　我们对于许多的地方都只是走马观花，但还是有些地方会给我们带来震撼，迫使我们去注意他们，这些地方的特色笼统来说，可以用“美”来概括。对于美我们总有一种想要占有成为生命一部分的渴望。拍照是常见的方法，还有人会用买一些纪念品的方式。而约翰·罗斯金提出了一种不同的方法。</p>
<p>　　罗斯金医生都在用一种不是为了娱乐消遣而是为了美的方法进行旅行，他一天旅行不超过50英里，并且每隔几英里就停下来观赏风景。对于美，罗斯金提出了5个重要结论</p>
<ol>
<li>美是由许多复杂因素组合而成，对人的心灵和视觉产生冲击。</li>
<li>人有一种与生俱来的倾向，对美作出反应并渴望拥有美</li>
<li>对拥有美比较低级的表现就是渴望买纪念品或者拍照等。</li>
<li>高级点的拥有美的方式，就是理解美并理解自己敏感与哪些促成美的因素。</li>
<li>对于追求高级拥有美方式的最有效方法就是通过艺术，如书写和绘画，这并不考虑我们是有具有这样的才华。</li>
</ol>
<p>　　罗斯金在伦敦工人学院教人绘画时表达他并不是希望把工匠变成艺术家，而是希望绘画让他们成为快乐的工匠。绘画让人去关注事物而不是走马观花，这种观察就会让人对美的组成有深刻理解，进而获得对于美的深刻记忆。</p>
<p>　　罗斯金认为技术只是让人更容易的接触美，但没有让拥有美和欣赏美变得简单。现在人使用相机并不是把它作为观察的补充，而是作为替代品，认为只要有一张相片即可。真正的对美的拥有，是要注意到它的各种原色和了解他们的结构，在绘画时我们就会意识到自己先前对于事物时多么地无知。而且绘画也能让人有基本的审美能力，能对美和丑进行判断，从简单的“我喜欢……”变为“我喜欢……因为……”。</p>
<p>　　语言与绘画类似，极致的景致往往让人意识到语言的贫乏。作者在给湖区朋友的明信片上，简单的形容“这片湖很美”但其实我们更应该问自己并回答，“这片湖美在哪里，为什么如此吸引人”。只有这样我们才能更接近于“为什么一个场景可以打动我们”这种问题的答案。</p>
<blockquote>
<ol>
<li>罗斯金：现在，请记住，绅士们，我并没有试图教你们画，只是教你们去观察。</li>
<li>罗斯金：我们在旅行时，如果我们放弃每小时走100英里，从从容容地行走，我们或许会变得健康些、快乐些或明智些。世界之大，远超过我们的眼界可以容纳的范围，不管人们走得多慢；走得快，他们也不会看到更多。真正正规的东西是所思和所见，不是速度。</li>
<li>罗斯金曾经提及说这种爱源于一种渴望。“不为名声，不为服务于别人，也不为自己，而是来自一种像吃或喝一样的本能。”而绘画、吃饭、喝水这三件事之所以可以相提并论，是因为他们全部涉及自己从这个师姐吸收好的元素，把好的东西输进来。</li>
<li>罗斯金：我相信视觉比绘画来得重要；我宁可教我的学生绘画，从而让他们学会热爱自然，而不会教他们盯着自然，从而让他们学会绘画。</li>
</ol>
</blockquote>
<h2 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h2><h3 id="习惯"><a href="#习惯" class="headerlink" title="习惯"></a>习惯</h3><p>　　作者在这一节通过梅伊斯特的文章叙述了如何我们在日常的生活中获得如旅行般的快乐。</p>
<p>　　作者觉得在旅行结束后返回冷漠的伦敦让他绝望。塞维尔·德·梅伊斯特曾写过一篇《我的卧室之旅》的文章教人如何在日常生活中找寻快乐，他用旅人的眼光去注视沙发和床，去欣赏房间内的家具。梅伊斯特认为，旅行中获得的快来更多取决于旅行时的心境而不是旅行本身。而感受力是旅行心境最重要的特征，需要有谦卑的态度去接近新的地方，对有趣东西的判断，不带有任何的成见。在刚到新地方时，我们的敏感性会带领我们注意很多东西，在之后我们注意的东西就会越来越少。</p>
<p>　　独自旅行也有助于感受力的提升。在多人一起旅行时，我们很大程度上收到了周围人的影响，我们会想让自己看起来正常，这样我们就无法去关注那些细小但自己感到有趣的事物，我们需要调整自己的状态，而这便影响了求知欲。</p>
<p>　　冯·洪堡在他的自传体笔记中写到他旅游的动机是从无聊的生活转向一个奇妙的世界。洪堡的遥远世界是指南美洲，而梅伊斯特为这两个世界划分了新的接线，他认为故乡也能提供有趣的东西。多年后读到梅伊斯特著作的尼采也给出了相同的观念，他认为只有少数的人可以化腐朽为神奇，在平淡无奇的日常生活中使自己成长。</p>
<blockquote>
<ol>
<li>人类不快乐的惟一原因是他不知道如何安静地待在他的房间里。——帕斯卡尔《沉思录》</li>
<li>大家都习惯了，认为这个世界本身就很无聊——于是，生活正如他们所预期的一样无趣。</li>
<li>洪堡：我被一种不确定的渴望所激励，这种渴望就是从一种令人厌倦的日常生活转向一个奇妙的世界</li>
<li>尼采：有些人知道如何利用他们的日常生活中平淡无奇的经验，使自己成为沃土，在这片沃土上每年能结出三次果实，而其他一些人（为数众多）则只会逐命运之流，逐时代和国家变化之流，就像一个软木塞一样在上面漂来漂去。当我们观察到这一切后，我们会把人分为两类：一种人可以化腐朽为神奇，另一种人则是化神奇为腐朽，绝大部分人是后者，前者则为数寥寥。</li>
<li>我们遇见过许多穿越沙漠的人，在冰上漂泊或在丛林里穿越的人，然而他们的灵魂里，我们无法找寻到他们所见的痕迹……让我们在前往远方之前，先关注一下我们已经看到的东西。</li>
</ol>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>《漫画数据库》 笔记 （一）</title>
    <url>/TheMangaGuideToDatabasesNotes-1/</url>
    <content><![CDATA[<p>《漫画数据库》 第一、二、三章笔记。</p>
<p>包括介绍数据库的一些术语限定，关系运算，E—R模型介绍，以及表格规范化。</p>
<span id="more"></span>
<h2 id="Chapter-1-What-is-a-database"><a href="#Chapter-1-What-is-a-database" class="headerlink" title="Chapter 1. What is a database"></a>Chapter 1. What is a database</h2><ol>
<li>一个所有数据被每个人共享的系统称为数据库，数据不共享会导致很多问题如内存浪费和数据不同步。</li>
<li>数据库是被多人使用的，所以它必须提供方便的输入和输出接口。</li>
<li>数据库的安全性和权限需要被关注。</li>
<li>数据库的并行处理（如多个人同时修改一个数据）需要被关注。</li>
<li>数据库需要有错误恢复机制来处理异常情况，如磁盘损坏，数据意外丢失等。</li>
</ol>
<p>DBMS-Database management system</p>
<h2 id="Chapter-2-What-is-a-relational-detabase"><a href="#Chapter-2-What-is-a-relational-detabase" class="headerlink" title="Chapter 2.What is a relational detabase?"></a>Chapter 2.What is a relational detabase?</h2><h3 id="术语限定"><a href="#术语限定" class="headerlink" title="术语限定"></a>术语限定</h3><p>如有一个表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>产品ID</th>
<th>产品名</th>
<th>单价</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>101</td>
<td>西瓜</td>
<td>800 G</td>
<td>有种子</td>
</tr>
<tr>
<td>102</td>
<td>草莓</td>
<td>150 G</td>
<td></td>
</tr>
<tr>
<td>103</td>
<td>苹果</td>
<td>120 G</td>
<td></td>
</tr>
<tr>
<td>104</td>
<td>柠檬</td>
<td>200 G</td>
</tr>
</tbody>
</table>
</div>
<p>表中每一列称为<code>字段（Field）</code>，每一行称为<code>记录（Record）</code>。可以理解为一个产品就是一个<code>记录</code>，产品的一个属性称为<code>字段</code>。每一个<code>记录</code>都有一系列相同类型的<code>字段</code>。</p>
<p>表中每一个<code>记录</code>的产品ID都是不同的，而类似于单价这样的字段可能存在重复，我们称这些不会有重复的字段为<code>唯一（Unique）</code>。</p>
<p>像字段备注中，有一些数据为空，这些空的数值称为<code>空值（Null）</code></p>
<h3 id="不同类型的数据库"><a href="#不同类型的数据库" class="headerlink" title="不同类型的数据库"></a>不同类型的数据库</h3><ol>
<li><p>有宛如树形结构的数据库，称为<code>层次数据模型（Hierarchical Data Model）</code>，在层次数据模型中，每个字子数据都只有一个母数据。</p>
<p> <img src="TheMangaGuideToDatabasesNotes-1/2019-10-21-15-02-09.png" alt="层次数据模型"></p>
</li>
<li><p>有网状结构的数据库，称为<code>网状数据模型（Network Data Model）</code>，在网状数据模型中，每个子数据都有多个母数据</p>
<p> <img src="TheMangaGuideToDatabasesNotes-1/2019-10-21-15-02-48.png" alt="网状数据模型"></p>
</li>
</ol>
<ol>
<li><p>还有二元表状的数据库， 称为<code>关系数据模型（Relational Data Model）</code></p>
<p><img src="TheMangaGuideToDatabasesNotes-1/2019-10-21-15-03-19.png" alt="关系数据模型"></p>
</li>
</ol>
<p>在关系数据模型中，称表格为<code>关系（Relation）</code>，之前的<code>记录</code>也称为<code>行</code>，之前的<code>字段</code>也称为<code>列</code>。像产品ID这样关键的，作为记录标识的字段，称为<code>主键(Primary key)</code>。</p>
<h3 id="关系运算"><a href="#关系运算" class="headerlink" title="关系运算"></a>关系运算</h3><p>关系数据模型可以用数学概念来处理数据。</p>
<p>关系数据模型一共有8个操作，分别为<code>并（Union）</code>,<code>差（Difference）</code>,<code>笛卡尔积（Cartesian Product）</code>,<code>除（Division）</code>,<code>交（Intersection）</code>,<code>投影（Projection）</code>,<code>选择（Selection）</code>,<code>连接（Join）</code>，这些操作都可以相互组合。</p>
<p>如存在两个表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>商品名称</th>
<th>单价</th>
</tr>
</thead>
<tbody>
<tr>
<td>西瓜</td>
<td>800G</td>
</tr>
<tr>
<td>草莓</td>
<td>150G</td>
</tr>
<tr>
<td>苹果</td>
<td>120G</td>
</tr>
<tr>
<td>柠檬</td>
<td>200G</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>商品名称</th>
<th>单价</th>
</tr>
</thead>
<tbody>
<tr>
<td>西瓜</td>
<td>800G</td>
</tr>
<tr>
<td>草莓</td>
<td>150G</td>
</tr>
<tr>
<td>栗子</td>
<td>200G</td>
</tr>
<tr>
<td>柿子</td>
<td>350G</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li><p>并（Union）</p>
<p> 并操作，就是将两个表的记录合并在一起，形成一个总表。并操作结果为：</p>
<p> | 商品名称 | 单价 |<br> | ———— | —— |<br> | 西瓜     | 800G |<br> | 草莓     | 150G |<br> | 苹果     | 120G |<br> | 柠檬     | 200G |<br> | 栗子     | 200G |<br> | 柿子     | 350G |</p>
</li>
<li><p>差（Difference）</p>
<p> 差是求两个表差异的记录，如表一差表二，结果为</p>
<p> | 商品名称 | 单价 |<br> | ———— | —— |<br> | 苹果     | 120G |<br> | 柠檬     | 200G |</p>
<p> 表二差表一，结果为</p>
<p> | 商品名称 | 单价 |<br> | ———— | —— |<br> | 栗子     | 200G |<br> | 柿子     | 350G |</p>
</li>
</ol>
<ol>
<li><p>交（Intersection）</p>
<p> 交是求两表相同的记录，交的结果为</p>
<p> | 商品名称 | 单价 |<br> | ———— | —— |<br> | 西瓜     | 800G |<br> | 草莓     | 150G |</p>
</li>
<li><p>笛卡尔积（Cartesion Product）</p>
<p> 笛卡尔积是求两个表所有行的排列组合，如有商品表和出口国表</p>
<p> | 商品编码 | 商品名称 | 单价 |<br> | ———— | ———— | —— |<br> | 101      | 西瓜     | 800G |<br> | 102      | 草莓     | 150G |<br> | 103      | 苹果     | 120G |</p>
<p> | 出口国编码 | 出口国名称 |<br> | ————— | ————— |<br> | 12         | 米纳米王国 |<br> | 23         | 阿尔法王国 |<br> | 25         | 理陀儿王国 |</p>
<p> 两表笛卡尔积的结果为：</p>
<p> | 商品编码 | 商品名称 | 单价 | 出口编码 | 出口国名称 |<br> | ———— | ———— | —— | ———— | ————— |<br> | 101      | 西瓜     | 800G | 12       | 米纳米王国 |<br> | 101      | 西瓜     | 800G | 23       | 阿尔法王国 |<br> | 101      | 西瓜     | 800G | 25       | 理陀儿王国 |<br> | 102      | 草莓     | 150G | 12       | 米纳米王国 |<br> | 102      | 草莓     | 150G | 23       | 阿尔法王国 |<br> | 102      | 草莓     | 150G | 25       | 理陀儿王国 |<br> | 103      | 苹果     | 120G | 12       | 米纳米王国 |<br> | 103      | 苹果     | 120G | 23       | 阿尔法王国 |<br> | 103      | 苹果     | 120G | 25       | 理陀儿王国 |</p>
<p> 笛卡尔表的结果就是将原先两个表的记录都排列组合。</p>
</li>
</ol>
<blockquote>
<p>并、差、交和笛卡尔积都为集合运算</p>
</blockquote>
<ol>
<li><p>投影（Projection）</p>
<p> 投影是求表中的某列（可以一列或多列），结果如</p>
<p> | 产品名 |<br> | —— |<br> | 西瓜 |<br> | 草莓 |<br> | 苹果 |<br> | 柠檬 |</p>
</li>
<li><p>选择（Selection）</p>
<p>选择是求表中的某行（可以一行或多行），结果如</p>
<p>| 商品名称 | 单价 |<br>| ———— | —— |<br>| 香瓜     | 800G |</p>
</li>
<li><p>连接（Join）</p>
<p>如存在两个表，商品表和销售表</p>
<p>| 商品编码 | 商品名称 | 单价 |<br>| ———— | ———— | —— |<br>| 101      | 西瓜     | 800G |<br>| 102      | 草莓     | 150G |<br>| 103      | 苹果     | 120G |<br>| 104      | 柠檬     | 200G |</p>
<p>| 日期 | 商品编码 | 数量 |<br>| —— | ———— | —— |<br>| 11/1 | 102      | 1100 |<br>| 11/1 | 101      | 300  |<br>| 11/5 | 103      | 1700 |<br>| 11/8 | 101      | 500  |</p>
<p>连接操作是将两个表通过相同的字段连接起来，这里的字段即为<code>商品编码</code>。结果为</p>
<p> | 日期 | 商品编码 | 商品名称 | 单价 | 数量 |<br> | —— | ———— | ———— | —— | —— |<br> | 11/1 | 102      | 草莓     | 150G | 1100 |<br> | 11/1 | 101      | 香瓜     | 800G | 300  |<br> | 11/5 | 103      | 苹果     | 120G | 1700 |<br> | 11/8 | 101      | 香瓜     | 800G | 500  |</p>
<p> 我们将销售表中的商品编码称为<code>外键(foreign key)</code>，外键参照其他表中的<code>主键</code>进行联合。</p>
</li>
<li><p>除（division）</p>
<p> 除运算就是在<code>被除表格</code>中找到<code>除表格</code>中所包含的行，并将<code>除表格</code>中的字段去除的操作。如有两个表销售表和出口国表，前者为被除表格，后者为除表格</p>
<p>  | 出口国编码 | 出口国名称 | 日期 |<br>  | ————— | ————— | —— |<br>  | 12         | 米纳米王国 | 3/5  |<br>  | 12         | 米纳米王国 | 3/10 |<br>  | 23         | 阿尔法王国 | 3/5  |<br>  | 25         | 理陀儿王国 |</p>
<p>  | 出口国编码 | 出口国名称 |<br>  | ————— | ————— |<br>  | 12         | 米纳米王国 |<br>  | 23         | 阿尔法王国 |</p>
<p>  结果为</p>
<p>  |日期|<br>  | —- |<br>  | 3/5 |<br>  |3/10 |</p>
<blockquote>
<p>注意，除的结果不包含重复行</p>
</blockquote>
</li>
</ol>
<h2 id="Chapter-3-Let-us-Design-a-databases"><a href="#Chapter-3-Let-us-Design-a-databases" class="headerlink" title="Chapter 3. Let us Design a databases"></a>Chapter 3. Let us Design a databases</h2><h3 id="E-R模型"><a href="#E-R模型" class="headerlink" title="E-R模型"></a>E-R模型</h3><p>可以使用E-R模型帮助分析问题和设计数据库，E表示<code>实体（Entity）</code>，R表示<code>关系（Relationship）</code>。</p>
<p>现实生活中物体可以标识为<code>实体</code>，如水果和出口目的地，<code>实体</code>间的交互称为<code>关系</code>，如我们将水果卖到出口目的地，“卖”就是<code>关系</code>。</p>
<p>有多种水果也有多个出口目的地，所以这个例子中的两个实体都代表多个对象，这个关系称为<code>多对多关系</code>。在<code>E-R模型</code>中实体的数量也需要被考虑。如果只将一种水果卖给多个地方，就为<code>一对多关系</code>。这种实体间对应的个数称为<code>基数(Cardinality)</code>。</p>
<h3 id="规范化表格"><a href="#规范化表格" class="headerlink" title="规范化表格"></a>规范化表格</h3><p>为了避免数据冲突（同一个数据在不同表中不一样，可能因为部分未更新而造成）而将表格拆分开的过程称为<code>规范化（Normalized）</code>。</p>
<ol>
<li><p><code>非范式（Unnormalized）</code>表格存在一个记录的一个字段存在多个数值，如<br> | 报表编码 | 日期 | 出口国编码 | 出口国名称 | 商品编码 | 商品名称 | 单价 | 数量 |<br> | ———— | —— | ————— | ————— | ———— | ———— | —— | —— |</p>
<p> 因为一次报表可以买多个商品，所以一个报表编码可以对应多个商品编码，因此该表为非范式表格。</p>
</li>
<li><p><code>第一范式（First Normal）</code>的表格满足一栏中只有一个项目，每一列都是不可分割的基本数据项。我们将上表拆分，可以得到第一范式表格，主要就是将商品编码与报表编码拆分。</p>
<p> | 报表编码 | 日期 | 出口国编码 | 出口国名称 |<br> | ———— | —— | ————— | ————— |</p>
<p> | 报表编码 | 商品编码 | 商品名称 | 单价 | 数量 |<br> | ———— | ———— | ———— | —— | —— |</p>
<p> 表一中，报表编码为主键<br> 表二中，报表编码和商品编码的<strong>组合</strong>为主键。并不是表示表二存在两个主键。</p>
</li>
<li><p>满足主键值可以确认其他列的表格称为<code>第二范式</code>表格。如果主键是多个字段的组合，那么其他列必须同时受这多个字段的控制。</p>
<p>本例中，如果关注<code>第一范式中</code>的表二，可以发现商品的名称和单价也存在与表格中，但实际上这两者只受<code>商品编码</code>控制（即使我们只知道<code>商品编码</code>，我们也能知道单价和名称），而表二的主键是<code>商品编码</code>和<code>报表编码</code>的组合，因此表二并不符合<code>第二范式</code>要求。我们可以将表二进行拆分。</p>
<p>表一保持不变<br>| 报表编码 | 日期 | 出口国编码 | 出口国名称 |<br>| ———— | —— | ————— | ————— |</p>
<p>表二拆分为<br>| 报表编码 | 商品编码 | 数量 |<br>| ———— | ———— | —— |</p>
<p>| 商品编码 | 商品名称 | 单价 |<br>| ———— | ———— | —— |</p>
<p>拆分出的第一个表，主键为<code>报表编码</code>和<code>商品编码</code>的组合。第二个表格，主键为<code>商品编码</code>。</p>
</li>
</ol>
<ol>
<li><p>满足主键值唯一确定其他列（即不存在间接性确认）的表格称为<code>第三范式</code>表格。</p>
<p> 在上面的表一中，存在间接性确认。<code>出口国名称</code>虽然受<code>报表编码</code>的控制，但实际上是出口国名称受<code>出口国编码</code>影响，出口国编码受<code>报表编码</code>控制。所以存在间接控制，不满足<code>第三范式</code>。</p>
<p> 因此将表一进行拆分为两个表格</p>
<p> | 报表编码 | 日期 | 出口国编码 |<br> | ———— | —— | ————— |</p>
<p> | 出口国编码 | 出口国名称 |<br> | ————— | ————— |</p>
<p> 表一的主键为报表编码，表二的主键为出口国编码。<br> 剩下的表格保持不变，即</p>
<p> | 报表编码 | 商品编码 | 数量 |<br> | ———— | ———— | —— |</p>
<p> | 商品编码 | 商品名称 | 单价 |<br> | ———— | ———— | —— |</p>
</li>
</ol>
<p>现在我们一共有四个表，表一中的<code>出口国编码</code>参照表二的主键<code>出口国编码</code>，表一与表二连接。同理表三中的<code>报表编码</code>参照表一的主键<code>报表编码</code>，表三与表一连接。表三中的<code>商品编码</code>参照表四的主键<code>商品编码</code>，表三与表四连接。</p>
<p>不同表格建立相互联系的键叫做<code>外键（Foreign Key）</code>，外键用来参照其他表格的主键。表一中的<code>出口国编码</code>，表三中的<code>报表编码</code>,<code>商品编码</code>，三者都是<code>外键</code>。</p>
<h3 id="设计数据库"><a href="#设计数据库" class="headerlink" title="设计数据库"></a>设计数据库</h3><p>设计数据库的步骤可以分为<code>概念模式</code>，<code>内部模式</code>,<code>外部模式</code>三部分</p>
<ol>
<li>概念模式：将现实世界模型化确认数据库理论结构的阶段。概念模式是通过E-R模型描述现实世界，并进一步规范化表格实现的。</li>
<li>内部模式：内部模式从计算机内部物理构造考虑，设计目的是让数据库可以被高速检索。</li>
<li>外部模式：外部模式是从用户和应用角度来考虑，设计目的是让用户和程序可以方便使用。</li>
</ol>
<div class="note info simple"><p>引用：</p>
<ol>
<li><em>The Manga Guide to Databases</em> 2009</li>
</ol>
</div>
<hr>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>《The Use of Digital Games to Teaching Computer Graphic》 笔记</title>
    <url>/TheUseofDigitalGamestoTeachingComputerGraphic-Notes/</url>
    <content><![CDATA[<p>这篇论文中，作者表达了希望可以通过游戏来帮助图形学教学，并探讨了以下几个问题：</p>
<ol>
<li>图形学课程的范畴</li>
<li>图形学不同教学方式</li>
<li>电子游戏对于高等教育的帮助</li>
<li>目前图形学课程中，交互式游戏的例子</li>
</ol>
<span id="more"></span>
<h1 id="The-Use-of-Digital-Games-to-Teaching-Computer-Graphics-an-Open-Opportunity"><a href="#The-Use-of-Digital-Games-to-Teaching-Computer-Graphics-an-Open-Opportunity" class="headerlink" title="The Use of Digital Games to Teaching Computer Graphics: an Open Opportunity"></a>The Use of Digital Games to Teaching Computer Graphics: an Open Opportunity</h1><div class="note info simple"><p>原文中有大量source作为例子，在这里不会将所有的被引用source的内容整理再次。</p>
<p>但会通过类似于<code>[2]</code>这样的标记，这个说明该部分内容在原文的第二篇引用中有详细说明。</p>
</div>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>3D空间想象的概念对于部分学生来说很难理解。</p>
<p>游戏和图形学都是需要可视化，而且都需要交互，所以这两者很匹配，有结合在一起的可能。</p>
<h2 id="The-Computer-Graphic-Curriculum"><a href="#The-Computer-Graphic-Curriculum" class="headerlink" title="The Computer Graphic Curriculum"></a>The Computer Graphic Curriculum</h2><blockquote>
<p>这一部分作者首先讨论了图形学的范畴，然后阐述了多年来图形学教学的变化。</p>
</blockquote>
<h3 id="The-Computer-Graphics-Knowledge-Base"><a href="#The-Computer-Graphics-Knowledge-Base" class="headerlink" title="The Computer Graphics Knowledge Base"></a>The Computer Graphics Knowledge Base</h3><p>在2006年的报告中，<em>ACM SIGGRAPH</em>将图形学分为了17个子领域<code>[1]</code>，如下所示：</p>
<p><img src="TheUseofDigitalGamestoTeachingComputerGraphic-Notes/2020-03-27-09-16-18.png" alt="图形学17个子领域"></p>
<h3 id="The-Modern-Computer-Graphics-Curriculum"><a href="#The-Modern-Computer-Graphics-Curriculum" class="headerlink" title="The Modern Computer Graphics Curriculum"></a>The Modern Computer Graphics Curriculum</h3><p>在1970-1980年代，受限于昂贵的图形学硬件，只有少数的大学提供了图形学课程。课程也大多局限在底层的硬件教学，基本渲染算法和3D模型的介绍。<br>在1980-1990年代，图形学硬件相对来说价格变得容易承受了一些。图形学课程变为了大学教育中的常见课程，课程关注底层算法，图形学硬件，数学，光照和颜色的原理和一些基本API的使用。<br>从1990倒现在，因为图形学硬件变得更便宜，和一些高标准的图形学库出现（OpenGL，Direct3D），图形学课程设计变为选择更好的软件工具来提升教学体验，目前主流的教学都是选择C/C++以及OpenGL库。<br>因为目前大多数较低层的算法和整个渲染处理都被结合进硬件层，所以课程的主题也发生了很大的变换。现在对于不同层次和目标的图形学学习者，通常会覆盖不同的主题。如对于计算机科学的学生，可能仍然需要关注于数学和一些底层的渲染知识。对于软件工程的学生，可能更多的是学习一些高层的编程框架。对于媒体的学生，则是关注于一些图形建模的商业软件等。</p>
<h3 id="Some-students-on-the-CG-syllabus"><a href="#Some-students-on-the-CG-syllabus" class="headerlink" title="Some students on the CG syllabus"></a>Some students on the CG syllabus</h3><blockquote>
<p>这里是作者总结了一些别人的关于图形学范畴大纲研究。</p>
</blockquote>
<p>第一份报告<code>[17]</code>是在1990年代后期发布的，这一份报告研究了美国23个大学的图形学研究范畴。关注度最高的主题包括，摄像机/观察者坐标变换，硬件，光照模型，3D变换，用户交互，物体表示，阴影模型，颜色模型，曲线，隐藏表面取出，光栅化（viewing/camera transformations, hardware,lighting models, 3D transformations, user interaction, object representation, shading models, color models, curves, hiddensurface removal, and rasterization）。</p>
<p>第二份报告是在2005年发表<code>[18]</code>，这一份报告研究了超过70个学术项目课程。发现许多的课程已经不仅仅局限在传统的3D图形范畴，更关注于图形学，图像处理，人机交互三个领域的结合，而且对于2D内容的关注也逐渐加深。</p>
<p>第三方报告是在2016年发表<code>[19]</code>，这一份报告选取了美国近400个关于图形学的课程研究。发现上述第一份报告中主要关注的主题，现在都出现在了教科书中。而且现在的课程开始关注于工业与学术的联系。这一份报告同时建议，之前的图形学17个子领域应该缩减为9个<code>[3]</code>：艺术设计，动画，数字成像，物理，视觉感知，可视化通信，数学，认知科学，计算机编程(Art and design, animation, digital imaging, physics, visual perception, visual communication, mathematics, cognitive sciences, and computer programming)。另外图形学课程必须强调多学科的结合，其基本框架应该是科学，技术和艺术原则的结合。</p>
<p>在2013年，<em>ACM</em>和<em>IEEE</em>还发布了一个关于计算机课程的指导文件<code>[20]</code>，其建议课程应该包含图形学的基本概念，基本与高级渲染，几何模型，动画和可视化，每一个学习了图形学课程的学生应该都有能力进行2D/3D的坐标转换，同时有对于3D渲染的基本了解。</p>
<h2 id="General-Approaches-To-Teaching-Computer-Graphics"><a href="#General-Approaches-To-Teaching-Computer-Graphics" class="headerlink" title="General Approaches To Teaching Computer Graphics"></a>General Approaches To Teaching Computer Graphics</h2><blockquote>
<p>这一部分作者总结了不同的图形学教学的方法</p>
</blockquote>
<p>目前图形学的教学方式可以分为以下六种：</p>
<p><img src="TheUseofDigitalGamestoTeachingComputerGraphic-Notes/2020-03-27-14-37-17.png" alt="图形学六种方式"></p>
<h3 id="Survey"><a href="#Survey" class="headerlink" title="Survey"></a>Survey</h3><p>调查法是提供一个对于图形学的笼统概念，而且并不提供编程相关的内容。</p>
<p>这一方法在图形学学科的初期被使用的较多，主要原因是当时并没有足够的软硬件进行其他的教学方式。</p>
<h3 id="Bottom-Up"><a href="#Bottom-Up" class="headerlink" title="Bottom-Up"></a>Bottom-Up</h3><p>自底向上法一开始学习一些最底层的算法，数学方法和其他的基本元素，然后逐渐的向更高层的知识学习。例如一开始学习如何画直线，如何画二维曲线，然后再一步步的变换为2D形状，3D形状。</p>
<p>很多经典的图形学书籍都是采用这个方法。</p>
<h3 id="Top-Down"><a href="#Top-Down" class="headerlink" title="Top-Down"></a>Top-Down</h3><p><code>[8]</code></p>
<p>自顶向下法一开始分析和实现一些图形学的软件，然后再逐渐的去了解其底层的知识。好比先学习如何开车，再学习汽车的构造等等。</p>
<p>这些年，大部分的教学都是通过自顶向下法。</p>
<p>自底向上法可能更适合于一些立志研究计算机科学的人，他们对底层的知识有更高的要求。而对于软件工程和艺术家而言，自顶向下法更为合适。</p>
<h3 id="Constructivist"><a href="#Constructivist" class="headerlink" title="Constructivist"></a>Constructivist</h3><p><code>[26]</code></p>
<p>建构法是老师不再为每个主题提供一个复杂的教学内容，而是去指引学生构建一个对于学科的概念知识。让学生可以通过对不同主题的教学内容进行可视化，实验，测试来得到知识。</p>
<h3 id="Breadth-First"><a href="#Breadth-First" class="headerlink" title="Breadth-First"></a>Breadth-First</h3><p><code>[27]</code></p>
<p>广度优先法类似于自顶向下法。只不过广度优先更强调跨学科的尝试，而自顶向下法仍然是针对不同专业的人，给他们特定的学习内容。</p>
<h3 id="Project-Based-Learning-PBL"><a href="#Project-Based-Learning-PBL" class="headerlink" title="Project-Based Learning(PBL)"></a>Project-Based Learning(PBL)</h3><p><code>[28]</code></p>
<p>基于项目的学习法是让学生通过解决特定问题或完成项目来学习知识。</p>
<p>这一方法成立的前提是目前C++，OpenGL等语言和库已经相对成熟，学生可以很快的搭建出一个软件的框架。</p>
<h2 id="Digital-Games-as-a-Leaning-Strategy-In-Higher-Education"><a href="#Digital-Games-as-a-Leaning-Strategy-In-Higher-Education" class="headerlink" title="Digital Games as a Leaning Strategy In Higher Education"></a>Digital Games as a Leaning Strategy In Higher Education</h2><blockquote>
<p>这一部分作者探讨了在高等教育中用电子游戏帮助学习的例子</p>
</blockquote>
<p>电子游戏可以可以提供一个沉浸式的学习体验，在许多的学科研究中也已经证明了电子游戏帮助学习的有效性<code>[34,35]</code>。</p>
<p>现在也有一系列通过游戏来帮助学生学习编程的例子<code>[36,37,38,39]</code>。</p>
<p>对于软件工程的学生而言，基于游戏学习可以再细分为两种类型，第一种是真正的用游戏来学习（Game-Based Leaning,GBL），另一种是基于游戏开发的学习（Game-Development-Based Learning，GDBL）<code>[43]</code></p>
<h2 id="The-Use-of-Digital-Games-and-Interactive-Simulators-to-Teaching-Computer-Graphics"><a href="#The-Use-of-Digital-Games-and-Interactive-Simulators-to-Teaching-Computer-Graphics" class="headerlink" title="The Use of Digital Games and Interactive Simulators to Teaching Computer Graphics"></a>The Use of Digital Games and Interactive Simulators to Teaching Computer Graphics</h2><blockquote>
<p>这一节作者针对说明了在图形学的教学中，用游戏和模拟方法来提升教学体验的例子</p>
</blockquote>
<p>对于图形学的教学，除了上述的两种游戏教学法（GBL和GDBL），还有一种提供交互的模拟方法（simulator）。这种方法严格意义上无法被称之为是游戏，但学生同样可以通过交互进行修改参数之类的操作，来实时进行实验和看到变化。</p>
<h3 id="GDBL-Approaches"><a href="#GDBL-Approaches" class="headerlink" title="GDBL Approaches"></a>GDBL Approaches</h3><p>这种方法是让学生通过开发一款游戏来了解图形学的知识。</p>
<p>主要的例子有<code>[44]</code>，其中老师开发了一款名为<code>GameX</code>的平台，学生在上面通过使用OpenGL和DirectX来进行开发游戏。而且他针对不同的学生，可以开放不同程度的API。</p>
<p>类似的还有<code>[45]</code>，一款名为<code>eNYyMyCar</code>的平台，其中学生可以共享和展示自己的开发成果。</p>
<p>还有`[46]也是一个实现，这个实现还结合了各种其他的游戏方面的知识。</p>
<h3 id="Interactive-Simulators"><a href="#Interactive-Simulators" class="headerlink" title="Interactive Simulators"></a>Interactive Simulators</h3><p>Simulator的例子有<code>[47,48,49,50,51,52]</code></p>
<p>这些例子都是通过让学生对某个主题的模拟程序进行交互，来查看效果。</p>
<h3 id="GBL-approaches"><a href="#GBL-approaches" class="headerlink" title="GBL approaches"></a>GBL approaches</h3><p><code>[54]</code>开发了一个网页游戏，学生通过解密学习知识。</p>
<p><code>[55]</code>一款2016年的游戏，学生要通过各种坐标变换来获得游戏要求的形状。</p>
<h2 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a>Discussion</h2><p>作者从1990年到2016年，一共找到了11个交互的图形学教学，其中5个是交互模拟，4个是GDBL，2个是GBL。</p>
<p>交互模拟是最早出现的，但是绝大部分都是出现在90年代，只有1个是在2000年早期。<br>GDBL都是使用类似于OpenGL，Direct3D这样的框架让学生进行开发游戏。<br>GBL很少，所以作者认为在GBL的方面，还能有很多工作进行开展。</p>
<div class="note info simple"><p>引用：</p>
<ol>
<li>González-Campos, J. S., Arnedo-Moreno, J., &amp; Sánchez-Navarro, J. (2018, April). The use of digital games to teaching computer graphics: An open opportunity. In 2018 IEEE Global Engineering Education Conference (EDUCON) (pp. 1988-1996). IEEE.</li>
</ol>
</div>
<hr>
]]></content>
      <categories>
        <category>论文笔记</category>
      </categories>
      <tags>
        <tag>论文笔记</tag>
        <tag>图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>《漫画数据库》 笔记 （二）</title>
    <url>/TheMangaGuideToDatabasesNotes-2/</url>
    <content><![CDATA[<p>《漫画数据库》 第四、五、六章笔记。</p>
<p>包括介绍SQL环境的配置，SQL语言的基本操作，事物的概念，数据库部分优化概念及分布式数据库。</p>
<span id="more"></span>
<h2 id="MySQL环境配置"><a href="#MySQL环境配置" class="headerlink" title="MySQL环境配置"></a>MySQL环境配置</h2><p>《漫画数据库》一书没有说明如何配置MYSQL环境，而在第四章中却开始说明一些SQL语句，这就导致读者没地方实践语句。</p>
<p>在这里先简单介绍如何配置MySQL环境，主要参考网上的<a href="http://www.mysqltutorial.org/">MySQL教程</a>。</p>
<ol>
<li><p>MySQL程序安装</p>
<p> Windows系统上可以直接安装<a href="https://dev.mysql.com/downloads/windows/installer/8.0.html">MySQL全家桶</a>来完成SQL环境的配置。</p>
<p> 安装过程基本傻瓜式，但需要注意在安装中有设置密码的步骤，这个密码在之后登陆服务器时会用到。</p>
<p> 安装过程并没有直接将<code>MySQL Server</code>添加到系统环境中，<code>MySQL Server</code>的安装地址默认在于<code>C:\Program Files\MySQL\MySQL Server 8.0\bin</code>，将这个地址默认添加到系统环境中即可，关于如何添加系统环境这里不赘述。</p>
</li>
<li><p>通过Shell连接MySQL</p>
<p> 配置完成后，可以通过命令<code>mysql -u &lt;userName&gt; -p</code>登陆Server，这里需要输入密码，密码即为安装过程中设置的那个。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PS C:\Users\wxj&gt; mysql -u root -p</span><br><span class="line">Enter password: *********                                                      Welcome to the MySQL monitor.  Commands end with ; or \g</span><br></pre></td></tr></table></figure>
<p> 可以使用命令 show databases来查看目前的数据库</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show databases;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sakila             |</span><br><span class="line">| sys                |</span><br><span class="line">| world              |</span><br><span class="line">+--------------------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li>
<li><p>通过MYSQL WorkBench连接MySQL</p>
<p><img src="TheMangaGuideToDatabasesNotes-2/2019-10-23-11-54-54.png" alt="workBench连接MySQL"></p>
<p>如图打开workBench后依次点击，操作分别是增加连接，设置连接名字（任取），设置密码，确认密码设置，确认连接设置。添加完成后效果如下图所示，</p>
<p><img src="TheMangaGuideToDatabasesNotes-2/2019-10-23-11-56-45.png" alt="添加连接后"></p>
<p>双击连接便能打开数据库界面。</p>
<p><img src="TheMangaGuideToDatabasesNotes-2/2019-10-23-11-58-30.png" alt="数据库界面"></p>
<p>注意红框处的数据库名称与我们通过shell所展现的是一样的。在右侧的Query窗口可以编写SQL语句</p>
</li>
<li><p>使用MySQL Workbench新建数据库</p>
<p>在SCHEMAS界面邮件，选择新建数据库，然后设置新数据名字并Apply即可</p>
<p><img src="TheMangaGuideToDatabasesNotes-2/2019-10-23-12-30-42.png" alt="新建数据库"></p>
<p>创建完成后，同样在SCHEMAS界面，双击新形成的数据库将他设置为默认的数据库即可。</p>
</li>
<li><p>执行SQL文件</p>
<p>在设置完默认的数据库后，运行的SQL文本会自动基于当前的数据库。可以只用快捷键<code>Ctrl+Shift+Enter</code>执行整个SQL文件的命令，或使用<code>CTRL+ENTER</code>执行当前语句的命令。</p>
</li>
</ol>
<h2 id="Chapter-4-Let-us-learn-about-SQL"><a href="#Chapter-4-Let-us-learn-about-SQL" class="headerlink" title="Chapter 4. Let us learn about SQL"></a>Chapter 4. Let us learn about SQL</h2><ol>
<li>数据定义语言（Data Definition Language，DDL）<br>用来创建、更改和删除表</li>
<li>数据操作语言（Data Manipulation Language，DML）<br>用来操作数据，如插入，更改，删除数据</li>
<li>数据控制语言（Data Control Language，DCL）<br>用来控制数据库，如保护多人同时使用数据库也不会有冲突</li>
</ol>
<p>SQL的<code>命令(Statement)</code>是由<code>短语(Phrase)</code>组成的，如<code>SELECT</code>,<code>WHERE</code>都为短语。</p>
<h3 id="创建表格"><a href="#创建表格" class="headerlink" title="创建表格"></a>创建表格</h3><p>使用短语<code>CREATE TABLE</code>创建表格</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>TableName<span class="operator">&gt;</span></span><br><span class="line">(</span><br><span class="line">    <span class="operator">&lt;</span>FieldName<span class="operator">&gt;</span> <span class="operator">&lt;</span>FieldType<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY(<span class="operator">&lt;</span>FieldName<span class="operator">&gt;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">如</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> `SALES_TABLE`</span><br><span class="line">(</span><br><span class="line">`REPORT_CODE` <span class="type">int</span> <span class="keyword">Not</span> <span class="keyword">NULL</span>,</span><br><span class="line">`EXPORT_DATE` <span class="type">date</span>,</span><br><span class="line">`EXPORT_DESTINATION_CODE` <span class="type">int</span>,</span><br><span class="line"></span><br><span class="line"><span class="keyword">primary</span> key(REPORT_CODE) <span class="comment">-- set primary Key</span></span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用短语<code>ALTER</code>修改表格</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>TableName<span class="operator">&gt;</span></span><br><span class="line"><span class="operator">&lt;</span>Phrase<span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 为product_table 表格增加DISTRICT列，且让他排在`UNIT_PRICE`后</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> product_table</span><br><span class="line"><span class="keyword">add</span> <span class="keyword">column</span> `DISTRICT`  <span class="type">VARCHAR</span>(<span class="number">45</span>) <span class="keyword">null</span></span><br><span class="line">after `UNIT_PRICE`;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="表格添加及删除数据"><a href="#表格添加及删除数据" class="headerlink" title="表格添加及删除数据"></a>表格添加及删除数据</h3><p>使用短语<code>Insert into</code>及<code>values</code>来添加数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="operator">&lt;</span>TableName<span class="operator">&gt;</span>(<span class="operator">&lt;</span>FieldName1<span class="operator">&gt;</span>,<span class="operator">&lt;</span>FieldName2<span class="operator">&gt;</span>)</span><br><span class="line"><span class="keyword">values</span></span><br><span class="line">    (<span class="operator">&lt;</span>Field1Data<span class="operator">&gt;</span>,<span class="operator">&lt;</span>Field2Data<span class="operator">&gt;</span>),</span><br><span class="line">    (<span class="operator">&lt;</span>Field1Data<span class="operator">&gt;</span>,<span class="operator">&lt;</span>Field2Data<span class="operator">&gt;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span></span><br><span class="line">	sales_table(REPORT_CODE,EXPORT_DATE,EXPORT_DESTINATION_CODE)</span><br><span class="line"><span class="keyword">values</span></span><br><span class="line">	(<span class="number">1101</span>,<span class="string">&#x27;2019-03-05&#x27;</span>,<span class="number">12</span>),</span><br><span class="line">    (<span class="number">1102</span>,<span class="string">&#x27;2019-03-07&#x27;</span>,<span class="number">23</span>),</span><br><span class="line">    (<span class="number">1103</span>,<span class="string">&#x27;2019-03-08&#x27;</span>,<span class="number">25</span>),</span><br><span class="line">    (<span class="number">1104</span>,<span class="string">&#x27;2019-03-10&#x27;</span>,<span class="number">12</span>),</span><br><span class="line">    (<span class="number">1105</span>,<span class="string">&#x27;2019-03-12&#x27;</span>,<span class="number">25</span>);</span><br></pre></td></tr></table></figure>
<p>使用<code>delete from</code>及<code>where</code>短语删除数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="operator">&lt;</span>TableName<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">where</span> <span class="operator">&lt;</span>condtion<span class="operator">&gt;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> product_table</span><br><span class="line"><span class="keyword">where</span> PRODUCT_CODE<span class="operator">=</span><span class="number">101</span>;</span><br></pre></td></tr></table></figure>
<p>使用<code>update</code>,<code>set</code>,<code>where</code>更新数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="operator">&lt;</span>tableName<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">set</span> <span class="operator">&lt;</span>FieldName<span class="operator">&gt;=</span><span class="operator">&lt;</span>FieldData<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">where</span> <span class="operator">&lt;</span><span class="keyword">Condition</span><span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如</span></span><br><span class="line"><span class="keyword">update</span> product_table <span class="keyword">set</span> DISTRICT<span class="operator">=</span><span class="string">&#x27;South Sea&#x27;</span> <span class="keyword">where</span> PRODUCT_CODE<span class="operator">=</span><span class="number">101</span> <span class="keyword">or</span> PRODUCT_CODE<span class="operator">=</span><span class="number">104</span>;</span><br><span class="line"><span class="keyword">update</span> product_table <span class="keyword">set</span> DISTRICT<span class="operator">=</span><span class="string">&#x27;Middle&#x27;</span> <span class="keyword">where</span> PRODUCT_CODE<span class="operator">=</span><span class="number">102</span>;</span><br><span class="line"><span class="keyword">update</span> product_table <span class="keyword">set</span> DISTRICT<span class="operator">=</span><span class="string">&#x27;North Sea&#x27;</span> <span class="keyword">where</span> PRODUCT_CODE<span class="operator">=</span><span class="number">103</span>;</span><br></pre></td></tr></table></figure>
<h3 id="查看数据"><a href="#查看数据" class="headerlink" title="查看数据"></a>查看数据</h3><p>使用短语<code>SELECT FROM</code>，<code>WHERE</code>，以及<code>比较运算符</code>,<code>关系运算符</code>以及<code>通配符</code>来选择数据，SQL支持的比较运算符和关系运算符如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>比较运算符</th>
<th>含义</th>
<th>关系运算符</th>
<th>含义</th>
<th>通配符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>A = B</td>
<td>A等于B</td>
<td>AND</td>
<td>与</td>
<td>*</td>
<td>匹配任意长度的任意字符</td>
</tr>
<tr>
<td>A &gt; B</td>
<td>A大于B</td>
<td>OR</td>
<td>或</td>
<td>-</td>
<td>匹配长度为1的任意字符</td>
</tr>
<tr>
<td>A &gt;= B</td>
<td>A大于等于B</td>
<td>NOT</td>
<td>非</td>
<td></td>
<td></td>
</tr>
<tr>
<td>A &lt; B</td>
<td>A小于B</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>A &lt;= B</td>
<td>A小于等于B</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>语句形式如下<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">&lt;</span>FieldName<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">from</span> <span class="operator">&lt;</span>TableName<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">where</span> <span class="operator">&lt;</span><span class="keyword">condition</span><span class="operator">&gt;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如搜索数量大于1000的产品,且显示表中所有数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sales_statement_table</span><br><span class="line"><span class="keyword">where</span> QUANTITY<span class="operator">&gt;</span><span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 这里使用了*来表示所有数据，如果我们仅想显示一个PRODUCT_CODE</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> PRODUCT_CODE <span class="keyword">from</span> sales_statement_table</span><br><span class="line"><span class="keyword">where</span> QUANTITY<span class="operator">&gt;</span><span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 取所有产品名以n结尾的产品</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product_table</span><br><span class="line"><span class="keyword">where</span> PRODUCT_NAME <span class="keyword">like</span> <span class="string">&#x27;%n&#x27;</span>;</span><br></pre></td></tr></table></figure></p>
<p>SQL还自带了一些函数帮助计算，如求最大值，求行数等</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>COUNT(*)</td>
<td>求行数</td>
</tr>
<tr>
<td>COUNT(<code>FieldName</code>)</td>
<td>求非空值行的行数</td>
</tr>
<tr>
<td>COUNT( Distinct <code>FieldName</code>)</td>
<td>求除了空值和重复值的行数</td>
</tr>
<tr>
<td>SUM(<code>FieldName</code>)</td>
<td>求各行总和</td>
</tr>
<tr>
<td>AVG(<code>FieldName</code>)</td>
<td>求各行平均</td>
</tr>
<tr>
<td>MAX(<code>FieldName</code>)</td>
<td>求各行最大</td>
</tr>
<tr>
<td>MIN(<code>FieldName</code>)</td>
<td>求各行最小</td>
</tr>
</tbody>
</table>
</div>
<p>如<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">-- 求一共有几个数量大于1000的销售产品</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">from</span> sales_statement_table</span><br><span class="line"><span class="keyword">where</span> QUANTITY<span class="operator">&gt;</span><span class="number">1000</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="分组计算"><a href="#分组计算" class="headerlink" title="分组计算"></a>分组计算</h3><p>使用短语<code>group by</code>进行分组</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">&lt;</span>FieldName<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">from</span> <span class="operator">&lt;</span>TableName<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="operator">&lt;</span>FieldName<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>
<p>如有列表<br>| PRODUCT_CODE | PRODUCT_NAME | UNIT_PRICE | DISTRICT  |<br>| —————— | —————— | ————— | ————- |<br>| 101          | MELON        | 800        | South Sea |<br>| 102          | STRAWBERRY   | 150        | Middle    |<br>| 103          | APPLE        | 120        | North Sea |<br>| 104          | LEMON        | 200        | South Sea |<br>| 201          | Chestnut     | 100        | North Sea |<br>| 202          | Persimmon    | 160        | Middle    |<br>| 301          | Peach        | 130        | South Sea |<br>| 302          | Kiwi         | 200        | South Sea |</p>
<p>想通过DISTRICT进行分组，可以使用</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> DISTRICT,<span class="built_in">AVG</span>(UNIT_PRICE),UNIT_PRICE</span><br><span class="line"><span class="keyword">from</span> product_table</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> DISTRICT;</span><br></pre></td></tr></table></figure>
<p>这里选择的是分组完后价格的平均值，输出结果为<br>| DISTRICT  | AVG(UNIT_PRICE) | UNIT_PRICE |<br>| ————- | ———————- | ————— |<br>| South Sea | 332.5           | 800        |<br>| Middle    | 155             | 150        |<br>| North Sea | 110             | 120        |</p>
<p>因为表的一项只能显示一个数值，所以在分组后的<code>UNIT_PRICE</code>项，只能显示这个分组的第一个数值。</p>
<p>分组完后的数据如果需要筛选，应该使用短语<code>having</code>而非<code>where</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> DISTRICT,<span class="built_in">AVG</span>(UNIT_PRICE),UNIT_PRICE</span><br><span class="line"><span class="keyword">from</span> product_table</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> DISTRICT</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">AVG</span>(UNIT_PRICE)<span class="operator">&gt;=</span><span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> DISTRICT,<span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">from</span> product_table</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> DISTRICT</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>)<span class="operator">&gt;=</span><span class="number">3</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果为<br>| DISTRICT  | AVG(UNIT_PRICE) | UNIT_PRICE |<br>| ————- | ———————- | ————— |<br>| South Sea | 332.5           | 800        |</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>DISTRICT</th>
<th>COUNT(*)</th>
</tr>
</thead>
<tbody>
<tr>
<td>South Sea</td>
<td>4</td>
</tr>
</tbody>
</table>
</div>
<h3 id="使用子查询检索"><a href="#使用子查询检索" class="headerlink" title="使用子查询检索"></a>使用子查询检索</h3><p>例如我们需要打印出销售额大于1000的产品名称，销售额是在销售表中，产品名称是在产品表中，这时就需要用到子查询。先重销售表中查询处满足条件的记录，再基于得到的记录查询名称。<code>子查询(Subquery)</code>使用短语<code>In</code>即可，这里是相当于先运行了括号内的内容，再执行外部的查询。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product_table</span><br><span class="line"><span class="keyword">where</span> PRODUCT_CODE <span class="keyword">IN</span></span><br><span class="line">(<span class="keyword">select</span> PRODUCT_CODE <span class="keyword">from</span> sales_statement_table</span><br><span class="line"><span class="keyword">where</span> QUANTITY<span class="operator">&gt;=</span><span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>另外还有<code>相关子查询(CORRELATED SUBQUERY)</code>，相关子查询最大的区别是先运行括号外的内容，再将结果一条条传递给括号内的查询，如</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sales_statement_table U</span><br><span class="line"><span class="keyword">where</span> QUANTITY <span class="operator">&gt;</span></span><br><span class="line">(</span><br><span class="line">	<span class="keyword">select</span> <span class="built_in">avg</span>(QUANTITY)</span><br><span class="line">    <span class="keyword">from</span> sales_statement_table</span><br><span class="line">    <span class="keyword">where</span> PRODUCT_CODE<span class="operator">=</span>U.PRODUCT_CODE</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>这里将外部查询的表<code>sales_statement_table</code>命名为U，并将查询的结果传递给内部查询。例如<code>sales_statement_table</code>表中的第一个元素的PRODUCT_CODE为101，那么实际上在第一次运行时，内部查询相当于</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(QUANTITY)</span><br><span class="line">   <span class="keyword">from</span> sales_statement_table</span><br><span class="line">   <span class="keyword">where</span> PRODUCT_CODE<span class="operator">=</span><span class="number">101</span></span><br></pre></td></tr></table></figure>
<p>得到结果后，再将结果（这里是平均值）传递给外部查询。这个相关子查询的工作是找出订单产品销售额大于该产品平均销售额的订单。</p>
<h3 id="制作视图"><a href="#制作视图" class="headerlink" title="制作视图"></a>制作视图</h3><p><code>视图(View)</code>相当于是一个虚拟表，它仅是用来被用户查看。生成视图的表成为<code>基表(Base table)</code>，使用短语<code>Create view</code>创建</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> <span class="operator">&lt;</span>ViewName<span class="operator">&gt;</span>(<span class="operator">&lt;</span>ViewField<span class="operator">&gt;</span>) <span class="comment">-- 如果Field完全与BaseTable一样，可忽略</span></span><br><span class="line"><span class="keyword">as</span> <span class="keyword">select</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> <span class="operator">&lt;</span>BaseTableName<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">where</span> <span class="operator">&lt;</span><span class="keyword">Condition</span><span class="operator">&gt;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> expensive_product_table</span><br><span class="line"><span class="keyword">as</span> <span class="keyword">select</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> product_table</span><br><span class="line"><span class="keyword">where</span> UNIT_PRICE<span class="operator">&gt;=</span><span class="number">200</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="删除视图与表"><a href="#删除视图与表" class="headerlink" title="删除视图与表"></a>删除视图与表</h3><p>使用短语<code>drop</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> <span class="operator">&lt;</span>ViewName<span class="operator">&gt;</span>;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="operator">&lt;</span>TableName<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure>
<h2 id="Chapter-5-Let-us-operate-a-databases"><a href="#Chapter-5-Let-us-operate-a-databases" class="headerlink" title="Chapter 5. Let us operate a databases"></a>Chapter 5. Let us operate a databases</h2><h3 id="事物"><a href="#事物" class="headerlink" title="事物"></a>事物</h3><p>用户的一系列成功操作成为<code>事物(Transaction)</code>。数据库必须保证即使多个事物同时执行，也不会发生矛盾，和即使事物处理过程中发生了意外，数据也不允许发生矛盾。数据库事物通过具有<code>ACID</code>属性来保证不会产生数据矛盾。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>A（Atomicity），原子性</td>
<td>事物必须结束于提交或回滚</td>
</tr>
<tr>
<td>C（Consistency），一致性</td>
<td>执行数据库事物时不能损坏数据库的一致性</td>
</tr>
<tr>
<td>I（Isolation），隔离性</td>
<td>多个事物的执行时互不干扰的</td>
</tr>
<tr>
<td>D（Durability），持久性</td>
<td>事物完成后，事物对于数据的更改会持久的保留在数据库中</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li><p>Atomicity，原子性</p>
<p>事物必须以<code>提交(Commit)</code>或者<code>回滚(Rollback)</code>作为结束，提交是确定数据库事物的处理，回滚是取消事物处理的指令。提交和回滚是自动执行，但也能通过命令<code>COMMIT</code>和<code>ROLLBACK</code>来显示执行。</p>
</li>
<li><p>Consistency，一致性</p>
<p>如描述，数据库需要保证不会损坏数据库数据的一致性</p>
</li>
<li><p>Isolation，隔离性</p>
<p>如果多个事物同时执行并返回了同样的结果，将这一些列事物称为<code>安排（Schedule）</code>，并称这些安排是<code>可序列化(Serializable)</code>的。事物的隔离性要求安排必须是可序列化的。</p>
<p>通常我们使用<code>锁(Lock)</code>来满足可序列化，锁又分为<code>共享锁(shared lock)</code>和<code>独占锁(exclusive lock)</code>，前者是读取数据时使用，后者是写入数据时使用。使用共享锁时，其他事务可以假设共享锁，但是不能加设独占锁。使用独占锁时，其他事务不能加设任何锁。</p>
<p>为了确保事务可以序列化，需要遵守一定的规则，规则其中一项就是<code>两阶段封锁(two-phase locking)</code>（书中未做详细解释）。</p>
<p> 另外还需要注意锁的<code>粒度(Granularity)</code>。粒度越大表示锁控制的数据就越大，这样一个事务设锁的次数会减少可以减少CPU负担，但是因为加锁的数据大，导致等等的对象会增多且等待时间上，所以同时可以执行的事务就减少了。反之同理。</p>
<p> 除了加锁外，还有其他的控制方法。如<code>时间戳控制(Timestamp control)</code>和<code>乐观控制(Optimistic control)</code>。</p>
<pre><code> （1） 时间戳控制是在执行一个事务时指定一个时间戳，当有另一个事务以更新的时间戳更新数据时，之前时间戳的事务将会被静止并回滚。

 （2） 乐观控制允许读操作，而在写操作时会检查是否有其他的事务已经更新了数据，如果有回滚该操作。
</code></pre><p> 在实际运用中，实际上可以设定<code>隔离等级(Levels of islation)</code>,隔离等级分为四个,<code>READ UNCOMMITTED</code>，<code>READ COMMITEED</code>,<code>REPEATABLE READ</code>,<code>SERIALIZABLE</code>,默认为<code>SERIALIZABLE</code>。</p>
<p> 根据隔离等级的不同，可能发生以下现象</p>
<p> |                  | 脏读     | 非重复读 | 虚读     |<br> | ———————— | ———— | ———— | ———— |<br> | READ UNCOMMITTED | 可能发生 | 可能发生 | 可能发生 |<br> | READ COMMITEED   | 不发生   | 可能发生 | 可能发生 |<br> | REPEATABLE READ  | 不发生   | 不发生   | 可能发生 |<br> | SERIALIZABLE     | 不发生   | 不发生   | 不发生   |</p>
<p> <code>脏读（Dirty Read）</code>表示在事物1提交前，事物2就读取了某数据。</p>
<p> <code>非重复读(Non-repeatable Read)</code>表示一个事务重复读取了两次数据，然后得到了不一样的值。可能原因就是其他的事务并行的更新了数值。</p>
<p> <code>虚读（Phantom Read）</code>表示一个事务搜索匹配某模式的数据时返回了错误值但是因为其他的事务在并行的更新数据，所以搜索到了错误数据。</p>
</li>
<li><p>持久性（Durability）</p>
<p>可以使用命令<code>GRANT</code>指定用户访问数据库或者表的权限,被授权的用户也可以附带<code>WITH GRANT OTION</code>信息来给其他用户权限，在取消某用户权限时，可以使用<code>REVOKE</code>。可设定的权限包括<code>SELECT</code>,<code>INSERT</code>,<code>UPDATE</code>,<code>DELETE</code>,<code>ALL</code>。</p>
<p>另外可以使用视图来管理权限，如将表格中的一部分数据生成视图，然后针对视图给用户权限。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="operator">&lt;</span>Privileges<span class="operator">&gt;</span> <span class="keyword">ON</span> <span class="operator">&lt;</span>TableName <span class="keyword">or</span> viewName<span class="operator">&gt;</span> <span class="keyword">TO</span> <span class="operator">&lt;</span><span class="keyword">User</span><span class="operator">&gt;</span> (<span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION);</span><br><span class="line"></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>,<span class="keyword">UPDATE</span> <span class="keyword">ON</span> product_table <span class="keyword">TO</span> business_department;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>,<span class="keyword">UPDATE</span> <span class="keyword">ON</span> product_table <span class="keyword">TO</span> overseas_business_department <span class="keyword">with</span> <span class="keyword">grant</span> option;</span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span>,<span class="keyword">UPDATE</span> <span class="keyword">ON</span> product_table <span class="keyword">FROM</span> business_department;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>数据库必须包含某种机制来保证意外发生时数据仍然正确。可能的意外包括</p>
<ol>
<li><p>事务错误（Transaction failure）</p>
<p>当事务错误发生时，事务将无法被提交，将会进行回滚处理。</p>
</li>
<li><p>系统错误（System failure）</p>
<p>如发生断电等情况，将发生系统错误，在系统重启后，未提交的事务将会被<code>回滚(Roll backward)</code>，已经提交的事务将会进行<code>前滚（Roll forward）</code>。</p>
<p>这里已经被提交的事务限定在上一个<code>检查点(CheckPoints)</code>后的提交。检查点的生成与缓存数据相关，在数据库写入数据时会被短暂的存储在缓存中，当缓存内的数据和数据库同步后，将会生成一个检查点。</p>
</li>
<li><p>介质错误（Media failure）</p>
<p>包含数据的硬盘发生损坏时称为介质错误。在这种情况下，将会恢复备份数据且在备份数据生效后，事务将会被前滚。</p>
</li>
</ol>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>当数据库非常庞大时，搜索特定数据可能会需要花费很长的时间，这时候就需要用到<code>索引(Indexes)</code>。索引有两种方式，<code>B树</code>和<code>散列（Hash）</code>。</p>
<ol>
<li><p>B树<br>B树相当于用树形结构来存储数据，每个节点都是经过了排序的，每个父节点都包含了子节点中最大值和最小值的信息，这样就可以加快节点的搜索。</p>
</li>
<li><p>散列</p>
<p>散列通过一个散列函数来求得数据的存储地址，但散列只适用于完全一致的搜索，如<code>找寻编码为101的数据</code>，而类似<code>找寻值大于XX</code> 这样的搜索就不匹配。</p>
</li>
</ol>
<h3 id="搜索优化"><a href="#搜索优化" class="headerlink" title="搜索优化"></a>搜索优化</h3><p>如存在一个搜索命令</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> dates,product_name</span><br><span class="line"><span class="keyword">FROM</span> product,sales</span><br><span class="line"><span class="keyword">WHERE</span> unit_price <span class="operator">&gt;=</span> <span class="number">200</span></span><br><span class="line"><span class="keyword">AND</span> product.product_code <span class="operator">=</span> sales.product_code</span><br></pre></td></tr></table></figure>
<p>这个操作可以看作由三个步骤组成</p>
<ol>
<li>将产品表和销售表两个表组合在一起</li>
<li>找出单价大于200的产品</li>
<li>抽出日期和产品名两列</li>
</ol>
<p>但这样的三个步骤可以有两种排列方式（1）按上述的步骤进行执行（2）先在两个表中各自抽出相关列，然后在产品表中找出满足条件的产品，然后在将两列结合在一起。</p>
<p>第二种方式有更高的效率，因为先抽取了列然后选择可以减少最后合并的工作量。</p>
<p>通常数据库的操作按照，先选择，在投影，最后合并的操作顺序，这样可以减少相关的工作量。</p>
<h4 id="合并操作优化"><a href="#合并操作优化" class="headerlink" title="合并操作优化"></a>合并操作优化</h4><p>对于合并操作来说，也有三种合并实现方式</p>
<ol>
<li><p>嵌套循环</p>
<p>即先从需要合并的表一找出需要合并的一行，然后遍历搜寻表二中符合的行。然后在表一中寻找需要合并的下一行</p>
</li>
<li><p>排序合并</p>
<p>即先对两个表各自排序，然后再合并。因为排序后两个表都可以按照一个顺序来合并，所以会提升效率。但需要考虑排序的时间。</p>
</li>
<li><p>散列</p>
<p>即通过散列函数快速的找到需要合并的两个表匹配的数据。</p>
</li>
</ol>
<h4 id="优化原则"><a href="#优化原则" class="headerlink" title="优化原则"></a>优化原则</h4><ol>
<li><p>规则导向</p>
<p>因为对于一个操作，可以有不同的执行顺序但能获取一样的结果。所以可以预先多个规则来指定步骤的执行顺序，如之前的<code>先选择，在投影,最后合并</code>就是一个规则。</p>
</li>
<li><p>成本导向</p>
<p>成本导向是根据数据库内的统计数据，再根据这些数据来选择优化的方式。成本导向相对于规则导向更灵活，但需要定期生成统计数据，统计数据的生成和分析都需要花费额外的时间。</p>
</li>
</ol>
<h2 id="Chapter-6-Databases-are-everywhere"><a href="#Chapter-6-Databases-are-everywhere" class="headerlink" title="Chapter 6. Databases are everywhere"></a>Chapter 6. Databases are everywhere</h2><h3 id="网络与数据库"><a href="#网络与数据库" class="headerlink" title="网络与数据库"></a>网络与数据库</h3><p>当网页与数据库一起工作时，整个系统由三层组成，称为三层客户端服务器(threetier client/server system)，包括<code>表示层(presentation layer)</code>，<code>逻辑层(logic layer)</code>和<code>数据层(data layer)</code>。</p>
<ol>
<li><p>表示层</p>
<p>表示层接受用户输入，并会显示数据库检索结果。</p>
</li>
<li><p>逻辑层</p>
<p>逻辑层对SQL命令进整合，对数据进行加工</p>
</li>
<li><p>数据层</p>
<p>数据层由数据库服务器处理，对数据库进行查询，并返回检索结果。</p>
</li>
</ol>
<h3 id="使用存储程序"><a href="#使用存储程序" class="headerlink" title="使用存储程序"></a>使用存储程序</h3><p>为了避免网络的数据传输，数据库有存储程序，可以存储一些高频的SQL查询命令。有三种存储程序，<code>存储过程（Stored procedure）</code>，<code>存储功能(Stored function)</code>和<code>触发器（Trigger）</code>。分别用来，存储没有返回值的才做，存储拥有返回值的操作，和在操作完成后自动存储。</p>
<h3 id="分布式数据库"><a href="#分布式数据库" class="headerlink" title="分布式数据库"></a>分布式数据库</h3><p>数据库本身可以被分散到不同的地点而通过网络相连接。尽管数据库被分散了，但是用户仍然可以把它当作一个数据库来进行处理。</p>
<p>数据库可分为<code>水平分布</code>和<code>垂直分布</code>两种，前者指的是使用多个同级别的数据库服务器的存储方式，这些服务器各自可以使用别的服务器的数据。后者指的是每个数据库服务器具有不同功能的分布方式，由承担主要任务的主服务器和承担其他处理任务的服务器构成。</p>
<p>分布式数据库的数据也必然是由各数据库服务器各自存储，而数据的分配方式也同样分为<code>水平分配</code>和<code>垂直分配</code>两种。水平分配指的是不同的服务器各自存储表的不同行（记录），而垂直分配则是不同的服务器各自存储表的不同列（字段）。</p>
<p>为了避免不同的数据库服务器同时操作而导致数据冲突，分布式数据库采用名为<code>两阶段提交(two-phase commit)</code>的方法。</p>
<p>两阶段提交包括有<code>协调者(coordinator)</code>和<code>参与者(participant)</code>且由两个阶段组成</p>
<ol>
<li><p>第一个阶段由协调者询问各参与者是否可以提交事物</p>
</li>
<li><p>第二阶段是协调者根据参与者返回的结论，进行相关操作，如果所有参与者都返回可以提交，则进行提交，反之有任何一个参与者拒绝了提交，则回滚事物。</p>
</li>
</ol>
<p>下图分别为成功提交和失败提交的例子。</p>
<p><img src="TheMangaGuideToDatabasesNotes-2/2019-10-25-01-25-02.png" alt="提交成功"><br><img src="TheMangaGuideToDatabasesNotes-2/2019-10-25-01-25-17.png" alt="提交失败"></p>
<h3 id="数据库复制"><a href="#数据库复制" class="headerlink" title="数据库复制"></a>数据库复制</h3><p>在分布式数据库中为了减少网络的负载，数据库设置了复制功能。我们将主要的数据库服务器称为<code>主数据库(Primary database)</code>，以及存有复制数据的服务器成为<code>复制数据库(replica)</code>。</p>
<p>复制数据库分为<code>读取专用</code>和<code>可更新</code>两种，前者复制服务器仅能读取主数据库的信息，后者可以对数据进行修改并且同步给主数据库以及其他数据库。</p>
<div class="note info simple"><p>引用：</p>
<ol>
<li><em>The Manga Guide to Databases</em> 2009</li>
</ol>
</div>
<hr>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>V2Ray  翻墙教程</title>
    <url>/V2RayTutorial/</url>
    <content><![CDATA[<p>简单介绍V2Ray以及如何通过V2Ray搭建梯子。</p>
<span id="more"></span>
<p>SS及SSR因为其易用性和使用人数的广泛，已经逐渐被GFW识别。但最近我和我的朋友搭建的SSR都相继因为IP被禁而无法使用。我可以理解而且在一定程度上也是支持GFW的存在，但在一些情况下也不得不需要绕过GFW来找寻一些工作中需要的资料。这篇教程也是为那些同样有迫切需要的人而写，技术无罪，但切不可利用技术行恶。</p>
<h2 id="V2Ray概述"><a href="#V2Ray概述" class="headerlink" title="V2Ray概述"></a>V2Ray概述</h2><p><code>V2Ray</code>是<code>ProjectV</code>下的一个工具。<code>ProjectV</code>是一个帮助打造专属基础网络通信的工具集合，<code>V2Ray</code>是其中最核心的一个工具，主要负责网络协议和功能的实现，目前最多的使用场景就是使用特殊的网络协议来绕开GFW的深度包检测进而实现翻墙的目的。</p>
<h2 id="V2Ray搭建"><a href="#V2Ray搭建" class="headerlink" title="V2Ray搭建"></a>V2Ray搭建</h2><h3 id="V2Ray服务端安装"><a href="#V2Ray服务端安装" class="headerlink" title="V2Ray服务端安装"></a>V2Ray服务端安装</h3><p>使用<code>V2Ray</code>搭梯子同样需要购买VPS及使用<code>SSH</code>登录VPS进行配置，这一部分在之前的<code>ShadowsocksR 翻墙教程</code>已经做了说明，这里就不重复介绍了。需要注意的一点是，为了避免安装过程中出现<code>command not found</code>等问题，建议使用<code>Debian 8.x</code>以上或<code>Ubantu 16.04</code>以上的版本操作系统，我个人使用的是<code>Ubuntu 18.04 x86_64</code>操作系统。</p>
<blockquote>
<p>如果出现<code>SSH</code>无法登录购买的VPS服务器，可能是VPS的IP被封，可以通过网址<code>ping.pe</code>进行检测，在输入要检测的VPSIP地址后，该网站可以从全球不同的节点去访问该地址，如果国内的节点丢包率都在100%，则说明该IP已经被封。如果是在搬瓦工上购买的VPS，可以在<code>https://bwh88.net/ipchange.php</code>网站上进行付费的更换IP服务，目前价格是8美元左右。</p>
<p>在windows环境下因为WSL的加入，可以不下载XShell直接进行连接，使用命令 <code>ssh root@&lt;ip&gt; -p &lt;port&gt;</code>即可</p>
</blockquote>
<p>因为<code>V2Ray</code>的验证方式包含时间，客户端及服务端的时间误差必须在90秒内，这个时间误差是考虑了时区问题的，比如客户端位于东八区，时间为23点20分，服务端位于西四区，时间为11点20分，虽然绝对时间不同，但是这是因为时区造成的，实际两者不存在误差，即可以正常运行。</p>
<p>在成功通过SSH连接到VPS后可以通过<code>date -R</code>命令检查服务端（VPS）的时间及时区，如果结果存在问题，可以使用<code>date --set</code>命令来修改时间，如<code>sudo date --set=&quot;2017-01-22 16:16:23&quot;</code>。</p>
<p>客户端的时间即为终端电脑或手机的时间，这里就不说明修改时间的方式了。</p>
<p>检查完时间后，通过运行<code>wget https://install.direct/go.sh</code>命令下载<code>V2Ray</code>安装脚本。</p>
<p><img src="V2RayTutorial/2019-06-13-22-53-21.png" alt="下载脚本"></p>
<p>下载完成后，通过命令<code>sudo bash go.sh</code>运行脚本</p>
<p><img src="V2RayTutorial/2019-06-13-23-08-07.png" alt="安装结果"></p>
<p>安装后会有如上图的结果，其中<code>PORT</code>和<code>UUID</code>两项（即图中马赛克部分）需要记录下来，在之后客户端的配置中需要用到。</p>
<p>在安装后,<code>V2Ray</code>并不会自动启动，我们还需要通过命令<code>sudo systemctl start v2ray</code>手动启动<code>V2Ray</code>。如果运行语句后无任何信息输出及表面<code>v2ray</code>启动成功。</p>
<p>如果以后需要更新<code>V2Ray</code>，再次运行安装命令<code>sudo bash go.sh</code>即可，这样会在保留配置文件的情况下更新<code>V2Ray</code>并重新启动。</p>
<p>可以使用命令<code>cat /etc/v2ray/config.json</code>来查看服务器端<code>V2Ray</code>的配置，后续章节会说明<code>V2Ray</code>的配置文件。</p>
<h3 id="V2Ray服务器加速"><a href="#V2Ray服务器加速" class="headerlink" title="V2Ray服务器加速"></a>V2Ray服务器加速</h3><p>安装了服务器后可安装锐速加速算法：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">wget –N —no–check–certificate https://raw.githubusercontent.com/91yun/serverspeeder/master/serverspeeder-all.sh &amp;&amp; bash serverspeeder-all.sh</span><br></pre></td></tr></table></figure>
<h3 id="V2Ray客户端安装"><a href="#V2Ray客户端安装" class="headerlink" title="V2Ray客户端安装"></a>V2Ray客户端安装</h3><h4 id="安卓版本"><a href="#安卓版本" class="headerlink" title="安卓版本"></a>安卓版本</h4><p>下载<code>V2RayNG</code>软件,Google商店可以搜索到，或者在<a href="https://github.com/2dust/v2rayNG/releases">工程发布地址</a>下载<code>app-universal-release.apk</code>并进行安装。</p>
<p>软件安装成功后，点击右上角加号并选择<code>手动输入Vmess</code>，然后将服务器的地址，以及之前服务器安装成后，显示的<code>PORT</code>和<code>UUID</code>分别填入<code>端口</code>和<code>用户ID</code>两个选项中，加密方式选择为<code>Auto</code>即可。</p>
<h4 id="Windows版本"><a href="#Windows版本" class="headerlink" title="Windows版本"></a>Windows版本</h4><p>在<a href="https://github.com/2dust/v2rayN/releases">V2RayN工程发布地址</a>分别下载<code>v2rayN-Core</code>和<code>v2rayN</code>压缩包，并将其解压到一个目录下。</p>
<blockquote>
<p>v2rayN-Core官方发布地址为<a href="https://github.com/v2ray/v2ray-core/releases">https://github.com/v2ray/v2ray-core/releases</a></p>
</blockquote>
<p>之后在解压目录中找到<code>v2rayN</code>文件，并双击运行，在界面左上角选择<code>服务器-添加VMess服务器</code>并如上述安卓版本一样，将对应信息填入。服务器添加完成后，双击运行。为方便运行可以在系统右下角的折叠栏中找到<code>V2Ray</code>图标，右键并选择<code>启用HTTP代理</code>，并将HTTP代理模式选择为全局代理。</p>
<blockquote>
<p>之后的教程中将会说明全局代理与PAC区别，以及介绍Chrome插件<code>SwitchyOmega</code>的使用。</p>
</blockquote>
<h4 id="MAC及IOS版本"><a href="#MAC及IOS版本" class="headerlink" title="MAC及IOS版本"></a>MAC及IOS版本</h4><p>因为我并没有苹果设备，所以这两个版本未进行过验证。但搜寻下来，普遍推荐MAC上使用V2RayX软件，IOS上使用Shadowrocket软件。两者都要注意在添加服务器时需要选择VMess类型，剩下的就是服务器地址，端口，ID的填写，这个与安卓与Windows版本并无差异，这里就不详细说明了。</p>
<div class="note info simple"><p>V2Ray官方版本并没有一个可视化的UI界面，以上推荐的软件都是针对V2Ray官方提供的<code>v2ray-core</code>项目的外部封装。我们可以在<a href="https://github.com/v2ray/v2ray-core/releases">v2ray-core项目地址</a>上下载该版本，下载对应的压缩包并解压后，在目录下的<code>config.json</code>填写入相应的参数，并运行<code>v2ray.exe</code>即完成了客户端的运行。但对于绝大部分用户来说仍然更熟悉可视化界面，所以我在这里还是推荐了不同平台上对应的第三方软件。</p>
</div>
<h2 id="V2Ray基本原理"><a href="#V2Ray基本原理" class="headerlink" title="V2Ray基本原理"></a>V2Ray基本原理</h2><p>至此，V2Ray的配置已经结束，之后的内容是对于V2Ray工作原理的一个基本说明。因为我也是这几天在<code>SSR</code>被封禁后才查询了一些<code>V2Ray</code>相关的资料，所以这里也只是将我自己对<code>V2Ray</code>原理的一些理解写出，如果要探究细节问题话，建议查看文末引用部分的官方文档。</p>
<h3 id="V2Ray连接通路"><a href="#V2Ray连接通路" class="headerlink" title="V2Ray连接通路"></a>V2Ray连接通路</h3><p>在前面V2Ray搭建章节，我们将V2Ray分为两个部分——客户端及服务端，其实严格意义上，V2Ray并没有服务端与客户端的概念。每个V2Ray进程可以看作一个盒子，每个盒子存在至少一个入口(<code>Inbounds</code>)以及最少一个出口(<code>Outbounds</code>)，整个V2Ray的工作原理实际上就是多个盒子串联起来形成一个连接通路。如果我们用服务端及客户端的概念来看我们分别运行在VPS上的V2Ray以及运行在电脑上的V2Ray（或安卓等终端），那么连接通路就是：</p>
<blockquote>
<p>游览器&lt;—-&gt;客户端inbound&lt;—-&gt;客户端outbound&lt;—-&gt;服务端inbound&lt;—-&gt;服务端outbound&lt;—-&gt;目标网站</p>
</blockquote>
<p>所以我们并不需要为每一个终端设置一个对应的VPS上的<code>V2Ray</code>，因为这些终端设备的切换只是更改了客户端这一个盒子，而服务端并不关心客户端是什么，只需要客户端能有正确的<code>inbounds</code>和<code>outbounds</code>即可。</p>
<p>每一个V2Ray进程都需要一个配置文件来指定需要的参数，其中最重要的参数便是<code>Inbounds</code>和<code>Outbounds</code>。下面会针对这个配置文件进行一些说明，为了简化阐述，我们将运行在PC上的V2Ray看作是客户端，运行在VPS上的V2Ray看作是服务端。</p>
<h4 id="客户端配置文件"><a href="#客户端配置文件" class="headerlink" title="客户端配置文件"></a>客户端配置文件</h4><p>在客户端的配置文件为安装目录下的文件<code>config.json</code>，文件是以json格式进行编写。这里不会详细的去分析客户端配置文件的每一行，我们目前只关注于<code>inbounds</code>和<code>outbounds</code>，我也不会对每个字段都进行分析。如果需要了解每一部分的每一个字段，可以查询<a href="https://v2ray.com/">v2ray的官方文档</a>中配置文件这一章节。</p>
<p>首先看<code>inbounds</code>，以下是我自己的客户端的配置文件中的<code>inbounds</code>部分。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;inbounds&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="number">10808</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;listen&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;protocol&quot;</span><span class="punctuation">:</span> <span class="string">&quot;socks&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;sniffing&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;enabled&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;destOverride&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">          <span class="string">&quot;http&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="string">&quot;tls&quot;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;settings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;auth&quot;</span><span class="punctuation">:</span> <span class="string">&quot;noauth&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;udp&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;ip&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;clients&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;streamSettings&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>可以看到<code>inbounds</code>字段包含一个数组，在当前的配置文件中，数组中只有一个元素(仅有一个大括号)，官网中将<code>inbounds</code>中的每一个元素定义为<code>InboundObject</code>。这里也对应了之前所说的，一个v2Ray进程可以有多个inbound，同理也可以有多个outbound。在有多个bound的情况下，可以使用<code>routing</code>字段来设定选择的规则，在未设定该字段时，默认以第一个bound进行运作，之后的章节会简单说明下<code>routing</code>字段。</p>
<p>这里的配置文件所想表达的就是：从127.0.0.1（<code>listen</code>）地址的10808端口(<code>port</code>字段)以socks协议(<code>protocol</code>字段)从上一级（在本例中为游览器）接受数据。（如果在V2RayN等软件中设置为全局模式，则实际上是监听所有端口）</p>
<p>关于不同协议的设置都放在<code>settings</code>字段中,根据协议的不同<code>settings</code>中的字段格式也会不同，这里就不对每个协议进行说明了。</p>
<p><code>sniffing</code>和<code>streanSetting</code>分别代表探测流量类型的设置和底层传输配置,因为这两个部分修改的比较少，我也没做研究。还是那句话，有需要看官方文档。</p>
<p>然后是<code>outbounds</code>部分，<code>outbounds</code>也同样是数组结构，其中每一个元素称为<code>OutboundObject</code>，这里因为篇幅关系，我仅黏贴了第一个<code>OutboundObject</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;outbounds&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;tag&quot;</span><span class="punctuation">:</span> <span class="string">&quot;proxy&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;protocol&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vmess&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;settings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;vnext&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;67.216.197.176&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="number">27533</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;users&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;25585281-69bd-4b72-9239-303bee11f555&quot;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="attr">&quot;alterId&quot;</span><span class="punctuation">:</span> <span class="number">64</span><span class="punctuation">,</span></span><br><span class="line">              <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;t@t.tt&quot;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="attr">&quot;security&quot;</span><span class="punctuation">:</span> <span class="string">&quot;auto&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">          <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;servers&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;response&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;streamSettings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="comment">//因为篇幅省略了该部分</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;mux&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;enabled&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="comment">//另一个outboundObject</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>可以看到这里用的协议就是<code>vmess</code>协议，这就是V2Ray与SSR最大的区别，SSR用的协议是<code>Shodowsocks</code>。这里<code>settings</code>字段中的设置就是针对于<code>vmess</code>协议的了，我们可以看到需要填写服务端的地址，端口及id，这里就是之前我们在配置客户端中需要填写的数据，我们在UI中添加服务器时，软件实际上就是修改了安装目录下的这个文件。</p>
<p>这个OutboundObject实际表达的意思为：将从Inbound中获取到的数据，以<code>vmess</code>协议发送给<code>67.216.97.176</code>地址的27533端口，在<code>vmess</code>中以25585281-69bd-4b72-9239-303bee11f555作为ID进行加密。</p>
<p>其他的字段含义同样可以在官方文档中找寻到，这里就不详细说明了。</p>
<h4 id="服务端配置文件"><a href="#服务端配置文件" class="headerlink" title="服务端配置文件"></a>服务端配置文件</h4><p>服务器的上配置文件地址为/etc/v2ray/config.json，我们可以在Xshell中通过<code>cat</code>命令进行查看，如果需要则可以使用<code>vi</code>命令进行修改，在修改完成后可以使用v2ray提供的test命令来检查配置文件的语法和格式是否正常（不包含连接性问题的检查）。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">cat /etc/v2ray/config.json</span><br><span class="line">vi /etc/v2ray/config.json</span><br><span class="line">/usr/bin/v2ray/v2ray -test -config /etc/v2ray/config.json</span><br></pre></td></tr></table></figure>
<p>还是以我自己的服务端(地址为67.216.197.176)配置文件为例，首先我们看<code>inbounds</code>部分</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;inbounds&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="number">27533</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;protocol&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vmess&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;settings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;clients&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;25585281-69bd-4b72-9239-303bee11f555&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;level&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;alterId&quot;</span><span class="punctuation">:</span> <span class="number">64</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>
<p>如上所述，<code>Inbounds</code>是从上一级接受数据，这里的上一级就是我们的客户端V2Ray。客户端V2Ray的outbounds协议为<code>vmess</code>，所以这里对应的inbounds协议为<code>vmess</code>，同理id，端口也要一一对应。</p>
<p>然后再看<code>outbounds</code>部分</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;outbounds&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;protocol&quot;</span><span class="punctuation">:</span> <span class="string">&quot;freedom&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;settings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>这里的协议为<code>freedom</code>，即直接发送给下一级，在本例子中为目标网址。</p>
<p>综上整个连接通路的详细流程为：游览器通过<code>socks</code>协议将数据发送给客户端，客户端用<code>Vmess</code>协议将数据加密并传出，服务端用<code>Vmess</code>协议接受数据并解密，服务端直接用解密后的数据访问目标网站。正是因为客户端在传出数据时进行了加密，所以可以躲避<code>GFW</code>的深度包检测，当数据成功传递给服务端时，只要将数据进行解密，就可以正常的浏览目标网站。</p>
<h3 id="V2Ray路由选择"><a href="#V2Ray路由选择" class="headerlink" title="V2Ray路由选择"></a>V2Ray路由选择</h3><p>前面可以注意到在一些<code>OutboundObject</code>中有字段<code>tag</code>，这个字段就是供选择时区分不同的Object。选择的规则是在<code>routing</code>字段中进行设定，这里我们还是通过一个例子进行说明</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;routing&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;domainStrategy&quot;</span><span class="punctuation">:</span> <span class="string">&quot;IPOnDemand&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;rules&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;field&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;outboundTag&quot;</span><span class="punctuation">:</span> <span class="string">&quot;direct&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;domain&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;geosite:cn&quot;</span><span class="punctuation">]</span> <span class="comment">// 中国大陆主流网站的域名</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p><code>domainStrategy</code>字段表示选择时的策略，当前的<code>IPOnDemand</code>表示如果有任何基于IP的规则，则立即以这些规则进行匹配。<code>rules</code>字段则是匹配的具体规则，注意这个字段也是个数组，我们可以指定多个规则。<br>规则中的<code>type</code>变量目前只有<code>field</code>这一个参数，所以也就不需要纠结。<code>domain</code>字段表示以域名进行匹配，例子中满足匹配的条件是中国大陆主流网站的域名。<code>outboundTag</code>则表示如果匹配成功，则选择<code>tag</code>为<code>direct</code>的<code>OutboundObject</code>。</p>
<p>关于匹配的其他规则如何写，如按IP进行匹配等，可以看官网上<code>路由配置</code>这一章节。</p>
<div class="note info simple"><ol>
<li>V2Ray官网 <a href="https://v2ray.com/">https://v2ray.com/</a></li>
<li>V2Ray白话教程 <a href="https://toutyrater.github.io/">https://toutyrater.github.io/</a></li>
</ol>
</div>
<hr>
]]></content>
      <categories>
        <category>教程</category>
        <category>翻墙梯子</category>
      </categories>
      <tags>
        <tag>翻墙梯子</tag>
        <tag>软件推荐</tag>
      </tags>
  </entry>
  <entry>
    <title>VR UI设计规范</title>
    <url>/VRUIDesignGuideLine/</url>
    <content><![CDATA[<p>Google I/O 2017，DayDream团队提出的UI设计规范。</p>
<span id="more"></span>
<h1 id="dmm概念"><a href="#dmm概念" class="headerlink" title="dmm概念"></a>dmm概念</h1><p>在VR的设计中，UI物体会因为距离用户的远近距离不同导致视觉上大小的变化。对于设计师而言，他们只能针对2D画面进行设计，而无法给出UI距离用户的距离，所以在游戏引擎中很难将UI调至设计师希望的样子。</p>
<p>我们可以用角度来解决这个问题，不同距离不同大小的物体，只要他们在视线内所占的角度是相同的，那么对于人眼来说，他们看起来就是相同的大小。如下图所示：</p>
<p><img src="VRUIDesignGuideLine/2019-02-17-17-08-33.png" alt="不同距离看不同大小物体"></p>
<p>上图左上角的<code>dmm</code>单位就是DayDream团队提出的用以解决这问题的单位，<code>dmm</code>(distance-independent millimeter，距离不相关毫米)，我们将1米外看起来长为1毫米的长度定义为1dmm，按定义可知2m外看起来为2mm的长度也为1dmm。在2D设计软件中，我们将软件中的1px看作为1mm。这样当设计师给出一张480*320像素的图片，这张图的含义即为在1米外看起来长480毫米，高320毫米的图片。</p>
<h1 id="文字最小尺寸"><a href="#文字最小尺寸" class="headerlink" title="文字最小尺寸"></a>文字最小尺寸</h1><p>一个文字看的是否清楚取决于用了多少像素的去渲染这个文字。在这里首先解释下<code>PPD</code>（Pixel Per Degree）的概念，在VR设备中我们用一块屏幕来显示一定宽度视场角的内容，如HTV Vive的双眼分辨率为2160*1200，单眼分辨率为1080*1200，视场角为110°，则HTV vive的PPD为<code>1080/110</code>约为9.8即1°的画面平均含有9.8个像素。在PPD越低的设备上，我们要保证一个文字足够清晰就需要扩大文字在设备中所占的角度来确保它有足够的像素。DayDream团队给出的文字所占角度与设备PPD关系的图如下：</p>
<p><img src="VRUIDesignGuideLine/2019-02-17-17-19-57.png" alt="文字大小与设备PPD"></p>
<p>以设备PPD为12.6进行计算， 则文字需要有1.6°的高度，也就是文字需要有12.6*1.6=20.16个屏幕上的像素进行渲染。如果使用dmm而非像素来进行统计的话，可以使用公式 $2\tan(\frac{angle}{2})*1000$ 来进行计算。如这里需要角度为1.6°，则结果为 $2\tan(\frac{1.6}{2})*1000=27.9$ dmm，即在2D设计软件中需要用28个像素来表示，也就是28号字体，对于3D场景来说则是28毫米。</p>
<h1 id="Unity中使用"><a href="#Unity中使用" class="headerlink" title="Unity中使用"></a>Unity中使用</h1><div class="note info simple"><p>Unity中Scale为1表示为1米</p>
</div>
<p>建立一个Demo场景，首先存在根物体<code>ParentUI</code>，Z轴值为1，表示距离我们1米远，Scale为1</p>
<p><img src="VRUIDesignGuideLine/2019-02-17-20-24-38.png" alt="根物体ParentUI"></p>
<p>在<code>ParentUI</code>下有个带有<code>Canvas</code>组件的物体<code>Canvas Menu</code>,它的Scale为0.001，这是因为在dmm概念中所有的计算单位都是毫米，所以我们需要将米转换为毫米。</p>
<p><img src="2019-02-17-20-26-58.png" alt="CanvasMenu"></p>
<p>这样在<code>Canvas Menu</code>下的所有UI组件都可以按设计图给的尺寸调整大小，如一张图片大小为400*320，在Unity中我们就将其Width,Height设为400,320。</p>
<p>当我们需要将UI放的更远，而保持UI大小不变的话，整体调整<code>ParentUI</code>的Scale即可，如</p>
<p><img src="VRUIDesignGuideLine/2019-02-17-20-28-56.png" alt="调整UI尺寸"></p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ol>
<li><p>UI的中心水平应该在水平线下6°左右</p>
<p> <img src="VRUIDesignGuideLine/2019-02-17-20-49-44.png" alt="水平线下6°"></p>
</li>
<li><p>人保持头不动时，理想的视线范围是左右30°以内，带上颈部旋转的话，理性范围是左右60°以内</p>
<p><img src="VRUIDesignGuideLine/2019-02-17-20-50-16.png" alt="舒适范围"></p>
</li>
</ol>
<div class="note info simple"><p>引用：</p>
<ol>
<li><a href="https://www.youtube.com/watch?v=ES9jArHRFHQ">Google I/O 视频</a></li>
<li><a href="https://developers.google.com/vr/design/sticker-sheet">Google Design Sticker Sheet</a></li>
<li><a href="https://www.jianshu.com/p/c21addac9b0e">如何 VR 界面设计规范与实操</a></li>
</ol>
</div>
<hr>
]]></content>
      <tags>
        <tag>虚拟现实</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 子模块 Submodule 教程</title>
    <url>/gitSubmoduleTutorial/</url>
    <content><![CDATA[<p>介绍git submodule的使用与可能遇到的问题。</p>
<span id="more"></span>
<p>很久没有更新博客，打开一看发现awesome的图标都无法显示了，版本回滚后仍然无法显示，估计是nexT更新导致的，查看后发现的确nexT更新了大版本。</p>
<p>但是原始工程在家里的台式机上，发现笔记本从github上拉下的工程并没有将nexT作为一个git仓库，于是只能将整个文件夹删除后进行覆盖更新。</p>
<p>但这样的方式肯定是不能长久维护的，于是想将nexT作为项目的子模块进行管理。在这里我整理了使用git submodule对项目进行子模块管理的方法和常见问题。</p>
<h2 id="git命令"><a href="#git命令" class="headerlink" title="git命令"></a>git命令</h2><h3 id="添加子模块"><a href="#添加子模块" class="headerlink" title="添加子模块"></a>添加子模块</h3><p>如需要将远程项目<code>xuejiaW/hexo-theme-next</code>作为子模块，并且下载到目录themes/next下，则运行命令</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">git submodule add git@github.com:xuejiaW/hexo-theme-next.git themes/next</span><br></pre></td></tr></table></figure>
<p>然后可以看到目录下出现了<code>.gitmodules</code>文件，其中记录了子模块保持地址及Url</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[submodule &quot;themes/next&quot;]</span><br><span class="line">	path = themes/next</span><br><span class="line">	url = git@github.com:xuejiaW/hexo-theme-next.git</span><br></pre></td></tr></table></figure>
<h3 id="查看子模块"><a href="#查看子模块" class="headerlink" title="查看子模块"></a>查看子模块</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">git submodule</span><br><span class="line"></span><br><span class="line">//可以看到类似结果</span><br><span class="line">//733d8e492aafe21abc971f853aa9e7b8b6196425 themes/next (v7.4.0-13-g733d8e4)</span><br><span class="line">//表示子模块最新的patch及子模块保存地址</span><br></pre></td></tr></table></figure>
<h3 id="初始化及更新子模块"><a href="#初始化及更新子模块" class="headerlink" title="初始化及更新子模块"></a>初始化及更新子模块</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">git submodule init</span><br><span class="line">//初始化本地的子模块配置文件，在拉取了一个带有子模块的工程后，需要先执行init</span><br><span class="line"></span><br><span class="line">git submodule update</span><br><span class="line">//更新子模块（如子模块文件夹为空，则会下载子模块）</span><br></pre></td></tr></table></figure>
<h3 id="提交子模块修改"><a href="#提交子模块修改" class="headerlink" title="提交子模块修改"></a>提交子模块修改</h3><p>当子模块有修改时，在主项目上<code>git status</code>并不会完全显示修改的文件，只会显示被修改的子文件夹，如</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">modified:   themes/next (modified content)</span><br></pre></td></tr></table></figure>
<p>然后需要进入子模块进行常规的<code>add</code>，<code>commit</code>等操作，将子模块的改动提交</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">cd themes/next</span><br><span class="line">git add --a</span><br><span class="line">git commit -s -m&quot;Modify submodule&quot;</span><br></pre></td></tr></table></figure>
<div class="note danger simple"><p>在子模块提交时，请确认分支是否正确，否则可能会造成提交到远程仓库的commit ID不符，导致其他工程开发者在运行<code>git submodule update</code>时出错</p>
</div>
<p>此时回到主工程，再次status查看</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">cd ../../</span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">modified:   themes/next (new commits)</span><br></pre></td></tr></table></figure>
<p>用<code>diff</code>语句查看改动，可以看到改动的是子模块最新的<code>commit ID</code>，这可以理解为主工程保留了每个子模块最新的<code>commit ID</code>指针，当运行<code>git submodule update</code>时，就是将每个子模块更新至各自最新的<code>commit ID</code></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">git diff themes/next</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">-Subproject commit 733d8e492aafe21abc971f853aa9e7b8b6196425</span><br><span class="line">+Subproject commit 1da46ea43f2084eb2be519162b8d9ccb8d45e660</span><br></pre></td></tr></table></figure>
<p>将这个改动提交，那么远程仓库也就更新了子模块的最新指针。</p>
<h3 id="删除子模块"><a href="#删除子模块" class="headerlink" title="删除子模块"></a>删除子模块</h3><p>删除子模块相比于之前的操作要复杂些</p>
<ol>
<li>删除<code>.gitmodules</code>中的子模块内容</li>
<li>删除<code>.git/config</code>中的子模块内容</li>
<li>删除<code>.git/modules</code>中的子模块对应文件夹</li>
<li>运行<code>git rm --cached -r themes/next</code>删除对应子模块文件夹的索引</li>
<li>删除子模块文件夹</li>
</ol>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="xxx-already-exists-in-the-index"><a href="#xxx-already-exists-in-the-index" class="headerlink" title="xxx already exists in the index"></a>xxx already exists in the index</h3><p>出现在<code>git submodule add</code>时，说明同一文件夹路径下有其他子模块。如果已经手动删除，错误仍然存在，可能是路径索引导致，需要完整执行删除子模块操作。</p>
<h3 id="server-does-not-allow-request-for-unadvertised-object"><a href="#server-does-not-allow-request-for-unadvertised-object" class="headerlink" title="server does not allow request for unadvertised object"></a>server does not allow request for unadvertised object</h3><p>出现在<code>git submodule update</code>时，说明主工程中保持的最新的子模块<code>commit id</code>，无法在服务器子模块工程中找到，可能是因为子模块改动未提交，或者提交分支错误导致<code>commit id</code>改变。</p>
<div class="note info simple"><p>引用：</p>
<ol>
<li>Git 工具 - 子模块 <a href="https://git-scm.com/book/zh/v1/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97">https://git-scm.com/book/zh/v1/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97</a> </li>
<li>Git submodule 子模块的管理和使用 <a href="https://www.jianshu.com/p/9000cd49822c">https://www.jianshu.com/p/9000cd49822c</a></li>
</ol>
</div>
<hr>
]]></content>
      <categories>
        <category>教程</category>
        <category>Git</category>
      </categories>
  </entry>
</search>
