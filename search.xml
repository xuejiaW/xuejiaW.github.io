<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>《Render Hell》 第一部分 概览</title>
    <url>/book_1_overview/</url>
    <content><![CDATA[<div class="note info simple"><p>这一部分简单介绍了一些 GPU 的涉及的概念。</p>
</div>
<h1 id="Copy_the_Data"><a class="header-anchor" href="#Copy_the_Data">#</a>Copy the Data</h1>
<div class="note info simple"><p>之所以需要在不同的硬件间拷贝数据，是因为从不同硬件中读取数据的速度差异很大。因此对于当前需要频繁访问的数据，通常会选择将其拷贝到更为高速的内存部分中。</p>
</div>
<div class="note warning simple"><p>GPU 和 显卡 并不是相等的关系 GPU 全称为 Graphics Processing Unit，它指示显卡中的核心计算芯片。整个显卡中还包括显存（VRam），散热器等配件。</p>
</div>
<p>对于所有与绘制相关的资源，如贴图，模型，一开始都是存储在硬盘（HDD）上的 。在整个绘制过程中，它们会先被读取到内存（RAM）中，再被读取到显卡上的显存（VRAM）中。之所以要进行这么一个数据从 HDD 拷贝到 VRAM 中的操作，是因为显卡读取 VRAM 中的内容速度更快。整个过程如下所示：<br>
<img src="/book_1_overview/gif_9-13-2021_8-52-50_am.gif" alt="数据从内存拷贝到显存"></p>
<p>又因为整个过程中数据是被 拷贝 的，因此当数据进入 VRAM 后，在 RAM 中的数据可以被正常销毁，不会影响到后续的绘制。如下所示：<br>
<img src="/book_1_overview/gif_9-13-2021_8-55-43_am.gif" alt="内存中数据可安全销毁"></p>
<p>但是 GPU 访问 VRAM 速度仍然不够快，VRAM 中需要使用到的数据会进一步的被拷贝到 GPU 中的一小块内存上（ on-chip caches），这一块内存被称为 <code>L2 Cache</code> 。过程如下所示：<br>
<img src="/book_1_overview/gif_9-13-2021_9-18-41_am.gif" alt="L2 Cache"></p>
<p>在 GPU 更靠近核心（Core）的地方，还有一片更小的内存，称为 <code>L1 Cache</code> 。因为更靠近核心，所以 <code>L1 Cache</code> 中数据的访问速度相对于 <code>L2 Cache</code> 也更快。 <code>L2 Cache</code> 中的数据在需要被操作时，也会先拷贝到 <code>L1 Cache</code> 中。</p>
<p>在 <code>L1 Cache</code> 中的数据还会被进一步拷贝到 GPU 中被称为 <code>Register</code> 的内存区域，GPU Cores 会从该区域中读取数据，计算并将运算后结果放回到 <code>Register</code> 中：<br>
<img src="/book_1_overview/gif_9-13-2021_9-25-58_am.gif" alt="Register"></p>
<h1 id="Set_the_Render_State"><a class="header-anchor" href="#Set_the_Render_State">#</a>Set the Render State</h1>
<p>对于除了 Mesh 数据外的数据，如顶点/像素着色器，纹理，材质，光照信息，是否半透明等信息都称为 <code>Render State</code> 。</p>
<p>Mesh 数据会使用被设置的 <code>Render State</code> 进行渲染，图形 API 又是一个类似状态机的实现，即设置了 Render State 后，后续的 Mesh 都会使用该 State 进行渲染，直到有了新 State 被设置。示意图如下所示：<br>
<img src="/book_1_overview/gif_9-14-2021_8-47-57_am.gif" alt="State"></p>
<h1 id="Draw_Call"><a class="header-anchor" href="#Draw_Call">#</a>Draw Call</h1>
<p><code>DrawCall</code> 是一个由 CPU 端发出，由 GPU 端接受的绘制 <strong>一个 Mesh</strong> 的指令。该指令只包含指向需要绘制的 Mesh 的指针，而如材质这样的信息是通过 Render State 进行传递，并不会在 <code>DrawCall</code> 中。示意图如下所示：<br>
<img src="/book_1_overview/gif_9-14-2021_8-55-41_am.gif" alt="Draw Call"></p>
<h1 id="Pipeline"><a class="header-anchor" href="#Pipeline">#</a>Pipeline</h1>
<p>当 <code>DrawCall</code> 发送后，GPU 会获取当前的 Render State，和设置的顶点信息（Mesh），并通过渲染管线（Pipeline）将其一步步转换到最终屏幕上所见像素。在管线中，对于顶点和像素的工作会被划分到 GPU 的多个核心中平行处理。整个管线工作的简单示意图如下所示：<br>
<img src="/book_1_overview/gif_9-14-2021_9-02-13_am.gif" alt="Pipeline"></p>
<h1 id="Command_Buffer"><a class="header-anchor" href="#Command_Buffer">#</a>Command Buffer</h1>
<p>CPU 并不是直接将数据传递给 GPU，而是通过 <code>Command Buffer</code> ，这样 CPU 和 GPU 就可以各自独立的工作。如果是直接传递的话，当 GPU 在忙碌时，CPU 无法将数据送给 GPU，就会造成 CPU 的堵塞。</p>
<p>Command Buffer 是一个 <code>FIFO 存储器</code> ，即 GPU 只会取 CPU 最早 Push 进 Command Buffer 中的数据。 Command Buffer 的示意图如下所示：<br>
<img src="/book_1_overview/gif_9-14-2021_9-12-25_am.gif" alt="Command Buffer"></p>
<h1 id="Reference"><a class="header-anchor" href="#Reference">#</a>Reference</h1>
<p><a href="http://simonschreibt.de/gat/renderhell-book1/">Render Hell – Book I | Simon schreibt.</a></p>
]]></content>
      <tags>
        <tag>GPU</tag>
      </tags>
  </entry>
  <entry>
    <title>《Render Hell》 第二部分 管线</title>
    <url>/book_2_pipeline/</url>
    <content><![CDATA[<h1 id="GPU_Core"><a class="header-anchor" href="#GPU_Core">#</a>GPU Core</h1>
<p>在 GPU Core 中有两个运算单元 <code>floating point unit(FP UNIT)</code> 和 <code>integer unit (INT UNIT)</code> ，当 GPU Core 接收到数据后，会通过这两个运算单元进行计算。</p>
<p><img src="/book_2_pipeline/gif_9-14-2021_9-27-55_am.gif" alt="FP / Int Unit"></p>
<h2 id="Not_Everything_is_done_by_GPU_Cores"><a class="header-anchor" href="#Not_Everything_is_done_by_GPU_Cores">#</a>Not Everything is done by GPU Cores</h2>
<p>对于如分发渲染任务，计算 <code>Tessellation</code>，<code>Culling</code> ，<code>Depth Testing</code>，光栅化，将计算后的 Pixel 信息写入到 Framebuffer 中等工作，并不是不通过 GPU Cores 完成，这些工作会由 GPU 中其他的硬件模块完成（这些模块不受开发者的代码控制）。</p>
<h2 id="Parallel_Running_Pipelines"><a class="header-anchor" href="#Parallel_Running_Pipelines">#</a>Parallel Running Pipelines</h2>
<p>对于 GPU Core 而言，它需要 <code>Streaming Multiprocessor(SM)</code> 为其分配工作，一个 SM 处理来自于 <strong>一个</strong> Shader 的顶点或像素数据。因此当一个 SM 下有多个 Core 时，来自于 <strong>一个</strong> Shader 的顶点或像素就能被并行的处理。当有多个 SM 时，多个 Shader 间也能并行处理。如下图所示：</p>
<p><img src="/book_2_pipeline/untitled.png" alt="Streaming Multiprocessor"></p>
<h1 id="Pipeline_Stages_In_Depth"><a class="header-anchor" href="#Pipeline_Stages_In_Depth">#</a>Pipeline Stages In-Depth</h1>
<div class="note info simple"><p>这一部分从上至下更深入的讲解 GPU Pipeline</p>
</div>
<h2 id="Application_Stage"><a class="header-anchor" href="#Application_Stage">#</a>Application Stage</h2>
<p>对于应用而言，其提交的图形 API 都是提交给 GPU 的驱动，告诉其需要绘制的内容和 Render State。</p>
<p><img src="/book_2_pipeline/gif_9-15-2021_8-41-31_am.gif" alt="Application 提交图像指令给 Driver"></p>
<h2 id="Driver_Stage"><a class="header-anchor" href="#Driver_Stage">#</a>Driver Stage</h2>
<p>驱动会将绘制的数据 Push 到 Command Buffer 中，当 VSync 或 Flush 时，Command Buffer 中的数据会被 Push 到 GPU 中。</p>
<p><img src="/book_2_pipeline/gif_9-15-2021_8-44-49_am.gif" alt="Driver 将指令给 Command Buffer"></p>
<h2 id="Read_Commands"><a class="header-anchor" href="#Read_Commands">#</a>Read Commands</h2>
<p>显卡中的 <code>Host Interface</code> 会负责读取 Command Buffer 传递进来的数据供后续的使用。<br>
<img src="/book_2_pipeline/gif_9-15-2021_8-45-28_am.gif" alt="Host Interface 读取 Command Buffer"></p>
<h2 id="Data_Fetch"><a class="header-anchor" href="#Data_Fetch">#</a>Data Fetch</h2>
<p>一些 Command 包含数据的拷贝。GPU 通常会有一个单独的模块处理从 RAM 拷贝数据到 VRAM 的过程，反之亦然。这些需要拷贝的数据可以是 Vertex Buffer，纹理或其他 Shader 的参数。通常渲染一帧会从传递 Camera 相关的数据开始。</p>
<p>当所有数据准备完成后，GPU 中会有一个模块（Gigathread Engine）负责处理任务的分发。它为每一个要处理的顶点或像素创建一个线程，并将多个线程打包成一个 Package, NVIDIA 将这个 Package 称为 Thread block 。 Thread Block 会被分发给 SM，如下图所示：<br>
<img src="/book_2_pipeline/gif_9-15-2021_8-58-59_am.gif" alt="分配 Thread Block"></p>
<h2 id="Vertex_Fetch"><a class="header-anchor" href="#Vertex_Fetch">#</a>Vertex Fetch</h2>
<p>SM 中仍然包含了多个硬件的单元，其中一个为 <code>Polymorph Engine</code> ，它负责将数据拷贝到各内存部分中，让 Core 在之后的工作中可以更快的访问数据。</p>
<p><img src="/book_2_pipeline/gif_9-15-2021_9-03-27_am.gif" alt="Polymorph Engine 拷贝数据"></p>
<h2 id="Shader_Execution"><a class="header-anchor" href="#Shader_Execution">#</a>Shader Execution</h2>
<p><code>Streaming MultiProcessor (SM)</code> 的主要功能为执行开发者编写的 Shaders。</p>
<p>SM 首先会将之前获取到的 Thread Block 拆分为多个 <code>Warp</code> 。每一个 Warp 包含的线程数根据硬件的不同可能存在差异， Nvidia 平台下一个 Warp 包含 32 个 Thread。<br>
<img src="/book_2_pipeline/pipeline_workdistribution_02.gif" alt="Thread Block to Warp"></p>
<p>SM 中包含多个 <code>Warp Schedulers</code> ，每个 <code>Warp Schedulers</code> 会选择其中一个 Warp，并将需要执行的指令进行翻译。与 Warp 中线程数相同的 GPU Core 会一起逐条执行这些指令。每个 GPU Core 在同一时间点会执行相同的指令，但有着不同的数据（如不同的像素，不同的顶点）。为了简化，如下只展示一个 <code>Warp Schedulers</code> 的情况，过程如下所示：</p>
<p><img src="/book_2_pipeline/pipeline_workdistribution_04.gif" alt="Wrap Schedulers 执行指令"></p>
<div class="note info simple"><p>对于每个 GPU Core 而言，它们无法知晓整个 Shader 指令，它们在仅知晓当前需要执行的那 <strong>一条</strong> 指令。</p>
</div>
<p>需要再次强调的是，一个 Warp 对应的 GPU Cores 在同一时间点会执行相同的指令，不会存在某个时间点一个 Core 执行语句 A，另一个 Core 执行语句 B 的情况。这种限制被称为 <code>lock-step</code> 。</p>
<p>当 Shader 中 IF 指令时，进入分支的 Core 会进行工作，剩下的 Core 会进入“休眠”。同理如果 Shader 中存在循环，那么仍然在循环内的 Core 进行工作，已经完成循环 工作的 Core 进入休眠，直到所有的 Core 都完成了操作。如下所示：</p>
<p><img src="/book_2_pipeline/pipeline_workdistribution_06.gif" alt="Lock Step"></p>
<div class="note info simple"><p>部分 Cores 工作，部分 Cores 休眠的现象称为 <strong><code>divergent threads</code></strong> 应当要尽量避免。</p>
</div>
<p>当 Warp 中需要执行的指令依赖的数据尚未被准备好， SM 会选择另一个 Warp 并执行其中的指令，如下所示：<br>
<img src="/book_2_pipeline/pipeline_workdistribution_07.gif" alt="Memory Stall"></p>
<div class="note info simple"><p>Warp 中指令依赖数据未准备好，必须切换另一个 Warp 继续执行的现象，称为 <code>Memory Stall</code> 。</p>
</div>
<p>如前所述，一个 SM 可能包含多个 Warp Schedulers，也因此可以并行的处理多个 Warps，<br>
<img src="/book_2_pipeline/untitled_1.png" alt="|多个 Warps"></p>
<h2 id="Vertex_Shader"><a class="header-anchor" href="#Vertex_Shader">#</a>Vertex Shader</h2>
<p>每一个顶点着色器的实例对应 <strong>一个</strong> 顶点的处理，且运行在被 SM 管理的一个线程上。<br>
<img src="/book_2_pipeline/pipeline_vertex_shader_01.gif" alt="顶点"></p>
<h2 id="Tessellation"><a class="header-anchor" href="#Tessellation">#</a>Tessellation</h2>
<div class="note info simple"><p>曲面细分阶段中，有两个可编程的着色器， <code>Hull Shader</code> 和 <code>Domain Shader</code></p>
</div>
<div class="note info simple"><p>为何需要曲面细分阶段，而不是直接在模型中增加更多的顶点？</p>
<ol>
<li>相较于更多顶点时数据传输时的开销，通过曲面细分生成更多顶点的开销更低</li>
<li>曲面细分阶段可以控制顶点该如何被细分，如根据摄像机的距离。这样就能产生出更适合实际使用时的顶点数据。</li>
</ol>
</div>
<h3 id="Patch_Assembly"><a class="header-anchor" href="#Patch_Assembly">#</a>Patch Assembly</h3>
<div class="note info simple"><p><code>Patch Assembly</code> 和后续的 <code>Hull Shader</code> ， <code>Tessellation</code> 及 <code>Domain Shader</code> 仅当使用了 <code>曲面细分着色器(Tessellation Shader)</code> 时才会进行。</p>
</div>
<p>Patch Assembly 阶段会把多个顶点打包成一个 Patch 供后续的 Tessellation 阶段处理。究竟多少个 顶点会被打包成一个 Patch，是由开发者决定的，最多 32 个顶点可以被打包成一个 Patch：<br>
<img src="/book_2_pipeline/pipeline_patch_assembly_01.gif" alt="将多个顶点打包为一个 Patch"></p>
<h3 id="Hull_Shader"><a class="header-anchor" href="#Hull_Shader">#</a>Hull Shader</h3>
<p>Hull Shader 处理之前被打包成一个 Patch 的顶点们，并生成一系列的 <code>Tessellation Factor</code> 。这些 Factors 指明了 Patch 中的边该如何细分，和 Patch 的内部该如何细分。</p>
<p>Hull Shader 中也可以指明计算 Factor 的方法，最常见的是根据与摄像机的距离：</p>
<p><img src="/book_2_pipeline/pipeline_hull_shader_01.gif" alt="Tessellation Factor"></p>
<p>另外因为 GPU 仅能对三个基本的几何元素（ Quad，Triangle，Lines）进行细分，Hull Shader 也会指明 Patch 需要按哪个几何元素进行细分。</p>
<h3 id="Tessellation-2"><a class="header-anchor" href="#Tessellation-2">#</a>Tessellation</h3>
<p><code>Polymorph Engine</code> 会根据之前的 Patch 以及得到的 Tessellation Factor 真正的执行细分操作：</p>
<p><img src="/book_2_pipeline/pipeline_tesselation_01.gif" alt="Polymorph Engine"></p>
<p>被细分创造出的顶点会被送回到 <code>GigaThead Engine</code> 中，并被其重新派分给 SM，这些 SM 会将得到的顶点通过 <code>Domain Shader</code> 处理。</p>
<h3 id="Domain_Shader"><a class="header-anchor" href="#Domain_Shader">#</a>Domain Shader</h3>
<p>Domain Shader 会根据 Hell Shader 的输出（ Patch 顶点）以及 Tessellation 的输出（顶点的质心坐标系（ Barycentric Coordinate））调整每个顶点的位置。如果开发者使用了 <code>Displacement map</code> ，则会在这个阶段被使用：</p>
<p><img src="/book_2_pipeline/pipeline_domain_shader01.gif" alt="Domain Shader "></p>
<h2 id="Primitive_Assembly"><a class="header-anchor" href="#Primitive_Assembly">#</a>Primitive Assembly</h2>
<p>图元装配阶段，会将顶点数据（来自于 Vertex Shader 或来自于 Tessellation ）装配成一个个几何图形：<br>
<img src="/book_2_pipeline/pipeline_primitive_assembly_01.gif" alt="图元装配"></p>
<h2 id="Geometry_Shader"><a class="header-anchor" href="#Geometry_Shader">#</a>Geometry Shader</h2>
<div class="note info simple"><p>几何着色器（Geometry Shader）是一个可选 Shadder</p>
</div>
<p>几何着色器会针对 Primitive Assembly 给出的图元进行调整，如它可以将一个点调整为两个三角形：</p>
<p><img src="/book_2_pipeline/pipeline_geometry_shader01.gif" alt="几何"></p>
<div class="note info simple"><p>如果需要大量的生成新顶点，更适合在 Tessellation 阶段进行。</p>
</div>
<div class="note info simple"><p>几何着色器更大意义在于，它是进入光栅化前最后可配置的一个阶段。如它在 <code>Voxelization Techniques</code> 中扮演了重要角色。</p>
</div>
<h2 id="Viewport_Transform_Clipping"><a class="header-anchor" href="#Viewport_Transform_Clipping">#</a>Viewport Transform &amp;&amp; Clipping</h2>
<p>之前的操作，物体都是处在 NDC 空间中的。在 Viewport Transform 中需要将其转换到与屏幕分辨率匹配的空间（Viewport 空间），这个操作被称为 <code>Viewport Transform</code> 或 <code>Screen Mapping</code> 。</p>
<p><img src="/book_2_pipeline/pipeline_screenmapping01.gif" alt="Viewport Transform"></p>
<p>超过了屏幕范围的三角形会被裁剪，这一部分称为 <code>Guard Band Clipping</code> ，如下所示：<br>
<img src="/book_2_pipeline/pipeline_clipping01.gif" alt="Guard Band Clipping"></p>
<h2 id="Rasterizing"><a class="header-anchor" href="#Rasterizing">#</a>Rasterizing</h2>
<p>在运行像素着色器前，需要通过光栅化，将之前的三角形转换为屏幕上的像素。 GPU 硬件中通常包含多个光栅器，并且他们可以同时工作。</p>
<p>每一个光栅器会负责屏幕中的特定区域，因此 GPU 会根据三角形在屏幕中的位置决定他们应当由哪个光栅器进行处理，并将其发送给特定的光栅器。示意图如下所示：</p>
<p><img src="/book_2_pipeline/pipeline_triangle_journey01.gif" alt="指定光栅器"></p>
<div class="note info simple"><p>如果一个三角形足够的大，覆盖了屏幕中的很大一部分，那么可能会同时有多个光栅器为其进行光栅化。</p>
</div>
<p>当光栅器接收到一个三角形数据后，它会首先快速的检查该三角形的朝向<code>（Face Culling）</code> 。如果三角形通过了 Face Culling，则光栅器会根据三角形的边，确定它覆盖了那些 Pixels Quad （ $2\times2$ Piexls，或称为 <code>pre-pixels</code> / <code>pre-fragment</code>），示意图如下所示：<br>
<img src="/book_2_pipeline/pipeline_rasterizing02.gif" alt="确认覆盖的 Pixels Quad"></p>
<p>之所以以 <code>pre-piexles/fragments</code> 作为一个单位，而非单一的 Pixel 作为单位，是因为这样可以计算一些后续操作需要用到的数据（如采样 Mipmap 时需要的导数<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。</p>
<div class="note info simple"><p>一些 Tile-Based 硬件 ，在 <code>pre-pixels/fragments</code> 创建后，可能会有一些硬件层面上的可见性检测。它们会将整个 Tile 发送给一个称为 <code>Z-Cull</code> 的模块，该模块会将 Tile 中的每个像素的深度与 FrameBuffer 中的像素深度进行比较，如果一整个 Tile 的测试都未通过，则该 Tile 会被丢弃。</p>
</div>
<h2 id="Pixel_Shader"><a class="header-anchor" href="#Pixel_Shader">#</a>Pixel Shader</h2>
<p>对于每个 <code>pre-pixels/fragments</code> ，它们会被 Pixel Shaders 进行填色处理。同样的， Pixel Shader 也是运行在 Warp 的一个线程上。</p>
<div class="note info simple"><p>一个 <code>pre-pixels/fragments</code> 实际上是 4 个像素（$2*2$），因此一个 32 线程的 Warp，实际上运行 8 个 <code>pre-pixels/fragments</code> 。</p>
</div>
<p>当核心工作完成后，它们会将得到的数据写入 L2 Cache。</p>
<h2 id="Raster_Output"><a class="header-anchor" href="#Raster_Output">#</a>Raster Output</h2>
<p>在管线的最后，会有称为 <code>Raster Output(ROP)</code> 的硬件模块将 L2 Cache 中存储的 Pixel Shader 运算得到的像素数据写入 VRAM 中的 Frame buffer。</p>
<p>除了单纯的拷贝像素数据， ROPs 还会进行如 Pixel Blending， 抗锯齿时依赖的 Coverage Information 计算等工作。</p>
<h1 id="Reference"><a class="header-anchor" href="#Reference">#</a>Reference</h1>
<p><a href="http://simonschreibt.de/gat/renderhell-book2/">Render Hell – Book II | Simon schreibt.</a></p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a href="https://developer.nvidia.com/content/life-triangle-nvidias-logical-pipeline">Life of a triangler</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <tags>
        <tag>GPU</tag>
      </tags>
  </entry>
  <entry>
    <title>《Render Hell》 第三部分 常见问题</title>
    <url>/book_3_problems/</url>
    <content><![CDATA[<h1 id="Many_Draw_Calls_Many_Commands"><a class="header-anchor" href="#Many_Draw_Calls_Many_Commands">#</a>Many Draw Calls / Many Commands</h1>
<p>对于一个 API 而言，它不仅仅是将命令发送给 GPU，它还会有额外的如驱动翻译等的开销，因此应当尽可能的使用更少的命令。</p>
<div class="note info simple"><p>对于新的图形 API，如 DirectX12， Vulkan 等，命令的开销会相对较少，但仍然应当尽可能的减少命令的数量。</p>
</div>
<p>如果有一系列很小的 Mesh，相较于每个 Mesh 都使用一个 Drawcall，更理想的做法是将这些 Meshes 组合成一个更大的 Mesh，并通过一个 Drawcall 传送。</p>
<p>因为对于 GPU 而言，绘制一个小 Mesh 的时间是非常快的，而 CPU 将数据发送给 GPU 的时间是相对较长的。</p>
<p>如果是每一个 Mesh 一个 Draw Call 的处理方式，往往瓶颈会出现在 CPU 侧。</p>
<h1 id="Many_Meshes_and_Materials"><a class="header-anchor" href="#Many_Meshes_and_Materials">#</a>Many Meshes and Materials</h1>
<p>如果要渲染许多 Mesh 并使用不同的 Materials，除了需要用许多的命令外，还会额外带来 <code>Flush Pipeline</code> 的问题。</p>
<p>如果多个 Meshes 是用同一种渲染状态，则在一个 Mesh 完成后，另一个 Mesh 可以被很快的装填。而如果更改了材质状态，则管线中的一部分数据需要被刷新，才能进行下一个 Mesh 的绘制，这会造成额外的开销。</p>
<h1 id="Meshes_and_Multi_Materials"><a class="header-anchor" href="#Meshes_and_Multi_Materials">#</a>Meshes and Multi-Materials</h1>
<p>如果一个 Mesh 被赋予了多个材质，则该 Mesh 会被切分成多份再被送入 Command Buffer 中，这无疑也会造成多个 Draw Call 的产生。如下示意图所示，球的左半部分和右半部分各需要一个 Draw Call：<br>
<img src="/book_3_problems/copy_data_from_hdd_to_ram_vram_01_multimaterial.gif" alt="Multi-Materials"></p>
<h1 id="Thin_Triangles"><a class="header-anchor" href="#Thin_Triangles">#</a>Thin Triangles</h1>
<p>如在 Book 2 的 <a href="/book_2_pipeline/#Rasterizing">Rasterizing</a> 中所属，光栅化后的单位是 <code>pre-pixles</code> ，Warp 中的四个线程会被分给一个 <code>pre-pixels</code> 。对于一些没有真正覆盖三角形的 Pixels 而言，它们的颜色并无意义，因此虽然它们在 pre-pixels 中但并不会有线程去计算它们的颜色，这也就造成了 Warp 中线程的浪费。这种性能浪费会比较常见的出现在狭长的三角形中，如下示意图所示：<br>
<img src="/book_3_problems/pipeline_rasterizing03_.gif" alt="Thin Triangles 造成的性能浪费"></p>
<h1 id="Reference"><a class="header-anchor" href="#Reference">#</a>Reference</h1>
<p><a href="http://simonschreibt.de/gat/renderhell-book3/">Render Hell – Book III | Simon schreibt.</a></p>
]]></content>
      <tags>
        <tag>GPU</tag>
      </tags>
  </entry>
  <entry>
    <title>《Render Hell》 第四部分 解决方法</title>
    <url>/book_4_solutions/</url>
    <content><![CDATA[<h1 id="Sorting"><a class="header-anchor" href="#Sorting">#</a>Sorting</h1>
<p>对于多个 Meshes，多个 Materials 的情况，可以通过排序将同一种 Material 的 Mesh 放在一起减少 Render State 的切换，如下所示：<br>
<img src="/book_4_solutions/optimisation_sorting_01.gif" alt="重新排序以减少 State 切换"></p>
<h1 id="Batching"><a class="header-anchor" href="#Batching">#</a>Batching</h1>
<p>在排序完，仍然存在的问题是多个 Meshes 会造成多个 Commands 进而引起过多开销。因此应当将多个 Meshes 结合在一起，通过一次 Draw Call 进行渲染。在调用 API 前将多个 Meshes 合并在一起的过程称为 <code>Batch</code> 。</p>
<p><img src="/book_4_solutions/optimisation_batching_02.gif" alt="Batching"></p>
<div class="note info simple"><p>在 RAM 中将多个 Mesh 结合在一起也是需要开销的（CPU 时间），因此通常选择将静态的 Mesh，如房子，石头等Batch 在一起。 而如果是一系列运动的子弹，因为它们的位置每帧都会移动，所以相当于每帧都需要重新 <code>Batch</code>，这会造成巨大的开销。</p>
</div>
<p>Batch 还会造成一个额外的问题。在未进行 Batch 时，如果一个 Mesh 在 Frustum 外，则它会被直接 Cull 掉。但如果将多个 Meshes Batch 成一个大 Mesh，则即使只有其中的一小部分处在 Frustum 中，整个 Mesh 仍然会被认为需要被绘制。</p>
<p>因此相对于 <code>Batching</code>，更好的解决方法是 <code>Instancing</code></p>
<h1 id="Instancing"><a class="header-anchor" href="#Instancing">#</a>Instancing</h1>
<p><code>Instancing</code> 是提交一次 Mesh，但会告知 GPU 绘制多次，并在 RAM 中指定每次绘制时需要用的状态。因此 <code>Instancing</code> 适合同一个 Mesh 要多次绘制的情况，如草，子弹。示意图如下所示：<br>
<img src="/book_4_solutions/20200129181033200.gif" alt="Instancing"></p>
<h1 id="Multi_Material_Shader"><a class="header-anchor" href="#Multi_Material_Shader">#</a>Multi-Material Shader</h1>
<p>为了解决 Book3 中提到的 <a href="/book_3_problems/#Meshes_and_Multi-Materials">Meshes and Multi-Materials</a> 导致多 Draw Call 的问题，一个解决思路是将多个材质需要用到的数据合并在一个 Shader 中，相当于将多个 Material 合并成了一个 Material。</p>
<p>如原来每个材质需要一个 Diffuse Texture，一个 Normal Texture，可以使用一个包含两个 Diffuse Texture， 两个 Normal Texture 的材质来取代原来的两个材质，并在 Shader 中通过 Blending 的方式达成之前的效果。</p>
<div class="note warning simple"><p>这种实现方式虽然减少了 DrawCall 的数量，但会造成 Blending 的大量额外开销，因此最终性能可能反而下降。</p>
</div>
<h1 id="Skinned_Meshes"><a class="header-anchor" href="#Skinned_Meshes">#</a>Skinned Meshes</h1>
<p>如之前的描述，如果需要通过 Batch 来解决多个子弹占用多个 Draw Call 的问题，则会因为子弹需要每帧移动而造成每帧重新 Batch，这会造成巨大的开销。</p>
<p>有一个解决思路是将所有这些子弹结合在一起作为 Skinned Mesh，其中每个子弹作为一个 Bone，在后续的帧中只需要更新这些 Bone 的位置，而不需要重新进行合并。</p>
<div class="note warning simple"><p>当出现了子弹增加或减少时，则需要重新合并 Mesh</p>
</div>
<h1 id="Reference"><a class="header-anchor" href="#Reference">#</a>Reference</h1>
<p><a href="http://simonschreibt.de/gat/renderhell-book4/">Render Hell – Book IV | Simon schreibt.</a></p>
]]></content>
      <tags>
        <tag>GPU</tag>
      </tags>
  </entry>
  <entry>
    <title>《Head First 设计模式》 Ch 02 观察者模式</title>
    <url>/ch_02_the_observer_pattern/</url>
    <content><![CDATA[<p>观察者模式（Observer Pattern）定义了一种一对多的依赖关系，当被观察者（<code>Subject</code>）的状态发生变化时，它将会通知观察者们（<code>Observers</code>）进行某种操作。</p>
<p>例如我们希望定义温度计和压力计，在天气信息发生变化时自动更新，而非自己反复的查询是否天气信息有发生变化。这里天气信息就是被观察者，而温度计和压力计就是观察者。</p>
<h1 id="代码示例"><a class="header-anchor" href="#代码示例">#</a>代码示例</h1>
<h2 id="观察者及被观察者接口"><a class="header-anchor" href="#观察者及被观察者接口">#</a>观察者及被观察者接口</h2>
<figure class="highlight cs"><figcaption><span>被观察者</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ISubject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RegisterObserver</span>(<span class="params">IObserver observer</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">UnregisterObserver</span>(<span class="params">IObserver observer</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NotifyObservers</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>观察者</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IObserver</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params">ISubject subject</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="观察者实现"><a class="header-anchor" href="#观察者实现">#</a>观察者实现</h2>
<figure class="highlight cs"><figcaption><span>温度计</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TemperatureObserver</span> : <span class="title">IObserver</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> ISubject subject;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TemperatureObserver</span>(<span class="params">ISubject subject</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">        <span class="keyword">this</span>.subject.RegisterObserver(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params">ISubject subject</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        WeatherData weatherData = subject <span class="keyword">as</span> WeatherData;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注意这里我们是从主动从被观察者那里去获取数据</span></span><br><span class="line">        <span class="keyword">if</span> (weatherData != <span class="literal">null</span>)</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Temperature is &quot;</span> + weatherData.Temperature);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>压力计</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PressureObserver</span> : <span class="title">IObserver</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> ISubject subject;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PressureObserver</span>(<span class="params">ISubject subject</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">        <span class="keyword">this</span>.subject.RegisterObserver(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params">ISubject subject</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        WeatherData weatherData = subject <span class="keyword">as</span> WeatherData;</span><br><span class="line">        <span class="keyword">if</span> (weatherData != <span class="literal">null</span>)</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Pressure is &quot;</span> + weatherData.Pressure);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="被观察者实现"><a class="header-anchor" href="#被观察者实现">#</a>被观察者实现</h2>
<figure class="highlight cs"><figcaption><span>天气数据</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WeatherData</span> : <span class="title">ISubject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;IObserver&gt; observersList;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> Temperature &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> Humidity &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> Pressure &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeatherData</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        observersList = <span class="keyword">new</span> List&lt;IObserver&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">NotifyObservers</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        observersList.ForEach(o =&gt; o.Update(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RegisterObserver</span>(<span class="params">IObserver o</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        observersList.Add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UnregisterObserver</span>(<span class="params">IObserver o</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        observersList.Remove(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">measurementsChanged</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        NotifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetMeasurements</span>(<span class="params"><span class="built_in">float</span> temperature, <span class="built_in">float</span> humidity, <span class="built_in">float</span> pressure</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.Temperature = temperature;</span><br><span class="line">        <span class="keyword">this</span>.Humidity = humidity;</span><br><span class="line">        <span class="keyword">this</span>.Pressure = pressure;</span><br><span class="line">        measurementsChanged();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="测试及结果"><a class="header-anchor" href="#测试及结果">#</a>测试及结果</h1>
<figure class="highlight cs"><figcaption><span>测试代码</span></figcaption><table><tr><td class="code"><pre><span class="line">WeatherData weatherData = <span class="keyword">new</span> WeatherData();</span><br><span class="line">TemperatureObserver temperatureObserver = <span class="keyword">new</span> TemperatureObserver(weatherData);</span><br><span class="line">PressureObserver pressureObserver = <span class="keyword">new</span> PressureObserver(weatherData);</span><br><span class="line"></span><br><span class="line">weatherData.SetMeasurements(<span class="number">30</span>, <span class="number">20</span>, <span class="number">10</span>);</span><br><span class="line">weatherData.SetMeasurements(<span class="number">20</span>, <span class="number">40</span>, <span class="number">5</span>);</span><br><span class="line">weatherData.UnregisterObserver(temperatureObserver);</span><br><span class="line">weatherData.SetMeasurements(<span class="number">10</span>, <span class="number">50</span>, <span class="number">15</span>);</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/ch_02_the_observer_pattern/2019-01-15-23-20-09.png" alt="观察者模式运行结果"></p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>《Computer Networks and Internets》 Ch 01 介绍与概览</title>
    <url>/ch_01_introduction_and_overview/</url>
    <content><![CDATA[<h1 id="Growth_Of_Computer_Networking"><a class="header-anchor" href="#Growth_Of_Computer_Networking">#</a>Growth Of Computer Networking</h1>
<p>计算机网络正在持续的爆炸性成长。在 1970 年代它只是一个非常小范围的研究课题，在 1980 年也只有几个网站，但到现在计算机网络f经成为了生活中的一部分。</p>
<h1 id="Why_Networking_Seems_Complex"><a class="header-anchor" href="#Why_Networking_Seems_Complex">#</a>Why Networking Seems Complex</h1>
<p>计算机网络是一个高速发展的领域。</p>
<p>对于初学者而言，他可能让人觉得很困惑，因为并没有一个最基础的理论来将计算机网络的所有部分联系在一起。有许多组织都定义了计算机网络的标准，而有时这些标准相互之间并不兼容。</p>
<p>计算机网络用语也并没有一个统一的标准，许多组织都定义过自己一套用语规范，这又很容易让初学者们感到困惑。</p>
<h1 id="The_Five_Key_Aspects_of_Networking"><a class="header-anchor" href="#The_Five_Key_Aspects_of_Networking">#</a>The Five Key Aspects of Networking</h1>
<p>计算机网络包括五个关键领域：</p>
<ol>
<li>网络应用与网络编程</li>
<li>数据通信</li>
<li>分组交换与网络技术</li>
<li>TCP/IP 的网络互联</li>
<li>附加的网络概念和技术</li>
</ol>
<h2 id="Network_Applications_and_network_programming"><a class="header-anchor" href="#Network_Applications_and_network_programming">#</a>Network Applications and network programming</h2>
<p>用户使用网络服务和设施是基于一个安装在电脑上的应用程序，这个程序可以与其他电脑上的程序通过网络进行交流。网络程序有很多种类，包括邮件，下载器，游览器等。</p>
<p>所有这些程序都是构建在一个单一的、共享的网络上，因此开发者可以使用同一套接口来进行开发。</p>
<p>计算机网络的知识可以帮助开发者更好的开发网络应用。</p>
<h2 id="Data_Communications"><a class="header-anchor" href="#Data_Communications">#</a>Data Communications</h2>
<p>数据通信是电子工程的主要领域，它基于一些物理现象来传输数据，是一个较底层的方法。</p>
<p>因为数据通信是基于物理概念，所以乍看起来它与计算机网络的学习并没有太深的关系，但数据通信中的一些关键概念影响了通信规范的制定。例如调制中带宽的概念直接影响了网络的吞吐量。</p>
<p>数据通信也引入了复用的概念，即多个来源的数据可以被组合在一起通过一个共享的媒介进行传输，然后再分开传递给不同的目的地。</p>
<p>数据通信包含了许多底层的细节，它为计算机网络构建了基础。</p>
<h2 id="Packet_Switching_And_Networking_Technologies"><a class="header-anchor" href="#Packet_Switching_And_Networking_Technologies">#</a>Packet Switching And Networking Technologies</h2>
<p>通信网络已经从早期的依赖于物理点线进行的点对点电报或电话系统转换为一个通信电路。早期的通过线连接已经转换为通过电交换。</p>
<p><code>分组交换（Packet switching）</code>从最底层的方式改变了网络，是现代网络的基础。多个信息发送者不再需要依赖于专用网络，通过分组交换他们可以通过一个共享的网络来传输数据。</p>
<p>分组交换将数据分为许多小块，称为包 <code>Packets</code>，包中都包含一个目的地的信息。网络中的设备都包含了如何抵达其他地址的信息，当设备接收到一个包后他会解析包中的数据，并选择一个通路将其送给正确的目的地。</p>
<p>因为计算机网络在设计时有许多不同的需求，例如速度，距离，经济成本等，有许多分组交换技术被发明出来，他们针对不同的需求在细节上存在着一些差异。</p>
<h2 id="Internetworking_with_TCP_IP"><a class="header-anchor" href="#Internetworking_with_TCP_IP">#</a>Internetworking with TCP/IP</h2>
<p>在一段时间内，许多研究者都致力于找到一个可以满足所有需求的分组交换技术。在 1973 年，Vinton Cerf 和 Pobert Kahn 认为不存在一种分组交换技术可以满足所有的需求，因此他们致力于将不同的技术融合在一起。他们发展了一系列的标准，并最终成为了<code>TCP/IP协议族(TCP/IP Internet Protocol)</code>(简称为 TCP/IP)。这最终成为了全球网络的基础，并称为计算机网络的一个重要组成部分。</p>
<p>TCP/IP 标准成功的一个重要原因是它宽容的异质性。TCP/IP 使用了一个虚拟的方法来定义网络不相关的包和网络不相关的检测方法。因此即使分组技术在持续的发展，TCP/IP 也始终可以与新的分组技术共存。</p>
<h2 id="Additional_Networking_Concepts_And_Technologies"><a class="header-anchor" href="#Additional_Networking_Concepts_And_Technologies">#</a>Additional Networking Concepts And Technologies</h2>
<p>除了构造网络的硬件和协议，还有大量的其他技术为网络提供了不同偶给你能。</p>
<p>例如 <code>软件定义网络(Software Defined Networking(SDN))</code> 允许管理者定义和控制网络， <code>物联网(Internet to Thing)</code> 让嵌入式系统可以通过网络进行交流。</p>
<h1 id="Public_and_Private_Parts_Of_The_Internet"><a class="header-anchor" href="#Public_and_Private_Parts_Of_The_Internet">#</a>Public and Private Parts Of The Internet</h1>
<p>计算机网络是由 <code>公共网络(Public network)</code> 和 <code>私人网络(Private network)</code> 构成的。</p>
<h2 id="Public_Network"><a class="header-anchor" href="#Public_Network">#</a>Public Network</h2>
<p>公共网络是 <code>服务提供商(Service Provider)</code> 所拥有的服务，服务商会将服务提供给任何订阅了的个人或组织。这里的公共指的是大众都可以订阅这个服务，并不意味着公共网络传输的数据是被暴露在外，所有人都可以获取的。</p>
<h2 id="Private_Network"><a class="header-anchor" href="#Private_Network">#</a>Private Network</h2>
<p>私人网络是指网络的使用权被限制在一个组间。如果服务商将服务租赁给了个人或公司，个人或公司仅在自己的范围内使用这个网络，那么它就是私人网络。</p>
<p>私人网络按其大小可以被分类为以下四种：</p>
<ol>
<li>消费者(Consumer)</li>
<li>小型办公室/家庭办公室(Small Office/Home Office, SOHO)</li>
<li>中小型商用(small-medium Business, SMB)</li>
<li>大型企业(Large enterprise)</li>
</ol>
<h1 id="Networks_Interoperability_And_Standards"><a class="header-anchor" href="#Networks_Interoperability_And_Standards">#</a>Networks, Interoperability, And Standards</h1>
<p>通信至少包含两个实体，信息发送者和信息接受者。为了保证网络中的所有实体都能正确的交流，需要有一个共同的标准。</p>
<p>使用 <code>互操作性(Interoperability)</code> 来表示两个实体是否可以无误的彼此通信。</p>
<p>为了保证实体可以正确的彼此交流，他们需要遵守一系列共同的规则，这些规则被称为 <code>通信协议(Communication protocol/Network protocol/Protocol)</code>。</p>
<ol>
<li>在通信发生错误的时候需要采取的行动也是由通信协议来指定。</li>
<li>通信协议可以是底层的，例如电压或信号的制定，也可以高层的，如软件传输的数据类型。</li>
</ol>
<h1 id="Protocol_Suites_And_Layering_Models"><a class="header-anchor" href="#Protocol_Suites_And_Layering_Models">#</a>Protocol Suites And Layering Models</h1>
<p>为了避免重复工作，每个协议应该只负责其他协议未包含的部分，因此协议的制定并非是相互独立的。将一系列合作的协议称为 <code>族(Suites/Families)</code>。族中的每个协议都只关注通信中的一部分，族中的所有协议组合起来就覆盖了整个通信的所有方面。</p>
<p>一个用来将协议分组的基本抽象是 <code>分组模型(Layering model)</code>，分组模型将所有通信问题分为几个部分，每个部分称为 <code>一层(Layer)</code>。将所有协议按层分组帮助协议的设计者和实现者有效的控制了问题的复杂度，因为他们只需要关注与网络的一个方面即可。</p>
<p>下图展示了因特网的分组模型，也成为 TCP/IP 分组模型：</p>
<p><img src="/ch_01_introduction_and_overview/2019-11-22-20-21-21.png" alt="TCP/IP分组模型"></p>
<h2 id="Layer_1_Physical"><a class="header-anchor" href="#Layer_1_Physical">#</a>Layer 1: Physical</h2>
<p>物理层的协议指定了传输媒介和相关硬件的细节。电子相关的属性，频率，信号等都属于物理层。</p>
<h2 id="Layer_2_Network_Interface_MAC"><a class="header-anchor" href="#Layer_2_Network_Interface_MAC">#</a>Layer 2: Network Interface(MAC)</h2>
<p>网络接口层的协议指定了对网络通信的细节以及网络硬件与 Layer3（Internet 层）的通信细节。硬件地址，网络地址，网络可支持的最大包数据以及传输媒介的协议等信息都属于网络接口层。</p>
<p>TCP/IP 的设计者将这一层命名为 <code>网络接口层（Network Interface）</code>，但一些协会更喜欢称为 <code>数据链路层（Data Link）</code>，工业界又喜欢称为 <code>媒介访问控制层（Media Access Control, MAC）</code></p>
<h2 id="Layer_3：Internet"><a class="header-anchor" href="#Layer_3：Internet">#</a>Layer 3：Internet</h2>
<p>因特网层是因特网的基础。因特网地址结构，因特网包的结构，大包拆分成小包的方式，报告错误的方式都属于因特网层。</p>
<h2 id="Layer_4：Transport"><a class="header-anchor" href="#Layer_4：Transport">#</a>Layer 4：Transport</h2>
<p>传输层协议提供了计算机上的一个应用与另一台机器上的应用交流的方法。如接收端接收数据的最大速率，避免网络堵塞的方法，和保证接收端按顺序接收数据的技术都属于传输层。</p>
<h2 id="Layer_5_Application"><a class="header-anchor" href="#Layer_5_Application">#</a>Layer 5: Application</h2>
<p>应用层的协议指定了通过网络交流的应用传输的数据信息的格式和意义，以及需要执行的步骤。如邮件，文件传输，语音电话等的实现都属于应用层。</p>
<h1 id="How_Data_passes_Through_Layers"><a class="header-anchor" href="#How_Data_passes_Through_Layers">#</a>How Data passes Through Layers</h1>
<p>分组模型并不只是为了帮助理解协议，协议的实现满足某一层协议的输出需要匹配相邻层协议的输入。</p>
<p>如下图展示了两台电脑通过网络传输数据的过程：</p>
<p><img src="/ch_01_introduction_and_overview/2019-11-22-20-59-21.png" alt="网络数据传输过程"></p>
<p>一号电脑是数据的发送方，二号电脑是数据的接收方。数据从一号电脑的应用层逐渐向下传递，通过接口层进入网络，在进入网络并传输后，通过二号电脑的接口层传入，再向上逐渐传递到应用层。</p>
<h1 id="Headers_And_Layers"><a class="header-anchor" href="#Headers_And_Layers">#</a>Headers And Layers</h1>
<p>每一层的协议为了保证数据被正确的传递都进行了一些计算。在发送端的每一层中都将一些额外的信息加到了数据包中，对应的，在接受段的每一层中都将解析并移除这些额外的信息。</p>
<p>这些被协议额外加入的数据称为<code>数据头(header)</code>。以发送端为例，数据头是在数据逐层向下的过程中一步步被加入的，即传输层增加一些数据头，网络层增加一些数据头，接口层增加一些数据头。因此最终的数据会如下图所示，最靠近原始数据的数据头是最早被添加的：</p>
<p><img src="/ch_01_introduction_and_overview/2019-11-22-21-08-20.png" alt="网络数据头添加"></p>
<ul>
<li>虽然图中每个被添加的数据头大小看起来相同，但实际上都不是一个固定的大小。</li>
</ul>
<h1 id="ISO_And_The_OSI_Seven_Layer_Reference_Model"><a class="header-anchor" href="#ISO_And_The_OSI_Seven_Layer_Reference_Model">#</a>ISO And The OSI Seven Layer Reference Model</h1>
<p>在因特网模型发展的过程中，有两个组织定义了一个替代的参考模型，称为<code>开放式系统互联参考七层模型(Open Systems Interconnection Seven-Layer Reference Model)</code>，简称为<code>OSI模型</code>。</p>
<p>这两个组织分别是<code>国际标准化组织（International Organization for Standardization）</code>，简称为<code>ISO</code>和<code>国际电信联盟（International Telecommunications Union）(ITU)</code>中的电信标准部门。</p>
<p><code>OSI</code>协议图如下：</p>
<p><img src="/ch_01_introduction_and_overview/2019-11-22-23-01-16.png" alt="OSI协议"></p>
<p>TCP/IP 协议比 OSI 协议更为高效合理，发展和部署 OSI 协议的工作已经被停滞。许多工作者目前在扩展 OSI 协议的定义来让其符合 TCP/IP，基本是让 Network 层匹配 Internet 层，然后再在 Session 层和 Presentation 层增加一些支持协议。</p>
<p>虽然许多工程师和商业部门知道<code>OSI协议</code>不如<code>TCP/IP协议</code>高效，但他们依然处于某些原因在坚持使用。</p>
<h1 id="Remainder_Of_The_Text"><a class="header-anchor" href="#Remainder_Of_The_Text">#</a>Remainder Of The Text</h1>
<p>书的剩下部分将分为五个部分，基本对应与 1.3 节中提到的五个重要领域。</p>
<p>第一部分介绍网络应用和网络编程</p>
<p>第二部分介绍数据通信和信息传输</p>
<p>第三部分介绍分组交换以及包数据，另外也会介绍一些网络的基本分类，如局域网和广域网</p>
<p>第四部分将介绍 TCP/IP 协议族</p>
<p>第五部分介绍剩下的一些网络相关的技术</p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《Head First 设计模式》 Ch 01 策略模式</title>
    <url>/ch_01_the_strategy_pattern/</url>
    <content><![CDATA[<p>策略模式（Strategy Pattern）是使用一些独立的类来各自封装一些通用的算法，这些封装类都继承自同一个接口，该接口定义了算法。对于调用类来说，它只保存一个算法接口的对象，而这个对象所指代的特定算法则可以在运行时动态更改。</p>
<p>例如有我们有一个项目需要描述鸭子，可能有 50 种不同的鸭子都派生自基类 <code>Duck</code>，鸭子一共有三种飞行方式。这时候我们如果将某一种特定的飞行方式写在基类中，则不是使用这个飞行方式的所有派生鸭子都需要对该方法重写。如果我们不在基类中定义，而在各个派生类中实现，则可能多个有相同飞行方式的鸭子派生类都有相同的代码定义飞行方式，这造成了代码冗余。</p>
<p>所以我们可以使用策略模式，将三种飞行方式都派生自接口 <code>FlyBehavior</code>，并在鸭子基类中定义变量<code>FlyBehavior</code>，然后在派生类中选择各自需要的飞行方式即可。</p>
<h1 id="代码示例"><a class="header-anchor" href="#代码示例">#</a>代码示例</h1>
<h2 id="算法接口及实现类"><a class="header-anchor" href="#算法接口及实现类">#</a>算法接口及实现类</h2>
<figure class="highlight cs"><figcaption><span>飞行方法接口</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IFlyBehavior</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Fly</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>飞行方法实现</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FlyNoWay</span> : <span class="title">IFlyBehavior</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fly</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Can not fly&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FlyWithRocket</span> : <span class="title">IFlyBehavior</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fly</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Fly with rocket&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FlyWithWings</span> : <span class="title">IFlyBehavior</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fly</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Fly with wings&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="环境类"><a class="header-anchor" href="#环境类">#</a>环境类</h2>
<figure class="highlight cs"><figcaption><span>鸭子基类</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Duck</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IFlyBehavior flyBehavior;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Duck</span>()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">disPlay</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PerformFly</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        flyBehavior.Fly();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlyBehavior</span>(<span class="params">IFlyBehavior fb</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        flyBehavior = fb;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>鸭子派生类</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BlackDuck</span> : <span class="title">Duck</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BlackDuck</span>() : <span class="title">base</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        setFlyBehavior(<span class="keyword">new</span> FlyWithWings());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">disPlay</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;I am a black duck&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RubberDuck</span> : <span class="title">Duck</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RubberDuck</span>() : <span class="title">base</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        setFlyBehavior(<span class="keyword">new</span> FlyNoWay());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">disPlay</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;I am a rubber duck&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="测试及结果"><a class="header-anchor" href="#测试及结果">#</a>测试及结果</h1>
<figure class="highlight cs"><figcaption><span>测试代码</span></figcaption><table><tr><td class="code"><pre><span class="line">RubberDuck rubberDuck = <span class="keyword">new</span> RubberDuck();</span><br><span class="line">rubberDuck.disPlay();</span><br><span class="line">rubberDuck.PerformFly();</span><br><span class="line"></span><br><span class="line">BlackDuck blackDuck = <span class="keyword">new</span> BlackDuck();</span><br><span class="line">blackDuck.disPlay();</span><br><span class="line">blackDuck.PerformFly();</span><br><span class="line">blackDuck.setFlyBehavior(<span class="keyword">new</span> FlyWithRocket());</span><br><span class="line">blackDuck.PerformFly();</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<p><img src="/ch_01_the_strategy_pattern/2019-01-15-00-12-45.png" alt="策略模式运行结果"></p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>《Head First 设计模式》 Ch 03 装饰模式</title>
    <url>/ch_03_the_decorator_pattern/</url>
    <content><![CDATA[<p>装饰模式（Decorator Pattern） 提供了一个动态增加一个类功能的方法，主要实现思想是通过一个作为装饰者的类（<code>Decorators</code>）包裹被装饰类（<code>Component</code>）（装饰类以及被装饰类都有共同的基类），<code>Decorators</code> 会在 <code>Component</code> 类的某一个函数执行前或后进行一些操作，进而达到增加功能的作用。</p>
<p>装饰模式主要实现了“代码应该对扩展功能开放而对于修改关闭”的面向对象原则，它在增加新功能的前提下，不需要改动既有的代码，只需要增加新的 <code>Decorators</code> 并且包含既有的 <code>Component</code> 即可。</p>
<p>例如我们要计算一杯咖啡的价格，而这杯咖啡的价格还会受到额外的配料的影响，比如要加抹茶需要额外支付 0.2 元，加奶泡需要额外支付 0.3 元等。如果对各种配料都各自使用一个类来表示，则会存在较多的类需要维护，而且一旦配料发生变化等，还需要进行代码修改。而使用装饰模式则可以将原始的咖啡作为被装饰类，而所有的配料都是装饰类，则配料的更改仅需要增加或删除外部的装饰类即可。</p>
<h1 id="代码示例"><a class="header-anchor" href="#代码示例">#</a>代码示例</h1>
<h2 id="装饰类及被装饰类基类"><a class="header-anchor" href="#装饰类及被装饰类基类">#</a>装饰类及被装饰类基类</h2>
<figure class="highlight cs"><figcaption><span>被装饰类基类</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Beverage</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">string</span> description = <span class="string">&quot;UnKnown Beverage&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">string</span> <span class="title">getDescription</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">double</span> <span class="title">Cost</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>装饰类基类</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">CondimentDecorator</span> : <span class="title">Beverage</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> Beverage beverage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CondimentDecorator</span>(<span class="params">Beverage beverage</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.beverage = beverage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note info simple"><p>注意装饰类基类继承自被装饰类，并存有一个被装饰类的变量，因为装饰类需要在被装饰类操作的基础上进行一定额外的操作，所以它需要存有对被装饰类的引用，同时对外部而言调用者而言，它与被装饰类相同。</p>
</div>
<h2 id="被装饰类实现"><a class="header-anchor" href="#被装饰类实现">#</a>被装饰类实现</h2>
<figure class="highlight cs"><figcaption><span>浓咖啡</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Espresso</span> : <span class="title">Beverage</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Espresso</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        description = <span class="string">&quot;Espresson&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">double</span> <span class="title">Cost</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.99</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="装饰类实现"><a class="header-anchor" href="#装饰类实现">#</a>装饰类实现</h2>
<figure class="highlight cs"><figcaption><span>酱油</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Soy</span> : <span class="title">CondimentDecorator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Soy</span>(<span class="params">Beverage beverage</span>) : <span class="title">base</span>(<span class="params">beverage</span>)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">getDescription</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> beverage.getDescription() + <span class="string">&quot;, Soy&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">double</span> <span class="title">Cost</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.30</span> + beverage.Cost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>奶泡</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Whip</span> : <span class="title">CondimentDecorator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Whip</span>(<span class="params">Beverage beverage</span>) : <span class="title">base</span>(<span class="params">beverage</span>)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">getDescription</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> beverage.getDescription() + <span class="string">&quot;, Whip&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">double</span> <span class="title">Cost</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.30</span> + beverage.Cost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>抹茶</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Mocha</span> : <span class="title">CondimentDecorator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mocha</span>(<span class="params">Beverage beverage</span>) : <span class="title">base</span>(<span class="params">beverage</span>)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">getDescription</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> beverage.getDescription() + <span class="string">&quot;, Mocha&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">double</span> <span class="title">Cost</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.20</span> + beverage.Cost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="测试及结果"><a class="header-anchor" href="#测试及结果">#</a>测试及结果</h1>
<figure class="highlight cs"><figcaption><span>测试代码</span></figcaption><table><tr><td class="code"><pre><span class="line">Espresso espresso = <span class="keyword">new</span> Espresso();</span><br><span class="line">Console.WriteLine(espresso.getDescription() + <span class="string">&quot; Cost: &quot;</span> + espresso.Cost());</span><br><span class="line"></span><br><span class="line">Beverage doubleMochaWhipEspresso = <span class="keyword">new</span> Mocha(<span class="keyword">new</span> Mocha(<span class="keyword">new</span> Whip(espresso)));</span><br><span class="line">Console.WriteLine(doubleMochaWhipEspresso.getDescription() + <span class="string">&quot; Cost: &quot;</span> + doubleMochaWhipEspresso.Cost());</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/ch_03_the_decorator_pattern/2019-01-15-23-43-20.png" alt="装饰模式运行结果"></p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>《Head First 设计模式》 Ch 04 工厂模式</title>
    <url>/ch_04_the_factory_pattern/</url>
    <content><![CDATA[<p>工厂模式是为了将对象的实例化与对对象的操作解耦。因为有时我们会根据情况的不同，实例化出对象的不同版本，而我们不希望这种对于情况的判断与逻辑代码耦合在一起。</p>
<p>工厂模式有三个较为常见的变种，简单工厂模式，工厂方法模式，抽象工厂模式，下面会以创建披萨为例子来具体说明。</p>
<h1 id="简单工厂模式"><a class="header-anchor" href="#简单工厂模式">#</a>简单工厂模式</h1>
<p>简单工厂模式严格意义上并不是一个设计模式，只是它被太多人的使用，所以需要单独进行说明。</p>
<p>简单工厂模式会定义一个工厂类来进行对象的实例化。</p>
<p>我们定义一个披萨商店，他将会管理披萨产出的整个流程。我们为了将披萨的生产与之后的操作（如切披萨）拆分开，需要定义一个简单披萨工厂。</p>
<h2 id="代码示例"><a class="header-anchor" href="#代码示例">#</a>代码示例</h2>
<h3 id="披萨类及其实例化"><a class="header-anchor" href="#披萨类及其实例化">#</a>披萨类及其实例化</h3>
<figure class="highlight cs"><figcaption><span>披萨基类</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Pizza</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> Cheese cheese = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">protected</span> Sauce sauce = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">protected</span> Onion onion = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">prepare</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Bake for 25 minutes at 350&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cut</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Cutting the pizza into diagonal slices&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">box</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Place pizza in official PizzaStore box&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Debug</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">        Console.WriteLine(name);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Cheese is &quot;</span> + (cheese != <span class="literal">null</span> ? cheese.ToString() : <span class="string">&quot;Null&quot;</span>));</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Sauce is &quot;</span> + (sauce != <span class="literal">null</span> ? sauce.ToString() : <span class="string">&quot;Null&quot;</span>));</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Onion is &quot;</span> + (onion != <span class="literal">null</span> ? onion.ToString() : <span class="string">&quot;Null&quot;</span>));</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>披萨实现</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CheesePizza</span> : <span class="title">Pizza</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">prepare</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cheese = <span class="keyword">new</span> Cheese();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SaucePizza</span> : <span class="title">Pizza</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">prepare</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        sauce = <span class="keyword">new</span> Sauce();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="披萨商店与简单披萨工厂"><a class="header-anchor" href="#披萨商店与简单披萨工厂">#</a>披萨商店与简单披萨工厂</h3>
<figure class="highlight cs"><figcaption><span>披萨商店</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PizzaStore</span></span><br><span class="line">&#123;</span><br><span class="line">    SimplePizzaFactory simpleFactory;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PizzaStore</span>(<span class="params">SimplePizzaFactory factory</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.simpleFactory = factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">orderPizza</span>(<span class="params"><span class="built_in">string</span> type</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Pizza pizza = simpleFactory.createPizza(type);</span><br><span class="line">        pizza.prepare();</span><br><span class="line">        pizza.bake();</span><br><span class="line">        pizza.cut();</span><br><span class="line">        pizza.box();</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>简单披萨工厂</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SimplePizzaFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">createPizza</span>(<span class="params"><span class="built_in">string</span> type</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Pizza pizza = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (type.Equals(<span class="string">&quot;cheese&quot;</span>))</span><br><span class="line">            pizza = <span class="keyword">new</span> CheesePizza();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (type.Equals(<span class="string">&quot;sauce&quot;</span>))</span><br><span class="line">            pizza = <span class="keyword">new</span> SaucePizza();</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试及结果"><a class="header-anchor" href="#测试及结果">#</a>测试及结果</h2>
<figure class="highlight cs"><figcaption><span>测试代码</span></figcaption><table><tr><td class="code"><pre><span class="line">PizzaStore store = <span class="keyword">new</span> PizzaStore(<span class="keyword">new</span> SimplePizzaFactory());</span><br><span class="line">Pizza pizza = store.orderPizza(<span class="string">&quot;cheese&quot;</span>);</span><br><span class="line">pizza.Debug();</span><br></pre></td></tr></table></figure>
<p>运行结果:<br>
<img src="/ch_04_the_factory_pattern/2019-01-20-21-24-34.png" alt="简单工厂运行结果"></p>
<h1 id="工厂方法模式"><a class="header-anchor" href="#工厂方法模式">#</a>工厂方法模式</h1>
<p>简单工厂提供了一个类来作为对象实例化的工厂，它解决了对象实例化与逻辑代码耦合的问题，但没有提供扩写这个工厂的方法。例如上例中，我们需要在工厂中增加新的产品只能扩写原先的工厂类，但这可能会造成单个工厂类的逻辑过于复杂。<br>
而工厂方法模式则是通过一个抽象函数来作为工厂，在各派生类中重写该函数，达到工厂的扩写。</p>
<p>我们定义一个抽象的披萨商店，并在其中定义一个抽象函数 <code>createPizza</code>，并在披萨商店的继承类中重写这个方法来演示工厂方法模式。</p>
<div class="note warning simple"><p>注意这个例子完全可以通过建立多个简单工厂来实现，这里只是为了说明工厂方法模式的结构。</p>
</div>
<h2 id="代码示例-2"><a class="header-anchor" href="#代码示例-2">#</a>代码示例</h2>
<h3 id="抽象披萨商店及实例化"><a class="header-anchor" href="#抽象披萨商店及实例化">#</a>抽象披萨商店及实例化</h3>
<figure class="highlight cs"><figcaption><span>抽象披萨商店</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">PizzaStore</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">orderPizza</span>(<span class="params"><span class="built_in">string</span> type</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Pizza pizza = createPizza(type);</span><br><span class="line">        pizza.prepare();</span><br><span class="line">        pizza.bake();</span><br><span class="line">        pizza.cut();</span><br><span class="line">        pizza.box();</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Pizza <span class="title">createPizza</span>(<span class="params"><span class="built_in">string</span> type</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>纽约披萨商店</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NYPizzaStore</span> : <span class="title">PizzaStore</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> Pizza <span class="title">createPizza</span>(<span class="params"><span class="built_in">string</span> type</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Pizza pizza = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (type.Equals(<span class="string">&quot;cheese&quot;</span>))</span><br><span class="line">            pizza = <span class="keyword">new</span> NYStyleCheesePizza();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (type.Equals(<span class="string">&quot;sauce&quot;</span>))</span><br><span class="line">            pizza = <span class="keyword">new</span> NYStyleSausePizza();</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>芝加哥披萨商店</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ChicagoPizzaStore</span> : <span class="title">PizzaStore</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> Pizza <span class="title">createPizza</span>(<span class="params"><span class="built_in">string</span> type</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Pizza pizza = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (type.Equals(<span class="string">&quot;cheese&quot;</span>))</span><br><span class="line">            pizza = <span class="keyword">new</span> ChicagoStyleCheesePizza();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (type.Equals(<span class="string">&quot;sauce&quot;</span>))</span><br><span class="line">            pizza = <span class="keyword">new</span> ChicagoStyleSaucePizza();</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="不同风格的披萨实现"><a class="header-anchor" href="#不同风格的披萨实现">#</a>不同风格的披萨实现</h3>
<figure class="highlight cs"><figcaption><span>纽约风格的披萨</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NYStyleCheesePizza</span> : <span class="title">Pizza</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">prepare</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cheese = <span class="keyword">new</span> NYCheese();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NYStyleSausePizza</span> : <span class="title">Pizza</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">prepare</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        sauce = <span class="keyword">new</span> NYSauce();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>芝加哥风格的披萨</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ChicagoStyleCheesePizza</span> : <span class="title">Pizza</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">prepare</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cheese = <span class="keyword">new</span> ChicagoCheese();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ChicagoStyleSaucePizza</span> : <span class="title">Pizza</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">prepare</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        sauce = <span class="keyword">new</span> ChicagoSauce();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试及结果-2"><a class="header-anchor" href="#测试及结果-2">#</a>测试及结果</h2>
<figure class="highlight cs"><figcaption><span>测试代码</span></figcaption><table><tr><td class="code"><pre><span class="line">PizzaStore store = <span class="keyword">new</span> ChicagoPizzaStore();</span><br><span class="line">Pizza pizza = store.orderPizza(<span class="string">&quot;cheese&quot;</span>);</span><br><span class="line">pizza.Debug();</span><br><span class="line">store = <span class="keyword">new</span> NYPizzaStore();</span><br><span class="line">pizza=store.orderPizza(<span class="string">&quot;cheese&quot;</span>);</span><br><span class="line">pizza.Debug();</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/ch_04_the_factory_pattern/2019-01-23-00-29-35.png" alt="工厂方法模式运行结果"></p>
<h1 id="抽象工厂模式"><a class="header-anchor" href="#抽象工厂模式">#</a>抽象工厂模式</h1>
<p>工厂方法模式中的工厂的多态性依赖于继承，比如我们定义的<code>PizzaStore</code>中有个抽象函数<code>createPizza</code>，这个抽象函数即为一个工厂，在各个派生类中我们去重写这个抽象函数，通过继承来实现不同的工厂。而在抽象工厂模式中，我们将定义一个工厂接口，在需要工厂的接口中类中存储这个接口，并在不同的情况下用这个接口不同的实现，来达到工厂的多态性。</p>
<p>另外在工厂方法模式中，因为是通过重写函数的方法来实现，所以一个工厂只能产出一个产品。而在抽象工厂模式中，在一个抽象工厂中却能定义多个制造产品的函数，进而一个抽象工厂可以提供多个产品。</p>
<div class="note info simple"><p>生产出一个产品还是多个产品并不是抽象工厂模式和工厂方法模式的主要区别，他们的主要区别在于工厂方法模式是通过继承来实现工厂的多态，而抽象工厂模式是通过组合。</p>
</div>
<p>我们定义一个披萨原料工厂，来体现抽象工厂模式。</p>
<h2 id="代码示例-3"><a class="header-anchor" href="#代码示例-3">#</a>代码示例</h2>
<h3 id="披萨原料工厂接口及实现"><a class="header-anchor" href="#披萨原料工厂接口及实现">#</a>披萨原料工厂接口及实现</h3>
<figure class="highlight cs"><figcaption><span>披萨原料工厂接口</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">PizzaIngredientFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Onion <span class="title">createOnion</span>()</span>;</span><br><span class="line">    <span class="function">Sauce <span class="title">createSauce</span>()</span>;</span><br><span class="line">    <span class="function">Cheese <span class="title">createCheese</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>纽约披萨原料商店</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NYPizzaIngredientFactory</span> : <span class="title">PizzaIngredientFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cheese <span class="title">createCheese</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NYCheese();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Onion <span class="title">createOnion</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NYOnion();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sauce <span class="title">createSauce</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NYSauce();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>芝加哥披萨原料商店</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ChicagoPizzaIngredientFactory</span> : <span class="title">PizzaIngredientFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cheese <span class="title">createCheese</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ChicagoCheese();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Onion <span class="title">createOnion</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ChicagoOnion();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sauce <span class="title">createSauce</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ChicagoSauce();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note info simple"><p>可以看到在抽象工厂的实现时，用到了工厂方法模式。抽象工厂模式与工厂方法模式并非互斥的两种模式，工厂方法模式实际上内嵌与抽象工厂模式中</p>
</div>
<h3 id="抽象披萨商店及实例化-2"><a class="header-anchor" href="#抽象披萨商店及实例化-2">#</a>抽象披萨商店及实例化</h3>
<figure class="highlight cs"><figcaption><span>抽象披萨商店</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">PizzaStore</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">orderPizza</span>(<span class="params"><span class="built_in">string</span> type</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Pizza pizza = createPizza(type);</span><br><span class="line">        pizza.prepare();</span><br><span class="line">        pizza.bake();</span><br><span class="line">        pizza.cut();</span><br><span class="line">        pizza.box();</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Pizza <span class="title">createPizza</span>(<span class="params"><span class="built_in">string</span> type</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>纽约披萨商店</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> Pizza <span class="title">createPizza</span>(<span class="params"><span class="built_in">string</span> item</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Pizza pizza = <span class="literal">null</span>;</span><br><span class="line">    PizzaIngredientFactory ingredientFactory = <span class="keyword">new</span> NYPizzaIngredientFactory();</span><br><span class="line">    <span class="keyword">if</span> (item == <span class="string">&quot;cheese&quot;</span>)</span><br><span class="line">        pizza = <span class="keyword">new</span> CheesePizza(ingredientFactory);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (item == <span class="string">&quot;sauce&quot;</span>)</span><br><span class="line">        pizza = <span class="keyword">new</span> SaucePizza(ingredientFactory);</span><br><span class="line">    <span class="keyword">return</span> pizza;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>芝加哥披萨商店</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ChicagoPizzaStore</span> : <span class="title">PizzaStore</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> Pizza <span class="title">createPizza</span>(<span class="params"><span class="built_in">string</span> item</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Pizza pizza = <span class="literal">null</span>;</span><br><span class="line">        PizzaIngredientFactory ingredientFactory = <span class="keyword">new</span> ChicagoPizzaIngredientFactory();</span><br><span class="line">        <span class="keyword">if</span> (item == <span class="string">&quot;cheese&quot;</span>)</span><br><span class="line">            pizza = <span class="keyword">new</span> CheesePizza(ingredientFactory);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (item == <span class="string">&quot;sauce&quot;</span>)</span><br><span class="line">            pizza = <span class="keyword">new</span> SaucePizza(ingredientFactory);</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note info simple"><p>注意，这里披萨商店的实现，仍然是通过工厂方法模式。只是在<code>createPizza</code>函数中会实例化一个抽象工厂，并将其传递给对应的<code>Pizza</code>对象</p>
</div>
<h3 id="披萨类及其实例化-2"><a class="header-anchor" href="#披萨类及其实例化-2">#</a>披萨类及其实例化</h3>
<p>在披萨类的实例化中，我们使用了抽象工厂模式，披萨的实例化会包含一个披萨原料的抽象工厂，通过不同的披萨原料工厂来取得不同风味的披萨</p>
<figure class="highlight cs"><figcaption><span>披萨基类</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Pizza</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> Cheese cheese = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">protected</span> Sauce sauce = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">protected</span> Onion onion = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">prepare</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Bake for 25 minutes at 350&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cut</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Cutting the pizza into diagonal slices&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">box</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Place pizza in official PizzaStore box&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Debug</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">        Console.WriteLine(name);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Cheese is &quot;</span> + (cheese != <span class="literal">null</span> ? cheese.ToString() : <span class="string">&quot;Null&quot;</span>));</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Sauce is &quot;</span> + (sauce != <span class="literal">null</span> ? sauce.ToString() : <span class="string">&quot;Null&quot;</span>));</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Onion is &quot;</span> + (onion != <span class="literal">null</span> ? onion.ToString() : <span class="string">&quot;Null&quot;</span>));</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>披萨实现</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CheesePizza</span> : <span class="title">Pizza</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> PizzaIngredientFactory ingredientFactory = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CheesePizza</span>(<span class="params">PizzaIngredientFactory ingredientFactory</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.ingredientFactory = ingredientFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">prepare</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cheese = ingredientFactory.createCheese();</span><br><span class="line">        onion = ingredientFactory.createOnion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SaucePizza</span> : <span class="title">Pizza</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> PizzaIngredientFactory ingredientFactory = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SaucePizza</span>(<span class="params">PizzaIngredientFactory ingredientFactory</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.ingredientFactory = ingredientFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">prepare</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        sauce = ingredientFactory.createSauce();</span><br><span class="line">        onion = ingredientFactory.createOnion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试及结果-3"><a class="header-anchor" href="#测试及结果-3">#</a>测试及结果</h2>
<figure class="highlight cs"><figcaption><span>测试代码</span></figcaption><table><tr><td class="code"><pre><span class="line">PizzaStore pizzaStore = <span class="keyword">new</span> NYPizzaStore();</span><br><span class="line">Pizza pizza = pizzaStore.OrderPizza(<span class="string">&quot;cheese&quot;</span>);</span><br><span class="line">pizza.Debug();</span><br><span class="line">Console.WriteLine(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line">pizzaStore = <span class="keyword">new</span> ChicagoPizzaStore();</span><br><span class="line">pizza = pizzaStore.OrderPizza(<span class="string">&quot;cheese&quot;</span>);</span><br><span class="line">pizza.Debug();</span><br></pre></td></tr></table></figure>
<p>运行结果：<br>
<img src="/ch_04_the_factory_pattern/2019-01-24-01-01-50.png" alt="抽象工厂模式运行结果"></p>
<h1 id="Reference"><a class="header-anchor" href="#Reference">#</a>Reference</h1>
<p><a href="https://dzone.com/articles/factory-method-vs-abstract">https://dzone.com/articles/factory-method-vs-abstract</a><br>
<a href="https://stackoverflow.com/questions/5739611/differences-between-abstract-factory-pattern-and-factory-method">https://stackoverflow.com/questions/5739611/differences-between-abstract-factory-pattern-and-factory-method</a></p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>《Computer Networks and Internets》 Ch 05 信息传输概览</title>
    <url>/ch_05_overview_of_data_communications/</url>
    <content><![CDATA[<h1 id="Introduction"><a class="header-anchor" href="#Introduction">#</a>Introduction</h1>
<p>这一章主要是分析通过物理媒介进行信息传递的方法，例如线，光和无线电波等。这些方式在一些细节上不同，但所有方法的基本原理是相通的。</p>
<h1 id="The_Essence_Of_Data_Communications"><a class="header-anchor" href="#The_Essence_Of_Data_Communications">#</a>The Essence Of Data Communications</h1>
<p>数据通信是物理，数学和电气工程三个学科的混合领域。</p>
<ol>
<li>物理：信息的传输依赖于物理媒介</li>
<li>数学：信息需要数字化</li>
<li>电气工程：数据传输需要构建现实中的通信系统</li>
</ol>
<h1 id="Motivation_And_Scope_Of_The_Subject"><a class="header-anchor" href="#Motivation_And_Scope_Of_The_Subject">#</a>Motivation And Scope Of The Subject</h1>
<p>在数据通信领域有三个重要的点，他们定义了数据通信的一些领域</p>
<ol>
<li>
<p>传输的数据可以是任意类型的</p>
<p>传输的数据并不一定是存储在计算机中的<code>bit</code>数据，也可以是从现实世界中获取的信息，如音频和视频。</p>
</li>
<li>
<p>数据的传输依赖于物理系统</p>
<p>数据是基于物理现象来传输的，例如电，电磁波。了解为什么这些物理现象可以被用来传输数据是很重要的。另外也需要理解物理系统的限制，因为这些限制引发的问题和这些问题如何被检测并解决。</p>
</li>
<li>
<p>多个来源的信息可以共享基础媒介来传输</p>
<p>媒介共享在计算机网络中是一个重要角色。了解哪些基础设施是可以被共享的，共享他们的优缺点，以及基于共享而设计的通信模型是很重要的。</p>
</li>
</ol>
<h1 id="The_Conceptual_Pieces_Of_A_Communications_System"><a class="header-anchor" href="#The_Conceptual_Pieces_Of_A_Communications_System">#</a>The Conceptual Pieces Of A Communications System</h1>
<p>每一个来源都需要一些方法来获取信息，调整信息为用于传播的模式，使用共享的物理媒介来传输信息。同时也需要一些方法从物理媒介中抽取出每条信息的目的地地址，并将信息传送给目标地址。整个过程如下图所示：</p>
<p><img src="/ch_05_overview_of_data_communications/2019-11-25-23-24-24.png" alt="数据通信简单模型"></p>
<p>上图是一个非常简化的模型，在实际操作中，在传输数据前，必须对数据进行数字化，也需要加入一些额外的信息防止错误发生。如果考虑到隐私，可能还需要进行加密。在使用共享媒介时，还要保证有方法可以分辨出每条信息且他们不会相互干扰。</p>
<p>为了解释数据通信的每个部分，工程师们制订了一个概念框架来说明通信系统中的每个小主题是如何联系在一起的，概念框架如下图所示：</p>
<p><img src="/ch_05_overview_of_data_communications/2019-11-25-23-28-26.png" alt="概念框架"></p>
<h1 id="The_Subtopics_Of_Data_Communications"><a class="header-anchor" href="#The_Subtopics_Of_Data_Communications">#</a>The Subtopics Of Data Communications</h1>
<p>上一节中的概念框架图中的每一部分都代表了数据通信中的一个小主题。这一节中简单介绍了图中的一些术语，之后的几章中会在对每一部分进行详细说。</p>
<ol>
<li>
<p><code>数据来源(Information Sources)</code>可以是模拟数据或者数字电路。这一部分的关键内容包括信号的特征（<code>振幅(Amplitude)</code>，<code>频率(Frequency)</code>，<code>相位(Phase)</code>），周期性与非周期性，以及模拟信息和数字信息的转换。</p>
</li>
<li>
<p><code>信源编码与解码(Source Encoder and Decoder)</code>。一旦信息被数字化后，信息就可以被转换，这一部分的关键内容包括数据压缩以及压缩后对于传输的影响</p>
</li>
<li>
<p><code>加密与解密(Encryptor and Decryptor)</code>。为了保护信息和保证其可信度，在信息传送前需要进行加密，在接收后需要解密。这一部分的关键内容包括密码学技术与算法。</p>
</li>
<li>
<p><code>信道编码与解码(Channel Encoder and Decoder)</code>。信道编码是用来检测也纠正传输错误。这一部分的关键内容包括检测和限制错误，以及实际应用的技术，如奇偶校验(parity checking)等。</p>
</li>
<li>
<p><code>复用与解复用(Multiplexor and Demultiplexor)</code>。复用是指让多个来源的信息结合在一起并保证可以使用同一个媒介传输的方式。这一部分的关键内容包括介绍同时复用以及分时复用的技术。</p>
</li>
<li>
<p><code>调制与解调(Modulator and Demodulator)</code>。调制是指让用电磁波传递信息的方式。这一部分的关键内容包括模拟信息与数字信息的调制方式，用来进行调制与解调的设备。</p>
</li>
<li>
<p><code>物理通道与传输(Physical Channel and Transmission)</code>。 这一部分的关键内容包括传输媒介与传输方式（如并行，串行），带宽，噪声，干扰，信道容量，</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《Head First 设计模式》 Ch 05 单例模式</title>
    <url>/ch_05_the_singleton_pattern/</url>
    <content><![CDATA[<p>单例模式(Singleton Pattern)可能是最简单，也是被应用最为广泛的设计模式。单例模式保证一个类只会存在一个实例，并且提供了一个公共的接口来访问该实例。</p>
<h1 id="代码示例"><a class="header-anchor" href="#代码示例">#</a>代码示例</h1>
<figure class="highlight cs"><figcaption><span>单例模式</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">object</span> lockObj = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">lock</span> (lockObj)</span><br><span class="line">                    <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">                        instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Constructor the Singleton&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里使用一个<code>lockObj</code>是为了保证多线程安全，如果有多个线程在同一时间第一次调用<code>Instance</code>，则可能存在两个线程都进入了<code>instance == null</code>的分支，这就会造成两次实例化，所以我们需要通过加锁来保证线程安全。但如果我们将锁直接加在第一个<code>If</code>外，则每次调用<code>Instance</code>都有一个加锁的过程，所以这里选择在第一个 If 内加锁，锁内再次检查保证只会有一次实例化。</p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>《Computer Networks and Internets》 Ch 06 信源与信号</title>
    <url>/ch_06_information_sources_and_signals/</url>
    <content><![CDATA[<h1 id="Introduction"><a class="header-anchor" href="#Introduction">#</a>Introduction</h1>
<p>这一章讲解释<code>信源（Information Sources）</code>和携带信息的信号的特征。</p>
<h1 id="Information_Sources"><a class="header-anchor" href="#Information_Sources">#</a>Information Sources</h1>
<p>数据通信理论更关注于较低层次的通信系统，因此信源可以是任意来源，不仅仅是包括计算机上层的键盘，鼠标，摄像机，传感器等等也是信源。</p>
<h1 id="Analog_And_Digital_Signals"><a class="header-anchor" href="#Analog_And_Digital_Signals">#</a>Analog And Digital Signals</h1>
<p>数据通信由两种信息组成，模拟信息或数字信息。模拟信号是由一个连续变化的函数构成，而数字信号则是跳跃变换的，在某个时间点会从一个强度突然跳跃至另一个强度。下图为模拟信号和数字信号的图解，左为模拟信号，右为数字信号：</p>
<p><img src="/ch_06_information_sources_and_signals/2019-11-28-09-30-33.png" alt="模拟信号与数字信号"></p>
<h1 id="Periodic_And_Aperiodic_Signals"><a class="header-anchor" href="#Periodic_And_Aperiodic_Signals">#</a>Periodic And Aperiodic Signals</h1>
<p>信号也可分类为周期信号与非周期信号。周期信号顾名思义表示信号会重复出现，反之为非周期信号。下图为周期信号：</p>
<p><img src="/ch_06_information_sources_and_signals/2019-11-28-09-33-10.png" alt="周期信号"></p>
<h1 id="Sine_Waves_And_Signal_Characteristics"><a class="header-anchor" href="#Sine_Waves_And_Signal_Characteristics">#</a>Sine Waves And Signal Characteristics</h1>
<p>数据通信通常使用 <code>Sin函数</code> 来表示信号。之所以选择 Sin 函数，是因为许多自然界产生的信号强度与时间的函数都是 Sin，如麦克风获取声音后的输出信号，电磁波的信号等。</p>
<p>Sin 函数波的信号特性由四个部分组成：</p>
<ol>
<li>频率（Frequency）：单位时间（通常是秒）内震动出现的个数。单位为赫兹（Hertz,Hz）</li>
<li>波幅（Amplitude）：信号最强和最弱两处的差</li>
<li>相位（Phase）：Sin 拨开始的地方与参考时间（一般是时间 0）的偏移</li>
<li>波长（Wavelength）：一个周期的波在传播媒介中要传播的距离。</li>
</ol>
<p>其中波长是一个媒介相关的特性，与波在媒介中传播的速度相关。剩下的三个特性都可以用数学公式表示，如波$A\sin (\omega t+\phi)$，其中$A$表示波幅，$\phi$表示相位，$\omega$表示频率，当$\omega=2\pi$时表示频率为 1。</p>
<p>数据通信用的波一般都是高频的，一秒内出现百万个循环，对于这种频率的波，通常用兆赫兹（Megahertz,MHz）来表示。高频率波的单位如下表显示：</p>
<p><img src="/ch_06_information_sources_and_signals/2019-11-28-09-53-47.png" alt="频率单位"></p>
<h1 id="Composite_Signals"><a class="header-anchor" href="#Composite_Signals">#</a>Composite Signals</h1>
<p>之前图中的波称为<code>简单信号(Simple Signal)</code>，因为只是以单一的 Sin 波组成。但在实际中，多数信号都是以<code>组合信号（Composite Signal）</code>的形式出现。如下图所示，就是两个不同频率及振幅的波组合成一个新的波。</p>
<p><img src="/ch_06_information_sources_and_signals/2019-11-28-09-57-46.png" alt="组合波"></p>
<h1 id="The_Importance_of_Composite_Signals_And_Sine_Functions"><a class="header-anchor" href="#The_Importance_of_Composite_Signals_And_Sine_Functions">#</a>The Importance of Composite Signals And Sine Functions</h1>
<p><code>调制（Modulation）</code>出来的信号通常是组合信号。数学家<code>傅里叶(Fourier)</code>发现可以从组合信号中解析出他的组成部分，即简单信号。大部分的通信系统都是用组合信号来携带信息，在接收端再将信息拆分成简单信号。</p>
<h1 id="Time_And_Frequency_Domain_Representations"><a class="header-anchor" href="#Time_And_Frequency_Domain_Representations">#</a>Time And Frequency Domain Representations</h1>
<p>之前的所有信号波的图片的 $X轴$ 都是时间，称为信号在<code>时域(Time Domain)</code>内表示。</p>
<p>还有一种表现方式是信号在<code>频域(Frequency Domain)</code>内的表示，如之前 $\sin (2\pi t)$ 和 $0.5\times \sin(2\pi 2 t)$ 组成的复合信号，也用下图在频域中表示：</p>
<p><img src="/ch_06_information_sources_and_signals/2019-11-28-10-29-27.png" alt="频域表示"></p>
<p>图中的 $x轴$ 为频率，$y$ 轴仍为波幅。可以看到在频率为 $1$ 和 $2$ 的地方有波形出现，正好对应函数 $\sin (2\pi t)$ 和 $0.5\times \sin(2\pi 2 t)$ 的频率，波形的振幅也与函数所表现的振幅相同。</p>
<p>因为每个简单波在频域图的 $x$ 轴上只占据一点，所以频域图用来表示复合波形是简单易读的。</p>
<h1 id="Bandwidth_Of_An_Analog_Signal"><a class="header-anchor" href="#Bandwidth_Of_An_Analog_Signal">#</a>Bandwidth Of An Analog Signal</h1>
<p>在计算机网络中经常听到<code>网络带宽(Network Bandwidth)</code>一词，关于网络带宽会在之后的章节中解释，这里先介绍一个相关概念，<code>模拟带宽(Analog Bandwidth)</code>。一个模拟信号的带宽是这个信号最高频率与最低频率之间的差，单位为$Hz$。如一个信号的频域图如下图所示，那么这个信号的贷款为$4KHz$，因为这个信号的最高频率为$5KHz$，最低频率为$1KHz$。</p>
<p><img src="/ch_06_information_sources_and_signals/2019-11-28-10-39-12.png" alt="模拟带宽"></p>
<p>如果一个信号是用频域图来表示的，那么可以很快的看出这个信号的带宽。</p>
<h1 id="Digital_Signals_And_Signal_Levels"><a class="header-anchor" href="#Digital_Signals_And_Signal_Levels">#</a>Digital Signals And Signal Levels</h1>
<p>数字信号是由一系列的固定的 <code>有效电平（Valid Level）</code> 组成且在任意的时间点信号都处于这些有效电平之一。</p>
<p>一些系统用电压来表示数字信号，如电压为 $5V$ 表示信号 1，电压为 $0V$ 表示信号 0，如下图所示：</p>
<p><img src="/ch_06_information_sources_and_signals/2019-11-28-10-55-33.png" alt="电压信号1"></p>
<p>如果将电压划分更细，如电压 $5V$ 表示信号 $11$，电压 $2V$ 表示 $10$，电压 $-2V$ 表示 $01$，电压 $-5V$ 表示 $00$，如下图所示：</p>
<p><img src="/ch_06_information_sources_and_signals/2019-11-28-10-57-06.png" alt="电压信号2"></p>
<p>可以看到传输相同数据(8 bit)的情况下，第二种方法花费的时间少了一半，称第二种方法的 <code>数据速率（Data Rate）</code> 翻倍。因为第一种方法一次只能表示 1bit 的数据（1 或 0），而第二种方法表示了 2bit 的数据。如果电压细分为 $2^n$ 种，则一次性能表达 $n$ bit 的数据。</p>
<p>理论上可以将电压切分到非常小（如分割成一百万个电平等级）达到每次都能传递许多信息的目的，但是实际中因为电力系统并不能区分过小的电压间隔，所以只将电压分割为几个电平等级。</p>
<h1 id="Baud_And_Bits_Per_Second"><a class="header-anchor" href="#Baud_And_Bits_Per_Second">#</a>Baud And Bits Per Second</h1>
<p>数据速率有两方面决定，一方面是上一节中提到的信号有效电平数量（决定每次可以携带多少数据），另一方面是每个有效电平持续的时间。</p>
<p>如上一节中的例子，假设将 1 秒切分为 8 部分（即一秒电平可以变换 8 次）传递数据，一共有 2 个电平等级。那么一秒传递 8 bit 的数据。如果改为有 4 个电平等级，则每次能传递 2 个 bit,一秒传递 16 bit 的数据。如果仍然保持两个电平等级，但将一秒切分为 16 个部分，则同样一秒传递 16 bit 的数据。</p>
<p>将一秒电平可以变换的次数用波特表示(Baud)，波特数越高则一个电平持续的时间越短，如给每个电平 0.001 的持续时间，那么这个系统工作在 1000 Baud。理论上来说波特可以非常高，让每秒传递的数据增多，但是实际上当一个信号持续时间过短系统是无法检测到该信号的。每秒传递的数据量可用以下公式表示:</p>
<p>$$<br>
\text{bits per second} = baud \times \lfloor \log_2{(levels)} \rfloor<br>
$$</p>
<h1 id="Converting_A_Digital_Signal_To_Analog"><a class="header-anchor" href="#Converting_A_Digital_Signal_To_Analog">#</a>Converting A Digital Signal To Analog</h1>
<p>根据傅里叶定理，任意的波形都可以由一系列 Sin 波组成，其中每个 Sin 波都有各自的振幅，相位与频率。</p>
<p>数字信号也可以看作是一个跃变的波形，但是这样的跃变波形需要由无数个 Sin 波才能构成，所以从工程角度来说不可能实现，毕竟不可能找出无数个信源。</p>
<p>所以在实际运用中只能妥协，运用越多的 Sin 波形，最终的复合波形就越接近跃变波形。下图展示了用模拟信号来表示数字信号的过程，图（a）是数字信号，显示为跃变波形，图（b）是用一个 Sin 波来表示，图（C）是两个 Sin 波，图（d）是用三个 Sin 波。可以看到 Sin 波的数量越多，波形越接近跃变信号，而且新增的波的频率越来越高。</p>
<p>一般而言，用三个 Sin 波模拟即可。</p>
<p><img src="/ch_06_information_sources_and_signals/2019-11-28-13-45-45.png" alt="数字电路转模拟电路"></p>
<h1 id="The_Bandwidth_Of_A_Digital_Signal"><a class="header-anchor" href="#The_Bandwidth_Of_A_Digital_Signal">#</a>The Bandwidth Of A Digital Signal</h1>
<p>如之前所述，求一个信号的带宽是求其最大频率和最小频率的差值。对于数字信号来说可以先将他转换为模拟信号（多个 Sin 信号），然后找出最高频率的 Sin 以及最低频率的 Sin。但是如上节所述，数字信号的跃变波形是由无数的 Sin 组成，且 Sin 的频率越来越高，即数字信号的最高频率是无限，因此数字信号的带宽为无限。</p>
<h1 id="Synchronization_And_Agreement_About_Signals"><a class="header-anchor" href="#Synchronization_And_Agreement_About_Signals">#</a>Synchronization And Agreement About Signals</h1>
<p>在实际运用中，发送端和接收端必须保证信号的每次变换间隔是一样的（可看作采样频率），这个问题称为<code>同步问题（Synchronization）</code>，下图展示了发送端和接收端以不同的频率采样会引发的问题，接收端的采样频率（10 次每秒）高于发送端（8 次每秒）。</p>
<p><img src="/ch_06_information_sources_and_signals/2019-11-28-13-57-49.png" alt="采样错误"></p>
<p>在实际运用中，这种频率的差异可能非常小，如误差为$10_{-8}$秒，那可能出现了几百万个 Bit 后才发生一次错误。但在传输速率在亿个 Bit 每秒时，这种细微的差距也会引发大量的错误数据。</p>
<h1 id="Line_Coding"><a class="header-anchor" href="#Line_Coding">#</a>Line Coding</h1>
<p>如上节所述，在数据传递的过程中可能会因为同步问题导致一些错误的发生，有一些方法来帮助避免这些错误的发生。一种是真正发送信号前，先发送一系列的特定模式的字节，如重复的 0 或者重复的 1，通过这些字节来帮助接收端校准，另一种方法称为<code>信道编码（Line Coding）</code>，在这种方式下会添加一些额外的字符来保证接收端能确切的解析出真实的数据。</p>
<p>如一个电路能产生 5V，0，-5V 的电压，可以将 -5V  定义为一个数据的开始。因此 0 信号表示为$-5V, 0V$，1 信号表示为$-5V, 5V$。接收端知道在-5V 信号后才是真正的数据。这种方式的图解如下：</p>
<p><img src="/ch_06_information_sources_and_signals/2019-11-28-14-26-48.png" alt="信道编码例子"></p>
<p>因为信道编码引入了额外的数据来保证真实数据的准确性，所以信道编码降低了真实数据的传输速率。</p>
<h1 id="Manchester_Encoding_Used_In_Computer_Networks"><a class="header-anchor" href="#Manchester_Encoding_Used_In_Computer_Networks">#</a>Manchester Encoding Used In Computer Networks</h1>
<p><code>曼彻斯特编码(Manchester Encoding)</code>是一种信道编码，在计算机网络中曼彻斯特编码主要用于以太网中，所以十分重要。</p>
<p>对电路来说，检测信号的变化比检测信号的强度要简单。因此曼彻斯特编码将 1 信号定义为从零电压跳转为正电压，将 0 信号定义为从正电压跳转为零电压。而且曼彻斯特采样的时间为时间周期的中间，因此可以对于连续 0 或者连续 1 的情况，信号有时间可以回到之前的电压水平，保证下一次的检测正常。曼彻斯特编码的图示如下：</p>
<p><img src="/ch_06_information_sources_and_signals/2019-11-28-14-44-39.png" alt="曼彻斯特编码"></p>
<p>曼彻斯特编码还有一个变化，叫做<code>差分曼彻斯特编码（Differential Manchester Encoding）</code>，这种方法用相对变化来表示信号，0 信号表示信号发生了变化，1 信号表示信号没有变化。采样时间为时间周期点。差分曼彻斯特编码如下图所示：</p>
<p><img src="/ch_06_information_sources_and_signals/2019-11-28-14-48-53.png" alt="差分曼彻斯特编码"></p>
<p>差分曼彻斯特编码的好处在于，即使信号的大小意外的翻转了也不会发生错误（如 5V 变为-5V 之类）。</p>
<h1 id="Converting_An_Analog_Signal_To_Digital"><a class="header-anchor" href="#Converting_An_Analog_Signal_To_Digital">#</a>Converting An Analog Signal To Digital</h1>
<p>模拟信号为了进一步的被处理，必须转换为数字信号。一般转换为数字信号有两种方式,一是 <code>脉冲编码调制(Pulse Code Modulation，PCM)</code>，另一种是 <code>差分调制(Delta modulation)</code></p>
<p>脉冲编码调制是以相同时间间隔去测量模拟信号，并根据模拟信号的强度，将其转换为数字信号，整个流程分为三步，如下图框出的部分所示：</p>
<p><img src="/ch_06_information_sources_and_signals/2019-11-30-21-29-15.png" alt="脉冲编码调制"></p>
<p>以相同时间间隔去测量模拟信号，即为采样，所以上图中的第一部分称为采样。有的时候为了避免采样时间点的信号突变导致的采样失真，会在相关时间点附近多采样几次，然后取平均值作为最后采样值。第二部分称为量化（Quantization），量化是根据模拟信号的强度，将其转换为一个 Int 值，如下图所示，第一个采样的数值，会被量化为 2，第二个采样的数值会被量化为 3，第三个采样的数值会被量化为 6。</p>
<p><img src="/ch_06_information_sources_and_signals/2019-11-30-21-34-25.png" alt="量化"></p>
<p>量化后的数据会被进一步编码为之后需要的数据格式（根据需求而定）。</p>
<p>差分调制的主题思想与脉冲编码调制类似，不同的是在量化阶段他不是对每个采样值进行量化，而是对当前采样值与上一个采样值的差距进行量化。这样节省了许多用来表示数据的 Bit 数，但是缺点在于一旦之前的数据出现了误差，后面的所有数据都会收到影响。</p>
<h1 id="The_Nyquist_Theorem_And_Sampling_Rate"><a class="header-anchor" href="#The_Nyquist_Theorem_And_Sampling_Rate">#</a>The Nyquist Theorem And Sampling Rate</h1>
<p>应该以怎样的采样频率进行采样是数据通信中需要考虑的问题，如果采样频率过低，那么采样出来的信号与原信号可能有较大差异，如果采样频率过高，则会产生大量的数据。</p>
<p>奈奎斯特（Nyquist Theorem）定理提出：为了避免采样失真，采样的最低频率应该是原信号最高频率的两倍。</p>
<h1 id="Nyquist_Theorem_And_Telephone_System_Transmission"><a class="header-anchor" href="#Nyquist_Theorem_And_Telephone_System_Transmission">#</a>Nyquist Theorem And Telephone System Transmission</h1>
<p>经过实验，0 到 4000HZ 的频率基本就能提供人所能接受的音频质量。因此根据奈奎斯特频率，语音信号的采样频率应该是 8000HZ，既一秒有 8000 个采样点。通话系统所用的 PCM 标准规定，每个采样信号用 8-bit 数据表示，所以每秒通话产生的数据量为：</p>
<p>$$<br>
8000 \frac{samples}{second} \times 8 \frac{bits}{sample} = 64000 \frac{bits}{second}<br>
$$</p>
<p>因此电话系统每秒传递 64000-bits 数据（64Kbps），也可见采样频率越高，可携带的数据也就越多。</p>
<h1 id="Nonlinear_Encoding"><a class="header-anchor" href="#Nonlinear_Encoding">#</a>Nonlinear Encoding</h1>
<p>当每个采样点只能用 8 个比特来表示时，线性的 PCM 编码无法很好的体现声音，因为 8 个 Bit 只能表现 256 个值，且线性表示的话，无论是非常低频或高频的部分还是人身大部分集中的部分都用了一样的采样间隔，这造成了浪费。而非线性编码，解决了这个问题，他更关注与人耳最敏感的频率。数字电话标准中有两种非线性编码：</p>
<ol>
<li>$\alpha-law$，主要是欧洲及中国采用的编码方式</li>
<li>$\mu-law$，主要是北美和日韩采用的编码方式</li>
</ol>
<p>$\mu-law$ 算法的主要优势在于它覆盖了更广的频率范围（例如可以更好的还原特别高的声音），缺点在于对于一些弱信号有更多的失真。$\alpha-law$ 在弱信号的失真上有优势，但动态范围更小。</p>
<p>对于国际电话，需要有 $\alpha-law$ 和 $\mu-law$ 之间的转化。</p>
<h1 id="Encoding_And_Data_Compression"><a class="header-anchor" href="#Encoding_And_Data_Compression">#</a>Encoding And Data Compression</h1>
<p><code>数据压缩(Data Compression)</code> 是用来减少用来表达数据的 bit 数的方法。对于数据通信来说，通常在传输前对数据进行压缩。压缩分为两种类型：<code>有损压缩(Lossy)</code>和<code>无损压缩(Lossless)</code>。</p>
<p>有损压缩则通常用来压缩一些人相关的文件，如图片，视频，音频，这种压缩方式会忽视掉一些人无法精确识别的数据，<code>JPEG</code> 和 <code>MPEG-3(MP3)</code> 都是典型的有损压缩。</p>
<p>无损压缩保证压缩后的数据在解压后与原数据相同，一般用于压缩文档之类的文件。大部分的无损压缩都用了字典技术，即如果一个字符串在文件中重复的出现，将这个字符串存放在字典中，之后的出现只要取字典中的索引值即可。</p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《Head First 设计模式》 Ch 06 命令模式</title>
    <url>/ch_06_the_command_pattern/</url>
    <content><![CDATA[<p>命令模式（Command Pattern）将一个请求封装为一个对象，进而将拥有不同的请求的物体参数化，并且还可以请求排队，打印请求日志，支持可逆操作。</p>
<p>命令模式由抽象命令类、具体命令类、接受者、调用者、客户类，五部分组成。其中接受者为被命令封装的类，调用者存放需要执行的类。</p>
<p>我们以一个远程控制装置作为例子，远程控制装置有两个按钮和一个撤回按钮。我们通过命令模式来将远程控制类与具体需要做的操作（如开灯）解耦。在例子中程序入口即为客户端，远程装置为调用者，灯为接受者，有开灯与关灯两个命令</p>
<h1 id="代码示例"><a class="header-anchor" href="#代码示例">#</a>代码示例</h1>
<h2 id="抽象命令类及实现"><a class="header-anchor" href="#抽象命令类及实现">#</a>抽象命令类及实现</h2>
<figure class="highlight cs"><figcaption><span>抽象命令类</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Command</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Execute</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Undo</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>命令类实现</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LightOffCommand</span> : <span class="title">Command</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Light light;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LightOffCommand</span>(<span class="params">Light light</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.light = light;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        light.Off();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Undo</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        light.On();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LightOnCommand</span> : <span class="title">Command</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Light light;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LightOnCommand</span>(<span class="params">Light light</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.light = light;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        light.On();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Undo</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        light.Off();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NoCommand</span> : <span class="title">Command</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;No command execute&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Undo</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;No command undo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="接受者"><a class="header-anchor" href="#接受者">#</a>接受者</h2>
<figure class="highlight cs"><figcaption><span>灯</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Light</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">On</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;The light is on&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Off</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;The light is off&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="调用者"><a class="header-anchor" href="#调用者">#</a>调用者</h2>
<figure class="highlight cs"><figcaption><span>远程控制</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">RemoteControl</span></span><br><span class="line">&#123;</span><br><span class="line">    Command[] commands;</span><br><span class="line">    Command lastCommond;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RemoteControl</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        commands = <span class="keyword">new</span> Command[<span class="number">2</span>] &#123; <span class="keyword">new</span> NoCommand(), <span class="keyword">new</span> NoCommand() &#125;;</span><br><span class="line">        lastCommond = <span class="keyword">new</span> NoCommand();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetCommand</span>(<span class="params"><span class="built_in">int</span> index, Command command</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        commands[index] = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnButtonClick</span>(<span class="params"><span class="built_in">int</span> index</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        commands[index].Execute();</span><br><span class="line">        lastCommond = commands[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnClickUndo</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        lastCommond.Undo();</span><br><span class="line">        lastCommond = <span class="keyword">new</span> NoCommand();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="客户类"><a class="header-anchor" href="#客户类">#</a>客户类</h2>
<figure class="highlight cs"><figcaption><span>函数入口</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Light light = <span class="keyword">new</span> Light();</span><br><span class="line">    RemoteControl remoteControl = <span class="keyword">new</span> RemoteControl();</span><br><span class="line">    remoteControl.SetCommand(<span class="number">0</span>, <span class="keyword">new</span> LightOnCommand(light));</span><br><span class="line">    remoteControl.SetCommand(<span class="number">1</span>, <span class="keyword">new</span> LightOffCommand(light));</span><br><span class="line">    remoteControl.OnButtonClick(<span class="number">0</span>);</span><br><span class="line">    remoteControl.OnButtonClick(<span class="number">1</span>);</span><br><span class="line">    remoteControl.OnClickUndo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="测试及结果"><a class="header-anchor" href="#测试及结果">#</a>测试及结果</h1>
<p>运行结果：</p>
<p><img src="/ch_06_the_command_pattern/2019-02-02-23-26-25.png" alt="命令模式测试结果"></p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>《Head First 设计模式》 Ch 07 适配器模式和外观模式</title>
    <url>/ch_07_the_adapter_and_facade_patterns/</url>
    <content><![CDATA[<h1 id="适配器模式"><a class="header-anchor" href="#适配器模式">#</a>适配器模式</h1>
<p>适配器模式（Adapter Pattern）将一个类的接口转换为用户想要的另一个接口。适配器模式将原先因为接口不兼容的一些类可以一起工作。</p>
<p>例如我们有已经实现的火鸡类和鸭子类，其中鸭子的鸣叫我们使用<code>Quack</code>，火鸡的鸣叫我们用<code>Goggle</code>，两个接口不相同，但在某些情况下，我们不希望具体区分是火鸡还是鸭子，只希望他们都能叫，这时候就需要用适配器模式，将火鸡或鸭子伪装成同一个类。</p>
<h2 id="代码示例"><a class="header-anchor" href="#代码示例">#</a>代码示例</h2>
<h3 id="鸭子及火鸡抽象接口及实现"><a class="header-anchor" href="#鸭子及火鸡抽象接口及实现">#</a>鸭子及火鸡抽象接口及实现</h3>
<figure class="highlight cs"><figcaption><span>鸭子接口</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Duck</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Quack</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Fly</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>鸭子实现</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MallardDuck</span> : <span class="title">Duck</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fly</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;MallardDuck Fly&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Quack</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;MallardDuck Quack&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>火鸡接口</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Turkey</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Gobble</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Fly</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>火鸡实现</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WildTurkey</span> : <span class="title">Turkey</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fly</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;WildTurkey Fly&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Gobble</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;WildTurkey Gobble&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="适配器类"><a class="header-anchor" href="#适配器类">#</a>适配器类</h3>
<figure class="highlight cs"><figcaption><span>火鸡适配器</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TurkeyAdapter</span> : <span class="title">Duck</span></span><br><span class="line">&#123;</span><br><span class="line">    Turkey turkey;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TurkeyAdapter</span>(<span class="params">Turkey turkey</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.turkey = turkey;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fly</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i != <span class="number">5</span>; ++i)</span><br><span class="line">            turkey.Fly();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Quack</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        turkey.Gobble();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试代码及结果"><a class="header-anchor" href="#测试代码及结果">#</a>测试代码及结果</h2>
<figure class="highlight cs"><figcaption><span>测试代码</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    MallardDuck duck = <span class="keyword">new</span> MallardDuck();</span><br><span class="line">    WildTurkey turkey = <span class="keyword">new</span> WildTurkey();</span><br><span class="line">    TestDuck(duck);</span><br><span class="line">    TestDuck(<span class="keyword">new</span> TurkeyAdapter(turkey));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">TestDuck</span>(<span class="params">Duck duck</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    duck.Fly();</span><br><span class="line">    duck.Quack();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/ch_07_the_adapter_and_facade_patterns/2019-02-03-00-10-27.png" alt="适配器模式运行结果"></p>
<h1 id="外观模式"><a class="header-anchor" href="#外观模式">#</a>外观模式</h1>
<p>外观模式(Facade Pattern)为子系统的一系列接口提供了一个统一的，更高级别的接口以简化外部的调用。</p>
<p>外观模式实际上是遵从于<code>最小知识原则</code>，对一些上层的类来说，它不需要了解下面子系统的具体构成，那么我们就用一个中间层（Facade）来将封装这些子系统，形成一个软解耦。</p>
<p>例如我们有一个家庭影院，在播放电影时我们需要打开 DVD 机，打开投影仪，打开放大器，打开音频协调器等，我们可以用一个<code>Facade</code>来将这些操作都封装起来，对于外部调用者来说仅有开始播放电影及关闭播放电影两步。</p>
<h2 id="代码示例-2"><a class="header-anchor" href="#代码示例-2">#</a>代码示例</h2>
<h3 id="子系统"><a class="header-anchor" href="#子系统">#</a>子系统</h3>
<figure class="highlight cs"><figcaption><span>DVD机器</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DvdPlayer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">On</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="keyword">this</span>.GetType().ToString() + <span class="string">&quot; On&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Off</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="keyword">this</span>.GetType().ToString() + <span class="string">&quot; Off&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>投影仪</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Projector</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">On</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="keyword">this</span>.GetType().ToString() + <span class="string">&quot; On&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Off</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="keyword">this</span>.GetType().ToString() + <span class="string">&quot; Off&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>放大器</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Amplifier</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">On</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="keyword">this</span>.GetType().ToString() + <span class="string">&quot; On&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Off</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="keyword">this</span>.GetType().ToString() + <span class="string">&quot; Off&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>音频协调器</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Tuner</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">On</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="keyword">this</span>.GetType().ToString() + <span class="string">&quot; On&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Off</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="keyword">this</span>.GetType().ToString() + <span class="string">&quot; Off&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Facade"><a class="header-anchor" href="#Facade">#</a>Facade</h3>
<figure class="highlight cs"><figcaption><span>家庭影院外观者</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">HomeTheaderFacade</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Amplifier amplifier = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Tuner tuner = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> DvdPlayer dvdPlayer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Projector projector = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HomeTheaderFacade</span>(<span class="params">Amplifier amplifier, Tuner tuner, DvdPlayer dvdPlayer, Projector projector</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.amplifier = amplifier;</span><br><span class="line">        <span class="keyword">this</span>.tuner = tuner;</span><br><span class="line">        <span class="keyword">this</span>.dvdPlayer = dvdPlayer;</span><br><span class="line">        <span class="keyword">this</span>.projector = projector;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">WatchMovie</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        amplifier.On();</span><br><span class="line">        tuner.On();</span><br><span class="line">        dvdPlayer.On();</span><br><span class="line">        projector.On();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endMovie</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        amplifier.Off();</span><br><span class="line">        tuner.Off();</span><br><span class="line">        dvdPlayer.Off();</span><br><span class="line">        projector.Off();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试代码及结果-2"><a class="header-anchor" href="#测试代码及结果-2">#</a>测试代码及结果</h2>
<figure class="highlight cs"><figcaption><span>测试代码</span></figcaption><table><tr><td class="code"><pre><span class="line">HomeTheaderFacade facade = <span class="keyword">new</span> HomeTheaderFacade(<span class="keyword">new</span> Amplifier(), <span class="keyword">new</span> Tuner(), <span class="keyword">new</span> DvdPlayer(), <span class="keyword">new</span> Projector());</span><br><span class="line">facade.WatchMovie();</span><br><span class="line">Console.WriteLine();</span><br><span class="line">facade.endMovie();</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/ch_07_the_adapter_and_facade_patterns/2019-02-03-13-53-18.png" alt="外观模式运行结果"></p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>《Computer Networks and Internets》 Ch 07 传播媒介</title>
    <url>/ch_07_transmission_media/</url>
    <content><![CDATA[<h1 id="Introduction"><a class="header-anchor" href="#Introduction">#</a>Introduction</h1>
<p>这一章将会给出传播媒介的分类，介绍电信号，无线信号，光信号各自的传输特征。在本章节的最后，介绍了奈奎斯特定律和香农理论，分别给出了理想情况和实际情况下最大的信息传输率。</p>
<h1 id="Guided_And_Unguided_Transmission"><a class="header-anchor" href="#Guided_And_Unguided_Transmission">#</a>Guided And Unguided Transmission</h1>
<p>有两种重要的将传输媒介分类的方法：</p>
<ol>
<li>
<p>按传播路径：使用 <code>有向（Guided）</code> 和 <code>无向（Unguided）</code> 来描述传播路径。像铜线和光纤这种提供特定路径的方式称为有向。而像无线电这样的传输称为无向。工程师会通俗的将这两种称为<code>有线(wired)</code>和<code>无线(wireless)</code>，因此光纤也算在有线的范畴。</p>
</li>
<li>
<p>按能的形式：分为三种类型，在线缆上的 <code>电信号（Electrical Energy）</code>，无线上使用的 <code>无线电（Radio）</code>和光纤中使用的 <code>光（Light）</code>。</p>
</li>
</ol>
<h2 id="Taxonomy_By_Forms_Of_Energy"><a class="header-anchor" href="#Taxonomy_By_Forms_Of_Energy">#</a>Taxonomy By Forms Of Energy</h2>
<p>下图展示了按能的形式分类的图，这个分类图也不是完美的，例如在无线电部分分为<code>陆地无线电（Terrestrial Radio）</code>和<code>卫星无线电（Satellite）</code>，但实际上太空空间站的无线电部分两者都不符合。</p>
<p><img src="/ch_07_transmission_media/2019-12-01-15-46-54.png" alt="能力形式分类"></p>
<h1 id="Background_Radiation_And_Electrical_Noise"><a class="header-anchor" href="#Background_Radiation_And_Electrical_Noise">#</a>Background Radiation And Electrical Noise</h1>
<p>所有用电信号传输的电路都需要两根线，一根用来将信号传递给接收方，一根用来将反馈还给发送方。最简单的电传输方式就是使用两根铜线，每根线都用塑料包裹住，来防止相互之间的电干扰，在两根线外还有一层整个包裹起来，为了人方便使用。</p>
<p>但在线缆形式下有许多改进，这主要是因为电信号有以下特征：</p>
<ol>
<li>环境中有随机的电磁辐射，称为<code>噪音（Noise）</code>，如霓虹灯和电机就会发出随机的辐射。一般来说通信系统在正常运行状态下就会产生少量的噪音。</li>
<li>当电磁辐射遇到金属会被吸收进而产生细微的信号，这些信号会对正常的信号造成干扰。</li>
<li>正因为金属能吸收电磁辐射，所以可以用足够的金属放在噪声源和通信系统间，将其作为<code>防护（Shield）</code>。</li>
</ol>
<h2 id="Twisted_Pair_Copper_Wiring"><a class="header-anchor" href="#Twisted_Pair_Copper_Wiring">#</a>Twisted Pair Copper Wiring</h2>
<p>有三种形式的电缆可以减少电磁噪音的干扰：</p>
<ol>
<li>非屏蔽双绞线（Unshielded Twisted Pair, UTP）</li>
<li>同轴电缆（Coaxial cable）</li>
<li>屏蔽双绞线（Shielded Twisted Pair, STP）</li>
</ol>
<p>第一个形式，非屏蔽双绞线在通信中被广泛应用。如名字一样，双绞线是将两根铜线缠绕在一起的形式，这种相互缠绕的形式比两根线平行排布有更好的抗干扰性。如下图所示，（a）为平行排列，蓝线更接近辐射源，于是它相对于灰线吸收了更多的能量，而在（b）图的缠绕形式中，两根线都各有一部分更靠近辐射源，所以整体来说，两者收到的能量是相同的。</p>
<p><img src="/ch_07_transmission_media/2019-12-01-15-06-05.png" alt="双绞线"></p>
<h3 id="Shielding_Coaxial_Cable_And_Shielded_Twisted_Pair"><a class="header-anchor" href="#Shielding_Coaxial_Cable_And_Shielded_Twisted_Pair">#</a>Shielding: Coaxial Cable And Shielded Twisted Pair</h3>
<p>因为非屏蔽双绞线只是让两根线吸收了相同的能量，但噪音还是被吸收了，所以在一些情况下，非屏蔽双绞线仍然会产生问题，如有特别强的电噪音环境，或者特别接近噪声源，或者通信系统中的信号频率很高（频率越高对噪音越敏感）。为了解决这些问题，只能尽量的屏蔽噪声。</p>
<p>一种方法就是<code>同轴电缆（Coaxial Cable）</code>，它在线材的外层增加了一层<code>编织金属屏蔽(Braided metal shield)</code>（如网状）。使用编织样的金属层而非一整块金属层主要是处于便携性的考虑（后者的屏蔽性更好），但相对于非屏蔽双绞线，同轴电缆的便携性还是差的。如电视的信号线，一般都是同轴电缆，同轴电缆如下图所示：</p>
<p><img src="/ch_07_transmission_media/2019-12-01-15-19-14.png" alt="同轴电缆"></p>
<p>屏蔽双绞线则是非屏蔽双绞线和同轴电缆的混合，是两者形式的折中，他在一对或多对双绞线的外层使用了更薄的金属屏蔽层，很多情况下用铝来作为金属屏蔽层（铝更软）。</p>
<p>如之前节所述，为了避免铜线间的电干扰，铜线外层会包裹一层塑料。双绞线是将两个两个包裹着塑料的铜线绞在一起，同轴电缆则是在一根包裹住塑料的导线外包裹金属屏蔽层，屏蔽双绞线是在两根包裹着塑料的铜线绞在一起后再包裹较薄的金属层。</p>
<h3 id="Categories_Of_Twisted_Pair_Cable"><a class="header-anchor" href="#Categories_Of_Twisted_Pair_Cable">#</a>Categories Of Twisted Pair Cable</h3>
<p>一些标准机构为用于计算机网络的双绞线定义了标准，这些机构包括 <code>美国国家标准组织（American National Standards Institute，ANSI）</code>，<code>通信产业联合（Telecommunications Industry Association，TIA）</code>，<code>电子产业联合（Electronic Industries Alliance，EIA）</code>，下图为主要分类：</p>
<p><img src="/ch_07_transmission_media/2019-12-01-15-45-39.png" alt="双绞线分类"></p>
<h1 id="Media_Using_Light_Energy_And_Optical_Fibers"><a class="header-anchor" href="#Media_Using_Light_Energy_And_Optical_Fibers">#</a>Media Using Light Energy And Optical Fibers</h1>
<p>有三种形式的媒介是用光能携带数据的：<code>光纤（Optical Fibers）</code>，<code>红外线传输（Infrared transmission）</code>，<code>点对点激光（Point to Point lasers）</code>。</p>
<h2 id="Optical_Fibers"><a class="header-anchor" href="#Optical_Fibers">#</a>Optical Fibers</h2>
<p>其中最重要的类型是光纤：</p>
<ol>
<li>每根光纤都是一根包裹在塑料外层中的细玻璃线或者透明塑料。</li>
<li>光纤是用于单项传播的。在光纤的一段是一个激光或者 LED，用来发射光，另一端是连接一个感光设备用来检测光。如果数据需要双向传播，则需要用到两根光纤。多根光纤用塑料封壳包裹在一起生成光纤电缆。</li>
</ol>
<p>光纤无法被弯折成直角，但光纤仍然可以弯曲，甚至可以弯曲成一个直径小于 2 英寸的圆，让光纤在弯折状态下仍然可以正常工作，主要是因为光的传播特性。</p>
<p>光从一个低密度物质照射入另一个高密度物质，随着入射的角度不同，光的反应也会不同。存在一个特定的角度，当光以这个角度入射时，光会随着两个物质的交界处传播。当光的入射角大于这个角度时，光会被反射。当光的入射角小于这个角度时，光会发生折射。如下图所示：</p>
<p><img src="/ch_07_transmission_media/2019-12-03-08-31-03.png" alt="光的反射"></p>
<p>光纤运用的是光的反射，有一个特殊的镀层（Cladding）与光纤共同形成一个边界，在传输过程中，光会在上下两个边界内反射前进。</p>
<p>但反射的过程中是存在能量损耗的，而且因为光的反射，光传播的路径是比光的直线传播要长的，因此光在光纤一段发射后，抵达另一端时能量会更低，而且会更分散（Dispersed），如下图所示：</p>
<p><img src="/ch_07_transmission_media/2019-12-03-08-36-42.png" alt="光分散"></p>
<p>上图中，因为接受时的能量更低，所以 Y 轴值更低，且因为能量更分散，所以接受的时间也会拖长，因此在 X 轴上如同被拉伸。</p>
<h3 id="Types_Of_Fiber_And_Light_Transmission"><a class="header-anchor" href="#Types_Of_Fiber_And_Light_Transmission">#</a>Types Of Fiber And Light Transmission</h3>
<p>因为光在传输中的反射导致的分散在长距离使用光纤时会成为严重问题，因此有三个种类的光纤，不同的在性能与价格上权衡，</p>
<ol>
<li>跃变型多模光纤（Multimode，step index fiber）：这种类型的光纤，光纤与镀层中的边界很陡峭，因此光会在边界内频繁的反射，造成大量的能量分散，但是这种光纤价格最便宜。</li>
<li>渐变型多模光纤（Multimode，graded index fiber）：这种类型比跃变型多模稍贵，但是能减少反射进而有更少的能量分散。</li>
<li>单模光纤（Single mode fiber）：这种类型的光纤最贵，但也有最低能量分散。通常用于长距离传输和高比特率的传输。</li>
</ol>
<p>如之前节所述光纤的一端会用来发射光，另一端会用来接收光。在发射端，可以通过<code>发光二极管（Light Emitting Diode，LED）</code>，或者<code>激光二极管（Injection Laser Diode，ILD）</code>。在 接收端可以用<code>感光细胞（Phote-sensitive）</code>或者<code>光敏二极管（Photodiode）</code>。</p>
<h3 id="Optical_Fiber_Compared_To_Copper_Wiring"><a class="header-anchor" href="#Optical_Fiber_Compared_To_Copper_Wiring">#</a>Optical Fiber Compared To Copper Wiring</h3>
<p>光纤的优势：</p>
<ol>
<li>对电噪音免疫</li>
<li>更少的衰减（相对于铜线而言）</li>
<li>更高的带宽</li>
</ol>
<p>铜线的优势：</p>
<ol>
<li>更低的价格</li>
<li>更少的设备要求（光纤的接收端必须被有效的抛光）</li>
<li>更不易被损坏</li>
</ol>
<h2 id="Infrared_Communication_Technologies"><a class="header-anchor" href="#Infrared_Communication_Technologies">#</a>Infrared Communication Technologies</h2>
<p><code>红外线通信（Infrared Communication）</code>也是光能通信的一种，也是点对点技术的一种,电视遥控机就是红外线通信的应用。红外线的频率在人眼可见光的范围外，但是红外线仍然表现的如同可见光，它会很快的消散，可以在坚硬光滑表面反射，会被不透明物体阻挡，薄如纸片的物体会阻挡信号，甚至大气中的水气都会阻碍信号。</p>
<p>因此红外线通信适用于室内使用，适用于距离短且无阻挡的通信。</p>
<p>下图是三种红外线通信的常见技术：</p>
<p><img src="/ch_07_transmission_media/2019-12-03-09-54-25.png" alt="红外线通信技术"></p>
<h2 id="Point_To_Point_Laser_Communication"><a class="header-anchor" href="#Point_To_Point_Laser_Communication">#</a>Point-To-Point Laser Communication</h2>
<p><code>激光通信（Laser Communication）</code>是另一种点对点通信，如红外线通信一样，激光通信也需要一个无阻挡的路径。</p>
<p>但与红外线通信不同的是，激光通信只能覆盖很小的一片区域，激光的宽度通常只有几厘米（这里是宽度，并不是指长度），也正是因为激光的宽度很窄，所以激光传输的接收条件是比较苛刻的，通常是被永久的固定安装。</p>
<p>激光通信的典型应用是楼与楼之间的信号传输，通常在相邻大楼的外墙或者顶楼安装部署用于激光通信的发射和接收装置。</p>
<h1 id="Electromagnetic_Radio_Communication"><a class="header-anchor" href="#Electromagnetic_Radio_Communication">#</a>Electromagnetic(Radio) Communication</h1>
<p>常用 <code>无向性（unguided）</code> 来描述不需要任何介质来传播能量的通信方式。在计算机网络中最常用的依赖于电磁能的无向性技术是无线电传播（Radio Frequency Transmission）。无线电传播相较于光传播有个显著的优势，即可以长距离传播且可穿透阻碍物。</p>
<p>电磁能的使用依赖于他的频率属性，常用<code>波谱（Spectrum）</code>来描述可能的频率范围。全球的各政府分配不同频率的使用权，例如在美国是 <code>联邦通信委员会（Federal Communications Commission）</code>。下图是主要的能量频率波谱，其中无线电的范围基本是 $3KHZ$ 到 $300GHZ$。</p>
<p><img src="/ch_07_transmission_media/2019-12-03-14-44-01.png" alt="波谱"></p>
<h2 id="Signal_Propagation"><a class="header-anchor" href="#Signal_Propagation">#</a>Signal Propagation</h2>
<p>电磁波的频率也决定它传播时的特性，下表是波传播的三大类型：</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>频率范围</th>
<th>传播类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>低频</td>
<td>&lt; 2 MHZ</td>
<td>沿地球表面传输，可能会被地形阻挡</td>
</tr>
<tr>
<td>中频</td>
<td>2 到 30 MHZ</td>
<td>在大气层中反射传播，尤其是在电离层</td>
</tr>
<tr>
<td>高频</td>
<td>&gt;30 MHZ</td>
<td>直线传播，会被障碍物阻挡</td>
</tr>
</tbody>
</table>
<p>无线技术也可被分为以下两类：</p>
<ol>
<li>地表（Terrestrial）：依赖相对贴近地表的设备通信，例如无线电发射器和微博发射器。这些设备一般安装在山顶，人造塔或建筑上。</li>
<li>非地表（Nonterrestrial）：依赖于大气层外的设备，例如轨道卫星</li>
</ol>
<h2 id="Types_Of_Satellites"><a class="header-anchor" href="#Types_Of_Satellites">#</a>Types Of Satellites</h2>
<p>通信卫星可以根据距离地表的距离分为三类：</p>
<ol>
<li><code>近地轨道卫星（Low Earth Orbit,LEO）</code>：</li>
</ol>
<p>有低延迟的优点，但是与地球的相对位置变化的较快，接收端需要追踪卫星。</p>
<ol start="2">
<li><code>中地球轨道卫星（Medium Earth Orbit,MEO）</code>：</li>
</ol>
<p>为地球南北极提供信号的椭圆轨道卫星。</p>
<ol start="3">
<li><code>对地静止轨道卫星（Geostationary Earth Orbit,GEO）</code>：</li>
</ol>
<p>与地面可以保持固定角度，缺点是离地球较远，延迟大。</p>
<h3 id="Geostationary_Earth_Orbit_GEO_Satellites"><a class="header-anchor" href="#Geostationary_Earth_Orbit_GEO_Satellites">#</a>Geostationary Earth Orbit(GEO) Satellites</h3>
<p>从上节对于通信卫星的描述可以看出，通信卫星的权衡主要是在延迟和与轨道周期的权衡（轨道周期与地球自转相差越远，追踪卫星越难）。</p>
<p>这里以<code>对地静止轨道卫星（Geostationary Earth Orbit,GEO）</code>为例，对地静止轨道卫星的距离地表距离约为 35805 千米，计算过程如下：</p>
<p>因为卫星保持在轨道上，所以离心力与万有引力相等，即</p>
<p>$$<br>
{\omega}^2mr=\frac{GMm}{r^2}<br>
$$</p>
<p>化简为：<br>
$$<br>
r^3=\frac{GM}{w^2}<br>
$$</p>
<p>其中，G 是万有引力常数为 $6.67\times 10^-20 {km}^3/kg\cdot {s^2}$，M 是地球质量为 $5.976\times 10^{24} kg$，$\omega$ 为角速度，如果要求对地静止，即角速度与地球自转相同，即：<br>
$$<br>
\omega = \frac{2\pi}{3600*24}=7.29\times10^{-5} rad/s<br>
$$</p>
<p>都代入上式，求得 $r=42172 km$，减去地球半径 6376km，得对地静止轨道卫星的距离地表距离约为35805 千米。</p>
<p>卫星距离如果不足这个数值，其旋转速度就会比地球快，在这个距离下，卫星与地表以相同的速度转动，所以地表上的卫星追踪装置在追踪到卫星后就不需要再次运动，因为两者的角度不会发生变化。但对地静止轨道卫星的最大缺陷是信号的延迟，信号的速度以光速计算，信号的一次来回需要：</p>
<p>$$<br>
2\times \frac{35.8\times 10^6 \text{ meters}}{3\times 10^8 \text{meters/sec}}=0.238 sec<br>
$$</p>
<p>0.2 秒的延迟在许多领域上是无法被接受的。</p>
<h2 id="GEO_Coverage_Of_The_Earth"><a class="header-anchor" href="#GEO_Coverage_Of_The_Earth">#</a>GEO Coverage Of The Earth</h2>
<p>在对地静止轨道上的卫星数量是由限制的。为了避免星号键的相互干扰，卫星与卫星间必须有间隔，间隔的大小与信号的强度相关，但通常而言是 4-8 度，因为整个轨道是 360 度，所以对地静止轨道上最多有 45-90 颗卫星。</p>
<p>最少则需要三颗卫星来覆盖整个地球，如下图所示：</p>
<p><img src="/ch_07_transmission_media/2019-12-03-15-52-33.png" alt="最少三颗卫星"></p>
<p>证明如下，首先根据透视原理，距离一个球体越近，能看到球体的部分越少。在距离球体无限远的距离，最多也只能看到球体的 50%，如下图所示：</p>
<p><img src="/ch_07_transmission_media/2019-12-03-16-17-36.png" alt="透视原理"></p>
<p>将能看到球体的百分比设为 X，离球体的距离设为 d，求的半径设为 R，表达式为：</p>
<p>$$<br>
X=\frac{50%}{1+\frac{R}{d}}<br>
$$</p>
<p>式子是由等比三角形得出的，如下图：</p>
<p><img src="/ch_07_transmission_media/2019-12-03-16-23-46.png" alt="等比证明"></p>
<p>将地球半径 6376KM 及对地静止轨道距离 35805KM 代入，得能看到的范围是约为 42.45%，所以最少需要三颗卫星才能覆盖地球。</p>
<h2 id="Low_Earth_Orbit_LEO_Satellites_And_Clusters"><a class="header-anchor" href="#Low_Earth_Orbit_LEO_Satellites_And_Clusters">#</a>Low Earth Orbit(LEO) Satellites And Clusters</h2>
<p>近地轨道卫星的高度最多为 2000 千米，其主要的缺点在于无法与地面保持相同速度，因此地面上的天线必须旋转来追踪卫星。最低的近地轨道卫星在大约 90 分钟就可以环绕一遍地球，移动速度还是将对较快的，因此对于地面天线来说追踪有一定难度。</p>
<p>通常的解决方式是用卫星群（Clustering）或者阵列部署（Array Deployment）的卫星来解决追踪问题。一系列卫星一同工作来覆盖较大的区域。</p>
<p>如一条信息需要从欧洲传到北美，欧洲的地面基站向此时他上方的卫星发送数据，上方的卫星将信息在卫星群之间传播，一直传送到北美上方的卫星，北美上方的卫星再将信息传送给北美的地面基站。</p>
<h1 id="Tradeoffs_Among_Media_Types"><a class="header-anchor" href="#Tradeoffs_Among_Media_Types">#</a>Tradeoffs Among Media Types</h1>
<p>通信媒介的选择是复杂的，通常需要从以下几个方面权衡：</p>
<ol>
<li>花费（Cost）：材料，安装，操作，维护等的开销</li>
<li>数据速率（Data rate）：每秒可以传送多少数据</li>
<li>延迟（Delay）：数据传播和处理的延迟</li>
<li>信号影响（Affect on signal）：信号是否会衰减和失真</li>
<li>环境（Environment）：对干扰的敏感性和电子噪音</li>
<li>安全性（Security）：是否容易被窃听</li>
</ol>
<h1 id="Measuring_Transmission_Media"><a class="header-anchor" href="#Measuring_Transmission_Media">#</a>Measuring Transmission Media</h1>
<p>可以从两个方面来评判传输媒介：<code>传播延迟（Progagation Delay）</code>和<code>信道容量（Channel Capacity）</code>。</p>
<p><code>奈奎斯特第一准则（Nyquist Theorem）</code> 表明在理想低通信道下的最高码元速率速率是带宽的 2 倍。假设有 K 个电平，则一个码元能传输的 bit 数为 $log_2K$ ，B 表示信道的带宽，因此数据速率可以表达为：</p>
<p>$$<br>
D=2Blog_2K \text{ bits /s}<br>
$$</p>
<p>下面证明奈奎斯特准则：</p>
<p>一个有限带宽的低通滤波器，如果其截至频率为 $\omega_g$ 其频域图如下：</p>
<p><img src="/ch_07_transmission_media/2019-12-03-17-06-01.png" alt="低通滤波器频域"></p>
<p>该滤波器的时域相应图为：</p>
<p><img src="/ch_07_transmission_media/2019-12-03-17-07-06.png" alt="低通滤波器时域"></p>
<p>时域的相应波形时一个拖尾的连续信号，这个拖尾会干扰后续信号。但是从波形上可以看出，在$t=\frac{\pi}{\omega_s},\frac{2pi}{\omega_s}…$处是 0，所以如果在这些间隔点发送码元，则不会被干扰。这些点的间隔时间为$T_s=\frac{\pi}{\omega_s}=\frac{1}{2f_m}$，所以码元速率为$R=\frac{1}{T_s}=2f_m$</p>
<h2 id="The_Effect_of_Noise_On_Communication"><a class="header-anchor" href="#The_Effect_of_Noise_On_Communication">#</a>The Effect of Noise On Communication</h2>
<p>奈奎斯特定理提供了了理论上的最高码元速率，因为他并没有将噪音纳入考虑， 而实际中噪音不可避免。香农在此基础上给出了考虑噪音的数据速率，称为香农定理（Shannon’s Theorem）：</p>
<p>$$<br>
C=B\log_2(1+S/N) bits/s<br>
$$</p>
<p>其中 $S/N$ 称为信噪比，式子中并没有给出电平数量 K，这是因为实际上在考虑噪声时，电平数量是受噪声影响的，噪声越大，为了避免干扰，电平的间隔就只能越大，因此电平数量就越少。</p>
<h2 id="The_Significance_Of_Channel_Capacity"><a class="header-anchor" href="#The_Significance_Of_Channel_Capacity">#</a>The Significance Of Channel Capacity</h2>
<p>奈奎斯特定律鼓励工程师探索更高效的编码方式，因为在最高码元速率受信道带宽限制时，编码方式越高效，一个码元携带的数据就越多，单位时间内就能传输更多的比特。</p>
<p>香农定理给出了真实环境下，数据速率的上限，即无论编码多么高效，在非理想环境（有噪声）下，每秒最大的比特传输量</p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《Computer Networks and Internets》 Ch 08 可靠性及信道编码</title>
    <url>/ch_08_reliability_and_channel_coding/</url>
    <content><![CDATA[<h1 id="Introduction"><a class="header-anchor" href="#Introduction">#</a>Introduction</h1>
<p>这一部分将介绍信息传输过程中发生错误的原因，以及纠错的方式——信道编码。本部分将着重介绍前向错误纠正技术，并引出汉明距离等概念。</p>
<h1 id="The_Three_Main_Sources_Of_Transmission_Errors"><a class="header-anchor" href="#The_Three_Main_Sources_Of_Transmission_Errors">#</a>The Three Main Sources Of Transmission Errors</h1>
<p>传输中发生的错误可以分为三大类：</p>
<ol>
<li>干扰（Interference）：如第七章所述，环境中存在许多电磁干扰，这些电磁干扰会阻碍无线电传输和线缆中的信号传输。</li>
<li>失真（Distortion）：所有的物理系统都会造成信号的失真。光纤中的光因为移动距离的增加，时域会发生扩张（频域也因此变化）。信道容量会导致一些频率的信号被过滤掉。放在线缆旁边的金属可能会改变线缆内信号的频率，金属也能干扰无线电信号。</li>
<li>衰弱（Attenuation）：信号在媒介中传输的过程中，信号会逐渐衰弱。</li>
</ol>
<p>香农定理给出了减少错误的思路：提高信噪比。</p>
<p>但无论如何噪声不可能被完全的消除，所以许多方法致力于检测错误，在某些情况下自动修复错误。</p>
<p>但是错误的监测机制无疑是会为系统增加开销的，因此系统设计时要考虑在错误影响与错误检测开销间做权衡，如金融系统，1bit 的错误可能会造成很严重的错误，但是在图片中 1bit 的错误可能根本无法被识别到。</p>
<h1 id="Effect_Of_Transmission_Errors_On_Data"><a class="header-anchor" href="#Effect_Of_Transmission_Errors_On_Data">#</a>Effect Of Transmission Errors On Data</h1>
<p>这里要区分传输错误与数据错误，数据是由传输信号在经过例如解码，解调后得到的。传输错误最后都会导致最后的数据出错。主要有三类传输造成的数据错误：</p>
<ol>
<li>
<p>单元位错误（Single Bit Error）：即一系列数据中，只有一位数据被改变了。这通常是因为传输信号的短时间（称为脉冲，Spike）干扰造成的。</p>
</li>
<li>
<p>突发性错误：一系列数据中有多位数据被改变，通常是由长时间的干扰造成的。错误长度是由错误开始位到错误结束位直接的位数决定。如下表，错误的数据由加粗表示，错误长度是 7：</p>
<table>
<thead>
<tr>
<th>发送</th>
<th>1</th>
<th>0</th>
<th>1</th>
<th>1</th>
<th>0</th>
<th>0</th>
<th>0</th>
<th>1</th>
<th>0</th>
<th>1</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr>
<td>接收</td>
<td>1</td>
<td>0</td>
<td><strong>0</strong></td>
<td>1</td>
<td><strong>1</strong></td>
<td>0</td>
<td><strong>1</strong></td>
<td><strong>0</strong></td>
<td><strong>1</strong></td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
</li>
</ol>
<h1 id="Two_Strategies_For_Handling_Channel_Errors"><a class="header-anchor" href="#Two_Strategies_For_Handling_Channel_Errors">#</a>Two Strategies For Handling Channel Errors</h1>
<p>有一系列的方法解决数据错误并增加数据的可靠性，这些方法统称为<code>信道编码(Channel Coding)</code>，这些方法可以被分为两类：<code>前向错误纠正技术（Forward Error Correction，FEC）</code>，<code>自动重传请求技术（Automatic Repeat reQuest，ARQ）</code>。</p>
<p>前向错误纠正技术的主题思想是在发送的数据中增加额外的信息，接收端可以根据这些额外信息来判断是否有错误发生，有些方法可以检测出究竟是哪一位数据发生了错误，并在可能的情况下纠正错误。</p>
<p>自动重传请求技术是让接收端和发送端互换数据来保证数据被正确的传递。</p>
<h1 id="Block_And_Convolutional_Error_Codes"><a class="header-anchor" href="#Block_And_Convolutional_Error_Codes">#</a>Block And Convolutional Error Codes</h1>
<p>前向错误纠正技术可以再细分为两类：</p>
<ol>
<li>分组错误码（Block Error Codes）：分组错误码是将数据分成一块块的，然后对每一块都增加额外信息。每一块的额外信息只针对于该块数据本身。</li>
<li>卷积错误码（Convolutional Error Codes）：卷积错误码是将数据看作一系列 bits，增加的额外信息是由当前的 bit 和之前的 bit 共同决定的。</li>
</ol>
<p>卷积错误码相对于分组错误码需要更多的计算，但是也更能检测出错误。</p>
<h1 id="An_Example_Block_Error_Code_Single_Parity_Checking"><a class="header-anchor" href="#An_Example_Block_Error_Code_Single_Parity_Checking">#</a>An Example Block Error Code: Single Parity Checking</h1>
<p>单一奇偶校验检查（Single Parity Checking）是分组错误码检测的一个例子，可以再分为偶校验检查和奇校验检查。如果将数据分为 $n$ bit 一组，那么每一组增加一位数据，当是偶校验时，$n$ 位数据+1 位额外数据应该一共有偶数个 1，当是奇校验时，$n$ 位数据+1 位额外数据应该一共有奇数个 1。下表为 8 位数据时的例子：</p>
<table>
<thead>
<tr>
<th>原始数据</th>
<th>偶校验</th>
<th>奇校验</th>
</tr>
</thead>
<tbody>
<tr>
<td>00000000</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>01011011</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>01010101</td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>单一奇偶校验是一个比较弱的信道编码，他只能检测错误，但无法检测出错误具体出现在哪一位，也无法纠正错误。而且当有偶数个位发生错误时，错误就无法被检测出来。</p>
<h1 id="The_Mathematics_of_Block_Error_Codes_And_n_k_Notation"><a class="header-anchor" href="#The_Mathematics_of_Block_Error_Codes_And_n_k_Notation">#</a>The Mathematics of Block Error Codes And (n,k) Notation</h1>
<p>如有 $k$ 位 bit 的数据，我们将所有 $2^k$ 种可能出现的数据称为<code>数据字(Datawords)</code>，在这些数据中增加 $r$ 位额外数据，一共有 $n=k+r$ 个数据，所有 $2^n$ 种可能称为<code>编码字(codeworks)</code>，其中编码字中合法的部分，即额外添加的数据与原数据时符合规则的部分，称为<code>码书(Codebook)</code>，并将这种方法标记为$(n,k)$</p>
<p>如单一奇偶校验中，$k=8,r=1$，因此一共有 256 个数据字，也对应了有 256 个合法的编码字，一共有 512 个编码字。</p>
<p>在理想状态下，合法编码字中的任一一位被改变了，改变后的编码字就不是合法编码字。但是在单一奇偶校验的例子中，如果同时改变了合法编码字中的两位，那么结果仍然是一个合法编码字。</p>
<p>没有一个信道编码可以达到理想状态，所以要考虑的就是，合法编码字最少多少位数据要被同时改变，才能产生另一个合法编码字。在单一数字编码中，这个位数为 2。</p>
<h1 id="Hamming_Distance：A_Measure_Of_A_Code’s_Strength"><a class="header-anchor" href="#Hamming_Distance：A_Measure_Of_A_Code’s_Strength">#</a>Hamming Distance：A Measure Of A Code’s Strength</h1>
<p>汉明距离（Hamming Distance）是用来测量一个合法编码字要转换为另一个合法编码字最少要改变的数据位数的方法中需要用到的概念。如果给定两个$n$长度的字符，两个字符的汉明距离就是两个字符间不同的数据数量。</p>
<p>如$d(000,001)=1,d(000,101)=2,d(000,111)=3,d(101,001)=1$。</p>
<p>可以先对两个字符求异或，然后计算异或出来的字符 1 的总数，即为汉明距离。</p>
<h1 id="The_Hamming_Distance_Among_String_In_A_Codebook"><a class="header-anchor" href="#The_Hamming_Distance_Among_String_In_A_Codebook">#</a>The Hamming Distance Among String In A Codebook</h1>
<p>为了计算出一个合法编码字要转换为另一个合法编码字最少要改变的数据位数，先要计算出码书中所有编码字组合的汉明距离。如对 2 位 bit 数据进行单一奇校验检测：</p>
<table>
<thead>
<tr>
<th>数据字</th>
<th>编码字</th>
</tr>
</thead>
<tbody>
<tr>
<td>00</td>
<td>001</td>
</tr>
<tr>
<td>01</td>
<td>010</td>
</tr>
<tr>
<td>10</td>
<td>100</td>
</tr>
<tr>
<td>11</td>
<td>111</td>
</tr>
</tbody>
</table>
<p>一共有 4 个编码字，4 个编码字一一配对一共有 6 种可能，$d(001,010)=2,d(010,100)=2,d(001,100)=2,d(010,111)=2,d(001,111)=2,d(100,111)=2$。6 种可能中最小的汉明距离是 2，所以最少需要更改 2 位数据才能从一个合法编码字变为另一个合法编码字。</p>
<p>因此计算从一个合法编码字转换为另一个合法编码字最少要改变的数据位数过程是，计算出所有码书中的编码字（即合法编码字）两两配对后的所有汉明距离 $d_{min}$，其中的最小值即为所求值。</p>
<h1 id="The_Tradeoff_Between_Error_Detection_And_Overhead"><a class="header-anchor" href="#The_Tradeoff_Between_Error_Detection_And_Overhead">#</a>The Tradeoff Between Error Detection And Overhead</h1>
<p>对于一个编码，最多的能被检测出来的错误位数为$e=d_{min}-1$，如单一奇偶校验，因为$d_{min}=2$，所以最多能正确检测出来的错误位数为 1。</p>
<p>虽然$d_{min}$越大能检测出来的错误位数越多，但这也意味着要增加更多的额外数据，对于$(n,k)$的编码，工程师用编码率（Code Rate）$R=\frac{k}{n}$来表示为了检测出错误信息的编码开销。</p>
<h1 id="Error_Correction_With_Row_And_Column_RAC_Parity"><a class="header-anchor" href="#Error_Correction_With_Row_And_Column_RAC_Parity">#</a>Error Correction With Row And Column(RAC) Parity</h1>
<p>奇偶校验本身是不能进行错误纠正的，但是通过<code>行列奇偶校验（Row And Column Parity）</code>就可以做到。如一共有 12 个 bit 的原始数据，即$k=12$，排成三行四列每一列每一行都进行奇偶校验，增加一个额外位，则一共 8 个额外位，即$r=8，n=k+r=20$，因此这是一个$(20,12)$的编码，如下图所示：</p>
<p><img src="/ch_08_reliability_and_channel_coding/2019-12-05-14-46-47.png" alt="行列奇偶校验"></p>
<p>因此如果一位数据出错，会同时在对应的行和列校验位感知到，因此就可以定位到错误的数据，取反后就能纠正数据。</p>
<p>奇偶校验数据的$d_{min}$还是 2，因此如果错误的位数大于 1，当是偶数时无法被检测到，当是奇数时虽然能检测出错误，但无法纠正。</p>
<h1 id="The_16_Bit_Checksum_Used_In_The_Internet"><a class="header-anchor" href="#The_16_Bit_Checksum_Used_In_The_Internet">#</a>The 16-Bit Checksum Used In The Internet</h1>
<p>有个称为<code>因特网校验和（Internet checksum）</code>的信道编码方法在网络中扮演了重要角色。这个算法的输入可以是任意长度，将输入拆分为一段段 16 字节的的部分，如果不能长度不能被 16 整除，则最后补 0。如下图所示：</p>
<p><img src="/ch_08_reliability_and_channel_coding/2019-12-06-17-25-08.png" alt="拆分为16字节"></p>
<p>算法的流程如下：</p>
<ol>
<li>将输入拆分为以 16-bit 为一组</li>
<li>定义一个 32-bit 的变量（这里称为$C$）作为结果。</li>
<li>将每一组 16-bit 的数据累加给$C$</li>
<li>将$C$的前 16 位累加给后 16 位</li>
<li>将$C$的后 16 位取反，如果取反后全是 0，则将其改为全是 1</li>
<li>此时$C$的 16 位即为校验和。</li>
</ol>
<p>可以看出最后的校验和也是 16 位的数据，将校验和作为新的一组 16-bit 放在原数据后（经过了补 0 的原数据）发送出去。接收端接受信息后重复算法流程，如果数据没有发生错误，最后接收端计算出的校验和应该是 FFFF。</p>
<p>下面以两个例子进行说明：</p>
<ol>
<li>
<p>例子 1<br>
如果发送端输入数据为<code>0100 1000 0110 0101</code>，<code>0110 1100 0110 1100</code>，<code>0110 1111 0010 0001</code>，计算过程如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">   0100 1000 0110 0101</span><br><span class="line">   0110 1100 0110 1100</span><br><span class="line">+  0110 1111 0010 0001</span><br><span class="line">----------------------------</span><br><span class="line">1  0010 0011 1111 0010</span><br></pre></td></tr></table></figure>
<p>将高 16 位移到后 16 位</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">  0010 0011 1111 0010</span><br><span class="line">+                   1</span><br><span class="line">-------------------------</span><br><span class="line">  0010 0011 1111 0011</span><br></pre></td></tr></table></figure>
<p>取反后得到：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1101 1100 0000 1100</span><br></pre></td></tr></table></figure>
<p>这即为校验和</p>
<p>对于接收端，因为将校验和也一并发送了过去，所以接收端的计算过程如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">   0100 1000 0110 0101</span><br><span class="line">   0110 1100 0110 1100</span><br><span class="line">   0110 1111 0010 0001</span><br><span class="line">+  1101 1100 0000 1100</span><br><span class="line">----------------------------</span><br><span class="line">1  1111 1111 1111 1110</span><br></pre></td></tr></table></figure>
<p>将高 16 位移到后 16 位</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">  1111 1111 1111 1110</span><br><span class="line">+                   1</span><br><span class="line">-------------------------</span><br><span class="line">  1111 1111 1111 1111</span><br></pre></td></tr></table></figure>
<p>取反后得到：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">0000 0000 0000 0000</span><br></pre></td></tr></table></figure>
<p>因为全为 0，所以改为全为 1</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1111 1111 1111 1111</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>例子 2<br>
如果发送端输入数据为<code>1111 1111 1111 1111</code>，<code>1111 1111 1111 1111</code>，<code>0000 0000 0000 0001</code>，计算过程如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">   1111 1111 1111 1111</span><br><span class="line">   1111 1111 1111 1111</span><br><span class="line">+  0000 0000 0000 0001</span><br><span class="line">----------------------------</span><br><span class="line">1  1111 1111 1111 1111</span><br></pre></td></tr></table></figure>
<p>将高 16 位移到后 16 位</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">  1111 1111 1111 1111</span><br><span class="line">+                   1</span><br><span class="line">-------------------------</span><br><span class="line">1 0000 0000 0000 0000</span><br></pre></td></tr></table></figure>
<p>此时虽然高 16 仍然有数值，但不需要再次累加，后 16 位取反后得到：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1111 1111 1111 11111</span><br></pre></td></tr></table></figure>
<p>这即为校验和</p>
<p>对于接收端，因为将校验和也一并发送了过去，所以接收端的计算过程如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">   1111 1111 1111 1111</span><br><span class="line">   1111 1111 1111 1111</span><br><span class="line">   0000 0000 0000 0001</span><br><span class="line">+  1111 1111 1111 1111</span><br><span class="line">----------------------------</span><br><span class="line">10 1111 1111 1111 1110</span><br></pre></td></tr></table></figure>
<p>将高 16 位移到后 16 位</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">  1111 1111 1111 1110</span><br><span class="line">+                  10</span><br><span class="line">-------------------------</span><br><span class="line">1 0000 0000 0000 0000</span><br></pre></td></tr></table></figure>
<p>取反后得到：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1111 1111 1111 1111</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="Cyclic_Redundancy_Codes_CRCs"><a class="header-anchor" href="#Cyclic_Redundancy_Codes_CRCs">#</a>Cyclic Redundancy Codes(CRCs)</h1>
<p>在高速网络中，有一个称为<code>循环冗余码(Cyclic Redundancy Codes,CRCs)</code>的信道编码方法。循环冗余码有三个主要优点：</p>
<ol>
<li>可以对任意长度的数据进行计算</li>
<li>可以充分的检测出错误</li>
<li>可以通过硬件实现，所以非常的高效</li>
</ol>
<p>求$CRC$的计算过程可以看作是两个二进制数的相除，一个代表原数据，一个代表一个特定的除数（可根据不同的情况设置，除数的设置决定错误检测的能力），如果需要求得$N$长度的$CRC$，则需要$N+1$长度的被除数。二进制数相除的过程可以看作是多项式相除，如果原数据是$1010$，除数设置为$1011$，则计算过程如下图：</p>
<p><img src="/ch_08_reliability_and_channel_coding/2019-12-07-00-01-18.png" alt="CRC计算过程"></p>
<h1 id="An_Efficient_Hardware_Implementation_Of_CRC"><a class="header-anchor" href="#An_Efficient_Hardware_Implementation_Of_CRC">#</a>An Efficient Hardware Implementation Of CRC</h1>
<p>CRC 算法的实现硬件是由<code>移位寄存器(Shift Register)</code>和<code>异或门(Exclusive or gates)</code>构成的。在计算 CRC 前，硬件会初始化将移位寄存器中的所有位改为 0，上例中的除数$1011$，对应的硬件图如下：</p>
<p><img src="/ch_08_reliability_and_channel_coding/2019-12-07-00-06-02.png" alt="1011硬件"></p>
<p>TODO：为什么这么设计的原因。</p>
<h1 id="Automatic_Repeat_Request_ARQ_Mechanisms"><a class="header-anchor" href="#Automatic_Repeat_Request_ARQ_Mechanisms">#</a>Automatic Repeat Request(ARQ) Mechanisms</h1>
<p>自动重传请求技术（Automatic Repeat Request,ARQ）需要发送端和接收端传递信息来检测错误。当一方发送数据给另一方时，接收方需要传递一个回执给发送方。如果在一段时间后发送方仍然没有收到回执，则认为数据丢失，重新发送数据。</p>
<p>自动重传请求技术适合只能检测错误，但不能修复错误的系统。当接收方检测出数据有错误后，将数据丢弃并不传递回执，那么发送方就会再次发送数据。</p>
<h1 id="Reference"><a class="header-anchor" href="#Reference">#</a>Reference</h1>
<p><a href="https://en.wikipedia.org/wiki/polynomial_long_division">多项式除法</a><br>
<a href="https://heasarc.gsfc.nasa.gov/docs/heasarc/ofwg/docs/general/checksum/node11.html">1’s Complement Arithmetic</a></p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《Head First 设计模式》 Ch 08 模板方法模式</title>
    <url>/ch_08_the_template_method_pattern/</url>
    <content><![CDATA[<p>模版方法模式（Template Method Pattern）定义了一个算法的操作步骤，但其中的某些步骤需要派生来对应实现。</p>
<ul>
<li>
<p>工厂方法&gt;模式就是模版方法模式的一种运用。</p>
</li>
<li>
<p>策略模式和模版方法模式都是将算法的实现抽象出来，不同的是策略模式的实现依靠组成，而模版方法模式依靠继承。</p>
</li>
</ul>
<p>例如我们需要准备咖啡和茶，准备咖啡基本步骤为烧开水，加入咖啡粉，将咖啡倒入杯子，增加牛奶或糖（可选），准备茶的基本步骤为烧开水，加入茶粉，将茶倒入杯子，增加柠檬（可选）。我们发现在制作两个饮料的过程中，烧开水和倒入杯子这两个步骤是一样的，剩下的两个步骤，向烧开的水中增加相应的粉和增加配料，这两部分也是类似的，于是我们可以用模版方法模式，将这两步骤作为抽象方法。</p>
<h1 id="代码示例"><a class="header-anchor" href="#代码示例">#</a>代码示例</h1>
<h2 id="算法模版基类"><a class="header-anchor" href="#算法模版基类">#</a>算法模版基类</h2>
<figure class="highlight cs"><figcaption><span>咖啡因饮料模版</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">CaffeineBeverage</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrepareRecipe</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        boilWater();</span><br><span class="line">        brew();</span><br><span class="line">        pourInCup();</span><br><span class="line">        <span class="keyword">if</span> (NeedCondiments())</span><br><span class="line">            addCondiments();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">brew</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">addCondiments</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">boilWater</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Boiling Water&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pourInCup</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Pouring Water&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">bool</span> <span class="title">NeedCondiments</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note info simple"><p>例子中<code>brew</code>和<code>addCondiments</code>即为模版函数，而<code>NeedCondiments</code>这种提供了基本实现，但派生类中仍然可以重写的函数被称为钩子（<code>Hook</code>）。</p>
</div>
<h2 id="咖啡因饮料实现"><a class="header-anchor" href="#咖啡因饮料实现">#</a>咖啡因饮料实现</h2>
<figure class="highlight cs"><figcaption><span>咖啡</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Coffee</span> : <span class="title">CaffeineBeverage</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">addCondiments</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Add sugar and Milk&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">brew</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Dripping coffee through filter&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> <span class="title">NeedCondiments</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>茶</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Tea</span> : <span class="title">CaffeineBeverage</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">addCondiments</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Adding lemon&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">brew</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Steeping the tea&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="测试代码及结果"><a class="header-anchor" href="#测试代码及结果">#</a>测试代码及结果</h1>
<figure class="highlight cs"><figcaption><span>测试代码</span></figcaption><table><tr><td class="code"><pre><span class="line">Coffee coffee = <span class="keyword">new</span> Coffee();</span><br><span class="line">Tea tea = <span class="keyword">new</span> Tea();</span><br><span class="line">coffee.PrepareRecipe();</span><br><span class="line">Console.WriteLine();</span><br><span class="line">tea.PrepareRecipe();</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<p><img src="/ch_08_the_template_method_pattern/2019-02-03-15-59-58.png" alt="模版方法模式运行结果"></p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>《Head First 设计模式》 Ch 09 模板方法模式</title>
    <url>/ch_09_the_iterator_and_composite_pattern/</url>
    <content><![CDATA[<h1 id="迭代器模式"><a class="header-anchor" href="#迭代器模式">#</a>迭代器模式</h1>
<p>迭代器模式(Iterator Pattern)提供了一种访问聚合对象但不需要关心其内部实现方法的方式。</p>
<p>例如我们存在两个菜单，第一个菜单表示早餐，第二个表示晚餐，第一个菜单其中的菜品用<code>List</code>来存储，第二个菜单其中的菜品用<code>Array</code>来存储。在这种情况下就需要使用迭代器模式，为两个菜单提供一个供外部调用的访问菜品的接口。</p>
<h2 id="代码示例"><a class="header-anchor" href="#代码示例">#</a>代码示例</h2>
<p>我们在两个菜单类中添加<code>createIterator</code>函数来返回迭代器，对于外部调用者，如测试代码中的<code>PrintMenu</code>,它只需要调用<code>hasNext</code>及<code>next</code>即可而不需要关心菜单中的具体实现。</p>
<h3 id="菜单"><a class="header-anchor" href="#菜单">#</a>菜单</h3>
<figure class="highlight cs"><figcaption><span>Pancake菜单</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PancakeHouseMenu</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;MenuItem&gt; menuItemsList = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PancakeHouseMenu</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        menuItemsList = <span class="keyword">new</span> List&lt;MenuItem&gt;();</span><br><span class="line">        addItem(<span class="string">&quot;K&amp;B&#x27;s Pancake Breakfast&quot;</span>, <span class="string">&quot;Pancake with eggs and toast&quot;</span>, <span class="literal">true</span>, <span class="number">2.99f</span>);</span><br><span class="line">        addItem(<span class="string">&quot;Regular&#x27;s Pancake Breakfast&quot;</span>, <span class="string">&quot;Pancake with eggs and sausags&quot;</span>, <span class="literal">true</span>, <span class="number">2.99f</span>);</span><br><span class="line">        addItem(<span class="string">&quot;Blueberry&#x27;s Pancake Breakfast&quot;</span>, <span class="string">&quot;Pancake with eggs and fresh blueberries&quot;</span>, <span class="literal">true</span>, <span class="number">2.99f</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">createIterator</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PancakeIterator(menuItemsList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addItem</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">string</span> description, <span class="built_in">bool</span> vegetarian, <span class="built_in">float</span> price</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        MenuItem menuItem = <span class="keyword">new</span> MenuItem(name, description, vegetarian, price);</span><br><span class="line">        menuItemsList.Add(menuItem);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>Diner菜单</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DinerMenu</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">int</span> MaxItemsCount = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">private</span> MenuItem[] menuItemsArray = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> numberOfItems = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DinerMenu</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        menuItemsArray = <span class="keyword">new</span> MenuItem[MaxItemsCount];</span><br><span class="line">        addItem(<span class="string">&quot;Vegetarian BLT&quot;</span>, <span class="string">&quot;Fakin Bacon with tomato&quot;</span>, <span class="literal">true</span>, <span class="number">2.99f</span>);</span><br><span class="line">        addItem(<span class="string">&quot;BLT&quot;</span>, <span class="string">&quot;Bacon with tomato&quot;</span>, <span class="literal">true</span>, <span class="number">3.99f</span>);</span><br><span class="line">        addItem(<span class="string">&quot;Soup of the day&quot;</span>, <span class="string">&quot;Soup of the day and salad&quot;</span>, <span class="literal">false</span>, <span class="number">3.29f</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addItem</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">string</span> description, <span class="built_in">bool</span> vegetarian, <span class="built_in">float</span> price</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (numberOfItems &gt;= MaxItemsCount)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        MenuItem menuItem = <span class="keyword">new</span> MenuItem(name, description, vegetarian, price);</span><br><span class="line">        menuItemsArray[numberOfItems++] = menuItem;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">createIterator</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DinerMenuIterator(menuItemsArray);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="迭代器接口及实现"><a class="header-anchor" href="#迭代器接口及实现">#</a>迭代器接口及实现</h3>
<figure class="highlight cs"><figcaption><span>迭代器接口</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Iterator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">bool</span> <span class="title">hasNext</span>()</span>;</span><br><span class="line">    <span class="function"><span class="built_in">object</span> <span class="title">next</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>迭代器实现</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PancakeIterator</span> : <span class="title">Iterator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;MenuItem&gt; itemsList = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> currentPosition = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PancakeIterator</span>(<span class="params">List&lt;MenuItem&gt; itemsList</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.itemsList = itemsList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">hasNext</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> currentPosition &lt; itemsList.Count &amp;&amp; itemsList[currentPosition] != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">next</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> itemsList[currentPosition++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DinerMenuIterator</span> : <span class="title">Iterator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> MenuItem[] itemsArray = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> currentPosition = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DinerMenuIterator</span>(<span class="params">MenuItem[] items</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.itemsArray = items;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">hasNext</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> currentPosition &lt; itemsArray.Length &amp;&amp; itemsArray[currentPosition] != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">next</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> itemsArray[currentPosition++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试代码及结果"><a class="header-anchor" href="#测试代码及结果">#</a>测试代码及结果</h2>
<figure class="highlight cs"><figcaption><span>测试代码</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    DinerMenu dinerMenu = <span class="keyword">new</span> DinerMenu();</span><br><span class="line">    PancakeHouseMenu pancakeHouseMenu = <span class="keyword">new</span> PancakeHouseMenu();</span><br><span class="line"></span><br><span class="line">    PrintMenu(dinerMenu.createIterator());</span><br><span class="line">    Console.WriteLine();</span><br><span class="line">    PrintMenu(pancakeHouseMenu.createIterator());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintMenu</span>(<span class="params">Iterator iterator</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())</span><br><span class="line">    &#123;</span><br><span class="line">        ((MenuItem)iterator.next()).Debug();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/ch_09_the_iterator_and_composite_pattern/2019-02-03-23-36-01.png" alt="迭代器模式运行结果"></p>
<h1 id="组合模式"><a class="header-anchor" href="#组合模式">#</a>组合模式</h1>
<p>组合模式（Composite Pattern）是用树形结构来组合对象进而体现一种局部-整体的层次结构。组合模式可以让调用者以统一的方式对待单个物体和多个物体的组合。</p>
<p>例如我们需要打印一个菜单上的所有菜品，但菜单中可能还包含子菜单，子菜单中又可能包含子菜单等等，但对于外部调用者而言则不希望关注这些细节。我们可以通过定义一个基类，无论是菜品还是菜单都继承自这个基类，这样对于菜单而言，无论是子菜单还是菜品都是同一个基类，可一起管理。对于外部调者而言只 x 需要关心这个基类即可。</p>
<h2 id="代码示例-2"><a class="header-anchor" href="#代码示例-2">#</a>代码示例</h2>
<h3 id="共同抽象类基类"><a class="header-anchor" href="#共同抽象类基类">#</a>共同抽象类基类</h3>
<figure class="highlight cs"><figcaption><span>菜单元素</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">MenuComponent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params">MenuComponent menuComponent</span>)</span> &#123; <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Remove</span>(<span class="params">MenuComponent menuComponent</span>)</span> &#123; <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> MenuComponent <span class="title">GetChild</span>(<span class="params"><span class="built_in">int</span> i</span>)</span> &#123; <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">protected</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">string</span> Description &#123; <span class="keyword">get</span>; <span class="keyword">protected</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">float</span> Price &#123; <span class="keyword">get</span>; <span class="keyword">protected</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">bool</span> Vegetarian &#123; <span class="keyword">get</span>; <span class="keyword">protected</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Debug</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(Name + <span class="string">&quot; , &quot;</span> + Description + <span class="string">&quot; , &quot;</span> + Vegetarian + <span class="string">&quot; , &quot;</span> + Price);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="菜单及菜品实现"><a class="header-anchor" href="#菜单及菜品实现">#</a>菜单及菜品实现</h3>
<figure class="highlight cs"><figcaption><span>菜单</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Menu</span> : <span class="title">MenuComponent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;MenuComponent&gt; menuComponetsList = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Menu</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">string</span> description</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        menuComponetsList = <span class="keyword">new</span> List&lt;MenuComponent&gt;();</span><br><span class="line">        Name = name;</span><br><span class="line">        Description = description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params">MenuComponent menuComponent</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        menuComponetsList.Add(menuComponent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Remove</span>(<span class="params">MenuComponent menuComponent</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        menuComponent.Remove(menuComponent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> MenuComponent <span class="title">GetChild</span>(<span class="params"><span class="built_in">int</span> i</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> menuComponetsList[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Debug</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(Name + <span class="string">&quot; , &quot;</span> + Description);</span><br><span class="line">        menuComponetsList.ForEach(menuComponent =&gt; menuComponent.Debug());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>菜品</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MenuItem</span> : <span class="title">MenuComponent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MenuItem</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">string</span> description, <span class="built_in">bool</span> vegetarian, <span class="built_in">float</span> price</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Name = name;</span><br><span class="line">        Description = description;</span><br><span class="line">        Vegetarian = vegetarian;</span><br><span class="line">        Price = price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试代码及结果-2"><a class="header-anchor" href="#测试代码及结果-2">#</a>测试代码及结果</h2>
<figure class="highlight cs"><figcaption><span>测试代码</span></figcaption><table><tr><td class="code"><pre><span class="line">Menu menu = <span class="keyword">new</span> Menu(<span class="string">&quot;General Menu&quot;</span>, <span class="string">&quot;Holds all menus and menu items&quot;</span>);</span><br><span class="line">Menu dinnerMenu = <span class="keyword">new</span> Menu(<span class="string">&quot;Dinner Menu&quot;</span>, <span class="string">&quot;Holds dinner menu items&quot;</span>);</span><br><span class="line">Menu breakfastMenu = <span class="keyword">new</span> Menu(<span class="string">&quot;Breakfast Menu&quot;</span>, <span class="string">&quot;Holds Breakfast menu items&quot;</span>);</span><br><span class="line">menu.Add(dinnerMenu);</span><br><span class="line">menu.Add(breakfastMenu);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">breakfastMenu.Add(<span class="keyword">new</span> MenuItem(<span class="string">&quot;K&amp;B&#x27;s Pancake Breakfast&quot;</span>, <span class="string">&quot;Pancake with eggs and toast&quot;</span>, <span class="literal">true</span>, <span class="number">2.99f</span>));</span><br><span class="line">breakfastMenu.Add(<span class="keyword">new</span> MenuItem(<span class="string">&quot;Regular&#x27;s Pancake Breakfast&quot;</span>, <span class="string">&quot;Pancake with eggs and sausags&quot;</span>, <span class="literal">true</span>, <span class="number">2.99f</span>));</span><br><span class="line">breakfastMenu.Add(<span class="keyword">new</span> MenuItem(<span class="string">&quot;Blueberry&#x27;s Pancake Breakfast&quot;</span>, <span class="string">&quot;Pancake with eggs and fresh blueberries&quot;</span>, <span class="literal">true</span>, <span class="number">2.99f</span>));</span><br><span class="line"></span><br><span class="line">dinnerMenu.Add(<span class="keyword">new</span> MenuItem(<span class="string">&quot;Vegetarian BLT&quot;</span>, <span class="string">&quot;Fakin Bacon with tomato&quot;</span>, <span class="literal">true</span>, <span class="number">2.99f</span>));</span><br><span class="line">dinnerMenu.Add(<span class="keyword">new</span> MenuItem(<span class="string">&quot;BLT&quot;</span>, <span class="string">&quot;Bacon with tomato&quot;</span>, <span class="literal">true</span>, <span class="number">3.99f</span>));</span><br><span class="line">dinnerMenu.Add(<span class="keyword">new</span> MenuItem(<span class="string">&quot;Soup of the day&quot;</span>, <span class="string">&quot;Soup of the day and salad&quot;</span>, <span class="literal">false</span>, <span class="number">3.29f</span>));</span><br><span class="line"></span><br><span class="line">menu.Debug();</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/ch_09_the_iterator_and_composite_pattern/2019-02-06-16-23-58.png" alt="组合模式运行结果"></p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>《Computer Networks and Internets》 Ch 10 调制与调制器</title>
    <url>/ch_10_modulation_and_modems/</url>
    <content><![CDATA[<h1 id="Introduction"><a class="header-anchor" href="#Introduction">#</a>Introduction</h1>
<p>这一章讨论数据通信中的调制与调制器相关的内容。</p>
<p>调制是利用高频的信息来携带原始数据，将分别讨论当原始数据是模拟信号和数字信号的情况。</p>
<h1 id="Carriers_Frequency_And_Propagation"><a class="header-anchor" href="#Carriers_Frequency_And_Propagation">#</a>Carriers,Frequency,And Propagation</h1>
<p>许多通信系统会利用一个持续震荡的电磁波来作为信息的载波（Carrier），通常这个信号都是一个高频信号。在第七章有提到，信号的频率会影响信号的传播特性，如穿透性，对噪声的敏感性等。</p>
<h1 id="Analog_Modulation_Schemes"><a class="header-anchor" href="#Analog_Modulation_Schemes">#</a>Analog Modulation Schemes</h1>
<p><code>调制（Modulation）</code>意为根据原始信号来改变载波的特性。调制有两个输入，一个是载波，一个是原信号，然后产生一个调制后的载波作为输出。调制的原理图如下：</p>
<p><img src="/ch_10_modulation_and_modems/2019-12-07-23-21-31.png" alt="调制原理图"></p>
<p>输入的原信号必须改变载波的一个特性，根据特性的不同可以分为<code>振幅调制（Amplitude modulation）</code>，<code>频移调制（Frequency modulation）</code>，<code>移相调制（Phase shift modulation）</code>。其中前两种最为普遍。</p>
<h1 id="Amplitude_Modulation"><a class="header-anchor" href="#Amplitude_Modulation">#</a>Amplitude Modulation</h1>
<p><code>振幅调制（Amplitude modulation）</code>是根据原信号改变载波的振幅。从时域图上看，调制后的波形的轮廓与原信号基本相同，如下图所示，（a）是高频载波，（b）是原信号，（c）是调制后的信号。</p>
<p><img src="/ch_10_modulation_and_modems/2019-12-07-23-28-45.png" alt="振幅调制"></p>
<h1 id="Frequency_Modulation"><a class="header-anchor" href="#Frequency_Modulation">#</a>Frequency Modulation</h1>
<p><code>频移调制（Frequency modulation）</code>是根据原信号改变载波的频率，当信号强是，载波的频率增加，反之减少。如下图即为频移调制后的样子：</p>
<p><img src="/ch_10_modulation_and_modems/2019-12-07-23-36-37.png" alt="频移调制"></p>
<h1 id="Phase_Shift_Modulation"><a class="header-anchor" href="#Phase_Shift_Modulation">#</a>Phase Shift Modulation</h1>
<p><code>移相调制（Phase shift modulation）</code>是根据原信号改变载波的相位。经过理论上可行，但对于模拟信号来说，很少用移相调制，因为模拟信号采样点的数据可能比较接近，导致移相的大小不明显，很容易被误认为是频率的改变。但对于数字信号来说移相调制因为可以一个码元传递多个 Bit 的字节，所以经常被使用。</p>
<h1 id="Amplitude_Modulation_And_Shannon’s_Theorem"><a class="header-anchor" href="#Amplitude_Modulation_And_Shannon’s_Theorem">#</a>Amplitude Modulation And Shannon’s Theorem</h1>
<p>在之前解释振幅调制的示意图中，调制后信号变化幅度较大，最低处的强度接近于 0。但实际运用时，基本上振幅调制的幅度变化很小。因为考虑到有噪声的存在，如果信号的变化幅度较大，在信号最弱时的信噪比会很低，则几乎无法传递有效信息。</p>
<h1 id="Modulation_Digital_Input_And_Shift_Keying"><a class="header-anchor" href="#Modulation_Digital_Input_And_Shift_Keying">#</a>Modulation,Digital Input,And Shift Keying</h1>
<p>为了区分模拟信号和数字信号的调制，使用属于<code>移位键控（Shift Keying）</code>来表示数字信号的调制。数字信号的调制与模拟信号调制基本原理类似，只不过作为原信号的模拟信号是连续的数值变化，而数字信号是离散的几个特定的数值。振幅与频率移位键控如下图，(a)是载波，(b)是原信号，©是振幅移位键控，(d)是频率移位键控</p>
<p><img src="/ch_10_modulation_and_modems/2019-12-08-00-05-53.png" alt="振幅，频率移位键控"></p>
<h1 id="Phase_Shift_Keying"><a class="header-anchor" href="#Phase_Shift_Keying">#</a>Phase Shift Keying</h1>
<p><code>相位移位键控(Phase Shift Keying)</code>是根据原信号突然的改变载波的相位，如下图所示，即为相位移位键控的示意图。</p>
<p><img src="/ch_10_modulation_and_modems/2019-12-08-00-11-28.png" alt="相位移位键控"></p>
<h1 id="Phase_Shift_And_A_Constellation_Diagram"><a class="header-anchor" href="#Phase_Shift_And_A_Constellation_Diagram">#</a>Phase Shift And A Constellation Diagram</h1>
<p>如之前所示，相位移位键控最大的优势在于可以用一个码元传递多个 bit。可通过$2^n$个相位来使一个码元可携带$n$ bit 数据。使用星座图来表示相位变化大小与该大小与对应数据的关系。星座图如下图所示，图（1）是只有两个相位变化，即表示 0 和 1，图（2）是有四个相位变化，可代表两个 bit,即 00,01,10,11。</p>
<p><img src="/ch_10_modulation_and_modems/2019-12-08-00-18-17.png" alt="两个相位的相位移位键控"></p>
<p><img src="/ch_10_modulation_and_modems/2019-12-08-00-18-54.png" alt="四个相位的相位移位键控"></p>
<h1 id="Quadrature_Amplitude_Modulation"><a class="header-anchor" href="#Quadrature_Amplitude_Modulation">#</a>Quadrature Amplitude Modulation</h1>
<p>如上节所述，可以在使用相位移位键控时采用多个相位间隔使一个码元传递多个 bit。但某些情况下，硬件无法检测过于精细的相位变化。这时候可以通过降相位移位键控和振幅移位键控结合在一起使一个码元可携带更多的数据，这方法称为<code>正交振幅调制（Quadrature Amplitude Modulation）</code>。如下图所示：</p>
<p><img src="/ch_10_modulation_and_modems/2019-12-08-10-04-32.png" alt="正交振幅调制"></p>
<p>如上图，一共有四个相位区分，每个点距离原点的距离代表振幅，一共有四个电压，因此一共有 16 种组合，一个码元可以携带 4 个 bit。</p>
<h1 id="Modem_Hardware_For_Modulation_And_Demodulation"><a class="header-anchor" href="#Modem_Hardware_For_Modulation_And_Demodulation">#</a>Modem Hardware For Modulation And Demodulation</h1>
<p>将一系列的数据 bit 作为输入，然后根据这些原数据对载波进行调制的设备称为<code>调制器（Modulator）</code>，反之根据调制后的载波重新解析出原信号的机器称为<code>解调器（Demodulator）</code>。在实际中，大部分的通信设备同时包含调制器和解调器，这种设备被称为<code>调制解调器（Modem）</code>。下图是两个计算机的通信简图，在两者将数据传给中间的电缆媒介前，都经过了调制解调器</p>
<p><img src="/ch_10_modulation_and_modems/2019-12-08-10-13-14.png" alt="调制解调器"></p>
<h1 id="Optical_And_Radio_Frequency_Modems"><a class="header-anchor" href="#Optical_And_Radio_Frequency_Modems">#</a>Optical And Radio Frequency Modems</h1>
<p>调制解调器不仅可用于电缆的传输，对于无线电波和光纤也同样适用，原理也一样，在发送端调制解调器对载波进行调制，在接收端，数据从被调制后的载波中会提取。</p>
<h1 id="Dialup_Modems"><a class="header-anchor" href="#Dialup_Modems">#</a>Dialup Modems</h1>
<p>在语音电话系统中，使用的调制解调器称为<code>拨号调制解调器（Dialup Modems）</code>，其与普通的调制解调器最大的区别在于，前者用的是语音信号，后者用的是电信号，而且拨号调制解调器占用的带宽更小。</p>
<p>因为电话系统接受的是模拟信号，所以拨号调制解调器也是一个对模拟信号进行调制的设备。但讽刺的是现代电话系统的中间传输部分是数字信号，于是发送端在调制后，需要将模拟信号转换为数字信号。而在接收端，在进行解调前也需要先将中间传输来的数字信号转换为模拟信号。</p>
<h1 id="QAM_Applied_To_Dialup"><a class="header-anchor" href="#QAM_Applied_To_Dialup">#</a>QAM Applied To Dialup</h1>
<p>正交振幅调制也同样可用于拨号调制解调器中。因为大部分语音频率本身是从$300HZ\sim 3300HZ$，但拨号调制解调器只能提供$600HZ\sim 3000HZ$，所以同样需要正交振幅调制来使一个码元能携带更多的数据。</p>
<h1 id="V_32_And_V_32bis_Dialup_Modems"><a class="header-anchor" href="#V_32_And_V_32bis_Dialup_Modems">#</a>V.32 And V.32bis Dialup Modems</h1>
<p>V.32 和 V.32bis 是两个拨号调制解调器用正交振幅调制的标准。</p>
<p>V.32 使用 32 个振幅和相位的组合来表示数据，可以达到单向每秒 9600 个 bit 的数据速率。</p>
<p><img src="/ch_10_modulation_and_modems/2019-12-08-10-28-37.png" alt="V.32"></p>
<p>V.32bis 使用 128 个振幅和相位的组合来表数据，可以达到单向每秒 14400 个 bit 的数据速率。</p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《Head First 设计模式》 Ch 10 状态模式</title>
    <url>/ch_10_the_state_pattern/</url>
    <content><![CDATA[<p>状态模式(State Pattern)允许一个对象根据其内部状态的变化来选择需要执行的操作。这个对象会看起来像是改变了它的类。</p>
<p>状态模式定义听起来有些奇怪，实际上就是将不同状态的行为定义在不同的状态类中，然后根据状态的不同切换这些状态类，进而达到不同的行为。</p>
<p>例如我们需要做一个口香糖贩卖机需要处理，投钱、退钱、旋转出货按钮这三个操作，然后机器有未投钱、投钱、货物卖出、货物卖完四个状态。我们可以将不同状态下对三个操作的处理定义在各自的状态类中。</p>
<h1 id="代码示例"><a class="header-anchor" href="#代码示例">#</a>代码示例</h1>
<h2 id="状态类接口"><a class="header-anchor" href="#状态类接口">#</a>状态类接口</h2>
<figure class="highlight cs"><figcaption><span>状态类接口</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">State</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InsertQuarter</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">EjectQuarter</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TurnCrank</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Dispense</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="状态类实现"><a class="header-anchor" href="#状态类实现">#</a>状态类实现</h2>
<figure class="highlight cs"><figcaption><span>未投钱状态</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NoQuarterState</span> : <span class="title">State</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> GumballMachine gumballMachine = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NoQuarterState</span>(<span class="params">GumballMachine gumballMachine</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.gumballMachine = gumballMachine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispense</span>()</span> &#123; Console.WriteLine(<span class="string">&quot;You need to pay first&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">EjectQuarter</span>()</span> &#123; Console.WriteLine(<span class="string">&quot;You haven&#x27;t inserted a quarter&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InsertQuarter</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        gumballMachine.SetState(gumballMachine.HasQuarterState);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;You inserted a quarter&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TurnCrank</span>()</span> &#123; Console.WriteLine(<span class="string">&quot;You turned,but there&#x27;s no quarter&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>投钱状态</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HasQuarterState</span> : <span class="title">State</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> GumballMachine gumballMachine = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HasQuarterState</span>(<span class="params">GumballMachine gumballMachine</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.gumballMachine = gumballMachine;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispense</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;No gumball dispensed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">EjectQuarter</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Quarter returned&quot;</span>);</span><br><span class="line">        gumballMachine.SetState(gumballMachine.NoQuarterState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InsertQuarter</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;You can&#x27;t insert another quater&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TurnCrank</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;You turned&quot;</span>);</span><br><span class="line">        gumballMachine.SetState(gumballMachine.SoldState);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>货物卖出状态</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SoldState</span> : <span class="title">State</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> GumballMachine gumballMachine = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SoldState</span>(<span class="params">GumballMachine gumballMachine</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.gumballMachine = gumballMachine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispense</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        gumballMachine.ReleaseBall();</span><br><span class="line">        <span class="keyword">if</span> (gumballMachine.remainGumballsNum &gt; <span class="number">0</span>)</span><br><span class="line">            gumballMachine.SetState(gumballMachine.NoQuarterState);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Opps,out of gumballs&quot;</span>);</span><br><span class="line">            gumballMachine.SetState(gumballMachine.SoldOutState);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">EjectQuarter</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Sorry,you already turned the crank&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InsertQuarter</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Please wait,we are already giving you a gumball&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TurnCrank</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Turning twice dones&#x27;t get you another gumball&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>货物售完状态</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SoldOutState</span> : <span class="title">State</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> GumballMachine gumballMachine = <span class="literal">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SoldOutState</span>(<span class="params">GumballMachine gumballMachine</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.gumballMachine = gumballMachine;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispense</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;No gumball dispensed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">EjectQuarter</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;You can&#x27;t eject,you haven&#x27;t inserted a quarter yet&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InsertQuarter</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;You can&#x27;t insert a quarter,the machine is sold out&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TurnCrank</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;You turned,but there are no gumballs&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="测试代码及结果"><a class="header-anchor" href="#测试代码及结果">#</a>测试代码及结果</h1>
<figure class="highlight cs"><figcaption><span>测试代码</span></figcaption><table><tr><td class="code"><pre><span class="line">GumballMachine gumballMachine = <span class="keyword">new</span> GumballMachine(<span class="number">5</span>);</span><br><span class="line">gumballMachine.TurnCrank();</span><br><span class="line">gumballMachine.InsertQuarter();</span><br><span class="line">gumballMachine.EjectQuarter();</span><br><span class="line">gumballMachine.TurnCrank();</span><br><span class="line">gumballMachine.InsertQuarter();</span><br><span class="line">gumballMachine.TurnCrank();</span><br><span class="line">gumballMachine.TurnCrank();</span><br><span class="line">gumballMachine.EjectQuarter();</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/ch_10_the_state_pattern/2019-02-06-20-10-15.png" alt="状态模式运行结果"></p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>《Head First 设计模式》 Ch 11 代理模式</title>
    <url>/ch_11_the_proxy_pattern/</url>
    <content><![CDATA[<p>代理模式（Proxy Pattern）为对象提供一个代理进而控制对其的访问。</p>
<p>例如我们需要加载一张图片，但加载图片是个访问网络或 IO 的操作，我们不希望这个这个操作阻塞 UI 线程，于是我们可以定义一个代理来进行多线程的加载，并在加载完成后显示图片。</p>
<h1 id="代码示例"><a class="header-anchor" href="#代码示例">#</a>代码示例</h1>
<h2 id="抽象接口"><a class="header-anchor" href="#抽象接口">#</a>抽象接口</h2>
<figure class="highlight cs"><figcaption><span>图片接口</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Icon</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrintIconWidthAndHeight</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="抽象接口实现"><a class="header-anchor" href="#抽象接口实现">#</a>抽象接口实现</h2>
<figure class="highlight cs"><figcaption><span>真实图片类</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ImageIcon</span> : <span class="title">Icon</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> width, height;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImageIcon</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Thread.Sleep(<span class="number">5000</span>);<span class="comment">//Pretend there is some hard work to load the image</span></span><br><span class="line">        width = <span class="number">800</span>;</span><br><span class="line">        height = <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintIconWidthAndHeight</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(DateTime.Now.ToLongTimeString() + <span class="string">&quot;: Width is &quot;</span> + width + <span class="string">&quot;,height is &quot;</span> + height);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>代理图片类</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ImageProxyIcon</span> : <span class="title">Icon</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> ImageIcon icon = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> isLoading = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImageProxyIcon</span>()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintIconWidthAndHeight</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (icon != <span class="literal">null</span>)</span><br><span class="line">            icon.PrintIconWidthAndHeight();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!isLoading)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(DateTime.Now.ToLongTimeString() + <span class="string">&quot;: Is Loading Image...&quot;</span>);</span><br><span class="line">            isLoading = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">new</span> Thread(() =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                icon = <span class="keyword">new</span> ImageIcon();</span><br><span class="line">                icon.PrintIconWidthAndHeight();</span><br><span class="line">            &#125;).Start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="测试代码及结果"><a class="header-anchor" href="#测试代码及结果">#</a>测试代码及结果</h1>
<figure class="highlight cs"><figcaption><span>测试代码</span></figcaption><table><tr><td class="code"><pre><span class="line">ImageProxyIcon proxyIcon = <span class="keyword">new</span> ImageProxyIcon();</span><br><span class="line">proxyIcon.PrintIconWidthAndHeight();</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/ch_11_the_proxy_pattern/2019-02-07-14-10-11.png" alt="代理模式运行结果"></p>
<div class="note info simple"><p>代理模式与装饰模式很像，不同的是装饰模式的目的是在原先的类外扩展某些功能，而代理模式只是控制原先类中某些接口的访问。例如上例子中，<code>ImageProxyIcon</code>并没有为<code>ImageIcon</code>拓展什么功能，只是用了多线程来访问访问其中的函数。</p>
</div>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>《Head First 设计模式》 Ch 12 复合模式</title>
    <url>/ch_12_the_compound_patterns/</url>
    <content><![CDATA[<p>复合模式（Compound Pattern）是通过两个或以上的设计模式形成一个可以解决一般性问题的通用框架。</p>
<p>MVC 框架就是一种组合模式，<code>Controller</code>和<code>View</code>之间使用了策略模式， <code>View</code>中只存<code>Controller</code>的接口，进而达到可以随时切换不同<code>Controller</code>的目的。<code>Model</code>和<code>View</code>之间使用了观察者模式，<code>View</code>作为观察者，<code>Model</code>作为被观察者，当<code>Model</code>的数据发生变化时，<code>View</code>相应改变。而<code>View</code>本身使用了组合模式，比如按钮中可能存在子按钮，窗口中存在子窗口等等。</p>
<p>我们以音量调节作为一个最简的 MVC 框架示例。</p>
<h1 id="代码示例"><a class="header-anchor" href="#代码示例">#</a>代码示例</h1>
<h2 id="框架接口"><a class="header-anchor" href="#框架接口">#</a>框架接口</h2>
<figure class="highlight cs"><figcaption><span>观察者接口</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IVolumeObserver</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">VolumeUpdated</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>Model接口</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IVolumeModel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> Volume &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RegisterObserver</span>(<span class="params">IVolumeObserver observer</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">UnRegisterObserver</span>(<span class="params">IVolumeObserver observer</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>Controller接口</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IViewController</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">VolumeUp</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">VolumeDown</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetVolume</span>(<span class="params"><span class="built_in">int</span> volume</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="接口实现"><a class="header-anchor" href="#接口实现">#</a>接口实现</h2>
<figure class="highlight cs"><figcaption><span>Model</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">VolumeModel</span> : <span class="title">IVolumeModel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> volume = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Volume</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> volume; &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            volume = <span class="keyword">value</span>;</span><br><span class="line">            observersList.ForEach(observer =&gt; observer.VolumeUpdated());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> List&lt;IVolumeObserver&gt; observersList = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VolumeModel</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        observersList = <span class="keyword">new</span> List&lt;IVolumeObserver&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RegisterObserver</span>(<span class="params">IVolumeObserver observer</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        observersList.Add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UnRegisterObserver</span>(<span class="params">IVolumeObserver observer</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        observersList.Remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>View</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">VolumeView</span> : <span class="title">IVolumeObserver</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IViewController controller = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> IVolumeModel model = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VolumeView</span>(<span class="params">IViewController controller, IVolumeModel model</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.controller = controller;</span><br><span class="line">        <span class="keyword">this</span>.model = model;</span><br><span class="line">        <span class="keyword">this</span>.model.RegisterObserver(<span class="keyword">this</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;View: volume init is &quot;</span> + model.Volume);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnVolumeUpButtonClick</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        controller.VolumeUp();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnVolumeDownButtonClick</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        controller.VolumeDown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">VolumeUpdated</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;View: volume updated &quot;</span> + model.Volume);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~VolumeView()</span><br><span class="line">    &#123;</span><br><span class="line">        model.UnRegisterObserver(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>Controller</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">VolumeController</span> : <span class="title">IViewController</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> VolumeModel model = <span class="literal">null</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">VolumeController</span>(<span class="params">VolumeModel model</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.model = model;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetVolume</span>(<span class="params"><span class="built_in">int</span> volume</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            model.Volume = volume;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">VolumeDown</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            --model.Volume;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">VolumeUp</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            ++model.Volume;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="测试代码及结果"><a class="header-anchor" href="#测试代码及结果">#</a>测试代码及结果</h1>
<figure class="highlight cs"><figcaption><span>测试代码</span></figcaption><table><tr><td class="code"><pre><span class="line">VolumeModel model = <span class="keyword">new</span> VolumeModel();</span><br><span class="line">VolumeView view = <span class="keyword">new</span> VolumeView(<span class="keyword">new</span> VolumeController(model), model);</span><br><span class="line">view.OnVolumeUpButtonClick();</span><br><span class="line">view.OnVolumeUpButtonClick();</span><br><span class="line">view.OnVolumeDownButtonClick();</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/ch_12_the_compound_patterns/2019-02-07-15-53-23.png" alt="复合模式运行结果"></p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>《Computer Networks and Internets》 Ch 11 复用与解复用</title>
    <url>/ch_11_multiplexing_and_demultiplexing/</url>
    <content><![CDATA[<h1 id="Introduction"><a class="header-anchor" href="#Introduction">#</a>Introduction</h1>
<p>这一部分将介绍将多个心愿的数据流合并在一起的复用，和将合并后数据流拆分的解复用。</p>
<h1 id="The_Concept_Of_Multiplexing"><a class="header-anchor" href="#The_Concept_Of_Multiplexing">#</a>The Concept Of Multiplexing</h1>
<p><code>复用(Multiplexing)</code>是将多个信源的数据流合并在一起，并通过一个共享的媒介进行传输。<code>复用器（Multiplexor）</code>是用来进行复用的设备。<code>解复用（Demultiplexing）</code>是将合并后的数据流拆分还原成一个个信源的信息，<code>解复用器（Demultiplexor）</code>是用来进行解复用的设备。下图是复用与解复用的使用简图：</p>
<p><img src="/ch_11_multiplexing_and_demultiplexing/2019-12-08-10-56-05.png" alt="复用与解复用"></p>
<p>复用与解复用在日常的计算机网络使用中一直在进行，如多台电脑使用同一根网线等。</p>
<h1 id="The_Basic_Types_Of_Multiplexing"><a class="header-anchor" href="#The_Basic_Types_Of_Multiplexing">#</a>The Basic Types Of Multiplexing</h1>
<p>在物理层，有四大类的复用方式：</p>
<ol>
<li>频分复用（Frequency Division Multiplexing）</li>
<li>波分复用（Wavelength Division Multiplexing）</li>
<li>时分复用（Time Division Multiplexing）</li>
<li>码分复用（Code Division Multiplexing）</li>
</ol>
<p>频分复用和波分复用使用比较广泛。波分复用可以看作是频分复用的一种特殊形式（波长与波的频率是相关的），波分复用用于光纤中。码分复用是没有使用物理特性，而是用数学原理，在一些电话系统中有运用。</p>
<h1 id="Frequency_Division_Multiplexing（FDM）"><a class="header-anchor" href="#Frequency_Division_Multiplexing（FDM）">#</a>Frequency Division Multiplexing（FDM）</h1>
<p><code>频分复用（Frequency Division Multiplexing）</code>是无线电广播的基础。在频分复用下，一个有大频率带宽的信道将拆分成许多小部分，每个信源都有一个自己单独的信道（占据一定频率的范围，相当于每个信源的载波频率都不同），每个信道间不会相互干扰，所有的信源都将使用一个共同的媒介进行传输。在频分复用下，每个信道都可以选择各自的方式进行调制。</p>
<p>频分复用最大的优点在于多个发送端和接收端都可以同时使用传输媒介。</p>
<p>为了避免在频分复用下，每个信源都有自己的信道，如果这些信道间的频率太过于接近则会产生干扰。为了避免干扰的的产生，信道之间需要由间隔（Gap），称为<code>防护频带（Guard band）</code>。</p>
<p>下图是频分复用的示意图，每个小块代表一个可供信源使用的单独信道，可以看到每个信道间都有一个小间隔作为防护频带。</p>
<p><img src="/ch_11_multiplexing_and_demultiplexing/2019-12-08-11-15-01.png" alt="频分复用"></p>
<h1 id="Using_A_Range_Of_Frequency_Per_Channel"><a class="header-anchor" href="#Using_A_Range_Of_Frequency_Per_Channel">#</a>Using A Range Of Frequency Per Channel</h1>
<p>在上节的例子中，每个信道都有一个频率范围，但载波是固定频率的，信道之所欲选择一个频率范围而非单一的频率，主要是考虑便捷性，因为划分出的信道可能会以各种方式被使用。大多数频分复用系统都给发送端和接收端一个频率范围，系统可以选择最适用的频率作为载波，选择的评判标准通常是数据速率和对噪音的敏感性。</p>
<p>因为频分复用通常的频率较高，对噪声敏感，因此通常使用同轴电缆来作为传输媒介。</p>
<p>有的时候为了进一步增加数据速率，被分配给一个信源的信道会被再次的分割成更小的信道，如一个信源将分配给它的信道再分割成$K$个小信道，则每个小信道只要传输$1/k$的数据即可，这技术称为<code>子信道（Subchannel）</code>。</p>
<p>有的时候为了进一步增加对噪声的抵抗性，会使用称为<code>展频(Spread Spectrum)</code>的技术。这个方法同样将信源的信道再切割成$k$个小信道，但每个信道都传输一样的数据，接收端收到信息后，从这$k$个小信道中找寻错误最少的数据作为接收数据。</p>
<h1 id="Hierarchical_FDM"><a class="header-anchor" href="#Hierarchical_FDM">#</a>Hierarchical FDM</h1>
<p><code>分层频分复用（Hierarchical FDM）</code>是将频分复用后的总数据再作为一个频率更高的频分复用的输入进行再次复用。如下图所示：</p>
<p><img src="/ch_11_multiplexing_and_demultiplexing/2019-12-08-12-06-55.png" alt="分层频分复用"></p>
<p>虽然上图中每一级的单一信道带宽是上一级所有信道带宽的总和。但在实际运用中，下一级的单一信道带宽是要略大于上一级所有信道带宽的总和的，因为还需要携带额外的同步帧。</p>
<h1 id="Wavelength_Division_Multiplexing（WDM）"><a class="header-anchor" href="#Wavelength_Division_Multiplexing（WDM）">#</a>Wavelength Division Multiplexing（WDM）</h1>
<p><code>波分复用（Wavelength Division Multiplexing，WDM）</code>是在使用光纤作为媒介时的频分复用。当波分复用使用了许多不同频率的光时，可称为<code>密集波分复用（Dense Wavelength Division Multiplexing）</code>。</p>
<p>波分复用的原理可以参考物理上的三棱镜实验，即白光可以拆分为不同颜色的光，而光的颜色是由光的频率决定的。棱柱为波分复用与解复用提供了基础。波分复用的复用器是接受一系列不同波长的光，然后通过一个棱柱将它们合并成一束光，然后接收端的解复用器再次通过棱镜将它们还原成不同波长的光。示意图如下：</p>
<p><img src="/ch_11_multiplexing_and_demultiplexing/2019-12-08-12-15-12.png" alt="波分复用"></p>
<h1 id="Time_Division_Multiplexing（TDM）"><a class="header-anchor" href="#Time_Division_Multiplexing（TDM）">#</a>Time Division Multiplexing（TDM）</h1>
<p><code>时分复用（Time Division Multiplexing，TDM）</code>的原理很简单，即每个信源使用共同的媒介一段时间，然后供下一个信源使用。示意图如下：</p>
<p><img src="/ch_11_multiplexing_and_demultiplexing/2019-12-08-12-18-29.png" alt="时分复用"></p>
<h1 id="Synchronous_TDM"><a class="header-anchor" href="#Synchronous_TDM">#</a>Synchronous TDM</h1>
<p>时分复用在计算机网络中是一个比较宽泛的概念。因此在实际运用中，上节中的概念图会在细节上有变化。例如有些时分复用系统并不是所有信源按顺序一个个发送。有些时分复用的系统中，每个信源发送间也并不像上图一样有时间间隔，一个信源发送后另一个信源会马上发送，这种系统称为<code>同步时间复用系统（Synchronous TDM）</code>。如下图所示：</p>
<p><img src="/ch_11_multiplexing_and_demultiplexing/2019-12-08-14-34-28.png" alt="同步TDM"></p>
<h1 id="Framing_Used_In_The_Telephone_System_Version_Of_TDM"><a class="header-anchor" href="#Framing_Used_In_The_Telephone_System_Version_Of_TDM">#</a>Framing Used In The Telephone System Version Of TDM</h1>
<p>如之前所述，电话系统的两端是模拟信号，中间传输的是数字信号。对于中间使用同一个媒介传输的数字信号是通过同步时间复用系统来进行复用的。在电话系统中在时间复用系统中用了一个特殊技术来保证接收端和发送端的时间是对齐的，因为一旦接收端的时间出现了偏差，则可能将错误的信号传递给错误的目的地。为了解决这个问题，电话系统中的时间复用系统需要额外传输一个<code>信道帧（Framing Channel）</code>来表示一轮传输的开始，如下图所示：</p>
<p><img src="/ch_11_multiplexing_and_demultiplexing/2019-12-08-14-42-09.png" alt="信道帧"></p>
<h1 id="Hierarchical_TDM"><a class="header-anchor" href="#Hierarchical_TDM">#</a>Hierarchical TDM</h1>
<p>如同频分复用，时间复用也可以是分层的。不同的是，在频分复用系统中，每一级增加的是频率，在时分复用系统中每一级增加的是数据速率（减少时间切分间隔）。另外每一级的数据速率略大于前一级所有数据速率的总和，这是因为要传输额外帧数据。分层时间复用如下图：</p>
<p><img src="/ch_11_multiplexing_and_demultiplexing/2019-12-08-14-46-19.png" alt=""></p>
<h1 id="The_Problem_With_Synchronous_TDM_Unfilled_Slots"><a class="header-anchor" href="#The_Problem_With_Synchronous_TDM_Unfilled_Slots">#</a>The Problem With Synchronous TDM: Unfilled Slots</h1>
<p>同步时间复用对与每个信源都平均的提供时间，即将整个信道的容量（容量可看作一秒能传输的数据量）平分。但如果一个信源在某一段是空白数据，那么当轮到这个信源发送数据时，只能往信道内填空白数据（通常填0），且额外增加一位表示该数据是无效的，而不是正好全是0。这样会造成信道容量的浪费。如下图所示：</p>
<p><img src="/ch_11_multiplexing_and_demultiplexing/2019-12-08-14-50-26.png" alt="未填充数据时间复用"></p>
<h1 id="Statistical_TDM"><a class="header-anchor" href="#Statistical_TDM">#</a>Statistical TDM</h1>
<p>为了解决同步TDM这个问题，有个称为<code>统计时间复用（Statistical TDM）</code>，或称为异步时间复用（Asynchronous）的技术。这个技术仍然是所有信源轮询的传输数据，但是当信源没有数据时，并非像同步时间同步那样装填空白数据，而是直接跳过。如下图所示：</p>
<p><img src="/ch_11_multiplexing_and_demultiplexing/2019-12-08-14-54-27.png" alt="统计时间复用"></p>
<p>尽管这个方法解决了空白数据造成的信道容量浪费，但需要引入额外的数据来表明每个数据块是哪个信源的。</p>
<h1 id="Inverse_Multiplexing"><a class="header-anchor" href="#Inverse_Multiplexing">#</a>Inverse Multiplexing</h1>
<p><code>逆复用（Inverse Multiplexing）</code>技术是用类似于复用的思维方式，但解决是只有两个信源，但其中有多个传输媒介，且两信源有大量的数据需要传输，但中间媒介没有一个有足够的足够的比特率。逆复用技术就是将原数据拆分成多份，然后通过中间的低容量媒介进行传输，最后在接收端再将数据合并在一起。示意图如下图所示：</p>
<p><img src="/ch_11_multiplexing_and_demultiplexing/2019-12-08-15-04-52.png" alt="逆复用"></p>
<p>虽然逆复用看着很像复用的反向使用，即将复用的输出端变成输入，输入端变成输出，但在实际使用时，不能简单的将复用器反向设计得到逆复用器。逆复用器在发射端必须考虑如何将数据拆分后分配给多个低速率媒介。在接收端也必须考虑多个媒介的传输速率不同，可能造成某些媒介中的数据到达特别缓慢，这时候该如何处理。</p>
<h1 id="Code_Division_Multiplexing"><a class="header-anchor" href="#Code_Division_Multiplexing">#</a>Code Division Multiplexing</h1>
<p><code>码分复用（Code Division Multiplexing）</code>是在蜂窝电话（Cellular telephone）和卫星通信中使用的复用方法。与频分复用和时分复用不同的是，码分复用并不依赖与物理特性，而是利用数学特性：两个正交的线段可以被结合在一起而不会互相干扰。</p>
<p>每个信源都有一个不同的二进制码$C_i$，每个信源的二进制码都必须与其他信源的二进制码正交。即将这些二进制码看作是线段（1保持1，0看成-1），这些线段间必须两两垂直。每个信源都将原数据与二进制码叉乘，然后传输结果，复用的过程即是将所有的结果都累加在一起，在接收端每个信源的目的地再相应的将接受到的复用数据再次与对应信源的二进制码点乘，结果即为该信源应该收到的数据。</p>
<p>下面以一个例子方便理解。</p>
<p>假设有两个信源，两个信源的$C_i$分别是$(1,0)和(1,1)$，需要传输的数据分别是$(1,0,1,0)$和$(0,1,1,0)$。传输过程如下：</p>
<p>将原数据和二进制码改为向量，即1为1，0变-1。<br>
信源1：$C_1=(1,-1)$，$V_1=(1,-1,1,-1)$<br>
信源2：$C_2=(1,1)$，$V_2=(-1,1,1,-1)$</p>
<p>可以看到$C_1$和$C_2$是正交的。</p>
<p>复用过程即为:<br>
$$<br>
(C_1 \times V_1) + (C_2\times V_2)= \\<br>
((1,-1),(-1,1),(1,-1),(-1,1))+((-1,-1),(1,1),(1,1),(-1,-1))\\<br>
=((0,-2),(0,2),(2,0),(-2,0))<br>
$$</p>
<p>((0,-2),(0,2),(2,0),(-2,0))即为复用后的结果。</p>
<p>对于信源1的接收端而言，解复用过程为：</p>
<p>$$(1,-1)\cdot((0,-2),(0,2),(2,0),(-2,0))\\<br>
=((0+2),(0-2),(2+0),(-2+0))\\<br>
=(2,-2,2,-2)<br>
$$</p>
<p>负数变为0，正数变为1，即接收端1收到数据为(1,-1,1,-1)，与信源1发送数据相同。</p>
<p>对于信源2的接收端来说，解复用过程如下：</p>
<p>$$(1,1)\cdot((0,-2),(0,2),(2,0),(-2,0))\\<br>
=((0-2),(0+2),(2+0),(-2+0))\\<br>
=(-2,2,2,-2)<br>
$$</p>
<p>负数变为0，正数变为1，即接收端2收到数据为(-1,1,1,-1)，与信源2发送数据相同。</p>
<p>上述例子中，每个信源的二进制码$c_i$都比较小，但在实际运用中$c_i$可能会很大，这就导致了计算量的上升。如果数据本身并不多，但是花费了大量时间计算，效率比较低，因此在数据量不高的网络中CDM并不适用，</p>
<p>但是高数据量网络中，码分复用非常常见，因为相对于时间复用，码分复用的延迟较低。因为码分复用可以将多个信源的数据一次性同时发送给发送端，而时分复用则必须等待轮询到自己才能发送一部分。</p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《Computer Networks and Internets》 Ch 13 局域网：数据包，帧 和拓扑结构</title>
    <url>/ch_13_local_area_networks_packets,_frames,_and_topologies/</url>
    <content><![CDATA[<h1 id="Introduction"><a class="header-anchor" href="#Introduction">#</a>Introduction</h1>
<p>这一部分将介绍分组交换技术，拓扑结构，硬件地址寻址，帧的概念。</p>
<h1 id="Circuit_Switching_And_Analog_Communication"><a class="header-anchor" href="#Circuit_Switching_And_Analog_Communication">#</a>Circuit Switching And Analog Communication</h1>
<p><code>电路交换（Circuit Switching）</code>概念是指使用时在发送端和接收端之间建立不受干扰的通路的通信方法。电路交换通常与模拟电话技术相关。下图是电路交换的示意图：</p>
<p><img src="/ch_13_local_area_networks_packets,_frames,_and_topologies/2019-12-09-08-28-27.png" alt="电路交换"></p>
<p>电路交换的主要特点是：</p>
<ol>
<li>是点对点的通信</li>
<li>有单独的步骤建立电路连接，使用电路，终止电路连接<br>
例如在电话通信中，实际上有三步。第一步在电话发起人和接受者之间建立电路，第二步双方使用电路进行通信，第三步在通话结束后，终止通路。<br>
这也是称为交换（Switched）电路的原因</li>
<li>与固定的物理通路有相同的性能。</li>
</ol>
<p>电路交换建立的电路最终使用频分复用或者时分复用使用同一个媒介进行传输。电路建立的过程包括在频分复用或时分复用中分配频率或时间段。</p>
<h1 id="Packet_Switching"><a class="header-anchor" href="#Packet_Switching">#</a>Packet Switching</h1>
<p>分组交换（Packet Switching）使用一种统计意义上的复用，即多个信源之间竞争共享媒介的使用。电路交换通常在传统的电话通信中使用，而分组交换构成了因特网的基础。分组交换示意图如下：</p>
<p><img src="/ch_13_local_area_networks_packets,_frames,_and_topologies/2019-12-09-08-37-20.png" alt="分组交换"></p>
<p>注意，在11章中提到的复用技术，如频分复用和时分复用是对于物理存在的信道或者像电路交换这样生成的信道使用的，与分组交换并没有关系。分组交换本身就有统计复用（Statistic Multiplexing）的概念。多个信源在媒介空闲时竞争使用，当媒介为空，且只有一个信源需要传输数据时，该信源就会独占媒介。如果同时有多个信源要传输数据，则基本每个信源占据媒介的时间是平均的，轮流使用。</p>
<p>分组交换的核心是将原数据切分成一个个小块方便传输，这些小块称作包（Packets），包中需要包括传送的目的地信息（在之后节会更详细说明）。分组交换传输的单位不是bit或者byte,而是包。不同的分组交换技术对于包的尺寸有不同的定义。</p>
<p>分组交换的主要特点是：</p>
<ol>
<li>任意大小的异步传输</li>
<li>在通信前没有建立通路的步骤</li>
<li>性能取决于各信源的包的统计复用</li>
</ol>
<p>分组交换的主要优点在于成本的控制。对于电路交换来说，如果有$N$个电脑，则需要$N/2$个独立的路径（虽然在连接时才创建）。但对于分组交换只要一个共享的电路就行。</p>
<h1 id="Local_And_Wide_Area_Packet_Networks"><a class="header-anchor" href="#Local_And_Wide_Area_Packet_Networks">#</a>Local And Wide Area Packet Networks</h1>
<p>分组交换技术通常根据传输距离的距离进行分类。通常分为三类：</p>
<ol>
<li>局域网（Local Area Network,LAN）：最便宜，通常范围在房间级或者一个大楼。</li>
<li>城域网（Metropolitan Area Network,MAN）中等开销，范围涵盖城市或者大都会。</li>
<li>广域网（Wide Area Network,WAN）：最贵。范围通常包含城市与城市之间。</li>
</ol>
<p>在实际使用中，虽然城域网的概念被提出，但在商业上并不成功。基本广泛使用的只有局域网和广域网，城域网的概念在逐步被纳入广域网中。</p>
<p>还有一些机构或者商家定义的类似的分类方式，如：</p>
<ol>
<li><code>个人局域网络（Personal Area Network，PAN）</code>，通常范围在几米内，如蓝牙通信等。</li>
<li><code>芯片局域网络（Chip Area Network）</code>，芯片厂商提出的概念，通常是超大型电路（Very-Large-Scale-Integration,VLSI）中多个核之间的通信。</li>
</ol>
<h1 id="Standards_For_Packet_Format_And_Identification"><a class="header-anchor" href="#Standards_For_Packet_Format_And_Identification">#</a>Standards For Packet Format And Identification</h1>
<p>每个在网络中传输的包都必须包含其目标收信人的标识。需要有规范来制定标识的格式以及添加的位置，在LAN领域最常用的标准是由IEEE（Institute Electrical And Electronics Engineers）创建的。</p>
<p>IEEE是由一群关注于协议栈最下两层（物理层（Physical）和数据链接层（Data Link））的工程师构成的。协议栈的不同层由不同的机构负责，如IEFT关注传输层和因特网协议，WWW组织关注应用层。机构与其关注的协议如下图所示：</p>
<p>在1980年，IEEE组织了<code>802项目局域网/城域网标准委员（Project 802 LAN/MAN Standards Commitee）</code>会为网络设定标准。</p>
<p><img src="/ch_13_local_area_networks_packets,_frames,_and_topologies/2019-12-09-09-12-05.png" alt="组织和协议"></p>
<h1 id="IEEE_802_Model_And_Standards"><a class="header-anchor" href="#IEEE_802_Model_And_Standards">#</a>IEEE 802 Model And Standards</h1>
<p>IEEE将数据链接层又在细分为了两层，<code>逻辑链接控制层（Logical Link Control,LLC）</code>(第15章中描述)和<code>媒介访问控制层（Media Access Control,MAC）</code>。</p>
<p>逻辑链接控制层设备的地址和在解复用中地址的使用。媒介访问控制层关注于多个计算机如何共享底层的媒介。</p>
<p>IEEE对于协议的命名是采用多部分标识符，如$XXX.YYY.ZZZ$，$XXX$表示协议的分类，$YYY$表示协议的子分类，$ZZZ$是当子分类也非常大是，额外添加的标识。</p>
<p>如局域网的规范在分类802中，这里的802并不是什么缩写或有实际的技术含义，仅仅是一个分类标识。IEEE不同的工作小组针对其细分的协议进行定义，如针对$802.1$或$802.2$。</p>
<p>IEEE中有许多不同的工作小组。当有新技术需要协议时，由工业代表和学术协会共同形成工作小组，他们会定期开会商定协议的细节等，当协议的所有细节都确定后，IEEE会发表协议的标准文件。</p>
<p>当协议最终发布后，工作小组可以选择解散或者如果协议非常重要或者仍需要后续工作，小组也可以继续活动。如果小组负责的部分协议不再有意义，如商业上不被接受，或者有更新更好的技术出现，小组也可以选择直接解散而不发表任何的规范。下图是802分类下的协议，有一些规范就已经被放弃（Disbanded）了。</p>
<p><img src="/ch_13_local_area_networks_packets,_frames,_and_topologies/2019-12-09-09-25-59.png" alt="802协议"></p>
<h2 id="LAN_Topologies"><a class="header-anchor" href="#LAN_Topologies">#</a>LAN Topologies</h2>
<p>因为有许多不同的LAN技术，通常使用拓扑型或者网络的基本形状来进行分类。LAN有四个基本的拓扑型，<code>总线型结构（Bus）</code>，<code>环状结构（Ring）</code>，<code>星状结构（Star）</code>，<code>网状结构（Mesh）</code>。</p>
<h2 id="Bus_Topology"><a class="header-anchor" href="#Bus_Topology">#</a>Bus Topology</h2>
<p><code>总线型结构（Bus Topology）</code>是如同以太网一样，用一根电缆连接所有电脑，任何电脑都可以将数据传输到电缆上，然后所有的计算机都可以接受到数据。</p>
<h2 id="Ring_Topology"><a class="header-anchor" href="#Ring_Topology">#</a>Ring Topology</h2>
<p><code>环状结构（Ring Topology）</code>是多个电脑首尾相接的连接，直至成为环形。环形结构的优点是对于相连的两台设备来说连接是安全的，即使别的设备出现问题仍然可以连接。</p>
<h2 id="Mesh_Topology"><a class="header-anchor" href="#Mesh_Topology">#</a>Mesh Topology</h2>
<p><code>网状结构（Mesh Topology）</code>为任意两两配对的电脑都提供了连接线路，这意味着如果有$N$台电脑，就需要$\frac{n^2-n}{2}$个连接。当增加电脑时，连接电缆的增加是平方级的，因此开销巨大，也因此网状结构在局域网中不常被使用</p>
<h2 id="Star_Topology"><a class="header-anchor" href="#Star_Topology">#</a>Star Topology</h2>
<p><code>星状结构（Star Topology）</code>是所有的电脑都连接在一个中心设备（Hub）上。注意星状结构并不严格要求中心设备真的在所有电脑的中心，与所有电脑的距离相同。</p>
<h2 id="The_Reason_For_Multiple_Topologies"><a class="header-anchor" href="#The_Reason_For_Multiple_Topologies">#</a>The Reason For Multiple Topologies</h2>
<p>每个结构都有各自的优点，如环状结构很适合各电脑间协调访问，但当其中一个设备出现问题时，通路就会出现问题。星状结构下单一设备出现了问题，其他设备都可以正常访问。总线结构有最少的连接需求，但与环状结构与相同的缺点。网状结构因为连接数量过多，通常不在局域网中使用。</p>
<h1 id="Packet_Identification，Demultiplexing，Mac_Addresses"><a class="header-anchor" href="#Packet_Identification，Demultiplexing，Mac_Addresses">#</a>Packet Identification，Demultiplexing，Mac Addresses</h1>
<p>IEEE为寻址（Addressing）创建了标准。在分组交换中，解复用是依赖于一个称为<code>地址（Address）</code>的标识。每个电脑都分配了一个独特的地址，每个传输的包中都包含其目标收件人（Intended Recipent）的地址。</p>
<p>在IEEE的寻址规范中，每个地址是由48-bit二进制数据组成的，IEEE将其称为媒介访问控制地址（Media Access Control address,MAC address）。因为48位地址来源于以太网技术，所以也有人将其称为以太网地址（Ethernet Address）。</p>
<p>IEEE为每块网卡（Network Interface Card，NIC）都分配了地址，因此当消费者购买了一张网卡时，其中就包含一个独一无二的地址。</p>
<p>但IEEE并不是单独的为每个网卡分配地址，它是将前24位（3 Bytes）分配给设备供应商，然后设备供应商再决定后24位的数据。因此前24位称为组织唯一标识符（Organizationally Unique Identifier，OUI），后24位称为网络接口控制标识符（Network Interface Controller Specific）。</p>
<p>组织唯一标识符的最高有效字节（Most Significant Byte，即大端模式下即最左端）的倒数两位有特殊含义。其最低位表示是单播（0）还是双播（1）。倒数第二位决定该设备是全球唯一（0）（Globally Unique）还是是本地分配（1）（Locally Assigned），全球唯一表明地址是IEEE分配，即世界上的每块网卡都有不同的表示，而本地分配是实验性网卡或者某组织自己地址空间等，即这张卡是在一个小范围内内部使用。</p>
<h1 id="Unicast，Broadcast，And_Multicast_Addresses"><a class="header-anchor" href="#Unicast，Broadcast，And_Multicast_Addresses">#</a>Unicast，Broadcast，And Multicast Addresses</h1>
<p>IEEE定义了三种对应包传递的方法：</p>
<ol>
<li>单播（Unicast）：目标地址是设定一个电脑，也仅这个电脑可收到包</li>
<li>广播（broadcast）：网络中的所有电脑都可收到包</li>
<li>多播（multicast）：目标地址是一系列的电脑，这些电脑都可以收到包。</li>
</ol>
<p>对于广播来说，因为是所有电脑都收到包，所以目标地址实际是没有意义的。将地址的48位全部设为1，则表示是广播模式。广播模式也可看作是多播模式的一个特殊情况。</p>
<h1 id="Broadcast_Multicast_And_Efficient_Multi_Point_Delivery"><a class="header-anchor" href="#Broadcast_Multicast_And_Efficient_Multi_Point_Delivery">#</a>Broadcast,Multicast,And Efficient Multi-Point Delivery</h1>
<p>广播和多播模式在局域网中特别有用，对于要传递给多台电脑的数据来说，用这两种方法进行传递特别的高效。</p>
<p>对于大多数的LAN技术，都是通过一个共享的媒介进行传输。当有数据在媒介中传输时，每台电脑都将从媒介中获取包的拷贝，然后再判断包中的地址情况是否与自己复合，来决定是处理包的内容还是丢弃包的内容。</p>
<p>因此局域网中的计算机在处理媒介中的包流程如下：</p>
<ol>
<li>从包中抽取出地址信息</li>
<li>判断地址是否满足自己的单播地址，如果是则接受并处理包</li>
<li>如果2失败，判断地址是否是广播模式，如果是则接受并处理包</li>
<li>如果3失败，判断地址是否是多播模式，且电脑是多播模式指定的电脑组的一员，如果是则接受并处理包</li>
<li>如果4失败，则丢弃包</li>
</ol>
<p>如在局域网情况下，如果多台电脑使用同一个媒介，且包需要传递给多态电脑，那么使用多播和广播模式，数据仅需要发送一次即可。</p>
<h1 id="Frames_And_Framing"><a class="header-anchor" href="#Frames_And_Framing">#</a>Frames And Framing</h1>
<p>在同步通信系统中，帧的概念是让接收者知道数据的开始和结束。但在更宽泛的概念下，帧是表示一系列bit或byte的特定结构，让接收方和发送方都能一致同意的特定格式。</p>
<p>在分组交换中，帧的概念就对应包。在分组交换中，每个包都需要一个数据头，数据头（header）中包含目标地址。数据头后是有效负载（payload），即真正需要传输的原数据。在大部分的网络技术中，有效负载是不透明的即网络设备只能检查数据头。</p>
<p>在整个包的前后还能加入可选的前置数据（Prelude）或后置数据（Postlude）。因此整个包的结构如下所示：</p>
<p><img src="/ch_13_local_area_networks_packets,_frames,_and_topologies/2019-12-09-10-47-15.png" alt="包的结构"></p>
<p>举一个例子，如果一个包有6个byte的数据头，然后任意长度的有效负载，在包的前后各有1byte表示包的开始和结束。且开始和结束标识用ASCII码中的SOH（Start Of Header）和EOT（End Of Transmission）表示，则整个包如下所示：</p>
<p><img src="/ch_13_local_area_networks_packets,_frames,_and_topologies/2019-12-09-10-49-20.png" alt="包的例子"></p>
<p>上述例子有一点点数据的浪费，因为如果包是一个接一个发的，那么后一个包的SOH会紧跟着前一个包的EOT。在实际中，只需要一个来区分两个包即可。</p>
<p>虽然包的前置数据和后置数据是可选的，但在实际使用中，他们可以一定程度上提升异步传输数据的处理速度和对错误的检测。在异步传输中，如果接收方收到了EOT，它就知道数据包传输完成了，可以直接开始处理数据而不需要等到下一个包的到来再根据新包确定上个包是否完成。当发送端发送数据到一般崩溃时，因为接收端始终收不到EOT，也就能知道错误的发生。</p>
<h1 id="Byte_And_Bit_Stuffing"><a class="header-anchor" href="#Byte_And_Bit_Stuffing">#</a>Byte And Bit Stuffing</h1>
<p>在ASCII码中，SOH用十六进制0x01表示，EOT用0x04表示。如果有效负载中也出现了0x01和0x04，接收端就无法判定到底是真实数据还是前置或后置标识。</p>
<p>一种称为字节填充（byte Stuffing）就是为了解决有效负载和特殊标记位有相同表示导致无法识别的问题。<br>
该技术有时也称为数据填充（Data Stuffing）或字符填充（Character Stuffing）。该技术主要是</p>
<p>字节装填是用另一个字符来替代特殊标识的出现。</p>
<p>如我们选择用ASCII码中的ESC字符（Ox1B）来作为替换字符。在发送端当有效负载中出现SOH，那么就替换为&quot;ESC A&quot;，如果出现EOT,就替换为&quot;ESC B&quot;，如果出现了ESC就替换为&quot;ESC C&quot;。注意这个计算是针对有效负载的，当整个发送的有效负载中就不会与EOT和SOH相同的数据。对接收端而言，去找寻背后跟着&quot;A,B,C&quot;的ESC字符，然后将其替换回SOH和EOT的数据。发送端的替换过程如下所示：</p>
<p><img src="/ch_13_local_area_networks_packets,_frames,_and_topologies/2019-12-09-11-22-32.png" alt="字节装填"></p>
<h1 id="Reference"><a class="header-anchor" href="#Reference">#</a>Reference</h1>
<p><a href="https://web.archive.org/web/20171217042848/http://www.cs.virginia.edu/~mngroup/projects/mpls/documents/thesis/node8.html">Switching technology</a><br>
<a href="https://www.cnblogs.com/penghuwan/p/7686059.html#_label3_1">【计算机网络】数据交换技术和多路复用技术的正（nao）确(can)打开方式</a></p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《Computer Networks and Internets》 Ch 14 MAC 层</title>
    <url>/ch_14_the_ieee_mac_sublayer/</url>
    <content><![CDATA[<ul>
<li>这一章原书中的Statiion一词，在笔记中翻译为<code>终端</code>。</li>
</ul>
<h1 id="Introduction"><a class="header-anchor" href="#Introduction">#</a>Introduction</h1>
<p>这一章将会深入讨论MAC层，包括多路访问协议（multi-access protocols）以及静态和动态信道分配。</p>
<h1 id="A_Taxonomy_Of_Mechanisms_For_Shared_Access"><a class="header-anchor" href="#A_Taxonomy_Of_Mechanisms_For_Shared_Access">#</a>A Taxonomy Of Mechanisms For Shared Access</h1>
<p>实现多个计算机通过一个共享媒介来访问数据主要有三种方法： （1）复用技术（Multiplexing Technique） （2）分布算法来控制访问（Distributed Algorithms For Controlled Access） （3）随机访问策略（Random Access Strategy）</p>
<ul>
<li>这里的复用技术与在11章中讨论的复用核心思想是相同的，但仍然有略微区别。11章中提到的是物理上的复用，通过复用器将信号合并在一起。这里的复用则是对于共享信道的逻辑划分，使不同的终端占用共享信道的部分资源，所以这里的复用技术也称为<code>信道协议（Channelization Protocols）</code>。</li>
</ul>
<p>下图展示了按照共享媒介所使用的方法的分类：</p>
<p><img src="/ch_14_the_ieee_mac_sublayer/2019-12-27-22-55-32.png" alt="共享媒介的分类方法"></p>
<h1 id="Static_And_Dynamic_Channel_Allocation"><a class="header-anchor" href="#Static_And_Dynamic_Channel_Allocation">#</a>Static And Dynamic Channel Allocation</h1>
<p>信道分配是与第11章中提到的复用技术相关联的。以频分复用为例子，在第11章中是每个终端都有它的载波频率，终端与载波频率是一对一的关系，这就是<code>信道的静态分配（Static Channel Allocation）</code>。</p>
<p>信道可以静态分配的前提是预先知道终端的存在，而且终端在传输过程中不会发生变化。而在许多的场景下，终端是会变化的，例如一个路由器负责房间内手机的信号，但是手机可以关闭或者离开房间，这就是终端的变化。</p>
<p>在这种情况下就需要<code>信道的动态分配（Dynamic Channel Allocation）</code>，即当终端出现时才分配信道的资源给终端。</p>
<h1 id="Channelization_Protocols"><a class="header-anchor" href="#Channelization_Protocols">#</a>Channelization Protocols</h1>
<p>与第11章中的复用技术相似，信道分配也存在频分多路复用（Frequency Division Multi-Access），时分多路复用（Time Division Multi—Access），码分多路复用（Code Division Multi-Access）三种类型。</p>
<h2 id="FDMA"><a class="header-anchor" href="#FDMA">#</a>FDMA</h2>
<p>频分多路复用下每个终端都可以选择一个载波频率，这个频率并不会影响到其他的终端。在有些系统下存在一个中央控制器进而支持动态的频分多路复用：当一个新的终端出现，中央控制器用一个预留的信道与终端通信，然后分配一个未使用的载波频率给这个终端，之后终端都使用这个载波频率传输数据。</p>
<h3 id="TDMA"><a class="header-anchor" href="#TDMA">#</a>TDMA</h3>
<p>时分多路复用下，所有终端按顺序编号，如$1,2,3,…N$，并且会按这个顺序占据信道进行传输。如同频分多路复用，在某些系统下支持动态分配，即终端出现时再分配给他信道的占用时间段。</p>
<h3 id="CDMA"><a class="header-anchor" href="#CDMA">#</a>CDMA</h3>
<p>码分多路复用如同码分复用，通过数学方法将多个终端的数据合并在一起，再同时通过信道进行传输。</p>
<h1 id="Controlled_Access_Protocols"><a class="header-anchor" href="#Controlled_Access_Protocols">#</a>Controlled Access Protocols</h1>
<p>访问控制协议（Controlled Access Protocols）为统计复用提供了方法，主要分为三个类型：</p>
<ol>
<li>轮询（Polling）：控制中央持续的询问每一个终端是否要发送数据。</li>
<li>预留（Reservation）：终端需要发送信息时，发出一个在下一次循环时发送数据的申请。</li>
<li>令牌传递（Token Passing）：终端间循环传递一个令牌，当终端持有令牌时可以发送数据。</li>
</ol>
<h2 id="Polling"><a class="header-anchor" href="#Polling">#</a>Polling</h2>
<p><code>轮询（Polling）</code>系统是存在一个中央控制器，这个控制器会询问其下的每个终端是否需要传递数据。轮询可以再细分为两种，<code>轮询调度顺序（Round Robin Order）</code>和<code>优先顺序（Priority Order）</code>。在轮询调度顺序下，每个终端都有相同的机会传递数据，而在优先顺序下，一些终端会有更多的机会去传递数据。</p>
<p>轮询的算法实现伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">For Centralized Controller:</span><br><span class="line">while(true)</span><br><span class="line">&#123;</span><br><span class="line">  Select a station S, and send a polling message to S;</span><br><span class="line">  Wait for S to respond by sending a packet or passing;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Reservation"><a class="header-anchor" href="#Reservation">#</a>Reservation</h2>
<p><code>预留（Reservation）</code>系统多用在航天系统中，系统分为两个步骤，在第一步中需要传输数据的终端申请，所有申请的终端构成一张表，在第二步中表中的终端开始传输数据。通常第一步与第二步使用的是不同的信道，即有一个信道专门用来接受申请信息，另一个信道作为主信道传递每个终端的数据。</p>
<p>预留的算法实现伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">For Centralized Controller:</span><br><span class="line">While(true)</span><br><span class="line">&#123;</span><br><span class="line">  Form a list of stations that have a packet to send;</span><br><span class="line">  Allow stations on the list to tranmit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Token_Passing"><a class="header-anchor" href="#Token_Passing">#</a>Token Passing</h2>
<p><code>令牌传递（Token Passing）</code>被用在多个局域网（LAN）技术中，被用的最多的就是环形拓步结构中。在一个网络中，某一台计算机持有着一个特殊的控制命令，这个命令被称作为令牌，持有令牌的计算机可以发送数据，在发送完毕后将令牌传递给下一个计算机。</p>
<p>令牌传递的算法实现伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">For each computer:</span><br><span class="line">While(true)</span><br><span class="line">&#123;</span><br><span class="line">  Wait for the token to arrive;</span><br><span class="line">  Transmit a packet if one is waiting to be send;</span><br><span class="line">  Send the token to he next station;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>环形拓补结构中，存在物理的环形链接，所以令牌可以直接传递给相邻的下一个电脑。在其他的拓步结构中，所有的计算机都被赋予了一个逻辑顺序，因此可以获知下一个要收取令牌的电脑是哪个。</p>
<h1 id="Random_Access_Protocols"><a class="header-anchor" href="#Random_Access_Protocols">#</a>Random Access Protocols</h1>
<p>许多网络，特别是局域网络中，并不使用访问控制协议，而使用<code>随机访问协议（Random Access Protocols）</code>。随机访问协议下只有当终端存在数据要发送时，才会被给予权限（在访问控制协议中，每个终端都要被持续检查）。这里的<em>随机</em>是在所有终端都有数据要发送时的处理方式。随机访问协议也可以被分为三类：</p>
<ol>
<li>ALOHA：早期夏威夷的无线电网络中被使用的协议。在教科书中比较流行，因为便于分析，但在实际网络中已不再使用。</li>
<li>CSMA/CD（Carrier Sense Multi-Access With Collision Detection）：原以太网的基础，现在也不再使用。</li>
<li>CSMA/CA（Carrier Sense Multi-Access With Collision Avoidance）：Wifi无线网络的基础。</li>
</ol>
<h2 id="ALOHA"><a class="header-anchor" href="#ALOHA">#</a>ALOHA</h2>
<p>在早期夏威夷的网络中使用，在这个系统下有一个强大的发送器被部署中在物理上的中心位置，其他的终端（通常对应一台计算机）在这个发送器周围部署，这些终端都没有足够的能量将数据直接传输给其他终端，因此需要通过中央的发送器。</p>
<p>中央发送器用两个载波频率与每个终端通信，一个被称为入站频率（In Frequency，407.305MHZ），一个被称为出站频率（Outbound Frequency，413.475MHZ）。终端通过入站频率将数据传递给中央发送器，中央发送器通过出站频率将数据发送给每个终端。</p>
<p>ALOHA的实现逻辑很直接：当终端有数据要发送时，使用入站频率将数据传递给中央数据站，中央数据站通过出站频率将数据传给所有的终端，终端检查数据是否是自己需要的。为了保证数据被正常发送，发送终端也需要监听出站频率，当发送的数据拷贝被传输回发送终端，发送终端确认数据被正常传递了，就会传输下一个数据。反之，则会在一段时间后尝试重新发送。</p>
<p>当两个终端同时使用各自的入站频率传输数据时，两个数据会发送混淆，进而导致信息错误，将这种情况称为信道冲突（Collision）。协议通过等待一段时间后重新发送数据来解决冲突，重新发送数据前的等待时间的设定尤为关键，如果两个终端等待的时间相同，那么再次发送数据时仍然是同时发送则会继续导致冲突。因此等待时间是随机的，但是网络繁忙时，冲突的概率仍然会增加，因为即使是随机时间仍然可能会与其他的终端发生冲突。</p>
<p>ALOHA示意图如下：</p>
<p><img src="/ch_14_the_ieee_mac_sublayer/2019-12-28-12-56-15.png" alt="ALOHA示意图"></p>
<h2 id="CSMA_CD"><a class="header-anchor" href="#CSMA_CD">#</a>CSMA/CD</h2>
<p>1978年，数字设备联盟（Digital Equipment Corporation），英特尔（Intel）和施乐（Xerox）共同指定了个标准（DIX标准），也就是后来的以太网。最早的以太网技术使用一根长电缆连接每个电脑，这根长电缆就是共享媒介，与ALOHA使用中央发送器来实现数据传输不同，在以太网中每个终端都可以通过这个共享的线缆传输数据。以太网同样需要解决冲突问题，以太网主要引入了三个解决冲突的方法，统称为<code>具有冲突检测功能的载波侦听多路访问（CSMA/CD，Carrier Sense Multi-Access With Collision Detection）</code>：</p>
<ol>
<li>载波侦听（Carrier Sense）：</li>
</ol>
<p>在每个终端发送数据前，先监听线缆确定是否有其他的终端正在传输数据。</p>
<ol start="2">
<li>冲突检测（Collision Detection）：</li>
</ol>
<p>虽然有载波侦听，但如果在线缆空闲时，两个需要发送数据的终端同时监听，此时他们都发现线缆空闲，因此都开始传输数据，这时候仍然会造成冲突。因此在传输过程中，发送终端也会持续的监听线缆，如果发现线缆中的数据与发送的数据不同，说明已经发生了冲突，数据被干扰了，于是停止数据的发送。</p>
<p>以太网的数据传输还有一些细节问题，如在检测到冲突时，发送端并不会立刻停止数据的发送，他仍然会传输数据一段时间，保证所有的其他终端都可以收到冲突信号。另外，当一个包被发送完后，发送终端需要等待一段时间，称为<code>包间间隙（Interpacket gap）</code>（在早期10Mbps的以太网中，包间间隙为9.6微秒），保证其他的终端可以检测到线缆的空闲并传递数据。</p>
<ol start="3">
<li>二进制指数补偿（Binary Exponential Backoff）</li>
</ol>
<p>如ALOHA一样，在发现了冲突后，发送端需要等待一段时间重新发送数据，这个等待时间是随机的，通常会设置一个最大延迟时间$d$，然后在$0\sim d$。如之前所述，在网络繁忙时，可能存在随机后终端仍然冲突的情况。二进制指数补偿是指在新一次冲突发生后，随机的范围变成$0\sim 2d$，如果再有冲突则变成$0\sim 4d$，依次类推。</p>
<p>CSMA/CD算法实现伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">For each Computer:</span><br><span class="line"></span><br><span class="line">Wait for a packet to be ready;</span><br><span class="line">Wait for the medium to be idle;</span><br><span class="line">Delay for the interpacket gap;</span><br><span class="line">Set x to be the standard backoff range d;</span><br><span class="line">Attempt to transmit the packet;</span><br><span class="line"></span><br><span class="line">While(Collision occured)</span><br><span class="line">&#123;</span><br><span class="line"> random a delay time q from 0 to x;</span><br><span class="line"> delay for q microseconds;</span><br><span class="line"> double x to be 2x</span><br><span class="line"> attempt to retransmit the packet</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CSMA_CA"><a class="header-anchor" href="#CSMA_CA">#</a>CSMA/CA</h2>
<p>CSMA/CD并不能被运用在无线网络中，因为无线网络中的设备存在一个最远距离$\delta$。即如果两个终端的距离大于$\delta$，则CSMA/DA中的载波监听就无法被应用，因为一个终端并不能知道另一个是否在发送信息。这种情况如下图所示，如果Computer1在发送信息，Computer3是无法得知的，因此冲突只有Computer2可以知晓，这种情况称为<code>隐藏终端问题(Hidden Station Problem)</code>。</p>
<p><img src="/ch_14_the_ieee_mac_sublayer/2019-12-28-15-00-02.png" alt="隐藏终端问题"></p>
<p>所以无线网络中使用<code>具有冲突规避的载波侦听多路访问（CSMA/CA，Carrier Sense Multi-Access With Collision Avoidance）</code>。以上图的例子，Computer3在发送数据前会先向所有它的$\delta$范围内的设备发出一个短信息表明自己需要发送数据了，接受到Computer3发出的短信息的设备会检查自己是否正在接受其他的数据，如果不是则回复可以发送的信号。如下图所示：</p>
<p><img src="/ch_14_the_ieee_mac_sublayer/2019-12-28-15-08-19.png" alt="CSMA/CA图解"></p>
<p>如果发送端没有收到接收方的回执，则会在随机时间后再次尝试发送。</p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《Computer Networks and Internets》 Ch 16 无线网络技术</title>
    <url>/ch_16_wireless_networking_technologies/</url>
    <content><![CDATA[<h1 id="Introduction"><a class="header-anchor" href="#Introduction">#</a>Introduction</h1>
<p>这一章主要介绍计算机网络无线部分的技术。</p>
<p>$16.2$节对无线技术依据网络的覆盖范围做了分类。<br>
$16.3$节介绍了个人局域网。<br>
$16.4$节介绍了ISM频域。<br>
$16.5\sim16.11$都是介绍局域网相关技术，主要关注对象是Wifi技术。<br>
$16.12$介绍了城域网中使用的WiMax技术。<br>
$16.13$给出了个人局域网的标准分类列表。<br>
$16.14$介绍了两个没有被包含在个人局域网中的短距离通信，红外线和射频识别通信。<br>
$16.15\sim16.18$介绍了广域网技术，主要关注蜂窝式网络。<br>
$16.19和16.20$介绍了卫星通信。<br>
$16.20$介绍了软件无线电系统。</p>
<h1 id="A_Taxonomy_Of_Wireless_Networks"><a class="header-anchor" href="#A_Taxonomy_Of_Wireless_Networks">#</a>A Taxonomy Of Wireless Networks</h1>
<p>计算机网络无线技术的变种非常多的原因之一在于因为政府的管理，电磁信号的频谱被切分为了许多不同的部分以供不同的目的使用，而这些不同频域的技术通常都不同。</p>
<p>无线技术通常通过其使用的范围来分类，主要可分为：<code>局域网（Local Area Networks,LANs）</code>，<code>城域网（Metropolitan Area Networks,MANs）</code>，<code>广域网（Wide Area Networks，WANs</code>）以及<code>个人局域网（ Personal Area Networks，PANs）</code>。如下图所示：</p>
<p><img src="/ch_16_wireless_networking_technologies/2019-12-30-15-51-47.png" alt="无线网络分类"></p>
<h1 id="Personal_Area_Networks（PANs）"><a class="header-anchor" href="#Personal_Area_Networks（PANs）">#</a>Personal Area Networks（PANs）</h1>
<p>上节中对于无线网络的分类与在第十三章中对于网络的分类十分类似，不同的是这里还引入了个人局域网（Personal Area Networks，PANs）的概念。个人局域网是提供非常短距离下的通信，通常是只供一个用户使用，如蓝牙耳机就属于个人局域网的应用。</p>
<p>个人局域网络可以再细分为以下几种：</p>
<ol>
<li>蓝牙（Bluetooth）：距离较短</li>
<li>红外线（Infrared）：视距通信（Line-Of-Sight Communication）即发射端和接收端之间需要无遮挡</li>
<li>紫峰（ZigBee）：距离可以支撑一个住宅的范围，在智能家居中被运用。</li>
<li>其他ISM无线技术：为工业，科学以及医药（Industrial，Scientific，Medical，ISM）预留的频率发展的技术。</li>
</ol>
<h1 id="ISM_Wireless_Bands_Used_By_LANs_And_PANs"><a class="header-anchor" href="#ISM_Wireless_Bands_Used_By_LANs_And_PANs">#</a>ISM Wireless Bands Used By LANs And PANs</h1>
<p>振幅为了工业，科学以及医药领域专门预留了一部分频域，被称为ISM无线。这部分的频域并没有再进一步细分，如科学只能用哪一段频域之类。这三个领域的产品都可以使用这部分频域，具体频域如下图所示：</p>
<p><img src="/ch_16_wireless_networking_technologies/2019-12-30-16-04-51.png" alt="ISM频域"></p>
<h1 id="Wireless_LAN_Technologies_And_Wi_Fi"><a class="header-anchor" href="#Wireless_LAN_Technologies_And_Wi_Fi">#</a>Wireless LAN Technologies And Wi-Fi</h1>
<p>IEEE将局域网下的无线网络协议分类在$802.11$下。1999年一些销售商建立了Wifi联盟，一个生产和验证使用802.11协议的无线设备的非盈利组织。因为这个联盟的产品在商业市场上反应很好，消费者将Wifi一词与无线局域网联系在了一起，Wifi原先是产品广告词中<code>Wireless Fidelity</code>的缩写。</p>
<p>下表为Wifi联盟所指定的协议：</p>
<p><img src="/ch_16_wireless_networking_technologies/2019-12-30-16-21-32.png" alt="Wifi联盟协议"></p>
<h1 id="Spread_Spectrum_Technology"><a class="header-anchor" href="#Spread_Spectrum_Technology">#</a>Spread Spectrum Technology</h1>
<p>在第十一章中提到的展频技术（Spread Spectrum Technology）在wifi技术中也有应用。</p>
<p>展频技术的原理是发送端将原先的信道频域再细分为多个部分，将数据通过不同的频率发送出去，接收端接受多个频率的数据，再还原出原信号。使用展频技术主要目的有两个，一是增加传输速率，另外是增加对噪声的抗干扰能力。</p>
<p>Wifi技术主要用了以下扩频技术，其主要目的还是帮助Wifi在有噪声环境下能更好的工作：</p>
<ol>
<li>
<p>直接扩频（Direct Sequence Spread Spectrum，DSSS）：</p>
<p>发送端使用一个序列码得到不同的频率，用这些频率来发送数据。</p>
</li>
<li>
<p>跳频扩频（Frequency Hopping Spread Spectrum，FHSS）：</p>
<p>载波的频率一直在设定的几个频率间切换。</p>
</li>
<li>
<p>正交频率复用（Orthogonal Frequency Division Multiplexing，OFDM）：</p>
<p>将原信道分为多个小信道，每个小信道传输一部分的数据。</p>
</li>
</ol>
<ul>
<li>书中并未对三个技术做详细的解释，上面的概括解释也可能存在错误。</li>
</ul>
<p>三个技术都有各自的优点，OFDM有最高的适用性，DSSS性能好，FHSS对于噪声的抗干扰能力强。</p>
<h1 id="Other_Wireless_LAN_Standards"><a class="header-anchor" href="#Other_Wireless_LAN_Standards">#</a>Other Wireless LAN Standards</h1>
<p>除了上述Wifi联盟所指定的协议，无线局域网还有其他许多的协议，都属于$802.11$协议分类下如下图所示：</p>
<p><img src="/ch_16_wireless_networking_technologies/2019-12-30-16-48-56.png" alt="其他802.11协议"></p>
<h1 id="Wireless_LAN_Architecture"><a class="header-anchor" href="#Wireless_LAN_Architecture">#</a>Wireless LAN Architecture</h1>
<p>局域网无线网络结构主要有三个因素：（1）<code>接入点（Access Point）</code>，有时也被称为<code>基站（Base Station）</code>。（2） <code>互联机制（Interconnection mechanism）</code>，例如路由器或者交换机，用来将接入点连接在一起。（3）一系列<code>终端（Hosts）</code>，如个人手机就是一个终端。</p>
<p>存在两种无线局域网，一是<code>自主网（Ad hoc）</code>，其中所有的终端都可以在没有接入点的情况下相互通信。另外一个是<code>基础设施结构（Infrastructure）</code>。</p>
<p>在实际运用中，自主网很少存在，基础设施结构如下图所示，图中的$AP$即为接入点（Access Point），一个接入点和连接它的一系列终端称为<code>基本服务集（Basic Service Set，BSS）</code>。</p>
<p><img src="/ch_16_wireless_networking_technologies/2019-12-30-16-59-39.png" alt="基础设施结构"></p>
<h1 id="Overlap，Association，And_802_11_Frame_Format"><a class="header-anchor" href="#Overlap，Association，And_802_11_Frame_Format">#</a>Overlap，Association，And 802.11 Frame Format</h1>
<p>在实际运用中，基础设施结构中的接入点如果距离太远，会出现<code>无服务区（Dead Zone）</code>，距离太仅的话，他们的覆盖的范围会出现重叠（Overlap），因此终端可能会同时存在于两个接入点的范围内。在这种情况下，终端需要指定他与哪个接入点进行通信，因此在$802.11$协议定义的网络帧格式下，帧数据必须包含其连接的接入点的MAC地址。</p>
<p>另外如果基础设施结构是要连接外网的，那么接入点的互联机制还需要另外一个有线连接至与外网连接的路由器，如下图所示，下图也同时展示了上述的接入点重叠情况</p>
<p><img src="/ch_16_wireless_networking_technologies/2019-12-30-17-06-11.png" alt="外网连接以及接入点重叠"></p>
<p>$802.11$的定义的数据帧，还需要指定连接外网的路由器的MAC地址，综上数据帧的结构如下：</p>
<p><img src="/ch_16_wireless_networking_technologies/2019-12-30-17-07-42.png" alt="802.11数据帧"></p>
<h1 id="Coordination_Among_Access_Points"><a class="header-anchor" href="#Coordination_Among_Access_Points">#</a>Coordination Among Access Points</h1>
<p>如上节所述，在接入点重叠的情况下，终端需要决定与哪个接入点进行通信。</p>
<p>主要有两种方法来实现接入点的切换，第一个是靠接入点本身，接入点能相互通信，当接入点发现有终端同时收到多个接入点信号时，接入点会判断信号强度然后帮助终端无缝切换，这种方法实现较为复杂且成本较高。第二种方法下，所有接入点都是独立的，切换是靠终端本身实现，这种方法的成本较低。</p>
<h1 id="Contention_And_Contention_Free_Access"><a class="header-anchor" href="#Contention_And_Contention_Free_Access">#</a>Contention And Contention-Free Access</h1>
<p>$802.11$定义了两种信道访问的方式：无竞争（Contention-Free）的点协调方式（Point Coordinated Function，PCF）和存在竞争的分布协调方式（Distributed Coordinated Function，DCF）。</p>
<p>PCF方式保证在一个基本服务集中的接入点保证下面的终端不会发生任何干扰，例如通过给每一个终端一个特定的频率来实现。但在实际中PCF从来都没有被使用过。</p>
<p>DCF则是让一个基本服务集中的终端都使用<code>随机访问协议（Random Access Protocols）</code>。并如同在十四章中的介绍，因为$802.11$是无线网络，所以通常使用的是CSMA/CA，终端需要发送准备完毕（Ready to Send，RTS）和信道空闲（Clear To Send，CTS）两种控制命令。</p>
<p>$802.11$中使用的CSMA/CA还包含一些在十四章未提及的细节，如定义了以下三个时间参数：</p>
<ol>
<li>
<p>短帧时间间隔（Short Inter-Frame Space,SIFS）为10微秒。</p>
<p>接收端在发送确认信息（Acknowledge，ACK）或其他控制命令前的等待时间。</p>
</li>
<li>
<p>帧间间隔（Distributed Inter-Frame Space）为50微秒。</p>
<p>在发送端发送数据前必须等待的时间，以保证其他的终端可以监听到信道的空闲。</p>
</li>
<li>
<p>时隙（Slot Time）为20微秒</p>
</li>
</ol>
<p>Wifi网络中所使用的CSMA/CA如下图所示：</p>
<p><img src="/ch_16_wireless_networking_technologies/2019-12-30-21-20-32.png" alt="Wifi网络中所使用的CSMA/CA"></p>
<p>因为各终端间的物理间隔以及环境噪声，微弱信号的检测是很困难的，因此Wifi网络并没有引入CSMA/CA中的冲突检测（Collision Detection）部分，即发送端并不会在数据发送过程中监听信道来判断是否有冲突。在Wifi网络中，发送端会等待ACK信号，如果没有收到ACK信号，发送端则认为数据发送失败。</p>
<h1 id="Wireless_MAN_Technology_And_WiMax"><a class="header-anchor" href="#Wireless_MAN_Technology_And_WiMax">#</a>Wireless MAN Technology And WiMax</h1>
<p>城域网技术的协议被反类在$802.16$中。如同在局域网中主要使用的是Wifi，在城域网中主要使用的事WiMax（World-wide Interoperability For Microwave Access）技术。</p>
<p>WiMax可以再被细分为固定WiMax和移动WiMax，前者是指服务提供方与连接者的位置是固定的，如大楼间的通信，后者则指接收方是可以移动的，如用户的手机和电脑等。</p>
<p>WiMax在城域网中的使用，如果是用在回传网络（服务提供方之间的连接，通常需要较高的数据速率）中则需要无阻碍（Line-Of-Sight，LOS）的连接，如果是在服务提供方与接入点直接的连接则也可以使用有阻碍的连接（Non-Line-Of-Sight，NLOS），如下图所示：</p>
<p><img src="/ch_16_wireless_networking_technologies/2019-12-30-22-02-35.png" alt="WiMax的使用"></p>
<h1 id="PAN_Technologies_And_Standards"><a class="header-anchor" href="#PAN_Technologies_And_Standards">#</a>PAN Technologies And Standards</h1>
<p>PAN技术被分类在$802.15$分类下，如下图所示：</p>
<p><img src="/ch_16_wireless_networking_technologies/2019-12-30-22-04-05.png" alt="PAN技术"></p>
<h1 id="Other_Short_Distantce_Communication_Technologies"><a class="header-anchor" href="#Other_Short_Distantce_Communication_Technologies">#</a>Other Short-Distantce Communication Technologies</h1>
<p>还有两种技术短距离的通信方式并没有被分类在PANs下，红外通信（Infrared Data Association，IrDA）以及射频识别（Radio Frequency Identification，RFID）通信。</p>
<p>红外通信是方向性的，大约有30°的范围，而且信号可以在障碍物表面反射，但是并不能传统障碍物。电视遥控器即是使用了红外通信。</p>
<p>射频识别通信，是一个芯片中包含有验证信息的Tag，接收方可以将信息从芯片中读取出来。酒店的门禁卡，大学食堂的饭卡等都是使用了这个技术。</p>
<h1 id="Wireless_WAN_Technologies"><a class="header-anchor" href="#Wireless_WAN_Technologies">#</a>Wireless WAN Technologies</h1>
<p>广域网通信有两大类，蜂窝式通信系统（Cellular communication systems）和卫星通信系统（Satellite communication system）。</p>
<p>蜂窝式通信系统最早是为了满足手机的电话服务设计的。在这个系统下，地区被风格为一个个小块称为<code>巣室（Cell）</code>，每个巣室都包含一个基站塔，一系列基站塔由一个移动交换中心控制。这个中心会追踪用户，并在用户从一个巣室进入另一个巣室时，提供巣室的切换服务。蜂窝式系统的结构如下图：</p>
<p><img src="/ch_16_wireless_networking_technologies/2019-12-30-22-18-47.png" alt="蜂窝式系统结构"></p>
<p>理论上每个巣室都是六边形的，那么就能无缝的分割区域，但在实际运用中，每个基站塔的覆盖范围大致是圆形的，因此就会出现重叠或者无服务区。且基站塔的覆盖范围由所处区域的用户数量决定，如果用户数量很多，则每个基站塔的覆盖范围会较小，且有更多的基站塔，反之每个基站塔覆盖很大一块区域。理论和实际的巣室图如下，（a）图为理想情况，（b）图为实际情况：</p>
<p><img src="/ch_16_wireless_networking_technologies/2019-12-30-22-21-33.png" alt="巣室情况"></p>
<h1 id="Micro_Cells"><a class="header-anchor" href="#Micro_Cells">#</a>Micro Cells</h1>
<p>如上节所述，用户密度越大，则设计时每个巣室的面积越小。在城市中，有时会出现一个巣室仅覆盖大楼的一层这种情况，这是称其为微巣室（Micro Cells）。因为巣室很小且很小块区域内有多个巣室，为了避免干扰，微巣室的功率都比较小。</p>
<h1 id="Cell_Clusters_And_Frequency_Reuse"><a class="header-anchor" href="#Cell_Clusters_And_Frequency_Reuse">#</a>Cell Clusters And Frequency Reuse</h1>
<p>蜂窝式通信有一个重要原则：相邻的巣室在不使用相同频率的载波情况下，干扰最小。</p>
<p>蜂窝式系统使用称为巣室簇的结构构成，每个巣室簇都由特定数目的巣室构成，其中的每个巣室频率都不同。通常而言，巣室簇由3，4，7或12个巣室构成，如下图所示：</p>
<p><img src="/ch_16_wireless_networking_technologies/2019-12-30-23-19-08.png" alt="巣室簇"></p>
<p>巣室簇中的每个巣室频率不同，将巣室簇拼接后就不会有相邻巣室频率相同的情况出现，如下图为7巣室簇拼接：</p>
<p><img src="/ch_16_wireless_networking_technologies/2019-12-30-23-20-04.png" alt="巣室簇拼接"></p>
<h1 id="Generations_Of_Cellular_Technologies"><a class="header-anchor" href="#Generations_Of_Cellular_Technologies">#</a>Generations Of Cellular Technologies</h1>
<p>目前通信技术的发展有四代，称为1G,2G,3G和4G：</p>
<ol>
<li>1G：出现在1970年代后期，通过模拟信号传递语音信息。</li>
<li>2G和2.5G：从1990年代早期开始发展，至今仍然在使用。与1G的主要区别在于，2G使用了数字信号传递语音信息。2.5G是2G的扩展，实现了部分3G的特性。</li>
<li>3G和2.5G：从2000年开始发展，主要关注高速数据服务。3G系统提供400Kbps到2Mbps的数据速度。</li>
<li>4G：从大约2008年开始使用，主要关注实时媒体的使用，如电视直播，高速视频下载等。4G手机通常包含多种数据连接方式，如Wifi和卫星通信。</li>
</ol>
<p>在2G技术发展过程中，许多组织都尝试定义标准，欧洲主要使用TDMA技术并制订了GSM标准（Global System For Mobile Communication），该标准逐渐称为了全球标准。在美国，摩托罗拉使用TDMA技术定义了iDEM标准。同时大部分其他的美国运营商和亚洲运营商都使用了CDMA技术来指定标准。</p>
<p>在3G时代，EVDO（Evolution Data Optimized/Evolution Data Only）和EVDV标准几乎同时出现，两者都是CDMA和FDM技术的混合。EVDO技术被运用的较为广泛。</p>
<p>在设计4G标准时，国际通信协会（ITU）指定了4G蜂窝式系统的标准，称为<code>IMT-Advanced（International Mobile Telecommunication Advaced）</code>。其指定终端在高速移动时（如在火车上）应该有100Mbps的数据速率，而在静止时应该有100Mbps的速率。</p>
<p>在早期，运营商指定的4G标准，如<code>HSPA+</code>，<code>HTC Evo 4G</code>，<code>WiMax</code>和<code>LTE（Long Term Evolution）</code>都未满足要求。但是ITU还是允许了他们使用4G作为自己的广告语，在后期，<code>LTE-Advanced</code>和<code>WiMax Advanced</code>满足了ITU的标准，被称为真4G。</p>
<p>3G和4G的主要区别在于，3G系统设计时仍然是基于语音通话系统考虑的，还是继承自原先的模拟电话系统，其他的数据是作为额外的要求。而在4G标准设计时主要考虑因特网协议，因此4G系统使用了帧交换而语音只是作为一个特殊应用。在实际应用中，许多蜂窝系统仍然通过3G来传输通话信息，而在其他数据时使用4G。</p>
<h1 id="VSAT_Satellite_Technology"><a class="header-anchor" href="#VSAT_Satellite_Technology">#</a>VSAT Satellite Technology</h1>
<p>卫星通信的关键是用一个曲面天线（Parabolic antenna/Dish）保证电磁信号被反射到一个单一点上，如下图所示：</p>
<p><img src="/ch_16_wireless_networking_technologies/2019-12-30-23-39-52.png" alt="曲面天线"></p>
<p>为了最大化收集到的信号，早期的卫星通信系统使用直径大于3米的曲面天线，但这种尺寸的天线并不适用于个人或小商家。于是称为<code>甚小口径天线终端（Very Small Aperture Terminal，VSAT）</code>的技术出现，它指代直径小于3米的曲面天线，通常直径在1米以下。</p>
<p>VSAT卫星通信选择的频率不同会影响信号强度，天气环境变化的敏感程度，和信号的覆盖范围（Satellite’s footprint）。如下表所示：</p>
<p><img src="/ch_16_wireless_networking_technologies/2019-12-30-23-45-24.png" alt="VSAT卫星频率"></p>
<h1 id="GPS_Satellites"><a class="header-anchor" href="#GPS_Satellites">#</a>GPS Satellites</h1>
<p>GPS（Global Positioning System）卫星提供实时的准确位置信息。GPS通信并非是计算机通信的一部分，但是越来越多的移动网络使用了位置信息。</p>
<p>GPS系统通过三颗卫星计算出终端的位置。首先要计算终端距离三颗卫星的距离，距离可以通过卫星与终端的传输时间乘上光速来确定。如果一个终端与卫星的距离为$d$，则终端出现在以卫星为球星，半径为$d$的球上任意位置。通过三个卫星，可以计算出三个球，三个球的交点为两个点（两个球的交点为一个圆形）。这两个交点，一个在太空中，一个在地球上，地球上的点即为终端的位置。</p>
<h1 id="Software_Defined_Radio_And_The_Future_Of_Wireless"><a class="header-anchor" href="#Software_Defined_Radio_And_The_Future_Of_Wireless">#</a>Software Defined Radio And The Future Of Wireless</h1>
<p>通常一个蜂窝网络手机需要指定天线，发射器和接收器的规格，这些数据都是需要预先指定的。如果同时支持GSM，Wifi和CDMA，则需要三套独立的无线电系统，使用时在其中切换。</p>
<p>现在传统的无线电系统被软件无线电取代，可以通过软件来指定的特性如下表所示：</p>
<p><img src="/ch_16_wireless_networking_technologies/2019-12-30-23-53-54.png" alt="软件无线电可以设定的特性"></p>
<p>软件无线电的一大特性是可以同时使用多个天线，称实现了多天线同时传输和接受的系统为<code>MIMO（Multiple-Input Multiple-Output）</code>系统。</p>
<p>通过软件来设定通信特性也有一定的危险性，如用户可以选择被政府限制的频率来发送数据或者占据为紧急服务预留的频道。因此这个技术也需要严格规范。</p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《Computer Networks and Internets》 Ch 17 中继器，网桥和交换机</title>
    <url>/ch_17_repeaters,_bridges,_and_switches/</url>
    <content><![CDATA[<h1 id="Introduction"><a class="header-anchor" href="#Introduction">#</a>Introduction</h1>
<p>这一章会介绍关于扩展 LAN 的方法，如中继器（Repeaters）和网桥（Bridges），也会介绍在网桥存在循环时解决死循环的<code>生成树算法(Spannning tree algorithms)</code>。最后会讨论交换机和网桥之间的关系。</p>
<h1 id="Distance_Limitation_And_LAN_Design"><a class="header-anchor" href="#Distance_Limitation_And_LAN_Design">#</a>Distance Limitation And LAN Design</h1>
<p>距离限制是 LAN 计算的核心，工程师们需要从最大延迟，信道容量和传输距离间做权衡。因为 LAN 中的硬件设备的发送功率是固定的，所以如果两个设备之间的电缆长度增加，其中的信号强度就会减弱，导致错误的发生。</p>
<h1 id="Fiber_Modem_Extensions"><a class="header-anchor" href="#Fiber_Modem_Extensions">#</a>Fiber Modem Extensions</h1>
<p>解决 LAN 距离的方法通常不是增加信号的强度也不是增加电缆，而是增加额外的硬件设备来转播信号。</p>
<p>最简单的 LAN 扩展方法是通过一根光纤和一堆光纤调制解调器，如下图所示：</p>
<p><img src="/ch_17_repeaters,_bridges,_and_switches/2020-01-03-08-27-17.png" alt="光纤调制解调器扩展"></p>
<p>一个光纤调制解调器与计算机设备连接，另一个光纤调制解调器与通向以太网的交换机或集线器连接，两个光纤调制解调器用光纤连接。这样计算机设备就能与以太网进行连接。</p>
<h1 id="Repeaters"><a class="header-anchor" href="#Repeaters">#</a>Repeaters</h1>
<p>中继器（Repeaters）是一个用来传播 LAN 信号的模拟设备，中继器并不理解包和 Bit 数据，它只是将接受到的信号放大再传播出去。</p>
<p>一个中继器的典型应用就是使用遥控器控制其他房间的设备，将中继器放置在另一个房间，在遥控器所在房间，将 Sensor 通过线缆与中继器相连。当本房间的 Sensor 搜到信号后，信号后传输给中继器，中继器放大后传播出去，另一个房间的设备就会收到，如下图所示：</p>
<p><img src="/ch_17_repeaters,_bridges,_and_switches/2020-01-03-08-35-01.png" alt=""></p>
<h1 id="Bridges_And_Bridging"><a class="header-anchor" href="#Bridges_And_Bridging">#</a>Bridges And Bridging</h1>
<p>网桥（Bridges）是连接两组 LAN 设备（如两个集线器）并且在它们之间传输包的方法。网桥是以混杂模式监听每组 LAN 设备，即数据发送给其下的任意一个设备，该数据都会被网桥检测到。因此，被网桥连接的两组设备表现如同是一组设备，即一组中的设备可以发送数据给另一组设备，且当一个设备广播时，两组设备中的所有设备都能接受到。而在网桥下的设备是无法区分自己是在一个单一的一组设备下（如只是在集线器下）还是在网桥下。</p>
<ul>
<li>这里将书中描述的 Segment 翻译为一组设备，如一个集线器下的设备。</li>
</ul>
<p>网桥连接的示意图如下：</p>
<p><img src="/ch_17_repeaters,_bridges,_and_switches/2020-01-03-09-14-18.png" alt=""></p>
<h1 id="Learning_Bridges_And_Frame_Filtering"><a class="header-anchor" href="#Learning_Bridges_And_Frame_Filtering">#</a>Learning Bridges And Frame Filtering</h1>
<p>虽然网桥是以混杂模式监听，且可以让两组设备表现的如同在同一组，但是网桥并不会盲目的将数据从一组设备传递给另一组。网桥监听到数据后会针对包的目标 MAC 地址过滤数据，仅将数据发送给需要的一组设备。当让，在广播或者多播模式下，网桥直接将数据发送给两个设备的，以保证广播或者多播的正常运行。</p>
<p>大多数网桥被称为自适应网桥（Adaptive/Learning Bridges），因为他们可以自动识别出每个设备是处于哪个分组下。当一个数据包经过网桥时，网桥会读取源地址，然后判断两组设备列表中是否有该发送设备，如果没有，则将发送设备放在符合的设备列表下。同时也会读取目标地址，决定数据需要发送给哪部分设备，如果目标地址在两组设备列表中都不存在，则两组设备都会收到网桥的转发的数据。</p>
<p>下表是发送网桥发送数据的例子。在第一行即网桥启动时，两组数据的列表都是空的。第二行即数据从 A 设备发送给 B 设备，此时先检测出将发送端 A 是在 Segment1 中，但此时 B 不在任何列表中，所以数据会发送给两个部分。第三行即数据从 B 设备发送给 A 设备，先检测出发送端 B 设备是再 Segment1 中，而 A 也在 Segment1 种，所以数据只要在 Segment1 中传输即可。同理可以分析其他的发送数据。</p>
<p><img src="/ch_17_repeaters,_bridges,_and_switches/2020-01-03-09-30-16.png" alt="网桥数据发送"></p>
<h1 id="Why_Bridging_Works_Well"><a class="header-anchor" href="#Why_Bridging_Works_Well">#</a>Why Bridging Works Well</h1>
<p>当网桥知道其下的所有设备处于哪个部分后，数据在网桥之间的传输效率要大于数据在真正的单一分组中的传输。</p>
<p>以上节中的示意图为例，当网桥知道所有的设备处于哪个部分后，如果数据从 A 发送给 B，那么数据只要在 Segment1 中传输，同理如果数据从 X 发送给 Y，数据只要在 Segment2 中传输。因此，这两个传输行为是可以同时进行的，因为它们都只是发生在各自的部分中。而如果所有设备都是在一个真正的单一分组下，即 A，B，X，Y 是共享一个媒介传输，两个传输行为也就不可能同时发生。</p>
<p>因此可以将设备分组后，用网桥连接来增加数据传输的效率。</p>
<h1 id="Distributed_Spanning_Tree"><a class="header-anchor" href="#Distributed_Spanning_Tree">#</a>Distributed Spanning Tree</h1>
<p>如果一系列设备如下图所示连接（每个 HUb 下有多个设备，图中未展现）：</p>
<p><img src="/ch_17_repeaters,_bridges,_and_switches/2020-01-03-09-37-20.png" alt=""></p>
<p>可以看到图中的设备形成了一个循环，在这种情况下广播的数据会发生死循环。因为网桥收到广播数据后会直接向前传递，而在网桥形成循环后，每个网桥的直接向前传递就会导致信息始终在循环中传输。</p>
<p>为了解决这个问题，电子设备协会（Digital Equipment Corporation）在 1985 年为以太网设计了一个称为<code>生成树协议（Spannning Tree Protocol,STP）</code>的方法。STP 方法是通过算法从一系列网桥 STP 计算出一个<code>分布生成树（Distributed Spanning Tree）</code>。协议规定如果将包的广播地址设为<code>01:80:C2:00:00:00</code>即表示使用 STP 方法。STP 方法的步骤如下：</p>
<ol>
<li>
<p>先找到一个网桥作为根。</p>
<p>每个网桥都有一个 ID 地址，算法将 ID 最小的网桥作为根。</p>
<p>每个网桥的 ID 地址都由两部分组成，第一部分是 16bit 长的可配置优先级数字，第二部分是 48bits 长的 MAC 地址。当比较 ID 地址时，会首先判断第一部分，在第一部分相同的情况下判断第二部分。因为第一部分是可配置的，所以管理员是可以指定某一个网桥作为根的。</p>
</li>
<li>
<p>最短路径计算</p>
<p>每个网桥都计算自己与根网桥的最短路径。</p>
</li>
<li>
<p>传递数据</p>
<p>网桥之间的数据传递，只能由最短路径传输。</p>
</li>
</ol>
<p>在上图展示的循环中，如果 Hub1 广播数据，那么 Hub4 收到数据的通路就是$Hub1-&gt;Hub4$，而更长的路径，如$Hub1-&gt;Hub2-&gt;Hub3-&gt;Hub4$就会被禁止，因此更长的循环路径也同样会被禁止。</p>
<h1 id="Switching_And_Layer_2_switchers"><a class="header-anchor" href="#Switching_And_Layer_2_switchers">#</a>Switching And Layer 2 switchers</h1>
<p><code>桥接（bridging）</code>的概念可以帮助理解现代以太网的基础：<code>交换（switching）</code>。一个以太网交换机（Ethernet switch）有时也被称为二层交换机（Layer-2 switch）。交换机如同集线器一样，有多个接口，每个接口都与一个计算机相连。交换机和集线器的不同在于，集线器如模拟设备一样，是将电脑传输的信号传递出去，而交换机是数字设备，传递的是电脑的数据包。可以将集线器想象成一个共享媒介，而把交换器想象成一个由网桥连接的网络，其中每个部分都只有一台电脑。</p>
<p>交换机可以想象成如下图的结构，可以看到交换机的左侧是三个网桥，每个网桥连接两个设备：</p>
<p><img src="/ch_17_repeaters,_bridges,_and_switches/2020-01-03-10-22-38.png" alt=""></p>
<p>但上图只是一个概念图，实际中的交换机中并没有网桥，而是每个端口都于一个<code>智能接口（Intelligent Interface）</code>相连，然后有个中央光纤将所有的接口连接在一起，而且这光纤支持两两配对的接口间的同时传输（如之前提到的网桥连接的两部分间的设备可同时传输一样）。</p>
<p>每个智能接口都有处理器和内存，因此可以判断需要传递的路线以及在目标端口繁忙时缓存数据，如电脑 1 和电脑 2 同时要向电脑 3 传输数据，则电脑 1 或电脑 2 中的一台会先将要传输的数据缓存起来。实际的交换机结构如下：</p>
<p><img src="/ch_17_repeaters,_bridges,_and_switches/2020-01-03-10-27-51.png" alt=""></p>
<p>交换机相对于集线器最大的优点在于并行。集线器在同一时间只能支持一个传输，而交换机可以同时进行多个独立的传输（这里的独立指不会有多个来自于不同地址的数据要发送给同一端口）。因此如果一个交换机有$N$个端口，最多可以有$N/2$个传输同时进行。</p>
<h1 id="VLAN_Switchers"><a class="header-anchor" href="#VLAN_Switchers">#</a>VLAN Switchers</h1>
<p>当一个交换机被扩展了虚拟功能，即称为虚拟局域网交换机（Virtual Local Area Network Switch,VLAN Switcher）。虚拟局域网交换机的功能就是让单一的交换机模拟成是多个独立的交换机，即管理者可以将一台交换机的其中某几个端口定义是在一个模拟局域网中，而另几个端口是在另外一个模拟局域网中，这样的话其中一个模拟局域网中的设备发送广播数据，另一个模拟局域网中的端口并不会接受到信息。</p>
<p>这种通过 VLAN 切分广播域的做法在公司环境下很关键，如一层楼只有一个交换机，但广播数据的发送并不希望整层楼都能收到。</p>
<h1 id="Multiple_Switchers_And_Shared_VLANs"><a class="header-anchor" href="#Multiple_Switchers_And_Shared_VLANs">#</a>Multiple Switchers And Shared VLANs</h1>
<p>交换机通常被部署在离计算机较近的地方，如每层楼都有一个交换机。在公司环境下有种情况是同一个部门可能处于不同的楼层，那么同一个部门的网络在不同的交换机下。在有多个交换机的情况下，上节中提到的 VLAN 会遇到问题。当只有一个交换机时，根据端口号分好 VLAN 后，数据的传输指定端口号就能判断出数据应该处于哪个 VLAN 中。但如果有两台交换机，两台交换机的同一端口，如端口 1，可能是在不同的 VLAN 下，因此光指定端口号是无法知道其到底在哪个 VLAN。</p>
<p>为了在多个交换机中使用 VLAN 技术，IEEE 扩展了以太网协议，记录在$802.1Q$中。该协议下，在以太网的数据包的头字段中，增加 16bit 长的数据表示 VLAN Tag，表示需要传递给 VLAN。在 802.1Q 协议下的以太网数据包如下图所示：</p>
<p><img src="/ch_17_repeaters,_bridges,_and_switches/2020-01-03-11-13-59.png" alt=""></p>
<p>即使是使用了多交换机的 VLAN，$802.1Q$协议下的以太网数据包仅在交换机之间传输，而在交换机与电脑间传输的包仍然是普通以太网数据包，因为只有交换机才能解析$802.1Q$数据。使用$802.1Q$实现 VLAN 的交换机如下图所示</p>
<p><img src="/ch_17_repeaters,_bridges,_and_switches/2020-01-03-11-15-56.png" alt=""></p>
<p>以上图为例，如果图中的 A，B，D，E 共处于 VLAN 17 中，当 A 广播数据后，B 会直接收到数据，然后交换机 1 会将$17$作为 VLAN Tag 插入到数据包头中，然后传递给交换机 2，交换机 2 在收到数据后，取出其中的 VLAN tag，并将包传递给 D 和 E。</p>
<h1 id="The_importance_Of_Bridging"><a class="header-anchor" href="#The_importance_Of_Bridging">#</a>The importance Of Bridging</h1>
<p>虽然现在很少会有厂商生产单独的网桥，但是桥接的概念已经被整合入网络设备中。如无线网络的路由器就整合了提供桥接功能的以太网的交换器，通常将其中交换机的端口称为<code>本地端口（Local Port）</code>，将连接网络调制解调器的端口称为<code>因特网端口（Internet Port）</code>。当两个本地的电脑传输数据时，无线路由器并不会将数据发送给网络服务商，而是直接将数据在本地进行传输（类似于桥接的分组功能）。</p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《Computer Networks and Internets》 笔记汇总</title>
    <url>/computer_networks_and_internets/</url>
    <content><![CDATA[<h1 id="Introduction_And_Internet_Applications"><a class="header-anchor" href="#Introduction_And_Internet_Applications">#</a>Introduction And Internet Applications</h1>
<p><a href="/ch_01_introduction_and_overview">Ch 01 Introduction And Overview</a></p>
<h1 id="Data_Communication_Basics"><a class="header-anchor" href="#Data_Communication_Basics">#</a>Data Communication Basics</h1>
<p><a href="/ch_05_overview_of_data_communications">Ch 05 Overview Of Data Communications</a></p>
<p><a href="/ch_06_information_sources_and_signals">Ch 06 Information Sources And Signals</a></p>
<p><a href="/ch_07_transmission_media">Ch 07 Transmission Media</a></p>
<p><a href="/ch_08_reliability_and_channel_coding">Ch 08 Reliability And Channel Coding</a></p>
<p><a href="/ch_10_modulation_and_modems">Ch 10 Modulation And Modems</a></p>
<p><a href="/ch_11_multiplexing_and_demultiplexing">Ch 11 Multiplexing And Demultiplexing (Channelization)</a></p>
<h1 id="Packet_Switching_And_Network_Technologies"><a class="header-anchor" href="#Packet_Switching_And_Network_Technologies">#</a>Packet Switching And Network Technologies</h1>
<p><a href="/ch_13_local_area_networks_packets,_frames,_and_topologies">Ch 13 Local Area Networks Packets, Frames, And Topologies</a></p>
<p><a href="/ch_14_the_ieee_mac_sublayer">Ch 14 The IEEE MAC Sublayer</a></p>
<p><a href="/ch_16_wireless_networking_technologies">Ch 16 Wireless Networking Technologies</a></p>
<p><a href="/ch_17_repeaters,_bridges,_and_switches">Ch 17 Repeaters, Bridges, And Switches</a></p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《Head First 设计模式》 - 设计原则总结</title>
    <url>/head_first_design_pattern_design_principles/</url>
    <content><![CDATA[<ol>
<li>将变化的部分封装起来（Encapsulate what varies)</li>
<li>组合优于继承（Favor composition over inheritance）</li>
<li>面向接口编程而非实现（Program to interfaces, not implementations.）</li>
<li>减少需要交互的类之间的耦合（Strive for loosely coupled designs between objects that interact）</li>
<li>对拓展开放，对修改关闭（Classes should be open for extension but closed for modification.）</li>
<li>依赖于抽象而非具体的类（ Depend on abstraction. Do not depend on concrete classes）</li>
<li>暴露最少的信息给其他类（最少知识原则）（Talk only to your immediate friends）</li>
<li>高层有对底层的管理，而底层不需要关心高层何时会调用自己（好莱坞原则）（Don’t call us ,we’ll call you）</li>
<li>一个类应该有且只有一个被改变的理由（A class should have only one reason to change）</li>
</ol>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>《Head First 设计模式》 笔记汇总</title>
    <url>/head_first_design_patterns/</url>
    <content><![CDATA[<p><a href="/ch_01_the_strategy_pattern">Ch 01 the Strategy Pattern</a></p>
<p><a href="/ch_02_the_observer_pattern">Ch 02 the Observer Pattern</a></p>
<p><a href="/ch_03_the_decorator_pattern">Ch 03 the Decorator Pattern</a></p>
<p><a href="/ch_04_the_factory_pattern">Ch 04 the Factory Pattern</a></p>
<p><a href="/ch_05_the_singleton_pattern">Ch 05 the Singleton Pattern</a></p>
<p><a href="/ch_06_the_command_pattern">Ch 06 the Command Pattern</a></p>
<p><a href="/ch_07_the_adapter_and_facade_patterns">Ch 07 the Adapter and Facade Patterns</a></p>
<p><a href="/ch_08_the_template_method_pattern">Ch 08 the Template Method Pattern</a></p>
<p><a href="/ch_09_the_iterator_and_composite_pattern">Ch 09 the Iterator and Composite Pattern</a></p>
<p><a href="/ch_10_the_state_pattern">Ch 10 the State Pattern</a></p>
<p><a href="/ch_11_the_proxy_pattern">Ch 11 the Proxy Pattern</a></p>
<p><a href="/ch_12_the_compound_patterns">Ch 12 the Compound Patterns</a></p>
<p><a href="/head_first_design_pattern_design_principles">Head First Design Pattern Design Principles</a></p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>《Render Hell》 笔记汇总</title>
    <url>/render_hell/</url>
    <content><![CDATA[<ul>
<li><a href="/book_1_overview">Book 1 Overview</a></li>
<li><a href="/book_2_pipeline">Book 2 Pipeline</a></li>
<li><a href="/book_3_problems">Book 3 Problems</a></li>
<li><a href="/book_4_solutions">Book 4 Solutions</a></li>
</ul>
<h1 id="Reference"><a class="header-anchor" href="#Reference">#</a>Reference</h1>
<p><a href="http://simonschreibt.de/gat/renderhell/">Render Hell 2.0 | Simon schreibt.</a></p>
]]></content>
      <tags>
        <tag>GPU</tag>
      </tags>
  </entry>
  <entry>
    <title>《贪婪的多巴胺》 读书笔记</title>
    <url>/tan_lan_de_duo_ba_an/</url>
    <content><![CDATA[<p>《贪婪的多巴胺》 笔记摘抄。该书主要从生物学角度介绍了多巴胺对人行为及心理的影响。主要的包括：</p>
<ul>
<li>多巴胺与当下因子：当下因子让人关注当下，多巴胺让人关注未来</li>
<li>多巴胺与自律的关系：毒品美食的吸引力来自于欲望多巴胺，抵抗这些诱惑的能力不仅可以依赖意志力，也可以依赖控制多巴胺。</li>
<li>多巴胺与创造力的关系：丰富的多巴胺，让人更多的关注抽象的概念，并压抑了对此刻的关注，这可能会带来更多的创造力。但过多的多巴胺，则可能带来如精神分裂症这样的疾病</li>
<li>多巴胺与保守的关系：多巴胺能的人倾向于自由主义，当下分子能的人倾向于保守主义。</li>
</ul>
<h1 id="第一章_爱情"><a class="header-anchor" href="#第一章_爱情">#</a>第一章 爱情</h1>
<p>二十万分之一的脑细胞可以产生多巴胺，但这些细胞却能对行为产生巨大的影响。</p>
<p>在特定的情况下，激活让人“感觉良好”的多巴胺是人们无法抗拒的诱惑。一些科学家给多巴胺取名为“快乐分子”，大脑中产生多巴胺的途径被称为“奖赏回路“。但实际上多巴胺跟快乐一点儿关系都没有，它的影响力比“快乐”要大得多</p>
<p>多巴胺不是快乐的制造者，而是对意外的反应，即对可能性和预期的反应。我们每时每刻都在预测将要发生的事，从什么时候可以下班，到在自动取款机上看到卡里有多少余额。实际发生的事好于我们的预期，就表明我们对未来的预言存在误差：可能我们可以提前下班了，或者查看余额时发现比预期多了 100 元。正是这种让人快乐的误差触发多巴胺行动起来。这种快乐不是源于额外的时间或钱本身，而是预期之外的好消息带来的兴奋感。</p>
<p>多巴胺能的兴奋（即预期带来的兴奋）并不持久，因为最终未来都会变成现在。</p>
<p>多巴胺的角度来说，拥有是无趣的，只有获得才有趣。</p>
<p>为了享受我们拥有的东西，而不是仅仅可能得到的东西，我们的大脑必须从面向未来的多巴胺过渡到面向现在的某种化学物质，这是一系列神经递质，我们称之为“<strong>当下分子</strong>“。事实上，尽管多巴胺和当下分子的回路能一起工作，但在大多数情况下它们是相互对抗的。在当下分子回路被激活时，我们更喜欢体验周围的真实世界，多巴胺就会被抑制；而当多巴胺回路被激活时，我们则进入一个充满可能性的未来，当下分子会被抑制。</p>
<p>基于当下神经递质，如<strong>催产素、血管升压素和内啡肽</strong>的作用，它会为你提供长期的幸福感。这就像我们心中总是有最喜欢的餐厅、商店、城市一样，我们之所以喜爱这些地方，是因为熟悉的环境总是能给我们带来快乐，这里所说的环境指那个地方真实的物理环境。我们喜欢熟悉的事物，不是因为它能变成什么，而是因为它本来的样子。</p>
<p>多巴胺代表着痴迷与渴望，而与长期关系最相关的化学物质则是催产素和血管升压素。催产素在女性中更活跃，而血管升压素在男性中更活跃。</p>
<p>性就是爱情的快进。性始于欲望，是由睾酮这种激素驱动的一种多巴胺能的现象。接下来是性兴奋，这也是一种期待性的多巴胺能的体验。当身体接触开始时，大脑就将控制权转移到当下分子以便提供感官体验的愉悦，这个过程主要涉及内啡肽的释放。这一行为的顶峰，即性高潮，几乎完全是一种此时此地的体验，内啡肽和其他当下神经递质一起工作，将多巴胺彻底关闭。除了少数例外，大脑对性高潮的反应是相同的：多巴胺被关闭，当下分子通行。但是，正如有些人很难从激情之爱过渡到陪伴之爱，由多巴胺驱动的人在性生活中也很难把主导权让给当下分子。也就是说，有着强烈多巴胺驱动力的女性和男性有时会发现，他们难以停止自己的想法，去纯粹地体验性爱中亲昵的感觉——少一些思考，多一些感觉对他们来说非常困难。</p>
<h1 id="第二章_毒品"><a class="header-anchor" href="#第二章_毒品">#</a>第二章 毒品</h1>
<p>欲望始于大脑中一个在进化上早就存在的区域，位于头骨深处，被称为腹侧被盖区。这一区域富含多巴胺，是多巴胺两个主要的产生区域之一。像大多数脑细胞一样，生长在那里的细胞长着长长的尾巴，穿过大脑到达伏隔核。这些长尾巴的细胞被激活时，会将多巴胺释放到伏隔核中，让我们产生做某事的动力。这个回路叫作中脑边缘通路，但我们通常更直白地称之为 <strong>多巴胺欲望回路</strong>。</p>
<p><img src="/tan_lan_de_duo_ba_an/image-20230212202055360.png" alt="欲望回路"></p>
<p>买家之所以会懊悔，就是因为当下体验无法弥补多巴胺能激励的损失。这是欲望回路描绘的美好前景被打破的一个体现。它告诉你，如果你购买了那辆昂贵的车，你会欣喜若狂，你的生活肯定也会改变。但是，在你买入之后，你却没有特别强烈的感觉，而且这种感觉也不会很持久。想要和喜欢是由大脑中的两个不同的系统产生的，所以我们想要的东西往往是我们不喜欢的。</p>
<p>一种避免购买后懊悔的方法是购买一些能触发更多多巴胺能预期的东西，例如，一种工具（如一台能大大提高工作效率的新电脑），或者一件让你出门时看起来更迷人的新夹克。</p>
<p>毒品会“劫持”欲望回路。它们与食物或性等自然奖赏一样会刺激大脑激励系统，但它们刺激大脑的强度远甚于自然奖赏。成瘾性药物像导弹一样，以猛烈的“化学爆炸”冲击着欲望回路。任何自然行为都比不上它，食物、性，什么都比不上。</p>
<p>多巴胺系统的目标是预测未来，当一个意想不到的奖赏出现时，它就会发送一个信号说：“注意！现在要学习一些新东西了。”这样，沉浸在多巴胺中的脑回路就产生了可塑性，它们变成了新的样式。新的记忆被储藏，新的连接也形成了。“记住发生了什么，”多巴胺回路说，“这在将来可能有用。”最终结果是什么？下次奖赏出现时，你就不会感到惊讶了。当你发现一个网站播放着你最喜欢的音乐时，你会感到兴奋，但下一次访问这个网站时就不会了，它不再有任何奖赏预测误差。多巴胺并不是一种持久的快乐储存体。毒品破坏了大脑正常运作所需的微妙平衡。无论吸毒者处于何种情况，毒品都会刺激多巴胺的释放。于是，大脑变得混乱不堪，开始将吸毒与一切事物联系起来</p>
<p>当你期望的奖赏没有实现时，多巴胺系统就会关闭。用科学术语来讲，当多巴胺系统处于静止状态时，它会以每秒 3 到 5 次的速度被激发。但当它兴奋时，它的激发速率会激增到每秒 20 到 30 次。当预期的奖赏没有实现时，多巴胺的激发速率会下降到零，而这种感觉很糟糕。就是为什么多巴胺的停止会让你感到愤恨和失落，一个正在恢复的毒瘾患者每天保持克制和冷静时也是这种感受。克服上瘾需要付出巨大的力量、决心和支持。不要轻易招惹多巴胺，它的反击会让人招架不住</p>
<p>多巴胺的增加会让人热情参与自己原本认为不重要的事务。例如，有报道称一些吸大麻的人会站在水池前，看着水龙头不断地滴水，这一平平无奇的景象让他们看得十分着迷。欲望多巴胺压制了大脑中更理性的部分。我们知道自己做出的选择并不符合我们的最大利益，但我们无力抗拒。这就好比我们的自由意志已经屈服于一种强烈的及时行乐的冲动——也许是我们在节食时吃的一袋薯片，也许是一夜挥霍。</p>
<p>上瘾不是性格软弱或意志力不足的表现，它只是欲望回路因过度刺激而进入病理状态时会发生的情况。</p>
<p>帕金森病是一种多巴胺缺乏症，患有这种病的人负责控制肌肉运动的一条通路中多巴胺不足。这条通路，简单地说，就是我们将内心世界转化为行动，以及将意志施加给世界的途径。当这条通路中没有足够的多巴胺时，人就会僵硬和颤抖，并且移动缓慢。治疗方法是吃一些能促进多巴胺增长的药物。</p>
<p>什么样的大脑回路强大到足以对抗多巴胺呢？答案是多巴胺，多巴胺可以对抗多巴胺。与欲望回路相反的回路可以被称为“多巴胺控制回路”。</p>
<h1 id="第三章_掌控的力量"><a class="header-anchor" href="#第三章_掌控的力量">#</a>第三章 掌控的力量</h1>
<p>多巴胺通过不同的大脑回路也会产生不同的功能，经过中脑边缘回路的多巴胺会产生冲动，我们称该回路为 <strong>多巴胺欲望回路</strong> 。计算和规划（控制各种情况的手段）来自中脑皮层回路，我们称之为 <strong>多巴胺控制回路</strong></p>
<p>控制多巴胺利用欲望多巴胺提供的兴奋和动力，评估选项、挑选工具，并制定策略来获得想要的东西</p>
<p>多巴胺的功能来自进化和生存的需要。多巴胺鼓励我们最大限度地利用资源，因此，当我们把一件事情做得更好，使我们的未来成为一个更好、更安全的地方时，多巴胺就会奖励我们，给我们一点儿“躁起来”的感觉。多巴胺驱动了努力。这种努力的特征可能受到其他很多因素的影响，但如果没有多巴胺，努力从一开始就根本不会存在。</p>
<p>当别人对成功抱有很高的期望时，我们就会给他们让路。我们会服从他们的意志——在控制多巴胺的驱动下，他们的自我效能得到了完全的表达。我们的大脑之所以进化成这样，有一个充分的理由：参加一场你无法取胜的比赛可不明智。如果你发现对手对成功抱有很高的期望，那么你想要获胜就不那么容易了。<br>
为什么控制性神经递质多巴胺会触发顺从行为？这不是矛盾吗？一点儿也不矛盾。在控制回路中，多巴胺驱动的是控制环境，而不一定是环境中的人。多巴胺想要更多，但它不在乎它是如何得到的。无论道德还是不道德，控制还是顺从，对多巴胺而言都是一样的，只要它能使未来更好。</p>
<p>欲望多巴胺会促进毒瘾，让人追求快感，但收获的多巴胺刺激越来越少，同样，有些人的控制多巴胺如此之多，这使他们对成就上瘾，因而无法体验当下的满足。<br>
这是聚焦未来的多巴胺和聚焦现在的当下神经递质之间的失衡。他们想要逃避当下的情感和感官体验。对他们来说，生活关乎未来，关乎进步，关乎创新。尽管他们的努力带来了金钱甚至名声，但他们总是不开心。不管做了多少，他们都觉得不够。</p>
<p>额叶负责控制多巴胺的活动，它是发育得最晚的脑区，直到一个人结束青春期进入成年期之后，它才与大脑的其他部分完成连接。控制回路的工作之一是限制欲望回路，因此冲动控制与 ADHD 相关。当控制多巴胺很弱时，人们会去追求他们想要的东西而不考虑长期的后果。多巴胺的生成不受良心的约束。相反，在欲望的滋养下，它是狡猾的源泉。它被激发时，会抑制内疚感这种当下的情绪。它能够激励人们做出不懈的努力，但在追求的过程中不能避免使用欺骗甚至暴力手段 。</p>
<p>由激情驱使的攻击是对挑衅的猛烈回击，但这并不是由多巴胺控制回路刻意安排的动作。恰恰相反，当激情驱使着我们攻击挑衅者时，当下分子回路会抑制多巴胺。</p>
<p>当下分子回路相抗衡的多巴胺可以关闭情绪的音量。在复杂的情况下，拥有“冷静头脑”的人，也就是多巴胺能更强的人，能够抑制这种反应，做出更深思熟虑的选择，这些选择通常会带来更好的结果。传统观点将他的脱险归因于“肾上腺素爆发”，事实则恰恰相反。他不是靠肾上腺素爆发，而是靠多巴胺爆发。在他拯救船只的紧张时刻，多巴胺开始掌控局面，肾上腺素（当它在大脑中时被称为去甲肾上腺素）被抑制。</p>
<p>但当我们需要抵制有害的欲望时，意志力是我们首先使用的工具。事实证明，这可能不是个好选择。意志力可以帮助酒鬼拒绝一次喝酒，但如果他要在几个月或几年的时间里一次次地拒绝的话，他很可能坚持不住。意志力就像一块肌肉，用过之后会疲劳，可能用不了多久，它就放弃了 。于是就有了通过多巴胺对抗多巴胺的疗法，包括：</p>
<ul>
<li>动机增强疗法：用欲望多巴胺对抗欲望多巴胺</li>
<li>认知行为疗法：用控制多巴胺对抗欲望多巴胺</li>
<li>十二步促进疗法：用当下分子对抗欲望多巴胺<br>
当下的内疚感是一种强大的动力（你母亲或许也经常利用这一点）。情感的支持和内疚的威胁相结合，帮助许多瘾君子长期保持不复饮</li>
</ul>
<h1 id="第四章_天才与疯子"><a class="header-anchor" href="#第四章_天才与疯子">#</a>第四章 天才与疯子</h1>
<p>有可能影响你未来的事情是突出的，能触发欲望多巴胺的事情也是突出的。突出的信息提醒你：“该醒醒了！”“当心点儿！”“兴奋起来！”“这很重要！ 如果大脑在突出性方面的功能失灵，即在没有发生对你真正重要的事情时，它也爆发了，那么会发生什么呢？想象你在看新闻，主持人正在谈论政府的一项间谍计划，突然你的突出性回路无缘无故地启动，你可能就会相信新闻上的这个故事和你有关。突出性过强或者在错误的时间出现，都会产生错觉，让触发事件从默默无闻上升到至关重要。</p>
<p>患有精神分裂症的人通过服用阻断多巴胺受体的药物来控制多巴胺的活动。阻断多巴胺通常不会使精神分裂症的所有症状消失，但可以消除妄想和幻觉。不幸的是，抗精神病药物会阻断整个大脑的多巴胺，而阻断额叶的控制回路会使某些方面变得更糟，例如难以集中注意力和难以用抽象概念推理。</p>
<p>精神分裂症的患者大脑处于短路状态，把原本熟悉而被忽视的普通事物变得更显著。这种状态也叫作“低潜在抑制“。“潜在抑制”中“潜在”的含义略有不同。不是说一件事从一开始就被隐藏起来，而是说我们把它隐藏起来，因为它对我们不重要。</p>
<p>我们会抑制自己关注不重要事物的能力，这样就不必把注意力浪费在它们上面。我们在街上走的时候，如果被干净透亮的窗户分散了注意力，可能就注意不到十字路口处“禁止通行”的标志。</p>
<p>有时我们的环境充满了新事物，使得潜在抑制能力无法挑选出最重要的东西。这种经历可能令人兴奋，也可能令人恐惧。如你身处异国他乡，没有什么可抑制的，它就能带来极大的愉悦，但也会让人混乱、迷失方向，这就是文化冲击。</p>
<p>模型是我们为了更好地理解世界而建立起的对世界的假想图示。在某些方面，模型就像潜在抑制。模型只包含模型建造者认为必不可少的环境元素，不包含其他细节。这使得这个世界更容易理解，后续我们还可以通过各种方式来操纵它以获得最大利益。模型不仅简化了我们对世界的理解，而且还让我们做抽象归纳，利用获取的特定经验来制定广泛、通用的规则，从而预测和处理从未遇到的情况。<br>
当我们需要在许多不同的选项中进行选择时，模型会很有帮助。它们让我们想象不同的场景，以便选出最佳的一个。</p>
<p>糟糕的现实模型可能是由许多因素造成的：没有足够的信息，难以进行抽象思考，或者执着于错误的假设。这些糟糕的假设可能会导致焦虑和抑郁等精神疾病。例如，如果一个孩子在父母的挑剔下长大，她可能会产生自己是一个无能的人的想法，这种想法将塑造她一生所创造的世界模型 。</p>
<p>模型是一种强大的工具，但也有缺点。它们会让我们陷入特定的思维方式中，导致我们错失一些改善世界的机会</p>
<p>美术和自然科学之间的共同点，比大多数人认为的要更多，因为两者都是由多巴胺驱动的。诗人写一首描写爱而不得的诗句和物理学家写出电子激发公式没有什么不同，都需要创作者具有超越感官世界，进入一个更深层、更深刻的抽象思想世界的能力。</p>
<p>高水平的多巴胺会抑制当下分子的功能，所以聪明的人在人际关系上往往很差。我们需要当下的同理心来理解别人的想法，这是社交互动的基本技能。极其聪明、成功和极富创造性的人，也就是那些典型的多巴胺丰富的人通常会表达一种奇怪的情绪：他们对人类充满激情，但对个人却没有耐心。</p>
<h1 id="第五章_自由与保守"><a class="header-anchor" href="#第五章_自由与保守">#</a>第五章 自由与保守</h1>
<p>多巴胺能的人倾向于支持自由主义政策。自由主义者经常把自己称为“进步的”，这个词意味着不断的提升。 硅谷的企业家以及为他们工作的人，往往极富多巴胺能。他们意志坚强、敢于冒险、追求刺激，与《美国政治科学杂志》修正版文章中的自由主义者的特征相符。 一项针对初创企业创始人的调查显示，83% 的人持进步主义的观点，认为教育可以解决社会上的所有或大部分问题。而在公众中，只有 44% 的人相信这是真的。《纽约时报》的一篇评论指出，只有 2% 的英语系教授是共和党人，而 18% 的社会学家则认为自己是马克思主义者。</p>
<div class="note info simple"><p>多巴胺能的人倾向于自由主义，当下分子能的人倾向于保守主义。</p>
</div>
<p>大多数专家都认为智商测试并不能衡量一般智力。它更着重于衡量根据不完整数据进行归纳和使用抽象规则找出新信息的能力。智商测试衡量了一个人根据过去的经验建立假想模型，然后利用这些模型预测未来会发生什么的能力。控制多巴胺在这些过程中起着很大的作用。</p>
<p>理性决定是不可靠的，总是随着新证据的出现而随时可能被修改。非理性则更持久，欲望多巴胺和当下分子通路都可以被用来引导人们做出非理性的决定。最有效的工具是恐惧、欲望和同情。 不论是哪种政治倾向的人，他们在感受到威胁时都会变得更加保守。一瓶洗手液能唤醒人对于病毒的恐惧。研究进化对人类行为影响的心理学家格伦·D. 威尔逊（Glenn D. Wilson）教授开玩笑说，在选举季节，厕所里张贴“员工必须洗手才能重返工作岗位”的标志就是在给共和党打广告。</p>
<p>保守主义者倾向于关注较小的群体，比如个人、家庭和国家，而自由主义者则更倾向于关注更大的群体：由所有人组成的全球社区。</p>
<p>把贫困移民拒之门外让人想起了爱因斯坦的那句话：“我对社会正义和社会责任充满热情，但我与其他人直接接触时却表现冷淡，这实在是一种奇怪的对比。”保守派似乎恰恰相反。他们想把非法移民排除在这个国家之外，以防止他们担心的事情发生，即他们的文化发生根本性转变。然而，伤害厌恶会促使他们愿意去照顾住在本国的人。</p>
<p>政治是一种多巴胺能的活动，因为政府是通过抽象的法律从远处管理人民的。由当下回路控制的暴力为法律树立威信。由于政府的本性就是多巴胺能的，自由主义者往往比专注于当下的保守主义者更热衷于此。相比之下，保守主义者更容易不信任政府，特别是距离较远的政府。保守派倾向于地方治理，权力在州或地方一级，而不是联邦一级。</p>
<h1 id="第六章_进步"><a class="header-anchor" href="#第六章_进步">#</a>第六章 进步</h1>
<p>多巴胺受体 D4 的一种编码基因。D4 基因的一个变体被称为 7R，拥有 7R 变体的人喜欢探求新奇事物。 他们喜欢追求新的体验，因为他们不大能容忍无聊。他们喜欢探索新的地方、想法、食物、毒品和性机会，他们是冒险家。全世界大约 1/5 的人有 7R 等位基因，但各地的差异很大。</p>
<p>经历了漫长征程的南美原住民中，长多巴胺等位基因的比例最高，达到 69%。在迁徙较短距离并定居北美的人中，只有 32% 的人拥有长等位基因。中美洲原住民的比例介于它们之间，为 42%。据估计，平均每迁移 1 000 英里，长等位基因的比例就会增加 4.3 个百分点。确定了 DRD4 基因的 7R 等位基因与种群迁移的距离有关以后，下一个问题就是为什么迁徙成员中的 7R 等位基因更多？答案是，也许 7R 等位基因并没有引发迁移，但一旦迁移开始，这一等位基因就会赋予携带者生存优势。7R 等位基因的一个优点是，它会让你不断探索新环境，以便寻找机会来使资源最大化。换句话说，它促进了对新事物的探索。不断前进的部落会一代又一代地经历陌生的环境。7R 的生殖优势将继续下去，7R 携带者将活得更长，生育更多的孩子。随着时间的推移，7R 等位基因在这些长途迁移者中会变得越来越普遍。</p>
<p>双相情感障碍中的双相又称两极（bipolar），是指两种极端的情绪。双相情感障碍患者会经历抑郁发作，即情绪异常低落，也会经历躁狂发作，即情绪过于高昂。后者与高水平的多巴胺有关，考虑到躁狂状态的症状，这一点儿也不奇怪。<br>
在舞蹈、表演、音乐和写作等创造性领域工作的人与没有从事创造性工作的人相比，患双相情感障碍的可能性高出 25%。在另一项研究中，格拉斯哥大学的科学家跟踪了 1 800 多名 8 岁到 20 岁出头的人。他们发现，8 岁时的智商分数越高，23 岁或之前患双相情感障碍的风险就越大。<br>
与普通大脑相比，聪明的大脑患多巴胺能精神疾病的风险更大。许多著名的有创造力的人都透露他们患有双相情感障碍。</p>
<p>多巴胺过度活动并不是双相情感障碍的唯一问题，但它起着重要的作用。它不是由高活性 DRD4 受体等位基因引起的。科学家认为这是由多巴胺转运体引起的。多巴胺转运体就像吸尘器，它可以限制多巴胺刺激周围细胞的时间。<br>
当一个能产生多巴胺的细胞被激活时，它会释放出它储存的多巴胺，后者与其他脑细胞的受体结合。之后，多巴胺转运体会将多巴胺吸回原来的细胞中，结束与受体的相互作用，以便后续再重复这一过程。这种转运体有时被称为“再摄取泵”，因为它将多巴胺重新泵入细胞。<br>
当转运体不能正常工作时会发生什么？我们可以通过研究滥用可卡因的人的行为来回答这个问题。可卡因会阻滞多巴胺转运体，就像把袜子塞进吸尘器吸嘴一样。这种阻滞作用使多巴胺能够一次又一次地与其受体相互作用。当这种情况发生时，人们会感受到更多的能量，也会有更多目标导向的活动和更强的性冲动。人的自尊和兴奋感得到提升，喜欢从一个话题跳到另一个话题。可卡因中毒与躁狂症十分相似，有时医生都难以区分。</p>
<p>高多巴胺能的科学家为高多巴胺能的统治者制造了末日武器。科学家无法阻止自己制造出更加致命的武器，独裁者也无法阻止自己对权力的贪欲。<br>
另一个容易想象到的世界末日场景是多巴胺驱使我们消耗越来越多的资源，直到我们毁灭地球<br>
着眼于未来的多巴胺让人不再生孩子，因为生活在发达国家的人在年老时不依赖孩子来抚养他们。</p>
<h1 id="第七章_和谐"><a class="header-anchor" href="#第七章_和谐">#</a>第七章 和谐</h1>
<p>现代世界驱使我们向着每时每刻全是多巴胺的状态发展。过多的多巴胺会导致精力旺盛的痛苦（如工作狂式的主管），而过多的当下神经递质则会导致快乐的懒惰（如躺在地下室抽大麻的人）。</p>
<p>从多巴胺的角度来看，精通是一件值得期待和追求的好事，但它不同于其他好事。它不仅仅是寻找食物和新的合作伙伴，或者击败竞争对手，它比这些更宏大、更普遍。它是我们成功提取奖励的过程：多巴胺达到了多巴胺的目标。实现了精通，多巴胺到达了它渴望的顶峰——挤压了所有可用资源的最后一滴。<br>
在尽其所能之后，多巴胺会暂停下来，允许当下分子在我们的快乐回路中发挥作用。在这一刻，多巴胺不再对抗满足感，它让它通行——即使只持续很短的一段时间。最好的享受就是沉浸在一份干得好的工作中。</p>
<p>关注现实，关注你此刻所做的事情，可以使进入你大脑的信息流最大化。它能最大限度地提高多巴胺制订新计划的能力，因为为了建立模型以准确地预测未来，多巴胺需要数据，以及来自感官的数据流。这时，多巴胺和当下分子就联手工作了。</p>
]]></content>
      <tags>
        <tag>自然科学</tag>
        <tag>心理学</tag>
        <tag>科普</tag>
      </tags>
  </entry>
</search>
