<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C# $ 字符串插值</title>
    <url>/$_string_interpolation/</url>
    <content><![CDATA[<h1 id="字符"><a class="header-anchor" href="#字符">#</a>$ 字符</h1>
<p>字符串插值（String Interpolation）有许多的实现方式，其中使用 <code>$</code> 字符在现代 C# 中时比较推荐的方式，它提供类似于 <code>String.Format</code> 的效果。</p>
<div class="note info simple"><p>实际根据 <code>$</code> 使用场景的不同，编译器会选择用不同的方式实现字符串插值，<code>String.Format</code> 只是其中一种，具体见 <a href="/$_string_interpolation/#%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82">实现细节</a></p>
</div>
<p>如下分别为使用 <code>$</code> 和 <code>String.Format</code>的示例：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> <span class="keyword">value</span> = <span class="number">3</span>;</span><br><span class="line">Debug.Log(<span class="string">$&quot;Value is <span class="subst">&#123;<span class="keyword">value</span>&#125;</span>&quot;</span>);</span><br><span class="line">Debug.Log(String.Format(<span class="string">&quot;Value is &#123;0&#125;&quot;</span>, <span class="keyword">value</span>));</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Value is 3</span><br><span class="line">Value is 3</span><br></pre></td></tr></table></figure>
<h1 id="使用方式"><a class="header-anchor" href="#使用方式">#</a>使用方式</h1>
<h2 id="创建内插字符串"><a class="header-anchor" href="#创建内插字符串">#</a>创建内插字符串</h2>
<p><code>字符串插值（String Interpolation）</code> 是用来将表达式插入到字符串中的方式，简单的示例如下所示：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> name = <span class="string">&quot;wxj&quot;</span>;</span><br><span class="line">Debug.Log(<span class="string">$&quot;Hello,<span class="subst">&#123;name&#125;</span>.&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Hello,wxj.</span><br></pre></td></tr></table></figure>
<p>其中 <code>$&quot;Hello,&#123;name&#125;.&quot;)</code> 被称为 <code>内插字符串表达式（interpolated string expression）</code>（下简称 <code>内插表达式</code>），最后输出的 <code>Hello,wxj.</code> 被称为 <code>结果字符串（result string）</code></p>
<p>由上例可以看出字符串插值的两个必要因素：</p>
<ol>
<li>在字符串前需要有 <code>$</code> 字符标记，且该字符与后续的 <code>&quot;</code> 间不能有空格。</li>
<li>在内插表达式内部可以有一个或多个 <code>&#123;&#125;</code> ，其中包含着任何返回结果的 C# 表达式，表达式的返回值也可以为 <code>null</code>。</li>
</ol>
<h2 id="包含不同的数据类型"><a class="header-anchor" href="#包含不同的数据类型">#</a>包含不同的数据类型</h2>
<p>对于内插表达式中的各 C# 表达式可以是任何类型的，如下所示：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> item = (Name: <span class="string">&quot;eggplant&quot;</span>, Price: <span class="number">1.99</span>m, perPackage: <span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> date = DateTime.Now;</span><br><span class="line">Debug.Log(<span class="string">$&quot;On <span class="subst">&#123;date&#125;</span>, the price of <span class="subst">&#123;item.Name&#125;</span> was <span class="subst">&#123;item.Price&#125;</span> per <span class="subst">&#123;item.perPackage&#125;</span> items.&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">On 12/10/2021 8:26:07 AM, the price of eggplant was 1.99 per 3 items.</span><br></pre></td></tr></table></figure>
<p>可以看到该内插字符串表达式中包含有各种类型的表达式（<code>string</code>，<code>Decimal</code>，<code>int</code>，<code>DeltaTime</code>），在最终的结果中都被正确的解析。</p>
<p>内插字符串表达式，各表达式都会被转换为 <code>string</code>，且规则如下：</p>
<ol>
<li>如果表达式结果为 <code>null</code> ，将其转换为空字符串。</li>
<li>如果表达式结果不为 <code>null</code>，对其调用 <code>ToString</code> 函数。</li>
</ol>
<h2 id="控制内插表达式的格式"><a class="header-anchor" href="#控制内插表达式的格式">#</a>控制内插表达式的格式</h2>
<p>在内插表达式中，还可以控制各表达式转换到 <code>string</code> 时的格式，如下所示：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">DateTime date = DateTime.Now;</span><br><span class="line"><span class="built_in">float</span> <span class="keyword">value</span> = <span class="number">1.12345678f</span>;</span><br><span class="line">Debug.Log(<span class="string">$&quot;On <span class="subst">&#123;date&#125;</span>, value is <span class="subst">&#123;<span class="keyword">value</span>&#125;</span>&quot;</span>);</span><br><span class="line">Debug.Log(<span class="string">$&quot;On <span class="subst">&#123;date:d&#125;</span>, value is <span class="subst">&#123;<span class="keyword">value</span>:f3&#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">On 12/10/2021 8:39:56 AM, value is 1.123457</span><br><span class="line">On 12/10/2021, value is 1.123</span><br></pre></td></tr></table></figure>
<p>在内插表达式中的各表达式中可以通过 <code>:</code> 后加控制的字符格式化输出。如上例中的 <code>d</code> 和 <code>f3</code> 即为控制字符。</p>
<div class="note info simple"><p><code>:</code> 后的控制字符，相当于在调用 <code>ToString</code> 时作为形参控制表达式的输出。<br>
上述表达式等同于：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Debug.Log(<span class="string">&quot;On &quot;</span> + date.ToString(<span class="string">&quot;d&quot;</span>) + <span class="string">&quot;, value is &quot;</span> + <span class="keyword">value</span>.ToString(<span class="string">&quot;f3&quot;</span>));</span><br></pre></td></tr></table></figure></div>
<h2 id="控制内插表达式的对齐方式"><a class="header-anchor" href="#控制内插表达式的对齐方式">#</a>控制内插表达式的对齐方式</h2>
<p>在内插表达式中的个表达式中可以通过 <code>,</code> 后加数字来控制字符宽度和对其方式，如下所示：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> inventory = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">int</span>&gt;()</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="string">&quot;hammer, ball pein&quot;</span>] = <span class="number">14</span>,</span><br><span class="line">    [<span class="string">&quot;hammer, ball pein a&quot;</span>] = <span class="number">18</span>,</span><br><span class="line">    [<span class="string">&quot;hammer, cross pein&quot;</span>] = <span class="number">5</span>,</span><br><span class="line">    [<span class="string">&quot;screwdriver, Phillips #2&quot;</span>] = <span class="number">14</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> result = <span class="string">$&quot;|<span class="subst">&#123;<span class="string">&quot;Item&quot;</span>,<span class="number">-25</span>&#125;</span>|<span class="subst">&#123;<span class="string">&quot;Quantity&quot;</span>,<span class="number">10</span>&#125;</span>|\n&quot;</span>;</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> inventory)</span><br><span class="line">    result += <span class="string">$&quot;|<span class="subst">&#123;item.Key,<span class="number">-25</span>&#125;</span>|<span class="subst">&#123;item.Value,<span class="number">10</span>&#125;</span>|\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">Debug.Log(result);</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">|Item                     |  Quantity|</span><br><span class="line">|hammer, ball pein        |        14|</span><br><span class="line">|hammer, ball pein a      |        18|</span><br><span class="line">|hammer, cross pein       |         5|</span><br><span class="line">|screwdriver, Phillips #2 |        14|</span><br></pre></td></tr></table></figure>
<p>其中逗号后的数字，如果为负数，则输出为左对齐，如果为正数则右对齐。数字本身表示最少的<strong>字符数</strong>。因此如果显示系统中每个字符的宽度是不相等的话，如 <code>i</code> 和 <code>a</code> 的宽度在某些显示系统下会有较大差异，则即使控制字符宽度也无法实现对其的效果。</p>
<p>如下为相同输出结果在 Unity 的 Console 面板中的展示：<br>
<img src="/$_string_interpolation/image-20211210201354094.png" alt="对齐输出"></p>
<p>表达式格式和对齐方式也可以一起设定，但需要首先设定对其方式，再设定格式。如下首先控制了左对齐，且字符数为 10 个，又设定输出格式为当前小时数：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Debug.Log(<span class="string">$&quot;[<span class="subst">&#123;DateTime.Now,<span class="number">-10</span>:HH&#125;</span>]&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>结果为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[10        ]</span><br></pre></td></tr></table></figure>
<h2 id="内插表达式中使用转义序列"><a class="header-anchor" href="#内插表达式中使用转义序列">#</a>内插表达式中使用转义序列</h2>
<p>如果要在内插表达式中可以使用转义序列，当需要多次使用转义序列时也可使用 原义标识符@ 替代。</p>
<p>如下所示，分别使用使用了转义序列和原文标识符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string userName = &quot;wxj&quot;;</span><br><span class="line">string stringWithEscapes = $&quot;C:\\Users\\&#123;userName&#125;\\Documents&quot;;</span><br><span class="line">string verbatimInterpolated = $@&quot;C:\Users\&#123;userName&#125;\Documents&quot;;</span><br><span class="line">Debug.Log(stringWithEscapes);</span><br><span class="line">Debug.Log(verbatimInterpolated);</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">C:\Users\wxj\Documents</span><br><span class="line">C:\Users\wxj\Documents</span><br></pre></td></tr></table></figure>
<div class="note primary simple"><p>C# 8.0 后，<code>$</code> 与 <code>@</code> 的先后顺序不会造成任何影响。在早期版本中，必须先写 <code>$</code> 再写 <code>@</code>。</p>
</div>
<p>在内插表达式中，如果需要输入 <code>&#123;</code>，则按如下方式处理：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[] values = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line">Debug.Log(<span class="string">$&quot;Value is &#123;&#123;<span class="subst">&#123;values[<span class="number">0</span>]&#125;</span>, <span class="subst">&#123;values[<span class="number">1</span>]&#125;</span>&#125;&#125;&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Value is &#123;1, 2&#125;</span><br></pre></td></tr></table></figure>
<p>也可以通过 <code>$@</code> 的结合控制换行，如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> publishDate = <span class="keyword">new</span> DateTime(<span class="number">2017</span>, <span class="number">12</span>, <span class="number">14</span>);</span><br><span class="line"><span class="built_in">string</span> str = <span class="string">$@&quot;This post published on <span class="subst">&#123;publishDate:yyyy-MM-dd&#125;</span> is about</span></span><br><span class="line"><span class="string">interpolated strings.&quot;</span>;</span><br><span class="line">Debug.Log(str);</span><br></pre></td></tr></table></figure>
<p>此时输出为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">This post published on 2017-12-14 is about</span><br><span class="line">interpolated strings.</span><br></pre></td></tr></table></figure>
<h2 id="内插表达式中使用_运算符"><a class="header-anchor" href="#内插表达式中使用_运算符">#</a>内插表达式中使用 ?: 运算符</h2>
<p>因为 <code>:</code> 在内插表达式中用来指定格式，因此当使用 <code>?:</code> 运算符时，必须定义在括号内。如下所示：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">System.Random random = <span class="keyword">new</span> System.Random();</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i != <span class="number">3</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(<span class="string">$&quot;Value is <span class="subst">&#123;(random.Next() % <span class="number">2</span> == <span class="number">1</span> ? <span class="string">&quot;Odd&quot;</span> : <span class="string">&quot;Even&quot;</span>)&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Even</span><br><span class="line">Odd</span><br><span class="line">Odd</span><br></pre></td></tr></table></figure>
<h1 id="实现细节"><a class="header-anchor" href="#实现细节">#</a>实现细节</h1>
<p>根据 <code>$</code> 的实现方式的不同，编译器会选择用不同的方式实现字符串插值。</p>
<h2 id="string_Concat"><a class="header-anchor" href="#string_Concat">#</a>string.Concat</h2>
<p>当插值的对象为类型为 string 时，编译器会选择使用 <code>string.Concat</code>。</p>
<p>如下代码：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> name = <span class="string">&quot;meziantou&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> hello = <span class="string">$&quot;Hello <span class="subst">&#123;name&#125;</span>!&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>编译器会将其转换为：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> name = <span class="string">&quot;meziantou&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> hello = <span class="built_in">string</span>.Concat(<span class="string">&quot;Hello &quot;</span>, name, <span class="string">&quot;!&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="string_Format"><a class="header-anchor" href="#string_Format">#</a>string.Format</h2>
<p>如果插值的对象为类型为非 string 时，编译器会选择使用 <code>string.Format</code>。</p>
<p>如下代码：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">DateTime now = DateTime.Now;</span><br><span class="line"><span class="built_in">string</span> str = <span class="string">$&quot;It is <span class="subst">&#123;now&#125;</span>&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>编译器会将其转换为：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">DateTime now = DateTime.Now;</span><br><span class="line"><span class="built_in">string</span> str = <span class="built_in">string</span>.Format(<span class="string">&quot;It is &#123;0&#125;&quot;</span>, now);</span><br></pre></td></tr></table></figure>
<h2 id="FormattableString"><a class="header-anchor" href="#FormattableString">#</a>FormattableString</h2>
<p>如果插值的对象为类型为 <a href="/formattable_string">Formattable String</a> 时，编译器会选择使用 <code>FormattableStringFactory.Create</code> 创建一个新的 <code>FormattableString</code>。</p>
<p>如下代码：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">object</span> value1 = <span class="string">&quot;Foo&quot;</span>;</span><br><span class="line"><span class="built_in">object</span> value2 = <span class="string">&quot;Bar&quot;</span>;</span><br><span class="line">FormattableString str = <span class="string">$&quot;Test <span class="subst">&#123;value1&#125;</span> <span class="subst">&#123;value2&#125;</span>&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>编译器会将其转换为：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">object</span> value1 = <span class="string">&quot;Foo&quot;</span>;</span><br><span class="line"><span class="built_in">object</span> value2 = <span class="string">&quot;Bar&quot;</span>;</span><br><span class="line">FormattableString str = FormattableStringFactory.Create(<span class="string">&quot;Test &#123;0&#125; &#123;1&#125;&quot;</span>, <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; value1, value2 &#125;);</span><br></pre></td></tr></table></figure>
<p>当真正需要使用该 string 时，会调用 <code>FormattableString.ToString</code> 方法，将其转换为 string。</p>
<h2 id="constants（C_10）"><a class="header-anchor" href="#constants（C_10）">#</a>constants（C# 10）</h2>
<p>在 C# 10 中，支持将内插表达式的结果作为常量。如下所示：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> Username = <span class="string">&quot;meziantou&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> Hello = <span class="string">$&quot;Hello <span class="subst">&#123;Username&#125;</span>!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In previous C# version, you need to use the following concat syntax</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> Hello2 = <span class="string">&quot;Hello &quot;</span> + Username + <span class="string">&quot;!&quot;</span>;</span><br></pre></td></tr></table></figure>
<h2 id="Interpolated_string_handlers（C_10）"><a class="header-anchor" href="#Interpolated_string_handlers（C_10）">#</a>Interpolated string handlers（C# 10）</h2>
<p>C# 10 中针对高性能场景，引入了 <code>InterpolatedStringHandlerArgument</code>，具体见：<br>
<a href="https://devblogs.microsoft.com/dotnet/string-interpolation-in-c-10-and-net-6/?WT.mc_id=DT-MVP-5003978">String Interpolation in C# 10 and .NET 6 - .NET Blog (microsoft.com)</a></p>
<h1 id="Reference"><a class="header-anchor" href="#Reference">#</a>Reference</h1>
<p><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/interpolated">$ - string interpolation - C# reference | Microsoft Docs</a></p>
<p><a href="https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/exploration/interpolated-strings-local">String interpolation - C# tutorial | Microsoft Docs</a></p>
<p><a href="https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/string-interpolation">String interpolation in C# | Microsoft Docs</a></p>
<p><a href="https://www.meziantou.net/interpolated-strings-advanced-usages.htm#interpolated-strings-a9996a-2">Interpolated strings: advanced usages - Meziantou’s blog</a></p>
]]></content>
      <tags>
        <tag>String</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>《5% 的改变》 摘抄</title>
    <url>/bai_fen_zhi_5_de_gai_bian/</url>
    <content><![CDATA[<h1 id="引言"><a class="header-anchor" href="#引言">#</a>引言</h1>
<p>在心理咨询界，有一条近乎行业共识的准则，那就是不要在咨询中提供建议。这不是故弄玄虚，明知道答案却非要卖关子，而是我们相信，来访者遇到的困境绝非听别人几句话就能解决  (  或者说，几句话就能解决的问题也不至于特意在这里求助  ) 。每个咨询师都了解成功的干预有多难，某种意义上像在打擂台，对抗一个名叫“惯性”的对手。</p>
<p>这些建议真是有益的吗？这件事也值得怀疑。凭什么认定来访者按照我们的建议做就是好的？它是心理咨询师的主观认识和个人偏好：我们认为什么是重要的，习惯用哪些办法解决困难。这偏好适用于咨询师，却未必适合其他人。</p>
<p>最有用的办法往往是靠自己找到的，只是很多人并没有真的在找——即使身陷痛苦，他们也总是在徒劳无功的老路上打转。</p>
<p>很多人都喜欢通过“思考”寻找答案，更安全，更无痛，并且显得更深刻和触及灵魂。但要我来说，还是“做”点什么更管用。行动会直接带来新的经验。我不太看重读者对我在观点上的共鸣，像是“每句话都醍醐灌顶”或者“真相了”。这些说法是在表达：“你说出了我一直同意的道理，很棒，但我没有什么行动。”比起这个，我更想听到的是：“我也不清楚你说得对不对，所以我试了试。”</p>
<p>“问题”并不是一个客观存在的东西，它是一种叙事，它建立在提问者过去理解并回应这个世界的视角之上。既然问题是在这个角度下产生的，就无法通过相同的角度解决。</p>
<p>我不同意他看问题的角度，我有不同的视角，但我能否把他当成一个值得尊重的人？是能看到他行动的合理性，还是认定“他犯了错，我要让他承认自己的错误”？——后面这种心态无论怎么美化，都会让我的建议带着一丝不自觉的傲慢，结果可想而知。谁会愿意听一个看轻自己的人说话呢？反过来，一个人越是被理解，越是感到安全，就越是愿意打开自己，面对新的经验。</p>
<p>如何做到发自内心地尊重，又能恰到好处地表达“我不同意你的看法”，拓展当事人看问题的角度？关键在于我们内心是否真的如此相信。</p>
<p>请当事人尝试的变化一定要小之又小，近乎不变。</p>
<ul>
<li>不要对改变的期望太高，有  5%新的经验就已经很好了。改变的悖论往往是这样：如果我说“请你变成那样”，对方会说“可我做不到”。我说“好吧，请保持你原来那样”，对方又会说“这样是不行的，我想改”</li>
<li>“请你保持基本不变的同时，朝着可能的方向改变一点。”书里的一问一答都是如此，乍一看不“解渴”，对方的核心问题没什么变化，有些尝试甚至是在背道而驰，但没关系。重点是他有了不一样的经验。新的经验就是会带来长远的改变。</li>
</ul>
<h1 id="Chapter_1_自我"><a class="header-anchor" href="#Chapter_1_自我">#</a>Chapter 1 自我</h1>
<p>“自我”是自身的一部分，但又不能全然被自己所掌握。人在成长的过程中，多少都会遭遇对自我的失望、恐惧、不接纳。这是最普遍的困惑，也是最抽象、最复杂的困惑。</p>
<p>思考”和“想”是有差别的。“想”是懒惰的自由，“思考”却必须带上复杂难言的现实生活，以及对真实自我的理解。“我想辞职”和“我考虑辞职”，难度差异太大了。</p>
<p>大多数痛苦都可以概括成两句话：“我不希望自己这样，但确实我就是这样的。”“我希望像别人一样，但我又做不到那样。”用学术一点的语言，就是理想自我和真实自我之间有差距。解决方案说来简单，就是“接纳”，接受自己真实的样子。</p>
<p>消化了“我不该如此”的错位感，才能看清楚真正的自己是什么样  (  满意也罢，不满也罢  ) 。这还没完，从看清自己到欣赏自己，从欣赏自己到用好自己，从用好自己再到自我实现，每一段都是长期功课。在自我认识、自我成就这件事上，我们有一生的路要走。</p>
<p>5%其实也不错了，问题在于，如果你太想要一个彻底的、长久的改变，你就会被挫败、沮丧和自我否定压垮，最后的结果是连 5%也做不到。你只做到了 0%。</p>
<p>我为什么不继续说服她，她有改变的希望呢？因为我猜，她经历过很多这样的对峙。她渴望改变，然而通篇又在证明自己的无望，这常常会吸引其他人去反驳，去灌输给她希望。改变的责任不知不觉转移到别人身上，她本人反而更抵触：“你们说的希望在哪里呢？我都试过了，真的不行！”——这不是我们想要的结果。何况靠别人灌输的希望始终有限。</p>
<ul>
<li>遇到这种情况，更好的办法是同意她现在的心理现实：如果她认为自己身处谷底，那你就接受这对她来说就是真的（哪怕你实际上不这么看）。彻彻底底站在她这一边。然后呢？行动的责任就落在她自己肩上了：她的人生陷入了大麻烦，她现在已经身处谷底，下一步她打算如何行动呢？</li>
</ul>
<p>虽然疫情是一个客观事件，我们无从选择；但如何让它为自己所用，却是可以主观调整的。选择强调它带来的负面影响，这是一种策略，叫作“防御性悲观”，也就是预先为自己铺好后路：万一失败了，不怪我，怪外部因素。看上去像是一种消极的心态，但是换一个角度，也不失为一种给自己解压松绑、轻装上阵的办法。</p>
<ul>
<li>生活中我们觉得这种心态有点负面，更推崇乐观地面对困难，那当然是一种英雄主义。但我们不能代替当事人的选择。所以我设计了一个仪式，帮助他把无意识的策略转变成有意识的自我对话，怎么选都是对的，但他可以明确意识到自己在做选择。我们看到，当他做出自己的选择——哪怕选择一种“悲观的态度”——他在后面的行动中，就能表现出更大的能动性。</li>
</ul>
<p>“李老师”某种意义上代表着她的那些同龄人，他们似乎秉承一种理性的态度，劝说她减少不必要的执念，轻装上阵，好好生活——可这些声音恰好是问题所在。它们无异于是在说：“这种你坚持的存在方式，是有问题的。”其实呢？没问题，提问者只是痛苦。痛苦是一种感知自己存在的方式。这很正常。世界上多的是人选择这样存在，也安于这样存在。如果把它当成问题，这种认识解决不了任何问题，反而制造了更多痛苦。</p>
<ul>
<li>如果再来一次的话，我会表达得更明确：不要放下。保持住你的痛苦。痛苦当然可以是人存在的方式。它代表着还没有答案的课题，而这个课题是有价值的。它在追问：“我做了能做的一切，但我还是不满足，我还要做什么？”没有答案，那就去找，但问题没有错。不要放弃问题本身。</li>
</ul>
<p>每当你担心小概率事件发生时，就告诉自己，不要心怀侥幸，它注定会发生（更何况你担心的就是已经发生的事）。剩下的问题就是：你必须采取怎样的预防或补救措施？——然后，去把该做的事做到。</p>
<ul>
<li>听上去这跟你现在每天的生活差不多。但至少你这样做是有底气的，不用一边做一边怀疑自己“是不是杞人忧天”，那样是双重的辛苦。</li>
</ul>
<p>从你的日常来看，你不需要真的自律，你只是需要一个叫“自律”的符号，用它带给自己一些积极暗示。</p>
<ul>
<li>这是很重要的自我发现。我们现在动辄讲“自律”，似乎自律是现代人的一种基本美德。但自律本身并不是目标，只是用来实现目标的手段。目标只能是一件具体的事，比如工作，就应该追求工作的完成度。这个过程中伴随着一丝不苟的节奏，就可以被称为“自律”。自律很好，但如果没有确定的目标，单单追求自律的状态，那就是买了一个名叫“自律”的盒子，却丢掉里面的珍珠。</li>
<li>自律这个词本身就有点拧巴。它强调的是一种自我克制，自我违抗——明明不想做一件事，却要自己必须做，这才叫作自律。而且不是做一次两次，要重复，日复一日，从这份坚持中获得某种意义——可是为什么要如此辛苦？如果找一件自己更喜欢的事，高高兴兴地做下来，不是更简单吗？</li>
</ul>
<p>世道艰难，你却如此轻易地拥有现在的生活，玩游戏，画画，还有人可以爱，这是容易让人感到不安的。也许焦虑的用处在于不断地“折磨”你，让你不时感受痛苦，是一种内在的补偿机制。</p>
<ul>
<li>也许在焦虑的时候，你可以用更有效的方式来“折磨”自己。比如做几件你平时没有动力去做的事。</li>
<li>一部分焦虑转化成了我的动力，转化的同时也减轻了我的焦虑。</li>
</ul>
<p>想是想不明白的，解决办法往往需要行动。积极的行动会开启一条“行动让人的状态变好，状态变好又带来更多积极行动”的正反馈循环链路。与之相反的就是“向下螺旋”的恶性循环：因为心情不好，导致什么都不想做；因为什么都没做，导致心情更差。这就是为什么很多人靠思考的方式解决问题，结果越想越难受。这种时候就要少想，多做。一旦开始做事，就启动了“向上螺旋”。</p>
<ul>
<li>有时人们不愿意开始行动，会把原因推给“状态”：“等我状态好了，这些事都会水到渠成。”但这是很难实现的，因为不开始行动，状态不会自己变好。要考虑的恰恰是在状态不好的同时，坚持迈出一小步</li>
</ul>
<p>人在纠结的时候，头脑里总在自我否定，想法一会儿一变：想做的事，事到临头又觉得做不到；想放弃，又不甘心。怎样都不满意。一个有效的应对办法，就是把所有的念头拿“出来”，变成两个或多个角色的对话。写下来，念出来，演出来，都可以。一个想这么做，而另一个刚好反对，如此而已。</p>
<ul>
<li>当几个声音都在一个人的头脑里，来回纠结，难免就让人感到困惑：“我是有什么问题？为什么明明想做的事，偏偏又做不到？”变成几个角色，一下就清楚了——就是头脑里同时有几个人嘛。几个人立场不同，意见谈不拢，也正常。这样的矛盾在生活里比比皆是。</li>
<li>不要预设只能存在一个声音，这是在自己头脑里的暴政——我们总认为自己只能有“唯一”的观点，从而造成了更多的困惑。有时候，允许不同的观点同时表达，本身就带来了沟通和解决的空间。</li>
<li>如果一个人同时存在着两种不同的人生观，它们又指向不同的生活方式，应对这种冲突最简单的方法，就是让两者同时实现。只不过放在生命的不同时间，像是单双日或者单双周。比如说吧，一个人可能想佛系，又觉得佛系不好，放不下自己的雄心壮志，那么与其花时间纠结“哪种人生观更好”，倒不如两种都要：一半时间充分努力，另一半时间充分躺平。</li>
<li>他不需要追求“统一”的生活态度，那样就只有一半的时间是好的，而现在是两种状态都好，都有价值；</li>
</ul>
<p>如果劝他“别担心，事情可能不会像你想的那么糟”，这种劝慰往往没有用。“可能”的另一面就是“不确定”，担心正是基于不确定。对方一句话就可以反问回来：“万一呢？”不要反驳，索性让他设定，担心的事确定会发生。</p>
<ul>
<li>回过头来，最坏的情况都能应对，现在又有什么好怕的呢？</li>
<li>沉浸在害怕中时，人们并不真的了解自己在怕什么，只是有一个强烈的印象：“太糟糕了！”“不可以让它发生！”这时候情绪当头，没办法思考“最大的损失有多大？”“整个过程究竟是怎样的？”当然也就更谈不上应变了：“就算在最坏的情况下，我也能做点什么。”进行了这样的深度加工，才能最有效地减轻焦虑。</li>
<li>焦虑的时候，反而可以多想一想“最坏的结果”。越具体，越实际，越有助于摆脱焦虑。遗憾的是，身边的人往往都在劝说“别想了，不会有事的”，等于还是在强化这样的意思——“它很糟糕”，“确实不能让它发生”。等到双方陷入争辩，就更没有时间对想象中的灾难做现实化的处理。</li>
</ul>
<p>在提建议的同时，不对建议的结果做任何预判。这样，就把建议变成了实验。就像所有实验一样，因为猜不到结果，所以期待。结果可能印证实验者的假设，也可能刚好相反。</p>
<ul>
<li>它把“行动”的目的异化了。做事是为了期待中的结果，这反而让人畏惧不前。</li>
<li>为了确定的结果做事，就有失败的可能。但如果行动的意义在于自我探索，就无所谓“失败”。</li>
</ul>
<h1 id="Chapter_2_原生家庭"><a class="header-anchor" href="#Chapter_2_原生家庭">#</a>Chapter 2 原生家庭</h1>
<p>“原生家庭”，差不多被当成了“童年阴影”的同义词。这是流行于当代的一种伤痕叙事。人们在孩提时代遭遇的不幸，天灾人祸也好，父母失职也好，或者是观念的偏狭、风俗的落后，都在成长关键时期留下了痛苦的烙印，其影响被认为会持续到成年之后。</p>
<ul>
<li>原生家庭的叙事本身就是一种影响的媒介。它把当下的经历和历史建立了联系：自己被描述成受制于过去的、无从反抗的“受害者”，一朝不幸，永远不幸。这成了一个悖论：过去那些事如果不是被反复提起，本不具有那么大的影响力。</li>
<li>有时候，只要我们稍加梳理，原生家庭的解释就未必站得住。它是一种被发明出来的、功能性的解释，看上去是为了解决问题，实际效果却是维持了问题。</li>
<li>过度的责任感让人更绝望，因为找不到其他原因，“只能是因为我不够好”。这时候就要让他看到，“不是我的错”，自己身上发生的一切都事出有因。这是“原生家庭”叙事本来的用意，创造更多的安全、稳定、被接纳。但要把握分寸——承认成长经验的影响，不代表“什么都不做”。接受不能改变的，恰恰是为了改变能改变的：过好我们今后的人生。</li>
</ul>
<p>不要预设她不联络就是生气，万一她是在适应一个人生活呢？下次联系她的时候，你先用正常的语气招呼她：“新年好！我们给你做了爱吃的东西。”</p>
<ul>
<li>她怎么接，都把她假定为有能力的、成长的人。如果她不是，别失望，给她一点时间，下次继续。你不需要再改变</li>
<li>既不绝情，但也不要无端成为出气筒和替罪羊。保持你的稳定，剩下的，她会学着适应。</li>
<li>妈妈那些令我反感的行为和语言，如果不方便反驳，就保持尊重和淡漠。但如果她用更健康的模式对待我，我会积极响应，让她觉得这个方向是对的。</li>
</ul>
<p>拖延的理由有很多种，最让人心疼的一种，大概就是“我必须完全做好一件事，才敢向人交代”。他们不是因为不负责，而是过于尽责了。假如这位提问者看到我的回复，真的可以随随便便置之不理，她就不会有拖延的困扰了。</p>
<p>假如有一件举手之劳的事始终做不到，除了解释为某种缺陷或障碍，另一种解释是，出于某种目的而特意“不去做”。一个成年人有能力拒绝妈妈的影响，却没有拒绝，除了来自母亲的积威之外，多半这个影响也是他（她）自己想要的。</p>
<ul>
<li>当一个年轻人对现状感到不满，对自己要求很严厉，同时也希望多体谅一下自己，那他就会说：“我已经尽力了，值得鼓励”，“都怪妈妈还在苛责我”。这样一来，就可以利用父母的要求，去摆平内心的冲突。看起来好像“难以”摆脱父母，但这总比承认自相矛盾好受一些。</li>
<li>也许当事人是有能力摆脱父母影响的，只是摆脱之后，还有很多属于这一刻的功课——自卑也好，不够成功也罢——那些烦恼仍然存在，并且作为自己的责任，终究只能自己承担。这让人看得更远，也更累。</li>
</ul>
<p>如果想让父母看到你不是那个“不懂事”“乱发脾气”的孩子，请你告诉他们：每次争吵你只是控制不住情绪，但不是真的想让他们难受。为了体现这一点，每次你发现自己又“怼”了父母之后，就为他们做一件小事，比如倒一杯水（或者别的小事），让他们感受到你的善意。</p>
<ul>
<li>你还是可以继续争吵，这是控制不住的。只是吵完了做点不一样的事。</li>
<li>比起“不要吵架”，更有效的建议是“吵也行，吵完倒杯水”。前者是在讲一个道理，正确，但是不知道怎么做。后者则是一个具体的动作，只要想做就能做到。当然了，后者听起来“不太解决问题”。但解决问题未必需要一个人发生由内而外的、连根拔起的改变。他也可以还是他，带着他（暂时没能解决）的问题，只是做了一点不同的动作。在我看来，完成一个动作，比想明白一百个道理更有用。</li>
<li>这样做还有一个附带的好处，它让这件事变得轻松了。“不要吵架”是一根随时绷紧的弦，“吵了再说”则有一种随遇而安的松弛。这反而有助于我们情绪平稳。有些情绪不再被刻意关注之后，自己就会淡化。这叫作“看见”或是“允许”这些情绪。反过来，越是不被允许的情绪，就越难以自控。</li>
</ul>
<p>有研究发现，那些在童年时期失去亲人的孩子，对逝去亲人最难说出口的一种情感是：生气。被重要的人抛弃的生气——“你抛下我而去，留下我在这个世界，一个人遭受那么多委屈。”生气是有理由的，但这份生气好像又不容易表达：你遭遇了比我更大的不幸，我怎么有资格责怪你？</p>
<p>困住你的不只父母的声音，他们就算不吭声，但仍然有一部分压力存在，那就是时间。时间在一年年地流逝，而你暂时还没想好自己想要怎样的生活，这是烦恼的根源。这烦恼本质上是针对自己：你也不知道想要什么。</p>
<ul>
<li>家人念着催生的咒语，反而帮你消解了一部分压力，把个人的烦恼转移给了家庭的矛盾，好像全部问题都来自他们的“催”。他们树了一个靶子。盯着这个靶子，关注点就不再是“如何安排未来的人生”，而变成了“如何应付家人”。</li>
</ul>
<p>阿德勒心理学强调的原则，在处理家庭问题时尤其适用。简单地说，就是要区分一个问题是谁的“课题”。谁的课题，谁负责解决。区分的原则很简单：这个问题让谁感到困扰？谁困扰，就是谁的课题。</p>
<ul>
<li>比如，子女决定了跟什么样的人结婚，如果子女想清楚了，就不困扰，因为这是他（她）的选择。可是父母不同意，他们担心这个对象不可靠，那么这件事就是父母的课题，只有他们为此感到困扰。按照课题分离原则，父母的课题父母自己解决，换句话说，子女并没有义务改变父母（当然更不用屈从）。</li>
<li>很多问题的处理就简单多了，尤其是原生家庭的纷扰，很多都是子女成年之后，抱怨得不到父母的支持：他们不理解自己选择的工作，不认同自己的伴侣，或者在生活观念上跟自己不合，由此又引发了童年时的很多委屈……遇到这些问题，要让做子女的人知道，重要的不是跟父母较劲，你只要按自己的想法，把自己的生活过好，就够了。至于父母怎么想——“那不是你的课题。”</li>
</ul>
<p>仪式的力量：它在生活中是一套约定俗成的、流程化的宣言和动作，比单纯的语言更具有感染力。它常常被用作某种转变的契机。例如，办一场庄重的成人礼，会比单纯的说教更有助于青少年减少孩子气的行为。</p>
<h1 id="Chapter_3_工作与理想"><a class="header-anchor" href="#Chapter_3_工作与理想">#</a>Chapter 3 工作与理想</h1>
<p>很多人都把“克服恐惧”看成目标，我认为不必。恐惧只是一种情绪，一个人带着恐惧这种情绪，照样可以采取行动。归根到底，做了什么是第一位的。</p>
<p>做事甚至不必产生“实际”的结果，行动本身就会开启“向上螺旋”。最初的行动一旦被激活，身体自然会越来越有力量，做的事也越来越多。就像是在滚雪球，从最初的一小点开始，一圈圈越滚越大 。</p>
<p>你需要接受这一点：你在这个阶段，只能拿出 1/7 的时间和精力，也就是一周只有一天做科研。无论你有多么不想接受，这都是现实。</p>
<ul>
<li>你要接受自己本质上属于这样一类人，也许你就没那么焦虑了。然后请你做两件事：第一，把这 1/7 的时间充分利用好，效率最大化（这一点，我估计你已经在做了）；第二，剩下的六天尽情做其他事。</li>
<li>尽量不去把科研看成一件痛苦的事，因为我觉得和一个东西对抗，需要耗费的精力远远大于处理它本身。</li>
</ul>
<p>你对自己能力的信心也带来了一点麻烦。麻烦在于，你不能让自己安于普通人的人生。所以考研失利后，你把“安于另一种人生”等同于“失败”，你必须让自己过不好，才有动力继续证明自己。但你现在越是过得不好，它就越是让你恐惧，破坏了你的努力。</p>
<ul>
<li>所以，这里就有一个悖论：如果你想尽全力证明自己一次，你就必须先安于当下的生活。我给你的建议就是如此：请你先以“不上研究生”为前提，把当下的生活过好。这是一盘大棋，为了更好的考研心态。你可以每天暗暗地复习，但不要再寄托“改变人生”那么大的压力。这只是用来自我证明的游戏，轻装上阵才好。等到有一天，你的生活足够满意了，不觉得非上研究生不可了，你的心态才算是准备好。那时候，你才最有可能一战功成。</li>
<li>现在有一种流行的信念说，成功需要“背水一战”。认为人只有在无路可退的时候才会爆发潜能，甚至于“思考退路”本身都会被当成一种懦弱。我认为这个观念要辩证地看，有一些绝境会激发人的勇气，另一些绝境则让人陷入恐慌，反而没法集中在自己要做的事情上。在这种情况下，思考退路是一种更积极和勇敢的策略。</li>
</ul>
<p>最重要的，就是不要重复已经做过的思考。总在相同的思路中绕圈子，人就没法获得新鲜的想法，问题就仍然得不到答案。</p>
<ul>
<li>很多人拿不定主意，是太想要一个“最终”的答案。但哪里能找到这样的答案呢？可能今年这样想，明年的想法又不一样。每一次都只是阶段性的尝试。先试，试了才会有结果，时间自然会告诉我们对不对。放轻松，不对就改嘛。</li>
<li>尝试的另一个前提是安全。多准备一些试错的成本。</li>
</ul>
]]></content>
      <tags>
        <tag>心理</tag>
        <tag>摘抄</tag>
      </tags>
  </entry>
  <entry>
    <title>《Render Hell》 第一部分 概览</title>
    <url>/book_1_overview/</url>
    <content><![CDATA[<div class="note info simple"><p>这一部分简单介绍了一些 GPU 的涉及的概念。</p>
</div>
<h1 id="Copy_the_Data"><a class="header-anchor" href="#Copy_the_Data">#</a>Copy the Data</h1>
<div class="note info simple"><p>之所以需要在不同的硬件间拷贝数据，是因为从不同硬件中读取数据的速度差异很大。因此对于当前需要频繁访问的数据，通常会选择将其拷贝到更为高速的内存部分中。</p>
</div>
<div class="note warning simple"><p>GPU 和 显卡 并不是相等的关系 GPU 全称为 Graphics Processing Unit，它指示显卡中的核心计算芯片。整个显卡中还包括显存（VRam），散热器等配件。</p>
</div>
<p>对于所有与绘制相关的资源，如贴图，模型，一开始都是存储在硬盘（HDD）上的 。在整个绘制过程中，它们会先被读取到内存（RAM）中，再被读取到显卡上的显存（VRAM）中。之所以要进行这么一个数据从 HDD 拷贝到 VRAM 中的操作，是因为显卡读取 VRAM 中的内容速度更快。整个过程如下所示：<br>
<img src="/book_1_overview/gif_9-13-2021_8-52-50_am.gif" alt="数据从内存拷贝到显存"></p>
<p>又因为整个过程中数据是被 拷贝 的，因此当数据进入 VRAM 后，在 RAM 中的数据可以被正常销毁，不会影响到后续的绘制。如下所示：<br>
<img src="/book_1_overview/gif_9-13-2021_8-55-43_am.gif" alt="内存中数据可安全销毁"></p>
<p>但是 GPU 访问 VRAM 速度仍然不够快，VRAM 中需要使用到的数据会进一步的被拷贝到 GPU 中的一小块内存上（ on-chip caches），这一块内存被称为 <code>L2 Cache</code> 。过程如下所示：<br>
<img src="/book_1_overview/gif_9-13-2021_9-18-41_am.gif" alt="L2 Cache"></p>
<p>在 GPU 更靠近核心（Core）的地方，还有一片更小的内存，称为 <code>L1 Cache</code> 。因为更靠近核心，所以 <code>L1 Cache</code> 中数据的访问速度相对于 <code>L2 Cache</code> 也更快。 <code>L2 Cache</code> 中的数据在需要被操作时，也会先拷贝到 <code>L1 Cache</code> 中。</p>
<p>在 <code>L1 Cache</code> 中的数据还会被进一步拷贝到 GPU 中被称为 <code>Register</code> 的内存区域，GPU Cores 会从该区域中读取数据，计算并将运算后结果放回到 <code>Register</code> 中：<br>
<img src="/book_1_overview/gif_9-13-2021_9-25-58_am.gif" alt="Register"></p>
<h1 id="Set_the_Render_State"><a class="header-anchor" href="#Set_the_Render_State">#</a>Set the Render State</h1>
<p>对于除了 Mesh 数据外的数据，如顶点/像素着色器，纹理，材质，光照信息，是否半透明等信息都称为 <code>Render State</code> 。</p>
<p>Mesh 数据会使用被设置的 <code>Render State</code> 进行渲染，图形 API 又是一个类似状态机的实现，即设置了 Render State 后，后续的 Mesh 都会使用该 State 进行渲染，直到有了新 State 被设置。示意图如下所示：<br>
<img src="/book_1_overview/gif_9-14-2021_8-47-57_am.gif" alt="State"></p>
<h1 id="Draw_Call"><a class="header-anchor" href="#Draw_Call">#</a>Draw Call</h1>
<p><code>DrawCall</code> 是一个由 CPU 端发出，由 GPU 端接受的绘制 <strong>一个 Mesh</strong> 的指令。该指令只包含指向需要绘制的 Mesh 的指针，而如材质这样的信息是通过 Render State 进行传递，并不会在 <code>DrawCall</code> 中。示意图如下所示：<br>
<img src="/book_1_overview/gif_9-14-2021_8-55-41_am.gif" alt="Draw Call"></p>
<h1 id="Pipeline"><a class="header-anchor" href="#Pipeline">#</a>Pipeline</h1>
<p>当 <code>DrawCall</code> 发送后，GPU 会获取当前的 Render State，和设置的顶点信息（Mesh），并通过渲染管线（Pipeline）将其一步步转换到最终屏幕上所见像素。在管线中，对于顶点和像素的工作会被划分到 GPU 的多个核心中平行处理。整个管线工作的简单示意图如下所示：<br>
<img src="/book_1_overview/gif_9-14-2021_9-02-13_am.gif" alt="Pipeline"></p>
<h1 id="Command_Buffer"><a class="header-anchor" href="#Command_Buffer">#</a>Command Buffer</h1>
<p>CPU 并不是直接将数据传递给 GPU，而是通过 <code>Command Buffer</code> ，这样 CPU 和 GPU 就可以各自独立的工作。如果是直接传递的话，当 GPU 在忙碌时，CPU 无法将数据送给 GPU，就会造成 CPU 的堵塞。</p>
<p>Command Buffer 是一个 <code>FIFO 存储器</code> ，即 GPU 只会取 CPU 最早 Push 进 Command Buffer 中的数据。 Command Buffer 的示意图如下所示：<br>
<img src="/book_1_overview/gif_9-14-2021_9-12-25_am.gif" alt="Command Buffer"></p>
<h1 id="Reference"><a class="header-anchor" href="#Reference">#</a>Reference</h1>
<p><a href="http://simonschreibt.de/gat/renderhell-book1/">Render Hell – Book I | Simon schreibt.</a></p>
]]></content>
      <tags>
        <tag>GPU</tag>
      </tags>
  </entry>
  <entry>
    <title>《Render Hell》 第二部分 管线</title>
    <url>/book_2_pipeline/</url>
    <content><![CDATA[<h1 id="GPU_Core"><a class="header-anchor" href="#GPU_Core">#</a>GPU Core</h1>
<p>在 GPU Core 中有两个运算单元 <code>floating point unit(FP UNIT)</code> 和 <code>integer unit (INT UNIT)</code> ，当 GPU Core 接收到数据后，会通过这两个运算单元进行计算。</p>
<p><img src="/book_2_pipeline/gif_9-14-2021_9-27-55_am.gif" alt="FP / Int Unit"></p>
<h2 id="Not_Everything_is_done_by_GPU_Cores"><a class="header-anchor" href="#Not_Everything_is_done_by_GPU_Cores">#</a>Not Everything is done by GPU Cores</h2>
<p>对于如分发渲染任务，计算 <code>Tessellation</code>，<code>Culling</code> ，<code>Depth Testing</code>，光栅化，将计算后的 Pixel 信息写入到 Framebuffer 中等工作，并不是不通过 GPU Cores 完成，这些工作会由 GPU 中其他的硬件模块完成（这些模块不受开发者的代码控制）。</p>
<h2 id="Parallel_Running_Pipelines"><a class="header-anchor" href="#Parallel_Running_Pipelines">#</a>Parallel Running Pipelines</h2>
<p>对于 GPU Core 而言，它需要 <code>Streaming Multiprocessor(SM)</code> 为其分配工作，一个 SM 处理来自于 <strong>一个</strong> Shader 的顶点或像素数据。因此当一个 SM 下有多个 Core 时，来自于 <strong>一个</strong> Shader 的顶点或像素就能被并行的处理。当有多个 SM 时，多个 Shader 间也能并行处理。如下图所示：</p>
<p><img src="/book_2_pipeline/untitled.png" alt="Streaming Multiprocessor"></p>
<h1 id="Pipeline_Stages_In_Depth"><a class="header-anchor" href="#Pipeline_Stages_In_Depth">#</a>Pipeline Stages In-Depth</h1>
<div class="note info simple"><p>这一部分从上至下更深入的讲解 GPU Pipeline</p>
</div>
<h2 id="Application_Stage"><a class="header-anchor" href="#Application_Stage">#</a>Application Stage</h2>
<p>对于应用而言，其提交的图形 API 都是提交给 GPU 的驱动，告诉其需要绘制的内容和 Render State。</p>
<p><img src="/book_2_pipeline/gif_9-15-2021_8-41-31_am.gif" alt="Application 提交图像指令给 Driver"></p>
<h2 id="Driver_Stage"><a class="header-anchor" href="#Driver_Stage">#</a>Driver Stage</h2>
<p>驱动会将绘制的数据 Push 到 Command Buffer 中，当 VSync 或 Flush 时，Command Buffer 中的数据会被 Push 到 GPU 中。</p>
<p><img src="/book_2_pipeline/gif_9-15-2021_8-44-49_am.gif" alt="Driver 将指令给 Command Buffer"></p>
<h2 id="Read_Commands"><a class="header-anchor" href="#Read_Commands">#</a>Read Commands</h2>
<p>显卡中的 <code>Host Interface</code> 会负责读取 Command Buffer 传递进来的数据供后续的使用。<br>
<img src="/book_2_pipeline/gif_9-15-2021_8-45-28_am.gif" alt="Host Interface 读取 Command Buffer"></p>
<h2 id="Data_Fetch"><a class="header-anchor" href="#Data_Fetch">#</a>Data Fetch</h2>
<p>一些 Command 包含数据的拷贝。GPU 通常会有一个单独的模块处理从 RAM 拷贝数据到 VRAM 的过程，反之亦然。这些需要拷贝的数据可以是 Vertex Buffer，纹理或其他 Shader 的参数。通常渲染一帧会从传递 Camera 相关的数据开始。</p>
<p>当所有数据准备完成后，GPU 中会有一个模块（Gigathread Engine）负责处理任务的分发。它为每一个要处理的顶点或像素创建一个线程，并将多个线程打包成一个 Package, NVIDIA 将这个 Package 称为 Thread block 。 Thread Block 会被分发给 SM，如下图所示：<br>
<img src="/book_2_pipeline/gif_9-15-2021_8-58-59_am.gif" alt="分配 Thread Block"></p>
<h2 id="Vertex_Fetch"><a class="header-anchor" href="#Vertex_Fetch">#</a>Vertex Fetch</h2>
<p>SM 中仍然包含了多个硬件的单元，其中一个为 <code>Polymorph Engine</code> ，它负责将数据拷贝到各内存部分中，让 Core 在之后的工作中可以更快的访问数据。</p>
<p><img src="/book_2_pipeline/gif_9-15-2021_9-03-27_am.gif" alt="Polymorph Engine 拷贝数据"></p>
<h2 id="Shader_Execution"><a class="header-anchor" href="#Shader_Execution">#</a>Shader Execution</h2>
<p><code>Streaming MultiProcessor (SM)</code> 的主要功能为执行开发者编写的 Shaders。</p>
<p>SM 首先会将之前获取到的 Thread Block 拆分为多个 <code>Warp</code> 。每一个 Warp 包含的线程数根据硬件的不同可能存在差异， Nvidia 平台下一个 Warp 包含 32 个 Thread。<br>
<img src="/book_2_pipeline/pipeline_workdistribution_02.gif" alt="Thread Block to Warp"></p>
<p>SM 中包含多个 <code>Warp Schedulers</code> ，每个 <code>Warp Schedulers</code> 会选择其中一个 Warp，并将需要执行的指令进行翻译。与 Warp 中线程数相同的 GPU Core 会一起逐条执行这些指令。每个 GPU Core 在同一时间点会执行相同的指令，但有着不同的数据（如不同的像素，不同的顶点）。为了简化，如下只展示一个 <code>Warp Schedulers</code> 的情况，过程如下所示：</p>
<p><img src="/book_2_pipeline/pipeline_workdistribution_04.gif" alt="Wrap Schedulers 执行指令"></p>
<div class="note info simple"><p>对于每个 GPU Core 而言，它们无法知晓整个 Shader 指令，它们在仅知晓当前需要执行的那 <strong>一条</strong> 指令。</p>
</div>
<p>需要再次强调的是，一个 Warp 对应的 GPU Cores 在同一时间点会执行相同的指令，不会存在某个时间点一个 Core 执行语句 A，另一个 Core 执行语句 B 的情况。这种限制被称为 <code>lock-step</code> 。</p>
<p>当 Shader 中 IF 指令时，进入分支的 Core 会进行工作，剩下的 Core 会进入“休眠”。同理如果 Shader 中存在循环，那么仍然在循环内的 Core 进行工作，已经完成循环 工作的 Core 进入休眠，直到所有的 Core 都完成了操作。如下所示：</p>
<p><img src="/book_2_pipeline/pipeline_workdistribution_06.gif" alt="Lock Step"></p>
<div class="note info simple"><p>部分 Cores 工作，部分 Cores 休眠的现象称为 <strong><code>divergent threads</code></strong> 应当要尽量避免。</p>
</div>
<p>当 Warp 中需要执行的指令依赖的数据尚未被准备好， SM 会选择另一个 Warp 并执行其中的指令，如下所示：<br>
<img src="/book_2_pipeline/pipeline_workdistribution_07.gif" alt="Memory Stall"></p>
<div class="note info simple"><p>Warp 中指令依赖数据未准备好，必须切换另一个 Warp 继续执行的现象，称为 <code>Memory Stall</code> 。</p>
</div>
<p>如前所述，一个 SM 可能包含多个 Warp Schedulers，也因此可以并行的处理多个 Warps，<br>
<img src="/book_2_pipeline/untitled_1.png" alt="|多个 Warps"></p>
<h2 id="Vertex_Shader"><a class="header-anchor" href="#Vertex_Shader">#</a>Vertex Shader</h2>
<p>每一个顶点着色器的实例对应 <strong>一个</strong> 顶点的处理，且运行在被 SM 管理的一个线程上。<br>
<img src="/book_2_pipeline/pipeline_vertex_shader_01.gif" alt="顶点"></p>
<h2 id="Tessellation"><a class="header-anchor" href="#Tessellation">#</a>Tessellation</h2>
<div class="note primary simple"><p>曲面细分阶段中，有两个可编程的着色器， <code>Hull Shader</code> 和 <code>Domain Shader</code></p>
</div>
<div class="note info simple"><p>为何需要曲面细分阶段，而不是直接在模型中增加更多的顶点？</p>
<ol>
<li>相较于更多顶点时数据传输时的开销，通过曲面细分生成更多顶点的开销更低</li>
<li>曲面细分阶段可以控制顶点该如何被细分，如根据摄像机的距离。这样就能产生出更适合实际使用时的顶点数据。</li>
</ol>
</div>
<h3 id="Patch_Assembly"><a class="header-anchor" href="#Patch_Assembly">#</a>Patch Assembly</h3>
<div class="note info simple"><p><code>Patch Assembly</code> 和后续的 <code>Hull Shader</code> ， <code>Tessellation</code> 及 <code>Domain Shader</code> 仅当使用了 <code>曲面细分着色器(Tessellation Shader)</code> 时才会进行。</p>
</div>
<p>Patch Assembly 阶段会把多个顶点打包成一个 Patch 供后续的 Tessellation 阶段处理。究竟多少个 顶点会被打包成一个 Patch，是由开发者决定的，最多 32 个顶点可以被打包成一个 Patch：<br>
<img src="/book_2_pipeline/pipeline_patch_assembly_01.gif" alt="将多个顶点打包为一个 Patch"></p>
<h3 id="Hull_Shader"><a class="header-anchor" href="#Hull_Shader">#</a>Hull Shader</h3>
<p>Hull Shader 处理之前被打包成一个 Patch 的顶点们，并生成一系列的 <code>Tessellation Factor</code> 。这些 Factors 指明了 Patch 中的边该如何细分，和 Patch 的内部该如何细分。</p>
<p>Hull Shader 中也可以指明计算 Factor 的方法，最常见的是根据与摄像机的距离：</p>
<p><img src="/book_2_pipeline/pipeline_hull_shader_01.gif" alt="Tessellation Factor"></p>
<p>另外因为 GPU 仅能对三个基本的几何元素（ Quad，Triangle，Lines）进行细分，Hull Shader 也会指明 Patch 需要按哪个几何元素进行细分。</p>
<h3 id="Tessellation-2"><a class="header-anchor" href="#Tessellation-2">#</a>Tessellation</h3>
<p><code>Polymorph Engine</code> 会根据之前的 Patch 以及得到的 Tessellation Factor 真正的执行细分操作：</p>
<p><img src="/book_2_pipeline/pipeline_tesselation_01.gif" alt="Polymorph Engine"></p>
<p>被细分创造出的顶点会被送回到 <code>GigaThead Engine</code> 中，并被其重新派分给 SM，这些 SM 会将得到的顶点通过 <code>Domain Shader</code> 处理。</p>
<h3 id="Domain_Shader"><a class="header-anchor" href="#Domain_Shader">#</a>Domain Shader</h3>
<p>Domain Shader 会根据 Hell Shader 的输出（ Patch 顶点）以及 Tessellation 的输出（顶点的质心坐标系（ Barycentric Coordinate））调整每个顶点的位置。如果开发者使用了 <code>Displacement map</code> ，则会在这个阶段被使用：</p>
<p><img src="/book_2_pipeline/pipeline_domain_shader01.gif" alt="Domain Shader "></p>
<h2 id="Primitive_Assembly"><a class="header-anchor" href="#Primitive_Assembly">#</a>Primitive Assembly</h2>
<p>图元装配阶段，会将顶点数据（来自于 Vertex Shader 或来自于 Tessellation ）装配成一个个几何图形：<br>
<img src="/book_2_pipeline/pipeline_primitive_assembly_01.gif" alt="图元装配"></p>
<h2 id="Geometry_Shader"><a class="header-anchor" href="#Geometry_Shader">#</a>Geometry Shader</h2>
<div class="note info simple"><p>几何着色器（Geometry Shader）是一个可选 Shadder</p>
</div>
<p>几何着色器会针对 Primitive Assembly 给出的图元进行调整，如它可以将一个点调整为两个三角形：</p>
<p><img src="/book_2_pipeline/pipeline_geometry_shader01.gif" alt="几何"></p>
<div class="note info simple"><p>如果需要大量的生成新顶点，更适合在 Tessellation 阶段进行。</p>
</div>
<div class="note info simple"><p>几何着色器更大意义在于，它是进入光栅化前最后可配置的一个阶段。如它在 <code>Voxelization Techniques</code> 中扮演了重要角色。</p>
</div>
<h2 id="Viewport_Transform_Clipping"><a class="header-anchor" href="#Viewport_Transform_Clipping">#</a>Viewport Transform &amp;&amp; Clipping</h2>
<p>之前的操作，物体都是处在 NDC 空间中的。在 Viewport Transform 中需要将其转换到与屏幕分辨率匹配的空间（Viewport 空间），这个操作被称为 <code>Viewport Transform</code> 或 <code>Screen Mapping</code> 。</p>
<p><img src="/book_2_pipeline/pipeline_screenmapping01.gif" alt="Viewport Transform"></p>
<p>超过了屏幕范围的三角形会被裁剪，这一部分称为 <code>Guard Band Clipping</code> ，如下所示：<br>
<img src="/book_2_pipeline/pipeline_clipping01.gif" alt="Guard Band Clipping"></p>
<h2 id="Rasterizing"><a class="header-anchor" href="#Rasterizing">#</a>Rasterizing</h2>
<p>在运行像素着色器前，需要通过光栅化，将之前的三角形转换为屏幕上的像素。 GPU 硬件中通常包含多个光栅器，并且他们可以同时工作。</p>
<p>每一个光栅器会负责屏幕中的特定区域，因此 GPU 会根据三角形在屏幕中的位置决定他们应当由哪个光栅器进行处理，并将其发送给特定的光栅器。示意图如下所示：</p>
<p><img src="/book_2_pipeline/pipeline_triangle_journey01.gif" alt="指定光栅器"></p>
<div class="note info simple"><p>如果一个三角形足够的大，覆盖了屏幕中的很大一部分，那么可能会同时有多个光栅器为其进行光栅化。</p>
</div>
<p>当光栅器接收到一个三角形数据后，它会首先快速的检查该三角形的朝向<code>（Face Culling）</code> 。如果三角形通过了 Face Culling，则光栅器会根据三角形的边，确定它覆盖了那些 Pixels Quad （ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>×</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2\times2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> Piexls，或称为 <code>pre-pixels</code> / <code>pre-fragment</code>），示意图如下所示：<br>
<img src="/book_2_pipeline/pipeline_rasterizing02.gif" alt="确认覆盖的 Pixels Quad"></p>
<p>之所以以 <code>pre-piexles/fragments</code> 作为一个单位，而非单一的 Pixel 作为单位，是因为这样可以计算一些后续操作需要用到的数据（如采样 Mipmap 时需要的导数<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。</p>
<div class="note info simple"><p>一些 Tile-Based 硬件 ，在 <code>pre-pixels/fragments</code> 创建后，可能会有一些硬件层面上的可见性检测。它们会将整个 Tile 发送给一个称为 <code>Z-Cull</code> 的模块，该模块会将 Tile 中的每个像素的深度与 FrameBuffer 中的像素深度进行比较，如果一整个 Tile 的测试都未通过，则该 Tile 会被丢弃。</p>
</div>
<h2 id="Pixel_Shader"><a class="header-anchor" href="#Pixel_Shader">#</a>Pixel Shader</h2>
<p>对于每个 <code>pre-pixels/fragments</code> ，它们会被 Pixel Shaders 进行填色处理。同样的， Pixel Shader 也是运行在 Warp 的一个线程上。</p>
<div class="note info simple"><p>一个 <code>pre-pixels/fragments</code> 实际上是 4 个像素（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>∗</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2*2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>），因此一个 32 线程的 Warp，实际上运行 8 个 <code>pre-pixels/fragments</code> 。</p>
</div>
<p>当核心工作完成后，它们会将得到的数据写入 L2 Cache。</p>
<h2 id="Raster_Output"><a class="header-anchor" href="#Raster_Output">#</a>Raster Output</h2>
<p>在管线的最后，会有称为 <code>Raster Output(ROP)</code> 的硬件模块将 L2 Cache 中存储的 Pixel Shader 运算得到的像素数据写入 VRAM 中的 Frame buffer。</p>
<p>除了单纯的拷贝像素数据， ROPs 还会进行如 Pixel Blending， 抗锯齿时依赖的 Coverage Information 计算等工作。</p>
<h1 id="Reference"><a class="header-anchor" href="#Reference">#</a>Reference</h1>
<p><a href="http://simonschreibt.de/gat/renderhell-book2/">Render Hell – Book II | Simon schreibt.</a></p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a href="https://developer.nvidia.com/content/life-triangle-nvidias-logical-pipeline">Life of a triangler</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <tags>
        <tag>GPU</tag>
      </tags>
  </entry>
  <entry>
    <title>《Render Hell》 第三部分 常见问题</title>
    <url>/book_3_problems/</url>
    <content><![CDATA[<h1 id="Many_Draw_Calls_Many_Commands"><a class="header-anchor" href="#Many_Draw_Calls_Many_Commands">#</a>Many Draw Calls / Many Commands</h1>
<p>对于一个 API 而言，它不仅仅是将命令发送给 GPU，它还会有额外的如驱动翻译等的开销，因此应当尽可能的使用更少的命令。</p>
<div class="note info simple"><p>对于新的图形 API，如 DirectX12， Vulkan 等，命令的开销会相对较少，但仍然应当尽可能的减少命令的数量。</p>
</div>
<p>如果有一系列很小的 Mesh，相较于每个 Mesh 都使用一个 Drawcall，更理想的做法是将这些 Meshes 组合成一个更大的 Mesh，并通过一个 Drawcall 传送。</p>
<p>因为对于 GPU 而言，绘制一个小 Mesh 的时间是非常快的，而 CPU 将数据发送给 GPU 的时间是相对较长的。</p>
<p>如果是每一个 Mesh 一个 Draw Call 的处理方式，往往瓶颈会出现在 CPU 侧。</p>
<h1 id="Many_Meshes_and_Materials"><a class="header-anchor" href="#Many_Meshes_and_Materials">#</a>Many Meshes and Materials</h1>
<p>如果要渲染许多 Mesh 并使用不同的 Materials，除了需要用许多的命令外，还会额外带来 <code>Flush Pipeline</code> 的问题。</p>
<p>如果多个 Meshes 是用同一种渲染状态，则在一个 Mesh 完成后，另一个 Mesh 可以被很快的装填。而如果更改了材质状态，则管线中的一部分数据需要被刷新，才能进行下一个 Mesh 的绘制，这会造成额外的开销。</p>
<h1 id="Meshes_and_Multi_Materials"><a class="header-anchor" href="#Meshes_and_Multi_Materials">#</a>Meshes and Multi-Materials</h1>
<p>如果一个 Mesh 被赋予了多个材质，则该 Mesh 会被切分成多份再被送入 Command Buffer 中，这无疑也会造成多个 Draw Call 的产生。如下示意图所示，球的左半部分和右半部分各需要一个 Draw Call：<br>
<img src="/book_3_problems/copy_data_from_hdd_to_ram_vram_01_multimaterial.gif" alt="Multi-Materials"></p>
<h1 id="Thin_Triangles"><a class="header-anchor" href="#Thin_Triangles">#</a>Thin Triangles</h1>
<p>如在 Book 2 的 <a href="/book_2_pipeline/#Rasterizing">Rasterizing</a> 中所属，光栅化后的单位是 <code>pre-pixles</code> ，Warp 中的四个线程会被分给一个 <code>pre-pixels</code> 。对于一些没有真正覆盖三角形的 Pixels 而言，它们的颜色并无意义，因此虽然它们在 pre-pixels 中但并不会有线程去计算它们的颜色，这也就造成了 Warp 中线程的浪费。这种性能浪费会比较常见的出现在狭长的三角形中，如下示意图所示：<br>
<img src="/book_3_problems/pipeline_rasterizing03_.gif" alt="Thin Triangles 造成的性能浪费"></p>
<h1 id="Reference"><a class="header-anchor" href="#Reference">#</a>Reference</h1>
<p><a href="http://simonschreibt.de/gat/renderhell-book3/">Render Hell – Book III | Simon schreibt.</a></p>
]]></content>
      <tags>
        <tag>GPU</tag>
      </tags>
  </entry>
  <entry>
    <title>《Render Hell》 第四部分 解决方法</title>
    <url>/book_4_solutions/</url>
    <content><![CDATA[<h1 id="Sorting"><a class="header-anchor" href="#Sorting">#</a>Sorting</h1>
<p>对于多个 Meshes，多个 Materials 的情况，可以通过排序将同一种 Material 的 Mesh 放在一起减少 Render State 的切换，如下所示：<br>
<img src="/book_4_solutions/optimisation_sorting_01.gif" alt="重新排序以减少 State 切换"></p>
<h1 id="Batching"><a class="header-anchor" href="#Batching">#</a>Batching</h1>
<p>在排序完，仍然存在的问题是多个 Meshes 会造成多个 Commands 进而引起过多开销。因此应当将多个 Meshes 结合在一起，通过一次 Draw Call 进行渲染。在调用 API 前将多个 Meshes 合并在一起的过程称为 <code>Batch</code> 。</p>
<p><img src="/book_4_solutions/optimisation_batching_02.gif" alt="Batching"></p>
<div class="note info simple"><p>在 RAM 中将多个 Mesh 结合在一起也是需要开销的（CPU 时间），因此通常选择将静态的 Mesh，如房子，石头等Batch 在一起。 而如果是一系列运动的子弹，因为它们的位置每帧都会移动，所以相当于每帧都需要重新 <code>Batch</code>，这会造成巨大的开销。</p>
</div>
<p>Batch 还会造成一个额外的问题。在未进行 Batch 时，如果一个 Mesh 在 Frustum 外，则它会被直接 Cull 掉。但如果将多个 Meshes Batch 成一个大 Mesh，则即使只有其中的一小部分处在 Frustum 中，整个 Mesh 仍然会被认为需要被绘制。</p>
<p>因此相对于 <code>Batching</code>，更好的解决方法是 <code>Instancing</code></p>
<h1 id="Instancing"><a class="header-anchor" href="#Instancing">#</a>Instancing</h1>
<p><code>Instancing</code> 是提交一次 Mesh，但会告知 GPU 绘制多次，并在 RAM 中指定每次绘制时需要用的状态。因此 <code>Instancing</code> 适合同一个 Mesh 要多次绘制的情况，如草，子弹。示意图如下所示：<br>
<img src="/book_4_solutions/20200129181033200.gif" alt="Instancing"></p>
<h1 id="Multi_Material_Shader"><a class="header-anchor" href="#Multi_Material_Shader">#</a>Multi-Material Shader</h1>
<p>为了解决 Book3 中提到的 <a href="/book_3_problems/#Meshes_and_Multi-Materials">Meshes and Multi-Materials</a> 导致多 Draw Call 的问题，一个解决思路是将多个材质需要用到的数据合并在一个 Shader 中，相当于将多个 Material 合并成了一个 Material。</p>
<p>如原来每个材质需要一个 Diffuse Texture，一个 Normal Texture，可以使用一个包含两个 Diffuse Texture， 两个 Normal Texture 的材质来取代原来的两个材质，并在 Shader 中通过 Blending 的方式达成之前的效果。</p>
<div class="note warning simple"><p>这种实现方式虽然减少了 DrawCall 的数量，但会造成 Blending 的大量额外开销，因此最终性能可能反而下降。</p>
</div>
<h1 id="Skinned_Meshes"><a class="header-anchor" href="#Skinned_Meshes">#</a>Skinned Meshes</h1>
<p>如之前的描述，如果需要通过 Batch 来解决多个子弹占用多个 Draw Call 的问题，则会因为子弹需要每帧移动而造成每帧重新 Batch，这会造成巨大的开销。</p>
<p>有一个解决思路是将所有这些子弹结合在一起作为 Skinned Mesh，其中每个子弹作为一个 Bone，在后续的帧中只需要更新这些 Bone 的位置，而不需要重新进行合并。</p>
<div class="note warning simple"><p>当出现了子弹增加或减少时，则需要重新合并 Mesh</p>
</div>
<h1 id="Reference"><a class="header-anchor" href="#Reference">#</a>Reference</h1>
<p><a href="http://simonschreibt.de/gat/renderhell-book4/">Render Hell – Book IV | Simon schreibt.</a></p>
]]></content>
      <tags>
        <tag>GPU</tag>
      </tags>
  </entry>
  <entry>
    <title>《Learn OpenGL》 Ch 00 创建 Window</title>
    <url>/ch_00_creating_a_window/</url>
    <content><![CDATA[<div class="note primary simple"><p>本部分的实现代码，见 <a href="https://github.com/xuejiaW/LearnOpenGL/tree/main/_00_CreateWindow">00_CreateWindow</a></p>
</div>
<p>在使用 OpenGL 前，首先需要创建 OpenGL 的上下文和用于绘制的窗口等，这些内容是与操作系统相关的。OpenGL 希望成为一个跨平台的工具，因此 OpenGL 本身并不复杂这些内容的处理，需要用户自己来进行相关的环境配置。</p>
<p>好在一些现有的库已经帮助完成了工作，在学习 OpenGL 前首先需要进行的就是相关库的配置。</p>
<ul>
<li>在 <a href="/ch_00_creating_a_window/#%E5%88%9B%E5%BB%BA%E5%B7%A5%E7%A8%8B">创建工程</a> 中，创建后续所有的 OpenGL 教材存储的解决方案文件夹，每一个 OpenGL 教材都会是其中的一个项目。</li>
<li>在 <a href="/ch_00_creating_a_window/#%E9%85%8D%E7%BD%AE_includes_%E5%92%8C_libs_%E6%96%87%E4%BB%B6%E5%A4%B9">配置 includes 和 libs 文件夹</a> 中，配置后续所有的项目需要用到的 <a href="/ch_00_creating_a_window/#GLFW">GLFW</a> 和 <a href="/ch_00_creating_a_window/#GLAD">GLAD</a>，他们会存储在 <code>includes</code> 和 <code>libs</code> 文件夹内。</li>
<li>在 <a href="/ch_00_creating_a_window/#%E9%85%8D%E7%BD%AE%E9%A1%B9%E7%9B%AE">配置项目</a> 中将 <code>includes</code> 和 <code>libs</code> 引用给项目。</li>
</ul>
<h1 id="创建工程"><a class="header-anchor" href="#创建工程">#</a>创建工程</h1>
<p>首先在 Visual Studio 或 Rider 中创建 C++ 空白解决方案，并创建 <code>00_HelloWindow</code> 项目。另外创建空白的 <code>includes</code> 和 <code>libs</code> 文件夹。</p>
<p>此时的工程结构为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── 00_HelloWindow</span><br><span class="line">│   ├── 00_HelloWindow.vcxproj</span><br><span class="line">│   ├── 00_HelloWindow.vcxproj.filters</span><br><span class="line">│   └── main.cpp</span><br><span class="line">├── LearnOpenGL.sln</span><br></pre></td></tr></table></figure>
<div class="note primary simple"><p>后续说明以 Rider 作为 IDE 为例。</p>
</div>
<h1 id="配置_includes_和_libs_文件夹"><a class="header-anchor" href="#配置_includes_和_libs_文件夹">#</a>配置 includes 和 libs 文件夹</h1>
<p>我们将项目所依赖的头文件放置在 <code>includes</code> 文件夹内，将依赖的静态库放置在 <code>libs</code> 文件夹内，目前主要需要包含 <a href="/ch_00_creating_a_window/#GLFW">GLFW</a> 和 <a href="/ch_00_creating_a_window/#GLAD">GLAD</a> 两个库。</p>
<h2 id="GLFW"><a class="header-anchor" href="#GLFW">#</a>GLFW</h2>
<p>GLFW 用来进行创建系统窗口 / 渲染上下文，处理用户输入等操作。</p>
<p>对于 Windows 平台，可以直接从 <a href="https://www.glfw.org/download.html">GLFW 官网</a> 上下载 <code>Windows pre-compiled binaries</code> 版本的文件，解压后的内容应当如下所示：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">└── glfw─3.4.bin.WIN64</span><br><span class="line">    ├── LICENSE.md</span><br><span class="line">    ├── README.md</span><br><span class="line">    ├── docs</span><br><span class="line">    │   └── html</span><br><span class="line">    ├── include</span><br><span class="line">    │   └── GLFW</span><br><span class="line">    ├── lib─mingw─w64</span><br><span class="line">    │   ├── glfw3.dll</span><br><span class="line">    │   ├── libglfw3.a</span><br><span class="line">    │   └── libglfw3dll.a</span><br><span class="line">    ├── lib─static─ucrt</span><br><span class="line">    │   ├── glfw3.dll</span><br><span class="line">    │   └── glfw3dll.lib</span><br><span class="line">    ├── lib─vc2013</span><br><span class="line">    │   ├── glfw3.dll</span><br><span class="line">    │   ├── glfw3.lib</span><br><span class="line">    │   ├── glfw3_mt.lib</span><br><span class="line">    │   └── glfw3dll.lib</span><br><span class="line">    ├── lib─vc2015</span><br><span class="line">    │   ├── glfw3.dll</span><br><span class="line">    │   ├── glfw3.lib</span><br><span class="line">    │   ├── glfw3_mt.lib</span><br><span class="line">    │   └── glfw3dll.lib</span><br><span class="line">    ├── lib─vc2017</span><br><span class="line">    │   ├── glfw3.dll</span><br><span class="line">    │   ├── glfw3.lib</span><br><span class="line">    │   ├── glfw3_mt.lib</span><br><span class="line">    │   └── glfw3dll.lib</span><br><span class="line">    ├── lib─vc2019</span><br><span class="line">    │   ├── glfw3.dll</span><br><span class="line">    │   ├── glfw3.lib</span><br><span class="line">    │   ├── glfw3_mt.lib</span><br><span class="line">    │   └── glfw3dll.lib</span><br><span class="line">    └── lib─vc2022</span><br><span class="line">        ├── glfw3.dll</span><br><span class="line">        ├── glfw3.lib</span><br><span class="line">        ├── glfw3_mt.lib</span><br><span class="line">        └── glfw3dll.lib</span><br></pre></td></tr></table></figure>
<p>我们只关心其中的 <code>lib-vc2022</code> 和 <code>GLFW</code> 文件夹，将 <code>GLFW</code> 拷贝至 <code>includes</code> 目录下，将 <code>lib-vs2022</code> 中的内容拷贝至 <code>libs</code> 目录中。</p>
<h2 id="GLAD"><a class="header-anchor" href="#GLAD">#</a>GLAD</h2>
<p><code>GLAD</code> 库用来简化找寻 OpenGL 实现地址的过程。</p>
<p>因为 OpenGL 实质上是一个标准，并不包含各函数接口的实现。所以不同的显卡厂商而言，会有不同的 OpenGL 函数的实现，这些实现都定义在显卡的驱动中。因此 OpenGL 函数的地址并不能在编译时刻确定，只能在 Runtime 时找到相关的函数指针地址再使用该指针进行操作，这无疑这是一个很繁琐的功能。因此我们需要 <code>GLAD</code> 库来简化操作。</p>
<p><code>GLAD</code>库使用了网络服务来简化了编译过程，只要在其<a href="https://glad.dav1d.de/">网站</a>上选择目标语言和相关 OpenGL 类型之后，就可以直接生成出想要的内容并直接下载，网站上的相关设置如下：</p>
<p><img src="/ch_00_creating_a_window/image-20211214094537336.png" alt=""></p>
<p>当进行完配置后，下载 <code>glad.zip</code> 压缩包：<br>
<img src="/ch_00_creating_a_window/image-20240424224815.png" alt="glad.zip"></p>
<p>解压缩下载到的 <code>glad.zip</code> 文件夹，应该得到如下的内容：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── include</span><br><span class="line">│   ├── KHR</span><br><span class="line">│   │   └── khrplatform.h</span><br><span class="line">│   └── glad</span><br><span class="line">│       └── glad.h</span><br><span class="line">└── src</span><br><span class="line">    └── glad.c</span><br></pre></td></tr></table></figure>
<p>在进入文件夹，运行如下两个命令来生成需要的静态链接文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc ./src/glad.c -c -I ./include/</span><br><span class="line">ar -rc glad.lib glad.o</span><br></pre></td></tr></table></figure>
<div class="note primary simple"><p>gcc 可以通过 Chocolatey 安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">choco install mingw</span><br></pre></td></tr></table></figure></div>
<p>然后将 <code>include</code> 目录下的内容拷贝至项目的 <code>includes</code> 目录下，将 <code>glab.lib</code> 拷贝至 <code>libs</code> 目录下。</p>
<h1 id="配置项目"><a class="header-anchor" href="#配置项目">#</a>配置项目</h1>
<p>当完成了 <a href="/ch_00_creating_a_window/#%E9%85%8D%E7%BD%AE_includes_%E5%92%8C_libs_%E6%96%87%E4%BB%B6%E5%A4%B9">配置 includes 和 libs 文件夹</a> 后，整个项目的目录结构为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">├── 00_HelloWindow</span><br><span class="line">│   ├── 00_HelloWindow.vcxproj</span><br><span class="line">│   ├── 00_HelloWindow.vcxproj.filters</span><br><span class="line">│   └── main.cpp</span><br><span class="line">├── LearnOpenGL.sln</span><br><span class="line">├── includes</span><br><span class="line">│   ├── GLFW</span><br><span class="line">│   │   ├── glfw3.h</span><br><span class="line">│   │   └── glfw3native.h</span><br><span class="line">│   ├── KHR</span><br><span class="line">│   │   └── khrplatform.h</span><br><span class="line">│   └── glad</span><br><span class="line">│       └── glad.h</span><br><span class="line">└── libs</span><br><span class="line">    ├── glad.lib</span><br><span class="line">    ├── glfw3.dll</span><br><span class="line">    ├── glfw3.lib</span><br><span class="line">    ├── glfw3_mt.lib</span><br><span class="line">    └── glfw3dll.lib</span><br></pre></td></tr></table></figure>
<p>此时需要配置项目，以保证项目正确的使用配置的 <code>includes</code> 和 <code>libs</code>，首先进入 <code>Solution Configuration</code> 选择目标的平台：</p>
<p><img src="/ch_00_creating_a_window/2024-04-24-22-02-40.png" alt="Solution Configuration"></p>
<p>这里选择为 <code>Debug|x64</code>：</p>
<p><img src="/ch_00_creating_a_window/image-20240424223630.png" alt="Debug|x64"></p>
<p>在 <code>Project Properties</code> 的 <code>Debug|x64</code> 中的 <code>VC++ Directories</code> 中添加 <code>includes</code> 和 <code>libs</code> 文件夹：</p>
<p><img src="/ch_00_creating_a_window/2024-04-24-22-38-48.png" alt="Include &amp;&amp; Library Directories"></p>
<p>在 <code>Linker -&gt; Input</code> 中添加 <code>glfw3dll.lib</code> 和 <code>glad.lib</code> 和 <code>opengl32.lib</code> 的链接：<br>
<img src="/ch_00_creating_a_window/2024-04-24-22-41-43.png" alt="Linker"></p>
<p>至此，<code>includes</code> 和 <code>libs</code> 都已经配置完成了，将 <code>main.cpp</code> 改为以下内容：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">glfwInit</span>();</span><br><span class="line">	<span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">	<span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">	<span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line">	GLFWwindow *window = <span class="built_in">glfwCreateWindow</span>(SCR_WIDTH, SCR_HEIGHT, <span class="string">&quot;LearnOpenGL&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="built_in">glfwTerminate</span>();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">		<span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line">		<span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">		<span class="built_in">glfwPollEvents</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">glfwTerminate</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时运行程序，结果应当为一个绿色的窗口，如下所示：</p>
<p><img src="/ch_00_creating_a_window/image-20211214094734876.png" alt=""></p>
<p>至此整个学习 OpenGL 的环境设置完成。</p>
<h1 id="Reference"><a class="header-anchor" href="#Reference">#</a>Reference</h1>
<p><a href="https://learnopengl.com/Getting-started/Creating-a-window">LearnOpenGL - Creating a window</a></p>
]]></content>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>《Computer Networks and Internets》 Ch 01 介绍与概览</title>
    <url>/ch_01_introduction_and_overview/</url>
    <content><![CDATA[<h1 id="Growth_Of_Computer_Networking"><a class="header-anchor" href="#Growth_Of_Computer_Networking">#</a>Growth Of Computer Networking</h1>
<p>计算机网络正在持续的爆炸性成长。在 1970 年代它只是一个非常小范围的研究课题，在 1980 年也只有几个网站，但到现在计算机网络f经成为了生活中的一部分。</p>
<h1 id="Why_Networking_Seems_Complex"><a class="header-anchor" href="#Why_Networking_Seems_Complex">#</a>Why Networking Seems Complex</h1>
<p>计算机网络是一个高速发展的领域。</p>
<p>对于初学者而言，他可能让人觉得很困惑，因为并没有一个最基础的理论来将计算机网络的所有部分联系在一起。有许多组织都定义了计算机网络的标准，而有时这些标准相互之间并不兼容。</p>
<p>计算机网络用语也并没有一个统一的标准，许多组织都定义过自己一套用语规范，这又很容易让初学者们感到困惑。</p>
<h1 id="The_Five_Key_Aspects_of_Networking"><a class="header-anchor" href="#The_Five_Key_Aspects_of_Networking">#</a>The Five Key Aspects of Networking</h1>
<p>计算机网络包括五个关键领域：</p>
<ol>
<li>网络应用与网络编程</li>
<li>数据通信</li>
<li>分组交换与网络技术</li>
<li>TCP/IP 的网络互联</li>
<li>附加的网络概念和技术</li>
</ol>
<h2 id="Network_Applications_and_network_programming"><a class="header-anchor" href="#Network_Applications_and_network_programming">#</a>Network Applications and network programming</h2>
<p>用户使用网络服务和设施是基于一个安装在电脑上的应用程序，这个程序可以与其他电脑上的程序通过网络进行交流。网络程序有很多种类，包括邮件，下载器，游览器等。</p>
<p>所有这些程序都是构建在一个单一的、共享的网络上，因此开发者可以使用同一套接口来进行开发。</p>
<p>计算机网络的知识可以帮助开发者更好的开发网络应用。</p>
<h2 id="Data_Communications"><a class="header-anchor" href="#Data_Communications">#</a>Data Communications</h2>
<p>数据通信是电子工程的主要领域，它基于一些物理现象来传输数据，是一个较底层的方法。</p>
<p>因为数据通信是基于物理概念，所以乍看起来它与计算机网络的学习并没有太深的关系，但数据通信中的一些关键概念影响了通信规范的制定。例如调制中带宽的概念直接影响了网络的吞吐量。</p>
<p>数据通信也引入了复用的概念，即多个来源的数据可以被组合在一起通过一个共享的媒介进行传输，然后再分开传递给不同的目的地。</p>
<p>数据通信包含了许多底层的细节，它为计算机网络构建了基础。</p>
<h2 id="Packet_Switching_And_Networking_Technologies"><a class="header-anchor" href="#Packet_Switching_And_Networking_Technologies">#</a>Packet Switching And Networking Technologies</h2>
<p>通信网络已经从早期的依赖于物理点线进行的点对点电报或电话系统转换为一个通信电路。早期的通过线连接已经转换为通过电交换。</p>
<p><code>分组交换（Packet switching）</code>从最底层的方式改变了网络，是现代网络的基础。多个信息发送者不再需要依赖于专用网络，通过分组交换他们可以通过一个共享的网络来传输数据。</p>
<p>分组交换将数据分为许多小块，称为包 <code>Packets</code>，包中都包含一个目的地的信息。网络中的设备都包含了如何抵达其他地址的信息，当设备接收到一个包后他会解析包中的数据，并选择一个通路将其送给正确的目的地。</p>
<p>因为计算机网络在设计时有许多不同的需求，例如速度，距离，经济成本等，有许多分组交换技术被发明出来，他们针对不同的需求在细节上存在着一些差异。</p>
<h2 id="Internetworking_with_TCP_IP"><a class="header-anchor" href="#Internetworking_with_TCP_IP">#</a>Internetworking with TCP/IP</h2>
<p>在一段时间内，许多研究者都致力于找到一个可以满足所有需求的分组交换技术。在 1973 年，Vinton Cerf 和 Pobert Kahn 认为不存在一种分组交换技术可以满足所有的需求，因此他们致力于将不同的技术融合在一起。他们发展了一系列的标准，并最终成为了<code>TCP/IP协议族(TCP/IP Internet Protocol)</code>(简称为 TCP/IP)。这最终成为了全球网络的基础，并称为计算机网络的一个重要组成部分。</p>
<p>TCP/IP 标准成功的一个重要原因是它宽容的异质性。TCP/IP 使用了一个虚拟的方法来定义网络不相关的包和网络不相关的检测方法。因此即使分组技术在持续的发展，TCP/IP 也始终可以与新的分组技术共存。</p>
<h2 id="Additional_Networking_Concepts_And_Technologies"><a class="header-anchor" href="#Additional_Networking_Concepts_And_Technologies">#</a>Additional Networking Concepts And Technologies</h2>
<p>除了构造网络的硬件和协议，还有大量的其他技术为网络提供了不同偶给你能。</p>
<p>例如 <code>软件定义网络(Software Defined Networking(SDN))</code> 允许管理者定义和控制网络， <code>物联网(Internet to Thing)</code> 让嵌入式系统可以通过网络进行交流。</p>
<h1 id="Public_and_Private_Parts_Of_The_Internet"><a class="header-anchor" href="#Public_and_Private_Parts_Of_The_Internet">#</a>Public and Private Parts Of The Internet</h1>
<p>计算机网络是由 <code>公共网络(Public network)</code> 和 <code>私人网络(Private network)</code> 构成的。</p>
<h2 id="Public_Network"><a class="header-anchor" href="#Public_Network">#</a>Public Network</h2>
<p>公共网络是 <code>服务提供商(Service Provider)</code> 所拥有的服务，服务商会将服务提供给任何订阅了的个人或组织。这里的公共指的是大众都可以订阅这个服务，并不意味着公共网络传输的数据是被暴露在外，所有人都可以获取的。</p>
<h2 id="Private_Network"><a class="header-anchor" href="#Private_Network">#</a>Private Network</h2>
<p>私人网络是指网络的使用权被限制在一个组间。如果服务商将服务租赁给了个人或公司，个人或公司仅在自己的范围内使用这个网络，那么它就是私人网络。</p>
<p>私人网络按其大小可以被分类为以下四种：</p>
<ol>
<li>消费者(Consumer)</li>
<li>小型办公室/家庭办公室(Small Office/Home Office, SOHO)</li>
<li>中小型商用(small-medium Business, SMB)</li>
<li>大型企业(Large enterprise)</li>
</ol>
<h1 id="Networks_Interoperability_And_Standards"><a class="header-anchor" href="#Networks_Interoperability_And_Standards">#</a>Networks, Interoperability, And Standards</h1>
<p>通信至少包含两个实体，信息发送者和信息接受者。为了保证网络中的所有实体都能正确的交流，需要有一个共同的标准。</p>
<p>使用 <code>互操作性(Interoperability)</code> 来表示两个实体是否可以无误的彼此通信。</p>
<p>为了保证实体可以正确的彼此交流，他们需要遵守一系列共同的规则，这些规则被称为 <code>通信协议(Communication protocol/Network protocol/Protocol)</code>。</p>
<ol>
<li>在通信发生错误的时候需要采取的行动也是由通信协议来指定。</li>
<li>通信协议可以是底层的，例如电压或信号的制定，也可以高层的，如软件传输的数据类型。</li>
</ol>
<h1 id="Protocol_Suites_And_Layering_Models"><a class="header-anchor" href="#Protocol_Suites_And_Layering_Models">#</a>Protocol Suites And Layering Models</h1>
<p>为了避免重复工作，每个协议应该只负责其他协议未包含的部分，因此协议的制定并非是相互独立的。将一系列合作的协议称为 <code>族(Suites/Families)</code>。族中的每个协议都只关注通信中的一部分，族中的所有协议组合起来就覆盖了整个通信的所有方面。</p>
<p>一个用来将协议分组的基本抽象是 <code>分组模型(Layering model)</code>，分组模型将所有通信问题分为几个部分，每个部分称为 <code>一层(Layer)</code>。将所有协议按层分组帮助协议的设计者和实现者有效的控制了问题的复杂度，因为他们只需要关注与网络的一个方面即可。</p>
<p>下图展示了因特网的分组模型，也成为 TCP/IP 分组模型：</p>
<p><img src="/ch_01_introduction_and_overview/2019-11-22-20-21-21.png" alt="TCP/IP分组模型"></p>
<h2 id="Layer_1_Physical"><a class="header-anchor" href="#Layer_1_Physical">#</a>Layer 1: Physical</h2>
<p>物理层的协议指定了传输媒介和相关硬件的细节。电子相关的属性，频率，信号等都属于物理层。</p>
<h2 id="Layer_2_Network_Interface_MAC"><a class="header-anchor" href="#Layer_2_Network_Interface_MAC">#</a>Layer 2: Network Interface(MAC)</h2>
<p>网络接口层的协议指定了对网络通信的细节以及网络硬件与 Layer3（Internet 层）的通信细节。硬件地址，网络地址，网络可支持的最大包数据以及传输媒介的协议等信息都属于网络接口层。</p>
<p>TCP/IP 的设计者将这一层命名为 <code>网络接口层（Network Interface）</code>，但一些协会更喜欢称为 <code>数据链路层（Data Link）</code>，工业界又喜欢称为 <code>媒介访问控制层（Media Access Control, MAC）</code></p>
<h2 id="Layer_3：Internet"><a class="header-anchor" href="#Layer_3：Internet">#</a>Layer 3：Internet</h2>
<p>因特网层是因特网的基础。因特网地址结构，因特网包的结构，大包拆分成小包的方式，报告错误的方式都属于因特网层。</p>
<h2 id="Layer_4：Transport"><a class="header-anchor" href="#Layer_4：Transport">#</a>Layer 4：Transport</h2>
<p>传输层协议提供了计算机上的一个应用与另一台机器上的应用交流的方法。如接收端接收数据的最大速率，避免网络堵塞的方法，和保证接收端按顺序接收数据的技术都属于传输层。</p>
<h2 id="Layer_5_Application"><a class="header-anchor" href="#Layer_5_Application">#</a>Layer 5: Application</h2>
<p>应用层的协议指定了通过网络交流的应用传输的数据信息的格式和意义，以及需要执行的步骤。如邮件，文件传输，语音电话等的实现都属于应用层。</p>
<h1 id="How_Data_passes_Through_Layers"><a class="header-anchor" href="#How_Data_passes_Through_Layers">#</a>How Data passes Through Layers</h1>
<p>分组模型并不只是为了帮助理解协议，协议的实现满足某一层协议的输出需要匹配相邻层协议的输入。</p>
<p>如下图展示了两台电脑通过网络传输数据的过程：</p>
<p><img src="/ch_01_introduction_and_overview/2019-11-22-20-59-21.png" alt="网络数据传输过程"></p>
<p>一号电脑是数据的发送方，二号电脑是数据的接收方。数据从一号电脑的应用层逐渐向下传递，通过接口层进入网络，在进入网络并传输后，通过二号电脑的接口层传入，再向上逐渐传递到应用层。</p>
<h1 id="Headers_And_Layers"><a class="header-anchor" href="#Headers_And_Layers">#</a>Headers And Layers</h1>
<p>每一层的协议为了保证数据被正确的传递都进行了一些计算。在发送端的每一层中都将一些额外的信息加到了数据包中，对应的，在接受段的每一层中都将解析并移除这些额外的信息。</p>
<p>这些被协议额外加入的数据称为<code>数据头(header)</code>。以发送端为例，数据头是在数据逐层向下的过程中一步步被加入的，即传输层增加一些数据头，网络层增加一些数据头，接口层增加一些数据头。因此最终的数据会如下图所示，最靠近原始数据的数据头是最早被添加的：</p>
<p><img src="/ch_01_introduction_and_overview/2019-11-22-21-08-20.png" alt="网络数据头添加"></p>
<ul>
<li>虽然图中每个被添加的数据头大小看起来相同，但实际上都不是一个固定的大小。</li>
</ul>
<h1 id="ISO_And_The_OSI_Seven_Layer_Reference_Model"><a class="header-anchor" href="#ISO_And_The_OSI_Seven_Layer_Reference_Model">#</a>ISO And The OSI Seven Layer Reference Model</h1>
<p>在因特网模型发展的过程中，有两个组织定义了一个替代的参考模型，称为<code>开放式系统互联参考七层模型(Open Systems Interconnection Seven-Layer Reference Model)</code>，简称为<code>OSI模型</code>。</p>
<p>这两个组织分别是<code>国际标准化组织（International Organization for Standardization）</code>，简称为<code>ISO</code>和<code>国际电信联盟（International Telecommunications Union）(ITU)</code>中的电信标准部门。</p>
<p><code>OSI</code>协议图如下：</p>
<p><img src="/ch_01_introduction_and_overview/2019-11-22-23-01-16.png" alt="OSI协议"></p>
<p>TCP/IP 协议比 OSI 协议更为高效合理，发展和部署 OSI 协议的工作已经被停滞。许多工作者目前在扩展 OSI 协议的定义来让其符合 TCP/IP，基本是让 Network 层匹配 Internet 层，然后再在 Session 层和 Presentation 层增加一些支持协议。</p>
<p>虽然许多工程师和商业部门知道<code>OSI协议</code>不如<code>TCP/IP协议</code>高效，但他们依然处于某些原因在坚持使用。</p>
<h1 id="Remainder_Of_The_Text"><a class="header-anchor" href="#Remainder_Of_The_Text">#</a>Remainder Of The Text</h1>
<p>书的剩下部分将分为五个部分，基本对应与 1.3 节中提到的五个重要领域。</p>
<p>第一部分介绍网络应用和网络编程</p>
<p>第二部分介绍数据通信和信息传输</p>
<p>第三部分介绍分组交换以及包数据，另外也会介绍一些网络的基本分类，如局域网和广域网</p>
<p>第四部分将介绍 TCP/IP 协议族</p>
<p>第五部分介绍剩下的一些网络相关的技术</p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《Head First 设计模式》 Ch 01 策略模式</title>
    <url>/ch_01_the_strategy_pattern/</url>
    <content><![CDATA[<p>策略模式（Strategy Pattern）是使用一些独立的类来各自封装一些通用的算法，这些封装类都继承自同一个接口，该接口定义了算法。对于调用类来说，它只保存一个算法接口的对象，而这个对象所指代的特定算法则可以在运行时动态更改。</p>
<p>例如有我们有一个项目需要描述鸭子，可能有 50 种不同的鸭子都派生自基类 <code>Duck</code>，鸭子一共有三种飞行方式。这时候我们如果将某一种特定的飞行方式写在基类中，则不是使用这个飞行方式的所有派生鸭子都需要对该方法重写。如果我们不在基类中定义，而在各个派生类中实现，则可能多个有相同飞行方式的鸭子派生类都有相同的代码定义飞行方式，这造成了代码冗余。</p>
<p>所以我们可以使用策略模式，将三种飞行方式都派生自接口 <code>FlyBehavior</code>，并在鸭子基类中定义变量<code>FlyBehavior</code>，然后在派生类中选择各自需要的飞行方式即可。</p>
<h1 id="代码示例"><a class="header-anchor" href="#代码示例">#</a>代码示例</h1>
<h2 id="算法接口及实现类"><a class="header-anchor" href="#算法接口及实现类">#</a>算法接口及实现类</h2>
<figure class="highlight cs"><figcaption><span>飞行方法接口</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IFlyBehavior</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Fly</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>飞行方法实现</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FlyNoWay</span> : <span class="title">IFlyBehavior</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fly</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Can not fly&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FlyWithRocket</span> : <span class="title">IFlyBehavior</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fly</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Fly with rocket&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FlyWithWings</span> : <span class="title">IFlyBehavior</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fly</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Fly with wings&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="环境类"><a class="header-anchor" href="#环境类">#</a>环境类</h2>
<figure class="highlight cs"><figcaption><span>鸭子基类</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Duck</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IFlyBehavior flyBehavior;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Duck</span>()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">disPlay</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PerformFly</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        flyBehavior.Fly();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlyBehavior</span>(<span class="params">IFlyBehavior fb</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        flyBehavior = fb;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>鸭子派生类</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BlackDuck</span> : <span class="title">Duck</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BlackDuck</span>() : <span class="title">base</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        setFlyBehavior(<span class="keyword">new</span> FlyWithWings());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">disPlay</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;I am a black duck&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RubberDuck</span> : <span class="title">Duck</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RubberDuck</span>() : <span class="title">base</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        setFlyBehavior(<span class="keyword">new</span> FlyNoWay());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">disPlay</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;I am a rubber duck&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="测试及结果"><a class="header-anchor" href="#测试及结果">#</a>测试及结果</h1>
<figure class="highlight cs"><figcaption><span>测试代码</span></figcaption><table><tr><td class="code"><pre><span class="line">RubberDuck rubberDuck = <span class="keyword">new</span> RubberDuck();</span><br><span class="line">rubberDuck.disPlay();</span><br><span class="line">rubberDuck.PerformFly();</span><br><span class="line"></span><br><span class="line">BlackDuck blackDuck = <span class="keyword">new</span> BlackDuck();</span><br><span class="line">blackDuck.disPlay();</span><br><span class="line">blackDuck.PerformFly();</span><br><span class="line">blackDuck.setFlyBehavior(<span class="keyword">new</span> FlyWithRocket());</span><br><span class="line">blackDuck.PerformFly();</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<p><img src="/ch_01_the_strategy_pattern/2019-01-15-00-12-45.png" alt="策略模式运行结果"></p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>《Code Complete》第一章：欢迎来到软件构建</title>
    <url>/ch_01_welcome_to_software_construction/</url>
    <content><![CDATA[<p>这本书是关于软件<strong>构建</strong>的，构建是建造的过程。在一些语境下，构建过程可能包括规划、设计、检查等部分，但大多情况下“构建”是指创建某些东西时真正动手的那部分。</p>
<h1 id="什么是软件构建？"><a class="header-anchor" href="#什么是软件构建？">#</a>什么是软件构建？</h1>
<p>软件开发是一个复杂的过程，在过去 25 年中，研究人员已经确定了软件开发中的许多不同活动，包括：</p>
<ul>
<li>问题定义</li>
<li>需求开发（创建出需求的过程）</li>
<li>构建规划</li>
<li>软件架构设计</li>
<li>详细设计</li>
<li>编码和调试</li>
<li>单元测试</li>
<li>集成测试</li>
<li>一体化</li>
<li>系统测试</li>
<li>问题修复</li>
</ul>
<p>如果你之前经历的项目流程不太正式，你可能会<em>觉得</em>上述这些活动是繁文缛节。而如果你之前经历的项目流程很正规，你就会<em>知道</em>上述的这些活动确实是繁文缛节。上述这些活动，完全不遵守或完全遵守都是不合适的，你需要找到其中的平衡点。无疑，这很难。</p>
<p>上述流程中，只有一部分属于<strong>构建</strong>，管理、需求开发、软件架构、UI 设计，系统测试和维护这些都不属于构建。构建设计范围如下所示，其中被黄色覆盖的部分才是与构建相关的工作：<br>
<img src="/ch_01_welcome_to_software_construction/image-20230916104532.png" alt="构建"></p>
<p>以下是构建时涉及的具体任务：</p>
<ul>
<li>验证前序任务（如需求开发，架构设计等）是否已经完成，以便后续能够顺利执行</li>
<li>确定如何测试代码</li>
<li>设计和编写类与调用时序</li>
<li>创建和命名变量/常量</li>
<li>选择控制结构并组织代码语句</li>
<li>单元测试，集成测试和调试自己的代码</li>
<li>审阅其他成员的设计和代码，并让他们审阅你的设计的和代码</li>
<li>通过格式化和注释来完善代码</li>
<li>将创建出来的代码组件集成到系统中</li>
<li>优化代码，让其更快和使用更少的资源</li>
</ul>
<h1 id="为什么软件构建很重要"><a class="header-anchor" href="#为什么软件构建很重要">#</a>为什么软件构建很重要</h1>
<p>构建是软件开发的重要组成部分。根据项目的规模，构建通常占项目总时间的 30% 到 80%。任何占用如此多项目时间的事情必然会影响项目的成功。</p>
<p>构建是软件开发的核心活动。需求和架构在构建前完成，以便你可以有效地进行构建。系统测试（严格意义上的独立测试）是在构建后进行的，以验证构建是否正确完成。</p>
<p>构建的产品，即源代码，通常是对软件的唯一准确描述。在许多项目中，程序员唯一可用的文档就是代码本身。需求规范和设计文档可能会过时，但源代码始终是最新的。因此，源代码必须具有尽可能高的质量。</p>
<p>构建是唯一可以保证软件开发完成的活动。</p>
<ul>
<li>理想的软件项目在施工开始之前会经过仔细的需求开发和架构设计。</li>
<li>理想的项目在施工后经过全面的、统计控制的系统测试。</li>
<li>不完美的现实项目常常会跳过需求和设计而直接进入施工阶段。但无论一个项目多么仓促或计划多么糟糕，你都不能放弃建设；</li>
</ul>
<p>归根结底，程序员对如何进行构造的理解决定了它是否一名优秀的程序员，这就是本书其余部分的主题。</p>
]]></content>
      <tags>
        <tag>系统设计</tag>
        <tag>工程实践</tag>
      </tags>
  </entry>
  <entry>
    <title>《Code Complete》第二章：丰富软件开发理解的隐喻</title>
    <url>/ch_02_metaphors_for_a_richer_understanding_of_software_development/</url>
    <content><![CDATA[<p>计算机科学拥有在所有领域中最丰富多彩的语言，在计算机科学中，我们会听到诸如 “病毒”，“特洛伊木马”，“蠕虫”，“崩溃” 等一系列看似与计算机无直接关系的词汇。</p>
<p>这些词汇都是隐喻，它们描述了特定的软件现象。生动的隐喻可以帮助人们增加对软件开发过程的理解。</p>
<div class="note info simple"><p>这里提到的 “隐喻（比喻）” 和 “类比” 在语境上极为类似，本节中可以将两者视为一物。</p>
</div>
<h1 id="隐喻的重要性"><a class="header-anchor" href="#隐喻的重要性">#</a>隐喻的重要性</h1>
<p>重要的发展往往时从类比中产生的。通过将不了解的主题与更了解的主题进行比较，你就可以得出一定的见解，从而更好的理解不熟悉的主题。这种隐喻被称作为 “建模”。</p>
<div class="note icon-padding simple"><i class="note-icon fas fa-quote-left"></i><p>当我们需要在许多不同的选项中进行选择时，模型会很有帮助。它们让我们想象不同的场景，以便选出最佳的一个。<br>
———— <a href="/tan_lan_de_duo_ba_an">《贪婪的多巴胺》 摘抄</a></p>
</div>
<p>科学史上充满了基于利用隐喻力量的发现：</p>
<ul>
<li>化学家凯库勒做了一个梦，梦中他看到一条蛇用嘴叼着尾巴。当他醒来时，他意识到基于类似环状形状的分子结构可以解释苯的性质，进一步的实验证实了这一假设。</li>
<li>气体动力学理论基于“台球”模型。人们认为气体分子具有质量并且可以弹性碰撞，就像台球一样，并且从这个模型中得出了许多有用的定理。</li>
<li>光的波动理论主要是通过探索光和声音之间的相似性而发展起来的。光和声音具有振幅（亮度、响度）、频率（颜色、音调）和其他共同属性。声音和光的波动理论之间的比较非常富有成效，以至于科学家们花费了大量的精力来寻找一种能够像空气传播声音一样传播光的介质。他们甚至给它起了一个名字——“以太”——但他们从未找到这种媒介。</li>
</ul>
<div class="note warning simple"><p>从 “以太” 的示例可以看出，隐喻在有些时候是具有误导性的。</p>
</div>
<div class="note icon-padding simple"><i class="note-icon fas fa-quote-left"></i><p>隐喻的价值不应该被低估。隐喻可以提供让所有人都能理解的预期行为。减少不必要的沟通和误解。让学习和教育的过程更快。实际上，隐喻是一种内化和抽象概念的方式，让人的思维处于更高的层次，避免低级的错误。<br>
—— Fernando J. Corbató（1990 年图灵奖得主）</p>
</div>
<p>人们很容易轻视隐喻的力量。对于前面的例子，人们可能会本能的做出反应是：“嗯，正确的隐喻当然有用，但也有错误的隐喻。”但科学史并不是一系列从“错误”隐喻到“正确”隐喻的转换，而是从“糟糕”的隐喻到“更好”的隐喻、从包容性较小到包容性更强、从一个领域的暗示性到另一个领域的暗示性等一系列变化。</p>
<p>而且，很多模型在被更好的模型替代后仍然有用。比如从理论上上，牛顿力学已经被爱因斯坦理论取代，但工程师们仍然使用牛顿力学来解决大部分工程问题。</p>
<p>与大多数其他科学相比，软件开发是一个年轻的领域，它还不够成熟，没有一套标准的隐喻。因此，它有大量互补和冲突的隐喻。有些比其他更好。有些更糟。你对隐喻的理解程度决定了你对软件开发的理解程度。</p>
<div class="note info simple"><p>设计模式一定程度上，也是隐喻</p>
</div>
<h1 id="如何使用软件隐喻"><a class="header-anchor" href="#如何使用软件隐喻">#</a>如何使用软件隐喻</h1>
<p>软件隐喻更像是探照灯而不是路线图。它不会告诉你在哪里可以找到答案，它只是告诉如何找到答案。隐喻更像是一种启发式方法，而不是一种算法。</p>
<p>算法是一组用于执行特定任务的明确定义的指令。算法是可预测的、确定性的，并且不受偶然性的影响。算法会告诉你如何从 A 点到 B 点：不走弯路，不绕道到 D、E 和 F 点。</p>
<p>启发式是一种帮助您寻找答案的技术。其结果可能会受到偶然性的影响，因为启发式方法只告诉您如何查看，而不是告诉您要查找什么。它不会告诉你如何从 A 点直接到达 B 点；它甚至可能不知道 A 点和 B 点在哪里。</p>
<p>以驾车前往某人家为例子：</p>
<ul>
<li>算法：沿 167 号高速公路向南行驶至皮阿拉普 (Puyallup)。从 South Hill Mall 出口驶出，驾车 4.5 英里上山。在杂货店旁的红绿灯处右转，然后在第一个路口左转。转入左侧大棕褐色房屋的车道，地址为 714 North Cedar</li>
<li>启发式方法：找到我们寄给您的最后一封信。开车前往回程地址所在的城镇。当你到达城里时，问问别人我们的房子在哪里。每个人都认识我们——有人会很乐意为您提供帮助。如果您找不到任何人，请使用公用电话给我们打电话，我们会来找您。</li>
</ul>
<p>使用隐喻可以帮助你深入了解编程中的问题和流程。使用它们来帮助你思考编程活动并帮助你构想更好的做事方式。随着时间的推移，使用隐喻来阐明软件开发过程的人将被认为比不使用隐喻的人更了解编程并更快地生成更好的代码。</p>
<div class="note info simple"><p>比如你可以通过“设计模式”这个隐喻：<br>
“这段代码核心思想是<a href="/ch_06_the_command_pattern">命令模式</a>，但 xxx 和 xxx 与命令模式定义的有所不同” 。这样，阅读代码的人如果了解命令模式，那么他需要关注的点，就一下子从整个代码设计变为只有 xxx</p>
</div>
<h1 id="常见软件开发隐喻"><a class="header-anchor" href="#常见软件开发隐喻">#</a>常见软件开发隐喻</h1>
<p>有许多不同的隐喻来形容软件开发的过程，有认为它是“写作的”，有认为它是 “种植的”，有认为是 “建造的“ 等等。这一节就是来分析这些隐喻哪个更好。</p>
<h2 id="写作"><a class="header-anchor" href="#写作">#</a>写作</h2>
<p>软件开发最原始的比喻源于“写代码”这一表达，将开发看作是一种写作。</p>
<p>写作比喻表明，开发一个程序就像写一封随意的信——你坐下来，拿着笔、墨水和纸，从头到尾写下来。它不需要任何正式的计划，你可以边走边想出你想说什么。</p>
<p>对于个人或小型项目，写作的比喻是有效的，但对于大型项目而言，则不够合适。</p>
<ul>
<li>写作通常是一项单人活动，而软件项目则很可能设计许多承担不同责任的人。</li>
<li>当你写完一封信后，你将其放入信封并邮寄，这件活动就完成了，你不会也无法再修改它。而对于软件而言，典型的软件系统多达 90% 的开发工作是在初始版本发布后完成的。</li>
<li>写作中，原创性非常重要。但在软件构件中，重用则非常重要。</li>
</ul>
<p>但不幸的是，在《人月神话》中，作者说”计划扔掉一份代码，无论如何，你会的“。这就让人想起写了一半的草稿纸被扔进废纸篓的画面。<br>
<img src="/ch_02_metaphors_for_a_richer_understanding_of_software_development/image-20230916115212.png" alt="草稿纸和废纸篓"></p>
<p>所以《人月神话》一定程度上加强了程序员将软件视作”写作“的可能。但写作被丢掉的成本很低（当你向你的阿姨写一份问候信，当你觉得不合适，你可以随时重新写一份），但软件开发的成本则极高。</p>
<h2 id="种植"><a class="header-anchor" href="#种植">#</a>种植</h2>
<p>一些软件开发人员表示，您应该将创建软件想象成<strong>种植农作物</strong>。设计一个片段，编写一个片段，测试一个片段，然后一次一点地将其添加到系统中。通过采取小步骤，你可以最大限度地减少随时可能遇到的麻烦。</p>
<p>但这个比喻实际上很糟糕，虽然“一次做一点”的想法和农务缓慢生长的方式有一点点类似，但也很难将农业的主要特征概括为“一次只做一点事”。</p>
<ul>
<li>农业上可以通过土地管理来增加产量（让土地休息一年增加土中的氮含量），但很难说让硬盘工作一年，以生成更多的代码。</li>
<li>种植的比喻还隐含着“开发者对开发结果没有直接控制权”的意思。程序员无法在春天种下代码种子，然后在秋天获得丰富的代码。</li>
</ul>
<h2 id="生长"><a class="header-anchor" href="#生长">#</a>生长</h2>
<p>将软件的构建隐喻为生长（Growing），可以替代之前的种植隐喻。</p>
<p>在增量开发中，你可以先制作一个可运行的最简系统。它不必接受真实的输入，不必对数据执行真实的操作，也不必产生真实的输出——它只需要成为一个足够强大的骨架，能够在开发时支撑真实的系统。这个基本的开始就像牡蛎中未来会增生为珍珠的小沙粒。</p>
<p>形成骨架后，逐渐放置肌肉和皮肤。将每个虚拟类更改为真实类，将虚假的输入改成真实的输入，将虚假的输出改成真实的输出。你一次添加一点代码，直到拥有一个完全工作的系统。</p>
<h2 id="建造"><a class="header-anchor" href="#建造">#</a>建造</h2>
<p>建造（ Building）比前面的写作和生长更合适，它与增长的理念兼容（建造也是一点点建造的），并提供了更详细的指导。构建意味着规划、准备和执行的各个阶段，这些阶段的种类和程度取决于所构建的内容。当你探索这个比喻时，你会发现许多其他相似之处。</p>
<h3 id="制造过程的类似"><a class="header-anchor" href="#制造过程的类似">#</a>制造过程的类似</h3>
<p>如果你要建造的是一个简单结构（比如狗舍），你去买一些木材和钉子，花一下午的时间，就能做出来。</p>
<p>但如果你要建的是房屋，那建造过程会更加复杂</p>
<ul>
<li>你必须决定你想要建造什么样的房子：与软件开发中的问题定义类似</li>
<li>你和建筑师必须提出总体设计并获得批准：与软件架构设计类似</li>
<li>你需要绘制详细的蓝图并雇用承包商：与详细的软件设计类似</li>
<li>准备好建筑工地，打好地基，搭建房屋框架，放置壁板和屋顶，然后安装管道和电线：与软件构建类似</li>
<li>当房子的大部分完工后，园林设计师、油漆工和装饰师就会进来，充分利用你的财产和你建造的房屋：与软件优化类似</li>
<li>在整个过程中，各种检查人员都会来检查场地、基础、框架、布线和其他检查项：与软件审查和测试类似</li>
</ul>
<h3 id="重来的成本"><a class="header-anchor" href="#重来的成本">#</a>重来的成本</h3>
<p>如果你忘了给狗舍做门，或者犯了一些其他错误，这不是啥大问题。你可以尝试去修复，大不了重头再来，你浪费的只不过是一下午的时间和一点钱。这与写小型软件非常类似，如果你写了 1000 行代码后发现对需求的理解错误，或用了错误的设计，你可以重构或直接重写，影响都不是太大。</p>
<p>但更大的复杂性和规模意味着这两项活动的后果更大：</p>
<ul>
<li>建房子，材料有些贵，但最主要的支出是人工。拆掉一堵墙并将其移动六英寸是昂贵的，不是因为你浪费了很多钉子，而是因为你必须向人们支付移动墙所需的额外时间。</li>
<li>在构建软件产品时，材料甚至更便宜（电脑和键盘），但劳动力成本同样高。</li>
</ul>
<h3 id="重用"><a class="header-anchor" href="#重用">#</a>重用</h3>
<p>在建造房屋时，你不会尝试建造可以购买的已经建成的东西：除非你是一个机械天才，不然你肯定会选择买现成的冰箱，而不是自己造一个。</p>
<ul>
<li>如果你正在构建软件系统，你也会做同样的事情。你将广泛使用高级语言功能，而不是编写自己的操作系统级代码。你还会使用各种已经构建的帮助类。</li>
</ul>
<p>如果您要建造一座配有一流家具的豪华房屋，你可能会定制橱柜，或定制不同寻常形状和尺寸的窗户</p>
<ul>
<li>这种定制与软件开发有相似之处。如果你正在构建一流的软件产品，你可能会构建自己的帮助类或底层库以获得更好的速度或准确性</li>
</ul>
<h3 id="规划"><a class="header-anchor" href="#规划">#</a>规划</h3>
<p>建筑施工和软件建设都受益于适当水平的规划。如果以错误的顺序构建软件，则很难编码、测试和调试。它可能需要更长的时间才能完成，或者项目可能会崩溃。因为每个模块都太复杂，因此当他们组合在一起时，可能会出现混乱。</p>
<p>周密的计划并不一定意味着详尽的计划或过度计划。你可以规划结构支撑，然后决定是否铺硬木地板或地毯、墙壁涂什么颜色、使用什么屋顶材料等等。</p>
<ul>
<li>一个精心计划的项目可以提高你以后改变对细节的想法的能力。</li>
<li>你对正在构建的软件类型的经验越多，你就越能理所应当的确认某些细节。</li>
</ul>
<h3 id="规格"><a class="header-anchor" href="#规格">#</a>规格</h3>
<p>在建筑过程中，如果你要建造仓库或工具棚，与建造医疗中心或核反应堆相比，你会使用不同级别的规划。</p>
<p>在软件中，你通常可能使用灵活的、轻量级的开发方法，但有时你需要严格的、重量级的方法来实现要求更高的软件。</p>
<h3 id="功能的重要性"><a class="header-anchor" href="#功能的重要性">#</a>功能的重要性</h3>
<p>如果墙壁是承重的，那么将墙壁移动六英寸的成本会比它只是房间之间的隔断要高。同样，在程序中进行架构更改比添加或删除需求功能的成本更高。</p>
<h3 id="额外预算"><a class="header-anchor" href="#额外预算">#</a>额外预算</h3>
<p>由于超大型结构的失效后果非常严重，因此必须对结构进行过度设计。如同建筑商仔细制定和检查他们的计划。它们建立了安全边际；多花 10% 的钱购买更坚固的材料，这总比让摩天大楼倒塌要好。</p>
<h2 id="工具箱"><a class="header-anchor" href="#工具箱">#</a>工具箱</h2>
<p>还有一种好隐喻，是不将技术视为规则，而视为分析工具：</p>
<ul>
<li>一个好的工匠知道适合工作的正确工具，并且知道如何正确使用它。</li>
<li>程序员也是如此。你对编程了解得越多，你的工具箱就越充满分析工具，你就越知道何时使用它们，以及如何正确的使用它们。</li>
</ul>
<p>在软件领域，有时候有人会告诉只使用某种软件方法，而排除其他方法。但如果你 100% 相信任何一种方法，你就会通过该方法来看待整个世界。在某些情况下，你会错过使用更适合你当前问题的方法。就如同如果你只拿着锤子，你可能会错误的将螺丝当成钉子。</p>
<p>工具箱比喻有助于正确看待所有方法、技术和技巧，以便在适当的时候使用。</p>
<h2 id="结合隐喻"><a class="header-anchor" href="#结合隐喻">#</a>结合隐喻</h2>
<p>因为隐喻是启发式的而不是算法式的，所以它们并不相互排斥。你可以使用任何能够激发你自己或团队内其他人思考的隐喻或隐喻的组合。</p>
<p>使用隐喻是一件模糊的事情。你必须扩展它们才能从它们提供的启发式见解中受益。但如果你把它们延伸得太远或方向错误，它们就会误导你，正如你可以滥用任何强大的工具一样。</p>
]]></content>
      <tags>
        <tag>系统设计</tag>
        <tag>工程实践</tag>
      </tags>
  </entry>
  <entry>
    <title>《Head First 设计模式》 Ch 02 观察者模式</title>
    <url>/ch_02_the_observer_pattern/</url>
    <content><![CDATA[<p>观察者模式（Observer Pattern）定义了一种一对多的依赖关系，当被观察者（<code>Subject</code>）的状态发生变化时，它将会通知观察者们（<code>Observers</code>）进行某种操作。</p>
<p>例如我们希望定义温度计和压力计，在天气信息发生变化时自动更新，而非自己反复的查询是否天气信息有发生变化。这里天气信息就是被观察者，而温度计和压力计就是观察者。</p>
<h1 id="代码示例"><a class="header-anchor" href="#代码示例">#</a>代码示例</h1>
<h2 id="观察者及被观察者接口"><a class="header-anchor" href="#观察者及被观察者接口">#</a>观察者及被观察者接口</h2>
<figure class="highlight cs"><figcaption><span>被观察者</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ISubject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RegisterObserver</span>(<span class="params">IObserver observer</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">UnregisterObserver</span>(<span class="params">IObserver observer</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NotifyObservers</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>观察者</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IObserver</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params">ISubject subject</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="观察者实现"><a class="header-anchor" href="#观察者实现">#</a>观察者实现</h2>
<figure class="highlight cs"><figcaption><span>温度计</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TemperatureObserver</span> : <span class="title">IObserver</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> ISubject subject;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TemperatureObserver</span>(<span class="params">ISubject subject</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">        <span class="keyword">this</span>.subject.RegisterObserver(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params">ISubject subject</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        WeatherData weatherData = subject <span class="keyword">as</span> WeatherData;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注意这里我们是从主动从被观察者那里去获取数据</span></span><br><span class="line">        <span class="keyword">if</span> (weatherData != <span class="literal">null</span>)</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Temperature is &quot;</span> + weatherData.Temperature);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>压力计</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PressureObserver</span> : <span class="title">IObserver</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> ISubject subject;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PressureObserver</span>(<span class="params">ISubject subject</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">        <span class="keyword">this</span>.subject.RegisterObserver(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params">ISubject subject</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        WeatherData weatherData = subject <span class="keyword">as</span> WeatherData;</span><br><span class="line">        <span class="keyword">if</span> (weatherData != <span class="literal">null</span>)</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Pressure is &quot;</span> + weatherData.Pressure);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="被观察者实现"><a class="header-anchor" href="#被观察者实现">#</a>被观察者实现</h2>
<figure class="highlight cs"><figcaption><span>天气数据</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WeatherData</span> : <span class="title">ISubject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;IObserver&gt; observersList;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> Temperature &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> Humidity &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> Pressure &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeatherData</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        observersList = <span class="keyword">new</span> List&lt;IObserver&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">NotifyObservers</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        observersList.ForEach(o =&gt; o.Update(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RegisterObserver</span>(<span class="params">IObserver o</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        observersList.Add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UnregisterObserver</span>(<span class="params">IObserver o</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        observersList.Remove(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">measurementsChanged</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        NotifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetMeasurements</span>(<span class="params"><span class="built_in">float</span> temperature, <span class="built_in">float</span> humidity, <span class="built_in">float</span> pressure</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.Temperature = temperature;</span><br><span class="line">        <span class="keyword">this</span>.Humidity = humidity;</span><br><span class="line">        <span class="keyword">this</span>.Pressure = pressure;</span><br><span class="line">        measurementsChanged();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="测试及结果"><a class="header-anchor" href="#测试及结果">#</a>测试及结果</h1>
<figure class="highlight cs"><figcaption><span>测试代码</span></figcaption><table><tr><td class="code"><pre><span class="line">WeatherData weatherData = <span class="keyword">new</span> WeatherData();</span><br><span class="line">TemperatureObserver temperatureObserver = <span class="keyword">new</span> TemperatureObserver(weatherData);</span><br><span class="line">PressureObserver pressureObserver = <span class="keyword">new</span> PressureObserver(weatherData);</span><br><span class="line"></span><br><span class="line">weatherData.SetMeasurements(<span class="number">30</span>, <span class="number">20</span>, <span class="number">10</span>);</span><br><span class="line">weatherData.SetMeasurements(<span class="number">20</span>, <span class="number">40</span>, <span class="number">5</span>);</span><br><span class="line">weatherData.UnregisterObserver(temperatureObserver);</span><br><span class="line">weatherData.SetMeasurements(<span class="number">10</span>, <span class="number">50</span>, <span class="number">15</span>);</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/ch_02_the_observer_pattern/2019-01-15-23-20-09.png" alt="观察者模式运行结果"></p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>《Code Complete》 架构检查清单</title>
    <url>/ch_03_architecture_checklist/</url>
    <content><![CDATA[<p>以下是一个好的架构应该解决的问题列表。该列表并不是要成为架构的综合指南，而是一种实用的方式来评估程序员获得的内容是否足够有营养。</p>
<p>使用此清单作为起点。与<a href="/ch_03_requirement_checklist">需求清单</a> 一样，如果你正在处理一个非正式项目，你会发现一些甚至不需要考虑的项目。如果你正在从事一个较大的项目，那么大多数项目都会很有用。</p>
<h2 id="具体的架构主题"><a class="header-anchor" href="#具体的架构主题">#</a>具体的架构主题</h2>
<ul>
<li>[ ] 程序的整体组织是否清晰，包括良好的架构概述和理由？</li>
<li>[ ] 主要构建模块是否明确定义，包括其职责范围以及与其他构建模块的接口？</li>
<li>[ ] 需求列表中的需求，是否都能合理的被架构中的模块覆盖？即不会有太多的模块需要因为一个需求而改动的情况，也不会有所有需求集中在一个模块内的情况出现。</li>
<li>[ ] 架构中最关键的类是否被合理的描述，且证明了其合理性？</li>
<li>[ ] 数据的设计是否得到了描述，并证明了其合理性？</li>
<li>[ ] 数据库之间的组织关系是否有被定义？</li>
<li>[ ] 是否所有关键的业务规则都有被定义，且说明了它们对系统的影响？</li>
<li>[ ] 是否描述了针对 UI 设计的策略？</li>
<li>[ ] UI 部分是否模块化，以便它不会影响程序的其他部分？</li>
<li>[ ] 是否描述了处理 IO 的策略，并证明了其合理性？</li>
<li>[ ] 是否对线程，数据库访问，句柄，网络带宽等稀缺资源描述了使用估计和资源管理策略，并证明了其合理性？</li>
<li>[ ] 架构是否描述了对安全性的要求？</li>
<li>[ ] 架构是否为每个类，每个子系统和每个功能都设置了空间和时间的预算？</li>
<li>[ ] 架构是否描述了如何实现可拓展性？</li>
<li>[ ] 架构是否解决了互操作性问题（其他软件/硬件共享的资源）？</li>
<li>[ ] 架构是否描述了本地化策略</li>
<li>[ ] 架构是否提供了一致的错误处理策略？</li>
<li>[ ] 架构是否定义了容错方法？</li>
<li>[ ] 系统中所有部分技术可行性是否已经确认？</li>
<li>[ ] 架构中是否有足够的饱和设计？</li>
<li>[ ] 架构是否有 购买/构建 的决策说明？</li>
<li>[ ] 架构是否有描述如何重用代码以符合其他的架构目标</li>
<li>[ ] 当前架构是否能够适应可能的变化</li>
</ul>
<h2 id="通用架构质量"><a class="header-anchor" href="#通用架构质量">#</a>通用架构质量</h2>
<ul>
<li>[ ] 架构是否考虑了所有的需求？</li>
<li>[ ] 架构中是否存在过度或不足的设计，是否有明确描述这些区域的期望？</li>
<li>[ ] 整个架构在概念上是否一致？</li>
<li>[ ] 顶层设计是否可以独立于硬件和语言？</li>
<li>[ ] 是否描述了架构中所有重大决策的动机？</li>
<li>[ ] 作为要实现该系统的程序员，你对架构是否满意？</li>
</ul>
]]></content>
      <tags>
        <tag>系统设计</tag>
        <tag>工程实践</tag>
      </tags>
  </entry>
  <entry>
    <title>《Code Complete》第三章：测量两次，切割一次——前期准备</title>
    <url>/ch_03_measure_twice,_cut_once_upstream_prerequisites/</url>
    <content><![CDATA[<p>与建筑施工一样，项目的成败很大程度上在施工开始前就已经确定。如果地基没有打好或者规划不充分，施工期间你能做的最好的事情就是将损害降到最低。</p>
<p>木匠的名言“测量两次，切割一次”，与软件开发的构建部分高度相关。</p>
<p>最糟糕的软件项目最终会进行两次或三次或更多次的构建。对于软件来说，将项目中最昂贵的部分做两次是一个糟糕的主意，就像在任何其他工作中一样。</p>
<h1 id="3_1_前期工作的重要性"><a class="header-anchor" href="#3_1_前期工作的重要性">#</a>3.1 前期工作的重要性</h1>
<p>如果在项目结束时才开始强调质量，那么你就会关心系统测试。当许多人想到如何确保软件质量时，他们首先想到的是测试。然而，测试只是完整质量保证策略的一部分，而且不是最有影响力的部分。</p>
<ul>
<li>测试无法发现根本性的缺陷，例如构建错误的产品或以错误的方式构建正确的产品。这些缺陷必须在测试之前（施工开始之前）得到解决。</li>
</ul>
<p>如果你在项目中期强调质量，那么被强调的就会是构建的过程。本书中中的绝大部分内容都是关于构建的。</p>
<p>如果你在项目开始时就强调质量，你就会在定义问题，设计解决方案时进行相应的规划。—— 关注先决条件</p>
<p>由于构建处于项目的中期，所以当你开始构建时，项目的前期工作已经为成功或失败奠定了一些基础。</p>
<h2 id="先决条件适用于现代软件项目吗？"><a class="header-anchor" href="#先决条件适用于现代软件项目吗？">#</a>先决条件适用于现代软件项目吗？</h2>
<p>准备工作的首要目标是降低风险：优秀的项目规划者尽早消除主要风险，以便项目的大部分工作能够尽可能顺利地进行。到目前为止，软件开发中最常见的项目风险是不良需求和不良项目规划，因此准备工作往往侧重于改进需求和项目计划。</p>
<div class="note icon-padding simple"><i class="note-icon fas fa-quote-left"></i><p>所使用的方法应该基于选择最新和最好的方法，而不是基于无知。它还应该与旧的和可靠的东西自由搭配。<br>
—— <a href="https://en.wikipedia.org/wiki/Harlan_Mills">Harlan Mills</a></p>
</div>
<h2 id="准备不充分的原因"><a class="header-anchor" href="#准备不充分的原因">#</a>准备不充分的原因</h2>
<p>准备不充分的一个常见原因是被分配从事前期工作的开发人员不具备执行相应任务的专业知识。项目规划、开发需求，创建架构所需要的技能绝不是琐碎的零散知识，大多数开发者都从未接受过如何执行这些活动的培训。当开发人员不知道如何做前期准备，那么&quot;做更多前期准备&quot;的建议听起来就像是无稽之谈。</p>
<p>有些程序员确实知道如何执行上游活动，但他们没有做好准备，因为他们无法抗拒尽快开始编码的冲动。</p>
<p>程序员不做好准备的最后一个原因是，项目经理们对花时间构建先决条件的程序员缺乏同情心，这是很普遍的。这种现象被称为 WISCA 或 WIMP 综合症：Why Isn’t Sam Coding Anything? or Why Isn’t Mary Programming?</p>
<p>如果你的项目经理命令你立即开始编码，那么你很容易说：“是的，先生！” （有什么坏处？这个老家伙肯定知道他在说什么）但这是一个不好的回应，你还有几个更好的选择：</p>
<ul>
<li>第一个选择：断然拒绝以无效的顺序进行工作（你需要保证你和领导的情感账户充裕）</li>
<li>第二个选择：假装在编码，而实际上你没有编码。将代码库放在一边，然后继续开发你的需求和架构，无论是否得到老板的批准。你最终都会更快地完成项目并获得更高质量的结果。有些人认为这种做法在道德上是令人反感的，但从你老板的角度来看，无知就是幸福。</li>
<li>第三个选择：你可以让你的老板了解技术项目的细微差别。这是一个很好的方法，因为它增加了世界上开明老板的数量。</li>
</ul>
<h1 id="3_2_确认开发的软件方式"><a class="header-anchor" href="#3_2_确认开发的软件方式">#</a>3.2 确认开发的软件方式</h1>
<p>有两种软件开发的方式：</p>
<ul>
<li>顺序方式：整个项目按照，先进行需求构建，再架构设计，再细节设计，再构建，最后系统测试和质量验收的方式进行。<br>
<img src="/ch_03_measure_twice,_cut_once_upstream_prerequisites/image-20230917150201.png" alt="顺序方式时间表"></li>
<li>迭代方式：整个项目在进行过程中，经过反复的迭代，每一个迭代中都有上述的项目流程。<br>
<img src="/ch_03_measure_twice,_cut_once_upstream_prerequisites/image-20230917150221.png" alt="迭代方式时间表"></li>
</ul>
<h2 id="迭代方式对先决条件的影响"><a class="header-anchor" href="#迭代方式对先决条件的影响">#</a>迭代方式对先决条件的影响</h2>
<p>一些人声称，使用迭代的项目根本不需要过多关注前期准备，但这种观点是错误的。迭代方法往往会减少上游工作不足的影响，但并不能消除它。</p>
<h2 id="在迭代方式和顺序方式之间选择"><a class="header-anchor" href="#在迭代方式和顺序方式之间选择">#</a>在迭代方式和顺序方式之间选择</h2>
<p>当以下情况下，你可以选择顺序方式：</p>
<ul>
<li>需求相当稳定</li>
<li>设计非常简单并且很好理解</li>
<li>开发团队熟悉应用领域</li>
<li>项目风险很小</li>
<li>长期可预测性很重要(因为迭代会导致预期一直在变化)</li>
<li>更改下游需求、设计和代码的成本可能很高（这样的话，在迭代中变更需求成本就很大）</li>
</ul>
<p>当以下情况时，你可以选择迭代性的方法：</p>
<ul>
<li>需求没有被很好地理解，或者它们由于其他原因而不稳定</li>
<li>设计是复杂的、具有挑战性的，或者两者兼而有之</li>
<li>开发团队不熟悉应用领域</li>
<li>该项目存在很大的风险</li>
<li>长期的可预测性并不重要</li>
<li>更改下游需求、设计和代码的成本可能很低</li>
</ul>
<p>有些项目在先决条件上花费的时间太少，这使施工面临不必要的高频率的不稳定变化，并阻止项目取得持续进展。<br>
有些项目前期做了太多事情，且当后续实施时发现了计划失效时，还顽固的遵守之前的要求和计划，这也可能阻碍施工进度。</p>
<h1 id="3_3_前期准备：问题定义"><a class="header-anchor" href="#3_3_前期准备：问题定义">#</a>3.3 前期准备：问题定义</h1>
<p>在开始构建之前，你需要满足的第一个先决条件是明确说明系统要解决的问题。这有时称为“产品愿景”、“愿景声明”、“使命声明”或“产品定义”。这里称为“问题定义”。</p>
<p>由于本书是关于构建的，因此本节不会告诉你如何编写问题定义，而是告诉你如何识别一个问题的是否已经被定义，以及所写的内容是否会为构建奠定良好的基础。</p>
<div class="note icon-padding simple"><i class="note-icon fas fa-quote-left"></i><p>如果“盒子”是约束和条件的边界，那么诀窍就是找到盒子……不要跳出它思考，你要先找到它。<br>
—— Andy Hunt / Dave Thomas <em>The Pragmatic Programmer</em> 作者</p>
</div>
<p>问题定义定义了问题是什么，但不需要提及任何可能的解决方案</p>
<ul>
<li>“我们无法跟上 Gigatron 的订单”这句话听起来像是一个问题，也是一个很好的问题定义</li>
<li>“我们需要优化我们的自动数据输入系统以跟上 Gigatron 的订单”这一说法是一个糟糕的问题定义（它指明了解决方案，而限制了思考）</li>
</ul>
<p>问题定义应该用用户语言，并且应该从用户的角度描述问题。通常不应该用计算机技术术语来表述。最好的解决方案可能不是计算机程序。</p>
<p>假设您需要一份显示你的年利润的报告，你已经有了显示季度利润的工具：</p>
<ul>
<li>如果你陷入了程序员的思维模式，你会认为向已经提供季度报告的系统添加年度报告应该很容易。然后，你将付钱给程序员来编写和调试一个计算年利润的耗时程序。</li>
<li>如果你没有陷入程序员的思维模式，你可以付钱给你的秘书，让他花一分钟在计算器上将季度数据相加来创建年度数据。</li>
</ul>
<p>未能定义问题的代价是你可能会浪费大量时间来解决错误的问题。这是双重惩罚，因为你也没有解决正确的问题。</p>
<h1 id="3_4_前期准备：需求"><a class="header-anchor" href="#3_4_前期准备：需求">#</a>3.4 前期准备：需求</h1>
<p>需求详细描述了软件系统应该做什么，它们是解决方案的第一步。需求活动也称为“需求开发”、“需求分析”。</p>
<h2 id="为什么需要正式需求"><a class="header-anchor" href="#为什么需要正式需求">#</a>为什么需要正式需求</h2>
<p>明确的需求有助于确保是用户而不是程序员驱动最后的功能产生。</p>
<p>如果需求明确，普通用户可以查看并给出意见。而如果需求不明确，程序员通常会在编程过程中做出需求决策，这可能与用户想要的不一致，明确的需求让程序员不需要猜测用户想要什么。</p>
<p>明确的要求也有助于避免争论。在开始编程之前，你需要决定功能的范围，如果您与其他程序员对于程序应该做什么有分歧，可以通过查看需求来解决。</p>
<p>关注需求有助于最大限度地减少开发开始后对系统的更改。如果您在编码过程中发现编码错误，只需更改几行代码即可继续工作。如果在编码过程中发现需求错误，则必须更改设计以满足更改后的需求。</p>
<ul>
<li>在大型项目中，在架构阶段发现需求错误的纠正成本，是在需求阶段检测到需求错误的成本的 3 倍。</li>
<li>如果在编码过程中被检测到，成本会增加到 5 至 10 倍。</li>
<li>系统测试时，则是 10 倍。</li>
<li>在功能发布后，其成本比在需求开发期间检测到的成本高出 10 到 100 倍。。</li>
</ul>
<h2 id="需求稳定的神话"><a class="header-anchor" href="#需求稳定的神话">#</a>需求稳定的神话</h2>
<p>稳定的需求是软件开发的圣杯。有了稳定的需求，项目就可以以有序、可预测和平静的方式从架构到设计、编码到测试。这是软件的天堂。</p>
<div class="note icon-padding simple"><i class="note-icon fas fa-quote-left"></i><p>需求就像水一样。当它们被冷冻时，更容易建造。</p>
</div>
<h2 id="处理施工期间的需求变化"><a class="header-anchor" href="#处理施工期间的需求变化">#</a>处理施工期间的需求变化</h2>
<p>评估需求的质量，如果发现需求的质量不够好，请停止工作。当然，如果你在这个阶段停止编码，感觉就像你在浪费时间。但是，如果你从芝加哥开车前往洛杉矶，当你看到前往纽约的路标时，停下来查看路线图是否是浪费时间？如果你没有朝着正确的方向前进，请停下来检查你的路线。</p>
<p>确保每个人都知道需求变更的成本。当客户想到新功能时会感到兴奋。在兴奋中，他们的血液变稀并流向延髓，他们变得头晕目眩，忘记了所有讨论需求的会议、签字仪式和已完成的需求文件。处理这些沉迷于功能的人的最简单方法是说：“哎呀，这听起来是个好主意。但由于它不在需求文档中，我将制定修订后的时间表和成本估算，以便你可以决定是否要现在或以后这样做。” “日程”和“费用”这两个词比咖啡和冷水澡更能让人清醒，许多“必须有”的需求很快就会变成“可以有”。</p>
<p>当需求变化时，你可以考虑以下的方式：</p>
<ul>
<li>建立一个需求变更的控制程序。改变主意并意识到他们需要更多功能是正常的，但问题是他们的变化太频繁，以至于研发无法跟上需求的变更。</li>
<li>使用适合与需求变化的开发方式：迭代式开发。渐进式交付是一种分阶段交付系统的方法。你可以构建一些，从用户那里获得一些反馈，稍微调整你的设计，在进行一些更改，然后构建更多。关键是使用较短的开发周期，以便你可以快速响应用户。</li>
<li>如果需求特别糟糕或不稳定，并且上述建议均不可行，可以考虑取消该项目</li>
</ul>
<p>密切关注项目的业务问题来源，当你回顾执行该项目的业务原因时，许多需求问题就会消失在眼前：如果你去评估功能可以带来的业务增长时，一些仅从功能角度出发非常好的想法，就可能变为了糟糕的想法。</p>
<p>需求检查清单：<br>
<a href="/ch_03_requirement_checklist">Requirement Checklist</a></p>
<h1 id="3_5_前期准备：架构"><a class="header-anchor" href="#3_5_前期准备：架构">#</a>3.5 前期准备：架构</h1>
<p>软件架构是软件设计的更高层次部分，框架比设计拥有更多的细节。一些人对软件架构和软件设计的区分方法是：架构是系统范围内的设计约束，而设计是子系统或类级别的设计约束。</p>
<p>本书主要是关于构建的，因此本书不会告诉你如何进行软件架构设计，但会关注如何确保架构的质量。</p>
<p>为什么要把架构作为先决条件？因为架构的质量决定了系统概念性上的完整性，而这又决定了系统的最终质量。经过深思熟虑的架构提供了系统从顶层到底层的保持概念完整性所需的结构。它为程序员提供了指导——提供了适合程序员技能水平与当前工作的细节信息。它将工作进行了划分，以便多个开发人员或多个开发团队可以独立工作。</p>
<p>在施工期间或之后进行架构更改的成本很高。修复软件架构中的错误所需的时间与修复需求设计的错误一样，都比简单的修复编码错误所需的时间更长。</p>
<h2 id="典型的架构组成部分"><a class="header-anchor" href="#典型的架构组成部分">#</a>典型的架构组成部分</h2>
<p>以下部分都是一个良好的系统架构应当考虑的部分：</p>
<h3 id="项目结构"><a class="header-anchor" href="#项目结构">#</a>项目结构</h3>
<p>一个系统架构首先需要在广义上描述整个系统。没有这样的概览，你很难从一堆细节和成千上万的类中拼凑出一个连贯的视图。</p>
<p>在架构中，应当体现出已经考虑过整体架构的其他解决方案，并说明使用现在的这个方案而不是其他解决方案的原因。如果架构中一个类的作用没有被清晰的表明，那人们只能沮丧的使用该类进行工作（我知道我应该这么做，但我不能理解这么做的原因）。研究表明，说明一个设计的合理性，和维护这个设计本身一样重要。</p>
<p>一个架构应当定义一个程序的主要组成部分（构建块，Building Block）。根据程序的大小，每一个构建块可以是一个类或者由一系列类构成的子模块。</p>
<p>每一个构建块的内容应当被明确的定义，每一个构建块应当明确自己的责任范围，并且尽可能地少了解其他构建块责任范围。</p>
<p>每个构建块之间的通行规则应当被明确，架构应当描述一个构建块可以直接使用哪些其他构建块，可以间接使用哪些其他构建块，以及不能使用哪些其他构建块。</p>
<h3 id="主要类"><a class="header-anchor" href="#主要类">#</a>主要类</h3>
<p>系统结构应当要说明需要使用的主要类，它应该要确定每个类的主要指责，该类该如何与其他类交互。它应该包括类层次结构、状态转换和对象生命周期的描述。如果系统足够大，还应当描述类是如何构成子系统的。</p>
<p>架构还应当描述它所考虑的其他类设计，以及为什么选择了当前的设计而不是其他设计。</p>
<h3 id="数据设计"><a class="header-anchor" href="#数据设计">#</a>数据设计</h3>
<p>架构应当描述其主要使用的文件和数据结构，且它应当描述替代方案，以及为什么选择了当前的设计而不是其他设计。比如一个应用程序需要维护一系列用户的 ID，架构选择了使用 <code>List</code> 来表示，而不是使用 <code>Set</code>，那么架构应当说明为什么选择了 <code>List</code> 而不是 <code>Set</code>。</p>
<p>数据通常只能由一个子系统或一个类修改，但可以由多个子系统或类读取。架构应当描述哪些类可以修改数据，哪些类可以读取数据。</p>
<h3 id="业务规则"><a class="header-anchor" href="#业务规则">#</a>业务规则</h3>
<p>如果架构依赖于特定的业务规则，则应该标明它们并描述这些规则对系统架构的影响。</p>
<p>例如，系统需要遵循一条业务规则 “客户信息的过期时间不得超过 30 秒”。在这种情况下，应该描述该规则对架构关于“同步用户信息”这部分的设计的影响。</p>
<h3 id="用户界面设计"><a class="header-anchor" href="#用户界面设计">#</a>用户界面设计</h3>
<p>用户的界面设计应当在 <a href="/ch_03_measure_twice,_cut_once_upstream_prerequisites/#3_4_%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87%EF%BC%9A%E9%9C%80%E6%B1%82">前期准备：需求</a> 阶段都已经准备好，如果没有的话，那就需要在架构部分指定。</p>
<p>架构应该模块化，以便可以替换新的用户界面，而不会影响程序的业务规则和输出部分。</p>
<p>例如，架构应该可以让“删除一个 UI 界面，并通过命令行执行相同逻辑” 的需求变得相当容易实现。这种能力通常很有用，特别是因为命令行界面可以方便地进行单元或子系统级别的软件测试。</p>
<h3 id="资源管理"><a class="header-anchor" href="#资源管理">#</a>资源管理</h3>
<p>一个架构应当描述如何管理系统的稀缺资源（线程数，数据库连接，句柄，内存等），应当估计在正常和极端情况下所使用的资源情况。</p>
<h3 id="安全性"><a class="header-anchor" href="#安全性">#</a>安全性</h3>
<p>架构应当描述设计层面和代码层面的安全性问题。指定编码规范时，应当要考虑到安全隐患，比如内存的处理方式，对于未经授权的输入信息的处理，加密，错误日志中体现信息的详细程度等问题。</p>
<h3 id="性能"><a class="header-anchor" href="#性能">#</a>性能</h3>
<p>如果性能是一个问题，那么就应该在需求中定义性能目标，性能目标可以是使用的资源数量，在这种情况下，目标还应该要说明资源之间的优先级，比如执行效率和内存哪个更重要。</p>
<p>架构应该要提供对性能目标的评估，并说明为什么架构师相信在此架构下目标是可以实现的。</p>
<ul>
<li>如果某些领域面临无法实现其目标的风险，架构应该要说明。</li>
<li>如果某些领域必须使用特定的算法或数据类型才能满足其性能目标，架构应该要说明。</li>
<li>架构还应该要说明每个类和对象的空间和时间预算</li>
</ul>
<h3 id="可拓展性"><a class="header-anchor" href="#可拓展性">#</a>可拓展性</h3>
<p>可拓展性是系统满足未来需求的能力。架构应当要描述该系统如何解决用户量增大，数据量增大，以及其他未来需求的问题。</p>
<p>如果架构预计这些数据不会增长，或者可拓展性不是问题，那么架构也应该明确说明这个假设。</p>
<h3 id="互操作性"><a class="header-anchor" href="#互操作性">#</a>互操作性</h3>
<p>如果系统期望与其他的软件或硬件共享数据或资源，那么架构应当要描述如何实现这一点。</p>
<h3 id="本地化"><a class="header-anchor" href="#本地化">#</a>本地化</h3>
<p>在交互系统的架构中，本地化问题值得关注，架构应表明已经考虑了典型的字符串和字符集问题，在不更改代码的情况下维护字符串，并将字符串翻译成外语，同时对代码和用户界面的影响最小。</p>
<h3 id="输入_输出"><a class="header-anchor" href="#输入_输出">#</a>输入/输出</h3>
<p>架构应当要描述预先，事后或实时的信息读取方案，它还需要描述在字段，记录，流或文件级别的错误处理。</p>
<h3 id="错误处理"><a class="header-anchor" href="#错误处理">#</a>错误处理</h3>
<p>错误处理是现代计算机科学中最棘手的问题之一，你不能随意的处理它。</p>
<p>有人估计，程序中 90% 的代码是为异常、错误情况和边界情况而编写的。正因为如此多的代码是专门处理错误的，所以应该在架构中描述错误处理的策略。</p>
<p>错误处理通常被认为是<em>编码规范</em> 级别的问题，但因为它具有系统范围的影响，因此最好在架构层级进行处理，以下是一些需要考虑的问题：</p>
<ul>
<li>错误处理是纠正性的还是仅仅是检测性的？
<ul>
<li>如果是纠正性的，程序应当尝试从错误中恢复。</li>
<li>如果是检测性的，程序可以继续执行，就好像什么也没发生一样，也可以选择退出。<br>
无论哪种情况，程序都应该提示用户它检测到了错误</li>
</ul>
</li>
<li>错误检测是主动的还是被动的？
<ul>
<li>系统可以主动预测错误（例如，通过检查用户输入的有效性），</li>
<li>或者仅在无法避免错误时才被动响应错误（例如，当用户输入的组合产生数字溢出时）。</li>
</ul>
</li>
<li>程序如何传播错误？ 一旦检测到错误，程序可以
<ul>
<li>选择丢弃导致错误的数据，</li>
<li>将错误视为异常并进入异常处理流程</li>
<li>等到所有逻辑处理完成并通知用户在某地检测到错误</li>
</ul>
</li>
<li>处理错误消息的约定是什么？如果架构没有定义一个单一且一致的策略，那么用户界面会变成一个令人困惑的存在。</li>
<li>异常情况该如何处理？架构应该解决代码何时可以抛出异常，在哪里捕获异常，如何打印异常，如何记录异常等问题。</li>
<li>在程序内部，异常需要在哪一个层级进行处理？是在检测的地方处理，还是将他们传递给异常处理类，还是将它们抛给调用链？</li>
<li>每个类验证其输入数据的责任级别是什么？每个类都需要检测自己的数据，还是有一组类专门负责验证系统的数据？任何级别的类都可以假设它们接收到的数据是干净的吗？</li>
<li>你希望使用已有环境内置的异常处理机制还是自己建立一套异常处理机制，已有环境内的异常处理可能并不能满足你的需求，但是自己建立一套异常处理机制可能会增加额外的复杂性。</li>
</ul>
<h3 id="容错能力"><a class="header-anchor" href="#容错能力">#</a>容错能力</h3>
<p>架构还应该表明预期的容错类型。容错是一系列技术的集合，这些技术通过检测错误、在可能的情况下从错误中恢复以及在没有错误的情况下遏制其不良影响来提高系统的可靠性。</p>
<h3 id="可行性"><a class="header-anchor" href="#可行性">#</a>可行性</h3>
<p>架构应证明该系统在技术上是可行的。</p>
<p>如果任何领域的不可行性可能导致项目无法实施，则架构应表明如何通过概念原型验证、调用或其他方式确认这些问题，这些风险应在全面构建开始之前得到解决。</p>
<h3 id="饱和设计"><a class="header-anchor" href="#饱和设计">#</a>饱和设计</h3>
<p>鲁棒性是指系统在检测到错误后继续运行的能力。通常，架构定义的系统比需求定义的系统更健壮。</p>
<p>在软件领域中，系统的薄弱等级并不等于所有组成模块中最薄弱的那个模块等级，而可能是所有模块薄弱程度的叠加。</p>
<p>通过在架构中明确指定鲁棒性的期望，也能避免出现某些类异常健壮，而某一些类勉强够用的情况。</p>
<h3 id="购买_构建_决策"><a class="header-anchor" href="#购买_构建_决策">#</a>购买/构建 决策</h3>
<p>构建一个软件最好的方式是压根不构建它，而是用购买或免费使用开源软件的方式。</p>
<p>如果架构决定不使用已有的库，它应该解释它期望的 <em>自建库要比市面上已有库强大的能力</em> 是什么。</p>
<p>如果一个架构决定要使用已有的库 / 测试用例 / 数据结构或其他，架构也应当解释这些已有的材料为何能满足架构中其他部分的需求。</p>
<h3 id="应对变动的策略"><a class="header-anchor" href="#应对变动的策略">#</a>应对变动的策略</h3>
<p>产品在整个开发过程中可能会发生变化，变化可能源于被破坏的数据类型和文件格式、更改的功能、新特性等等。因此，软件架构师面临的主要挑战之一是使架构足够灵活以适应可能的变化。</p>
<p>架构应该清楚地描述应对变动的策略。架构应表明已经考虑了可能的新增功能，并且这些新增功能在现有架构下最有可能也是最容易实现的。</p>
<p>如果输入或输出格式、用户交互风格或处理要求发生变化，架构应该表明这些变化都是预期的，并且任何单个变化的影响将仅限于少数类。</p>
<h3 id="架构质量"><a class="header-anchor" href="#架构质量">#</a>架构质量</h3>
<p>一个好的架构特点，是它对系统中的每个类，每个类的隐藏信息，和其他所有可能的设计方案都进行了原理性的讨论。</p>
<p>大型系统的基本问题是保持其概念完整性，一个好的架构应该能够解决问题。</p>
<ul>
<li>当你查看架构时，你应该会对解决方案看起来如此自然和简单感到满意。</li>
<li>要解决的问题和架构本身不应该看起来像是用胶带强行绑在一起的。</li>
</ul>
<p>架构应该表述所有重大决策的动机，并且要避免出现 “我们一直都是这样做的” 这样的理由。</p>
<p>好的架构应当是独立于硬件和语言的。当然，构建环境（硬件和语言）是不可被忽略的，但是尽可能地脱离于环境，可以有效地避免过度设计地诱惑。</p>
<p>架构应当明确地区分 <strong>未设计</strong> 和<strong>过度设计</strong>的部分，不应该出现架构中的某一个部分受到了超出其应有的设计，而又有部分不受到关注。</p>
<p>架构应明确指出可能存在风险的区域，架构也应该解释为什么这些区域有风险以及已采取哪些措施来最大程度地降低风险。</p>
<p>架构应该包含多个角度的说明，这样可以消除错误和不一致，并帮助程序员充分理解系统的设计。</p>
<p>最后，你不应该对架构的任何部分感到不安，架构不应该包含任何只是为了取悦老板的内容。它不应包含任何你难以理解的内容。你是负责实施它的人，如果它对你来说没有意义，你如何实施它？</p>
<p>架构检查清单：<br>
<a href="/ch_03_architecture_checklist">Architecture Checklist</a></p>
<h1 id="3_6_花在上游决策条件上的时间量"><a class="header-anchor" href="#3_6_花在上游决策条件上的时间量">#</a>3.6 花在上游决策条件上的时间量</h1>
<p>花在问题定义、需求和软件架构上的时间根据项目的需求而变化。一般来说，一个运行良好的项目应当将大约 10% 到 20% 的精力和大约 20% 到 30% 的进度投入到需求、架构和前期规划上。</p>
<ul>
<li>如果需求不明确，并且你正在处理大型正式项目，则需要与需求分析师合作来解决在构建早期发现的需求问题。</li>
<li>如果需求不明确，并且你正在处理一个小型的非正式项目，那么你可能需要自己解决需求问题：留出足够的时间来定义需求，使其波动对施工的影响降至最低。</li>
</ul>
<p>无论是什么项目，如果需求不明确，请将需求的明确作为自己的工作一部分。</p>
<ul>
<li>如果你不知道自己要做什么，那么没有人能理智的估算出周期。</li>
<li>就好比你是一个建筑承包商，被要求建一所房子，你的客户说“这项工作要花多少钱？” 理智的话，你应该问“你想让我做什么？” 如果你的客户说“我不能告诉你，但是你需要花多少钱？” 这时，你应该做的就是感谢下这个顾客浪费了你宝贵的时间，然后回家。</li>
</ul>
<p>完整的上游决策的检查清单：<br>
<a href="/ch_03_prerequisites_checklist">Prerequisites Checklist</a></p>
]]></content>
      <tags>
        <tag>系统设计</tag>
        <tag>工程实践</tag>
      </tags>
  </entry>
  <entry>
    <title>《Code Complete》需求检查清单</title>
    <url>/ch_03_requirement_checklist/</url>
    <content><![CDATA[<p>需求清单包含一系列你可以用来询问自己的，有关项目需求的问题。</p>
<p>使用该列表作为施工时的健全性检查，以确定构建前的需求准备工作的坚固程度。</p>
<p>并非所有清单问题都适用于你的项目。</p>
<ul>
<li>如果你正在从事非正式项目，你会发现一些你甚至不需要考虑的问题，也会发现其他一些你需要考虑但不需要正式回答的问题。</li>
<li>如果你正在从事一个大型的正式项目，你可能需要考虑每一个问题。</li>
</ul>
<div class="note info simple"><p>这里的需求，并不仅仅是指用户的需求，也可能指一个软件库的需求</p>
</div>
<h1 id="功能需求"><a class="header-anchor" href="#功能需求">#</a>功能需求</h1>
<ul>
<li>[ ] 是否明确了系统的所有输入标准，包括其来源、精度、值范围和频率？</li>
<li>[ ] 是否明确了系统的所有输出标准，包括其目的地、精度、值范围、频率和格式？</li>
<li>[ ] 是否为网页、报告等指定了所有输出格式？</li>
<li>[ ] 所有对外的硬件/软件结构是否都有指定？</li>
<li>[ ] 所有与外部接口的通信标准是否有指定？包括握手、错误检查和通信协议</li>
<li>[ ] 是否说明了用户所有想要执行的任务？</li>
<li>[ ] 是否说明了每个任务使用的数据以及每个任务产生的数据？</li>
</ul>
<h1 id="非功能（质量）需求"><a class="header-anchor" href="#非功能（质量）需求">#</a>非功能（质量）需求</h1>
<ul>
<li>[ ] 从用户的角度来看，是否为所有必要的操作指定了预期响应时间？</li>
<li>[ ] 其他的时间因素的考量是否有说明，例如处理时间、数据传输速率和系统吞吐量</li>
<li>[ ] 是否规定了安全级别？</li>
<li>[ ] 是否制定了可靠性标准，包括软件故障的后果、需要保护免受故障影响的重要信息是哪些，错误检测和恢复的策略是什么？</li>
<li>[ ] 最小支持的硬件内存和磁盘空间是否有说明？</li>
<li>[ ] 是否规定了系统的可维护性？包括适应特定功能变化、操作环境变化以及与其他软件接口变化的能力？</li>
<li>[ ] 是否描述了成功 / 失败的定义</li>
</ul>
<h1 id="需求质量"><a class="header-anchor" href="#需求质量">#</a>需求质量</h1>
<ul>
<li>[ ] 需求是用用户（需求完成者）的语言描述的吗？用户也这么觉得吗？</li>
<li>[ ] 每个需求是否避免了与其他需求的冲突？</li>
<li>[ ] 是否指定了竞争属性之间可接受的权衡（例如，鲁棒性和正确性之间的权衡）</li>
<li>[ ] 需求是否避免指定设计？（必须通过某个方式来解决）</li>
<li>[ ] 需求的详细程度是否相当一致？是否存在需要更详细规定的任何需求？是否存在描述过于细致的任何需求？</li>
<li>[ ] 需求是否足够清晰，以至于可以移交给独立小组进行构建并且可以被正确的理解？开发团队也是这么认为吗？</li>
<li>[ ] 每个需求是否能与问题和解决方案相关联，每个需求是否能追溯到问题环境？</li>
<li>[ ] 每个需求都可以被测试吗？是否可以通过独立测试来确定是否满足每项要求？</li>
<li>[ ] 需求所有可能的变更是否都指明了？是否说明了每一个变更的可能性？</li>
</ul>
<h1 id="需求完整性"><a class="header-anchor" href="#需求完整性">#</a>需求完整性</h1>
<ul>
<li>[ ] 如果在开发前，无法获取全部信息，缺失的区域是否有说明？</li>
<li>[ ] 需求范围是否足够完整，即如果每一项需求都被满足，是否可以推论产品可以被接受？</li>
<li>[ ] 你是否对所有的需求满意？你是否消除了所有仅是为了安抚客人或老板而不可能实现的需求？</li>
</ul>
]]></content>
      <tags>
        <tag>系统设计</tag>
        <tag>工程实践</tag>
      </tags>
  </entry>
  <entry>
    <title>《Code Complete》先决条件检查清单</title>
    <url>/ch_03_prerequisites_checklist/</url>
    <content><![CDATA[<p>关于所有上游先决条件的检查表：</p>
<ul>
<li>[ ] 你是否已经确定了你正在从事的软件项目的类型并适当地调整了你的方法（迭代 或 顺序）？</li>
<li>[ ] 需求是否足够明确，足以开始构建？（更详细的请参考，<a href="/ch_03_requirement_checklist">Ch 03 Requirement Checklist</a>）</li>
<li>[ ] 架构是否足够明确，足以开始构建（更详细的请参考 <a href="/ch_03_architecture_checklist">Ch 03 Architecture Checklist</a></li>
<li>[ ] 你项目中的特有的风险是否已经得到了解决，以保证在施工时不会面临不必要的风险？</li>
</ul>
]]></content>
      <tags>
        <tag>工程实践</tag>
      </tags>
  </entry>
  <entry>
    <title>《Head First 设计模式》 Ch 03 装饰模式</title>
    <url>/ch_03_the_decorator_pattern/</url>
    <content><![CDATA[<p>装饰模式（Decorator Pattern） 提供了一个动态增加一个类功能的方法，主要实现思想是通过一个作为装饰者的类（<code>Decorators</code>）包裹被装饰类（<code>Component</code>）（装饰类以及被装饰类都有共同的基类），<code>Decorators</code> 会在 <code>Component</code> 类的某一个函数执行前或后进行一些操作，进而达到增加功能的作用。</p>
<p>装饰模式主要实现了“代码应该对扩展功能开放而对于修改关闭”的面向对象原则，它在增加新功能的前提下，不需要改动既有的代码，只需要增加新的 <code>Decorators</code> 并且包含既有的 <code>Component</code> 即可。</p>
<p>例如我们要计算一杯咖啡的价格，而这杯咖啡的价格还会受到额外的配料的影响，比如要加抹茶需要额外支付 0.2 元，加奶泡需要额外支付 0.3 元等。如果对各种配料都各自使用一个类来表示，则会存在较多的类需要维护，而且一旦配料发生变化等，还需要进行代码修改。而使用装饰模式则可以将原始的咖啡作为被装饰类，而所有的配料都是装饰类，则配料的更改仅需要增加或删除外部的装饰类即可。</p>
<h1 id="代码示例"><a class="header-anchor" href="#代码示例">#</a>代码示例</h1>
<h2 id="装饰类及被装饰类基类"><a class="header-anchor" href="#装饰类及被装饰类基类">#</a>装饰类及被装饰类基类</h2>
<figure class="highlight cs"><figcaption><span>被装饰类基类</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Beverage</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">string</span> description = <span class="string">&quot;UnKnown Beverage&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">string</span> <span class="title">getDescription</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">double</span> <span class="title">Cost</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>装饰类基类</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">CondimentDecorator</span> : <span class="title">Beverage</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> Beverage beverage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CondimentDecorator</span>(<span class="params">Beverage beverage</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.beverage = beverage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note info simple"><p>注意装饰类基类继承自被装饰类，并存有一个被装饰类的变量，因为装饰类需要在被装饰类操作的基础上进行一定额外的操作，所以它需要存有对被装饰类的引用，同时对外部而言调用者而言，它与被装饰类相同。</p>
</div>
<h2 id="被装饰类实现"><a class="header-anchor" href="#被装饰类实现">#</a>被装饰类实现</h2>
<figure class="highlight cs"><figcaption><span>浓咖啡</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Espresso</span> : <span class="title">Beverage</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Espresso</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        description = <span class="string">&quot;Espresson&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">double</span> <span class="title">Cost</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.99</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="装饰类实现"><a class="header-anchor" href="#装饰类实现">#</a>装饰类实现</h2>
<figure class="highlight cs"><figcaption><span>酱油</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Soy</span> : <span class="title">CondimentDecorator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Soy</span>(<span class="params">Beverage beverage</span>) : <span class="title">base</span>(<span class="params">beverage</span>)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">getDescription</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> beverage.getDescription() + <span class="string">&quot;, Soy&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">double</span> <span class="title">Cost</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.30</span> + beverage.Cost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>奶泡</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Whip</span> : <span class="title">CondimentDecorator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Whip</span>(<span class="params">Beverage beverage</span>) : <span class="title">base</span>(<span class="params">beverage</span>)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">getDescription</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> beverage.getDescription() + <span class="string">&quot;, Whip&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">double</span> <span class="title">Cost</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.30</span> + beverage.Cost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>抹茶</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Mocha</span> : <span class="title">CondimentDecorator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mocha</span>(<span class="params">Beverage beverage</span>) : <span class="title">base</span>(<span class="params">beverage</span>)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">getDescription</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> beverage.getDescription() + <span class="string">&quot;, Mocha&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">double</span> <span class="title">Cost</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.20</span> + beverage.Cost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="测试及结果"><a class="header-anchor" href="#测试及结果">#</a>测试及结果</h1>
<figure class="highlight cs"><figcaption><span>测试代码</span></figcaption><table><tr><td class="code"><pre><span class="line">Espresso espresso = <span class="keyword">new</span> Espresso();</span><br><span class="line">Console.WriteLine(espresso.getDescription() + <span class="string">&quot; Cost: &quot;</span> + espresso.Cost());</span><br><span class="line"></span><br><span class="line">Beverage doubleMochaWhipEspresso = <span class="keyword">new</span> Mocha(<span class="keyword">new</span> Mocha(<span class="keyword">new</span> Whip(espresso)));</span><br><span class="line">Console.WriteLine(doubleMochaWhipEspresso.getDescription() + <span class="string">&quot; Cost: &quot;</span> + doubleMochaWhipEspresso.Cost());</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/ch_03_the_decorator_pattern/2019-01-15-23-43-20.png" alt="装饰模式运行结果"></p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>《Code Complete》 构建实践检查清单</title>
    <url>/ch_04_construction_practices_checklists/</url>
    <content><![CDATA[<p>这一节中包含有在编码时，需要检查的内容。</p>
<h1 id="Coding"><a class="header-anchor" href="#Coding">#</a>Coding</h1>
<ul>
<li>[ ] 你是否定义了在编写代码时，多少工作应该在编码之前完成预先设计，多少工作在真正编码时在键盘上完成？</li>
<li>[ ] 你是否定义了命名、注释和布局的编码约定？</li>
<li>[ ] 你是否定义了架构所隐含的特定编码实践，例如如何处理错误条件、如何解决安全性、类接口将使用哪些约定、重用代码将应用哪些标准、在编码时应该多大程度的考虑性能问题等等？</li>
<li>[ ] 你是否已确定如何使用某语言进行编程，而不是受到该语言的限制？（<strong>利用语言</strong> 还是 <strong>用语言</strong>）</li>
</ul>
<h1 id="团队合作"><a class="header-anchor" href="#团队合作">#</a>团队合作</h1>
<ul>
<li>[ ] 你是否定义了集成过程——也就是说，你是否定义了程序员在将代码合入主代码前必须执行的具体步骤？</li>
<li>[ ] 程序员会结对编程，还是单独编程，还是两者的组合？（测试和开发的结合关系）</li>
</ul>
<h1 id="质量保证"><a class="header-anchor" href="#质量保证">#</a>质量保证</h1>
<ul>
<li>[ ] 程序员会在编写代码之前为其代码编写测试用例吗？</li>
<li>[ ] 程序员是否会为他们的代码编写单元测试，无论他们是事先写还是事后写？</li>
<li>[ ] 程序员在合入代码之前会在调试器中单步执行代码？</li>
<li>[ ] 程序员会在合入代码之前对其进行集成测试吗？</li>
<li>[ ] 程序员会审查或检查彼此的代码吗？</li>
</ul>
<h1 id="工具"><a class="header-anchor" href="#工具">#</a>工具</h1>
<ul>
<li>[ ] 你选择了版本控制工具吗？</li>
<li>[ ] 你是否选择了编程语言，语言版本或编译器版本？</li>
<li>[ ] 你是否选择了某框架，或者明确决定不使用框架？</li>
<li>[ ] 你是否允许使用非标准语言功能？</li>
<li>[ ] 你是否已经确定并获得了你需要使用的其他工具——编辑器、重构工具、调试器、测试框架、语法检查器等等？</li>
</ul>
]]></content>
      <tags>
        <tag>工程实践</tag>
      </tags>
  </entry>
  <entry>
    <title>《Code Complete》第四章：关键构建决策</title>
    <url>/ch_04_key_construction_decisions/</url>
    <content><![CDATA[<h1 id="4_1_编程语言的选择"><a class="header-anchor" href="#4_1_编程语言的选择">#</a>4.1 编程语言的选择</h1>
<p>编程语言的选择会通过多种方式影响生产力和代码质量。</p>
<p>程序员使用熟悉的语言比使用不熟悉的语言更有效率。IBM 的一项早期研究发现，对一个语言有丰富经验的程序员的工作效率是那些经验很少的程序员的三倍多</p>
<p>使用高级语言的程序员比使用低级语言的程序员可以获得更好的生产力和质量。高级语言相对于低级语言在生产效率、可靠性和可阅读性提高了 5 到 15 倍。高级语言相对于低级语言有更高的表达能力，即每行代码可以实现更多的任务。</p>
<p>萨丕尔-沃夫假说 认为人思考某个想法的能力取决于他是否知道能够表达该想法的词语。如果你不认识单词，你就无法表达想法。也因此程序员可能会类似地受到他们的语言的影响。</p>
<p>编程语言对程序员思维影响的证据很常见，如一些拥有 A 语言背景的人去使用 B 语言开发，他们很可能只是通过 B 语言来实现 A 语言的特色，而忽略了 B 语言本身的能力。</p>
<h1 id="4_2_编码约定"><a class="header-anchor" href="#4_2_编码约定">#</a>4.2 编码约定</h1>
<p>在复杂的项目中，架构赋予项目结构平衡，而编码约定则提供实现层的和谐。如果没有统一的编码风格，编写的代码将在风格上存在杂乱的变化。而这些变化会消耗开发者的大脑——大脑会需要分出一部分精力去理解编码风格差异。成功编程的关键之一是避免任意变化，以便让开发者的大脑可以专注于真正需要关心的逻辑上。</p>
<div class="note info simple"><p>如果你有一幅画的伟大设计，但一部分是古典派，一部分是印象派，一部分是立体派，该怎么办？无论你多么严格地遵循其宏伟的设计，它都不具有概念完整性。它看起来像一幅廉价拼贴画。</p>
</div>
<p>在开始构建之前，需要阐明你将使用的编程约定。编码约定的细节将非常精确，以至于在编写软件后几乎不可能对其进行改造。</p>
<h1 id="4_3_你在科技浪潮中的位置"><a class="header-anchor" href="#4_3_你在科技浪潮中的位置">#</a>4.3 你在科技浪潮中的位置</h1>
<p>理解**用一种语言编程（Programming in one language）**和 <strong>利用一种语言编程（Programming into one language）</strong> 之间的区别对于理解本书至关重要。</p>
<p>大多数重要的编程原则并不取决于特定的语言，而是取决于你使用它们的方式。如果你的语言缺乏你想要使用的结构或者容易出现其他类型的问题，请尝试弥补它们。发明你自己的编码约定、标准、类库和其他增强语言的方式。</p>
<p>如，VB 语言本身并不支持数据和业务的解耦，但可以通过约定 <code>.fsm</code> 文件仅可以支持查询查询数据库和将数据存储回数据库，将对于数据库业务的访问的工作难度降低，因为后续所有的开发者都可以基于这个约定知道 <code>.fsm</code> 本身并不会修改数据库。这就是作者通过约定对 VB 语言的加强。</p>
<h1 id="4_4_构建实践的选择"><a class="header-anchor" href="#4_4_构建实践的选择">#</a>4.4 构建实践的选择</h1>
<p>准备构建的一部分是决定你将强调哪些可用的良好实践。一些项目使用结对编程并优先编写测试，而另一些项目则使用单独开发和事后的测试。根据项目的实际情况，这两种选择都可能发挥很好的作用。</p>
<p>以下清单总结了在构建过程中应有意识地决定包含或排除的具体实践，这些实践的细节将在本书的其他部分进行阐述：<br>
<a href="/ch_04_construction_practices_checklists">Ch 04 Construction Practices Checklists</a></p>
]]></content>
      <tags>
        <tag>工程实践</tag>
      </tags>
  </entry>
  <entry>
    <title>《Head First 设计模式》 Ch 04 工厂模式</title>
    <url>/ch_04_the_factory_pattern/</url>
    <content><![CDATA[<p>工厂模式是为了将对象的实例化与对对象的操作解耦。因为有时我们会根据情况的不同，实例化出对象的不同版本，而我们不希望这种对于情况的判断与逻辑代码耦合在一起。</p>
<p>工厂模式有三个较为常见的变种，简单工厂模式，工厂方法模式，抽象工厂模式，下面会以创建披萨为例子来具体说明。</p>
<h1 id="简单工厂模式"><a class="header-anchor" href="#简单工厂模式">#</a>简单工厂模式</h1>
<p>简单工厂模式严格意义上并不是一个设计模式，只是它被太多人的使用，所以需要单独进行说明。</p>
<p>简单工厂模式会定义一个工厂类来进行对象的实例化。</p>
<p>我们定义一个披萨商店，他将会管理披萨产出的整个流程。我们为了将披萨的生产与之后的操作（如切披萨）拆分开，需要定义一个简单披萨工厂。</p>
<h2 id="代码示例"><a class="header-anchor" href="#代码示例">#</a>代码示例</h2>
<h3 id="披萨类及其实例化"><a class="header-anchor" href="#披萨类及其实例化">#</a>披萨类及其实例化</h3>
<figure class="highlight cs"><figcaption><span>披萨基类</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Pizza</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> Cheese cheese = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">protected</span> Sauce sauce = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">protected</span> Onion onion = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">prepare</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Bake for 25 minutes at 350&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cut</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Cutting the pizza into diagonal slices&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">box</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Place pizza in official PizzaStore box&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Debug</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">        Console.WriteLine(name);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Cheese is &quot;</span> + (cheese != <span class="literal">null</span> ? cheese.ToString() : <span class="string">&quot;Null&quot;</span>));</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Sauce is &quot;</span> + (sauce != <span class="literal">null</span> ? sauce.ToString() : <span class="string">&quot;Null&quot;</span>));</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Onion is &quot;</span> + (onion != <span class="literal">null</span> ? onion.ToString() : <span class="string">&quot;Null&quot;</span>));</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>披萨实现</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CheesePizza</span> : <span class="title">Pizza</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">prepare</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cheese = <span class="keyword">new</span> Cheese();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SaucePizza</span> : <span class="title">Pizza</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">prepare</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        sauce = <span class="keyword">new</span> Sauce();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="披萨商店与简单披萨工厂"><a class="header-anchor" href="#披萨商店与简单披萨工厂">#</a>披萨商店与简单披萨工厂</h3>
<figure class="highlight cs"><figcaption><span>披萨商店</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PizzaStore</span></span><br><span class="line">&#123;</span><br><span class="line">    SimplePizzaFactory simpleFactory;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PizzaStore</span>(<span class="params">SimplePizzaFactory factory</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.simpleFactory = factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">orderPizza</span>(<span class="params"><span class="built_in">string</span> type</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Pizza pizza = simpleFactory.createPizza(type);</span><br><span class="line">        pizza.prepare();</span><br><span class="line">        pizza.bake();</span><br><span class="line">        pizza.cut();</span><br><span class="line">        pizza.box();</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>简单披萨工厂</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SimplePizzaFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">createPizza</span>(<span class="params"><span class="built_in">string</span> type</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Pizza pizza = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (type.Equals(<span class="string">&quot;cheese&quot;</span>))</span><br><span class="line">            pizza = <span class="keyword">new</span> CheesePizza();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (type.Equals(<span class="string">&quot;sauce&quot;</span>))</span><br><span class="line">            pizza = <span class="keyword">new</span> SaucePizza();</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试及结果"><a class="header-anchor" href="#测试及结果">#</a>测试及结果</h2>
<figure class="highlight cs"><figcaption><span>测试代码</span></figcaption><table><tr><td class="code"><pre><span class="line">PizzaStore store = <span class="keyword">new</span> PizzaStore(<span class="keyword">new</span> SimplePizzaFactory());</span><br><span class="line">Pizza pizza = store.orderPizza(<span class="string">&quot;cheese&quot;</span>);</span><br><span class="line">pizza.Debug();</span><br></pre></td></tr></table></figure>
<p>运行结果:<br>
<img src="/ch_04_the_factory_pattern/2019-01-20-21-24-34.png" alt="简单工厂运行结果"></p>
<h1 id="工厂方法模式"><a class="header-anchor" href="#工厂方法模式">#</a>工厂方法模式</h1>
<p>简单工厂提供了一个类来作为对象实例化的工厂，它解决了对象实例化与逻辑代码耦合的问题，但没有提供扩写这个工厂的方法。例如上例中，我们需要在工厂中增加新的产品只能扩写原先的工厂类，但这可能会造成单个工厂类的逻辑过于复杂。<br>
而工厂方法模式则是通过一个抽象函数来作为工厂，在各派生类中重写该函数，达到工厂的扩写。</p>
<p>我们定义一个抽象的披萨商店，并在其中定义一个抽象函数 <code>createPizza</code>，并在披萨商店的继承类中重写这个方法来演示工厂方法模式。</p>
<div class="note warning simple"><p>注意这个例子完全可以通过建立多个简单工厂来实现，这里只是为了说明工厂方法模式的结构。</p>
</div>
<h2 id="代码示例-2"><a class="header-anchor" href="#代码示例-2">#</a>代码示例</h2>
<h3 id="抽象披萨商店及实例化"><a class="header-anchor" href="#抽象披萨商店及实例化">#</a>抽象披萨商店及实例化</h3>
<figure class="highlight cs"><figcaption><span>抽象披萨商店</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">PizzaStore</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">orderPizza</span>(<span class="params"><span class="built_in">string</span> type</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Pizza pizza = createPizza(type);</span><br><span class="line">        pizza.prepare();</span><br><span class="line">        pizza.bake();</span><br><span class="line">        pizza.cut();</span><br><span class="line">        pizza.box();</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Pizza <span class="title">createPizza</span>(<span class="params"><span class="built_in">string</span> type</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>纽约披萨商店</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NYPizzaStore</span> : <span class="title">PizzaStore</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> Pizza <span class="title">createPizza</span>(<span class="params"><span class="built_in">string</span> type</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Pizza pizza = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (type.Equals(<span class="string">&quot;cheese&quot;</span>))</span><br><span class="line">            pizza = <span class="keyword">new</span> NYStyleCheesePizza();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (type.Equals(<span class="string">&quot;sauce&quot;</span>))</span><br><span class="line">            pizza = <span class="keyword">new</span> NYStyleSausePizza();</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>芝加哥披萨商店</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ChicagoPizzaStore</span> : <span class="title">PizzaStore</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> Pizza <span class="title">createPizza</span>(<span class="params"><span class="built_in">string</span> type</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Pizza pizza = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (type.Equals(<span class="string">&quot;cheese&quot;</span>))</span><br><span class="line">            pizza = <span class="keyword">new</span> ChicagoStyleCheesePizza();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (type.Equals(<span class="string">&quot;sauce&quot;</span>))</span><br><span class="line">            pizza = <span class="keyword">new</span> ChicagoStyleSaucePizza();</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="不同风格的披萨实现"><a class="header-anchor" href="#不同风格的披萨实现">#</a>不同风格的披萨实现</h3>
<figure class="highlight cs"><figcaption><span>纽约风格的披萨</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NYStyleCheesePizza</span> : <span class="title">Pizza</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">prepare</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cheese = <span class="keyword">new</span> NYCheese();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NYStyleSausePizza</span> : <span class="title">Pizza</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">prepare</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        sauce = <span class="keyword">new</span> NYSauce();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>芝加哥风格的披萨</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ChicagoStyleCheesePizza</span> : <span class="title">Pizza</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">prepare</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cheese = <span class="keyword">new</span> ChicagoCheese();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ChicagoStyleSaucePizza</span> : <span class="title">Pizza</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">prepare</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        sauce = <span class="keyword">new</span> ChicagoSauce();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试及结果-2"><a class="header-anchor" href="#测试及结果-2">#</a>测试及结果</h2>
<figure class="highlight cs"><figcaption><span>测试代码</span></figcaption><table><tr><td class="code"><pre><span class="line">PizzaStore store = <span class="keyword">new</span> ChicagoPizzaStore();</span><br><span class="line">Pizza pizza = store.orderPizza(<span class="string">&quot;cheese&quot;</span>);</span><br><span class="line">pizza.Debug();</span><br><span class="line">store = <span class="keyword">new</span> NYPizzaStore();</span><br><span class="line">pizza=store.orderPizza(<span class="string">&quot;cheese&quot;</span>);</span><br><span class="line">pizza.Debug();</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/ch_04_the_factory_pattern/2019-01-23-00-29-35.png" alt="工厂方法模式运行结果"></p>
<h1 id="抽象工厂模式"><a class="header-anchor" href="#抽象工厂模式">#</a>抽象工厂模式</h1>
<p>工厂方法模式中的工厂的多态性依赖于继承，比如我们定义的<code>PizzaStore</code>中有个抽象函数<code>createPizza</code>，这个抽象函数即为一个工厂，在各个派生类中我们去重写这个抽象函数，通过继承来实现不同的工厂。而在抽象工厂模式中，我们将定义一个工厂接口，在需要工厂的接口中类中存储这个接口，并在不同的情况下用这个接口不同的实现，来达到工厂的多态性。</p>
<p>另外在工厂方法模式中，因为是通过重写函数的方法来实现，所以一个工厂只能产出一个产品。而在抽象工厂模式中，在一个抽象工厂中却能定义多个制造产品的函数，进而一个抽象工厂可以提供多个产品。</p>
<div class="note info simple"><p>生产出一个产品还是多个产品并不是抽象工厂模式和工厂方法模式的主要区别，他们的主要区别在于工厂方法模式是通过继承来实现工厂的多态，而抽象工厂模式是通过组合。</p>
</div>
<p>我们定义一个披萨原料工厂，来体现抽象工厂模式。</p>
<h2 id="代码示例-3"><a class="header-anchor" href="#代码示例-3">#</a>代码示例</h2>
<h3 id="披萨原料工厂接口及实现"><a class="header-anchor" href="#披萨原料工厂接口及实现">#</a>披萨原料工厂接口及实现</h3>
<figure class="highlight cs"><figcaption><span>披萨原料工厂接口</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">PizzaIngredientFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Onion <span class="title">createOnion</span>()</span>;</span><br><span class="line">    <span class="function">Sauce <span class="title">createSauce</span>()</span>;</span><br><span class="line">    <span class="function">Cheese <span class="title">createCheese</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>纽约披萨原料商店</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NYPizzaIngredientFactory</span> : <span class="title">PizzaIngredientFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cheese <span class="title">createCheese</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NYCheese();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Onion <span class="title">createOnion</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NYOnion();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sauce <span class="title">createSauce</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NYSauce();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>芝加哥披萨原料商店</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ChicagoPizzaIngredientFactory</span> : <span class="title">PizzaIngredientFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cheese <span class="title">createCheese</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ChicagoCheese();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Onion <span class="title">createOnion</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ChicagoOnion();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sauce <span class="title">createSauce</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ChicagoSauce();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note info simple"><p>可以看到在抽象工厂的实现时，用到了工厂方法模式。抽象工厂模式与工厂方法模式并非互斥的两种模式，工厂方法模式实际上内嵌与抽象工厂模式中</p>
</div>
<h3 id="抽象披萨商店及实例化-2"><a class="header-anchor" href="#抽象披萨商店及实例化-2">#</a>抽象披萨商店及实例化</h3>
<figure class="highlight cs"><figcaption><span>抽象披萨商店</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">PizzaStore</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">orderPizza</span>(<span class="params"><span class="built_in">string</span> type</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Pizza pizza = createPizza(type);</span><br><span class="line">        pizza.prepare();</span><br><span class="line">        pizza.bake();</span><br><span class="line">        pizza.cut();</span><br><span class="line">        pizza.box();</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Pizza <span class="title">createPizza</span>(<span class="params"><span class="built_in">string</span> type</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>纽约披萨商店</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> Pizza <span class="title">createPizza</span>(<span class="params"><span class="built_in">string</span> item</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Pizza pizza = <span class="literal">null</span>;</span><br><span class="line">    PizzaIngredientFactory ingredientFactory = <span class="keyword">new</span> NYPizzaIngredientFactory();</span><br><span class="line">    <span class="keyword">if</span> (item == <span class="string">&quot;cheese&quot;</span>)</span><br><span class="line">        pizza = <span class="keyword">new</span> CheesePizza(ingredientFactory);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (item == <span class="string">&quot;sauce&quot;</span>)</span><br><span class="line">        pizza = <span class="keyword">new</span> SaucePizza(ingredientFactory);</span><br><span class="line">    <span class="keyword">return</span> pizza;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>芝加哥披萨商店</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ChicagoPizzaStore</span> : <span class="title">PizzaStore</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> Pizza <span class="title">createPizza</span>(<span class="params"><span class="built_in">string</span> item</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Pizza pizza = <span class="literal">null</span>;</span><br><span class="line">        PizzaIngredientFactory ingredientFactory = <span class="keyword">new</span> ChicagoPizzaIngredientFactory();</span><br><span class="line">        <span class="keyword">if</span> (item == <span class="string">&quot;cheese&quot;</span>)</span><br><span class="line">            pizza = <span class="keyword">new</span> CheesePizza(ingredientFactory);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (item == <span class="string">&quot;sauce&quot;</span>)</span><br><span class="line">            pizza = <span class="keyword">new</span> SaucePizza(ingredientFactory);</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note info simple"><p>注意，这里披萨商店的实现，仍然是通过工厂方法模式。只是在<code>createPizza</code>函数中会实例化一个抽象工厂，并将其传递给对应的<code>Pizza</code>对象</p>
</div>
<h3 id="披萨类及其实例化-2"><a class="header-anchor" href="#披萨类及其实例化-2">#</a>披萨类及其实例化</h3>
<p>在披萨类的实例化中，我们使用了抽象工厂模式，披萨的实例化会包含一个披萨原料的抽象工厂，通过不同的披萨原料工厂来取得不同风味的披萨</p>
<figure class="highlight cs"><figcaption><span>披萨基类</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Pizza</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> Cheese cheese = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">protected</span> Sauce sauce = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">protected</span> Onion onion = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">prepare</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Bake for 25 minutes at 350&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cut</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Cutting the pizza into diagonal slices&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">box</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Place pizza in official PizzaStore box&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Debug</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">        Console.WriteLine(name);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Cheese is &quot;</span> + (cheese != <span class="literal">null</span> ? cheese.ToString() : <span class="string">&quot;Null&quot;</span>));</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Sauce is &quot;</span> + (sauce != <span class="literal">null</span> ? sauce.ToString() : <span class="string">&quot;Null&quot;</span>));</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Onion is &quot;</span> + (onion != <span class="literal">null</span> ? onion.ToString() : <span class="string">&quot;Null&quot;</span>));</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>披萨实现</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CheesePizza</span> : <span class="title">Pizza</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> PizzaIngredientFactory ingredientFactory = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CheesePizza</span>(<span class="params">PizzaIngredientFactory ingredientFactory</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.ingredientFactory = ingredientFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">prepare</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cheese = ingredientFactory.createCheese();</span><br><span class="line">        onion = ingredientFactory.createOnion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SaucePizza</span> : <span class="title">Pizza</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> PizzaIngredientFactory ingredientFactory = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SaucePizza</span>(<span class="params">PizzaIngredientFactory ingredientFactory</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.ingredientFactory = ingredientFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">prepare</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        sauce = ingredientFactory.createSauce();</span><br><span class="line">        onion = ingredientFactory.createOnion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试及结果-3"><a class="header-anchor" href="#测试及结果-3">#</a>测试及结果</h2>
<figure class="highlight cs"><figcaption><span>测试代码</span></figcaption><table><tr><td class="code"><pre><span class="line">PizzaStore pizzaStore = <span class="keyword">new</span> NYPizzaStore();</span><br><span class="line">Pizza pizza = pizzaStore.OrderPizza(<span class="string">&quot;cheese&quot;</span>);</span><br><span class="line">pizza.Debug();</span><br><span class="line">Console.WriteLine(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line">pizzaStore = <span class="keyword">new</span> ChicagoPizzaStore();</span><br><span class="line">pizza = pizzaStore.OrderPizza(<span class="string">&quot;cheese&quot;</span>);</span><br><span class="line">pizza.Debug();</span><br></pre></td></tr></table></figure>
<p>运行结果：<br>
<img src="/ch_04_the_factory_pattern/2019-01-24-01-01-50.png" alt="抽象工厂模式运行结果"></p>
<h1 id="Reference"><a class="header-anchor" href="#Reference">#</a>Reference</h1>
<p><a href="https://dzone.com/articles/factory-method-vs-abstract">https://dzone.com/articles/factory-method-vs-abstract</a><br>
<a href="https://stackoverflow.com/questions/5739611/differences-between-abstract-factory-pattern-and-factory-method">https://stackoverflow.com/questions/5739611/differences-between-abstract-factory-pattern-and-factory-method</a></p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>《Code Complete》 设计检查清单</title>
    <url>/ch_05_design_checklist/</url>
    <content><![CDATA[<p>设计清单，帮助你在设计完成后，确认自己的设计是否理想，合适。</p>
<h1 id="设计实践"><a class="header-anchor" href="#设计实践">#</a>设计实践</h1>
<ul>
<li>[ ] 你是否进行过<a href="/ch_05_design_in_construction/#%E8%BF%AD%E4%BB%A3">迭代</a>，选择多次尝试中最好的设计而不是第一次尝试就选定了设计？</li>
<li>[ ] 你是否尝试过多种不同的方式 <a href="/ch_05_design_in_construction/#%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B">拆解</a> 系统，并确认那种方式最好？</li>
<li>[ ] 你是否通过使用了<a href="/ch_05_design_in_construction/#%E8%87%AA%E4%B8%8A%E8%80%8C%E4%B8%8B%E7%9A%84%E8%AE%BA%E6%8D%AE">自上而下</a> 和 <a href="/ch_05_design_in_construction/#%E8%87%AA%E4%B8%8B%E8%80%8C%E4%B8%8A%E7%9A%84%E8%AE%BA%E6%8D%AE">自下而上</a> 的方法处理设计问题？</li>
<li>[ ] 你是否对系统中存在的风险或不熟悉的部分进行了 <a href="/ch_05_design_in_construction/#%E5%AE%9E%E9%AA%8C%E5%8E%9F%E5%9E%8B%E5%88%B6%E4%BD%9C">实验原型制作</a>，用以回答特定的问题并使用了最少的一次性代码？</li>
<li>[ ] 你的设计是否已经被其他人正式或非正式的审查过？</li>
<li>[ ] 你是否已经将设计推进到了实现起来显而易见的<a href="/ch_05_design_in_construction/#%E5%A4%9A%E5%B0%91%E8%AE%BE%E8%AE%A1%E5%B0%B1%E8%B6%B3%E5%A4%9F%E4%BA%86%EF%BC%9F">程度</a>？</li>
<li>[ ] 你是否使用 <a href="/ch_05_design_in_construction/#%E8%AE%B0%E5%BD%95%E4%BD%A0%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%B7%A5%E4%BD%9C">记录了你的设计工作</a> ？</li>
</ul>
<h1 id="设计目标"><a class="header-anchor" href="#设计目标">#</a>设计目标</h1>
<ul>
<li>[ ] 设计是否充分解决了在架构级别确认并推迟的问题？</li>
<li>[ ] 设计是否有对系统进行分层？</li>
<li>[ ] 你对于系统拆分为子系统，Packakge 和类的方式是否满意？</li>
<li>[ ] 你对于类进一步拆分成函数的方式是否满意？</li>
<li>[ ] 设计是否有限制类之间的交互数量，并达到最少？</li>
<li>[ ] 设计是否让子系统和类可以在未来复用到其他的系统中？</li>
<li>[ ] 设计是否让程序易于维护？</li>
<li>[ ] 设计是否精益（Lean）？它的所有部分都是必要存在的吗？</li>
<li>[ ] 设计是否使用了标准的方案，并避免了外部的，难以理解的元素的使用？</li>
<li>[ ] 总体而言，该设计是否有助于最大程度的减少 <a href="/ch_05_design_in_construction/#%E6%9C%AC%E8%B4%A8%E5%92%8C%E6%84%8F%E5%A4%96%E7%9A%84%E5%A4%8D%E6%9D%82%E6%80%A7">本质和意外的复杂性</a></li>
</ul>
]]></content>
      <tags>
        <tag>工程实践</tag>
      </tags>
  </entry>
  <entry>
    <title>《Computer Networks and Internets》 Ch 05 信息传输概览</title>
    <url>/ch_05_overview_of_data_communications/</url>
    <content><![CDATA[<h1 id="Introduction"><a class="header-anchor" href="#Introduction">#</a>Introduction</h1>
<p>这一章主要是分析通过物理媒介进行信息传递的方法，例如线，光和无线电波等。这些方式在一些细节上不同，但所有方法的基本原理是相通的。</p>
<h1 id="The_Essence_Of_Data_Communications"><a class="header-anchor" href="#The_Essence_Of_Data_Communications">#</a>The Essence Of Data Communications</h1>
<p>数据通信是物理，数学和电气工程三个学科的混合领域。</p>
<ol>
<li>物理：信息的传输依赖于物理媒介</li>
<li>数学：信息需要数字化</li>
<li>电气工程：数据传输需要构建现实中的通信系统</li>
</ol>
<h1 id="Motivation_And_Scope_Of_The_Subject"><a class="header-anchor" href="#Motivation_And_Scope_Of_The_Subject">#</a>Motivation And Scope Of The Subject</h1>
<p>在数据通信领域有三个重要的点，他们定义了数据通信的一些领域</p>
<ol>
<li>
<p>传输的数据可以是任意类型的</p>
<p>传输的数据并不一定是存储在计算机中的<code>bit</code>数据，也可以是从现实世界中获取的信息，如音频和视频。</p>
</li>
<li>
<p>数据的传输依赖于物理系统</p>
<p>数据是基于物理现象来传输的，例如电，电磁波。了解为什么这些物理现象可以被用来传输数据是很重要的。另外也需要理解物理系统的限制，因为这些限制引发的问题和这些问题如何被检测并解决。</p>
</li>
<li>
<p>多个来源的信息可以共享基础媒介来传输</p>
<p>媒介共享在计算机网络中是一个重要角色。了解哪些基础设施是可以被共享的，共享他们的优缺点，以及基于共享而设计的通信模型是很重要的。</p>
</li>
</ol>
<h1 id="The_Conceptual_Pieces_Of_A_Communications_System"><a class="header-anchor" href="#The_Conceptual_Pieces_Of_A_Communications_System">#</a>The Conceptual Pieces Of A Communications System</h1>
<p>每一个来源都需要一些方法来获取信息，调整信息为用于传播的模式，使用共享的物理媒介来传输信息。同时也需要一些方法从物理媒介中抽取出每条信息的目的地地址，并将信息传送给目标地址。整个过程如下图所示：</p>
<p><img src="/ch_05_overview_of_data_communications/2019-11-25-23-24-24.png" alt="数据通信简单模型"></p>
<p>上图是一个非常简化的模型，在实际操作中，在传输数据前，必须对数据进行数字化，也需要加入一些额外的信息防止错误发生。如果考虑到隐私，可能还需要进行加密。在使用共享媒介时，还要保证有方法可以分辨出每条信息且他们不会相互干扰。</p>
<p>为了解释数据通信的每个部分，工程师们制订了一个概念框架来说明通信系统中的每个小主题是如何联系在一起的，概念框架如下图所示：</p>
<p><img src="/ch_05_overview_of_data_communications/2019-11-25-23-28-26.png" alt="概念框架"></p>
<h1 id="The_Subtopics_Of_Data_Communications"><a class="header-anchor" href="#The_Subtopics_Of_Data_Communications">#</a>The Subtopics Of Data Communications</h1>
<p>上一节中的概念框架图中的每一部分都代表了数据通信中的一个小主题。这一节中简单介绍了图中的一些术语，之后的几章中会在对每一部分进行详细说。</p>
<ol>
<li>
<p><code>数据来源(Information Sources)</code>可以是模拟数据或者数字电路。这一部分的关键内容包括信号的特征（<code>振幅(Amplitude)</code>，<code>频率(Frequency)</code>，<code>相位(Phase)</code>），周期性与非周期性，以及模拟信息和数字信息的转换。</p>
</li>
<li>
<p><code>信源编码与解码(Source Encoder and Decoder)</code>。一旦信息被数字化后，信息就可以被转换，这一部分的关键内容包括数据压缩以及压缩后对于传输的影响</p>
</li>
<li>
<p><code>加密与解密(Encryptor and Decryptor)</code>。为了保护信息和保证其可信度，在信息传送前需要进行加密，在接收后需要解密。这一部分的关键内容包括密码学技术与算法。</p>
</li>
<li>
<p><code>信道编码与解码(Channel Encoder and Decoder)</code>。信道编码是用来检测也纠正传输错误。这一部分的关键内容包括检测和限制错误，以及实际应用的技术，如奇偶校验(parity checking)等。</p>
</li>
<li>
<p><code>复用与解复用(Multiplexor and Demultiplexor)</code>。复用是指让多个来源的信息结合在一起并保证可以使用同一个媒介传输的方式。这一部分的关键内容包括介绍同时复用以及分时复用的技术。</p>
</li>
<li>
<p><code>调制与解调(Modulator and Demodulator)</code>。调制是指让用电磁波传递信息的方式。这一部分的关键内容包括模拟信息与数字信息的调制方式，用来进行调制与解调的设备。</p>
</li>
<li>
<p><code>物理通道与传输(Physical Channel and Transmission)</code>。 这一部分的关键内容包括传输媒介与传输方式（如并行，串行），带宽，噪声，干扰，信道容量，</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《Code Complete》 第五章：构建中的设计</title>
    <url>/ch_05_design_in_construction/</url>
    <content><![CDATA[<p>在小型项目中，许多 <em>理论上处于编码外</em> 的活动也会被认为是编码。在一些较大的项目中，架构仅解决了系统级的问题，而将许多设计工作留在编码部分。在真正的大型项目中，前期的设计可能会足够的详细，让编码真正的只需要关心编码本身，但这种详细的设计实际上很少会出现。</p>
<p>设计可以有许多不同的形式，可以是：</p>
<ul>
<li>用伪代码编写类接口</li>
<li>绘制类关系图</li>
<li>询问另一个程序员哪种设计模式更合适</li>
</ul>
<p>但无论如何，将设计视作为一项明确的活动都可以让你从中受益。</p>
<h1 id="5_1_设计挑战"><a class="header-anchor" href="#5_1_设计挑战">#</a>5.1 设计挑战</h1>
<p>短语“软件设计（Software Design）”是指将计算机软件规范转变为可操作软件的方案的构思、发明或设计。设计是将需求与编码和调试联系起来的活动。</p>
<p>良好的顶层设计提供了一个可以安全地包含多个较低层设计的结构。</p>
<p>设计中包含有许多的挑战，本小节将概述这些挑战。</p>
<h2 id="设计是一个棘手问题"><a class="header-anchor" href="#设计是一个棘手问题">#</a>设计是一个棘手问题</h2>
<p><strong>棘手问题（Wicked Problem）</strong> 的定义：如果一个问题，只能通过解决它或者解决它的一部分才能定义，那这个问题就是一个棘手问题。</p>
<p>棘手问题一定程度上存在一些悖论：你在无法定义问题的时候，又怎么能给出一个合理的答案？</p>
<p>所以对于棘手问题，你必须先<strong>解决</strong>它一次，然后获得它的定义，再真正给出有效的解决方案。</p>
<div class="note info simple"><p>所以软件开发，不能空想。在思考到一定程度后，你就需要动手去做。</p>
</div>
<p>棘手问题的一个现实例子：<a href="https://zh.wikipedia.org/zh-cn/%E5%A1%94%E7%A7%91%E9%A6%AC%E6%B5%B7%E5%B3%BD%E5%90%8A%E6%A9%8B">塔科马海峡吊桥 </a><br>
在桥梁设计的时候，主要考虑的因素是桥梁的强度要足以支撑其负载，这个设计要素在建造时也满足了。但建造后不久，桥梁因为大风引起桥身摆动，最终导致共振而坍塌。<br>
在桥梁坍塌之前，工程师并不知道需要考虑空气动力学所引发的共振问题。而只有通过真正建造了这个桥梁（第一次解决问题），工程师们才了解问题中其他需要额外考虑的因素，从而建造起另一种至今仍然矗立的桥梁（第二次真正有效的解决问题）。</p>
<h2 id="设计是一个马虎过程（即使它产生了整洁的结果）"><a class="header-anchor" href="#设计是一个马虎过程（即使它产生了整洁的结果）">#</a>设计是一个马虎过程（即使它产生了整洁的结果）</h2>
<p>最终的软件设计应该看起来组织良好且干净，但用于得到这个设计的过程却往往不如最终结果那么整洁。</p>
<p>设计的过程草率的一个原因是，在设计的过程中，你会犯许多的错误，并走进很多死胡同。而这种犯错的过程是合理的，因为在设计过程中犯错并纠正，要比在编码过程中发现错误并纠正，成本便宜的多。正因为一个良好的解决方案和一个糟糕的解决方案之间的差异很小，所以设计过程是草率的，它需要不断的试错。</p>
<p>设计的过程草率的另一个原因是，在设计过程中，你很难知道设计是否“足够好”：你的设计需要包含多少细节，你的设计应该多大程度描述开发中的约束？由于设计是开放式的，所以“设计什么时候足够好” 这个问题的答案，往往是“当你没时间的时候”。</p>
<h2 id="设计是关于权衡和优先级的"><a class="header-anchor" href="#设计是关于权衡和优先级的">#</a>设计是关于权衡和优先级的</h2>
<p>在理想的世界中，每个系统都可以立即运行，不需要消耗存储空间，不占用网络带宽，不会包含任何错误，没有任何的构建成本。但在现实世界中，设计师工作的一个关键部分是权衡上述这些相互竞争资源并在其中之间取得平衡。</p>
<p>如果快速响应速度比最小化开发时间更重要，那么设计人员将选择一种设计。如果最大限度地缩短开发时间更为重要，那么优秀的设计师会精心设计另一个不同的设计。</p>
<h2 id="设计与限制有关"><a class="header-anchor" href="#设计与限制有关">#</a>设计与限制有关</h2>
<p>设计的一部分目的是创造可能性，而另一部分则是限制可能性。</p>
<p>因为我们没有无限的资源和时间，所以我们必须简化解决方案，最终给出改进后的解决方案。</p>
<h2 id="设计是不确定的"><a class="header-anchor" href="#设计是不确定的">#</a>设计是不确定的</h2>
<p>如果你派三个人去设计同一个程序，他们很容易带着三种截然不同的设计回来，而每一种设计都是完全可以接受的。</p>
<h2 id="设计是一个启发性的过程"><a class="header-anchor" href="#设计是一个启发性的过程">#</a>设计是一个启发性的过程</h2>
<p>因为设计是一个启发性的过程，所以并不是每一步都能产生可预期的结果，它往往依靠“经验法则” 和 “有时有效的尝试”。</p>
<p>设计涉及反复试验。在一项工作中效果良好的设计工具或技术可能在下一个项目中效果不佳。</p>
<p>没有任何工具适合所有情况。</p>
<h2 id="设计是自然生长的"><a class="header-anchor" href="#设计是自然生长的">#</a>设计是自然生长的</h2>
<p>设计并不是直接从某人的大脑中形成的。他们是通过设计评审、非正式的讨论、编码的经验以及修改代码的经验来逐步发展和改进的。</p>
<p>所有系统在最初的开发过程中都会经历一定程度的设计更改，然后随着扩展到更高版本，它们通常会发生更大程度的更改。</p>
<h1 id="5_2_关键设计概念"><a class="header-anchor" href="#5_2_关键设计概念">#</a>5.2 关键设计概念</h1>
<p>好的设计取决于一些关键概念的理解，本小杰将讨论这些关键的设计概念。</p>
<h2 id="软件的主要技术要求：管理复杂性"><a class="header-anchor" href="#软件的主要技术要求：管理复杂性">#</a>软件的主要技术要求：管理复杂性</h2>
<h3 id="本质和意外的复杂性"><a class="header-anchor" href="#本质和意外的复杂性">#</a>本质和意外的复杂性</h3>
<div class="note info simple"><p>本节中的内容，都是书引用 Brooks（人月神话作者）的观点</p>
</div>
<p>Brooks 认为，软件开发之所以变得困难，是因为两类不同的问题——本质问题（Essential Problem）和意外问题（Accidental Problem）。</p>
<p>本质和偶然这两个术语，来自于亚里士多德的哲学：</p>
<ul>
<li>本质属性是一个事物成为该事物所必须具备的属性。汽车必须有发动机、车轮和车门才能成为汽车。</li>
<li>意外属性是一个事物恰好具有的属性，这些属性并不真正影响该事物是否是它本身。汽车可以配备 V8、涡轮增压 4 缸发动机或其他类型的发动机，无论细节如何，它都是汽车。</li>
</ul>
<p>Brooks 认为，软件中的主要意外问题已经被解决了：</p>
<ul>
<li>与编程语言相关的困难，在从汇编语言到高级语言转换的过程中被解决了</li>
<li>分时操作系统的出现，解决与非交互式计算机相关的意外困难</li>
</ul>
<p>同时 Brooks 认为，计算机领域剩下的本质问题的解决会越来越困难。因为计算机必须与复杂、无序的现实世界进行交互。</p>
<ul>
<li>即使我们使用自然语言来进行编程，编程仍然会很困难，因为准确的描述现实世界是如何运作的也存在挑战。</li>
<li>随着软件规模越来越大，要解决的现实问题也越来越大，与现实世界的交互也就越来越复杂，而这又增加了要解决的本质问题</li>
</ul>
<p>所有的问题都来自于复杂性，复杂性也有本质复杂性和偶然复杂性。</p>
<div class="note info simple"><p><a href="/unix_bian_cheng_yi_shu">Unix 编程艺术</a> 中也有类似的讨论：<a href="/di_13_zhang_fu_za_du%EF%BC%9Ajin_ke_neng_jian_dan%EF%BC%8Cdan_bie_jian_dan_guo_le_tou/#13_1_3_%E6%9C%AC%E8%B4%A8%E7%9A%84%E3%80%81%E9%80%89%E6%8B%A9%E7%9A%84%E5%92%8C%E5%81%B6%E7%84%B6%E5%9C%B0%E5%A4%8D%E6%9D%82%E5%BA%A6">13.1.3 本质的、选择的和偶然地复杂度</a></p>
</div>
<h3 id="管理复杂性的重要性"><a class="header-anchor" href="#管理复杂性的重要性">#</a>管理复杂性的重要性</h3>
<p>当软件项目调查报告项目失败的原因时，他们很少将技术原因确定为项目失败的主要原因。项目失败最常见的原因是需求不明确、规划不善或管理不善。</p>
<p>但是，当项目因主要技术原因而失败时，原因通常是不受控制的复杂性。</p>
<ul>
<li>该软件变得如此复杂，以至于没有人真正知道它的用途。</li>
<li>当一个项目达到没有人完全理解某一领域的代码更改将对其他领域产生的影响时，进度就会陷入停滞。</li>
</ul>
<p>管理复杂性是软件开发中最重要的技术主题。甚至，软件的首要技术要求必须是管理复杂性。</p>
<p>Dijkstra（1972 年图灵机获得者）说没有人的大脑大到足以容纳一个完整的现代计算机程序。因此作为开发者，不应当将记住一个软件所有的细节作为目标。计算机程序的构建模式，应当可以让开发者可以在一段时间内安全的只关注于其中的一小部分。作为开发者的目标，应当是减少自己在任何时刻必须考虑的程序量。</p>
<div class="note icon-padding simple"><i class="note-icon fas fa-quote-left"></i><p>One symptom that you have bogged down in complexity overload is when you find yourself doggedly applying a method that is clearly irrelevant, at least to any outside observer. It is like the mechanically inept person whose car breaks down—so he puts water in the battery and empties the ashtrays.<br>
—— P. J. Plauger</p>
</div>
<p>在软件架构层面，可以通过将系统划分为子系统来降低问题的复杂性。人类更容易理解几条简单的信息，而不是一条复杂的信息。所有软件设计的目标都是将复杂的问题分解为几个简单的部分。子系统越独立，开发者就越能安全地一次专注于一处的复杂性上。</p>
<h3 id="如何应对复杂性"><a class="header-anchor" href="#如何应对复杂性">#</a>如何应对复杂性</h3>
<p>出现 <em>开发成本过高，效率低下</em> 的设计，通常是如下三个原因：</p>
<ul>
<li>对简单问题用了复杂的解决方案</li>
<li>对复杂问题用了简单但错误的解决方案</li>
<li>对复杂问题用了不恰当的复杂的解决方案</li>
</ul>
<p>现代软件本质上是复杂的，无论你多么努力，你最终都会遇到现实世界问题本身固有的某种程度的复杂性。这建议采用双管齐下的方法来管理复杂性：</p>
<ul>
<li>最大程度减少任何开发者在处理任务问题时必须处理的复杂性</li>
<li>防止不必要的意外复杂性增长</li>
</ul>
<p>一旦了解了软件设计中，其他的技术目标相对于管理复杂性都是次要的，许多设计考虑因素都会变得简单。</p>
<h2 id="设计的理想特征"><a class="header-anchor" href="#设计的理想特征">#</a>设计的理想特征</h2>
<p>高质量的设计具有几个一般特征。如果你的设计能实现所有这些目标，那这个设计就是一个非常好的设计。有些目标与其他目标相矛盾，但这就是设计的挑战——从相互竞争的目标中创建一套良好的平衡。</p>
<div class="note icon-padding simple"><i class="note-icon fas fa-quote-left"></i><p>When I am working on a problem I never think about beauty. I think only how to solve the problem. But when I have finished, if the solution is not beautiful, I know it is wrong.<br>
—— R. Buckminster Fuller</p>
</div>
<p>以下是一些高质量设计的特征：</p>
<ul>
<li>最小复杂度：设计的主要目标应该是最小化复杂性。避免做出“聪明”的设计，“聪明”的设计通常很难理解。相反，要做出“简单”和“易于理解”的设计。</li>
<li>易于维护：易于维护意味着解决方案是为未来维护这段代码的程序员而设计。不断想象维护的程序员会询问的关于你正在编写的代码的问题。将维护程序员视为你的受众，然后你编写的系统就会不言自明。</li>
<li>松耦合：松耦合意味着设计时应将程序不同部分之间的连接保持在最低限度。最小连接性可以最大限度地减少集成、测试和维护期间的工作。</li>
<li>可扩展性。可扩展性意味着你可以增强系统而不会对基本结构造成破坏。你可以更改系统的一部分而不影响其他部分。对于最有可能发生的变化，在设计中已经考虑，因此这些变化对系统造成的伤害最小。</li>
<li>可重复使用性：可重用性意味着你的系统可以在其他系统中重用它的各个部分。</li>
<li>高扇入（High fan-in）：高扇入意味着系统被设计为充分利用系统较低级别的 Utilities 类。</li>
<li>中低扇出（Low-to-medium fan-out）：中低扇出意味着每一个类都使用中低数量的其他类。如果一个类使用 7 个以上的其他类，则说明该类存在高扇出，即该类过于复杂。</li>
<li>可移植性：可移植性意味着系统可以轻松地将其移动到另一个环境中。</li>
<li>精益（Leanness）：精益意味着设计的系统没有额外的部件。伏尔泰说，一本书完成时，不是不能再添加任何东西，而是不能再删除任何东西。</li>
<li>分层（Stratification）：分层意味着保持各层次的解耦。在设计好的系统中，你应当可以在某一个级别查看细节，而不需要深入到其他的级别中。
<ul>
<li>例如，如果您正在编写一个必须使用大量旧的、设计不良的代码的现代系统，请在新系统中编写一个负责与旧代码进行交互的层。设计该层，使其隐藏旧代码的低质量，为新层提供一组一致的 API。然后让系统的其余部分使用这些新类而不是旧代码。</li>
</ul>
</li>
<li>标准技术：一个系统越依赖特异的实现。对于第一次尝试理解它的人来说就越令人生畏。尝试通过使用标准化、通用的方法来让整个系统给人带来熟悉的感觉。</li>
</ul>
<h2 id="设计的层次"><a class="header-anchor" href="#设计的层次">#</a>设计的层次</h2>
<p>软件系统需要在几个不同的细节层次上进行设计。有些设计技术适用于所有级别，有些仅适用于一两个级别。</p>
<p>系统的第一层次为系统本身，第二层次为组成系统的子系统或 Packages，第三层次是组成 Packages 的类，第四层次是组成类的方法和数据，第五层次是类内部的方法设计。如下图所示：<br>
<img src="/ch_05_design_in_construction/image-20231003103542.png" alt="系统设计层次"></p>
<h3 id="第一层次：_软件系统"><a class="header-anchor" href="#第一层次：_软件系统">#</a>第一层次： 软件系统</h3>
<p>设计的第一层次是整个系统，在这一层次中通常不会有太多的设计。</p>
<h3 id="第二层次：子系统或包"><a class="header-anchor" href="#第二层次：子系统或包">#</a>第二层次：子系统或包</h3>
<p>第二层次的设计目标主要是识别主要的子系统。该级别的设计活动是决定如何将程序划分为几个主要的子系统，以及定义每个子系统在何种程度上允许使用其他的子系统。</p>
<ul>
<li>对于需要持续几周的项目，通常都需要进行这个级别的划分。</li>
</ul>
<p>在此级别中，定义各个子系统如何通信的规则特别重要。如果所有子系统都可以与所有其他子系统通信，那么就失去将它们分开的好处。通过限制通信使每个子系统变得有意义。</p>
<p>只有当两个子系统“需要知道”彼此时才放开通信，而且这个 “需要知道” 最好也有个充足的理由。如果没法确定是否应该放开通信，在一起开始指定严格的通信标准，并在实践中逐步放开，也比一开始任意通信，然后在有数百个子系统间通信时再尝试收紧要好。</p>
<p>为了使连接易于理解和维护，最好选择简单的子系统间的关系。</p>
<ul>
<li>最简单的关系是一个子系统调用另一个子系统的接口。</li>
<li>一种更复杂的关系是让一个子系统包含另一个子系统的类。</li>
<li>最复杂的关系是一个子系统中的类继承另一个子系统中的类。</li>
<li>不应该出现循环依赖，即 A 依赖 B，B 依赖 C，C 依赖 A 的情况出现。</li>
</ul>
<h3 id="第三层次：类"><a class="header-anchor" href="#第三层次：类">#</a>第三层次：类</h3>
<p>这个层次的主要设计活动，是确保已有的子系统都已经分解到了足够详细的程度（详细定义了每一个类暴露的接口），以便开发者可以用单独的类来实现其中的一部分。</p>
<p>如果一个项目很大，那么第三层次的划分与第二层次的划分将有明显的差异。而如果项目很小，则可能跳过第二层次的划分，直接进入第三层次。</p>
<h3 id="第四层次：函数（Routine）"><a class="header-anchor" href="#第四层次：函数（Routine）">#</a>第四层次：函数（Routine）</h3>
<p>在第三层次中，应当完成定义每一个类暴露的接口。而在这一层次，则应该定义类中所有的函数。</p>
<p>定义类中所有函数的过程，通常可以让开发者更好的理解类的接口，并对接口进行相应的调整（回到第三层次）。</p>
<h3 id="第五层次：函数的内部设计"><a class="header-anchor" href="#第五层次：函数的内部设计">#</a>第五层次：函数的内部设计</h3>
<p>在这一层次中，开发者需要设计每一个函数的实现，在设计过程中会进行编写伪代码，查找算法等一系列活动。</p>
<p>第五层次的设计总是会完成的（毕竟你需要写出代码），尽管设计有时是无意识地、糟糕地完成，而不是有意识地、良好地完成。</p>
<h1 id="5_3_用启发式的方式进行设计"><a class="header-anchor" href="#5_3_用启发式的方式进行设计">#</a>5.3 用启发式的方式进行设计</h1>
<p>程序员往往倾向于算法“做 A，B，C， 然后你会得到 X，Y，Z“，当一样的步骤产生了不一样的结果后，程序员会感到恼火。这种对确定性的渴望，非常适合于编程的过程。</p>
<p>但在软件设计时，则完全不同。由于设计是不确定的，因此熟练应用一组有效的启发式方法是优秀软件设计的核心活动。</p>
<div class="note icon-padding simple"><i class="note-icon fas fa-quote-left"></i><p>算法是一组用于执行特定任务的明确定义的指令。算法是可预测的、确定性的，并且不受偶然性的影响。算法会告诉你如何从 A 点到 B 点：不走弯路，不绕道到 D、E 和 F 点。<br>
———— <a href="/ch_02_metaphors_for_a_richer_understanding_of_software_development">《Code Complete》第二章：丰富软件开发理解的隐喻</a></p>
</div>
<div class="note icon-padding simple"><i class="note-icon fas fa-quote-left"></i><p>启发式是一种帮助您寻找答案的技术。其结果可能会受到偶然性的影响，因为启发式方法只告诉您如何查看，而不是告诉您要查找什么。它不会告诉你如何从 A 点直接到达 B 点；它甚至可能不知道 A 点和 B 点在哪里。<br>
———— <a href="/ch_02_metaphors_for_a_richer_understanding_of_software_development">《Code Complete》第二章：丰富软件开发理解的隐喻</a></p>
</div>
<p>以下是一些启发式的进行设计的方法：</p>
<div class="note info simple"><p>以下是一些进行软件设计时，可以考虑的方向，期望这些方向可以启发你对于软件设计的思考。<br>
这些方向不是相互冲突的，相反，你可以将他们结合起来思考</p>
</div>
<h2 id="寻找现实世界的物体进行参考"><a class="header-anchor" href="#寻找现实世界的物体进行参考">#</a>寻找现实世界的物体进行参考</h2>
<p>设计的第一种也是最流行的方案就是“按字面意义的”进行面向对象设计，即识别现实世界并设计对象。</p>
<p>识别的步骤为：</p>
<ul>
<li>识别对象及其属性</li>
<li>确定可以对每个对象执行哪些操作</li>
<li>确定每个对象可以对其他对象执行哪些操作</li>
<li>确定每个对象的哪些部分对其他对象是可见的——哪些部分是公共的，哪些部分是私有的</li>
<li>定义每个对象的公共接口。</li>
</ul>
<h2 id="形成一致的抽象"><a class="header-anchor" href="#形成一致的抽象">#</a>形成一致的抽象</h2>
<p>抽象是指在理解概念的同时安全地忽略其某些细节的能力——在不同级别处理不同的细节。从复杂性的角度来看，抽象的主要好处是它允许您忽略不相关的细节。大多数现实世界的对象已经是某种抽象，比如房子是窗户、门、壁板、电线、管道、绝缘材料以及组织它们的特定方式的抽象。</p>
<p>在现实生活中，人不断的在使用抽象。如果出门时你要进行的不是拧把手，而是要处理木纤维，清漆分子和钢分子，那你将很难出门。</p>
<p>但开发者软件有时会在木纤维、清漆分子和钢分子级别构建系统（没有进行合理的抽象），这就使得系统过于复杂并且难以管理。</p>
<h2 id="封装实现细节"><a class="header-anchor" href="#封装实现细节">#</a>封装实现细节</h2>
<p>封装是抽象的延续： <strong>抽象</strong> 说，“你可以以高维度的方式（忽略细节）观察一个物体。 <strong>封装</strong> 说：“此外，您不允许以任何其他维度观察对象。你现在看到的一切就是你被允许看到的一切”</p>
<h2 id="继承"><a class="header-anchor" href="#继承">#</a>继承</h2>
<p>继承简化了编程，因为开发者可以编写通用的方法来处理通用属性的任何内容，然后编写特定方法来处理特定的操作。</p>
<h2 id="隐藏信息"><a class="header-anchor" href="#隐藏信息">#</a>隐藏信息</h2>
<p>在结构化设计中，“黑匣子”的概念来自于信息隐藏。</p>
<p>在面向对象设计中，信息隐藏产生了封装和模块化的概念，并与抽象的概念相关联。</p>
<p>信息隐藏的特点是软件开发人员将“秘密”、设计和实现决策隐藏在一个地方，不让程序的其余部分看到。</p>
<p>信息隐藏是对隐藏复杂性的强调。</p>
<h3 id="秘密和隐私权"><a class="header-anchor" href="#秘密和隐私权">#</a>秘密和隐私权</h3>
<p>设计类的一项关键任务是决定其中的哪些信息应该在类之外为人所知，而哪些信息应该保密。</p>
<ul>
<li>一个类可能使用 25 个函数，并且仅公开其中 5 个，在内部使用其他 20 个。</li>
<li>类的接口应该尽可能少的展示其内部工作原理。</li>
</ul>
<h3 id="隐藏细节的一个示例"><a class="header-anchor" href="#隐藏细节的一个示例">#</a>隐藏细节的一个示例</h3>
<p>比如程序中需要为每一个对象分配一个唯一 ID。一个最简单的思路是在全局变量中定义一个 <code>g_maxId</code> 表示当前最高的 ID，然后在每个对象的构造函数中，使用 <code>id = ++ g_maxId</code>。但这个实现可能会遇到如下的麻烦：</p>
<ol>
<li>
<p>ID 的创建方式变更<br>
如果对于 ID 的分配有了新需求，比如需要为特殊的对象保留 ID 范围，或者需要使用非连续 ID 来提高安全性，或需要重用已经被销毁的对象的 ID。<br>
此时就需要修改 <code>id = ++ g_maxId</code> 语句，而它遍布在了整个程序各种对象的构造函数中，因此修改会很麻烦。</p>
<p>针对该方法的解决方法可以是，使用一个全局的函数来分配 ID，如 <code>id = GetNewId()</code>，然后在各个对象的构造函数中调用该函数。这样，如果 ID 的分配方式变更，只需要修改 <code>GetNewId()</code> 函数即可。</p>
<p>这样的实现就隐藏了信息，隐藏了 “ID” 是如何分配的信息。</p>
</li>
<li>
<p>ID 的类型发生了变化</p>
<p>如果 ID 的类型从 <code>int</code> 变成了 <code>string</code>，那么即使存在 <code>GetNewId</code> 函数也不能解决问题，因为整个程序中的 <code>id</code> 变量都是 <code>int</code> 类型的，因此修改范围仍然是整个程序。</p>
<p>针对该问题的解决方法是，定义一个类来表示 ID，而 ID 的具体实现细节则隐藏在该类中。这样，如果 ID 的类型发生了变化，只需要修改 ID 类即可。</p>
<p>这样的实现也隐藏了信息，隐藏了 “ID” 是什么类型的信息。</p>
</li>
</ol>
<div class="note info simple"><p>隐藏信息会让实现变得更加复杂，因此隐藏信息并不是一种万能的解决方案，而是一种权衡。</p>
</div>
<h3 id="两类秘密"><a class="header-anchor" href="#两类秘密">#</a>两类秘密</h3>
<p>有两类实现中的秘密需要被隐藏：</p>
<ul>
<li>复杂性：将复杂的实现隐藏起来，这样开发者的大脑就不需要关系它。除非开发者真的需要关心它（如要修改实现），它可以自己点进去。</li>
<li>变化：将可能发生变化的实现隐藏起来，这样当变化发生时，只需要修改隐藏的实现即可，即让变化的影响限定在了局部。</li>
</ul>
<h3 id="隐藏信息的障碍"><a class="header-anchor" href="#隐藏信息的障碍">#</a>隐藏信息的障碍</h3>
<p>在某些情况下，信息隐藏确实是不可能的，但信息隐藏的大多数障碍都是由于已经使用或习惯使用其他技术而面对要大规模修改时产生的心理障碍。如下是一些障碍：</p>
<ul>
<li>
<p>信息已经过度传播：信息隐藏的一个常见障碍是整个系统中信息已经过度分布，这里的信息可能是：</p>
<ul>
<li><em>硬编码</em>：整个系统中可能已经充满了诸如 100 这一的 magic number，导致修改的工作量很大。最好使用将 magic number 隐藏在一个常量之中。</li>
<li><em>交互模式</em>：如果整个系统的信息与 UI 交互强绑定，那么当交互模式发生变更时，几乎所有代码都必须重新修改。最好将用户的交互集中在单个的模块中。</li>
<li><em>全局变量</em>：假设程序中有一个大小为 100 的数组表示员工数据，整个程序都访问该数组进行数据的填充。在这种情况下，整个系统都强耦合了“大小为 100 的数组” 这个信息，一旦整个数据结构发生了变化，整个系统都需要变更。</li>
</ul>
</li>
<li>
<p>循环依赖：如果存在两个类 A 和 B，A 的函数调用 B 的函数，B 的函数调用 A 的函数。那么进行信息隐藏时，你很难进行测试：你最少得保证 A 和 B 的一部分已经准备就绪，否则你无法测试 A 和 B。</p>
</li>
<li>
<p>对类成员数据的恐惧：部分严谨的程序员，会将类成员数据看作为全局数据并避免它。但很大程度上，类成员数据的危害要比全局数据小得多。</p>
<blockquote>
<p>The road to programming hell is paved with global variables.</p>
</blockquote>
<p>全局数据主要有以下两个问题：</p>
<ul>
<li>一个函数在操作全局数据时，并不知道是不是有其他的函数也在操作它</li>
<li>一个函数在操作全局数据时，即使它知道其他函数也在操作它，但它仍然不知道其他函数在对这个数据进行什么操作。</li>
</ul>
<p>但类成员数据大程度上，减少了上述两个问题的发生，因为对一个数据的访问者被限定在这个类中。</p>
</li>
</ul>
<div class="note warning simple"><p>上述关于<em>类成员数据危害比全局数据小得多</em> 的结论前提是，整个程序使用 <em>设计良好</em>，<em>小型</em> 的类。如果整个程序都基于几个大型的类，那么类成员数据与全局数据的定义就变得非常模糊了</p>
</div>
<ul>
<li>对性能惩罚的恐惧：有些程序员认为，隐藏信息会导致性能下降，如封装了太多的类，会导致内存的频繁分配等等。但设计一个“隐藏信息”的系统，和设计一个“性能良好”的系统并不冲突，在设计系统时完全可以同时考虑这两个目标。</li>
</ul>
<div class="note info simple"><p>在你能够明确的测量出性能瓶颈前，对于性能的担忧都是过早的。此时你能做到，应该是尽可能的将代码模块化，以保证后续检测到性能瓶颈热区时，对它的修改不会影响到整个系统。</p>
</div>
<h3 id="隐藏信息的价值"><a class="header-anchor" href="#隐藏信息的价值">#</a>隐藏信息的价值</h3>
<p>信息隐藏是少数在实践中无可争议地证明其价值的理论技术之一，学术界在多年前就发现使用信息隐藏的大型程序比不使用信息隐藏的程序更容易修改。</p>
<p>针对信息隐藏的思考，与传统的面向对象的设计思路可能存在差异。</p>
<ul>
<li>在使用面向对象的思考模式时，你不会想到<em>应该将 ID 封装在 <code>IdType</code> 中，而不是直接使用 int</em>。如果声明了 <code>IdType</code>，常常意味着需要定义构造函数，析构函数，赋值运算符等等一系列代码，绝大部分的程序员会认为 “不，不值得仅仅为一个 ID 创造整个类，使用整数就好”</li>
<li>针对信息隐藏的思考，则会提出一个问题 “ID 的数据应该被其他模块感知吗？”，这个问题在面向对象思考模式时，是不会出现在程序员脑子中的。</li>
</ul>
<p>对于大部分的程序与，在设计类接口时，往往也只是考虑“外部接口怎么调用最方便”，这通常会导致类暴露越来越多的接口。而针对信息隐藏的思考，则会提出一个问题 “这个类需要隐藏什么？”，这个问题可以帮助类设计时将更多的操作隐藏在被暴露的接口中，而不泄露其具体实现。</p>
<p>询问自己“哪些信息需要被隐藏”，可以在各种帮助实现各种级别的良好设计：</p>
<ul>
<li>编码级别会更容易使用常量而不是硬编码的 Magic number</li>
<li>函数级别会更容易定义少量的、必须的形参</li>
<li>类级别会更容易设计出只暴露少量的、必须的接口</li>
<li>系统界别会更容易考虑各模块和子系统间的分解、连接策略。</li>
</ul>
<p>养成问自己 “我应该隐藏什么？”的习惯。你会惊讶地发现有多少困难的设计问题迎刃而解。</p>
<h2 id="确认可能发生变化的领域"><a class="header-anchor" href="#确认可能发生变化的领域">#</a>确认可能发生变化的领域</h2>
<p>一项针对伟大软件设计师的研究发现，他们的一个共同属性是预测变化的能力。</p>
<p>针对容易变化的程序，你应该遵循以下的步骤：</p>
<ol>
<li>确认可能会更改的部分：如果完全遵循 <a href="/ch_03_measure_twice,_cut_once_upstream_prerequisites/#3_4_%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87%EF%BC%9A%E9%9C%80%E6%B1%82">3.4 前期准备：需求</a>，那需求中应当包含有对可能发生变更的部分的描述。如果需求没有，则你需要在设计时重新审视。</li>
<li>将容易变更的部分与项目的其他部分分开：将容易变更的部分划分为自己的类或组件，以保证它和其他部分相独立</li>
<li>将容易变更的部分隔离：将容易变更的部分的接口设计为对潜在的变更不敏感。让这些变更内容局限在接口的实现内部，以保证外部并不会被变更影响。</li>
</ol>
<p>以下是一些容易发生变化的领域：</p>
<ol>
<li>商业规则：如费率，折扣策略等商业的规则极容易发生变化，应当将这些部分拆分出来（或者使用表驱动）</li>
<li>硬件依赖：将对硬件的依赖隔离在类或子模块中，以保证当程序迁移到新硬件时，不需要关注太多的依赖</li>
<li>编码困难的地方：如果你在设计或编写某段代码时，发现这一部分很难（无论难在设计，算法还是具体的实现），那就说明你很可能这一段写的不好，你很可能需要重新做。因此将这部分隔离开来，并尽可能减少它的不良设计。</li>
<li>状态变量：建议使用 Enum 表示状态，状态很可能会新增，如果使用类似 bool 值来表示状态，则再拓展时会发生问题。
<ul>
<li>使用函数来检测状态，而非直接对状态变量进行访问：使用函数来检测状态意味着可以进行更复杂的检测，如果你的状态检测与其他的数据相耦合，那么这个信息应当封装在函数中。</li>
</ul>
</li>
</ol>
<p>在考虑可能变更的部分时，也要将后续的程序质量提升（如增加线程安全机制，增加本地化机制）等考虑在内，这些地方存在潜在的优化，也意味着这些地方存在潜在的变化可能。</p>
<h2 id="保持松耦合"><a class="header-anchor" href="#保持松耦合">#</a>保持松耦合</h2>
<p>耦合描述了一个类或函数与其他类或函数交互的紧密程度。耦合的概念同样适用于类和函数，因此在本节中，将使用 <em>模块</em> 一词来指代类和函数。</p>
<p>如果模块之间的耦合足够松散，那么一个模块可以很容易的被其他模块所使用：</p>
<ul>
<li><code>sin(float angles)</code> 是足够松耦合的，调用者知道只需要传入一个表示角度的 float 值即可</li>
<li><code>InitVars(var 1,var 2, ...，var N)</code> 这样的函数就是紧耦合的，因为调用者需要知道这些需要传入的形参究竟是什么</li>
</ul>
<h3 id="耦合标准"><a class="header-anchor" href="#耦合标准">#</a>耦合标准</h3>
<p>以下是几个评估模块之间耦合程度的标准：</p>
<h4 id="连接数量"><a class="header-anchor" href="#连接数量">#</a>连接数量</h4>
<p>模块之间的连接数量越多，两个模块就越耦合。</p>
<p>有 6 个形参的函数比有 1 个形参的函数与调用者的耦合紧。</p>
<p>有 30 个 public 函数的类比有 4 个 public 函数的类与调用者更耦合。</p>
<h4 id="可见性"><a class="header-anchor" href="#可见性">#</a>可见性</h4>
<p>模块之间的连接关系越明显耦合度越低。</p>
<p>比如 A 函数的处理依赖于 B 函数的处理。耦合最低的方式，是将 B 函数的输出作为 A 函数的输入；耦合最强的方式，是 B 函数修改一个全局变量，A 函数再处理这个全局变量。</p>
<div class="note info simple"><p>直观上，A 函数的输入依赖 B 函数的形参，是一个强耦合。<br>
但实际上这样的操作，让 A 并不需要关心 B 的具体实现，A 只要求其他函数提供满足要求的输入即可，提供输入的函数可以是 B，也可以是 C，所以实际上这样的做法是弱耦合。</p>
</div>
<h4 id="灵活性"><a class="header-anchor" href="#灵活性">#</a>灵活性</h4>
<p>灵活性是指模块间相互调用的便捷程度，灵活性越高，耦合越低。</p>
<p>灵活性一定程度上是通过封装来实现的，如 U 盘是电线和芯片的封装，它带来了与电脑的连接灵活性。</p>
<p>有的时候，封装则会降低灵活性质。如果有一个函数 <code>LookupVacationBenefit</code> 用以查询员工的假期福利，假期福利取决于员工的入职时间和工种。一种常见的做法是将函数的形参定义为 <code>employee</code> 类型，即传入一个员工类型，返回该员工的假期福利。看起来这个实现耦合度很低，因为它有足够低的 <a href="/ch_05_design_in_construction/#%E8%BF%9E%E6%8E%A5%E6%95%B0%E9%87%8F">连接数量</a>。</p>
<p>如果此时，有另一个模块（如招聘网站）想要查询假期福利，它有入职时长和工种的数据，但它并没有员工数据。此时它想要调用 <code>LookupVacationBenefit</code>，就只能实例化一个临时的 <code>employee</code> 对象。但这样可行的前提条件是，该模块需要了解 <code>LookupVacationBenefit</code> 的实现细节，即该函数只用了 <code>employee</code> 中的入职时长和工种两个数据，而没有用到其他的数据。这破坏了 <a href="/ch_05_design_in_construction/#%E5%8F%AF%E8%A7%81%E6%80%A7">可见性</a> 原则，即带来了高耦合。</p>
<div class="note info simple"><p>这个例子即为后续会提到的 <a href="/ch_05_design_in_construction/#%E8%AF%AD%E4%B9%89%E8%80%A6%E5%90%88">语义耦合</a></p>
</div>
<h3 id="耦合类型"><a class="header-anchor" href="#耦合类型">#</a>耦合类型</h3>
<p>模块间有以下几种耦合类型：</p>
<h4 id="简单参数数据耦合"><a class="header-anchor" href="#简单参数数据耦合">#</a>简单参数数据耦合</h4>
<p>如果两个模块间传递的数据都是原生数据类型，且所有数据都通过参数列表传递，则称为 <em>简单参数数据耦合（Simple-data-parameter coupling）</em>，这种耦合通过是 <strong>正常且可以接受的</strong>。</p>
<div class="note info simple"><p>因为这种耦合满足了 <a href="/ch_05_design_in_construction/#%E5%8F%AF%E8%A7%81%E6%80%A7">可见性</a>，只要参数的个数不要太多，就不会违背 <a href="/ch_05_design_in_construction/#%E8%BF%9E%E6%8E%A5%E6%95%B0%E9%87%8F">连接数量</a></p>
</div>
<h4 id="对象参数耦合"><a class="header-anchor" href="#对象参数耦合">#</a>对象参数耦合</h4>
<p>如果对象 1 要求对象 2 向其传递对象 3，则两个模块之间是 *对象参数耦合（Object-parameter coupling）*的。</p>
<p>这种耦合比 <a href="/ch_05_design_in_construction/#%E7%AE%80%E5%8D%95%E5%8F%82%E6%95%B0%E6%95%B0%E6%8D%AE%E8%80%A6%E5%90%88">简单参数数据耦合</a> 耦合程度更高，因为它要求对象 2 了解对象 3（对象 2 要负责对象 3 的创建）。</p>
<h4 id="语义耦合"><a class="header-anchor" href="#语义耦合">#</a>语义耦合</h4>
<p>如果一个模块不依赖另一个模块的成员，而是依赖其内部工作的一些结果，则这两个模块间是 <em>语义耦合（Semantic Coupling）</em>。</p>
<p>以下是一些语义耦合的例子：</p>
<ul>
<li><code>Module 1</code> 将一个 Magic Number 传递给 <code>Module 2</code>，以此告知 <code>Module 2</code> 应该要执行的操作。这个行为假设了 <code>Module 2</code> 能理解 <code>Module 1</code> 的 Magic Number。</li>
</ul>
<div class="note info simple"><p>如果传递的不是 Magic Number，而是枚举值，则不算是语义耦合</p>
</div>
<ul>
<li><code>Module 2</code> 在 <code>Module 1</code> 修改了全局变量后，使用该全局变量的值。这个行为假设了 <code>Module 1</code> 会修改全局变量，且 <code>Module 2</code> 能理解 <code>Module 1</code> 对全局变量的修改。</li>
<li><code>Module 1</code> 的接口声明中表示了调用 <code>routine</code> 函数前，必然会先调用 <code>initialize</code>。所以 <code>Module 2</code> 直接调用了 <code>routine</code> 而未调用 <code>initialize</code>。这个行为假设了 <code>Module 2</code> 能理解 <code>Module 1</code> 的接口声明，且 <code>Module 1</code> 的行为不会发生改变。</li>
<li><code>Module 1</code> 将 Object 传递给 <code>Module 2</code>时，因为 <code>Module 1</code> 知道 <code>Module 2</code> 仅使用 Object 的 7 个方法中的 3 个，所以它仅使用这 3 个方法所需的特定数据部分初始化 Object。一旦 <code>Module 2</code> 的行为发生了变化，则 <code>Module 1</code> 的行为也需要发生变化。</li>
<li><code>Module 1</code> 将 BaseObject 传递给 <code>Module 2</code>。<code>Module 2</code> 知道 <code>Module 1</code> 实际上正在向其传递 DerivedObject，所以它将 BaseObject 转换为 DerivedObject 并调用特定于 DerivedObject 的方法。一旦 <code>Module 1</code> 传递的实际数据发生了变化，则 <code>Module 2</code> 的行为也需要发生变化。</li>
</ul>
<p>语义耦合是危险的，因为当更改了一个模块的代码后，另一个模块的代码也需要相应的修改，而且这个修改往往不是编译器能检测到的（不是语法错误）。这就带来了潜在的 bug。</p>
<div class="note primary simple"><p>松耦合的核心是，一个模块提供了有效的，额外的抽象级别——一旦你编写了它，你就可以认为它是理所当然的。<br>
它降低了整个程序的复杂性，让您一次专注于一件事。<br>
如果使用模块需要你同时关注多件事情（了解其内部工作原理、修改全局数据、不确定的功能），则抽象能力就会丧失，模块帮助管理复杂性的能力也会降低或消除。</p>
</div>
<h2 id="寻找常见的设计模式"><a class="header-anchor" href="#寻找常见的设计模式">#</a>寻找常见的设计模式</h2>
<p>有些软件问题需要从第一原理出发，找寻出解决方案。但大部分的软件问题都与过去的问题类似，因此也可以用过去类似的解决方案来解决。这些过去的解决方案，就是 <strong>设计模式</strong>。</p>
<p>设计模式的好处在于：</p>
<ul>
<li>设计模式将常见问题的解决方案制度化，以减少错误：模式代表了解决常见问题的标准化方法，这些方法通常是多年来解决这些方法的智慧的积累。</li>
<li>设计模式通过提供现成的抽象来降低复杂度：如果你说“这个类通过单例模式创建实例”，项目中的其他程序员就能很快的理解这段代码的约束。</li>
<li>设计模式能带来启发性思考：熟悉设计模式，可以帮助设计者在架构时思考，现有的问题和哪个设计模式解决的问题更类似，使用熟悉的解决方案的组合要比从头制定解决方案简单的多，也更容易让别人理解。</li>
</ul>
<p>设计模式的潜在风险是：</p>
<ul>
<li>可能存在强行适配一个设计模式的情况：在某些情况下，稍微改变代码以符合公认的模式将提高代码的可理解性。但是，如果代码大范围改动而让强制让其看起来像标准模式，则会增加复杂性。</li>
<li>尝鲜：使用模式是因为想要尝试一种模式，而不是因为该模式是合适的设计解决方案。</li>
</ul>
<h2 id="其他启发性方法"><a class="header-anchor" href="#其他启发性方法">#</a>其他启发性方法</h2>
<h3 id="寻求高内聚"><a class="header-anchor" href="#寻求高内聚">#</a>寻求高内聚</h3>
<p>内聚是衡量一个类中的所有方法，或一个方法内所有的代码，是否是为了一个共同的目的而实现的。</p>
<p>如果一个类中的所有方法或一个方法内所有的代码，都是为了解决同一个问题，那么你的大脑就约容易记住这个类或方法。</p>
<h3 id="建立层次结构"><a class="header-anchor" href="#建立层次结构">#</a>建立层次结构</h3>
<p>层次结构（Hierarchy）是一种将信息分层的方式，将概念中最抽象，或最一般的信息放在层次结构的顶部，层次结构越底部就越详细、专用。</p>
<div class="note icon-padding simple"><i class="note-icon fas fa-quote-left"></i><p>另一个降低复杂性的尝试是，仅让系统的一个子集可以被使用：一个简单的公共系统向所有人开放，它由一个隐藏着的一个更大、更复杂的私有系统驱动。<br>
———— <a href="/system,_math_and_explosions">《System, Math and Explosions》 摘抄</a></p>
</div>
<p>使用层次结构是人类组织复杂信息的自然方式：当人画一个房子时，会先画房子的轮廓，再时门窗，然后是细节，而不是从一砖一瓦逐步画出整个房子。</p>
<p>层次结构是实现软件时有用的工具，因为它允许开发者仅关注当前需要关注的细节的级别。而且细节并没有完全消失，它们只是被推到了另一个层次，这样开发者就可以在需要的时候考虑它们，而不是一直考虑所有的细节。</p>
<h3 id="建立标准"><a class="header-anchor" href="#建立标准">#</a>建立标准</h3>
<p>将每个类的接口视为与程序其他部分交互的 <em>契约</em>，是一个很好的思考方向。</p>
<p>通常这种契约会类似：如果你承诺提供数据 x、y 和 z，并且承诺它们将具有特征 a、b 和 c，我承诺在约束 8 内执行操作 1、2 和 3， 9 和 10。</p>
<p>这种契约理论上对于管理程序的复杂性很有用，因为开发者可以安全的忽略任何非契约的行为。但实际上，契约本身的指定会很难。</p>
<div class="note info simple"><p>类似 OpenXR，Vulkan 都是 <em>契约</em></p>
</div>
<h3 id="为测试而设计"><a class="header-anchor" href="#为测试而设计">#</a>为测试而设计</h3>
<p>通过询问自己“我该怎么设计这个系统，以方便测试”可以引发有趣的思考过程。比如，这个问题会让你开始思考：</p>
<ul>
<li>是否需要将 UI 部分与系统的其他部分分开，以方便可以独立测试系统的其他部分？</li>
<li>是否需要规划每一个子系统，以保证每一个子系统对其他系统有最小依赖？</li>
</ul>
<p>为测试而设计，往往会产生更正式的类接口，在对于后续的维护是有益的。</p>
<h3 id="规避失败"><a class="header-anchor" href="#规避失败">#</a>规避失败</h3>
<p><em>Design Paradigms: Case Histories of Error and Judgment in Engineering (Petroski 1994)</em> 一书指出：许多重大桥梁故障的发生都是因为只关注了过去的成功，而没有充分考虑可能的故障。如果设计者仔细考虑桥梁可能失败的方式，而不是仅仅复制其他设计成功的部分，那么像 <a href="https://zh.wikipedia.org/zh-cn/%E5%A1%94%E7%A7%91%E9%A6%AC%E6%B5%B7%E5%B3%BD%E5%90%8A%E6%A9%8B">塔科马海峡吊桥 </a> 这样的失败是可以避免的。</p>
<p>在计算机领域中，许多知名的系统中重大的安全漏洞也都类似，如果后者能参考前者的失败原因，那么设计中的许多错误都是能规避的。</p>
<h3 id="谨慎的选择绑定时间"><a class="header-anchor" href="#谨慎的选择绑定时间">#</a>谨慎的选择绑定时间</h3>
<p><em>绑定时间（Binding Time）</em> 是指将一个特定的值与一个变量绑定在一起的时间点。比如将渲染时的分辨率就是一个需要与特定值绑定的变量，绑定时间可以是写代码时（硬编码），也可以是设备启动时（设备存在配置文件决定分辨率），也可以是程序启动时（程序的初始化设置），也可以是运行时（支持用户动态设置）。</p>
<p>如果一个值在很早期就和特定的变量绑定在一起，那么代码往往更简单，但灵活性也往往较差。有时，你可以通过提出以下问题获得良好的设计见解：</p>
<ul>
<li>如果我早点绑定这些值会怎么样？</li>
<li>如果我稍后绑定这些值怎么办？</li>
<li>如果我在代码中初始化该表会怎么样？</li>
<li>如果我在运行时从用户那里读取该变量的值会怎么样？</li>
</ul>
<h3 id="建立中心控制点"><a class="header-anchor" href="#建立中心控制点">#</a>建立中心控制点</h3>
<p>对于一个需求或问题，最好能在 <strong>一个</strong> 正确的位置找到所有重要的代码或进行相应的修改。</p>
<p>这样做能降低程序的复杂度：开发者需要寻找某些东西的地方越少，改变就越容易和安全。</p>
<h3 id="考虑使用蛮力"><a class="header-anchor" href="#考虑使用蛮力">#</a>考虑使用蛮力</h3>
<p>一种有效的思考方法是 <strong>使用蛮力</strong>。</p>
<p>有效的蛮力解决方案总比无效的优雅方案要好，现实中很可能需要特别长的时间才能获取到一个有效的优雅的解决方案。</p>
<blockquote>
<p>如二分搜索算法的第一个描述是在 1946 年发布的（John Mauchly），但在 1960 才有人发布了可以正确针对任意长度的列表的二分搜索算法（Derrick Henry）。</p>
</blockquote>
<h3 id="画图"><a class="header-anchor" href="#画图">#</a>画图</h3>
<p>图表是一种强大的思考方式，图可以在更高的抽象层次上表示问题。当你需要更笼统的处理问题时，图就是一个很好的工具。</p>
<h3 id="保持模块化"><a class="header-anchor" href="#保持模块化">#</a>保持模块化</h3>
<p>模块化的目标是让每个例程或类都像一个“黑匣子”：你知道进去什么，知道出来什么，但你不知道里面发生了什么。</p>
<p>思考如何从一组黑匣子组装一个系统，可以提供关于信息隐藏、封装，低耦合等各种信息。</p>
<h2 id="使用启发式方法的指南"><a class="header-anchor" href="#使用启发式方法的指南">#</a>使用启发式方法的指南</h2>
<p>思考一个问题的最有效的指导意见之一就是：不要陷入单一方案。</p>
<ul>
<li>如果用 UML 绘制设计图不起作用，请用语言编写。</li>
<li>编写一个简短的测试程序。</li>
<li>尝试一种完全不同的方法。</li>
<li>考虑一个暴力解决方案。</li>
</ul>
<p>如果其他一切都失败了，那就离开这个问题，去散散步或者思考一些其他的问题。如果你已经力而为但没有结果，那么暂时的将这个问题抛之脑后往往能比纯粹的 <em>坚持</em> 思考能更快的产生结果。</p>
<p>你不必马上解决整个设计问题，如果你在设计时遇到了困难，你首先要确认一点：你是否有足够的信息解决这个问题。</p>
<ul>
<li>如果你可以在未来，在拥有更多信息的情况下给出一个好的解决方案。为何你一定要在现在，基于不足的信息，给出一个错误的方案？</li>
</ul>
<h1 id="5_4_设计实践"><a class="header-anchor" href="#5_4_设计实践">#</a>5.4 设计实践</h1>
<div class="note info simple"><p>上一节中是关于设计时的思考方式，这一节则是在应用设计时的实践。</p>
</div>
<h2 id="迭代"><a class="header-anchor" href="#迭代">#</a>迭代</h2>
<p>设计是一个迭代的过程。当你进行设计并尝试不同的方法时，你会拥有对整个工程的高级视角和低级视角。</p>
<ul>
<li>从高级视角处理问题，将帮助你获得大局观，这可以更进一步的帮助你正确看待低级细节。</li>
<li>从低级视角处理问题，你将获得更多的详细细节，这些细节为高级决策提供了坚实的现实基础。</li>
</ul>
<div class="note primary simple"><p>在高级视角和低级视角之间进行切换是一种健康的动态，它创造了一种比完全从上到下或从下到上建造的结构更稳定的受力结构。<br>
从一种视角切换到另一种视角需要耗费大量的脑力，但这对于创建有效的设计至关重要。</p>
</div>
<p>当你做出了一个看似良好的设计尝试时，请不要停止。第二次尝试通常会比第一次尝试得到更好的结果，而且每次你都可以在尝试中学到可以改进整体设计的东西。在许多情况下，使用一种方式解决问题会产生见解，使你能够使用另一种更好的方法解决问题</p>
<h2 id="分而治之"><a class="header-anchor" href="#分而治之">#</a>分而治之</h2>
<p>没有人的头骨大到足以包含复杂程序的所有细节，这也适用于设计。将计划划分为不同的关注领域，然后分别解决每个领域。如果您在某个领域遇到了死胡同，请 <a href="/ch_05_design_in_construction/#%E8%BF%AD%E4%BB%A3">迭代</a>。</p>
<h2 id="从上而下和自下而上的设计方法"><a class="header-anchor" href="#从上而下和自下而上的设计方法">#</a>从上而下和自下而上的设计方法</h2>
<p>“自上而下”和“自下而上”听起来可能有些过时，但它们为面向对象设计的创建提供了宝贵的见解。</p>
<ul>
<li>自上向下的设计从高抽象层次开始。通常你从定义基类开始，在设计的过程中，逐渐增加详细程度，如定义派生类。</li>
<li>自下而上的设计从细节开始，努力实现通用性。它通常从具体对象开始，然后根据这些对象的细节找出通用性，并进行抽象操作。</li>
</ul>
<p>自上而下和自上而下都有各自优点，以下是双方的论据：</p>
<h3 id="自上而下的论据"><a class="header-anchor" href="#自上而下的论据">#</a>自上而下的论据</h3>
<p>自上而下方法背后的指导原则是，人脑一次只能专注于一定数量的细节。如果你从基类开始，逐步将它们分解为更详细的类，你的大脑就不会被迫同时处理太多细节。</p>
<p>需要分解到什么程度才算是设计完成？你应该持续分解，直到你觉得现在直接动手写代码比继续分解设计更容易。</p>
<ul>
<li>如果你的设计程度，是让你没法直观的知道你该如何实现，那么说明分解的程度还不够。</li>
<li>如果你的设计程度，对你自己开始实现都有点棘手，那么对于以后处理它的任何人来说都会有点麻烦。</li>
</ul>
<h3 id="自下而上的论据"><a class="header-anchor" href="#自下而上的论据">#</a>自下而上的论据</h3>
<p>有时，自上而下的方法是如此抽象，以至于很难开始。如果您需要使用更具体的东西，请尝试自下而上的设计方法。</p>
<div class="note info simple"><p>如果你看到一个钉子，你要解决它。<br>
你可以选择直接使用锤子（自下而上）。<br>
而不是选择一个工具，选择一个捶打类工具，选择锤子（自上而下）。</p>
</div>
<p>问问自己，“这个系统需要做什么？”毫无疑问，你可以回答这个问题。你可能会确定一些可以分配给具体类的低级职责。例如，你可能知道系统需要格式化特定的报表、计算该报表的数据、将其标题居中、在屏幕上显示报表、在打印机上打印报表等等。在确定了几个低级别的职责后，你通常会开始感到足够舒服，此时可以再次查看高层职责。</p>
<p>当进行自下而上的工作时，需要记住如下步骤：</p>
<ol>
<li>问问自己，这个系统要解决什么问题</li>
<li>从问题中确定具体的目标，和各部分的责任</li>
<li>识别各部分的共同点，并使用类/对象等进行抽象</li>
<li>到第 3 步抽象后的层次，思考这些抽象后的部分有什么共同点，并进一步抽象</li>
<li>重复步骤 3 和步骤 4，直到顶层</li>
</ol>
<h3 id="没有好坏"><a class="header-anchor" href="#没有好坏">#</a>没有好坏</h3>
<p>自上而下和自下而上策略之间的主要区别在于，一种是分解策略，另一种是组合策略。</p>
<ul>
<li>自上而下：从一般性问题开始，将其分解为可管理的部分</li>
<li>自下而上：一个从可管理的部分开始，建立一个通用的解决方案。</li>
</ul>
<p>这两个方案都有各自的优点和缺点：</p>
<p>自上而下的优点是：</p>
<ul>
<li>它很简单：人擅长将大的东西分解成更小的组件，反之则不然。</li>
<li>可以推迟施工细节：由于系统的细节经常会受到干扰而变化（需求变动），因此尽早的直到这些细节应该隐藏在整个结构的哪一部分是有用的。</li>
</ul>
<div class="note info simple"><p>人们拆乐高并不需要任何的说明书，但是组装乐高却需要说明书。<br>
而且即使有说明书，拼装到最后可能也会出现一些额外的零件，这些零件可能是多余的，也可能是拼装错误导致的，但你不知道是哪种情况。</p>
</div>
<p>自下而上的优点是：</p>
<ul>
<li>可以很早的识别所需的实用功能：如果你构建过类似的系统，你可以很快的查看旧系统中的部分并考虑重用</li>
<li>可以尽早的识别复杂度：自上而下往往开始时很简单，但有时候底层的复杂度会波及到顶层。而这些波澜会将事情变得比实际需要的更复杂。而自下而上开始时很复杂，但能尽早的识别复杂性，一帮助更好的设计。</li>
</ul>
<p>总之，自上而下和自下而上的设计并不是相互竞争的策略，他们是互惠互利的。<a href="/ch_05_design_in_construction/#%E8%AE%BE%E8%AE%A1%E6%98%AF%E4%B8%80%E4%B8%AA%E5%90%AF%E5%8F%91%E6%80%A7%E7%9A%84%E8%BF%87%E7%A8%8B">设计是一个启发性的过程</a>的，<a href="/ch_05_design_in_construction/#%E8%BF%AD%E4%BB%A3">迭代</a> 的过程，你需要反复实验，多次尝试。</p>
<h2 id="实验原型制作"><a class="header-anchor" href="#实验原型制作">#</a>实验原型制作</h2>
<p>有时，除非你更好地理解某些实现细节，否则你无法真正知道设计是否有效。在你知道某个特定数据库组织是否能够满足你的性能目标之前，你可能不知道它是否能胜任工作。毕竟 <a href="/ch_05_design_in_construction/#%E8%AE%BE%E8%AE%A1%E6%98%AF%E4%B8%80%E4%B8%AA%E6%A3%98%E6%89%8B%E9%97%AE%E9%A2%98">设计是一个棘手问题</a>。</p>
<p>原型设计是编写需要回答特定设计问题所需要的绝对最少量的一次性代码。</p>
<p>当开发人员没有遵守编写回答问题所需的绝对最少的代码时，原型设计的效果就会很差。</p>
<ul>
<li>你可能会引入额外的问题，进而导致无法准确的回答初始的问题。</li>
<li>你如果不将原型代码视为一次性代码，那么这些“半临时，半正式”的代码就会最终出现在生产系统中，这无疑增加了维护的复杂度。</li>
</ul>
<p>当设计问题不够具体时，原型设计的效果也会很差。</p>
<ul>
<li>这个数据库能工作吗？ ——狗屎问题</li>
<li>在 X，Y，Z 情况同时发生时，数据是否能支持每秒 1000 个事务的处理 ？—— 好问题</li>
</ul>
<div class="note primary simple"><p>实验原型是软件设计师对抗棘手问题的主要工具，但如果没有纪律性的使用原型，则它会引发更多的棘手问题</p>
</div>
<h2 id="多少设计就足够了？"><a class="header-anchor" href="#多少设计就足够了？">#</a>多少设计就足够了？</h2>
<div class="note icon-padding simple"><i class="note-icon fas fa-quote-left"></i><p>We try to solve the problem by rushing through the design process so that enough time is left at the end of the project to uncover the errors that were made because we rushed through the design process.<br>
—— Glenford Myers</p>
</div>
<p>如果设计下降到你以前完成过的任务级别，或者你对于如何解决非常的确信，你或许就已经完成了设计工作，你可以开始编码。</p>
<p>最大的设计问题往往不是来自知道很困难并且创建了糟糕设计的领域，而是来自认为很简单并且根本没有创建任何设计的领域。</p>
<h2 id="记录你的设计工作"><a class="header-anchor" href="#记录你的设计工作">#</a>记录你的设计工作</h2>
<p>记录一个设计工作的传统方法是将设计写在正式的设计文档中。但针对小型项目、非正式项目还有一些替代的方式：</p>
<ul>
<li>在代码中体现设计文档：如在注释中记录关键的设计决策</li>
<li>在合作软件上上记录下讨论和决策</li>
<li>使用相机/截图：将设计在白板或绘图工具中画出来，然后通过拍照或截图获得突破，并嵌入到设计文档中。这种方法只需要使用 1% 的时间，就能获得设计文档 80% 的好处。</li>
</ul>
<h1 id="5_2_对流行方法论的评论"><a class="header-anchor" href="#5_2_对流行方法论的评论">#</a>5.2 对流行方法论的评论</h1>
<p>在软件工程发展的历程中，设计思路从 “设计一切（BDUF, Big Design Up Front）” 渐渐转换到 “不设计任何东西” 。但对于 BDUF 的替代方案，应当是足够的预先设计（ENUF，Enough Design Up Front）。</p>
<p>对于多少是足够，这是一个主观的判断，没人能完美的做出这样的判断。但虽然你无法完全确定正确的设计程度，但设计到最后的一丝细节和完全不设计，这两个极端的设计程度肯定是错误的。</p>
<div class="note info simple"><p>不要做二极管</p>
</div>
<div class="note icon-padding simple"><i class="note-icon fas fa-quote-left"></i><p>The more dogmatic you are about applying a design method, the fewer real-life problems you are going to solve<br>
—— P.J Plauger</p>
</div>
<p>将设计看作一个棘手的，草率的，启发式的过程。不要满足于你想到的第一个设计，在必要时做原型试验，然后迭代，迭代，再迭代。最终你会对你的设计满意。</p>
<p><a href="/ch_05_design_checklist">Ch 05 Design Checklist</a></p>
]]></content>
      <tags>
        <tag>工程实践</tag>
      </tags>
  </entry>
  <entry>
    <title>《Head First 设计模式》 Ch 05 单例模式</title>
    <url>/ch_05_the_singleton_pattern/</url>
    <content><![CDATA[<p>单例模式(Singleton Pattern)可能是最简单，也是被应用最为广泛的设计模式。单例模式保证一个类只会存在一个实例，并且提供了一个公共的接口来访问该实例。</p>
<h1 id="代码示例"><a class="header-anchor" href="#代码示例">#</a>代码示例</h1>
<figure class="highlight cs"><figcaption><span>单例模式</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">object</span> lockObj = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">lock</span> (lockObj)</span><br><span class="line">                    <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">                        instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Constructor the Singleton&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里使用一个<code>lockObj</code>是为了保证多线程安全，如果有多个线程在同一时间第一次调用<code>Instance</code>，则可能存在两个线程都进入了<code>instance == null</code>的分支，这就会造成两次实例化，所以我们需要通过加锁来保证线程安全。但如果我们将锁直接加在第一个<code>If</code>外，则每次调用<code>Instance</code>都有一个加锁的过程，所以这里选择在第一个 If 内加锁，锁内再次检查保证只会有一次实例化。</p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>《Head First 设计模式》 Ch 06 命令模式</title>
    <url>/ch_06_the_command_pattern/</url>
    <content><![CDATA[<p>命令模式（Command Pattern）将一个请求封装为一个对象，进而将拥有不同的请求的物体参数化，并且还可以请求排队，打印请求日志，支持可逆操作。</p>
<p>命令模式由抽象命令类、具体命令类、接受者、调用者、客户类，五部分组成。其中接受者为被命令封装的类，调用者存放需要执行的类。</p>
<p>我们以一个远程控制装置作为例子，远程控制装置有两个按钮和一个撤回按钮。我们通过命令模式来将远程控制类与具体需要做的操作（如开灯）解耦。在例子中程序入口即为客户端，远程装置为调用者，灯为接受者，有开灯与关灯两个命令</p>
<h1 id="代码示例"><a class="header-anchor" href="#代码示例">#</a>代码示例</h1>
<h2 id="抽象命令类及实现"><a class="header-anchor" href="#抽象命令类及实现">#</a>抽象命令类及实现</h2>
<figure class="highlight cs"><figcaption><span>抽象命令类</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Command</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Execute</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Undo</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>命令类实现</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LightOffCommand</span> : <span class="title">Command</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Light light;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LightOffCommand</span>(<span class="params">Light light</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.light = light;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        light.Off();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Undo</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        light.On();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LightOnCommand</span> : <span class="title">Command</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Light light;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LightOnCommand</span>(<span class="params">Light light</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.light = light;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        light.On();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Undo</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        light.Off();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NoCommand</span> : <span class="title">Command</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;No command execute&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Undo</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;No command undo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="接受者"><a class="header-anchor" href="#接受者">#</a>接受者</h2>
<figure class="highlight cs"><figcaption><span>灯</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Light</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">On</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;The light is on&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Off</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;The light is off&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="调用者"><a class="header-anchor" href="#调用者">#</a>调用者</h2>
<figure class="highlight cs"><figcaption><span>远程控制</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">RemoteControl</span></span><br><span class="line">&#123;</span><br><span class="line">    Command[] commands;</span><br><span class="line">    Command lastCommond;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RemoteControl</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        commands = <span class="keyword">new</span> Command[<span class="number">2</span>] &#123; <span class="keyword">new</span> NoCommand(), <span class="keyword">new</span> NoCommand() &#125;;</span><br><span class="line">        lastCommond = <span class="keyword">new</span> NoCommand();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetCommand</span>(<span class="params"><span class="built_in">int</span> index, Command command</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        commands[index] = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnButtonClick</span>(<span class="params"><span class="built_in">int</span> index</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        commands[index].Execute();</span><br><span class="line">        lastCommond = commands[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnClickUndo</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        lastCommond.Undo();</span><br><span class="line">        lastCommond = <span class="keyword">new</span> NoCommand();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="客户类"><a class="header-anchor" href="#客户类">#</a>客户类</h2>
<figure class="highlight cs"><figcaption><span>函数入口</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Light light = <span class="keyword">new</span> Light();</span><br><span class="line">    RemoteControl remoteControl = <span class="keyword">new</span> RemoteControl();</span><br><span class="line">    remoteControl.SetCommand(<span class="number">0</span>, <span class="keyword">new</span> LightOnCommand(light));</span><br><span class="line">    remoteControl.SetCommand(<span class="number">1</span>, <span class="keyword">new</span> LightOffCommand(light));</span><br><span class="line">    remoteControl.OnButtonClick(<span class="number">0</span>);</span><br><span class="line">    remoteControl.OnButtonClick(<span class="number">1</span>);</span><br><span class="line">    remoteControl.OnClickUndo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="测试及结果"><a class="header-anchor" href="#测试及结果">#</a>测试及结果</h1>
<p>运行结果：</p>
<p><img src="/ch_06_the_command_pattern/2019-02-02-23-26-25.png" alt="命令模式测试结果"></p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>《Computer Networks and Internets》 Ch 06 信源与信号</title>
    <url>/ch_06_information_sources_and_signals/</url>
    <content><![CDATA[<h1 id="Introduction"><a class="header-anchor" href="#Introduction">#</a>Introduction</h1>
<p>这一章讲解释<code>信源（Information Sources）</code>和携带信息的信号的特征。</p>
<h1 id="Information_Sources"><a class="header-anchor" href="#Information_Sources">#</a>Information Sources</h1>
<p>数据通信理论更关注于较低层次的通信系统，因此信源可以是任意来源，不仅仅是包括计算机上层的键盘，鼠标，摄像机，传感器等等也是信源。</p>
<h1 id="Analog_And_Digital_Signals"><a class="header-anchor" href="#Analog_And_Digital_Signals">#</a>Analog And Digital Signals</h1>
<p>数据通信由两种信息组成，模拟信息或数字信息。模拟信号是由一个连续变化的函数构成，而数字信号则是跳跃变换的，在某个时间点会从一个强度突然跳跃至另一个强度。下图为模拟信号和数字信号的图解，左为模拟信号，右为数字信号：</p>
<p><img src="/ch_06_information_sources_and_signals/2019-11-28-09-30-33.png" alt="模拟信号与数字信号"></p>
<h1 id="Periodic_And_Aperiodic_Signals"><a class="header-anchor" href="#Periodic_And_Aperiodic_Signals">#</a>Periodic And Aperiodic Signals</h1>
<p>信号也可分类为周期信号与非周期信号。周期信号顾名思义表示信号会重复出现，反之为非周期信号。下图为周期信号：</p>
<p><img src="/ch_06_information_sources_and_signals/2019-11-28-09-33-10.png" alt="周期信号"></p>
<h1 id="Sine_Waves_And_Signal_Characteristics"><a class="header-anchor" href="#Sine_Waves_And_Signal_Characteristics">#</a>Sine Waves And Signal Characteristics</h1>
<p>数据通信通常使用 <code>Sin函数</code> 来表示信号。之所以选择 Sin 函数，是因为许多自然界产生的信号强度与时间的函数都是 Sin，如麦克风获取声音后的输出信号，电磁波的信号等。</p>
<p>Sin 函数波的信号特性由四个部分组成：</p>
<ol>
<li>频率（Frequency）：单位时间（通常是秒）内震动出现的个数。单位为赫兹（Hertz,Hz）</li>
<li>波幅（Amplitude）：信号最强和最弱两处的差</li>
<li>相位（Phase）：Sin 拨开始的地方与参考时间（一般是时间 0）的偏移</li>
<li>波长（Wavelength）：一个周期的波在传播媒介中要传播的距离。</li>
</ol>
<p>其中波长是一个媒介相关的特性，与波在媒介中传播的速度相关。剩下的三个特性都可以用数学公式表示，如波<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>sin</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>ω</mi><mi>t</mi><mo>+</mo><mi>ϕ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A\sin (\omega t+\phi)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">sin</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ϕ</span><span class="mclose">)</span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>表示波幅，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ϕ</span></span></span></span>表示相位，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ω</mi></mrow><annotation encoding="application/x-tex">\omega</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span></span></span></span>表示频率，当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ω</mi><mo>=</mo><mn>2</mn><mi>π</mi></mrow><annotation encoding="application/x-tex">\omega=2\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span>时表示频率为 1。</p>
<p>数据通信用的波一般都是高频的，一秒内出现百万个循环，对于这种频率的波，通常用兆赫兹（Megahertz,MHz）来表示。高频率波的单位如下表显示：</p>
<p><img src="/ch_06_information_sources_and_signals/2019-11-28-09-53-47.png" alt="频率单位"></p>
<h1 id="Composite_Signals"><a class="header-anchor" href="#Composite_Signals">#</a>Composite Signals</h1>
<p>之前图中的波称为<code>简单信号(Simple Signal)</code>，因为只是以单一的 Sin 波组成。但在实际中，多数信号都是以<code>组合信号（Composite Signal）</code>的形式出现。如下图所示，就是两个不同频率及振幅的波组合成一个新的波。</p>
<p><img src="/ch_06_information_sources_and_signals/2019-11-28-09-57-46.png" alt="组合波"></p>
<h1 id="The_Importance_of_Composite_Signals_And_Sine_Functions"><a class="header-anchor" href="#The_Importance_of_Composite_Signals_And_Sine_Functions">#</a>The Importance of Composite Signals And Sine Functions</h1>
<p><code>调制（Modulation）</code>出来的信号通常是组合信号。数学家<code>傅里叶(Fourier)</code>发现可以从组合信号中解析出他的组成部分，即简单信号。大部分的通信系统都是用组合信号来携带信息，在接收端再将信息拆分成简单信号。</p>
<h1 id="Time_And_Frequency_Domain_Representations"><a class="header-anchor" href="#Time_And_Frequency_Domain_Representations">#</a>Time And Frequency Domain Representations</h1>
<p>之前的所有信号波的图片的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mtext>轴</mtext></mrow><annotation encoding="application/x-tex">X轴</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord cjk_fallback">轴</span></span></span></span> 都是时间，称为信号在<code>时域(Time Domain)</code>内表示。</p>
<p>还有一种表现方式是信号在<code>频域(Frequency Domain)</code>内的表示，如之前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>sin</mi><mo>⁡</mo><mo stretchy="false">(</mo><mn>2</mn><mi>π</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sin (2\pi t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">sin</span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.5</mn><mo>×</mo><mi>sin</mi><mo>⁡</mo><mo stretchy="false">(</mo><mn>2</mn><mi>π</mi><mn>2</mn><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">0.5\times \sin(2\pi 2 t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">0.5</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">sin</span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mord">2</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span> 组成的复合信号，也用下图在频域中表示：</p>
<p><img src="/ch_06_information_sources_and_signals/2019-11-28-10-29-27.png" alt="频域表示"></p>
<p>图中的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mtext>轴</mtext></mrow><annotation encoding="application/x-tex">x轴</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">x</span><span class="mord cjk_fallback">轴</span></span></span></span> 为频率，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 轴仍为波幅。可以看到在频率为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> 的地方有波形出现，正好对应函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>sin</mi><mo>⁡</mo><mo stretchy="false">(</mo><mn>2</mn><mi>π</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sin (2\pi t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">sin</span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.5</mn><mo>×</mo><mi>sin</mi><mo>⁡</mo><mo stretchy="false">(</mo><mn>2</mn><mi>π</mi><mn>2</mn><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">0.5\times \sin(2\pi 2 t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">0.5</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">sin</span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mord">2</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span> 的频率，波形的振幅也与函数所表现的振幅相同。</p>
<p>因为每个简单波在频域图的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 轴上只占据一点，所以频域图用来表示复合波形是简单易读的。</p>
<h1 id="Bandwidth_Of_An_Analog_Signal"><a class="header-anchor" href="#Bandwidth_Of_An_Analog_Signal">#</a>Bandwidth Of An Analog Signal</h1>
<p>在计算机网络中经常听到<code>网络带宽(Network Bandwidth)</code>一词，关于网络带宽会在之后的章节中解释，这里先介绍一个相关概念，<code>模拟带宽(Analog Bandwidth)</code>。一个模拟信号的带宽是这个信号最高频率与最低频率之间的差，单位为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mi>z</mi></mrow><annotation encoding="application/x-tex">Hz</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">Hz</span></span></span></span>。如一个信号的频域图如下图所示，那么这个信号的贷款为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mi>K</mi><mi>H</mi><mi>z</mi></mrow><annotation encoding="application/x-tex">4KHz</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">4</span><span class="mord mathnormal" style="margin-right:0.04398em;">KHz</span></span></span></span>，因为这个信号的最高频率为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn><mi>K</mi><mi>H</mi><mi>z</mi></mrow><annotation encoding="application/x-tex">5KHz</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">5</span><span class="mord mathnormal" style="margin-right:0.04398em;">KHz</span></span></span></span>，最低频率为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi>K</mi><mi>H</mi><mi>z</mi></mrow><annotation encoding="application/x-tex">1KHz</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">1</span><span class="mord mathnormal" style="margin-right:0.04398em;">KHz</span></span></span></span>。</p>
<p><img src="/ch_06_information_sources_and_signals/2019-11-28-10-39-12.png" alt="模拟带宽"></p>
<p>如果一个信号是用频域图来表示的，那么可以很快的看出这个信号的带宽。</p>
<h1 id="Digital_Signals_And_Signal_Levels"><a class="header-anchor" href="#Digital_Signals_And_Signal_Levels">#</a>Digital Signals And Signal Levels</h1>
<p>数字信号是由一系列的固定的 <code>有效电平（Valid Level）</code> 组成且在任意的时间点信号都处于这些有效电平之一。</p>
<p>一些系统用电压来表示数字信号，如电压为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn><mi>V</mi></mrow><annotation encoding="application/x-tex">5V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">5</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> 表示信号 1，电压为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mi>V</mi></mrow><annotation encoding="application/x-tex">0V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">0</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> 表示信号 0，如下图所示：</p>
<p><img src="/ch_06_information_sources_and_signals/2019-11-28-10-55-33.png" alt="电压信号1"></p>
<p>如果将电压划分更细，如电压 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn><mi>V</mi></mrow><annotation encoding="application/x-tex">5V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">5</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> 表示信号 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>11</mn></mrow><annotation encoding="application/x-tex">11</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">11</span></span></span></span>，电压 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>V</mi></mrow><annotation encoding="application/x-tex">2V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> 表示 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>10</mn></mrow><annotation encoding="application/x-tex">10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">10</span></span></span></span>，电压 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>2</mn><mi>V</mi></mrow><annotation encoding="application/x-tex">-2V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> 表示 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>01</mn></mrow><annotation encoding="application/x-tex">01</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">01</span></span></span></span>，电压 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>5</mn><mi>V</mi></mrow><annotation encoding="application/x-tex">-5V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">5</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> 表示 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>00</mn></mrow><annotation encoding="application/x-tex">00</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">00</span></span></span></span>，如下图所示：</p>
<p><img src="/ch_06_information_sources_and_signals/2019-11-28-10-57-06.png" alt="电压信号2"></p>
<p>可以看到传输相同数据(8 bit)的情况下，第二种方法花费的时间少了一半，称第二种方法的 <code>数据速率（Data Rate）</code> 翻倍。因为第一种方法一次只能表示 1bit 的数据（1 或 0），而第二种方法表示了 2bit 的数据。如果电压细分为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span> 种，则一次性能表达 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> bit 的数据。</p>
<p>理论上可以将电压切分到非常小（如分割成一百万个电平等级）达到每次都能传递许多信息的目的，但是实际中因为电力系统并不能区分过小的电压间隔，所以只将电压分割为几个电平等级。</p>
<h1 id="Baud_And_Bits_Per_Second"><a class="header-anchor" href="#Baud_And_Bits_Per_Second">#</a>Baud And Bits Per Second</h1>
<p>数据速率有两方面决定，一方面是上一节中提到的信号有效电平数量（决定每次可以携带多少数据），另一方面是每个有效电平持续的时间。</p>
<p>如上一节中的例子，假设将 1 秒切分为 8 部分（即一秒电平可以变换 8 次）传递数据，一共有 2 个电平等级。那么一秒传递 8 bit 的数据。如果改为有 4 个电平等级，则每次能传递 2 个 bit,一秒传递 16 bit 的数据。如果仍然保持两个电平等级，但将一秒切分为 16 个部分，则同样一秒传递 16 bit 的数据。</p>
<p>将一秒电平可以变换的次数用波特表示(Baud)，波特数越高则一个电平持续的时间越短，如给每个电平 0.001 的持续时间，那么这个系统工作在 1000 Baud。理论上来说波特可以非常高，让每秒传递的数据增多，但是实际上当一个信号持续时间过短系统是无法检测到该信号的。每秒传递的数据量可用以下公式表示:</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>bits per second</mtext><mo>=</mo><mi>b</mi><mi>a</mi><mi>u</mi><mi>d</mi><mo>×</mo><mo stretchy="false">⌊</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mrow><mo stretchy="false">(</mo><mi>l</mi><mi>e</mi><mi>v</mi><mi>e</mi><mi>l</mi><mi>s</mi><mo stretchy="false">)</mo></mrow><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">\text{bits per second} = baud \times \lfloor \log_2{(levels)} \rfloor
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord text"><span class="mord">bits per second</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">ba</span><span class="mord mathnormal">u</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span><span class="mclose">⌋</span></span></span></span></span></p>
<h1 id="Converting_A_Digital_Signal_To_Analog"><a class="header-anchor" href="#Converting_A_Digital_Signal_To_Analog">#</a>Converting A Digital Signal To Analog</h1>
<p>根据傅里叶定理，任意的波形都可以由一系列 Sin 波组成，其中每个 Sin 波都有各自的振幅，相位与频率。</p>
<p>数字信号也可以看作是一个跃变的波形，但是这样的跃变波形需要由无数个 Sin 波才能构成，所以从工程角度来说不可能实现，毕竟不可能找出无数个信源。</p>
<p>所以在实际运用中只能妥协，运用越多的 Sin 波形，最终的复合波形就越接近跃变波形。下图展示了用模拟信号来表示数字信号的过程，图（a）是数字信号，显示为跃变波形，图（b）是用一个 Sin 波来表示，图（C）是两个 Sin 波，图（d）是用三个 Sin 波。可以看到 Sin 波的数量越多，波形越接近跃变信号，而且新增的波的频率越来越高。</p>
<p>一般而言，用三个 Sin 波模拟即可。</p>
<p><img src="/ch_06_information_sources_and_signals/2019-11-28-13-45-45.png" alt="数字电路转模拟电路"></p>
<h1 id="The_Bandwidth_Of_A_Digital_Signal"><a class="header-anchor" href="#The_Bandwidth_Of_A_Digital_Signal">#</a>The Bandwidth Of A Digital Signal</h1>
<p>如之前所述，求一个信号的带宽是求其最大频率和最小频率的差值。对于数字信号来说可以先将他转换为模拟信号（多个 Sin 信号），然后找出最高频率的 Sin 以及最低频率的 Sin。但是如上节所述，数字信号的跃变波形是由无数的 Sin 组成，且 Sin 的频率越来越高，即数字信号的最高频率是无限，因此数字信号的带宽为无限。</p>
<h1 id="Synchronization_And_Agreement_About_Signals"><a class="header-anchor" href="#Synchronization_And_Agreement_About_Signals">#</a>Synchronization And Agreement About Signals</h1>
<p>在实际运用中，发送端和接收端必须保证信号的每次变换间隔是一样的（可看作采样频率），这个问题称为<code>同步问题（Synchronization）</code>，下图展示了发送端和接收端以不同的频率采样会引发的问题，接收端的采样频率（10 次每秒）高于发送端（8 次每秒）。</p>
<p><img src="/ch_06_information_sources_and_signals/2019-11-28-13-57-49.png" alt="采样错误"></p>
<p>在实际运用中，这种频率的差异可能非常小，如误差为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msub><mn>0</mn><mrow><mo>−</mo><mn>8</mn></mrow></msub></mrow><annotation encoding="application/x-tex">10_{-8}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8528em;vertical-align:-0.2083em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">8</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span>秒，那可能出现了几百万个 Bit 后才发生一次错误。但在传输速率在亿个 Bit 每秒时，这种细微的差距也会引发大量的错误数据。</p>
<h1 id="Line_Coding"><a class="header-anchor" href="#Line_Coding">#</a>Line Coding</h1>
<p>如上节所述，在数据传递的过程中可能会因为同步问题导致一些错误的发生，有一些方法来帮助避免这些错误的发生。一种是真正发送信号前，先发送一系列的特定模式的字节，如重复的 0 或者重复的 1，通过这些字节来帮助接收端校准，另一种方法称为<code>信道编码（Line Coding）</code>，在这种方式下会添加一些额外的字符来保证接收端能确切的解析出真实的数据。</p>
<p>如一个电路能产生 5V，0，-5V 的电压，可以将 -5V  定义为一个数据的开始。因此 0 信号表示为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>5</mn><mi>V</mi><mo separator="true">,</mo><mn>0</mn><mi>V</mi></mrow><annotation encoding="application/x-tex">-5V, 0V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord">−</span><span class="mord">5</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span>，1 信号表示为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>5</mn><mi>V</mi><mo separator="true">,</mo><mn>5</mn><mi>V</mi></mrow><annotation encoding="application/x-tex">-5V, 5V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord">−</span><span class="mord">5</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">5</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span>。接收端知道在-5V 信号后才是真正的数据。这种方式的图解如下：</p>
<p><img src="/ch_06_information_sources_and_signals/2019-11-28-14-26-48.png" alt="信道编码例子"></p>
<p>因为信道编码引入了额外的数据来保证真实数据的准确性，所以信道编码降低了真实数据的传输速率。</p>
<h1 id="Manchester_Encoding_Used_In_Computer_Networks"><a class="header-anchor" href="#Manchester_Encoding_Used_In_Computer_Networks">#</a>Manchester Encoding Used In Computer Networks</h1>
<p><code>曼彻斯特编码(Manchester Encoding)</code>是一种信道编码，在计算机网络中曼彻斯特编码主要用于以太网中，所以十分重要。</p>
<p>对电路来说，检测信号的变化比检测信号的强度要简单。因此曼彻斯特编码将 1 信号定义为从零电压跳转为正电压，将 0 信号定义为从正电压跳转为零电压。而且曼彻斯特采样的时间为时间周期的中间，因此可以对于连续 0 或者连续 1 的情况，信号有时间可以回到之前的电压水平，保证下一次的检测正常。曼彻斯特编码的图示如下：</p>
<p><img src="/ch_06_information_sources_and_signals/2019-11-28-14-44-39.png" alt="曼彻斯特编码"></p>
<p>曼彻斯特编码还有一个变化，叫做<code>差分曼彻斯特编码（Differential Manchester Encoding）</code>，这种方法用相对变化来表示信号，0 信号表示信号发生了变化，1 信号表示信号没有变化。采样时间为时间周期点。差分曼彻斯特编码如下图所示：</p>
<p><img src="/ch_06_information_sources_and_signals/2019-11-28-14-48-53.png" alt="差分曼彻斯特编码"></p>
<p>差分曼彻斯特编码的好处在于，即使信号的大小意外的翻转了也不会发生错误（如 5V 变为-5V 之类）。</p>
<h1 id="Converting_An_Analog_Signal_To_Digital"><a class="header-anchor" href="#Converting_An_Analog_Signal_To_Digital">#</a>Converting An Analog Signal To Digital</h1>
<p>模拟信号为了进一步的被处理，必须转换为数字信号。一般转换为数字信号有两种方式,一是 <code>脉冲编码调制(Pulse Code Modulation，PCM)</code>，另一种是 <code>差分调制(Delta modulation)</code></p>
<p>脉冲编码调制是以相同时间间隔去测量模拟信号，并根据模拟信号的强度，将其转换为数字信号，整个流程分为三步，如下图框出的部分所示：</p>
<p><img src="/ch_06_information_sources_and_signals/2019-11-30-21-29-15.png" alt="脉冲编码调制"></p>
<p>以相同时间间隔去测量模拟信号，即为采样，所以上图中的第一部分称为采样。有的时候为了避免采样时间点的信号突变导致的采样失真，会在相关时间点附近多采样几次，然后取平均值作为最后采样值。第二部分称为量化（Quantization），量化是根据模拟信号的强度，将其转换为一个 Int 值，如下图所示，第一个采样的数值，会被量化为 2，第二个采样的数值会被量化为 3，第三个采样的数值会被量化为 6。</p>
<p><img src="/ch_06_information_sources_and_signals/2019-11-30-21-34-25.png" alt="量化"></p>
<p>量化后的数据会被进一步编码为之后需要的数据格式（根据需求而定）。</p>
<p>差分调制的主题思想与脉冲编码调制类似，不同的是在量化阶段他不是对每个采样值进行量化，而是对当前采样值与上一个采样值的差距进行量化。这样节省了许多用来表示数据的 Bit 数，但是缺点在于一旦之前的数据出现了误差，后面的所有数据都会收到影响。</p>
<h1 id="The_Nyquist_Theorem_And_Sampling_Rate"><a class="header-anchor" href="#The_Nyquist_Theorem_And_Sampling_Rate">#</a>The Nyquist Theorem And Sampling Rate</h1>
<p>应该以怎样的采样频率进行采样是数据通信中需要考虑的问题，如果采样频率过低，那么采样出来的信号与原信号可能有较大差异，如果采样频率过高，则会产生大量的数据。</p>
<p>奈奎斯特（Nyquist Theorem）定理提出：为了避免采样失真，采样的最低频率应该是原信号最高频率的两倍。</p>
<h1 id="Nyquist_Theorem_And_Telephone_System_Transmission"><a class="header-anchor" href="#Nyquist_Theorem_And_Telephone_System_Transmission">#</a>Nyquist Theorem And Telephone System Transmission</h1>
<p>经过实验，0 到 4000HZ 的频率基本就能提供人所能接受的音频质量。因此根据奈奎斯特频率，语音信号的采样频率应该是 8000HZ，既一秒有 8000 个采样点。通话系统所用的 PCM 标准规定，每个采样信号用 8-bit 数据表示，所以每秒通话产生的数据量为：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>8000</mn><mfrac><mrow><mi>s</mi><mi>a</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>e</mi><mi>s</mi></mrow><mrow><mi>s</mi><mi>e</mi><mi>c</mi><mi>o</mi><mi>n</mi><mi>d</mi></mrow></mfrac><mo>×</mo><mn>8</mn><mfrac><mrow><mi>b</mi><mi>i</mi><mi>t</mi><mi>s</mi></mrow><mrow><mi>s</mi><mi>a</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>e</mi></mrow></mfrac><mo>=</mo><mn>64000</mn><mfrac><mrow><mi>b</mi><mi>i</mi><mi>t</mi><mi>s</mi></mrow><mrow><mi>s</mi><mi>e</mi><mi>c</mi><mi>o</mi><mi>n</mi><mi>d</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">8000 \frac{samples}{second} \times 8 \frac{bits}{sample} = 64000 \frac{bits}{second}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.0574em;vertical-align:-0.686em;"></span><span class="mord">8000</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">seco</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="mord mathnormal">am</span><span class="mord mathnormal" style="margin-right:0.01968em;">pl</span><span class="mord mathnormal">es</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.2519em;vertical-align:-0.8804em;"></span><span class="mord">8</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="mord mathnormal">am</span><span class="mord mathnormal" style="margin-right:0.01968em;">pl</span><span class="mord mathnormal">e</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">bi</span><span class="mord mathnormal">t</span><span class="mord mathnormal">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8804em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0574em;vertical-align:-0.686em;"></span><span class="mord">64000</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">seco</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">bi</span><span class="mord mathnormal">t</span><span class="mord mathnormal">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>因此电话系统每秒传递 64000-bits 数据（64Kbps），也可见采样频率越高，可携带的数据也就越多。</p>
<h1 id="Nonlinear_Encoding"><a class="header-anchor" href="#Nonlinear_Encoding">#</a>Nonlinear Encoding</h1>
<p>当每个采样点只能用 8 个比特来表示时，线性的 PCM 编码无法很好的体现声音，因为 8 个 Bit 只能表现 256 个值，且线性表示的话，无论是非常低频或高频的部分还是人身大部分集中的部分都用了一样的采样间隔，这造成了浪费。而非线性编码，解决了这个问题，他更关注与人耳最敏感的频率。数字电话标准中有两种非线性编码：</p>
<ol>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>−</mo><mi>l</mi><mi>a</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">\alpha-law</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span>，主要是欧洲及中国采用的编码方式</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><mo>−</mo><mi>l</mi><mi>a</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">\mu-law</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">μ</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span>，主要是北美和日韩采用的编码方式</li>
</ol>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><mo>−</mo><mi>l</mi><mi>a</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">\mu-law</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">μ</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span> 算法的主要优势在于它覆盖了更广的频率范围（例如可以更好的还原特别高的声音），缺点在于对于一些弱信号有更多的失真。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>−</mo><mi>l</mi><mi>a</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">\alpha-law</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span> 在弱信号的失真上有优势，但动态范围更小。</p>
<p>对于国际电话，需要有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>−</mo><mi>l</mi><mi>a</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">\alpha-law</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><mo>−</mo><mi>l</mi><mi>a</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">\mu-law</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">μ</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span> 之间的转化。</p>
<h1 id="Encoding_And_Data_Compression"><a class="header-anchor" href="#Encoding_And_Data_Compression">#</a>Encoding And Data Compression</h1>
<p><code>数据压缩(Data Compression)</code> 是用来减少用来表达数据的 bit 数的方法。对于数据通信来说，通常在传输前对数据进行压缩。压缩分为两种类型：<code>有损压缩(Lossy)</code>和<code>无损压缩(Lossless)</code>。</p>
<p>有损压缩则通常用来压缩一些人相关的文件，如图片，视频，音频，这种压缩方式会忽视掉一些人无法精确识别的数据，<code>JPEG</code> 和 <code>MPEG-3(MP3)</code> 都是典型的有损压缩。</p>
<p>无损压缩保证压缩后的数据在解压后与原数据相同，一般用于压缩文档之类的文件。大部分的无损压缩都用了字典技术，即如果一个字符串在文件中重复的出现，将这个字符串存放在字典中，之后的出现只要取字典中的索引值即可。</p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《Code Complete》 第六章：类的实践</title>
    <url>/ch_06_working_classes/</url>
    <content><![CDATA[<h1 id="6_1_类基础：抽象数据类型"><a class="header-anchor" href="#6_1_类基础：抽象数据类型">#</a>6.1 类基础：抽象数据类型</h1>
<p>抽象数据类型（Abstract data type, ADT）是一系列 <em>数据</em> 和操作这些数据的函数集合。</p>
<div class="note info simple"><p>可以将 ADT 看作为对 <strong>一个</strong> 事物的合理封装</p>
</div>
<p>ADT 中 <em>数据</em> 概念很宽松，它可以是存储在磁盘中的数据，也可以是内存中的数据，甚至可以是一系列 UI 中按钮的，因此一个包含有操作的 UI 界面，可以被定义为 ADT，一个文件也可以被定义为 ADT，一个数据库也可以被定义为 ADT 等等。</p>
<p>在处理 <em>类</em> 前，开发者首先要明确 ADT 的概念，因为类就是 ADT 的一种实现方式。如果开发者不了解 <em>ADT</em>，那么创建出来的类，很可能就是一系列松散相关，甚至不相关的数据和函数的集合，而考虑了 <em>ADT</em> 后创建出来的</p>
<h2 id="使用_ADT_的示例"><a class="header-anchor" href="#使用_ADT_的示例">#</a>使用 ADT 的示例</h2>
<p>假设有一个应用，且需要提供设置该应用中字体显示的功能。如果不使用 ADT，你可能会实现如下的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">currentFont.sizeInPixels = <span class="built_in">PointsToPixels</span>( <span class="number">12</span> )</span><br><span class="line">currentFont.attribute = currentFont.attribute <span class="keyword">or</span> BOLD</span><br></pre></td></tr></table></figure>
<p>这样的代码问题是，你直接访问了数据对象（<code>sizeInPixels</code> 和 <code>attribute</code> ），当这个数据对象的了类发生了变化，则你需要在程序的各个地方都进行修改。</p>
<p>如果使用 ADT，你可能会实现如下的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">currentFont.<span class="built_in">SetSizeInPoints</span>( sizeInPoints )</span><br><span class="line">currentFont.<span class="built_in">SetSizeInPixels</span>( sizeInPixels )</span><br><span class="line">currentFont.<span class="built_in">SetBoldOn</span>()</span><br><span class="line">currentFont.<span class="built_in">SetBoldOff</span>()</span><br><span class="line">currentFont.<span class="built_in">SetItalicOn</span>()</span><br><span class="line">currentFont.<span class="built_in">SetItalicOff</span>()</span><br><span class="line">currentFont.<span class="built_in">SetTypeFace</span>( faceName )</span><br></pre></td></tr></table></figure>
<p>虽然看上去和之前的代码很类似，但是你已经将对字体的操作封装在了函数中，让调用者和数据进行了隔离。这样程序的其他部分就不必担心数据结构的实现、限制和变更。</p>
<h2 id="更多_ADT_的示例"><a class="header-anchor" href="#更多_ADT_的示例">#</a>更多 ADT 的示例</h2>
<p>ADT 的使用随处可见：</p>
<ul>
<li>各种数据结构，如堆栈，列表，队列都属于 ADT，因为它将真正的数据（内存对象）进行了隔离。</li>
<li>文件也是 ADT。文件的本质是磁盘中的物理地址，<code>File</code> 封装了系统调用和操作磁盘等各种混乱的细节。</li>
</ul>
<h2 id="ADTs_and_类"><a class="header-anchor" href="#ADTs_and_类">#</a>ADTs and 类</h2>
<p>ADT 构成了就是类概念的基础。</p>
<h1 id="6_2_好的类接口"><a class="header-anchor" href="#6_2_好的类接口">#</a>6.2 好的类接口</h1>
<p>创建高质量的类的第一步，也可能是最重要的一步，就是创建一系列良好的接口。</p>
<h2 id="好的抽象"><a class="header-anchor" href="#好的抽象">#</a>好的抽象</h2>
<h3 id="仅实现一个_ADT"><a class="header-anchor" href="#仅实现一个_ADT">#</a>仅实现一个 ADT</h3>
<p>类的接口应该提供一系列明显相关的函数。</p>
<p>如下类暴露的一系列接口就是 <strong>不好</strong> 的典范，你可以看到其中包含有各种的操作，而你很难直接看出这些操作之间的关系：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Program</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">// public routines</span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">InitializeCommandStack</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">PushCommand</span><span class="params">( Command command )</span></span>;</span><br><span class="line">   <span class="function">Command <span class="title">PopCommand</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">ShutdownCommandStack</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">InitializeReportFormatting</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">FormatReport</span><span class="params">( Report report )</span></span>;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">PrintReport</span><span class="params">( Report report )</span></span>;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">InitializeGlobalData</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">ShutdownGlobalData</span><span class="params">()</span></span>;</span><br><span class="line">   ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="提供相同的抽象等级"><a class="header-anchor" href="#提供相同的抽象等级">#</a>提供相同的抽象等级</h3>
<p>对于一个类而言，它应该实现一个且仅实现一个 <a href="/ch_06_working_classes/#6_1_%E7%B1%BB%E5%9F%BA%E7%A1%80%EF%BC%9A%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">ADT</a>。</p>
<p>如果你发现一个类实现了多个 ADT，或者你无法确认这个类实现的 ADT 是什么，则你应该将该类重新组织为一个 ADT，或定义多个类来分别表示其中的 ADT。</p>
<p>如下就是一个提供了<strong>不同</strong>抽象等级的 <strong>坏</strong> 代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EmployeeCenus</span>: <span class="keyword">public</span> ListContainer &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">// public routines</span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">AddEmployee</span><span class="params">( Employee employee )</span></span>;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">RemoveEmployee</span><span class="params">( Employee employee )</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="function">Employee <span class="title">NextItemInList</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function">Employee <span class="title">FirstItem</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function">Employee <span class="title">LastItem</span><span class="params">()</span></span>;</span><br><span class="line">   ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个类表示了两个 ADTs：<code>Employee</code> 和 <code>ListContainer</code>：</p>
<ul>
<li>从命名以及 <code>AddEmployee</code> 和 <code>RemoveEmployee</code> 函数出发，这个类表示 <code>Employee</code></li>
<li>从 <code>NextItemInList</code>，<code>FirstItem</code> 和 <code>LastItem</code> 函数出发，这个类表示的是 <code>ListContainer</code></li>
</ul>
<p>而一个提供 <strong>相同</strong> 抽象等级的 <strong>好</strong> 代码，应当是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EmployeeCenus</span>: <span class="keyword">public</span> ListContainer &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">// public routines</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">AddEmployee</span><span class="params">( Employee employee )</span></span>;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">RemoveEmployee</span><span class="params">( Employee employee )</span></span>;</span><br><span class="line">   <span class="function">Employee <span class="title">NextEmployee</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function">Employee <span class="title">FirstEmployee</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function">Employee <span class="title">LastEmployee</span><span class="params">()</span></span>;</span><br><span class="line">   ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   ListContainer m_EmployeeList;</span><br><span class="line">   ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个实现，虽然同样继承了 <code>ListContainer</code>，但它将 List 作为被封装的数据，因此它隔离了数据。且只表示 <code>Employee</code> 这个 ADT：</p>
<ul>
<li>这个类的暴露所有函数，都是 <code>Employee</code> 等级的</li>
</ul>
<div class="note primary simple"><p>上面两个例子，看上去差别很小。<strong>坏</strong> 代码，只不过是暴露的函数命名 XXXItem，让其表现的像是 <code>ListContainer</code> 的抽象而已。<br>
但如果将一个类暴露的接口视作防止进入潜水艇的气闸，不一致的接口就如同一个漏水的挡板，虽然它不会立刻让大量的水进来，但给它足够长的时间，它仍然会让船沉没。<br>
因此，当你定义接口时，如果有多个抽象等级，表示了多个 ADTs，随着程序的修改，这些混合的等级就会让程序变得越来越难理解，直到不可维护。</p>
</div>
<h3 id="想清楚类是对什么_ADT_的抽象"><a class="header-anchor" href="#想清楚类是对什么_ADT_的抽象">#</a>想清楚类是对什么 ADT 的抽象</h3>
<p>你应该仅提供你想要的 ADT 抽象的接口。</p>
<p>假设 UI 中存在两个组件，一个是网格控件，一个是电子表格控件。电子表格控件比网格空间复杂的多，前者有 150 个函数，后者有 15 个函数，且前者能覆盖后者的所有功能。</p>
<p>如果要开发的项目，想要展现的是普通的网格控件，加上能为为每一个单元格设置不同的颜色功能。且默认的 UI 库中的网格控件不支持该功能，而电子表格控件支持。</p>
<p>此时开发者可以通过定义一个包装类，来封装电子表格控件以实现该功能。开发者的包装类应该只提供 16 个接口（网格控件等效的 15 个接口 + 单元格设置颜色的函数接口），而不是暴露电子表格控件的所有 150 个接口。</p>
<p>如果开发者暴露的是电子表格控件的 150 个接口，那就是没有想明白需要封装的 ADT 是什么。这将导致，未来当包装类内部被包装的对象更改时（如更改为新版本已经支持设置单元格颜色的网格控件）需要调整 150 个接口，而不是实际上真正需要的 16 个接口。</p>
<h3 id="提供成对的接口"><a class="header-anchor" href="#提供成对的接口">#</a>提供成对的接口</h3>
<p>许多接口都应当是成对的，比如你提供了一个打开灯的操作，那么你就应该提供一个关闭灯的操作。</p>
<p>在设计一个类时，请检查每一个接口是否需要提供一个成对的接口。你不应该没理由的创建一个对立接口，但你也不应该无理由的不提供一个对立接口。</p>
<div class="note info simple"><p>如果一个类只提供了开灯接口，但没有关灯接口。<br>
类的使用者就会感到困惑，即使现阶段他不需要关灯，也会担心未来的需求。</p>
</div>
<h3 id="将不相关的信息挪到另一个类中"><a class="header-anchor" href="#将不相关的信息挪到另一个类中">#</a>将不相关的信息挪到另一个类中</h3>
<p>如果你发现一个类中一半的函数都在处理某一半数据，而另一半的函数处理另外一半的数据，那么你就应该将这两部分数据分别放到两个类中。</p>
<h3 id="让接口定义编程化而不是语义化"><a class="header-anchor" href="#让接口定义编程化而不是语义化">#</a>让接口定义编程化而不是语义化</h3>
<p>每个接口都由编程部分和语义部分两部分构成。编程部分是编译器可以检查的部分，语义部分是编译器无法检查，需要靠人为约定的部分。</p>
<p>如有一个接口 <code>int GetString()</code>，其中返回值 <code>int</code> 就是编程部分，编译器会保证返回值必然是 <code>int</code> 类型，而 <code>GetString</code> 就是语义部分，虽然函数名中有 <code>String</code>，但编译器无法保证返回值是 <code>String</code> 类型，如在这个例子中，它实际上返回的是 <code>int</code> 类型。</p>
<p>语义部分需要通过注释和文档来进行约定，但这并不安全，所以应当尽可能的将语义部分转化为编程部分。</p>
<div class="note info simple"><p>即使你无法做到完全的编程化，即让编译器帮你检查，最起码你应该在运行时当事情未按约定执行时，给出足够的错误信息，即：</p>
<div class="note icon-padding simple"><i class="note-icon fas fa-quote-left"></i><p>软件要尽可能从容地应付各种错误输入和自身的运行错误。但是，如果做不到这一点，就让程序尽可能以一种容易诊断错误的方式终止。<br>
———— <a href="/di_1_zhang_zhe_xue">《Unix 编程艺术》 第一章 哲学</a></p>
</div></div>
<h3 id="小心接口的逐渐腐蚀"><a class="header-anchor" href="#小心接口的逐渐腐蚀">#</a>小心接口的逐渐腐蚀</h3>
<p>当类被修改和拓展时，你很可能发现需要增加的功能和类原始的接口不太符合，而这些接口放到其他实现由显得不太合适或比较麻烦，此时就很可能出现接口腐蚀，最终会产生如下的一个 <code>Employee</code> 类：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">// public routines</span></span><br><span class="line">   <span class="function">FullName <span class="title">GetName</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">   <span class="function">Address <span class="title">GetAddress</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">   <span class="function">PhoneNumber <span class="title">GetWorkPhone</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">   ...</span><br><span class="line">   <span class="function"><span class="type">bool</span> <span class="title">IsJobClassificationValid</span><span class="params">( JobClassification jobClass )</span></span>;</span><br><span class="line">   <span class="function"><span class="type">bool</span> <span class="title">IsZipCodeValid</span><span class="params">( Address address )</span></span>;</span><br><span class="line">   <span class="function"><span class="type">bool</span> <span class="title">IsPhoneNumberValid</span><span class="params">( PhoneNumber phoneNumber )</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="function">SqlQuery <span class="title">GetQueryToCreateNewEmployee</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">   <span class="function">SqlQuery <span class="title">GetQueryToModifyEmployee</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">   <span class="function">SqlQuery <span class="title">GetQueryToRetrieveEmployee</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">   ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看出早期干净的对于 <code>Employee</code> 的抽象已经变成了一系列松散相关的函数的大杂烩。检查邮政编码，手机号等工作和 <code>Employee</code> 本身并不相关，这破坏了 <a href="/ch_06_working_classes/#%E4%BB%85%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA_adt">仅实现一个 ADT</a> 原则。而且也出现了一系列 SQL 的低层次函数的，导致破坏了 <a href="/ch_06_working_classes/#%E6%8F%90%E4%BE%9B%E7%9B%B8%E5%90%8C%E7%9A%84%E6%8A%BD%E8%B1%A1%E7%AD%89%E7%BA%A7">提供相同的抽象等级</a> 的原则。</p>
<h2 id="良好的封装"><a class="header-anchor" href="#良好的封装">#</a>良好的封装</h2>
<p>封装和抽象强相关，而且封装是比抽象更强的概念：</p>
<div class="note icon-padding simple"><i class="note-icon fas fa-quote-left"></i><p>封装是抽象的延续： <strong>抽象</strong> 说，“你可以以高维度的方式（忽略细节）观察一个物体。 <strong>封装</strong> 说：“此外，您不允许以任何其他维度观察对象。你现在看到的一切就是你被允许看到的一切”<br>
———— <a href="/ch_05_design_in_construction">《Code Complete》 第五章：构建中的设计</a></p>
</div>
<p>根据经验之谈，如果没有封装，那么抽象终将崩溃。所以要么你同时拥有抽象和封装，要么两者都没有。</p>
<p>为了达到良好的封装，你应该：</p>
<h3 id="尽量减少类和成员的可访问性"><a class="header-anchor" href="#尽量减少类和成员的可访问性">#</a>尽量减少类和成员的可访问性</h3>
<p>最小化可访问性是旨在鼓励封装的几条规则之一。</p>
<p>如果你在犹豫某个特定的函数应该是 <code>public</code>，<code>private</code> 还是 <code>protected</code>，一个良好的解决方案是，你应该采取最严格的 <code>private</code> 等级。</p>
<p>另一种解决方案是，你应该问自己，这个函数如果暴露出去的话，它与现在已经暴露的函数是否提供了一样的抽象等级。</p>
<h3 id="不要暴露成员变量"><a class="header-anchor" href="#不要暴露成员变量">#</a>不要暴露成员变量</h3>
<p>如下的 <code>Point</code> 类实现违反了封装性：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">float</span> x;</span><br><span class="line">    <span class="type">float</span> y;</span><br><span class="line">    <span class="type">float</span> z;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而一个良好的封装是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">GetX</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">GetY</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">GetZ</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetX</span><span class="params">( <span class="type">float</span> x )</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetY</span><span class="params">( <span class="type">float</span> y )</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetZ</span><span class="params">( <span class="type">float</span> z )</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样封装的好处是，它约定了返回的数据是 <code>float</code>，但真实的数据是什么并没有约束，如真实的数据可能是 <code>double</code> 的，也可能是 <code>string</code>。另外当你调用 <code>Set</code> 时，调用者也与真实的实现解耦了，真实的实现可能是将其转换为 <code>double</code> 或 <code>string</code> 等。</p>
<h3 id="不要对类的使用者做出假设"><a class="header-anchor" href="#不要对类的使用者做出假设">#</a>不要对类的使用者做出假设</h3>
<p>类的设计和实现应遵守类接口本身所表达的契约。除了接口本身表达的信息之外，它不应该对如何使用或不使用该接口做出任何假设。</p>
<p>比如一个函数，如果由如下的注释，就说明这个类假设了使用者会按 <em>它的意愿，先对 x,y,z 进行初始化</em>，而这个假设很可能会破灭：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">// 你应该将初始化 x, y, z 设定为正数</span><br><span class="line">// 因为派生类在接收到 0 时会 Crash</span><br></pre></td></tr></table></figure>
<h3 id="优先考虑读取时的便利性而不是写入时的便利性"><a class="header-anchor" href="#优先考虑读取时的便利性而不是写入时的便利性">#</a>优先考虑读取时的便利性而不是写入时的便利性</h3>
<p>即使在开发过程中，你读代码的次数也远远多于写代码的次数。牺牲读代码时的便利性，以换取写代码时的便利，以期望能更快的写出代码，是不理智的。</p>
<p>这在为类增加接口时尤其容易发生，如果你发现一个要新增的接口，与当前的类有点格格不入，但你很可能为了快速的写出代码而选择先把这个接口塞进去。但之后，这个<em>塞进去</em> 的接口就会成为走向滑坡的第一步，见 <a href="/ch_06_working_classes/#%E5%B0%8F%E5%BF%83%E6%8E%A5%E5%8F%A3%E7%9A%84%E9%80%90%E6%B8%90%E8%85%90%E8%9A%80">小心接口的逐渐腐蚀</a></p>
<h3 id="警惕，警惕再警惕违反封装的语义"><a class="header-anchor" href="#警惕，警惕再警惕违反封装的语义">#</a>警惕，警惕再警惕违反封装的语义</h3>
<p>就如同接口定义时区分编程化和语义化一样，在接口封装时也分为编程性和语义性。</p>
<div class="note icon-padding simple"><i class="note-icon fas fa-quote-left"></i><p>每个接口都由编程部分和语义部分两部分构成。编程部分是编译器可以检查的部分，语义部分是编译器无法检查，需要靠人为约定的部分。<br>
———— <a href="/ch_06_working_classes">《Code Complete》 第六章：类的实践</a></p>
</div>
<p>从编程性而言，只要将一个类的函数和数据定义为 <code>private</code> 即完成了封装，但语义上则完全不是，以下就是类的使用者在语义上打破封装的示例：</p>
<ul>
<li>不要调用 A 类的 <code>Initialize</code> 函数，因为 A 的函数 <code>PerformFirstOperation</code> 会自动调用</li>
<li>不要调用 A 类的 <code>Terminal</code> 函数，因为 A 的函数 <code>PerformFinalOperation</code> 会自动调用</li>
<li>你可以随意使用 <code>ClassB.MAXIMUM</code> 和 <code>ClassA.MAXIMUM</code>，因为他们的值相同。</li>
</ul>
<p>上述例子的问题都在于，这些依赖并不是根据公共接口的信息，而是依赖其中的私有实现。</p>
<p>每当你发现你在查看一个类中函数的具体实现，以帮助你使用该类时，就说明这个类的封装已经被破坏了，之后这个类的抽象也必然会被破坏。</p>
<div class="note primary simple"><p>如果你无法仅仅根据类的接口文档来弄清楚该如何使用这个类，那你的第一反应不应当是拉下源码并查看实现。<br>
你真正的做法应当是联系该类的作者，并说 “我不知道这个类该如何用”<br>
而类的作者，在此时应该要做的，也不是直接回答你的问题，而应该是找出该类的文档，补全信息，再提交文档。并问你，现在你可以基于文档理解它是如何工作的了吗？<br>
只有这样，你才能保证你的困惑能帮助到未来的人。</p>
</div>
<h3 id="耦合与抽象和封装密切相关"><a class="header-anchor" href="#耦合与抽象和封装密切相关">#</a>耦合与抽象和封装密切相关</h3>
<p>当一个类的封装或抽象被破坏后，很快这个类就会与其他类发生紧耦合。</p>
<p>如果一个类提供了不完整的功能，其他函数可能会发现它必须直接读取或写入这个类的内部数据。这就破坏了类的封装。</p>
<h1 id="6_3_设计和实现的问题"><a class="header-anchor" href="#6_3_设计和实现的问题">#</a>6.3 设计和实现的问题</h1>
<p>在之前两节，已经说了定义一个好的类接口，对于构建一个高质量的程序有帮助。</p>
<p>而类内部的设计和实现也同样很重要，本节将讨论组合，继承，成员函数，成员变量，类耦合，构造函数，值类型与应用类型等问题。</p>
<h2 id="组合"><a class="header-anchor" href="#组合">#</a>组合</h2>
<p>组合（Containment）通常表示类之间 <em>Has a</em> 的关系，如 <code>Employee</code> <em>Has a</em> <code>Name</code>，<code>Employee</code> <em>Has a</em> <code>Phone</code>。所以 <code>Name</code> 和 <code>Phone</code> 是 <code>Employee</code> 的成员变量。</p>
<div class="note warning simple"><p>在 C++ 中，你可以使用 <code>private inheritance</code> 来表示组合关系。这样做的主要目的，是可以访问到一个类中的 `protected`` 对象，但这种方法违反了封装性，应当通过其他的方法来实现。</p>
</div>
<p>如果一个类有超过 7 个数据成员，那你要警惕了。研究表示， 7 个左右（上下浮动 2 个）是一个人在执行其他任务时可以记住的数据的数量。如果一个类包含有超过 7 个成员数据，你可以考虑将其拆分为多个较小的类。</p>
<h2 id="继承"><a class="header-anchor" href="#继承">#</a>继承</h2>
<p>继承（Inheritance）表示一个类是另一个类的特化。继承的目的主要是将公用的代码和数据集中在基类中，避免多个位置重复定义编写类似的代码和数据，以降低维护的复杂性。</p>
<p>当你决定使用继承时，你应该要考虑：</p>
<ul>
<li>对于成员函数，他们是否应当对派生类可见，他们有默认实现吗，默认实现可以被重写吗？</li>
<li>对于成员变量，他们是否应该对派生类可见？</li>
</ul>
<h3 id="遵守里氏替换原则"><a class="header-anchor" href="#遵守里氏替换原则">#</a>遵守里氏替换原则</h3>
<p>基类设定了派生类应当如何 <em>继承</em> 的期望，并对派生类如何操作做出了约束。如果派生类没有完全遵守基类定义的相同接口协定，那么继承就不是合理的技术。</p>
<p><a href="/solid/#L_-_Liskov_Substitution_Principle_%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99">里氏替换原则</a> 表达的即是这个概念。概括而言，<a href="/solid/#L_-_Liskov_Substitution_Principle_%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99">里氏替换原则</a> 表示基类中的所有函数在派生类中都应该有相同的含义。</p>
<ul>
<li>如有 <code>Account</code> 的基类，并定义了 <code>GetInterestRate</code> 函数，<code>CheckingAccount</code> 和 <code>SavingAccount</code> 两个派生类分别表示支票账户和储蓄账户，这时候的 <code>GetInterestRate</code> 返回的数据就是 “储蓄利率”。而如果此时又有一个 <code>LoanAccount</code> 表示贷款账号，那么 <code>GetInterestRate</code> 返回的数据就是 “贷款利率”。</li>
<li>对于使用者而言，<code>LoanAccount.GetInterestRate</code> 和 <code>SavingAccount.GetInterestRate</code> 就存在语义不同，两个类返回的数据并不是一种数据。</li>
</ul>
<div class="note primary simple"><p>如果你使用继承的方式符合 <a href="/solid/#L_-_Liskov_Substitution_Principle_%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99">L - Liskov Substitution Principle 里氏替换原则</a> 那么继承就是降低复杂度的强大工具，因为程序员可以专注于对象的通用属性，不需要关注细节。反之程序员必须不断考虑子类实现的语义差异，此时继承只会增加复杂度。</p>
</div>
<h3 id="关注你想要继承的内容"><a class="header-anchor" href="#关注你想要继承的内容">#</a>关注你想要继承的内容</h3>
<p>对于一个继承的类而言，它有三种可能的继承的内容：</p>
<ol>
<li>抽象接口：如 <code>protected abstract GetValue()</code> ，这种情况下派生类获取到了基类的接口，但没有获取到实现，因此派生类必须重写基类的基类。</li>
<li>不可重写接口：如 <code>protected GetValue()</code> ，这种情况下派生类获取到了基类函数的接口和实现信息，但不允许重写基类的实现。</li>
<li>可重写接口：如 <code>protected virtual GetValue()</code>，这种情况下派生类获取到了基类函数的接口和实现信息，且允许重写基类的实现。</li>
</ol>
<p>当你使用派生类时，你应当自己考虑，派生类想要从基类中获取到什么信息。如果派生类仅仅是想要获取到基类中的某个函数的实现，或许你应该考虑使用 <a href="/ch_01_the_strategy_pattern">策略模式</a>。</p>
<p>概括而言，如果：</p>
<ul>
<li>你发现多个类依赖相同的数据而不依赖相同的行为，你应该创建出一个包含有这些数据的类，并用 <a href="/ch_06_working_classes/#%E7%BB%84%E5%90%88">组合</a> 而不是 <a href="/ch_06_working_classes/#%E7%BB%A7%E6%89%BF">继承</a></li>
<li>你发现多个类依赖相同的行为而不依赖相同的数据，你创建出一个包含有这些行为的基类，使用 <a href="/ch_01_the_strategy_pattern">策略模式</a> 和 <a href="/ch_06_working_classes/#%E7%BB%84%E5%90%88">组合</a></li>
<li>你发现多个类依赖相同的行为和数据，此时才考虑使用 <a href="/ch_06_working_classes/#%E7%BB%A7%E6%89%BF">继承</a></li>
</ul>
<h3 id="将公共接口，数据和行为尽可能的往基类移动"><a class="header-anchor" href="#将公共接口，数据和行为尽可能的往基类移动">#</a>将公共接口，数据和行为尽可能的往基类移动</h3>
<p>接口，数据和行为越往基类（高层）移动，派生类就越容易使用它们。</p>
<p>如果你发现将数据或函数往基类移动的过程中，让某些派生类会破坏 <a href="/solid/#L_-_Liskov_Substitution_Principle_%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99">里氏替换原则</a>，那么就说明你移动的太高了。</p>
<h3 id="对只有一个实例的派生类保持怀疑"><a class="header-anchor" href="#对只有一个实例的派生类保持怀疑">#</a>对只有一个实例的派生类保持怀疑</h3>
<p>如果一个派生类只有一个实例，可能说明类和实例的概念出现了混淆。</p>
<p>问问你自己，是否可以通过只创建一个基类的实例，但传入不同的数据来实现一样的效果，而不是非要定义一个类。</p>
<div class="note primary simple"><p>单例模式是例外</p>
</div>
<div class="note info simple"><p>这只是参考，并不是说只有一个实例的派生类一定有问题</p>
</div>
<h3 id="对只有一个派生类的基类保持怀疑"><a class="header-anchor" href="#对只有一个派生类的基类保持怀疑">#</a>对只有一个派生类的基类保持怀疑</h3>
<p>如果一个基类只有一个派生类，说明很可能发生了 <em>提前设计</em>：开发者试图预测未来的需求，但没有完全理解这些未来的需求是什么。</p>
<p>为未来的工作做准备的最好方式，不是提前抽象出基类。然后告诉自己“可能这层未来会有不同的实现，所以让现在的工作应该尽可能的简单”。</p>
<h3 id="对派生类中存在空实现的重写函数保持怀疑"><a class="header-anchor" href="#对派生类中存在空实现的重写函数保持怀疑">#</a>对派生类中存在空实现的重写函数保持怀疑</h3>
<p>如果一个派生类中的重写函数是空函数，这通常说明基类的设计存在问题。</p>
<p>假设你有一个 <code>Cat</code> 类和一个函数 <code>Scratch()</code>，但你发现有的猫失去了爪子所以无法抓挠，你可能会想派生出一个 <code>ScratchlessCat</code> 类，并将 <code>Scratch</code> 函数重写为空函数。</p>
<p>但这样做的问题是：</p>
<ul>
<li>你违反了 <a href="/solid/#L_-_Liskov_Substitution_Principle_%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99">里氏替换原则</a>，对于基类而言，所有猫都应该有抓挠的能力，只不过抓挠的方式不同而已，但你却实现了一个无法抓挠的猫。这造成了语义上的不统一。</li>
<li>随着时间的推移，会产生难以维护的代码。
<ul>
<li>如果你发现一只没有尾巴的猫怎么办，一只不会抓老鼠的猫怎么办，一只不会喵喵叫的猫怎么办，最初你会出现一个 <code>ScratchlessTaillessMouselessMewlessCat</code> 的怪物类。</li>
<li>当类似上述的怪物类出现后，你会发现基类对派生类没有起到任何的约束，你无法相信基类中定义的任何东西。</li>
</ul>
</li>
</ul>
<p>正确的做法，是定义一个 <code>Claws</code> 类封装抓挠，并将对象定义在 <code>Cat</code> 中。这样对于没有爪子的猫，你可以将 <code>Claws</code> 对象定义为空，这是正常的数据表达。原先 <code>Cat</code> 基类的根本问题是，它假设所有的猫都会抓挠，你应该解决根本问题（通过定义 <code>Claws</code> 对象，让 <code>Cat</code> 的抓挠能力是通过组合，而不是必须项），而不是简单的在派生类中打补丁弥补基类的问题。</p>
<h3 id="避免深继承树"><a class="header-anchor" href="#避免深继承树">#</a>避免深继承树</h3>
<p>在 <a href="/ch_06_working_classes/#%E7%BB%84%E5%90%88">组合</a> 中说一个类最多有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>7</mn><mo>±</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">7 \pm 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">7</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">±</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> 个数据成员。但对于继承而言，最多有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>−</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">2-3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span> 个继承深度。</p>
<p>继承的深度增加了复杂性，这与继承的目的相反。牢记，继承是为了避免重复代码以降低复杂性。</p>
<h3 id="使用多态性而不是类型检查"><a class="header-anchor" href="#使用多态性而不是类型检查">#</a>使用多态性而不是类型检查</h3>
<p>如果你发现代码中有大量的根据类型进行选择代码，可能此时使用多态性进行抽象是更好的选择。</p>
<p>如下的代码，是典型的可以通过多态性进行抽象的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> ( shape.type ) &#123;</span><br><span class="line">   <span class="keyword">case</span> Shape_Circle:</span><br><span class="line">      shape.<span class="built_in">DrawCircle</span>();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> Shape_Square:</span><br><span class="line">      shape.<span class="built_in">DrawSquare</span>();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中，根据类型去选择调用 <code>DrawCircle</code> 和 <code>DrawSquare</code> 的选择。在这种情况下可以通过抽象出 <code>shape.Draw()</code> 函数来解决，因为调用者通常关心的只是调用 <code>shape</code> 的绘制，而不会耦合到具体的实现。</p>
<p>但也有一些代码，使用类型检查后，执行的操作是明显不同的，此时使用多态性进行抽象是不合适的，如下的代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> ( ui.<span class="built_in">Command</span>() ) &#123;</span><br><span class="line">   <span class="keyword">case</span> Command_OpenFile:</span><br><span class="line">      <span class="built_in">OpenFile</span>();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> Command_Print:</span><br><span class="line">      <span class="built_in">Print</span>();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> Command_Save:</span><br><span class="line">      <span class="built_in">Save</span>();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> Command_Exit:</span><br><span class="line">      <span class="built_in">ShutDown</span>();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果将上述的一系列操作，抽象为 <code>DoCommand</code>，则这个类的含义会被过度的淡化，进而无法提供任何的信息，以至于调用者需要关心每个 <code>Command</code> 究竟是什么，这就引入了额外的复杂度。</p>
<h3 id="将所有的成员变量设为_private"><a class="header-anchor" href="#将所有的成员变量设为_private">#</a>将所有的成员变量设为 private</h3>
<p>继承在一定程度上也打破了封装。</p>
<p>所以当你继承一个对象时，最好让基类中的所有成员数据都是私有的，以避免派生类破坏基类的封装。如果派生类确实需要访问数据，请提供 <code>protected accessor</code>。</p>
<h3 id="多继承"><a class="header-anchor" href="#多继承">#</a>多继承</h3>
<div class="note icon-padding simple"><i class="note-icon fas fa-quote-left"></i><p>The one indisputable fact about multiple inheritance in C++ is that it opens up a Pandora’s box of complexities that simply do not exist under single inheritance.<br>
—— Scott Meyers</p>
</div>
<p>多重继承应该只用于定义 <code>mixin</code>，即类似于 <code>Displayable</code>，<code>Sortable</code> ,<code>Disposable</code> 之类抽象的类。</p>
<p>对于其他的情况，多重继承很容易引发极大的复杂度。</p>
<h2 id="成员函数和数据"><a class="header-anchor" href="#成员函数和数据">#</a>成员函数和数据</h2>
<p>这一节将讨论实现成员函数和数据的一些准则。</p>
<h3 id="保持类中的函数数量尽可能的少"><a class="header-anchor" href="#保持类中的函数数量尽可能的少">#</a>保持类中的函数数量尽可能的少</h3>
<p>如同之前在 <a href="/ch_06_working_classes/#%E7%BB%84%E5%90%88">组合</a> 和 <a href="/ch_06_working_classes/#%E9%81%BF%E5%85%8D%E6%B7%B1%E7%BB%A7%E6%89%BF%E6%A0%91">避免深继承树</a> 中提及的，你应当尽可能的避免一个类中的函数数量太多，人脑不足以处理数量过多的数据。</p>
<h3 id="尽可能避免调用其他类的数量"><a class="header-anchor" href="#尽可能避免调用其他类的数量">#</a>尽可能避免调用其他类的数量</h3>
<p>一个类使用的其他类数量越多，错误率就越高，这时就是高扇出。</p>
<div class="note icon-padding simple"><i class="note-icon fas fa-quote-left"></i><ul>
<li>中低扇出（Low-to-medium fan-out）：中低扇出意味着每一个类都使用中低数量的其他类。如果一个类使用 7 个以上的其他类，则说明该类存在高扇出，即该类过于复杂。<br>
———— <a href="/ch_05_design_in_construction">《Code Complete》 第五章：构建中的设计</a></li>
</ul>
</div>
<h3 id="尽可能减少对其他类的间接调用"><a class="header-anchor" href="#尽可能减少对其他类的间接调用">#</a>尽可能减少对其他类的间接调用</h3>
<p>Law of Demeter 规定：A 类可以随意调用自己的函数，如果 A 类中实例化了 B，那么 A 可以调用 B 中的任意函数，但 A 要避免调用 B 函数返回的数据中的函数。</p>
<p>如 <code>Account.ContactPerson()</code> 没问题，但 <code>Account.ContactPerson().DaytimeContactInfo()</code> 不行，因为这样 <code>Account</code> 间接耦合了 <code>ContactPerson</code> 所返回的数据。</p>
<div class="note primary simple"><p>对其他类的直接连接已经足够危险了，因为你要 <a href="/ch_06_working_classes/#%E5%B0%BD%E5%8F%AF%E8%83%BD%E9%81%BF%E5%85%8D%E8%B0%83%E7%94%A8%E5%85%B6%E4%BB%96%E7%B1%BB%E7%9A%84%E6%95%B0%E9%87%8F">尽可能避免调用其他类的数量</a>。<br>
间接连接无疑更危险。</p>
</div>
<h2 id="构造函数"><a class="header-anchor" href="#构造函数">#</a>构造函数</h2>
<h3 id="如果可能的话，构造函数中初始化所有成员数据"><a class="header-anchor" href="#如果可能的话，构造函数中初始化所有成员数据">#</a>如果可能的话，构造函数中初始化所有成员数据</h3>
<p>在构造函数中初始化所有成员数据，是一种廉价的防御性编程的实践。</p>
<h3 id="优先实现深拷贝而非浅拷贝"><a class="header-anchor" href="#优先实现深拷贝而非浅拷贝">#</a>优先实现深拷贝而非浅拷贝</h3>
<p>当实现对象的拷贝函数时，优先实现深拷贝而非浅拷贝。</p>
<p>创建浅拷贝通常是为了提高性能。尽管深拷贝了多个复杂对象的内存在本能上会引发反感，觉得这浪费了性能。但实际上，它很少会造成可以被测量出的性能影响。</p>
<p>深拷贝可以避免开发者意外的修改了对象的数据，也避免了意外引用导致的内存不释放，进而避免复杂度。</p>
<div class="note warning simple"><p>优先实现浅拷贝，就是通过增加复杂性以获得存疑的性能提升，这是一个糟糕的决策。</p>
</div>
<h1 id="6_4_创建类的理由"><a class="header-anchor" href="#6_4_创建类的理由">#</a>6.4 创建类的理由</h1>
<p>在这一节中会列出创建类的一系列理由以及需要避免创建类的情况。</p>
<h2 id="对现实世界的物体建模"><a class="header-anchor" href="#对现实世界的物体建模">#</a>对现实世界的物体建模</h2>
<p>创建一个类最通常的理由就是对现实中存在的物体进行一个抽象建模，这种抽象正是 <a href="/ch_06_working_classes/#6_1_%E7%B1%BB%E5%9F%BA%E7%A1%80%EF%BC%9A%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">抽象数据类型</a> 的直接体现：</p>
<div class="note icon-padding simple"><i class="note-icon fas fa-quote-left"></i><p>抽象数据类型（Abstract data type, ADT）是一系列 <em>数据</em> 和操作这些数据的函数集合。<br>
———— <a href="/ch_06_working_classes">《Code Complete》 第六章：类的实践</a></p>
</div>
<h2 id="对抽象的物体建模"><a class="header-anchor" href="#对抽象的物体建模">#</a>对抽象的物体建模</h2>
<p>创建类还可以对现实中并不物理存在的对象进行抽象建模，如经典的 <code>Shape</code> 对象：</p>
<ul>
<li><em>圆</em> 和 <em>方</em> 是现实中确实存在的概念，你可以准确的描述这两者的概念，如 <em>圆</em> 是一系列到一个点距离相同的点的集合。</li>
<li><em>形状</em> 是一种抽象概念，你很难描述什么是 <em>形状</em>。</li>
</ul>
<div class="note primary simple"><p>对于抽象概念的建模是困难的，它要求建模者需要知道一系列具体事物的抽象概念：</p>
<ul>
<li>如一个人，他不知道 <em>形状</em> 这个概念，那么他大概率无法定义出 <code>Shape</code> 这个类。他只能给出 “类似鸡蛋的”，“类似桌子的”，这样的抽象等级。</li>
</ul>
</div>
<h2 id="降低复杂度"><a class="header-anchor" href="#降低复杂度">#</a>降低复杂度</h2>
<p>创建类的另一个重要理由就是 <a href="/ch_05_design_in_construction/#%E8%BD%AF%E4%BB%B6%E7%9A%84%E4%B8%BB%E8%A6%81%E6%8A%80%E6%9C%AF%E8%A6%81%E6%B1%82%EF%BC%9A%E7%AE%A1%E7%90%86%E5%A4%8D%E6%9D%82%E6%80%A7">管理复杂性</a>。</p>
<ul>
<li>
<p>类可以 <a href="/ch_05_design_in_construction/#%E9%9A%90%E8%97%8F%E4%BF%A1%E6%81%AF">隐藏信息</a>，这样当一个类开发完成后，外部的使用者就可以忘记其中的细节，并使用该类。</p>
</li>
<li>
<p>类可以隔离复杂性：</p>
<ul>
<li>如果你已经 <a href="/ch_05_design_in_construction/#%E7%A1%AE%E8%AE%A4%E5%8F%AF%E8%83%BD%E5%8F%91%E7%94%9F%E5%8F%98%E5%8C%96%E7%9A%84%E9%A2%86%E5%9F%9F">确认了可能发生变化的领域</a> 。你就可以通过类，将容易变化的部分隔离到一个类中。</li>
<li>对于外部的数据的方案，也可以通过类来隔离。如建立一个类来统一的控制外部设备。</li>
</ul>
</li>
<li>
<p>类可以简化参数的传递。如果在几个函数中，你需要频繁的传递数据，则可能表示这几个函数或许需要封装在一个类中，然后共同访问一个成员数据。</p>
</li>
<li>
<p>类的存在也可以促进可重用代码。与一个庞大的类相比，分解并有效管理的各较小的类，可以显著的提升代码重用的可能性。</p>
</li>
</ul>
<div class="note primary simple"><p>在项目开发中，不要将 “重用” 作为目的来设计类。<br>
你应该在一个项目结束，或进行到某一个阶段后，找出各重用的部分，然后进行拆分，重构，以供其他项目使用。<br>
这样可以避免过度设计，即为了让一个类可以重用，而增加了不必要的复杂性。</p>
</div>
<h2 id="需要创建万能类"><a class="header-anchor" href="#需要创建万能类">#</a>需要创建万能类</h2>
<p>避免创建一个无所不知，无所不能的万能类。如果 A 类频繁的调用 B 类的 <code>Get</code>，<code>Set</code> 接口，即 A 类从 B 类获取数据，处理数据，再将处理后的结果告知 B 类。</p>
<p>你就应该询问下自己，这个处理数据的操作是不是可以封装到 B 类中，而不是让 A 类称为 B 类万能的上帝，为其处理一切事物。</p>
<h1 id="6_5_特定于语言的问题"><a class="header-anchor" href="#6_5_特定于语言的问题">#</a>6.5 特定于语言的问题</h1>
<p>以下问题是一个编程语言与类相关的区域，它们在不同的语言中可能有巨大的差异：</p>
<ul>
<li>继承中 Override 构造函数和析构函数的行为</li>
<li>异常处理条件下构造函数和析构函数的行为</li>
<li>默认构造函数的重要性</li>
<li>调用析构函数或 <code>Finalizer</code> 的时间</li>
<li>重写语言的内置运算符（如赋值，相等）的策略</li>
<li>创建和销毁对象（通过声明或超过代码域）时内存的处理方式</li>
</ul>
<h1 id="6_6_超越类：包"><a class="header-anchor" href="#6_6_超越类：包">#</a>6.6 超越类：包</h1>
<p>类的作用是将程序模块化，模块化本身是个比类更大的话题。在程序的初期，语句就是相较于机器指令的模块化，然后函数是相较于语句的模块化，类是相较于函数的模块化，包则是类更进一步的模块化。</p>
<p>可以在 <a href="/ch_05_design_in_construction/#%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%B1%82%E6%AC%A1">设计的层次</a> 中查看各层次的封装。</p>
<p>Ch 06 Class Quality Checklist</p>
]]></content>
      <tags>
        <tag>工程实践</tag>
        <tag>代码质量</tag>
      </tags>
  </entry>
  <entry>
    <title>《Head First 设计模式》 Ch 07 适配器模式和外观模式</title>
    <url>/ch_07_the_adapter_and_facade_patterns/</url>
    <content><![CDATA[<h1 id="适配器模式"><a class="header-anchor" href="#适配器模式">#</a>适配器模式</h1>
<p>适配器模式（Adapter Pattern）将一个类的接口转换为用户想要的另一个接口。适配器模式将原先因为接口不兼容的一些类可以一起工作。</p>
<p>例如我们有已经实现的火鸡类和鸭子类，其中鸭子的鸣叫我们使用<code>Quack</code>，火鸡的鸣叫我们用<code>Goggle</code>，两个接口不相同，但在某些情况下，我们不希望具体区分是火鸡还是鸭子，只希望他们都能叫，这时候就需要用适配器模式，将火鸡或鸭子伪装成同一个类。</p>
<h2 id="代码示例"><a class="header-anchor" href="#代码示例">#</a>代码示例</h2>
<h3 id="鸭子及火鸡抽象接口及实现"><a class="header-anchor" href="#鸭子及火鸡抽象接口及实现">#</a>鸭子及火鸡抽象接口及实现</h3>
<figure class="highlight cs"><figcaption><span>鸭子接口</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Duck</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Quack</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Fly</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>鸭子实现</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MallardDuck</span> : <span class="title">Duck</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fly</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;MallardDuck Fly&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Quack</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;MallardDuck Quack&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>火鸡接口</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Turkey</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Gobble</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Fly</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>火鸡实现</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WildTurkey</span> : <span class="title">Turkey</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fly</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;WildTurkey Fly&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Gobble</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;WildTurkey Gobble&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="适配器类"><a class="header-anchor" href="#适配器类">#</a>适配器类</h3>
<figure class="highlight cs"><figcaption><span>火鸡适配器</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TurkeyAdapter</span> : <span class="title">Duck</span></span><br><span class="line">&#123;</span><br><span class="line">    Turkey turkey;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TurkeyAdapter</span>(<span class="params">Turkey turkey</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.turkey = turkey;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fly</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i != <span class="number">5</span>; ++i)</span><br><span class="line">            turkey.Fly();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Quack</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        turkey.Gobble();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试代码及结果"><a class="header-anchor" href="#测试代码及结果">#</a>测试代码及结果</h2>
<figure class="highlight cs"><figcaption><span>测试代码</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    MallardDuck duck = <span class="keyword">new</span> MallardDuck();</span><br><span class="line">    WildTurkey turkey = <span class="keyword">new</span> WildTurkey();</span><br><span class="line">    TestDuck(duck);</span><br><span class="line">    TestDuck(<span class="keyword">new</span> TurkeyAdapter(turkey));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">TestDuck</span>(<span class="params">Duck duck</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    duck.Fly();</span><br><span class="line">    duck.Quack();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/ch_07_the_adapter_and_facade_patterns/2019-02-03-00-10-27.png" alt="适配器模式运行结果"></p>
<h1 id="外观模式"><a class="header-anchor" href="#外观模式">#</a>外观模式</h1>
<p>外观模式(Facade Pattern)为子系统的一系列接口提供了一个统一的，更高级别的接口以简化外部的调用。</p>
<p>外观模式实际上是遵从于<code>最小知识原则</code>，对一些上层的类来说，它不需要了解下面子系统的具体构成，那么我们就用一个中间层（Facade）来将封装这些子系统，形成一个软解耦。</p>
<p>例如我们有一个家庭影院，在播放电影时我们需要打开 DVD 机，打开投影仪，打开放大器，打开音频协调器等，我们可以用一个<code>Facade</code>来将这些操作都封装起来，对于外部调用者来说仅有开始播放电影及关闭播放电影两步。</p>
<h2 id="代码示例-2"><a class="header-anchor" href="#代码示例-2">#</a>代码示例</h2>
<h3 id="子系统"><a class="header-anchor" href="#子系统">#</a>子系统</h3>
<figure class="highlight cs"><figcaption><span>DVD机器</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DvdPlayer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">On</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="keyword">this</span>.GetType().ToString() + <span class="string">&quot; On&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Off</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="keyword">this</span>.GetType().ToString() + <span class="string">&quot; Off&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>投影仪</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Projector</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">On</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="keyword">this</span>.GetType().ToString() + <span class="string">&quot; On&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Off</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="keyword">this</span>.GetType().ToString() + <span class="string">&quot; Off&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>放大器</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Amplifier</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">On</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="keyword">this</span>.GetType().ToString() + <span class="string">&quot; On&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Off</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="keyword">this</span>.GetType().ToString() + <span class="string">&quot; Off&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>音频协调器</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Tuner</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">On</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="keyword">this</span>.GetType().ToString() + <span class="string">&quot; On&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Off</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="keyword">this</span>.GetType().ToString() + <span class="string">&quot; Off&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Facade"><a class="header-anchor" href="#Facade">#</a>Facade</h3>
<figure class="highlight cs"><figcaption><span>家庭影院外观者</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">HomeTheaderFacade</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Amplifier amplifier = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Tuner tuner = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> DvdPlayer dvdPlayer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Projector projector = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HomeTheaderFacade</span>(<span class="params">Amplifier amplifier, Tuner tuner, DvdPlayer dvdPlayer, Projector projector</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.amplifier = amplifier;</span><br><span class="line">        <span class="keyword">this</span>.tuner = tuner;</span><br><span class="line">        <span class="keyword">this</span>.dvdPlayer = dvdPlayer;</span><br><span class="line">        <span class="keyword">this</span>.projector = projector;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">WatchMovie</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        amplifier.On();</span><br><span class="line">        tuner.On();</span><br><span class="line">        dvdPlayer.On();</span><br><span class="line">        projector.On();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endMovie</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        amplifier.Off();</span><br><span class="line">        tuner.Off();</span><br><span class="line">        dvdPlayer.Off();</span><br><span class="line">        projector.Off();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试代码及结果-2"><a class="header-anchor" href="#测试代码及结果-2">#</a>测试代码及结果</h2>
<figure class="highlight cs"><figcaption><span>测试代码</span></figcaption><table><tr><td class="code"><pre><span class="line">HomeTheaderFacade facade = <span class="keyword">new</span> HomeTheaderFacade(<span class="keyword">new</span> Amplifier(), <span class="keyword">new</span> Tuner(), <span class="keyword">new</span> DvdPlayer(), <span class="keyword">new</span> Projector());</span><br><span class="line">facade.WatchMovie();</span><br><span class="line">Console.WriteLine();</span><br><span class="line">facade.endMovie();</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/ch_07_the_adapter_and_facade_patterns/2019-02-03-13-53-18.png" alt="外观模式运行结果"></p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>《Computer Networks and Internets》 Ch 07 传播媒介</title>
    <url>/ch_07_transmission_media/</url>
    <content><![CDATA[<h1 id="Introduction"><a class="header-anchor" href="#Introduction">#</a>Introduction</h1>
<p>这一章将会给出传播媒介的分类，介绍电信号，无线信号，光信号各自的传输特征。在本章节的最后，介绍了奈奎斯特定律和香农理论，分别给出了理想情况和实际情况下最大的信息传输率。</p>
<h1 id="Guided_And_Unguided_Transmission"><a class="header-anchor" href="#Guided_And_Unguided_Transmission">#</a>Guided And Unguided Transmission</h1>
<p>有两种重要的将传输媒介分类的方法：</p>
<ol>
<li>
<p>按传播路径：使用 <code>有向（Guided）</code> 和 <code>无向（Unguided）</code> 来描述传播路径。像铜线和光纤这种提供特定路径的方式称为有向。而像无线电这样的传输称为无向。工程师会通俗的将这两种称为<code>有线(wired)</code>和<code>无线(wireless)</code>，因此光纤也算在有线的范畴。</p>
</li>
<li>
<p>按能的形式：分为三种类型，在线缆上的 <code>电信号（Electrical Energy）</code>，无线上使用的 <code>无线电（Radio）</code>和光纤中使用的 <code>光（Light）</code>。</p>
</li>
</ol>
<h2 id="Taxonomy_By_Forms_Of_Energy"><a class="header-anchor" href="#Taxonomy_By_Forms_Of_Energy">#</a>Taxonomy By Forms Of Energy</h2>
<p>下图展示了按能的形式分类的图，这个分类图也不是完美的，例如在无线电部分分为<code>陆地无线电（Terrestrial Radio）</code>和<code>卫星无线电（Satellite）</code>，但实际上太空空间站的无线电部分两者都不符合。</p>
<p><img src="/ch_07_transmission_media/2019-12-01-15-46-54.png" alt="能力形式分类"></p>
<h1 id="Background_Radiation_And_Electrical_Noise"><a class="header-anchor" href="#Background_Radiation_And_Electrical_Noise">#</a>Background Radiation And Electrical Noise</h1>
<p>所有用电信号传输的电路都需要两根线，一根用来将信号传递给接收方，一根用来将反馈还给发送方。最简单的电传输方式就是使用两根铜线，每根线都用塑料包裹住，来防止相互之间的电干扰，在两根线外还有一层整个包裹起来，为了人方便使用。</p>
<p>但在线缆形式下有许多改进，这主要是因为电信号有以下特征：</p>
<ol>
<li>环境中有随机的电磁辐射，称为<code>噪音（Noise）</code>，如霓虹灯和电机就会发出随机的辐射。一般来说通信系统在正常运行状态下就会产生少量的噪音。</li>
<li>当电磁辐射遇到金属会被吸收进而产生细微的信号，这些信号会对正常的信号造成干扰。</li>
<li>正因为金属能吸收电磁辐射，所以可以用足够的金属放在噪声源和通信系统间，将其作为<code>防护（Shield）</code>。</li>
</ol>
<h2 id="Twisted_Pair_Copper_Wiring"><a class="header-anchor" href="#Twisted_Pair_Copper_Wiring">#</a>Twisted Pair Copper Wiring</h2>
<p>有三种形式的电缆可以减少电磁噪音的干扰：</p>
<ol>
<li>非屏蔽双绞线（Unshielded Twisted Pair, UTP）</li>
<li>同轴电缆（Coaxial cable）</li>
<li>屏蔽双绞线（Shielded Twisted Pair, STP）</li>
</ol>
<p>第一个形式，非屏蔽双绞线在通信中被广泛应用。如名字一样，双绞线是将两根铜线缠绕在一起的形式，这种相互缠绕的形式比两根线平行排布有更好的抗干扰性。如下图所示，（a）为平行排列，蓝线更接近辐射源，于是它相对于灰线吸收了更多的能量，而在（b）图的缠绕形式中，两根线都各有一部分更靠近辐射源，所以整体来说，两者收到的能量是相同的。</p>
<p><img src="/ch_07_transmission_media/2019-12-01-15-06-05.png" alt="双绞线"></p>
<h3 id="Shielding_Coaxial_Cable_And_Shielded_Twisted_Pair"><a class="header-anchor" href="#Shielding_Coaxial_Cable_And_Shielded_Twisted_Pair">#</a>Shielding: Coaxial Cable And Shielded Twisted Pair</h3>
<p>因为非屏蔽双绞线只是让两根线吸收了相同的能量，但噪音还是被吸收了，所以在一些情况下，非屏蔽双绞线仍然会产生问题，如有特别强的电噪音环境，或者特别接近噪声源，或者通信系统中的信号频率很高（频率越高对噪音越敏感）。为了解决这些问题，只能尽量的屏蔽噪声。</p>
<p>一种方法就是<code>同轴电缆（Coaxial Cable）</code>，它在线材的外层增加了一层<code>编织金属屏蔽(Braided metal shield)</code>（如网状）。使用编织样的金属层而非一整块金属层主要是处于便携性的考虑（后者的屏蔽性更好），但相对于非屏蔽双绞线，同轴电缆的便携性还是差的。如电视的信号线，一般都是同轴电缆，同轴电缆如下图所示：</p>
<p><img src="/ch_07_transmission_media/2019-12-01-15-19-14.png" alt="同轴电缆"></p>
<p>屏蔽双绞线则是非屏蔽双绞线和同轴电缆的混合，是两者形式的折中，他在一对或多对双绞线的外层使用了更薄的金属屏蔽层，很多情况下用铝来作为金属屏蔽层（铝更软）。</p>
<p>如之前节所述，为了避免铜线间的电干扰，铜线外层会包裹一层塑料。双绞线是将两个两个包裹着塑料的铜线绞在一起，同轴电缆则是在一根包裹住塑料的导线外包裹金属屏蔽层，屏蔽双绞线是在两根包裹着塑料的铜线绞在一起后再包裹较薄的金属层。</p>
<h3 id="Categories_Of_Twisted_Pair_Cable"><a class="header-anchor" href="#Categories_Of_Twisted_Pair_Cable">#</a>Categories Of Twisted Pair Cable</h3>
<p>一些标准机构为用于计算机网络的双绞线定义了标准，这些机构包括 <code>美国国家标准组织（American National Standards Institute，ANSI）</code>，<code>通信产业联合（Telecommunications Industry Association，TIA）</code>，<code>电子产业联合（Electronic Industries Alliance，EIA）</code>，下图为主要分类：</p>
<p><img src="/ch_07_transmission_media/2019-12-01-15-45-39.png" alt="双绞线分类"></p>
<h1 id="Media_Using_Light_Energy_And_Optical_Fibers"><a class="header-anchor" href="#Media_Using_Light_Energy_And_Optical_Fibers">#</a>Media Using Light Energy And Optical Fibers</h1>
<p>有三种形式的媒介是用光能携带数据的：<code>光纤（Optical Fibers）</code>，<code>红外线传输（Infrared transmission）</code>，<code>点对点激光（Point to Point lasers）</code>。</p>
<h2 id="Optical_Fibers"><a class="header-anchor" href="#Optical_Fibers">#</a>Optical Fibers</h2>
<p>其中最重要的类型是光纤：</p>
<ol>
<li>每根光纤都是一根包裹在塑料外层中的细玻璃线或者透明塑料。</li>
<li>光纤是用于单项传播的。在光纤的一段是一个激光或者 LED，用来发射光，另一端是连接一个感光设备用来检测光。如果数据需要双向传播，则需要用到两根光纤。多根光纤用塑料封壳包裹在一起生成光纤电缆。</li>
</ol>
<p>光纤无法被弯折成直角，但光纤仍然可以弯曲，甚至可以弯曲成一个直径小于 2 英寸的圆，让光纤在弯折状态下仍然可以正常工作，主要是因为光的传播特性。</p>
<p>光从一个低密度物质照射入另一个高密度物质，随着入射的角度不同，光的反应也会不同。存在一个特定的角度，当光以这个角度入射时，光会随着两个物质的交界处传播。当光的入射角大于这个角度时，光会被反射。当光的入射角小于这个角度时，光会发生折射。如下图所示：</p>
<p><img src="/ch_07_transmission_media/2019-12-03-08-31-03.png" alt="光的反射"></p>
<p>光纤运用的是光的反射，有一个特殊的镀层（Cladding）与光纤共同形成一个边界，在传输过程中，光会在上下两个边界内反射前进。</p>
<p>但反射的过程中是存在能量损耗的，而且因为光的反射，光传播的路径是比光的直线传播要长的，因此光在光纤一段发射后，抵达另一端时能量会更低，而且会更分散（Dispersed），如下图所示：</p>
<p><img src="/ch_07_transmission_media/2019-12-03-08-36-42.png" alt="光分散"></p>
<p>上图中，因为接受时的能量更低，所以 Y 轴值更低，且因为能量更分散，所以接受的时间也会拖长，因此在 X 轴上如同被拉伸。</p>
<h3 id="Types_Of_Fiber_And_Light_Transmission"><a class="header-anchor" href="#Types_Of_Fiber_And_Light_Transmission">#</a>Types Of Fiber And Light Transmission</h3>
<p>因为光在传输中的反射导致的分散在长距离使用光纤时会成为严重问题，因此有三个种类的光纤，不同的在性能与价格上权衡，</p>
<ol>
<li>跃变型多模光纤（Multimode，step index fiber）：这种类型的光纤，光纤与镀层中的边界很陡峭，因此光会在边界内频繁的反射，造成大量的能量分散，但是这种光纤价格最便宜。</li>
<li>渐变型多模光纤（Multimode，graded index fiber）：这种类型比跃变型多模稍贵，但是能减少反射进而有更少的能量分散。</li>
<li>单模光纤（Single mode fiber）：这种类型的光纤最贵，但也有最低能量分散。通常用于长距离传输和高比特率的传输。</li>
</ol>
<p>如之前节所述光纤的一端会用来发射光，另一端会用来接收光。在发射端，可以通过<code>发光二极管（Light Emitting Diode，LED）</code>，或者<code>激光二极管（Injection Laser Diode，ILD）</code>。在 接收端可以用<code>感光细胞（Phote-sensitive）</code>或者<code>光敏二极管（Photodiode）</code>。</p>
<h3 id="Optical_Fiber_Compared_To_Copper_Wiring"><a class="header-anchor" href="#Optical_Fiber_Compared_To_Copper_Wiring">#</a>Optical Fiber Compared To Copper Wiring</h3>
<p>光纤的优势：</p>
<ol>
<li>对电噪音免疫</li>
<li>更少的衰减（相对于铜线而言）</li>
<li>更高的带宽</li>
</ol>
<p>铜线的优势：</p>
<ol>
<li>更低的价格</li>
<li>更少的设备要求（光纤的接收端必须被有效的抛光）</li>
<li>更不易被损坏</li>
</ol>
<h2 id="Infrared_Communication_Technologies"><a class="header-anchor" href="#Infrared_Communication_Technologies">#</a>Infrared Communication Technologies</h2>
<p><code>红外线通信（Infrared Communication）</code>也是光能通信的一种，也是点对点技术的一种,电视遥控机就是红外线通信的应用。红外线的频率在人眼可见光的范围外，但是红外线仍然表现的如同可见光，它会很快的消散，可以在坚硬光滑表面反射，会被不透明物体阻挡，薄如纸片的物体会阻挡信号，甚至大气中的水气都会阻碍信号。</p>
<p>因此红外线通信适用于室内使用，适用于距离短且无阻挡的通信。</p>
<p>下图是三种红外线通信的常见技术：</p>
<p><img src="/ch_07_transmission_media/2019-12-03-09-54-25.png" alt="红外线通信技术"></p>
<h2 id="Point_To_Point_Laser_Communication"><a class="header-anchor" href="#Point_To_Point_Laser_Communication">#</a>Point-To-Point Laser Communication</h2>
<p><code>激光通信（Laser Communication）</code>是另一种点对点通信，如红外线通信一样，激光通信也需要一个无阻挡的路径。</p>
<p>但与红外线通信不同的是，激光通信只能覆盖很小的一片区域，激光的宽度通常只有几厘米（这里是宽度，并不是指长度），也正是因为激光的宽度很窄，所以激光传输的接收条件是比较苛刻的，通常是被永久的固定安装。</p>
<p>激光通信的典型应用是楼与楼之间的信号传输，通常在相邻大楼的外墙或者顶楼安装部署用于激光通信的发射和接收装置。</p>
<h1 id="Electromagnetic_Radio_Communication"><a class="header-anchor" href="#Electromagnetic_Radio_Communication">#</a>Electromagnetic(Radio) Communication</h1>
<p>常用 <code>无向性（unguided）</code> 来描述不需要任何介质来传播能量的通信方式。在计算机网络中最常用的依赖于电磁能的无向性技术是无线电传播（Radio Frequency Transmission）。无线电传播相较于光传播有个显著的优势，即可以长距离传播且可穿透阻碍物。</p>
<p>电磁能的使用依赖于他的频率属性，常用<code>波谱（Spectrum）</code>来描述可能的频率范围。全球的各政府分配不同频率的使用权，例如在美国是 <code>联邦通信委员会（Federal Communications Commission）</code>。下图是主要的能量频率波谱，其中无线电的范围基本是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mi>K</mi><mi>H</mi><mi>Z</mi></mrow><annotation encoding="application/x-tex">3KHZ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">3</span><span class="mord mathnormal" style="margin-right:0.08125em;">KH</span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>300</mn><mi>G</mi><mi>H</mi><mi>Z</mi></mrow><annotation encoding="application/x-tex">300GHZ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">300</span><span class="mord mathnormal">G</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span></span></span></span>。</p>
<p><img src="/ch_07_transmission_media/2019-12-03-14-44-01.png" alt="波谱"></p>
<h2 id="Signal_Propagation"><a class="header-anchor" href="#Signal_Propagation">#</a>Signal Propagation</h2>
<p>电磁波的频率也决定它传播时的特性，下表是波传播的三大类型：</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>频率范围</th>
<th>传播类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>低频</td>
<td>&lt; 2 MHZ</td>
<td>沿地球表面传输，可能会被地形阻挡</td>
</tr>
<tr>
<td>中频</td>
<td>2 到 30 MHZ</td>
<td>在大气层中反射传播，尤其是在电离层</td>
</tr>
<tr>
<td>高频</td>
<td>&gt;30 MHZ</td>
<td>直线传播，会被障碍物阻挡</td>
</tr>
</tbody>
</table>
<p>无线技术也可被分为以下两类：</p>
<ol>
<li>地表（Terrestrial）：依赖相对贴近地表的设备通信，例如无线电发射器和微博发射器。这些设备一般安装在山顶，人造塔或建筑上。</li>
<li>非地表（Nonterrestrial）：依赖于大气层外的设备，例如轨道卫星</li>
</ol>
<h2 id="Types_Of_Satellites"><a class="header-anchor" href="#Types_Of_Satellites">#</a>Types Of Satellites</h2>
<p>通信卫星可以根据距离地表的距离分为三类：</p>
<ol>
<li><code>近地轨道卫星（Low Earth Orbit,LEO）</code>：</li>
</ol>
<p>有低延迟的优点，但是与地球的相对位置变化的较快，接收端需要追踪卫星。</p>
<ol start="2">
<li><code>中地球轨道卫星（Medium Earth Orbit,MEO）</code>：</li>
</ol>
<p>为地球南北极提供信号的椭圆轨道卫星。</p>
<ol start="3">
<li><code>对地静止轨道卫星（Geostationary Earth Orbit,GEO）</code>：</li>
</ol>
<p>与地面可以保持固定角度，缺点是离地球较远，延迟大。</p>
<h3 id="Geostationary_Earth_Orbit_GEO_Satellites"><a class="header-anchor" href="#Geostationary_Earth_Orbit_GEO_Satellites">#</a>Geostationary Earth Orbit(GEO) Satellites</h3>
<p>从上节对于通信卫星的描述可以看出，通信卫星的权衡主要是在延迟和与轨道周期的权衡（轨道周期与地球自转相差越远，追踪卫星越难）。</p>
<p>这里以<code>对地静止轨道卫星（Geostationary Earth Orbit,GEO）</code>为例，对地静止轨道卫星的距离地表距离约为 35805 千米，计算过程如下：</p>
<p>因为卫星保持在轨道上，所以离心力与万有引力相等，即</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi>ω</mi><mn>2</mn></msup><mi>m</mi><mi>r</mi><mo>=</mo><mfrac><mrow><mi>G</mi><mi>M</mi><mi>m</mi></mrow><msup><mi>r</mi><mn>2</mn></msup></mfrac></mrow><annotation encoding="application/x-tex">{\omega}^2mr=\frac{GMm}{r^2}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8641em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord mathnormal">m</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">GM</span><span class="mord mathnormal">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>化简为：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi>r</mi><mn>3</mn></msup><mo>=</mo><mfrac><mrow><mi>G</mi><mi>M</mi></mrow><msup><mi>w</mi><mn>2</mn></msup></mfrac></mrow><annotation encoding="application/x-tex">r^3=\frac{GM}{w^2}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8641em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">GM</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>其中，G 是万有引力常数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>6.67</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mo>−</mo></msup><mn>20</mn><msup><mrow><mi>k</mi><mi>m</mi></mrow><mn>3</mn></msup><mi mathvariant="normal">/</mi><mi>k</mi><mi>g</mi><mo>⋅</mo><msup><mi>s</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">6.67\times 10^-20 {km}^3/kg\cdot {s^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">6.67</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.1484em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span></span></span></span></span><span class="mord">20</span><span class="mord"><span class="mord"><span class="mord mathnormal">km</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8984em;"><span style="top:-3.1473em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>，M 是地球质量为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5.976</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>24</mn></msup><mi>k</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">5.976\times 10^{24} kg</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">5.976</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0085em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">24</span></span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ω</mi></mrow><annotation encoding="application/x-tex">\omega</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span></span></span></span> 为角速度，如果要求对地静止，即角速度与地球自转相同，即：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>ω</mi><mo>=</mo><mfrac><mrow><mn>2</mn><mi>π</mi></mrow><mrow><mn>3600</mn><mo>∗</mo><mn>24</mn></mrow></mfrac><mo>=</mo><mn>7.29</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mrow><mo>−</mo><mn>5</mn></mrow></msup><mi>r</mi><mi>a</mi><mi>d</mi><mi mathvariant="normal">/</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">\omega = \frac{2\pi}{3600*24}=7.29\times10^{-5} rad/s
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0074em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3600</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">24</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">7.29</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.1141em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">5</span></span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal">d</span><span class="mord">/</span><span class="mord mathnormal">s</span></span></span></span></span></p>
<p>都代入上式，求得 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>=</mo><mn>42172</mn><mi>k</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">r=42172 km</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">42172</span><span class="mord mathnormal">km</span></span></span></span>，减去地球半径 6376km，得对地静止轨道卫星的距离地表距离约为35805 千米。</p>
<p>卫星距离如果不足这个数值，其旋转速度就会比地球快，在这个距离下，卫星与地表以相同的速度转动，所以地表上的卫星追踪装置在追踪到卫星后就不需要再次运动，因为两者的角度不会发生变化。但对地静止轨道卫星的最大缺陷是信号的延迟，信号的速度以光速计算，信号的一次来回需要：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>2</mn><mo>×</mo><mfrac><mrow><mn>35.8</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup><mtext> meters</mtext></mrow><mrow><mn>3</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>8</mn></msup><mtext>meters/sec</mtext></mrow></mfrac><mo>=</mo><mn>0.238</mn><mi>s</mi><mi>e</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">2\times \frac{35.8\times 10^6 \text{ meters}}{3\times 10^8 \text{meters/sec}}=0.238 sec
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.4271em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4911em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mord text"><span class="mord">meters/sec</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">35.8</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span><span class="mord text"><span class="mord"> meters</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.238</span><span class="mord mathnormal">sec</span></span></span></span></span></p>
<p>0.2 秒的延迟在许多领域上是无法被接受的。</p>
<h2 id="GEO_Coverage_Of_The_Earth"><a class="header-anchor" href="#GEO_Coverage_Of_The_Earth">#</a>GEO Coverage Of The Earth</h2>
<p>在对地静止轨道上的卫星数量是由限制的。为了避免星号键的相互干扰，卫星与卫星间必须有间隔，间隔的大小与信号的强度相关，但通常而言是 4-8 度，因为整个轨道是 360 度，所以对地静止轨道上最多有 45-90 颗卫星。</p>
<p>最少则需要三颗卫星来覆盖整个地球，如下图所示：</p>
<p><img src="/ch_07_transmission_media/2019-12-03-15-52-33.png" alt="最少三颗卫星"></p>
<p>证明如下，首先根据透视原理，距离一个球体越近，能看到球体的部分越少。在距离球体无限远的距离，最多也只能看到球体的 50%，如下图所示：</p>
<p><img src="/ch_07_transmission_media/2019-12-03-16-17-36.png" alt="透视原理"></p>
<p>将能看到球体的百分比设为 X，离球体的距离设为 d，求的半径设为 R，表达式为：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>X</mi><mo>=</mo><mfrac><mrow><mn>50</mn><mi mathvariant="normal">%</mi></mrow><mrow><mn>1</mn><mo>+</mo><mfrac><mi>R</mi><mi>d</mi></mfrac></mrow></mfrac></mrow><annotation encoding="application/x-tex">X=\frac{50\%}{1+\frac{R}{d}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.5343em;vertical-align:-1.1073em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.2377em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">50%</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.1073em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>式子是由等比三角形得出的，如下图：</p>
<p><img src="/ch_07_transmission_media/2019-12-03-16-23-46.png" alt="等比证明"></p>
<p>将地球半径 6376KM 及对地静止轨道距离 35805KM 代入，得能看到的范围是约为 42.45%，所以最少需要三颗卫星才能覆盖地球。</p>
<h2 id="Low_Earth_Orbit_LEO_Satellites_And_Clusters"><a class="header-anchor" href="#Low_Earth_Orbit_LEO_Satellites_And_Clusters">#</a>Low Earth Orbit(LEO) Satellites And Clusters</h2>
<p>近地轨道卫星的高度最多为 2000 千米，其主要的缺点在于无法与地面保持相同速度，因此地面上的天线必须旋转来追踪卫星。最低的近地轨道卫星在大约 90 分钟就可以环绕一遍地球，移动速度还是将对较快的，因此对于地面天线来说追踪有一定难度。</p>
<p>通常的解决方式是用卫星群（Clustering）或者阵列部署（Array Deployment）的卫星来解决追踪问题。一系列卫星一同工作来覆盖较大的区域。</p>
<p>如一条信息需要从欧洲传到北美，欧洲的地面基站向此时他上方的卫星发送数据，上方的卫星将信息在卫星群之间传播，一直传送到北美上方的卫星，北美上方的卫星再将信息传送给北美的地面基站。</p>
<h1 id="Tradeoffs_Among_Media_Types"><a class="header-anchor" href="#Tradeoffs_Among_Media_Types">#</a>Tradeoffs Among Media Types</h1>
<p>通信媒介的选择是复杂的，通常需要从以下几个方面权衡：</p>
<ol>
<li>花费（Cost）：材料，安装，操作，维护等的开销</li>
<li>数据速率（Data rate）：每秒可以传送多少数据</li>
<li>延迟（Delay）：数据传播和处理的延迟</li>
<li>信号影响（Affect on signal）：信号是否会衰减和失真</li>
<li>环境（Environment）：对干扰的敏感性和电子噪音</li>
<li>安全性（Security）：是否容易被窃听</li>
</ol>
<h1 id="Measuring_Transmission_Media"><a class="header-anchor" href="#Measuring_Transmission_Media">#</a>Measuring Transmission Media</h1>
<p>可以从两个方面来评判传输媒介：<code>传播延迟（Progagation Delay）</code>和<code>信道容量（Channel Capacity）</code>。</p>
<p><code>奈奎斯特第一准则（Nyquist Theorem）</code> 表明在理想低通信道下的最高码元速率速率是带宽的 2 倍。假设有 K 个电平，则一个码元能传输的 bit 数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>K</mi></mrow><annotation encoding="application/x-tex">log_2K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> ，B 表示信道的带宽，因此数据速率可以表达为：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>D</mi><mo>=</mo><mn>2</mn><mi>B</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>K</mi><mtext> bits /s</mtext></mrow><annotation encoding="application/x-tex">D=2Blog_2K \text{ bits /s}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.01968em;">Bl</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord text"><span class="mord"> bits /s</span></span></span></span></span></span></p>
<p>下面证明奈奎斯特准则：</p>
<p>一个有限带宽的低通滤波器，如果其截至频率为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mi>g</mi></msub></mrow><annotation encoding="application/x-tex">\omega_g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> 其频域图如下：</p>
<p><img src="/ch_07_transmission_media/2019-12-03-17-06-01.png" alt="低通滤波器频域"></p>
<p>该滤波器的时域相应图为：</p>
<p><img src="/ch_07_transmission_media/2019-12-03-17-07-06.png" alt="低通滤波器时域"></p>
<p>时域的相应波形时一个拖尾的连续信号，这个拖尾会干扰后续信号。但是从波形上可以看出，在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mfrac><mi>π</mi><msub><mi>ω</mi><mi>s</mi></msub></mfrac><mo separator="true">,</mo><mfrac><mrow><mn>2</mn><mi>p</mi><mi>i</mi></mrow><msub><mi>ω</mi><mi>s</mi></msub></mfrac><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">t=\frac{\pi}{\omega_s},\frac{2pi}{\omega_s}...</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.3529em;vertical-align:-0.4451em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6954em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:-0.0359em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4451em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9078em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:-0.0359em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4451em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord">...</span></span></span></span>处是 0，所以如果在这些间隔点发送码元，则不会被干扰。这些点的间隔时间为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>s</mi></msub><mo>=</mo><mfrac><mi>π</mi><msub><mi>ω</mi><mi>s</mi></msub></mfrac><mo>=</mo><mfrac><mn>1</mn><mrow><mn>2</mn><msub><mi>f</mi><mi>m</mi></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">T_s=\frac{\pi}{\omega_s}=\frac{1}{2f_m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1405em;vertical-align:-0.4451em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6954em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:-0.0359em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4451em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.3262em;vertical-align:-0.4811em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:-0.1076em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4811em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，所以码元速率为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>=</mo><mfrac><mn>1</mn><msub><mi>T</mi><mi>s</mi></msub></mfrac><mo>=</mo><mn>2</mn><msub><mi>f</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">R=\frac{1}{T_s}=2f_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2902em;vertical-align:-0.4451em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:-0.1389em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4451em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">2</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<h2 id="The_Effect_of_Noise_On_Communication"><a class="header-anchor" href="#The_Effect_of_Noise_On_Communication">#</a>The Effect of Noise On Communication</h2>
<p>奈奎斯特定理提供了了理论上的最高码元速率，因为他并没有将噪音纳入考虑， 而实际中噪音不可避免。香农在此基础上给出了考虑噪音的数据速率，称为香农定理（Shannon’s Theorem）：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>C</mi><mo>=</mo><mi>B</mi><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>S</mi><mi mathvariant="normal">/</mi><mi>N</mi><mo stretchy="false">)</mo><mi>b</mi><mi>i</mi><mi>t</mi><mi>s</mi><mi mathvariant="normal">/</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">C=B\log_2(1+S/N) bits/s
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mord mathnormal">bi</span><span class="mord mathnormal">t</span><span class="mord mathnormal">s</span><span class="mord">/</span><span class="mord mathnormal">s</span></span></span></span></span></p>
<p>其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi mathvariant="normal">/</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">S/N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 称为信噪比，式子中并没有给出电平数量 K，这是因为实际上在考虑噪声时，电平数量是受噪声影响的，噪声越大，为了避免干扰，电平的间隔就只能越大，因此电平数量就越少。</p>
<h2 id="The_Significance_Of_Channel_Capacity"><a class="header-anchor" href="#The_Significance_Of_Channel_Capacity">#</a>The Significance Of Channel Capacity</h2>
<p>奈奎斯特定律鼓励工程师探索更高效的编码方式，因为在最高码元速率受信道带宽限制时，编码方式越高效，一个码元携带的数据就越多，单位时间内就能传输更多的比特。</p>
<p>香农定理给出了真实环境下，数据速率的上限，即无论编码多么高效，在非理想环境（有噪声）下，每秒最大的比特传输量</p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《Computer Networks and Internets》 Ch 08 可靠性及信道编码</title>
    <url>/ch_08_reliability_and_channel_coding/</url>
    <content><![CDATA[<h1 id="Introduction"><a class="header-anchor" href="#Introduction">#</a>Introduction</h1>
<p>这一部分将介绍信息传输过程中发生错误的原因，以及纠错的方式——信道编码。本部分将着重介绍前向错误纠正技术，并引出汉明距离等概念。</p>
<h1 id="The_Three_Main_Sources_Of_Transmission_Errors"><a class="header-anchor" href="#The_Three_Main_Sources_Of_Transmission_Errors">#</a>The Three Main Sources Of Transmission Errors</h1>
<p>传输中发生的错误可以分为三大类：</p>
<ol>
<li>干扰（Interference）：如第七章所述，环境中存在许多电磁干扰，这些电磁干扰会阻碍无线电传输和线缆中的信号传输。</li>
<li>失真（Distortion）：所有的物理系统都会造成信号的失真。光纤中的光因为移动距离的增加，时域会发生扩张（频域也因此变化）。信道容量会导致一些频率的信号被过滤掉。放在线缆旁边的金属可能会改变线缆内信号的频率，金属也能干扰无线电信号。</li>
<li>衰弱（Attenuation）：信号在媒介中传输的过程中，信号会逐渐衰弱。</li>
</ol>
<p>香农定理给出了减少错误的思路：提高信噪比。</p>
<p>但无论如何噪声不可能被完全的消除，所以许多方法致力于检测错误，在某些情况下自动修复错误。</p>
<p>但是错误的监测机制无疑是会为系统增加开销的，因此系统设计时要考虑在错误影响与错误检测开销间做权衡，如金融系统，1bit 的错误可能会造成很严重的错误，但是在图片中 1bit 的错误可能根本无法被识别到。</p>
<h1 id="Effect_Of_Transmission_Errors_On_Data"><a class="header-anchor" href="#Effect_Of_Transmission_Errors_On_Data">#</a>Effect Of Transmission Errors On Data</h1>
<p>这里要区分传输错误与数据错误，数据是由传输信号在经过例如解码，解调后得到的。传输错误最后都会导致最后的数据出错。主要有三类传输造成的数据错误：</p>
<ol>
<li>
<p>单元位错误（Single Bit Error）：即一系列数据中，只有一位数据被改变了。这通常是因为传输信号的短时间（称为脉冲，Spike）干扰造成的。</p>
</li>
<li>
<p>突发性错误：一系列数据中有多位数据被改变，通常是由长时间的干扰造成的。错误长度是由错误开始位到错误结束位直接的位数决定。如下表，错误的数据由加粗表示，错误长度是 7：</p>
<table>
<thead>
<tr>
<th>发送</th>
<th>1</th>
<th>0</th>
<th>1</th>
<th>1</th>
<th>0</th>
<th>0</th>
<th>0</th>
<th>1</th>
<th>0</th>
<th>1</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr>
<td>接收</td>
<td>1</td>
<td>0</td>
<td><strong>0</strong></td>
<td>1</td>
<td><strong>1</strong></td>
<td>0</td>
<td><strong>1</strong></td>
<td><strong>0</strong></td>
<td><strong>1</strong></td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
</li>
</ol>
<h1 id="Two_Strategies_For_Handling_Channel_Errors"><a class="header-anchor" href="#Two_Strategies_For_Handling_Channel_Errors">#</a>Two Strategies For Handling Channel Errors</h1>
<p>有一系列的方法解决数据错误并增加数据的可靠性，这些方法统称为<code>信道编码(Channel Coding)</code>，这些方法可以被分为两类：<code>前向错误纠正技术（Forward Error Correction，FEC）</code>，<code>自动重传请求技术（Automatic Repeat reQuest，ARQ）</code>。</p>
<p>前向错误纠正技术的主题思想是在发送的数据中增加额外的信息，接收端可以根据这些额外信息来判断是否有错误发生，有些方法可以检测出究竟是哪一位数据发生了错误，并在可能的情况下纠正错误。</p>
<p>自动重传请求技术是让接收端和发送端互换数据来保证数据被正确的传递。</p>
<h1 id="Block_And_Convolutional_Error_Codes"><a class="header-anchor" href="#Block_And_Convolutional_Error_Codes">#</a>Block And Convolutional Error Codes</h1>
<p>前向错误纠正技术可以再细分为两类：</p>
<ol>
<li>分组错误码（Block Error Codes）：分组错误码是将数据分成一块块的，然后对每一块都增加额外信息。每一块的额外信息只针对于该块数据本身。</li>
<li>卷积错误码（Convolutional Error Codes）：卷积错误码是将数据看作一系列 bits，增加的额外信息是由当前的 bit 和之前的 bit 共同决定的。</li>
</ol>
<p>卷积错误码相对于分组错误码需要更多的计算，但是也更能检测出错误。</p>
<h1 id="An_Example_Block_Error_Code_Single_Parity_Checking"><a class="header-anchor" href="#An_Example_Block_Error_Code_Single_Parity_Checking">#</a>An Example Block Error Code: Single Parity Checking</h1>
<p>单一奇偶校验检查（Single Parity Checking）是分组错误码检测的一个例子，可以再分为偶校验检查和奇校验检查。如果将数据分为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> bit 一组，那么每一组增加一位数据，当是偶校验时，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 位数据+1 位额外数据应该一共有偶数个 1，当是奇校验时，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 位数据+1 位额外数据应该一共有奇数个 1。下表为 8 位数据时的例子：</p>
<table>
<thead>
<tr>
<th>原始数据</th>
<th>偶校验</th>
<th>奇校验</th>
</tr>
</thead>
<tbody>
<tr>
<td>00000000</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>01011011</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>01010101</td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>单一奇偶校验是一个比较弱的信道编码，他只能检测错误，但无法检测出错误具体出现在哪一位，也无法纠正错误。而且当有偶数个位发生错误时，错误就无法被检测出来。</p>
<h1 id="The_Mathematics_of_Block_Error_Codes_And_n_k_Notation"><a class="header-anchor" href="#The_Mathematics_of_Block_Error_Codes_And_n_k_Notation">#</a>The Mathematics of Block Error Codes And (n,k) Notation</h1>
<p>如有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 位 bit 的数据，我们将所有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span> 种可能出现的数据称为<code>数据字(Datawords)</code>，在这些数据中增加 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> 位额外数据，一共有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mi>k</mi><mo>+</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">n=k+r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> 个数据，所有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span> 种可能称为<code>编码字(codeworks)</code>，其中编码字中合法的部分，即额外添加的数据与原数据时符合规则的部分，称为<code>码书(Codebook)</code>，并将这种方法标记为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo separator="true">,</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n,k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></p>
<p>如单一奇偶校验中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>8</mn><mo separator="true">,</mo><mi>r</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k=8,r=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，因此一共有 256 个数据字，也对应了有 256 个合法的编码字，一共有 512 个编码字。</p>
<p>在理想状态下，合法编码字中的任一一位被改变了，改变后的编码字就不是合法编码字。但是在单一奇偶校验的例子中，如果同时改变了合法编码字中的两位，那么结果仍然是一个合法编码字。</p>
<p>没有一个信道编码可以达到理想状态，所以要考虑的就是，合法编码字最少多少位数据要被同时改变，才能产生另一个合法编码字。在单一数字编码中，这个位数为 2。</p>
<h1 id="Hamming_Distance：A_Measure_Of_A_Code’s_Strength"><a class="header-anchor" href="#Hamming_Distance：A_Measure_Of_A_Code’s_Strength">#</a>Hamming Distance：A Measure Of A Code’s Strength</h1>
<p>汉明距离（Hamming Distance）是用来测量一个合法编码字要转换为另一个合法编码字最少要改变的数据位数的方法中需要用到的概念。如果给定两个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>长度的字符，两个字符的汉明距离就是两个字符间不同的数据数量。</p>
<p>如<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo stretchy="false">(</mo><mn>000</mn><mo separator="true">,</mo><mn>001</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">(</mo><mn>000</mn><mo separator="true">,</mo><mn>101</mn><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">(</mo><mn>000</mn><mo separator="true">,</mo><mn>111</mn><mo stretchy="false">)</mo><mo>=</mo><mn>3</mn><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">(</mo><mn>101</mn><mo separator="true">,</mo><mn>001</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">d(000,001)=1,d(000,101)=2,d(000,111)=3,d(101,001)=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord">000</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">001</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord">000</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">101</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord">000</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">111</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord">101</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">001</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>。</p>
<p>可以先对两个字符求异或，然后计算异或出来的字符 1 的总数，即为汉明距离。</p>
<h1 id="The_Hamming_Distance_Among_String_In_A_Codebook"><a class="header-anchor" href="#The_Hamming_Distance_Among_String_In_A_Codebook">#</a>The Hamming Distance Among String In A Codebook</h1>
<p>为了计算出一个合法编码字要转换为另一个合法编码字最少要改变的数据位数，先要计算出码书中所有编码字组合的汉明距离。如对 2 位 bit 数据进行单一奇校验检测：</p>
<table>
<thead>
<tr>
<th>数据字</th>
<th>编码字</th>
</tr>
</thead>
<tbody>
<tr>
<td>00</td>
<td>001</td>
</tr>
<tr>
<td>01</td>
<td>010</td>
</tr>
<tr>
<td>10</td>
<td>100</td>
</tr>
<tr>
<td>11</td>
<td>111</td>
</tr>
</tbody>
</table>
<p>一共有 4 个编码字，4 个编码字一一配对一共有 6 种可能，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo stretchy="false">(</mo><mn>001</mn><mo separator="true">,</mo><mn>010</mn><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">(</mo><mn>010</mn><mo separator="true">,</mo><mn>100</mn><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">(</mo><mn>001</mn><mo separator="true">,</mo><mn>100</mn><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">(</mo><mn>010</mn><mo separator="true">,</mo><mn>111</mn><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">(</mo><mn>001</mn><mo separator="true">,</mo><mn>111</mn><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">(</mo><mn>100</mn><mo separator="true">,</mo><mn>111</mn><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">d(001,010)=2,d(010,100)=2,d(001,100)=2,d(010,111)=2,d(001,111)=2,d(100,111)=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord">001</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">010</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord">010</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">100</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord">001</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">100</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord">010</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">111</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord">001</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">111</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord">100</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">111</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>。6 种可能中最小的汉明距离是 2，所以最少需要更改 2 位数据才能从一个合法编码字变为另一个合法编码字。</p>
<p>因此计算从一个合法编码字转换为另一个合法编码字最少要改变的数据位数过程是，计算出所有码书中的编码字（即合法编码字）两两配对后的所有汉明距离 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">d_{min}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">min</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，其中的最小值即为所求值。</p>
<h1 id="The_Tradeoff_Between_Error_Detection_And_Overhead"><a class="header-anchor" href="#The_Tradeoff_Between_Error_Detection_And_Overhead">#</a>The Tradeoff Between Error Detection And Overhead</h1>
<p>对于一个编码，最多的能被检测出来的错误位数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>=</mo><msub><mi>d</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">e=d_{min}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">min</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，如单一奇偶校验，因为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">d_{min}=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">min</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>，所以最多能正确检测出来的错误位数为 1。</p>
<p>虽然<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">d_{min}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">min</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>越大能检测出来的错误位数越多，但这也意味着要增加更多的额外数据，对于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo separator="true">,</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n,k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>的编码，工程师用编码率（Code Rate）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>=</mo><mfrac><mi>k</mi><mi>n</mi></mfrac></mrow><annotation encoding="application/x-tex">R=\frac{k}{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2251em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>来表示为了检测出错误信息的编码开销。</p>
<h1 id="Error_Correction_With_Row_And_Column_RAC_Parity"><a class="header-anchor" href="#Error_Correction_With_Row_And_Column_RAC_Parity">#</a>Error Correction With Row And Column(RAC) Parity</h1>
<p>奇偶校验本身是不能进行错误纠正的，但是通过<code>行列奇偶校验（Row And Column Parity）</code>就可以做到。如一共有 12 个 bit 的原始数据，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>12</mn></mrow><annotation encoding="application/x-tex">k=12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">12</span></span></span></span>，排成三行四列每一列每一行都进行奇偶校验，增加一个额外位，则一共 8 个额外位，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>=</mo><mn>8</mn><mtext>，</mtext><mi>n</mi><mo>=</mo><mi>k</mi><mo>+</mo><mi>r</mi><mo>=</mo><mn>20</mn></mrow><annotation encoding="application/x-tex">r=8，n=k+r=20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">8</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">20</span></span></span></span>，因此这是一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>20</mn><mo separator="true">,</mo><mn>12</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(20,12)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">20</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">12</span><span class="mclose">)</span></span></span></span>的编码，如下图所示：</p>
<p><img src="/ch_08_reliability_and_channel_coding/2019-12-05-14-46-47.png" alt="行列奇偶校验"></p>
<p>因此如果一位数据出错，会同时在对应的行和列校验位感知到，因此就可以定位到错误的数据，取反后就能纠正数据。</p>
<p>奇偶校验数据的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">d_{min}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">min</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>还是 2，因此如果错误的位数大于 1，当是偶数时无法被检测到，当是奇数时虽然能检测出错误，但无法纠正。</p>
<h1 id="The_16_Bit_Checksum_Used_In_The_Internet"><a class="header-anchor" href="#The_16_Bit_Checksum_Used_In_The_Internet">#</a>The 16-Bit Checksum Used In The Internet</h1>
<p>有个称为<code>因特网校验和（Internet checksum）</code>的信道编码方法在网络中扮演了重要角色。这个算法的输入可以是任意长度，将输入拆分为一段段 16 字节的的部分，如果不能长度不能被 16 整除，则最后补 0。如下图所示：</p>
<p><img src="/ch_08_reliability_and_channel_coding/2019-12-06-17-25-08.png" alt="拆分为16字节"></p>
<p>算法的流程如下：</p>
<ol>
<li>将输入拆分为以 16-bit 为一组</li>
<li>定义一个 32-bit 的变量（这里称为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>）作为结果。</li>
<li>将每一组 16-bit 的数据累加给<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span></li>
<li>将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>的前 16 位累加给后 16 位</li>
<li>将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>的后 16 位取反，如果取反后全是 0，则将其改为全是 1</li>
<li>此时<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>的 16 位即为校验和。</li>
</ol>
<p>可以看出最后的校验和也是 16 位的数据，将校验和作为新的一组 16-bit 放在原数据后（经过了补 0 的原数据）发送出去。接收端接受信息后重复算法流程，如果数据没有发生错误，最后接收端计算出的校验和应该是 FFFF。</p>
<p>下面以两个例子进行说明：</p>
<ol>
<li>
<p>例子 1<br>
如果发送端输入数据为<code>0100 1000 0110 0101</code>，<code>0110 1100 0110 1100</code>，<code>0110 1111 0010 0001</code>，计算过程如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">   0100 1000 0110 0101</span><br><span class="line">   0110 1100 0110 1100</span><br><span class="line">+  0110 1111 0010 0001</span><br><span class="line">----------------------------</span><br><span class="line">1  0010 0011 1111 0010</span><br></pre></td></tr></table></figure>
<p>将高 16 位移到后 16 位</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">  0010 0011 1111 0010</span><br><span class="line">+                   1</span><br><span class="line">-------------------------</span><br><span class="line">  0010 0011 1111 0011</span><br></pre></td></tr></table></figure>
<p>取反后得到：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1101 1100 0000 1100</span><br></pre></td></tr></table></figure>
<p>这即为校验和</p>
<p>对于接收端，因为将校验和也一并发送了过去，所以接收端的计算过程如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">   0100 1000 0110 0101</span><br><span class="line">   0110 1100 0110 1100</span><br><span class="line">   0110 1111 0010 0001</span><br><span class="line">+  1101 1100 0000 1100</span><br><span class="line">----------------------------</span><br><span class="line">1  1111 1111 1111 1110</span><br></pre></td></tr></table></figure>
<p>将高 16 位移到后 16 位</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">  1111 1111 1111 1110</span><br><span class="line">+                   1</span><br><span class="line">-------------------------</span><br><span class="line">  1111 1111 1111 1111</span><br></pre></td></tr></table></figure>
<p>取反后得到：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">0000 0000 0000 0000</span><br></pre></td></tr></table></figure>
<p>因为全为 0，所以改为全为 1</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1111 1111 1111 1111</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>例子 2<br>
如果发送端输入数据为<code>1111 1111 1111 1111</code>，<code>1111 1111 1111 1111</code>，<code>0000 0000 0000 0001</code>，计算过程如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">   1111 1111 1111 1111</span><br><span class="line">   1111 1111 1111 1111</span><br><span class="line">+  0000 0000 0000 0001</span><br><span class="line">----------------------------</span><br><span class="line">1  1111 1111 1111 1111</span><br></pre></td></tr></table></figure>
<p>将高 16 位移到后 16 位</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">  1111 1111 1111 1111</span><br><span class="line">+                   1</span><br><span class="line">-------------------------</span><br><span class="line">1 0000 0000 0000 0000</span><br></pre></td></tr></table></figure>
<p>此时虽然高 16 仍然有数值，但不需要再次累加，后 16 位取反后得到：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1111 1111 1111 11111</span><br></pre></td></tr></table></figure>
<p>这即为校验和</p>
<p>对于接收端，因为将校验和也一并发送了过去，所以接收端的计算过程如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">   1111 1111 1111 1111</span><br><span class="line">   1111 1111 1111 1111</span><br><span class="line">   0000 0000 0000 0001</span><br><span class="line">+  1111 1111 1111 1111</span><br><span class="line">----------------------------</span><br><span class="line">10 1111 1111 1111 1110</span><br></pre></td></tr></table></figure>
<p>将高 16 位移到后 16 位</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">  1111 1111 1111 1110</span><br><span class="line">+                  10</span><br><span class="line">-------------------------</span><br><span class="line">1 0000 0000 0000 0000</span><br></pre></td></tr></table></figure>
<p>取反后得到：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1111 1111 1111 1111</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="Cyclic_Redundancy_Codes_CRCs"><a class="header-anchor" href="#Cyclic_Redundancy_Codes_CRCs">#</a>Cyclic Redundancy Codes(CRCs)</h1>
<p>在高速网络中，有一个称为<code>循环冗余码(Cyclic Redundancy Codes,CRCs)</code>的信道编码方法。循环冗余码有三个主要优点：</p>
<ol>
<li>可以对任意长度的数据进行计算</li>
<li>可以充分的检测出错误</li>
<li>可以通过硬件实现，所以非常的高效</li>
</ol>
<p>求<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>R</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">CRC</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">CRC</span></span></span></span>的计算过程可以看作是两个二进制数的相除，一个代表原数据，一个代表一个特定的除数（可根据不同的情况设置，除数的设置决定错误检测的能力），如果需要求得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>长度的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>R</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">CRC</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">CRC</span></span></span></span>，则需要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>长度的被除数。二进制数相除的过程可以看作是多项式相除，如果原数据是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1010</mn></mrow><annotation encoding="application/x-tex">1010</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1010</span></span></span></span>，除数设置为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1011</mn></mrow><annotation encoding="application/x-tex">1011</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1011</span></span></span></span>，则计算过程如下图：</p>
<p><img src="/ch_08_reliability_and_channel_coding/2019-12-07-00-01-18.png" alt="CRC计算过程"></p>
<h1 id="An_Efficient_Hardware_Implementation_Of_CRC"><a class="header-anchor" href="#An_Efficient_Hardware_Implementation_Of_CRC">#</a>An Efficient Hardware Implementation Of CRC</h1>
<p>CRC 算法的实现硬件是由<code>移位寄存器(Shift Register)</code>和<code>异或门(Exclusive or gates)</code>构成的。在计算 CRC 前，硬件会初始化将移位寄存器中的所有位改为 0，上例中的除数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1011</mn></mrow><annotation encoding="application/x-tex">1011</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1011</span></span></span></span>，对应的硬件图如下：</p>
<p><img src="/ch_08_reliability_and_channel_coding/2019-12-07-00-06-02.png" alt="1011硬件"></p>
<p>TODO：为什么这么设计的原因。</p>
<h1 id="Automatic_Repeat_Request_ARQ_Mechanisms"><a class="header-anchor" href="#Automatic_Repeat_Request_ARQ_Mechanisms">#</a>Automatic Repeat Request(ARQ) Mechanisms</h1>
<p>自动重传请求技术（Automatic Repeat Request,ARQ）需要发送端和接收端传递信息来检测错误。当一方发送数据给另一方时，接收方需要传递一个回执给发送方。如果在一段时间后发送方仍然没有收到回执，则认为数据丢失，重新发送数据。</p>
<p>自动重传请求技术适合只能检测错误，但不能修复错误的系统。当接收方检测出数据有错误后，将数据丢弃并不传递回执，那么发送方就会再次发送数据。</p>
<h1 id="Reference"><a class="header-anchor" href="#Reference">#</a>Reference</h1>
<p><a href="https://en.wikipedia.org/wiki/Polynomial_long_division">多项式除法</a><br>
<a href="https://heasarc.gsfc.nasa.gov/docs/heasarc/ofwg/docs/general/checksum/node11.html">1’s Complement Arithmetic</a></p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《Head First 设计模式》 Ch 08 模板方法模式</title>
    <url>/ch_08_the_template_method_pattern/</url>
    <content><![CDATA[<p>模版方法模式（Template Method Pattern）定义了一个算法的操作步骤，但其中的某些步骤需要派生来对应实现。</p>
<ul>
<li>
<p>工厂方法&gt;模式就是模版方法模式的一种运用。</p>
</li>
<li>
<p>策略模式和模版方法模式都是将算法的实现抽象出来，不同的是策略模式的实现依靠组成，而模版方法模式依靠继承。</p>
</li>
</ul>
<p>例如我们需要准备咖啡和茶，准备咖啡基本步骤为烧开水，加入咖啡粉，将咖啡倒入杯子，增加牛奶或糖（可选），准备茶的基本步骤为烧开水，加入茶粉，将茶倒入杯子，增加柠檬（可选）。我们发现在制作两个饮料的过程中，烧开水和倒入杯子这两个步骤是一样的，剩下的两个步骤，向烧开的水中增加相应的粉和增加配料，这两部分也是类似的，于是我们可以用模版方法模式，将这两步骤作为抽象方法。</p>
<h1 id="代码示例"><a class="header-anchor" href="#代码示例">#</a>代码示例</h1>
<h2 id="算法模版基类"><a class="header-anchor" href="#算法模版基类">#</a>算法模版基类</h2>
<figure class="highlight cs"><figcaption><span>咖啡因饮料模版</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">CaffeineBeverage</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrepareRecipe</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        boilWater();</span><br><span class="line">        brew();</span><br><span class="line">        pourInCup();</span><br><span class="line">        <span class="keyword">if</span> (NeedCondiments())</span><br><span class="line">            addCondiments();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">brew</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">addCondiments</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">boilWater</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Boiling Water&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pourInCup</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Pouring Water&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">bool</span> <span class="title">NeedCondiments</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note info simple"><p>例子中<code>brew</code>和<code>addCondiments</code>即为模版函数，而<code>NeedCondiments</code>这种提供了基本实现，但派生类中仍然可以重写的函数被称为钩子（<code>Hook</code>）。</p>
</div>
<h2 id="咖啡因饮料实现"><a class="header-anchor" href="#咖啡因饮料实现">#</a>咖啡因饮料实现</h2>
<figure class="highlight cs"><figcaption><span>咖啡</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Coffee</span> : <span class="title">CaffeineBeverage</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">addCondiments</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Add sugar and Milk&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">brew</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Dripping coffee through filter&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> <span class="title">NeedCondiments</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>茶</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Tea</span> : <span class="title">CaffeineBeverage</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">addCondiments</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Adding lemon&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">brew</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Steeping the tea&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="测试代码及结果"><a class="header-anchor" href="#测试代码及结果">#</a>测试代码及结果</h1>
<figure class="highlight cs"><figcaption><span>测试代码</span></figcaption><table><tr><td class="code"><pre><span class="line">Coffee coffee = <span class="keyword">new</span> Coffee();</span><br><span class="line">Tea tea = <span class="keyword">new</span> Tea();</span><br><span class="line">coffee.PrepareRecipe();</span><br><span class="line">Console.WriteLine();</span><br><span class="line">tea.PrepareRecipe();</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<p><img src="/ch_08_the_template_method_pattern/2019-02-03-15-59-58.png" alt="模版方法模式运行结果"></p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>《Head First 设计模式》 Ch 09 模板方法模式</title>
    <url>/ch_09_the_iterator_and_composite_pattern/</url>
    <content><![CDATA[<h1 id="迭代器模式"><a class="header-anchor" href="#迭代器模式">#</a>迭代器模式</h1>
<p>迭代器模式(Iterator Pattern)提供了一种访问聚合对象但不需要关心其内部实现方法的方式。</p>
<p>例如我们存在两个菜单，第一个菜单表示早餐，第二个表示晚餐，第一个菜单其中的菜品用<code>List</code>来存储，第二个菜单其中的菜品用<code>Array</code>来存储。在这种情况下就需要使用迭代器模式，为两个菜单提供一个供外部调用的访问菜品的接口。</p>
<h2 id="代码示例"><a class="header-anchor" href="#代码示例">#</a>代码示例</h2>
<p>我们在两个菜单类中添加<code>createIterator</code>函数来返回迭代器，对于外部调用者，如测试代码中的<code>PrintMenu</code>,它只需要调用<code>hasNext</code>及<code>next</code>即可而不需要关心菜单中的具体实现。</p>
<h3 id="菜单"><a class="header-anchor" href="#菜单">#</a>菜单</h3>
<figure class="highlight cs"><figcaption><span>Pancake菜单</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PancakeHouseMenu</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;MenuItem&gt; menuItemsList = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PancakeHouseMenu</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        menuItemsList = <span class="keyword">new</span> List&lt;MenuItem&gt;();</span><br><span class="line">        addItem(<span class="string">&quot;K&amp;B&#x27;s Pancake Breakfast&quot;</span>, <span class="string">&quot;Pancake with eggs and toast&quot;</span>, <span class="literal">true</span>, <span class="number">2.99f</span>);</span><br><span class="line">        addItem(<span class="string">&quot;Regular&#x27;s Pancake Breakfast&quot;</span>, <span class="string">&quot;Pancake with eggs and sausags&quot;</span>, <span class="literal">true</span>, <span class="number">2.99f</span>);</span><br><span class="line">        addItem(<span class="string">&quot;Blueberry&#x27;s Pancake Breakfast&quot;</span>, <span class="string">&quot;Pancake with eggs and fresh blueberries&quot;</span>, <span class="literal">true</span>, <span class="number">2.99f</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">createIterator</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PancakeIterator(menuItemsList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addItem</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">string</span> description, <span class="built_in">bool</span> vegetarian, <span class="built_in">float</span> price</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        MenuItem menuItem = <span class="keyword">new</span> MenuItem(name, description, vegetarian, price);</span><br><span class="line">        menuItemsList.Add(menuItem);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>Diner菜单</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DinerMenu</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">int</span> MaxItemsCount = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">private</span> MenuItem[] menuItemsArray = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> numberOfItems = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DinerMenu</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        menuItemsArray = <span class="keyword">new</span> MenuItem[MaxItemsCount];</span><br><span class="line">        addItem(<span class="string">&quot;Vegetarian BLT&quot;</span>, <span class="string">&quot;Fakin Bacon with tomato&quot;</span>, <span class="literal">true</span>, <span class="number">2.99f</span>);</span><br><span class="line">        addItem(<span class="string">&quot;BLT&quot;</span>, <span class="string">&quot;Bacon with tomato&quot;</span>, <span class="literal">true</span>, <span class="number">3.99f</span>);</span><br><span class="line">        addItem(<span class="string">&quot;Soup of the day&quot;</span>, <span class="string">&quot;Soup of the day and salad&quot;</span>, <span class="literal">false</span>, <span class="number">3.29f</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addItem</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">string</span> description, <span class="built_in">bool</span> vegetarian, <span class="built_in">float</span> price</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (numberOfItems &gt;= MaxItemsCount)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        MenuItem menuItem = <span class="keyword">new</span> MenuItem(name, description, vegetarian, price);</span><br><span class="line">        menuItemsArray[numberOfItems++] = menuItem;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">createIterator</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DinerMenuIterator(menuItemsArray);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="迭代器接口及实现"><a class="header-anchor" href="#迭代器接口及实现">#</a>迭代器接口及实现</h3>
<figure class="highlight cs"><figcaption><span>迭代器接口</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Iterator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">bool</span> <span class="title">hasNext</span>()</span>;</span><br><span class="line">    <span class="function"><span class="built_in">object</span> <span class="title">next</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>迭代器实现</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PancakeIterator</span> : <span class="title">Iterator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;MenuItem&gt; itemsList = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> currentPosition = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PancakeIterator</span>(<span class="params">List&lt;MenuItem&gt; itemsList</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.itemsList = itemsList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">hasNext</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> currentPosition &lt; itemsList.Count &amp;&amp; itemsList[currentPosition] != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">next</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> itemsList[currentPosition++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DinerMenuIterator</span> : <span class="title">Iterator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> MenuItem[] itemsArray = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> currentPosition = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DinerMenuIterator</span>(<span class="params">MenuItem[] items</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.itemsArray = items;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">hasNext</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> currentPosition &lt; itemsArray.Length &amp;&amp; itemsArray[currentPosition] != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">next</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> itemsArray[currentPosition++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试代码及结果"><a class="header-anchor" href="#测试代码及结果">#</a>测试代码及结果</h2>
<figure class="highlight cs"><figcaption><span>测试代码</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    DinerMenu dinerMenu = <span class="keyword">new</span> DinerMenu();</span><br><span class="line">    PancakeHouseMenu pancakeHouseMenu = <span class="keyword">new</span> PancakeHouseMenu();</span><br><span class="line"></span><br><span class="line">    PrintMenu(dinerMenu.createIterator());</span><br><span class="line">    Console.WriteLine();</span><br><span class="line">    PrintMenu(pancakeHouseMenu.createIterator());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintMenu</span>(<span class="params">Iterator iterator</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())</span><br><span class="line">    &#123;</span><br><span class="line">        ((MenuItem)iterator.next()).Debug();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/ch_09_the_iterator_and_composite_pattern/2019-02-03-23-36-01.png" alt="迭代器模式运行结果"></p>
<h1 id="组合模式"><a class="header-anchor" href="#组合模式">#</a>组合模式</h1>
<p>组合模式（Composite Pattern）是用树形结构来组合对象进而体现一种局部-整体的层次结构。组合模式可以让调用者以统一的方式对待单个物体和多个物体的组合。</p>
<p>例如我们需要打印一个菜单上的所有菜品，但菜单中可能还包含子菜单，子菜单中又可能包含子菜单等等，但对于外部调用者而言则不希望关注这些细节。我们可以通过定义一个基类，无论是菜品还是菜单都继承自这个基类，这样对于菜单而言，无论是子菜单还是菜品都是同一个基类，可一起管理。对于外部调者而言只 x 需要关心这个基类即可。</p>
<h2 id="代码示例-2"><a class="header-anchor" href="#代码示例-2">#</a>代码示例</h2>
<h3 id="共同抽象类基类"><a class="header-anchor" href="#共同抽象类基类">#</a>共同抽象类基类</h3>
<figure class="highlight cs"><figcaption><span>菜单元素</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">MenuComponent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params">MenuComponent menuComponent</span>)</span> &#123; <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Remove</span>(<span class="params">MenuComponent menuComponent</span>)</span> &#123; <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> MenuComponent <span class="title">GetChild</span>(<span class="params"><span class="built_in">int</span> i</span>)</span> &#123; <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">protected</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">string</span> Description &#123; <span class="keyword">get</span>; <span class="keyword">protected</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">float</span> Price &#123; <span class="keyword">get</span>; <span class="keyword">protected</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">bool</span> Vegetarian &#123; <span class="keyword">get</span>; <span class="keyword">protected</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Debug</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(Name + <span class="string">&quot; , &quot;</span> + Description + <span class="string">&quot; , &quot;</span> + Vegetarian + <span class="string">&quot; , &quot;</span> + Price);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="菜单及菜品实现"><a class="header-anchor" href="#菜单及菜品实现">#</a>菜单及菜品实现</h3>
<figure class="highlight cs"><figcaption><span>菜单</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Menu</span> : <span class="title">MenuComponent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;MenuComponent&gt; menuComponetsList = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Menu</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">string</span> description</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        menuComponetsList = <span class="keyword">new</span> List&lt;MenuComponent&gt;();</span><br><span class="line">        Name = name;</span><br><span class="line">        Description = description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params">MenuComponent menuComponent</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        menuComponetsList.Add(menuComponent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Remove</span>(<span class="params">MenuComponent menuComponent</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        menuComponent.Remove(menuComponent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> MenuComponent <span class="title">GetChild</span>(<span class="params"><span class="built_in">int</span> i</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> menuComponetsList[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Debug</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(Name + <span class="string">&quot; , &quot;</span> + Description);</span><br><span class="line">        menuComponetsList.ForEach(menuComponent =&gt; menuComponent.Debug());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>菜品</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MenuItem</span> : <span class="title">MenuComponent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MenuItem</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">string</span> description, <span class="built_in">bool</span> vegetarian, <span class="built_in">float</span> price</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Name = name;</span><br><span class="line">        Description = description;</span><br><span class="line">        Vegetarian = vegetarian;</span><br><span class="line">        Price = price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试代码及结果-2"><a class="header-anchor" href="#测试代码及结果-2">#</a>测试代码及结果</h2>
<figure class="highlight cs"><figcaption><span>测试代码</span></figcaption><table><tr><td class="code"><pre><span class="line">Menu menu = <span class="keyword">new</span> Menu(<span class="string">&quot;General Menu&quot;</span>, <span class="string">&quot;Holds all menus and menu items&quot;</span>);</span><br><span class="line">Menu dinnerMenu = <span class="keyword">new</span> Menu(<span class="string">&quot;Dinner Menu&quot;</span>, <span class="string">&quot;Holds dinner menu items&quot;</span>);</span><br><span class="line">Menu breakfastMenu = <span class="keyword">new</span> Menu(<span class="string">&quot;Breakfast Menu&quot;</span>, <span class="string">&quot;Holds Breakfast menu items&quot;</span>);</span><br><span class="line">menu.Add(dinnerMenu);</span><br><span class="line">menu.Add(breakfastMenu);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">breakfastMenu.Add(<span class="keyword">new</span> MenuItem(<span class="string">&quot;K&amp;B&#x27;s Pancake Breakfast&quot;</span>, <span class="string">&quot;Pancake with eggs and toast&quot;</span>, <span class="literal">true</span>, <span class="number">2.99f</span>));</span><br><span class="line">breakfastMenu.Add(<span class="keyword">new</span> MenuItem(<span class="string">&quot;Regular&#x27;s Pancake Breakfast&quot;</span>, <span class="string">&quot;Pancake with eggs and sausags&quot;</span>, <span class="literal">true</span>, <span class="number">2.99f</span>));</span><br><span class="line">breakfastMenu.Add(<span class="keyword">new</span> MenuItem(<span class="string">&quot;Blueberry&#x27;s Pancake Breakfast&quot;</span>, <span class="string">&quot;Pancake with eggs and fresh blueberries&quot;</span>, <span class="literal">true</span>, <span class="number">2.99f</span>));</span><br><span class="line"></span><br><span class="line">dinnerMenu.Add(<span class="keyword">new</span> MenuItem(<span class="string">&quot;Vegetarian BLT&quot;</span>, <span class="string">&quot;Fakin Bacon with tomato&quot;</span>, <span class="literal">true</span>, <span class="number">2.99f</span>));</span><br><span class="line">dinnerMenu.Add(<span class="keyword">new</span> MenuItem(<span class="string">&quot;BLT&quot;</span>, <span class="string">&quot;Bacon with tomato&quot;</span>, <span class="literal">true</span>, <span class="number">3.99f</span>));</span><br><span class="line">dinnerMenu.Add(<span class="keyword">new</span> MenuItem(<span class="string">&quot;Soup of the day&quot;</span>, <span class="string">&quot;Soup of the day and salad&quot;</span>, <span class="literal">false</span>, <span class="number">3.29f</span>));</span><br><span class="line"></span><br><span class="line">menu.Debug();</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/ch_09_the_iterator_and_composite_pattern/2019-02-06-16-23-58.png" alt="组合模式运行结果"></p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>《Head First 设计模式》 Ch 10 状态模式</title>
    <url>/ch_10_the_state_pattern/</url>
    <content><![CDATA[<p>状态模式(State Pattern)允许一个对象根据其内部状态的变化来选择需要执行的操作。这个对象会看起来像是改变了它的类。</p>
<p>状态模式定义听起来有些奇怪，实际上就是将不同状态的行为定义在不同的状态类中，然后根据状态的不同切换这些状态类，进而达到不同的行为。</p>
<p>例如我们需要做一个口香糖贩卖机需要处理，投钱、退钱、旋转出货按钮这三个操作，然后机器有未投钱、投钱、货物卖出、货物卖完四个状态。我们可以将不同状态下对三个操作的处理定义在各自的状态类中。</p>
<h1 id="代码示例"><a class="header-anchor" href="#代码示例">#</a>代码示例</h1>
<h2 id="状态类接口"><a class="header-anchor" href="#状态类接口">#</a>状态类接口</h2>
<figure class="highlight cs"><figcaption><span>状态类接口</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">State</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InsertQuarter</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">EjectQuarter</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TurnCrank</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Dispense</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="状态类实现"><a class="header-anchor" href="#状态类实现">#</a>状态类实现</h2>
<figure class="highlight cs"><figcaption><span>未投钱状态</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NoQuarterState</span> : <span class="title">State</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> GumballMachine gumballMachine = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NoQuarterState</span>(<span class="params">GumballMachine gumballMachine</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.gumballMachine = gumballMachine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispense</span>()</span> &#123; Console.WriteLine(<span class="string">&quot;You need to pay first&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">EjectQuarter</span>()</span> &#123; Console.WriteLine(<span class="string">&quot;You haven&#x27;t inserted a quarter&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InsertQuarter</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        gumballMachine.SetState(gumballMachine.HasQuarterState);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;You inserted a quarter&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TurnCrank</span>()</span> &#123; Console.WriteLine(<span class="string">&quot;You turned,but there&#x27;s no quarter&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>投钱状态</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HasQuarterState</span> : <span class="title">State</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> GumballMachine gumballMachine = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HasQuarterState</span>(<span class="params">GumballMachine gumballMachine</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.gumballMachine = gumballMachine;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispense</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;No gumball dispensed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">EjectQuarter</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Quarter returned&quot;</span>);</span><br><span class="line">        gumballMachine.SetState(gumballMachine.NoQuarterState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InsertQuarter</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;You can&#x27;t insert another quater&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TurnCrank</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;You turned&quot;</span>);</span><br><span class="line">        gumballMachine.SetState(gumballMachine.SoldState);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>货物卖出状态</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SoldState</span> : <span class="title">State</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> GumballMachine gumballMachine = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SoldState</span>(<span class="params">GumballMachine gumballMachine</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.gumballMachine = gumballMachine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispense</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        gumballMachine.ReleaseBall();</span><br><span class="line">        <span class="keyword">if</span> (gumballMachine.remainGumballsNum &gt; <span class="number">0</span>)</span><br><span class="line">            gumballMachine.SetState(gumballMachine.NoQuarterState);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Opps,out of gumballs&quot;</span>);</span><br><span class="line">            gumballMachine.SetState(gumballMachine.SoldOutState);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">EjectQuarter</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Sorry,you already turned the crank&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InsertQuarter</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Please wait,we are already giving you a gumball&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TurnCrank</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Turning twice dones&#x27;t get you another gumball&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>货物售完状态</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SoldOutState</span> : <span class="title">State</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> GumballMachine gumballMachine = <span class="literal">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SoldOutState</span>(<span class="params">GumballMachine gumballMachine</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.gumballMachine = gumballMachine;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispense</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;No gumball dispensed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">EjectQuarter</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;You can&#x27;t eject,you haven&#x27;t inserted a quarter yet&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InsertQuarter</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;You can&#x27;t insert a quarter,the machine is sold out&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TurnCrank</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;You turned,but there are no gumballs&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="测试代码及结果"><a class="header-anchor" href="#测试代码及结果">#</a>测试代码及结果</h1>
<figure class="highlight cs"><figcaption><span>测试代码</span></figcaption><table><tr><td class="code"><pre><span class="line">GumballMachine gumballMachine = <span class="keyword">new</span> GumballMachine(<span class="number">5</span>);</span><br><span class="line">gumballMachine.TurnCrank();</span><br><span class="line">gumballMachine.InsertQuarter();</span><br><span class="line">gumballMachine.EjectQuarter();</span><br><span class="line">gumballMachine.TurnCrank();</span><br><span class="line">gumballMachine.InsertQuarter();</span><br><span class="line">gumballMachine.TurnCrank();</span><br><span class="line">gumballMachine.TurnCrank();</span><br><span class="line">gumballMachine.EjectQuarter();</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/ch_10_the_state_pattern/2019-02-06-20-10-15.png" alt="状态模式运行结果"></p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>《Computer Networks and Internets》 Ch 10 调制与调制器</title>
    <url>/ch_10_modulation_and_modems/</url>
    <content><![CDATA[<h1 id="Introduction"><a class="header-anchor" href="#Introduction">#</a>Introduction</h1>
<p>这一章讨论数据通信中的调制与调制器相关的内容。</p>
<p>调制是利用高频的信息来携带原始数据，将分别讨论当原始数据是模拟信号和数字信号的情况。</p>
<h1 id="Carriers_Frequency_And_Propagation"><a class="header-anchor" href="#Carriers_Frequency_And_Propagation">#</a>Carriers,Frequency,And Propagation</h1>
<p>许多通信系统会利用一个持续震荡的电磁波来作为信息的载波（Carrier），通常这个信号都是一个高频信号。在第七章有提到，信号的频率会影响信号的传播特性，如穿透性，对噪声的敏感性等。</p>
<h1 id="Analog_Modulation_Schemes"><a class="header-anchor" href="#Analog_Modulation_Schemes">#</a>Analog Modulation Schemes</h1>
<p><code>调制（Modulation）</code>意为根据原始信号来改变载波的特性。调制有两个输入，一个是载波，一个是原信号，然后产生一个调制后的载波作为输出。调制的原理图如下：</p>
<p><img src="/ch_10_modulation_and_modems/2019-12-07-23-21-31.png" alt="调制原理图"></p>
<p>输入的原信号必须改变载波的一个特性，根据特性的不同可以分为<code>振幅调制（Amplitude modulation）</code>，<code>频移调制（Frequency modulation）</code>，<code>移相调制（Phase shift modulation）</code>。其中前两种最为普遍。</p>
<h1 id="Amplitude_Modulation"><a class="header-anchor" href="#Amplitude_Modulation">#</a>Amplitude Modulation</h1>
<p><code>振幅调制（Amplitude modulation）</code>是根据原信号改变载波的振幅。从时域图上看，调制后的波形的轮廓与原信号基本相同，如下图所示，（a）是高频载波，（b）是原信号，（c）是调制后的信号。</p>
<p><img src="/ch_10_modulation_and_modems/2019-12-07-23-28-45.png" alt="振幅调制"></p>
<h1 id="Frequency_Modulation"><a class="header-anchor" href="#Frequency_Modulation">#</a>Frequency Modulation</h1>
<p><code>频移调制（Frequency modulation）</code>是根据原信号改变载波的频率，当信号强是，载波的频率增加，反之减少。如下图即为频移调制后的样子：</p>
<p><img src="/ch_10_modulation_and_modems/2019-12-07-23-36-37.png" alt="频移调制"></p>
<h1 id="Phase_Shift_Modulation"><a class="header-anchor" href="#Phase_Shift_Modulation">#</a>Phase Shift Modulation</h1>
<p><code>移相调制（Phase shift modulation）</code>是根据原信号改变载波的相位。经过理论上可行，但对于模拟信号来说，很少用移相调制，因为模拟信号采样点的数据可能比较接近，导致移相的大小不明显，很容易被误认为是频率的改变。但对于数字信号来说移相调制因为可以一个码元传递多个 Bit 的字节，所以经常被使用。</p>
<h1 id="Amplitude_Modulation_And_Shannon’s_Theorem"><a class="header-anchor" href="#Amplitude_Modulation_And_Shannon’s_Theorem">#</a>Amplitude Modulation And Shannon’s Theorem</h1>
<p>在之前解释振幅调制的示意图中，调制后信号变化幅度较大，最低处的强度接近于 0。但实际运用时，基本上振幅调制的幅度变化很小。因为考虑到有噪声的存在，如果信号的变化幅度较大，在信号最弱时的信噪比会很低，则几乎无法传递有效信息。</p>
<h1 id="Modulation_Digital_Input_And_Shift_Keying"><a class="header-anchor" href="#Modulation_Digital_Input_And_Shift_Keying">#</a>Modulation,Digital Input,And Shift Keying</h1>
<p>为了区分模拟信号和数字信号的调制，使用属于<code>移位键控（Shift Keying）</code>来表示数字信号的调制。数字信号的调制与模拟信号调制基本原理类似，只不过作为原信号的模拟信号是连续的数值变化，而数字信号是离散的几个特定的数值。振幅与频率移位键控如下图，(a)是载波，(b)是原信号，©是振幅移位键控，(d)是频率移位键控</p>
<p><img src="/ch_10_modulation_and_modems/2019-12-08-00-05-53.png" alt="振幅，频率移位键控"></p>
<h1 id="Phase_Shift_Keying"><a class="header-anchor" href="#Phase_Shift_Keying">#</a>Phase Shift Keying</h1>
<p><code>相位移位键控(Phase Shift Keying)</code>是根据原信号突然的改变载波的相位，如下图所示，即为相位移位键控的示意图。</p>
<p><img src="/ch_10_modulation_and_modems/2019-12-08-00-11-28.png" alt="相位移位键控"></p>
<h1 id="Phase_Shift_And_A_Constellation_Diagram"><a class="header-anchor" href="#Phase_Shift_And_A_Constellation_Diagram">#</a>Phase Shift And A Constellation Diagram</h1>
<p>如之前所示，相位移位键控最大的优势在于可以用一个码元传递多个 bit。可通过<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>个相位来使一个码元可携带<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> bit 数据。使用星座图来表示相位变化大小与该大小与对应数据的关系。星座图如下图所示，图（1）是只有两个相位变化，即表示 0 和 1，图（2）是有四个相位变化，可代表两个 bit,即 00,01,10,11。</p>
<p><img src="/ch_10_modulation_and_modems/2019-12-08-00-18-17.png" alt="两个相位的相位移位键控"></p>
<p><img src="/ch_10_modulation_and_modems/2019-12-08-00-18-54.png" alt="四个相位的相位移位键控"></p>
<h1 id="Quadrature_Amplitude_Modulation"><a class="header-anchor" href="#Quadrature_Amplitude_Modulation">#</a>Quadrature Amplitude Modulation</h1>
<p>如上节所述，可以在使用相位移位键控时采用多个相位间隔使一个码元传递多个 bit。但某些情况下，硬件无法检测过于精细的相位变化。这时候可以通过降相位移位键控和振幅移位键控结合在一起使一个码元可携带更多的数据，这方法称为<code>正交振幅调制（Quadrature Amplitude Modulation）</code>。如下图所示：</p>
<p><img src="/ch_10_modulation_and_modems/2019-12-08-10-04-32.png" alt="正交振幅调制"></p>
<p>如上图，一共有四个相位区分，每个点距离原点的距离代表振幅，一共有四个电压，因此一共有 16 种组合，一个码元可以携带 4 个 bit。</p>
<h1 id="Modem_Hardware_For_Modulation_And_Demodulation"><a class="header-anchor" href="#Modem_Hardware_For_Modulation_And_Demodulation">#</a>Modem Hardware For Modulation And Demodulation</h1>
<p>将一系列的数据 bit 作为输入，然后根据这些原数据对载波进行调制的设备称为<code>调制器（Modulator）</code>，反之根据调制后的载波重新解析出原信号的机器称为<code>解调器（Demodulator）</code>。在实际中，大部分的通信设备同时包含调制器和解调器，这种设备被称为<code>调制解调器（Modem）</code>。下图是两个计算机的通信简图，在两者将数据传给中间的电缆媒介前，都经过了调制解调器</p>
<p><img src="/ch_10_modulation_and_modems/2019-12-08-10-13-14.png" alt="调制解调器"></p>
<h1 id="Optical_And_Radio_Frequency_Modems"><a class="header-anchor" href="#Optical_And_Radio_Frequency_Modems">#</a>Optical And Radio Frequency Modems</h1>
<p>调制解调器不仅可用于电缆的传输，对于无线电波和光纤也同样适用，原理也一样，在发送端调制解调器对载波进行调制，在接收端，数据从被调制后的载波中会提取。</p>
<h1 id="Dialup_Modems"><a class="header-anchor" href="#Dialup_Modems">#</a>Dialup Modems</h1>
<p>在语音电话系统中，使用的调制解调器称为<code>拨号调制解调器（Dialup Modems）</code>，其与普通的调制解调器最大的区别在于，前者用的是语音信号，后者用的是电信号，而且拨号调制解调器占用的带宽更小。</p>
<p>因为电话系统接受的是模拟信号，所以拨号调制解调器也是一个对模拟信号进行调制的设备。但讽刺的是现代电话系统的中间传输部分是数字信号，于是发送端在调制后，需要将模拟信号转换为数字信号。而在接收端，在进行解调前也需要先将中间传输来的数字信号转换为模拟信号。</p>
<h1 id="QAM_Applied_To_Dialup"><a class="header-anchor" href="#QAM_Applied_To_Dialup">#</a>QAM Applied To Dialup</h1>
<p>正交振幅调制也同样可用于拨号调制解调器中。因为大部分语音频率本身是从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>300</mn><mi>H</mi><mi>Z</mi><mo>∼</mo><mn>3300</mn><mi>H</mi><mi>Z</mi></mrow><annotation encoding="application/x-tex">300HZ\sim 3300HZ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">300</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">3300</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span></span></span></span>，但拨号调制解调器只能提供<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>600</mn><mi>H</mi><mi>Z</mi><mo>∼</mo><mn>3000</mn><mi>H</mi><mi>Z</mi></mrow><annotation encoding="application/x-tex">600HZ\sim 3000HZ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">600</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">3000</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span></span></span></span>，所以同样需要正交振幅调制来使一个码元能携带更多的数据。</p>
<h1 id="V_32_And_V_32bis_Dialup_Modems"><a class="header-anchor" href="#V_32_And_V_32bis_Dialup_Modems">#</a>V.32 And V.32bis Dialup Modems</h1>
<p>V.32 和 V.32bis 是两个拨号调制解调器用正交振幅调制的标准。</p>
<p>V.32 使用 32 个振幅和相位的组合来表示数据，可以达到单向每秒 9600 个 bit 的数据速率。</p>
<p><img src="/ch_10_modulation_and_modems/2019-12-08-10-28-37.png" alt="V.32"></p>
<p>V.32bis 使用 128 个振幅和相位的组合来表数据，可以达到单向每秒 14400 个 bit 的数据速率。</p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《Computer Networks and Internets》 Ch 11 复用与解复用</title>
    <url>/ch_11_multiplexing_and_demultiplexing/</url>
    <content><![CDATA[<h1 id="Introduction"><a class="header-anchor" href="#Introduction">#</a>Introduction</h1>
<p>这一部分将介绍将多个心愿的数据流合并在一起的复用，和将合并后数据流拆分的解复用。</p>
<h1 id="The_Concept_Of_Multiplexing"><a class="header-anchor" href="#The_Concept_Of_Multiplexing">#</a>The Concept Of Multiplexing</h1>
<p><code>复用(Multiplexing)</code>是将多个信源的数据流合并在一起，并通过一个共享的媒介进行传输。<code>复用器（Multiplexor）</code>是用来进行复用的设备。<code>解复用（Demultiplexing）</code>是将合并后的数据流拆分还原成一个个信源的信息，<code>解复用器（Demultiplexor）</code>是用来进行解复用的设备。下图是复用与解复用的使用简图：</p>
<p><img src="/ch_11_multiplexing_and_demultiplexing/2019-12-08-10-56-05.png" alt="复用与解复用"></p>
<p>复用与解复用在日常的计算机网络使用中一直在进行，如多台电脑使用同一根网线等。</p>
<h1 id="The_Basic_Types_Of_Multiplexing"><a class="header-anchor" href="#The_Basic_Types_Of_Multiplexing">#</a>The Basic Types Of Multiplexing</h1>
<p>在物理层，有四大类的复用方式：</p>
<ol>
<li>频分复用（Frequency Division Multiplexing）</li>
<li>波分复用（Wavelength Division Multiplexing）</li>
<li>时分复用（Time Division Multiplexing）</li>
<li>码分复用（Code Division Multiplexing）</li>
</ol>
<p>频分复用和波分复用使用比较广泛。波分复用可以看作是频分复用的一种特殊形式（波长与波的频率是相关的），波分复用用于光纤中。码分复用是没有使用物理特性，而是用数学原理，在一些电话系统中有运用。</p>
<h1 id="Frequency_Division_Multiplexing（FDM）"><a class="header-anchor" href="#Frequency_Division_Multiplexing（FDM）">#</a>Frequency Division Multiplexing（FDM）</h1>
<p><code>频分复用（Frequency Division Multiplexing）</code>是无线电广播的基础。在频分复用下，一个有大频率带宽的信道将拆分成许多小部分，每个信源都有一个自己单独的信道（占据一定频率的范围，相当于每个信源的载波频率都不同），每个信道间不会相互干扰，所有的信源都将使用一个共同的媒介进行传输。在频分复用下，每个信道都可以选择各自的方式进行调制。</p>
<p>频分复用最大的优点在于多个发送端和接收端都可以同时使用传输媒介。</p>
<p>为了避免在频分复用下，每个信源都有自己的信道，如果这些信道间的频率太过于接近则会产生干扰。为了避免干扰的的产生，信道之间需要由间隔（Gap），称为<code>防护频带（Guard band）</code>。</p>
<p>下图是频分复用的示意图，每个小块代表一个可供信源使用的单独信道，可以看到每个信道间都有一个小间隔作为防护频带。</p>
<p><img src="/ch_11_multiplexing_and_demultiplexing/2019-12-08-11-15-01.png" alt="频分复用"></p>
<h1 id="Using_A_Range_Of_Frequency_Per_Channel"><a class="header-anchor" href="#Using_A_Range_Of_Frequency_Per_Channel">#</a>Using A Range Of Frequency Per Channel</h1>
<p>在上节的例子中，每个信道都有一个频率范围，但载波是固定频率的，信道之所欲选择一个频率范围而非单一的频率，主要是考虑便捷性，因为划分出的信道可能会以各种方式被使用。大多数频分复用系统都给发送端和接收端一个频率范围，系统可以选择最适用的频率作为载波，选择的评判标准通常是数据速率和对噪音的敏感性。</p>
<p>因为频分复用通常的频率较高，对噪声敏感，因此通常使用同轴电缆来作为传输媒介。</p>
<p>有的时候为了进一步增加数据速率，被分配给一个信源的信道会被再次的分割成更小的信道，如一个信源将分配给它的信道再分割成<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span>个小信道，则每个小信道只要传输<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">1/k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1/</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>的数据即可，这技术称为<code>子信道（Subchannel）</code>。</p>
<p>有的时候为了进一步增加对噪声的抵抗性，会使用称为<code>展频(Spread Spectrum)</code>的技术。这个方法同样将信源的信道再切割成<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>个小信道，但每个信道都传输一样的数据，接收端收到信息后，从这<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>个小信道中找寻错误最少的数据作为接收数据。</p>
<h1 id="Hierarchical_FDM"><a class="header-anchor" href="#Hierarchical_FDM">#</a>Hierarchical FDM</h1>
<p><code>分层频分复用（Hierarchical FDM）</code>是将频分复用后的总数据再作为一个频率更高的频分复用的输入进行再次复用。如下图所示：</p>
<p><img src="/ch_11_multiplexing_and_demultiplexing/2019-12-08-12-06-55.png" alt="分层频分复用"></p>
<p>虽然上图中每一级的单一信道带宽是上一级所有信道带宽的总和。但在实际运用中，下一级的单一信道带宽是要略大于上一级所有信道带宽的总和的，因为还需要携带额外的同步帧。</p>
<h1 id="Wavelength_Division_Multiplexing（WDM）"><a class="header-anchor" href="#Wavelength_Division_Multiplexing（WDM）">#</a>Wavelength Division Multiplexing（WDM）</h1>
<p><code>波分复用（Wavelength Division Multiplexing，WDM）</code>是在使用光纤作为媒介时的频分复用。当波分复用使用了许多不同频率的光时，可称为<code>密集波分复用（Dense Wavelength Division Multiplexing）</code>。</p>
<p>波分复用的原理可以参考物理上的三棱镜实验，即白光可以拆分为不同颜色的光，而光的颜色是由光的频率决定的。棱柱为波分复用与解复用提供了基础。波分复用的复用器是接受一系列不同波长的光，然后通过一个棱柱将它们合并成一束光，然后接收端的解复用器再次通过棱镜将它们还原成不同波长的光。示意图如下：</p>
<p><img src="/ch_11_multiplexing_and_demultiplexing/2019-12-08-12-15-12.png" alt="波分复用"></p>
<h1 id="Time_Division_Multiplexing（TDM）"><a class="header-anchor" href="#Time_Division_Multiplexing（TDM）">#</a>Time Division Multiplexing（TDM）</h1>
<p><code>时分复用（Time Division Multiplexing，TDM）</code>的原理很简单，即每个信源使用共同的媒介一段时间，然后供下一个信源使用。示意图如下：</p>
<p><img src="/ch_11_multiplexing_and_demultiplexing/2019-12-08-12-18-29.png" alt="时分复用"></p>
<h1 id="Synchronous_TDM"><a class="header-anchor" href="#Synchronous_TDM">#</a>Synchronous TDM</h1>
<p>时分复用在计算机网络中是一个比较宽泛的概念。因此在实际运用中，上节中的概念图会在细节上有变化。例如有些时分复用系统并不是所有信源按顺序一个个发送。有些时分复用的系统中，每个信源发送间也并不像上图一样有时间间隔，一个信源发送后另一个信源会马上发送，这种系统称为<code>同步时间复用系统（Synchronous TDM）</code>。如下图所示：</p>
<p><img src="/ch_11_multiplexing_and_demultiplexing/2019-12-08-14-34-28.png" alt="同步TDM"></p>
<h1 id="Framing_Used_In_The_Telephone_System_Version_Of_TDM"><a class="header-anchor" href="#Framing_Used_In_The_Telephone_System_Version_Of_TDM">#</a>Framing Used In The Telephone System Version Of TDM</h1>
<p>如之前所述，电话系统的两端是模拟信号，中间传输的是数字信号。对于中间使用同一个媒介传输的数字信号是通过同步时间复用系统来进行复用的。在电话系统中在时间复用系统中用了一个特殊技术来保证接收端和发送端的时间是对齐的，因为一旦接收端的时间出现了偏差，则可能将错误的信号传递给错误的目的地。为了解决这个问题，电话系统中的时间复用系统需要额外传输一个<code>信道帧（Framing Channel）</code>来表示一轮传输的开始，如下图所示：</p>
<p><img src="/ch_11_multiplexing_and_demultiplexing/2019-12-08-14-42-09.png" alt="信道帧"></p>
<h1 id="Hierarchical_TDM"><a class="header-anchor" href="#Hierarchical_TDM">#</a>Hierarchical TDM</h1>
<p>如同频分复用，时间复用也可以是分层的。不同的是，在频分复用系统中，每一级增加的是频率，在时分复用系统中每一级增加的是数据速率（减少时间切分间隔）。另外每一级的数据速率略大于前一级所有数据速率的总和，这是因为要传输额外帧数据。分层时间复用如下图：</p>
<p><img src="/ch_11_multiplexing_and_demultiplexing/2019-12-08-14-46-19.png" alt=""></p>
<h1 id="The_Problem_With_Synchronous_TDM_Unfilled_Slots"><a class="header-anchor" href="#The_Problem_With_Synchronous_TDM_Unfilled_Slots">#</a>The Problem With Synchronous TDM: Unfilled Slots</h1>
<p>同步时间复用对与每个信源都平均的提供时间，即将整个信道的容量（容量可看作一秒能传输的数据量）平分。但如果一个信源在某一段是空白数据，那么当轮到这个信源发送数据时，只能往信道内填空白数据（通常填0），且额外增加一位表示该数据是无效的，而不是正好全是0。这样会造成信道容量的浪费。如下图所示：</p>
<p><img src="/ch_11_multiplexing_and_demultiplexing/2019-12-08-14-50-26.png" alt="未填充数据时间复用"></p>
<h1 id="Statistical_TDM"><a class="header-anchor" href="#Statistical_TDM">#</a>Statistical TDM</h1>
<p>为了解决同步TDM这个问题，有个称为<code>统计时间复用（Statistical TDM）</code>，或称为异步时间复用（Asynchronous）的技术。这个技术仍然是所有信源轮询的传输数据，但是当信源没有数据时，并非像同步时间同步那样装填空白数据，而是直接跳过。如下图所示：</p>
<p><img src="/ch_11_multiplexing_and_demultiplexing/2019-12-08-14-54-27.png" alt="统计时间复用"></p>
<p>尽管这个方法解决了空白数据造成的信道容量浪费，但需要引入额外的数据来表明每个数据块是哪个信源的。</p>
<h1 id="Inverse_Multiplexing"><a class="header-anchor" href="#Inverse_Multiplexing">#</a>Inverse Multiplexing</h1>
<p><code>逆复用（Inverse Multiplexing）</code>技术是用类似于复用的思维方式，但解决是只有两个信源，但其中有多个传输媒介，且两信源有大量的数据需要传输，但中间媒介没有一个有足够的足够的比特率。逆复用技术就是将原数据拆分成多份，然后通过中间的低容量媒介进行传输，最后在接收端再将数据合并在一起。示意图如下图所示：</p>
<p><img src="/ch_11_multiplexing_and_demultiplexing/2019-12-08-15-04-52.png" alt="逆复用"></p>
<p>虽然逆复用看着很像复用的反向使用，即将复用的输出端变成输入，输入端变成输出，但在实际使用时，不能简单的将复用器反向设计得到逆复用器。逆复用器在发射端必须考虑如何将数据拆分后分配给多个低速率媒介。在接收端也必须考虑多个媒介的传输速率不同，可能造成某些媒介中的数据到达特别缓慢，这时候该如何处理。</p>
<h1 id="Code_Division_Multiplexing"><a class="header-anchor" href="#Code_Division_Multiplexing">#</a>Code Division Multiplexing</h1>
<p><code>码分复用（Code Division Multiplexing）</code>是在蜂窝电话（Cellular telephone）和卫星通信中使用的复用方法。与频分复用和时分复用不同的是，码分复用并不依赖与物理特性，而是利用数学特性：两个正交的线段可以被结合在一起而不会互相干扰。</p>
<p>每个信源都有一个不同的二进制码<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">C_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，每个信源的二进制码都必须与其他信源的二进制码正交。即将这些二进制码看作是线段（1保持1，0看成-1），这些线段间必须两两垂直。每个信源都将原数据与二进制码叉乘，然后传输结果，复用的过程即是将所有的结果都累加在一起，在接收端每个信源的目的地再相应的将接受到的复用数据再次与对应信源的二进制码点乘，结果即为该信源应该收到的数据。</p>
<p>下面以一个例子方便理解。</p>
<p>假设有两个信源，两个信源的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">C_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>分别是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo><mtext>和</mtext><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1,0)和(1,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mord cjk_fallback">和</span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，需要传输的数据分别是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1,0,1,0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0,1,1,0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span>。传输过程如下：</p>
<p>将原数据和二进制码改为向量，即1为1，0变-1。<br>
信源1：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mn>1</mn></msub><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">C_1=(1,-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mn>1</mn></msub><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">V_1=(1,-1,1,-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mclose">)</span></span></span></span><br>
信源2：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mn>2</mn></msub><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">C_2=(1,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mn>2</mn></msub><mo>=</mo><mo stretchy="false">(</mo><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">V_2=(-1,1,1,-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
<p>可以看到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">C_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">C_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是正交的。</p>
<p>复用过程即为:</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>C</mi><mn>1</mn></msub><mo>×</mo><msub><mi>V</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><msub><mi>C</mi><mn>2</mn></msub><mo>×</mo><msub><mi>V</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mspace linebreak="newline"></mspace><mspace linebreak="newline"></mspace><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace><mspace linebreak="newline"></mspace><mo>=</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>2</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mn>2</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mo>−</mo><mn>2</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(C_1 \times V_1) + (C_2\times V_2)= \\\\
((1,-1),(-1,1),(1,-1),(-1,1))+((-1,-1),(1,1),(1,1),(-1,-1))\\\\
=((0,-2),(0,2),(2,0),(-2,0))
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span></span><span class="mspace newline"></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">((</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">((</span><span class="mord">−</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mclose">))</span></span><span class="mspace newline"></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">((</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">−</span><span class="mord">2</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose">))</span></span></span></span></span></p>
<p>((0,-2),(0,2),(2,0),(-2,0))即为复用后的结果。</p>
<p>对于信源1的接收端而言，解复用过程为：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>⋅</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>2</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mn>2</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mo>−</mo><mn>2</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace><mspace linebreak="newline"></mspace><mo>=</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mn>0</mn><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mn>0</mn><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mn>2</mn><mo>+</mo><mn>0</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mo>−</mo><mn>2</mn><mo>+</mo><mn>0</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace><mspace linebreak="newline"></mspace><mo>=</mo><mo stretchy="false">(</mo><mn>2</mn><mo separator="true">,</mo><mo>−</mo><mn>2</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1,-1)\cdot((0,-2),(0,2),(2,0),(-2,0))\\\\
=((0+2),(0-2),(2+0),(-2+0))\\\\
=(2,-2,2,-2)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">((</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">−</span><span class="mord">2</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose">))</span></span><span class="mspace newline"></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">((</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">))</span></span><span class="mspace newline"></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">−</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">−</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span></p>
<p>负数变为0，正数变为1，即接收端1收到数据为(1,-1,1,-1)，与信源1发送数据相同。</p>
<p>对于信源2的接收端来说，解复用过程如下：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo><mo>⋅</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>2</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mn>2</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mo>−</mo><mn>2</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace><mspace linebreak="newline"></mspace><mo>=</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mn>0</mn><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mn>0</mn><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mn>2</mn><mo>+</mo><mn>0</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mo>−</mo><mn>2</mn><mo>+</mo><mn>0</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace><mspace linebreak="newline"></mspace><mo>=</mo><mo stretchy="false">(</mo><mo>−</mo><mn>2</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1,1)\cdot((0,-2),(0,2),(2,0),(-2,0))\\\\
=((0-2),(0+2),(2+0),(-2+0))\\\\
=(-2,2,2,-2)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">((</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">−</span><span class="mord">2</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose">))</span></span><span class="mspace newline"></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">((</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">))</span></span><span class="mspace newline"></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">−</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span></p>
<p>负数变为0，正数变为1，即接收端2收到数据为(-1,1,1,-1)，与信源2发送数据相同。</p>
<p>上述例子中，每个信源的二进制码<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">c_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>都比较小，但在实际运用中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">c_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>可能会很大，这就导致了计算量的上升。如果数据本身并不多，但是花费了大量时间计算，效率比较低，因此在数据量不高的网络中CDM并不适用，</p>
<p>但是高数据量网络中，码分复用非常常见，因为相对于时间复用，码分复用的延迟较低。因为码分复用可以将多个信源的数据一次性同时发送给发送端，而时分复用则必须等待轮询到自己才能发送一部分。</p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《Head First 设计模式》 Ch 11 代理模式</title>
    <url>/ch_11_the_proxy_pattern/</url>
    <content><![CDATA[<p>代理模式（Proxy Pattern）为对象提供一个代理进而控制对其的访问。</p>
<p>例如我们需要加载一张图片，但加载图片是个访问网络或 IO 的操作，我们不希望这个这个操作阻塞 UI 线程，于是我们可以定义一个代理来进行多线程的加载，并在加载完成后显示图片。</p>
<h1 id="代码示例"><a class="header-anchor" href="#代码示例">#</a>代码示例</h1>
<h2 id="抽象接口"><a class="header-anchor" href="#抽象接口">#</a>抽象接口</h2>
<figure class="highlight cs"><figcaption><span>图片接口</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Icon</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrintIconWidthAndHeight</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="抽象接口实现"><a class="header-anchor" href="#抽象接口实现">#</a>抽象接口实现</h2>
<figure class="highlight cs"><figcaption><span>真实图片类</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ImageIcon</span> : <span class="title">Icon</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> width, height;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImageIcon</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Thread.Sleep(<span class="number">5000</span>);<span class="comment">//Pretend there is some hard work to load the image</span></span><br><span class="line">        width = <span class="number">800</span>;</span><br><span class="line">        height = <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintIconWidthAndHeight</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(DateTime.Now.ToLongTimeString() + <span class="string">&quot;: Width is &quot;</span> + width + <span class="string">&quot;,height is &quot;</span> + height);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>代理图片类</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ImageProxyIcon</span> : <span class="title">Icon</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> ImageIcon icon = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> isLoading = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImageProxyIcon</span>()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintIconWidthAndHeight</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (icon != <span class="literal">null</span>)</span><br><span class="line">            icon.PrintIconWidthAndHeight();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!isLoading)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(DateTime.Now.ToLongTimeString() + <span class="string">&quot;: Is Loading Image...&quot;</span>);</span><br><span class="line">            isLoading = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">new</span> Thread(() =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                icon = <span class="keyword">new</span> ImageIcon();</span><br><span class="line">                icon.PrintIconWidthAndHeight();</span><br><span class="line">            &#125;).Start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="测试代码及结果"><a class="header-anchor" href="#测试代码及结果">#</a>测试代码及结果</h1>
<figure class="highlight cs"><figcaption><span>测试代码</span></figcaption><table><tr><td class="code"><pre><span class="line">ImageProxyIcon proxyIcon = <span class="keyword">new</span> ImageProxyIcon();</span><br><span class="line">proxyIcon.PrintIconWidthAndHeight();</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/ch_11_the_proxy_pattern/2019-02-07-14-10-11.png" alt="代理模式运行结果"></p>
<div class="note info simple"><p>代理模式与装饰模式很像，不同的是装饰模式的目的是在原先的类外扩展某些功能，而代理模式只是控制原先类中某些接口的访问。例如上例子中，<code>ImageProxyIcon</code>并没有为<code>ImageIcon</code>拓展什么功能，只是用了多线程来访问访问其中的函数。</p>
</div>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>《Head First 设计模式》 Ch 12 复合模式</title>
    <url>/ch_12_the_compound_patterns/</url>
    <content><![CDATA[<p>复合模式（Compound Pattern）是通过两个或以上的设计模式形成一个可以解决一般性问题的通用框架。</p>
<p>MVC 框架就是一种组合模式，<code>Controller</code>和<code>View</code>之间使用了策略模式， <code>View</code>中只存<code>Controller</code>的接口，进而达到可以随时切换不同<code>Controller</code>的目的。<code>Model</code>和<code>View</code>之间使用了观察者模式，<code>View</code>作为观察者，<code>Model</code>作为被观察者，当<code>Model</code>的数据发生变化时，<code>View</code>相应改变。而<code>View</code>本身使用了组合模式，比如按钮中可能存在子按钮，窗口中存在子窗口等等。</p>
<p>我们以音量调节作为一个最简的 MVC 框架示例。</p>
<div class="note info simple"><p>关于 MVC 更多的减少，见 MVC</p>
</div>
<h1 id="代码示例"><a class="header-anchor" href="#代码示例">#</a>代码示例</h1>
<h2 id="框架接口"><a class="header-anchor" href="#框架接口">#</a>框架接口</h2>
<figure class="highlight cs"><figcaption><span>观察者接口</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IVolumeObserver</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">VolumeUpdated</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>Model接口</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IVolumeModel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> Volume &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RegisterObserver</span>(<span class="params">IVolumeObserver observer</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">UnRegisterObserver</span>(<span class="params">IVolumeObserver observer</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>Controller接口</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IViewController</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">VolumeUp</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">VolumeDown</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetVolume</span>(<span class="params"><span class="built_in">int</span> volume</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="接口实现"><a class="header-anchor" href="#接口实现">#</a>接口实现</h2>
<figure class="highlight cs"><figcaption><span>Model</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">VolumeModel</span> : <span class="title">IVolumeModel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> volume = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Volume</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> volume; &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            volume = <span class="keyword">value</span>;</span><br><span class="line">            observersList.ForEach(observer =&gt; observer.VolumeUpdated());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> List&lt;IVolumeObserver&gt; observersList = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VolumeModel</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        observersList = <span class="keyword">new</span> List&lt;IVolumeObserver&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RegisterObserver</span>(<span class="params">IVolumeObserver observer</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        observersList.Add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UnRegisterObserver</span>(<span class="params">IVolumeObserver observer</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        observersList.Remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>View</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">VolumeView</span> : <span class="title">IVolumeObserver</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IViewController controller = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> IVolumeModel model = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VolumeView</span>(<span class="params">IViewController controller, IVolumeModel model</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.controller = controller;</span><br><span class="line">        <span class="keyword">this</span>.model = model;</span><br><span class="line">        <span class="keyword">this</span>.model.RegisterObserver(<span class="keyword">this</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;View: volume init is &quot;</span> + model.Volume);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnVolumeUpButtonClick</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        controller.VolumeUp();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnVolumeDownButtonClick</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        controller.VolumeDown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">VolumeUpdated</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;View: volume updated &quot;</span> + model.Volume);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~VolumeView()</span><br><span class="line">    &#123;</span><br><span class="line">        model.UnRegisterObserver(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><figcaption><span>Controller</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">VolumeController</span> : <span class="title">IViewController</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> VolumeModel model = <span class="literal">null</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">VolumeController</span>(<span class="params">VolumeModel model</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.model = model;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetVolume</span>(<span class="params"><span class="built_in">int</span> volume</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            model.Volume = volume;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">VolumeDown</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            --model.Volume;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">VolumeUp</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            ++model.Volume;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="测试代码及结果"><a class="header-anchor" href="#测试代码及结果">#</a>测试代码及结果</h1>
<figure class="highlight cs"><figcaption><span>测试代码</span></figcaption><table><tr><td class="code"><pre><span class="line">VolumeModel model = <span class="keyword">new</span> VolumeModel();</span><br><span class="line">VolumeView view = <span class="keyword">new</span> VolumeView(<span class="keyword">new</span> VolumeController(model), model);</span><br><span class="line">view.OnVolumeUpButtonClick();</span><br><span class="line">view.OnVolumeUpButtonClick();</span><br><span class="line">view.OnVolumeDownButtonClick();</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/ch_12_the_compound_patterns/2019-02-07-15-53-23.png" alt="复合模式运行结果"></p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>《Computer Networks and Internets》 Ch 13 局域网：数据包，帧 和拓扑结构</title>
    <url>/ch_13_local_area_networks_packets,_frames,_and_topologies/</url>
    <content><![CDATA[<h1 id="Introduction"><a class="header-anchor" href="#Introduction">#</a>Introduction</h1>
<p>这一部分将介绍分组交换技术，拓扑结构，硬件地址寻址，帧的概念。</p>
<h1 id="Circuit_Switching_And_Analog_Communication"><a class="header-anchor" href="#Circuit_Switching_And_Analog_Communication">#</a>Circuit Switching And Analog Communication</h1>
<p><code>电路交换（Circuit Switching）</code>概念是指使用时在发送端和接收端之间建立不受干扰的通路的通信方法。电路交换通常与模拟电话技术相关。下图是电路交换的示意图：</p>
<p><img src="/ch_13_local_area_networks_packets,_frames,_and_topologies/2019-12-09-08-28-27.png" alt="电路交换"></p>
<p>电路交换的主要特点是：</p>
<ol>
<li>是点对点的通信</li>
<li>有单独的步骤建立电路连接，使用电路，终止电路连接<br>
例如在电话通信中，实际上有三步。第一步在电话发起人和接受者之间建立电路，第二步双方使用电路进行通信，第三步在通话结束后，终止通路。<br>
这也是称为交换（Switched）电路的原因</li>
<li>与固定的物理通路有相同的性能。</li>
</ol>
<p>电路交换建立的电路最终使用频分复用或者时分复用使用同一个媒介进行传输。电路建立的过程包括在频分复用或时分复用中分配频率或时间段。</p>
<h1 id="Packet_Switching"><a class="header-anchor" href="#Packet_Switching">#</a>Packet Switching</h1>
<p>分组交换（Packet Switching）使用一种统计意义上的复用，即多个信源之间竞争共享媒介的使用。电路交换通常在传统的电话通信中使用，而分组交换构成了因特网的基础。分组交换示意图如下：</p>
<p><img src="/ch_13_local_area_networks_packets,_frames,_and_topologies/2019-12-09-08-37-20.png" alt="分组交换"></p>
<p>注意，在11章中提到的复用技术，如频分复用和时分复用是对于物理存在的信道或者像电路交换这样生成的信道使用的，与分组交换并没有关系。分组交换本身就有统计复用（Statistic Multiplexing）的概念。多个信源在媒介空闲时竞争使用，当媒介为空，且只有一个信源需要传输数据时，该信源就会独占媒介。如果同时有多个信源要传输数据，则基本每个信源占据媒介的时间是平均的，轮流使用。</p>
<p>分组交换的核心是将原数据切分成一个个小块方便传输，这些小块称作包（Packets），包中需要包括传送的目的地信息（在之后节会更详细说明）。分组交换传输的单位不是bit或者byte,而是包。不同的分组交换技术对于包的尺寸有不同的定义。</p>
<p>分组交换的主要特点是：</p>
<ol>
<li>任意大小的异步传输</li>
<li>在通信前没有建立通路的步骤</li>
<li>性能取决于各信源的包的统计复用</li>
</ol>
<p>分组交换的主要优点在于成本的控制。对于电路交换来说，如果有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>个电脑，则需要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">N/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord">/2</span></span></span></span>个独立的路径（虽然在连接时才创建）。但对于分组交换只要一个共享的电路就行。</p>
<h1 id="Local_And_Wide_Area_Packet_Networks"><a class="header-anchor" href="#Local_And_Wide_Area_Packet_Networks">#</a>Local And Wide Area Packet Networks</h1>
<p>分组交换技术通常根据传输距离的距离进行分类。通常分为三类：</p>
<ol>
<li>局域网（Local Area Network,LAN）：最便宜，通常范围在房间级或者一个大楼。</li>
<li>城域网（Metropolitan Area Network,MAN）中等开销，范围涵盖城市或者大都会。</li>
<li>广域网（Wide Area Network,WAN）：最贵。范围通常包含城市与城市之间。</li>
</ol>
<p>在实际使用中，虽然城域网的概念被提出，但在商业上并不成功。基本广泛使用的只有局域网和广域网，城域网的概念在逐步被纳入广域网中。</p>
<p>还有一些机构或者商家定义的类似的分类方式，如：</p>
<ol>
<li><code>个人局域网络（Personal Area Network，PAN）</code>，通常范围在几米内，如蓝牙通信等。</li>
<li><code>芯片局域网络（Chip Area Network）</code>，芯片厂商提出的概念，通常是超大型电路（Very-Large-Scale-Integration,VLSI）中多个核之间的通信。</li>
</ol>
<h1 id="Standards_For_Packet_Format_And_Identification"><a class="header-anchor" href="#Standards_For_Packet_Format_And_Identification">#</a>Standards For Packet Format And Identification</h1>
<p>每个在网络中传输的包都必须包含其目标收信人的标识。需要有规范来制定标识的格式以及添加的位置，在LAN领域最常用的标准是由IEEE（Institute Electrical And Electronics Engineers）创建的。</p>
<p>IEEE是由一群关注于协议栈最下两层（物理层（Physical）和数据链接层（Data Link））的工程师构成的。协议栈的不同层由不同的机构负责，如IEFT关注传输层和因特网协议，WWW组织关注应用层。机构与其关注的协议如下图所示：</p>
<p>在1980年，IEEE组织了<code>802项目局域网/城域网标准委员（Project 802 LAN/MAN Standards Commitee）</code>会为网络设定标准。</p>
<p><img src="/ch_13_local_area_networks_packets,_frames,_and_topologies/2019-12-09-09-12-05.png" alt="组织和协议"></p>
<h1 id="IEEE_802_Model_And_Standards"><a class="header-anchor" href="#IEEE_802_Model_And_Standards">#</a>IEEE 802 Model And Standards</h1>
<p>IEEE将数据链接层又在细分为了两层，<code>逻辑链接控制层（Logical Link Control,LLC）</code>(第15章中描述)和<code>媒介访问控制层（Media Access Control,MAC）</code>。</p>
<p>逻辑链接控制层设备的地址和在解复用中地址的使用。媒介访问控制层关注于多个计算机如何共享底层的媒介。</p>
<p>IEEE对于协议的命名是采用多部分标识符，如<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mi>X</mi><mi>X</mi><mi mathvariant="normal">.</mi><mi>Y</mi><mi>Y</mi><mi>Y</mi><mi mathvariant="normal">.</mi><mi>Z</mi><mi>Z</mi><mi>Z</mi></mrow><annotation encoding="application/x-tex">XXX.YYY.ZZZ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">XXX</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.22222em;">YYY</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.07153em;">ZZZ</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mi>X</mi><mi>X</mi></mrow><annotation encoding="application/x-tex">XXX</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">XXX</span></span></span></span>表示协议的分类，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mi>Y</mi><mi>Y</mi></mrow><annotation encoding="application/x-tex">YYY</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">YYY</span></span></span></span>表示协议的子分类，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Z</mi><mi>Z</mi><mi>Z</mi></mrow><annotation encoding="application/x-tex">ZZZ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">ZZZ</span></span></span></span>是当子分类也非常大是，额外添加的标识。</p>
<p>如局域网的规范在分类802中，这里的802并不是什么缩写或有实际的技术含义，仅仅是一个分类标识。IEEE不同的工作小组针对其细分的协议进行定义，如针对<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>802.1</mn></mrow><annotation encoding="application/x-tex">802.1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">802.1</span></span></span></span>或<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>802.2</mn></mrow><annotation encoding="application/x-tex">802.2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">802.2</span></span></span></span>。</p>
<p>IEEE中有许多不同的工作小组。当有新技术需要协议时，由工业代表和学术协会共同形成工作小组，他们会定期开会商定协议的细节等，当协议的所有细节都确定后，IEEE会发表协议的标准文件。</p>
<p>当协议最终发布后，工作小组可以选择解散或者如果协议非常重要或者仍需要后续工作，小组也可以继续活动。如果小组负责的部分协议不再有意义，如商业上不被接受，或者有更新更好的技术出现，小组也可以选择直接解散而不发表任何的规范。下图是802分类下的协议，有一些规范就已经被放弃（Disbanded）了。</p>
<p><img src="/ch_13_local_area_networks_packets,_frames,_and_topologies/2019-12-09-09-25-59.png" alt="802协议"></p>
<h2 id="LAN_Topologies"><a class="header-anchor" href="#LAN_Topologies">#</a>LAN Topologies</h2>
<p>因为有许多不同的LAN技术，通常使用拓扑型或者网络的基本形状来进行分类。LAN有四个基本的拓扑型，<code>总线型结构（Bus）</code>，<code>环状结构（Ring）</code>，<code>星状结构（Star）</code>，<code>网状结构（Mesh）</code>。</p>
<h2 id="Bus_Topology"><a class="header-anchor" href="#Bus_Topology">#</a>Bus Topology</h2>
<p><code>总线型结构（Bus Topology）</code>是如同以太网一样，用一根电缆连接所有电脑，任何电脑都可以将数据传输到电缆上，然后所有的计算机都可以接受到数据。</p>
<h2 id="Ring_Topology"><a class="header-anchor" href="#Ring_Topology">#</a>Ring Topology</h2>
<p><code>环状结构（Ring Topology）</code>是多个电脑首尾相接的连接，直至成为环形。环形结构的优点是对于相连的两台设备来说连接是安全的，即使别的设备出现问题仍然可以连接。</p>
<h2 id="Mesh_Topology"><a class="header-anchor" href="#Mesh_Topology">#</a>Mesh Topology</h2>
<p><code>网状结构（Mesh Topology）</code>为任意两两配对的电脑都提供了连接线路，这意味着如果有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>台电脑，就需要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><msup><mi>n</mi><mn>2</mn></msup><mo>−</mo><mi>n</mi></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{n^2-n}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3629em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0179em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>个连接。当增加电脑时，连接电缆的增加是平方级的，因此开销巨大，也因此网状结构在局域网中不常被使用</p>
<h2 id="Star_Topology"><a class="header-anchor" href="#Star_Topology">#</a>Star Topology</h2>
<p><code>星状结构（Star Topology）</code>是所有的电脑都连接在一个中心设备（Hub）上。注意星状结构并不严格要求中心设备真的在所有电脑的中心，与所有电脑的距离相同。</p>
<h2 id="The_Reason_For_Multiple_Topologies"><a class="header-anchor" href="#The_Reason_For_Multiple_Topologies">#</a>The Reason For Multiple Topologies</h2>
<p>每个结构都有各自的优点，如环状结构很适合各电脑间协调访问，但当其中一个设备出现问题时，通路就会出现问题。星状结构下单一设备出现了问题，其他设备都可以正常访问。总线结构有最少的连接需求，但与环状结构与相同的缺点。网状结构因为连接数量过多，通常不在局域网中使用。</p>
<h1 id="Packet_Identification，Demultiplexing，Mac_Addresses"><a class="header-anchor" href="#Packet_Identification，Demultiplexing，Mac_Addresses">#</a>Packet Identification，Demultiplexing，Mac Addresses</h1>
<p>IEEE为寻址（Addressing）创建了标准。在分组交换中，解复用是依赖于一个称为<code>地址（Address）</code>的标识。每个电脑都分配了一个独特的地址，每个传输的包中都包含其目标收件人（Intended Recipent）的地址。</p>
<p>在IEEE的寻址规范中，每个地址是由48-bit二进制数据组成的，IEEE将其称为媒介访问控制地址（Media Access Control address,MAC address）。因为48位地址来源于以太网技术，所以也有人将其称为以太网地址（Ethernet Address）。</p>
<p>IEEE为每块网卡（Network Interface Card，NIC）都分配了地址，因此当消费者购买了一张网卡时，其中就包含一个独一无二的地址。</p>
<p>但IEEE并不是单独的为每个网卡分配地址，它是将前24位（3 Bytes）分配给设备供应商，然后设备供应商再决定后24位的数据。因此前24位称为组织唯一标识符（Organizationally Unique Identifier，OUI），后24位称为网络接口控制标识符（Network Interface Controller Specific）。</p>
<p>组织唯一标识符的最高有效字节（Most Significant Byte，即大端模式下即最左端）的倒数两位有特殊含义。其最低位表示是单播（0）还是双播（1）。倒数第二位决定该设备是全球唯一（0）（Globally Unique）还是是本地分配（1）（Locally Assigned），全球唯一表明地址是IEEE分配，即世界上的每块网卡都有不同的表示，而本地分配是实验性网卡或者某组织自己地址空间等，即这张卡是在一个小范围内内部使用。</p>
<h1 id="Unicast，Broadcast，And_Multicast_Addresses"><a class="header-anchor" href="#Unicast，Broadcast，And_Multicast_Addresses">#</a>Unicast，Broadcast，And Multicast Addresses</h1>
<p>IEEE定义了三种对应包传递的方法：</p>
<ol>
<li>单播（Unicast）：目标地址是设定一个电脑，也仅这个电脑可收到包</li>
<li>广播（broadcast）：网络中的所有电脑都可收到包</li>
<li>多播（multicast）：目标地址是一系列的电脑，这些电脑都可以收到包。</li>
</ol>
<p>对于广播来说，因为是所有电脑都收到包，所以目标地址实际是没有意义的。将地址的48位全部设为1，则表示是广播模式。广播模式也可看作是多播模式的一个特殊情况。</p>
<h1 id="Broadcast_Multicast_And_Efficient_Multi_Point_Delivery"><a class="header-anchor" href="#Broadcast_Multicast_And_Efficient_Multi_Point_Delivery">#</a>Broadcast,Multicast,And Efficient Multi-Point Delivery</h1>
<p>广播和多播模式在局域网中特别有用，对于要传递给多台电脑的数据来说，用这两种方法进行传递特别的高效。</p>
<p>对于大多数的LAN技术，都是通过一个共享的媒介进行传输。当有数据在媒介中传输时，每台电脑都将从媒介中获取包的拷贝，然后再判断包中的地址情况是否与自己复合，来决定是处理包的内容还是丢弃包的内容。</p>
<p>因此局域网中的计算机在处理媒介中的包流程如下：</p>
<ol>
<li>从包中抽取出地址信息</li>
<li>判断地址是否满足自己的单播地址，如果是则接受并处理包</li>
<li>如果2失败，判断地址是否是广播模式，如果是则接受并处理包</li>
<li>如果3失败，判断地址是否是多播模式，且电脑是多播模式指定的电脑组的一员，如果是则接受并处理包</li>
<li>如果4失败，则丢弃包</li>
</ol>
<p>如在局域网情况下，如果多台电脑使用同一个媒介，且包需要传递给多态电脑，那么使用多播和广播模式，数据仅需要发送一次即可。</p>
<h1 id="Frames_And_Framing"><a class="header-anchor" href="#Frames_And_Framing">#</a>Frames And Framing</h1>
<p>在同步通信系统中，帧的概念是让接收者知道数据的开始和结束。但在更宽泛的概念下，帧是表示一系列bit或byte的特定结构，让接收方和发送方都能一致同意的特定格式。</p>
<p>在分组交换中，帧的概念就对应包。在分组交换中，每个包都需要一个数据头，数据头（header）中包含目标地址。数据头后是有效负载（payload），即真正需要传输的原数据。在大部分的网络技术中，有效负载是不透明的即网络设备只能检查数据头。</p>
<p>在整个包的前后还能加入可选的前置数据（Prelude）或后置数据（Postlude）。因此整个包的结构如下所示：</p>
<p><img src="/ch_13_local_area_networks_packets,_frames,_and_topologies/2019-12-09-10-47-15.png" alt="包的结构"></p>
<p>举一个例子，如果一个包有6个byte的数据头，然后任意长度的有效负载，在包的前后各有1byte表示包的开始和结束。且开始和结束标识用ASCII码中的SOH（Start Of Header）和EOT（End Of Transmission）表示，则整个包如下所示：</p>
<p><img src="/ch_13_local_area_networks_packets,_frames,_and_topologies/2019-12-09-10-49-20.png" alt="包的例子"></p>
<p>上述例子有一点点数据的浪费，因为如果包是一个接一个发的，那么后一个包的SOH会紧跟着前一个包的EOT。在实际中，只需要一个来区分两个包即可。</p>
<p>虽然包的前置数据和后置数据是可选的，但在实际使用中，他们可以一定程度上提升异步传输数据的处理速度和对错误的检测。在异步传输中，如果接收方收到了EOT，它就知道数据包传输完成了，可以直接开始处理数据而不需要等到下一个包的到来再根据新包确定上个包是否完成。当发送端发送数据到一般崩溃时，因为接收端始终收不到EOT，也就能知道错误的发生。</p>
<h1 id="Byte_And_Bit_Stuffing"><a class="header-anchor" href="#Byte_And_Bit_Stuffing">#</a>Byte And Bit Stuffing</h1>
<p>在ASCII码中，SOH用十六进制0x01表示，EOT用0x04表示。如果有效负载中也出现了0x01和0x04，接收端就无法判定到底是真实数据还是前置或后置标识。</p>
<p>一种称为字节填充（byte Stuffing）就是为了解决有效负载和特殊标记位有相同表示导致无法识别的问题。<br>
该技术有时也称为数据填充（Data Stuffing）或字符填充（Character Stuffing）。该技术主要是</p>
<p>字节装填是用另一个字符来替代特殊标识的出现。</p>
<p>如我们选择用ASCII码中的ESC字符（Ox1B）来作为替换字符。在发送端当有效负载中出现SOH，那么就替换为&quot;ESC A&quot;，如果出现EOT,就替换为&quot;ESC B&quot;，如果出现了ESC就替换为&quot;ESC C&quot;。注意这个计算是针对有效负载的，当整个发送的有效负载中就不会与EOT和SOH相同的数据。对接收端而言，去找寻背后跟着&quot;A,B,C&quot;的ESC字符，然后将其替换回SOH和EOT的数据。发送端的替换过程如下所示：</p>
<p><img src="/ch_13_local_area_networks_packets,_frames,_and_topologies/2019-12-09-11-22-32.png" alt="字节装填"></p>
<h1 id="Reference"><a class="header-anchor" href="#Reference">#</a>Reference</h1>
<p><a href="https://web.archive.org/web/20171217042848/http://www.cs.virginia.edu/~mngroup/projects/mpls/documents/thesis/node8.html">Switching technology</a><br>
<a href="https://www.cnblogs.com/penghuwan/p/7686059.html#_label3_1">【计算机网络】数据交换技术和多路复用技术的正（nao）确(can)打开方式</a></p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《Computer Networks and Internets》 Ch 14 MAC 层</title>
    <url>/ch_14_the_ieee_mac_sublayer/</url>
    <content><![CDATA[<ul>
<li>这一章原书中的Statiion一词，在笔记中翻译为<code>终端</code>。</li>
</ul>
<h1 id="Introduction"><a class="header-anchor" href="#Introduction">#</a>Introduction</h1>
<p>这一章将会深入讨论MAC层，包括多路访问协议（multi-access protocols）以及静态和动态信道分配。</p>
<h1 id="A_Taxonomy_Of_Mechanisms_For_Shared_Access"><a class="header-anchor" href="#A_Taxonomy_Of_Mechanisms_For_Shared_Access">#</a>A Taxonomy Of Mechanisms For Shared Access</h1>
<p>实现多个计算机通过一个共享媒介来访问数据主要有三种方法： （1）复用技术（Multiplexing Technique） （2）分布算法来控制访问（Distributed Algorithms For Controlled Access） （3）随机访问策略（Random Access Strategy）</p>
<ul>
<li>这里的复用技术与在11章中讨论的复用核心思想是相同的，但仍然有略微区别。11章中提到的是物理上的复用，通过复用器将信号合并在一起。这里的复用则是对于共享信道的逻辑划分，使不同的终端占用共享信道的部分资源，所以这里的复用技术也称为<code>信道协议（Channelization Protocols）</code>。</li>
</ul>
<p>下图展示了按照共享媒介所使用的方法的分类：</p>
<p><img src="/ch_14_the_ieee_mac_sublayer/2019-12-27-22-55-32.png" alt="共享媒介的分类方法"></p>
<h1 id="Static_And_Dynamic_Channel_Allocation"><a class="header-anchor" href="#Static_And_Dynamic_Channel_Allocation">#</a>Static And Dynamic Channel Allocation</h1>
<p>信道分配是与第11章中提到的复用技术相关联的。以频分复用为例子，在第11章中是每个终端都有它的载波频率，终端与载波频率是一对一的关系，这就是<code>信道的静态分配（Static Channel Allocation）</code>。</p>
<p>信道可以静态分配的前提是预先知道终端的存在，而且终端在传输过程中不会发生变化。而在许多的场景下，终端是会变化的，例如一个路由器负责房间内手机的信号，但是手机可以关闭或者离开房间，这就是终端的变化。</p>
<p>在这种情况下就需要<code>信道的动态分配（Dynamic Channel Allocation）</code>，即当终端出现时才分配信道的资源给终端。</p>
<h1 id="Channelization_Protocols"><a class="header-anchor" href="#Channelization_Protocols">#</a>Channelization Protocols</h1>
<p>与第11章中的复用技术相似，信道分配也存在频分多路复用（Frequency Division Multi-Access），时分多路复用（Time Division Multi—Access），码分多路复用（Code Division Multi-Access）三种类型。</p>
<h2 id="FDMA"><a class="header-anchor" href="#FDMA">#</a>FDMA</h2>
<p>频分多路复用下每个终端都可以选择一个载波频率，这个频率并不会影响到其他的终端。在有些系统下存在一个中央控制器进而支持动态的频分多路复用：当一个新的终端出现，中央控制器用一个预留的信道与终端通信，然后分配一个未使用的载波频率给这个终端，之后终端都使用这个载波频率传输数据。</p>
<h3 id="TDMA"><a class="header-anchor" href="#TDMA">#</a>TDMA</h3>
<p>时分多路复用下，所有终端按顺序编号，如<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">1,2,3,...N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>，并且会按这个顺序占据信道进行传输。如同频分多路复用，在某些系统下支持动态分配，即终端出现时再分配给他信道的占用时间段。</p>
<h3 id="CDMA"><a class="header-anchor" href="#CDMA">#</a>CDMA</h3>
<p>码分多路复用如同码分复用，通过数学方法将多个终端的数据合并在一起，再同时通过信道进行传输。</p>
<h1 id="Controlled_Access_Protocols"><a class="header-anchor" href="#Controlled_Access_Protocols">#</a>Controlled Access Protocols</h1>
<p>访问控制协议（Controlled Access Protocols）为统计复用提供了方法，主要分为三个类型：</p>
<ol>
<li>轮询（Polling）：控制中央持续的询问每一个终端是否要发送数据。</li>
<li>预留（Reservation）：终端需要发送信息时，发出一个在下一次循环时发送数据的申请。</li>
<li>令牌传递（Token Passing）：终端间循环传递一个令牌，当终端持有令牌时可以发送数据。</li>
</ol>
<h2 id="Polling"><a class="header-anchor" href="#Polling">#</a>Polling</h2>
<p><code>轮询（Polling）</code>系统是存在一个中央控制器，这个控制器会询问其下的每个终端是否需要传递数据。轮询可以再细分为两种，<code>轮询调度顺序（Round Robin Order）</code>和<code>优先顺序（Priority Order）</code>。在轮询调度顺序下，每个终端都有相同的机会传递数据，而在优先顺序下，一些终端会有更多的机会去传递数据。</p>
<p>轮询的算法实现伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">For Centralized Controller:</span><br><span class="line">while(true)</span><br><span class="line">&#123;</span><br><span class="line">  Select a station S, and send a polling message to S;</span><br><span class="line">  Wait for S to respond by sending a packet or passing;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Reservation"><a class="header-anchor" href="#Reservation">#</a>Reservation</h2>
<p><code>预留（Reservation）</code>系统多用在航天系统中，系统分为两个步骤，在第一步中需要传输数据的终端申请，所有申请的终端构成一张表，在第二步中表中的终端开始传输数据。通常第一步与第二步使用的是不同的信道，即有一个信道专门用来接受申请信息，另一个信道作为主信道传递每个终端的数据。</p>
<p>预留的算法实现伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">For Centralized Controller:</span><br><span class="line">While(true)</span><br><span class="line">&#123;</span><br><span class="line">  Form a list of stations that have a packet to send;</span><br><span class="line">  Allow stations on the list to tranmit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Token_Passing"><a class="header-anchor" href="#Token_Passing">#</a>Token Passing</h2>
<p><code>令牌传递（Token Passing）</code>被用在多个局域网（LAN）技术中，被用的最多的就是环形拓步结构中。在一个网络中，某一台计算机持有着一个特殊的控制命令，这个命令被称作为令牌，持有令牌的计算机可以发送数据，在发送完毕后将令牌传递给下一个计算机。</p>
<p>令牌传递的算法实现伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">For each computer:</span><br><span class="line">While(true)</span><br><span class="line">&#123;</span><br><span class="line">  Wait for the token to arrive;</span><br><span class="line">  Transmit a packet if one is waiting to be send;</span><br><span class="line">  Send the token to he next station;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>环形拓补结构中，存在物理的环形链接，所以令牌可以直接传递给相邻的下一个电脑。在其他的拓步结构中，所有的计算机都被赋予了一个逻辑顺序，因此可以获知下一个要收取令牌的电脑是哪个。</p>
<h1 id="Random_Access_Protocols"><a class="header-anchor" href="#Random_Access_Protocols">#</a>Random Access Protocols</h1>
<p>许多网络，特别是局域网络中，并不使用访问控制协议，而使用<code>随机访问协议（Random Access Protocols）</code>。随机访问协议下只有当终端存在数据要发送时，才会被给予权限（在访问控制协议中，每个终端都要被持续检查）。这里的<em>随机</em>是在所有终端都有数据要发送时的处理方式。随机访问协议也可以被分为三类：</p>
<ol>
<li>ALOHA：早期夏威夷的无线电网络中被使用的协议。在教科书中比较流行，因为便于分析，但在实际网络中已不再使用。</li>
<li>CSMA/CD（Carrier Sense Multi-Access With Collision Detection）：原以太网的基础，现在也不再使用。</li>
<li>CSMA/CA（Carrier Sense Multi-Access With Collision Avoidance）：Wifi无线网络的基础。</li>
</ol>
<h2 id="ALOHA"><a class="header-anchor" href="#ALOHA">#</a>ALOHA</h2>
<p>在早期夏威夷的网络中使用，在这个系统下有一个强大的发送器被部署中在物理上的中心位置，其他的终端（通常对应一台计算机）在这个发送器周围部署，这些终端都没有足够的能量将数据直接传输给其他终端，因此需要通过中央的发送器。</p>
<p>中央发送器用两个载波频率与每个终端通信，一个被称为入站频率（In Frequency，407.305MHZ），一个被称为出站频率（Outbound Frequency，413.475MHZ）。终端通过入站频率将数据传递给中央发送器，中央发送器通过出站频率将数据发送给每个终端。</p>
<p>ALOHA的实现逻辑很直接：当终端有数据要发送时，使用入站频率将数据传递给中央数据站，中央数据站通过出站频率将数据传给所有的终端，终端检查数据是否是自己需要的。为了保证数据被正常发送，发送终端也需要监听出站频率，当发送的数据拷贝被传输回发送终端，发送终端确认数据被正常传递了，就会传输下一个数据。反之，则会在一段时间后尝试重新发送。</p>
<p>当两个终端同时使用各自的入站频率传输数据时，两个数据会发送混淆，进而导致信息错误，将这种情况称为信道冲突（Collision）。协议通过等待一段时间后重新发送数据来解决冲突，重新发送数据前的等待时间的设定尤为关键，如果两个终端等待的时间相同，那么再次发送数据时仍然是同时发送则会继续导致冲突。因此等待时间是随机的，但是网络繁忙时，冲突的概率仍然会增加，因为即使是随机时间仍然可能会与其他的终端发生冲突。</p>
<p>ALOHA示意图如下：</p>
<p><img src="/ch_14_the_ieee_mac_sublayer/2019-12-28-12-56-15.png" alt="ALOHA示意图"></p>
<h2 id="CSMA_CD"><a class="header-anchor" href="#CSMA_CD">#</a>CSMA/CD</h2>
<p>1978年，数字设备联盟（Digital Equipment Corporation），英特尔（Intel）和施乐（Xerox）共同指定了个标准（DIX标准），也就是后来的以太网。最早的以太网技术使用一根长电缆连接每个电脑，这根长电缆就是共享媒介，与ALOHA使用中央发送器来实现数据传输不同，在以太网中每个终端都可以通过这个共享的线缆传输数据。以太网同样需要解决冲突问题，以太网主要引入了三个解决冲突的方法，统称为<code>具有冲突检测功能的载波侦听多路访问（CSMA/CD，Carrier Sense Multi-Access With Collision Detection）</code>：</p>
<ol>
<li>载波侦听（Carrier Sense）：</li>
</ol>
<p>在每个终端发送数据前，先监听线缆确定是否有其他的终端正在传输数据。</p>
<ol start="2">
<li>冲突检测（Collision Detection）：</li>
</ol>
<p>虽然有载波侦听，但如果在线缆空闲时，两个需要发送数据的终端同时监听，此时他们都发现线缆空闲，因此都开始传输数据，这时候仍然会造成冲突。因此在传输过程中，发送终端也会持续的监听线缆，如果发现线缆中的数据与发送的数据不同，说明已经发生了冲突，数据被干扰了，于是停止数据的发送。</p>
<p>以太网的数据传输还有一些细节问题，如在检测到冲突时，发送端并不会立刻停止数据的发送，他仍然会传输数据一段时间，保证所有的其他终端都可以收到冲突信号。另外，当一个包被发送完后，发送终端需要等待一段时间，称为<code>包间间隙（Interpacket gap）</code>（在早期10Mbps的以太网中，包间间隙为9.6微秒），保证其他的终端可以检测到线缆的空闲并传递数据。</p>
<ol start="3">
<li>二进制指数补偿（Binary Exponential Backoff）</li>
</ol>
<p>如ALOHA一样，在发现了冲突后，发送端需要等待一段时间重新发送数据，这个等待时间是随机的，通常会设置一个最大延迟时间<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span>，然后在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>∼</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">0\sim d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span>。如之前所述，在网络繁忙时，可能存在随机后终端仍然冲突的情况。二进制指数补偿是指在新一次冲突发生后，随机的范围变成<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>∼</mo><mn>2</mn><mi>d</mi></mrow><annotation encoding="application/x-tex">0\sim 2d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">2</span><span class="mord mathnormal">d</span></span></span></span>，如果再有冲突则变成<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>∼</mo><mn>4</mn><mi>d</mi></mrow><annotation encoding="application/x-tex">0\sim 4d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">4</span><span class="mord mathnormal">d</span></span></span></span>，依次类推。</p>
<p>CSMA/CD算法实现伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">For each Computer:</span><br><span class="line"></span><br><span class="line">Wait for a packet to be ready;</span><br><span class="line">Wait for the medium to be idle;</span><br><span class="line">Delay for the interpacket gap;</span><br><span class="line">Set x to be the standard backoff range d;</span><br><span class="line">Attempt to transmit the packet;</span><br><span class="line"></span><br><span class="line">While(Collision occured)</span><br><span class="line">&#123;</span><br><span class="line"> random a delay time q from 0 to x;</span><br><span class="line"> delay for q microseconds;</span><br><span class="line"> double x to be 2x</span><br><span class="line"> attempt to retransmit the packet</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CSMA_CA"><a class="header-anchor" href="#CSMA_CA">#</a>CSMA/CA</h2>
<p>CSMA/CD并不能被运用在无线网络中，因为无线网络中的设备存在一个最远距离<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi></mrow><annotation encoding="application/x-tex">\delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span></span></span></span>。即如果两个终端的距离大于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi></mrow><annotation encoding="application/x-tex">\delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span></span></span></span>，则CSMA/DA中的载波监听就无法被应用，因为一个终端并不能知道另一个是否在发送信息。这种情况如下图所示，如果Computer1在发送信息，Computer3是无法得知的，因此冲突只有Computer2可以知晓，这种情况称为<code>隐藏终端问题(Hidden Station Problem)</code>。</p>
<p><img src="/ch_14_the_ieee_mac_sublayer/2019-12-28-15-00-02.png" alt="隐藏终端问题"></p>
<p>所以无线网络中使用<code>具有冲突规避的载波侦听多路访问（CSMA/CA，Carrier Sense Multi-Access With Collision Avoidance）</code>。以上图的例子，Computer3在发送数据前会先向所有它的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi></mrow><annotation encoding="application/x-tex">\delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span></span></span></span>范围内的设备发出一个短信息表明自己需要发送数据了，接受到Computer3发出的短信息的设备会检查自己是否正在接受其他的数据，如果不是则回复可以发送的信号。如下图所示：</p>
<p><img src="/ch_14_the_ieee_mac_sublayer/2019-12-28-15-08-19.png" alt="CSMA/CA图解"></p>
<p>如果发送端没有收到接收方的回执，则会在随机时间后再次尝试发送。</p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《Computer Networks and Internets》 Ch 16 无线网络技术</title>
    <url>/ch_16_wireless_networking_technologies/</url>
    <content><![CDATA[<h1 id="Introduction"><a class="header-anchor" href="#Introduction">#</a>Introduction</h1>
<p>这一章主要介绍计算机网络无线部分的技术。</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>16.2</mn></mrow><annotation encoding="application/x-tex">16.2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">16.2</span></span></span></span>节对无线技术依据网络的覆盖范围做了分类。<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>16.3</mn></mrow><annotation encoding="application/x-tex">16.3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">16.3</span></span></span></span>节介绍了个人局域网。<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>16.4</mn></mrow><annotation encoding="application/x-tex">16.4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">16.4</span></span></span></span>节介绍了ISM频域。<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>16.5</mn><mo>∼</mo><mn>16.11</mn></mrow><annotation encoding="application/x-tex">16.5\sim16.11</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">16.5</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">16.11</span></span></span></span>都是介绍局域网相关技术，主要关注对象是Wifi技术。<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>16.12</mn></mrow><annotation encoding="application/x-tex">16.12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">16.12</span></span></span></span>介绍了城域网中使用的WiMax技术。<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>16.13</mn></mrow><annotation encoding="application/x-tex">16.13</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">16.13</span></span></span></span>给出了个人局域网的标准分类列表。<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>16.14</mn></mrow><annotation encoding="application/x-tex">16.14</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">16.14</span></span></span></span>介绍了两个没有被包含在个人局域网中的短距离通信，红外线和射频识别通信。<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>16.15</mn><mo>∼</mo><mn>16.18</mn></mrow><annotation encoding="application/x-tex">16.15\sim16.18</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">16.15</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">16.18</span></span></span></span>介绍了广域网技术，主要关注蜂窝式网络。<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>16.19</mn><mtext>和</mtext><mn>16.20</mn></mrow><annotation encoding="application/x-tex">16.19和16.20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">16.19</span><span class="mord cjk_fallback">和</span><span class="mord">16.20</span></span></span></span>介绍了卫星通信。<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>16.20</mn></mrow><annotation encoding="application/x-tex">16.20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">16.20</span></span></span></span>介绍了软件无线电系统。</p>
<h1 id="A_Taxonomy_Of_Wireless_Networks"><a class="header-anchor" href="#A_Taxonomy_Of_Wireless_Networks">#</a>A Taxonomy Of Wireless Networks</h1>
<p>计算机网络无线技术的变种非常多的原因之一在于因为政府的管理，电磁信号的频谱被切分为了许多不同的部分以供不同的目的使用，而这些不同频域的技术通常都不同。</p>
<p>无线技术通常通过其使用的范围来分类，主要可分为：<code>局域网（Local Area Networks,LANs）</code>，<code>城域网（Metropolitan Area Networks,MANs）</code>，<code>广域网（Wide Area Networks，WANs</code>）以及<code>个人局域网（ Personal Area Networks，PANs）</code>。如下图所示：</p>
<p><img src="/ch_16_wireless_networking_technologies/2019-12-30-15-51-47.png" alt="无线网络分类"></p>
<h1 id="Personal_Area_Networks（PANs）"><a class="header-anchor" href="#Personal_Area_Networks（PANs）">#</a>Personal Area Networks（PANs）</h1>
<p>上节中对于无线网络的分类与在第十三章中对于网络的分类十分类似，不同的是这里还引入了个人局域网（Personal Area Networks，PANs）的概念。个人局域网是提供非常短距离下的通信，通常是只供一个用户使用，如蓝牙耳机就属于个人局域网的应用。</p>
<p>个人局域网络可以再细分为以下几种：</p>
<ol>
<li>蓝牙（Bluetooth）：距离较短</li>
<li>红外线（Infrared）：视距通信（Line-Of-Sight Communication）即发射端和接收端之间需要无遮挡</li>
<li>紫峰（ZigBee）：距离可以支撑一个住宅的范围，在智能家居中被运用。</li>
<li>其他ISM无线技术：为工业，科学以及医药（Industrial，Scientific，Medical，ISM）预留的频率发展的技术。</li>
</ol>
<h1 id="ISM_Wireless_Bands_Used_By_LANs_And_PANs"><a class="header-anchor" href="#ISM_Wireless_Bands_Used_By_LANs_And_PANs">#</a>ISM Wireless Bands Used By LANs And PANs</h1>
<p>振幅为了工业，科学以及医药领域专门预留了一部分频域，被称为ISM无线。这部分的频域并没有再进一步细分，如科学只能用哪一段频域之类。这三个领域的产品都可以使用这部分频域，具体频域如下图所示：</p>
<p><img src="/ch_16_wireless_networking_technologies/2019-12-30-16-04-51.png" alt="ISM频域"></p>
<h1 id="Wireless_LAN_Technologies_And_Wi_Fi"><a class="header-anchor" href="#Wireless_LAN_Technologies_And_Wi_Fi">#</a>Wireless LAN Technologies And Wi-Fi</h1>
<p>IEEE将局域网下的无线网络协议分类在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>802.11</mn></mrow><annotation encoding="application/x-tex">802.11</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">802.11</span></span></span></span>下。1999年一些销售商建立了Wifi联盟，一个生产和验证使用802.11协议的无线设备的非盈利组织。因为这个联盟的产品在商业市场上反应很好，消费者将Wifi一词与无线局域网联系在了一起，Wifi原先是产品广告词中<code>Wireless Fidelity</code>的缩写。</p>
<p>下表为Wifi联盟所指定的协议：</p>
<p><img src="/ch_16_wireless_networking_technologies/2019-12-30-16-21-32.png" alt="Wifi联盟协议"></p>
<h1 id="Spread_Spectrum_Technology"><a class="header-anchor" href="#Spread_Spectrum_Technology">#</a>Spread Spectrum Technology</h1>
<p>在第十一章中提到的展频技术（Spread Spectrum Technology）在wifi技术中也有应用。</p>
<p>展频技术的原理是发送端将原先的信道频域再细分为多个部分，将数据通过不同的频率发送出去，接收端接受多个频率的数据，再还原出原信号。使用展频技术主要目的有两个，一是增加传输速率，另外是增加对噪声的抗干扰能力。</p>
<p>Wifi技术主要用了以下扩频技术，其主要目的还是帮助Wifi在有噪声环境下能更好的工作：</p>
<ol>
<li>
<p>直接扩频（Direct Sequence Spread Spectrum，DSSS）：</p>
<p>发送端使用一个序列码得到不同的频率，用这些频率来发送数据。</p>
</li>
<li>
<p>跳频扩频（Frequency Hopping Spread Spectrum，FHSS）：</p>
<p>载波的频率一直在设定的几个频率间切换。</p>
</li>
<li>
<p>正交频率复用（Orthogonal Frequency Division Multiplexing，OFDM）：</p>
<p>将原信道分为多个小信道，每个小信道传输一部分的数据。</p>
</li>
</ol>
<ul>
<li>书中并未对三个技术做详细的解释，上面的概括解释也可能存在错误。</li>
</ul>
<p>三个技术都有各自的优点，OFDM有最高的适用性，DSSS性能好，FHSS对于噪声的抗干扰能力强。</p>
<h1 id="Other_Wireless_LAN_Standards"><a class="header-anchor" href="#Other_Wireless_LAN_Standards">#</a>Other Wireless LAN Standards</h1>
<p>除了上述Wifi联盟所指定的协议，无线局域网还有其他许多的协议，都属于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>802.11</mn></mrow><annotation encoding="application/x-tex">802.11</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">802.11</span></span></span></span>协议分类下如下图所示：</p>
<p><img src="/ch_16_wireless_networking_technologies/2019-12-30-16-48-56.png" alt="其他802.11协议"></p>
<h1 id="Wireless_LAN_Architecture"><a class="header-anchor" href="#Wireless_LAN_Architecture">#</a>Wireless LAN Architecture</h1>
<p>局域网无线网络结构主要有三个因素：（1）<code>接入点（Access Point）</code>，有时也被称为<code>基站（Base Station）</code>。（2） <code>互联机制（Interconnection mechanism）</code>，例如路由器或者交换机，用来将接入点连接在一起。（3）一系列<code>终端（Hosts）</code>，如个人手机就是一个终端。</p>
<p>存在两种无线局域网，一是<code>自主网（Ad hoc）</code>，其中所有的终端都可以在没有接入点的情况下相互通信。另外一个是<code>基础设施结构（Infrastructure）</code>。</p>
<p>在实际运用中，自主网很少存在，基础设施结构如下图所示，图中的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>P</mi></mrow><annotation encoding="application/x-tex">AP</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span>即为接入点（Access Point），一个接入点和连接它的一系列终端称为<code>基本服务集（Basic Service Set，BSS）</code>。</p>
<p><img src="/ch_16_wireless_networking_technologies/2019-12-30-16-59-39.png" alt="基础设施结构"></p>
<h1 id="Overlap，Association，And_802_11_Frame_Format"><a class="header-anchor" href="#Overlap，Association，And_802_11_Frame_Format">#</a>Overlap，Association，And 802.11 Frame Format</h1>
<p>在实际运用中，基础设施结构中的接入点如果距离太远，会出现<code>无服务区（Dead Zone）</code>，距离太仅的话，他们的覆盖的范围会出现重叠（Overlap），因此终端可能会同时存在于两个接入点的范围内。在这种情况下，终端需要指定他与哪个接入点进行通信，因此在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>802.11</mn></mrow><annotation encoding="application/x-tex">802.11</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">802.11</span></span></span></span>协议定义的网络帧格式下，帧数据必须包含其连接的接入点的MAC地址。</p>
<p>另外如果基础设施结构是要连接外网的，那么接入点的互联机制还需要另外一个有线连接至与外网连接的路由器，如下图所示，下图也同时展示了上述的接入点重叠情况</p>
<p><img src="/ch_16_wireless_networking_technologies/2019-12-30-17-06-11.png" alt="外网连接以及接入点重叠"></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>802.11</mn></mrow><annotation encoding="application/x-tex">802.11</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">802.11</span></span></span></span>的定义的数据帧，还需要指定连接外网的路由器的MAC地址，综上数据帧的结构如下：</p>
<p><img src="/ch_16_wireless_networking_technologies/2019-12-30-17-07-42.png" alt="802.11数据帧"></p>
<h1 id="Coordination_Among_Access_Points"><a class="header-anchor" href="#Coordination_Among_Access_Points">#</a>Coordination Among Access Points</h1>
<p>如上节所述，在接入点重叠的情况下，终端需要决定与哪个接入点进行通信。</p>
<p>主要有两种方法来实现接入点的切换，第一个是靠接入点本身，接入点能相互通信，当接入点发现有终端同时收到多个接入点信号时，接入点会判断信号强度然后帮助终端无缝切换，这种方法实现较为复杂且成本较高。第二种方法下，所有接入点都是独立的，切换是靠终端本身实现，这种方法的成本较低。</p>
<h1 id="Contention_And_Contention_Free_Access"><a class="header-anchor" href="#Contention_And_Contention_Free_Access">#</a>Contention And Contention-Free Access</h1>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>802.11</mn></mrow><annotation encoding="application/x-tex">802.11</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">802.11</span></span></span></span>定义了两种信道访问的方式：无竞争（Contention-Free）的点协调方式（Point Coordinated Function，PCF）和存在竞争的分布协调方式（Distributed Coordinated Function，DCF）。</p>
<p>PCF方式保证在一个基本服务集中的接入点保证下面的终端不会发生任何干扰，例如通过给每一个终端一个特定的频率来实现。但在实际中PCF从来都没有被使用过。</p>
<p>DCF则是让一个基本服务集中的终端都使用<code>随机访问协议（Random Access Protocols）</code>。并如同在十四章中的介绍，因为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>802.11</mn></mrow><annotation encoding="application/x-tex">802.11</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">802.11</span></span></span></span>是无线网络，所以通常使用的是CSMA/CA，终端需要发送准备完毕（Ready to Send，RTS）和信道空闲（Clear To Send，CTS）两种控制命令。</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>802.11</mn></mrow><annotation encoding="application/x-tex">802.11</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">802.11</span></span></span></span>中使用的CSMA/CA还包含一些在十四章未提及的细节，如定义了以下三个时间参数：</p>
<ol>
<li>
<p>短帧时间间隔（Short Inter-Frame Space,SIFS）为10微秒。</p>
<p>接收端在发送确认信息（Acknowledge，ACK）或其他控制命令前的等待时间。</p>
</li>
<li>
<p>帧间间隔（Distributed Inter-Frame Space）为50微秒。</p>
<p>在发送端发送数据前必须等待的时间，以保证其他的终端可以监听到信道的空闲。</p>
</li>
<li>
<p>时隙（Slot Time）为20微秒</p>
</li>
</ol>
<p>Wifi网络中所使用的CSMA/CA如下图所示：</p>
<p><img src="/ch_16_wireless_networking_technologies/2019-12-30-21-20-32.png" alt="Wifi网络中所使用的CSMA/CA"></p>
<p>因为各终端间的物理间隔以及环境噪声，微弱信号的检测是很困难的，因此Wifi网络并没有引入CSMA/CA中的冲突检测（Collision Detection）部分，即发送端并不会在数据发送过程中监听信道来判断是否有冲突。在Wifi网络中，发送端会等待ACK信号，如果没有收到ACK信号，发送端则认为数据发送失败。</p>
<h1 id="Wireless_MAN_Technology_And_WiMax"><a class="header-anchor" href="#Wireless_MAN_Technology_And_WiMax">#</a>Wireless MAN Technology And WiMax</h1>
<p>城域网技术的协议被反类在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>802.16</mn></mrow><annotation encoding="application/x-tex">802.16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">802.16</span></span></span></span>中。如同在局域网中主要使用的是Wifi，在城域网中主要使用的事WiMax（World-wide Interoperability For Microwave Access）技术。</p>
<p>WiMax可以再被细分为固定WiMax和移动WiMax，前者是指服务提供方与连接者的位置是固定的，如大楼间的通信，后者则指接收方是可以移动的，如用户的手机和电脑等。</p>
<p>WiMax在城域网中的使用，如果是用在回传网络（服务提供方之间的连接，通常需要较高的数据速率）中则需要无阻碍（Line-Of-Sight，LOS）的连接，如果是在服务提供方与接入点直接的连接则也可以使用有阻碍的连接（Non-Line-Of-Sight，NLOS），如下图所示：</p>
<p><img src="/ch_16_wireless_networking_technologies/2019-12-30-22-02-35.png" alt="WiMax的使用"></p>
<h1 id="PAN_Technologies_And_Standards"><a class="header-anchor" href="#PAN_Technologies_And_Standards">#</a>PAN Technologies And Standards</h1>
<p>PAN技术被分类在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>802.15</mn></mrow><annotation encoding="application/x-tex">802.15</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">802.15</span></span></span></span>分类下，如下图所示：</p>
<p><img src="/ch_16_wireless_networking_technologies/2019-12-30-22-04-05.png" alt="PAN技术"></p>
<h1 id="Other_Short_Distantce_Communication_Technologies"><a class="header-anchor" href="#Other_Short_Distantce_Communication_Technologies">#</a>Other Short-Distantce Communication Technologies</h1>
<p>还有两种技术短距离的通信方式并没有被分类在PANs下，红外通信（Infrared Data Association，IrDA）以及射频识别（Radio Frequency Identification，RFID）通信。</p>
<p>红外通信是方向性的，大约有30°的范围，而且信号可以在障碍物表面反射，但是并不能传统障碍物。电视遥控器即是使用了红外通信。</p>
<p>射频识别通信，是一个芯片中包含有验证信息的Tag，接收方可以将信息从芯片中读取出来。酒店的门禁卡，大学食堂的饭卡等都是使用了这个技术。</p>
<h1 id="Wireless_WAN_Technologies"><a class="header-anchor" href="#Wireless_WAN_Technologies">#</a>Wireless WAN Technologies</h1>
<p>广域网通信有两大类，蜂窝式通信系统（Cellular communication systems）和卫星通信系统（Satellite communication system）。</p>
<p>蜂窝式通信系统最早是为了满足手机的电话服务设计的。在这个系统下，地区被风格为一个个小块称为<code>巣室（Cell）</code>，每个巣室都包含一个基站塔，一系列基站塔由一个移动交换中心控制。这个中心会追踪用户，并在用户从一个巣室进入另一个巣室时，提供巣室的切换服务。蜂窝式系统的结构如下图：</p>
<p><img src="/ch_16_wireless_networking_technologies/2019-12-30-22-18-47.png" alt="蜂窝式系统结构"></p>
<p>理论上每个巣室都是六边形的，那么就能无缝的分割区域，但在实际运用中，每个基站塔的覆盖范围大致是圆形的，因此就会出现重叠或者无服务区。且基站塔的覆盖范围由所处区域的用户数量决定，如果用户数量很多，则每个基站塔的覆盖范围会较小，且有更多的基站塔，反之每个基站塔覆盖很大一块区域。理论和实际的巣室图如下，（a）图为理想情况，（b）图为实际情况：</p>
<p><img src="/ch_16_wireless_networking_technologies/2019-12-30-22-21-33.png" alt="巣室情况"></p>
<h1 id="Micro_Cells"><a class="header-anchor" href="#Micro_Cells">#</a>Micro Cells</h1>
<p>如上节所述，用户密度越大，则设计时每个巣室的面积越小。在城市中，有时会出现一个巣室仅覆盖大楼的一层这种情况，这是称其为微巣室（Micro Cells）。因为巣室很小且很小块区域内有多个巣室，为了避免干扰，微巣室的功率都比较小。</p>
<h1 id="Cell_Clusters_And_Frequency_Reuse"><a class="header-anchor" href="#Cell_Clusters_And_Frequency_Reuse">#</a>Cell Clusters And Frequency Reuse</h1>
<p>蜂窝式通信有一个重要原则：相邻的巣室在不使用相同频率的载波情况下，干扰最小。</p>
<p>蜂窝式系统使用称为巣室簇的结构构成，每个巣室簇都由特定数目的巣室构成，其中的每个巣室频率都不同。通常而言，巣室簇由3，4，7或12个巣室构成，如下图所示：</p>
<p><img src="/ch_16_wireless_networking_technologies/2019-12-30-23-19-08.png" alt="巣室簇"></p>
<p>巣室簇中的每个巣室频率不同，将巣室簇拼接后就不会有相邻巣室频率相同的情况出现，如下图为7巣室簇拼接：</p>
<p><img src="/ch_16_wireless_networking_technologies/2019-12-30-23-20-04.png" alt="巣室簇拼接"></p>
<h1 id="Generations_Of_Cellular_Technologies"><a class="header-anchor" href="#Generations_Of_Cellular_Technologies">#</a>Generations Of Cellular Technologies</h1>
<p>目前通信技术的发展有四代，称为1G,2G,3G和4G：</p>
<ol>
<li>1G：出现在1970年代后期，通过模拟信号传递语音信息。</li>
<li>2G和2.5G：从1990年代早期开始发展，至今仍然在使用。与1G的主要区别在于，2G使用了数字信号传递语音信息。2.5G是2G的扩展，实现了部分3G的特性。</li>
<li>3G和2.5G：从2000年开始发展，主要关注高速数据服务。3G系统提供400Kbps到2Mbps的数据速度。</li>
<li>4G：从大约2008年开始使用，主要关注实时媒体的使用，如电视直播，高速视频下载等。4G手机通常包含多种数据连接方式，如Wifi和卫星通信。</li>
</ol>
<p>在2G技术发展过程中，许多组织都尝试定义标准，欧洲主要使用TDMA技术并制订了GSM标准（Global System For Mobile Communication），该标准逐渐称为了全球标准。在美国，摩托罗拉使用TDMA技术定义了iDEM标准。同时大部分其他的美国运营商和亚洲运营商都使用了CDMA技术来指定标准。</p>
<p>在3G时代，EVDO（Evolution Data Optimized/Evolution Data Only）和EVDV标准几乎同时出现，两者都是CDMA和FDM技术的混合。EVDO技术被运用的较为广泛。</p>
<p>在设计4G标准时，国际通信协会（ITU）指定了4G蜂窝式系统的标准，称为<code>IMT-Advanced（International Mobile Telecommunication Advaced）</code>。其指定终端在高速移动时（如在火车上）应该有100Mbps的数据速率，而在静止时应该有100Mbps的速率。</p>
<p>在早期，运营商指定的4G标准，如<code>HSPA+</code>，<code>HTC Evo 4G</code>，<code>WiMax</code>和<code>LTE（Long Term Evolution）</code>都未满足要求。但是ITU还是允许了他们使用4G作为自己的广告语，在后期，<code>LTE-Advanced</code>和<code>WiMax Advanced</code>满足了ITU的标准，被称为真4G。</p>
<p>3G和4G的主要区别在于，3G系统设计时仍然是基于语音通话系统考虑的，还是继承自原先的模拟电话系统，其他的数据是作为额外的要求。而在4G标准设计时主要考虑因特网协议，因此4G系统使用了帧交换而语音只是作为一个特殊应用。在实际应用中，许多蜂窝系统仍然通过3G来传输通话信息，而在其他数据时使用4G。</p>
<h1 id="VSAT_Satellite_Technology"><a class="header-anchor" href="#VSAT_Satellite_Technology">#</a>VSAT Satellite Technology</h1>
<p>卫星通信的关键是用一个曲面天线（Parabolic antenna/Dish）保证电磁信号被反射到一个单一点上，如下图所示：</p>
<p><img src="/ch_16_wireless_networking_technologies/2019-12-30-23-39-52.png" alt="曲面天线"></p>
<p>为了最大化收集到的信号，早期的卫星通信系统使用直径大于3米的曲面天线，但这种尺寸的天线并不适用于个人或小商家。于是称为<code>甚小口径天线终端（Very Small Aperture Terminal，VSAT）</code>的技术出现，它指代直径小于3米的曲面天线，通常直径在1米以下。</p>
<p>VSAT卫星通信选择的频率不同会影响信号强度，天气环境变化的敏感程度，和信号的覆盖范围（Satellite’s footprint）。如下表所示：</p>
<p><img src="/ch_16_wireless_networking_technologies/2019-12-30-23-45-24.png" alt="VSAT卫星频率"></p>
<h1 id="GPS_Satellites"><a class="header-anchor" href="#GPS_Satellites">#</a>GPS Satellites</h1>
<p>GPS（Global Positioning System）卫星提供实时的准确位置信息。GPS通信并非是计算机通信的一部分，但是越来越多的移动网络使用了位置信息。</p>
<p>GPS系统通过三颗卫星计算出终端的位置。首先要计算终端距离三颗卫星的距离，距离可以通过卫星与终端的传输时间乘上光速来确定。如果一个终端与卫星的距离为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span>，则终端出现在以卫星为球星，半径为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span>的球上任意位置。通过三个卫星，可以计算出三个球，三个球的交点为两个点（两个球的交点为一个圆形）。这两个交点，一个在太空中，一个在地球上，地球上的点即为终端的位置。</p>
<h1 id="Software_Defined_Radio_And_The_Future_Of_Wireless"><a class="header-anchor" href="#Software_Defined_Radio_And_The_Future_Of_Wireless">#</a>Software Defined Radio And The Future Of Wireless</h1>
<p>通常一个蜂窝网络手机需要指定天线，发射器和接收器的规格，这些数据都是需要预先指定的。如果同时支持GSM，Wifi和CDMA，则需要三套独立的无线电系统，使用时在其中切换。</p>
<p>现在传统的无线电系统被软件无线电取代，可以通过软件来指定的特性如下表所示：</p>
<p><img src="/ch_16_wireless_networking_technologies/2019-12-30-23-53-54.png" alt="软件无线电可以设定的特性"></p>
<p>软件无线电的一大特性是可以同时使用多个天线，称实现了多天线同时传输和接受的系统为<code>MIMO（Multiple-Input Multiple-Output）</code>系统。</p>
<p>通过软件来设定通信特性也有一定的危险性，如用户可以选择被政府限制的频率来发送数据或者占据为紧急服务预留的频道。因此这个技术也需要严格规范。</p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《Code Complete》 笔记汇总</title>
    <url>/code_complete/</url>
    <content><![CDATA[<p>Preface</p>
<h1 id="Laying_the_Foundation"><a class="header-anchor" href="#Laying_the_Foundation">#</a>Laying the Foundation</h1>
<p><a href="/ch_01_welcome_to_software_construction">Ch 01 Welcome to Software Construction</a><br>
<a href="/ch_02_metaphors_for_a_richer_understanding_of_software_development">Ch 02 Metaphors for a Richer Understanding of Software Development</a><br>
<a href="/ch_03_measure_twice,_cut_once_upstream_prerequisites">Ch 03 Measure Twice, Cut Once_Upstream Prerequisites</a></p>
<ul>
<li><a href="/ch_03_requirement_checklist">Ch 03 Requirement Checklist</a></li>
<li><a href="/ch_03_architecture_checklist">Ch 03 Architecture Checklist</a></li>
<li><a href="/ch_03_prerequisites_checklist">Ch 03 Prerequisites Checklist</a></li>
</ul>
<p><a href="/ch_04_key_construction_decisions">Ch 04 Key Construction Decisions</a></p>
<ul>
<li><a href="/ch_04_construction_practices_checklists">Ch 04 Construction Practices Checklists</a></li>
</ul>
<h1 id="Creating_High_Quality_Code"><a class="header-anchor" href="#Creating_High_Quality_Code">#</a>Creating High-Quality Code</h1>
<p><a href="/ch_05_design_in_construction">Ch 05 Design in Construction</a></p>
<ul>
<li><a href="/ch_05_design_checklist">Ch 05 Design Checklist</a></li>
</ul>
<p><a href="/ch_06_working_classes">Ch 06 Working Classes</a></p>
<ul>
<li>Ch 06 Class Quality Checklist</li>
</ul>
<p>Ch 07 High-Quality Routines<br>
Ch 08 Defensive Programming<br>
Ch 09 The Pseudocode Programming Process</p>
<h1 id="Variables"><a class="header-anchor" href="#Variables">#</a>Variables</h1>
<p>Ch 10 General Issues In Using Variables<br>
Ch 11 The Power of Variable Names<br>
Ch 12 Fundamental Data Types<br>
Ch 13 Unusual Data Types</p>
<h1 id="Statements"><a class="header-anchor" href="#Statements">#</a>Statements</h1>
<p>Ch 14 Organizing Straight-Line Code<br>
Ch 15 Using Conditionals<br>
Ch 16 Controlling Loops<br>
Ch 17 Unusual Control Structures<br>
Ch 18 Table-Driven Methods<br>
Ch 19 General Control Issues</p>
<h1 id="Code_Improvements"><a class="header-anchor" href="#Code_Improvements">#</a>Code Improvements</h1>
<p>Ch 20 The Software-Quality Landscape<br>
Ch 21 Collaborative Construction<br>
Ch 22 Developer Testing<br>
Ch 23 Debugging<br>
Ch 24 Refactoring<br>
Ch 25 Code-Tuning Strategies<br>
Ch 26 Code-Tuning Techniques</p>
<h1 id="System_Considerations"><a class="header-anchor" href="#System_Considerations">#</a>System Considerations</h1>
<p>Ch 27 How Program Size Affects Construction<br>
Ch 28 Managing Construction<br>
Ch 29 Integration<br>
Ch 30 Programming Tools</p>
<h1 id="Software_Craftsmanship"><a class="header-anchor" href="#Software_Craftsmanship">#</a>Software Craftsmanship</h1>
<p>Ch 31 Layout and Style<br>
Ch 32 Self-Documenting Code<br>
Ch 33 Personal Character<br>
Ch 34 Themes in Software Craftsmanship</p>
]]></content>
      <tags>
        <tag>系统设计</tag>
        <tag>编码规范</tag>
      </tags>
  </entry>
  <entry>
    <title>《Computer Networks and Internets》 Ch 17 中继器，网桥和交换机</title>
    <url>/ch_17_repeaters,_bridges,_and_switches/</url>
    <content><![CDATA[<h1 id="Introduction"><a class="header-anchor" href="#Introduction">#</a>Introduction</h1>
<p>这一章会介绍关于扩展 LAN 的方法，如中继器（Repeaters）和网桥（Bridges），也会介绍在网桥存在循环时解决死循环的<code>生成树算法(Spannning tree algorithms)</code>。最后会讨论交换机和网桥之间的关系。</p>
<h1 id="Distance_Limitation_And_LAN_Design"><a class="header-anchor" href="#Distance_Limitation_And_LAN_Design">#</a>Distance Limitation And LAN Design</h1>
<p>距离限制是 LAN 计算的核心，工程师们需要从最大延迟，信道容量和传输距离间做权衡。因为 LAN 中的硬件设备的发送功率是固定的，所以如果两个设备之间的电缆长度增加，其中的信号强度就会减弱，导致错误的发生。</p>
<h1 id="Fiber_Modem_Extensions"><a class="header-anchor" href="#Fiber_Modem_Extensions">#</a>Fiber Modem Extensions</h1>
<p>解决 LAN 距离的方法通常不是增加信号的强度也不是增加电缆，而是增加额外的硬件设备来转播信号。</p>
<p>最简单的 LAN 扩展方法是通过一根光纤和一堆光纤调制解调器，如下图所示：</p>
<p><img src="/ch_17_repeaters,_bridges,_and_switches/2020-01-03-08-27-17.png" alt="光纤调制解调器扩展"></p>
<p>一个光纤调制解调器与计算机设备连接，另一个光纤调制解调器与通向以太网的交换机或集线器连接，两个光纤调制解调器用光纤连接。这样计算机设备就能与以太网进行连接。</p>
<h1 id="Repeaters"><a class="header-anchor" href="#Repeaters">#</a>Repeaters</h1>
<p>中继器（Repeaters）是一个用来传播 LAN 信号的模拟设备，中继器并不理解包和 Bit 数据，它只是将接受到的信号放大再传播出去。</p>
<p>一个中继器的典型应用就是使用遥控器控制其他房间的设备，将中继器放置在另一个房间，在遥控器所在房间，将 Sensor 通过线缆与中继器相连。当本房间的 Sensor 搜到信号后，信号后传输给中继器，中继器放大后传播出去，另一个房间的设备就会收到，如下图所示：</p>
<p><img src="/ch_17_repeaters,_bridges,_and_switches/2020-01-03-08-35-01.png" alt=""></p>
<h1 id="Bridges_And_Bridging"><a class="header-anchor" href="#Bridges_And_Bridging">#</a>Bridges And Bridging</h1>
<p>网桥（Bridges）是连接两组 LAN 设备（如两个集线器）并且在它们之间传输包的方法。网桥是以混杂模式监听每组 LAN 设备，即数据发送给其下的任意一个设备，该数据都会被网桥检测到。因此，被网桥连接的两组设备表现如同是一组设备，即一组中的设备可以发送数据给另一组设备，且当一个设备广播时，两组设备中的所有设备都能接受到。而在网桥下的设备是无法区分自己是在一个单一的一组设备下（如只是在集线器下）还是在网桥下。</p>
<ul>
<li>这里将书中描述的 Segment 翻译为一组设备，如一个集线器下的设备。</li>
</ul>
<p>网桥连接的示意图如下：</p>
<p><img src="/ch_17_repeaters,_bridges,_and_switches/2020-01-03-09-14-18.png" alt=""></p>
<h1 id="Learning_Bridges_And_Frame_Filtering"><a class="header-anchor" href="#Learning_Bridges_And_Frame_Filtering">#</a>Learning Bridges And Frame Filtering</h1>
<p>虽然网桥是以混杂模式监听，且可以让两组设备表现的如同在同一组，但是网桥并不会盲目的将数据从一组设备传递给另一组。网桥监听到数据后会针对包的目标 MAC 地址过滤数据，仅将数据发送给需要的一组设备。当让，在广播或者多播模式下，网桥直接将数据发送给两个设备的，以保证广播或者多播的正常运行。</p>
<p>大多数网桥被称为自适应网桥（Adaptive/Learning Bridges），因为他们可以自动识别出每个设备是处于哪个分组下。当一个数据包经过网桥时，网桥会读取源地址，然后判断两组设备列表中是否有该发送设备，如果没有，则将发送设备放在符合的设备列表下。同时也会读取目标地址，决定数据需要发送给哪部分设备，如果目标地址在两组设备列表中都不存在，则两组设备都会收到网桥的转发的数据。</p>
<p>下表是发送网桥发送数据的例子。在第一行即网桥启动时，两组数据的列表都是空的。第二行即数据从 A 设备发送给 B 设备，此时先检测出将发送端 A 是在 Segment1 中，但此时 B 不在任何列表中，所以数据会发送给两个部分。第三行即数据从 B 设备发送给 A 设备，先检测出发送端 B 设备是再 Segment1 中，而 A 也在 Segment1 种，所以数据只要在 Segment1 中传输即可。同理可以分析其他的发送数据。</p>
<p><img src="/ch_17_repeaters,_bridges,_and_switches/2020-01-03-09-30-16.png" alt="网桥数据发送"></p>
<h1 id="Why_Bridging_Works_Well"><a class="header-anchor" href="#Why_Bridging_Works_Well">#</a>Why Bridging Works Well</h1>
<p>当网桥知道其下的所有设备处于哪个部分后，数据在网桥之间的传输效率要大于数据在真正的单一分组中的传输。</p>
<p>以上节中的示意图为例，当网桥知道所有的设备处于哪个部分后，如果数据从 A 发送给 B，那么数据只要在 Segment1 中传输，同理如果数据从 X 发送给 Y，数据只要在 Segment2 中传输。因此，这两个传输行为是可以同时进行的，因为它们都只是发生在各自的部分中。而如果所有设备都是在一个真正的单一分组下，即 A，B，X，Y 是共享一个媒介传输，两个传输行为也就不可能同时发生。</p>
<p>因此可以将设备分组后，用网桥连接来增加数据传输的效率。</p>
<h1 id="Distributed_Spanning_Tree"><a class="header-anchor" href="#Distributed_Spanning_Tree">#</a>Distributed Spanning Tree</h1>
<p>如果一系列设备如下图所示连接（每个 HUb 下有多个设备，图中未展现）：</p>
<p><img src="/ch_17_repeaters,_bridges,_and_switches/2020-01-03-09-37-20.png" alt=""></p>
<p>可以看到图中的设备形成了一个循环，在这种情况下广播的数据会发生死循环。因为网桥收到广播数据后会直接向前传递，而在网桥形成循环后，每个网桥的直接向前传递就会导致信息始终在循环中传输。</p>
<p>为了解决这个问题，电子设备协会（Digital Equipment Corporation）在 1985 年为以太网设计了一个称为<code>生成树协议（Spannning Tree Protocol,STP）</code>的方法。STP 方法是通过算法从一系列网桥 STP 计算出一个<code>分布生成树（Distributed Spanning Tree）</code>。协议规定如果将包的广播地址设为<code>01:80:C2:00:00:00</code>即表示使用 STP 方法。STP 方法的步骤如下：</p>
<ol>
<li>
<p>先找到一个网桥作为根。</p>
<p>每个网桥都有一个 ID 地址，算法将 ID 最小的网桥作为根。</p>
<p>每个网桥的 ID 地址都由两部分组成，第一部分是 16bit 长的可配置优先级数字，第二部分是 48bits 长的 MAC 地址。当比较 ID 地址时，会首先判断第一部分，在第一部分相同的情况下判断第二部分。因为第一部分是可配置的，所以管理员是可以指定某一个网桥作为根的。</p>
</li>
<li>
<p>最短路径计算</p>
<p>每个网桥都计算自己与根网桥的最短路径。</p>
</li>
<li>
<p>传递数据</p>
<p>网桥之间的数据传递，只能由最短路径传输。</p>
</li>
</ol>
<p>在上图展示的循环中，如果 Hub1 广播数据，那么 Hub4 收到数据的通路就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mi>u</mi><mi>b</mi><mn>1</mn><mo>−</mo><mo>&gt;</mo><mi>H</mi><mi>u</mi><mi>b</mi><mn>4</mn></mrow><annotation encoding="application/x-tex">Hub1-&gt;Hub4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal">u</span><span class="mord mathnormal">b</span><span class="mord">1</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal">u</span><span class="mord mathnormal">b</span><span class="mord">4</span></span></span></span>，而更长的路径，如<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mi>u</mi><mi>b</mi><mn>1</mn><mo>−</mo><mo>&gt;</mo><mi>H</mi><mi>u</mi><mi>b</mi><mn>2</mn><mo>−</mo><mo>&gt;</mo><mi>H</mi><mi>u</mi><mi>b</mi><mn>3</mn><mo>−</mo><mo>&gt;</mo><mi>H</mi><mi>u</mi><mi>b</mi><mn>4</mn></mrow><annotation encoding="application/x-tex">Hub1-&gt;Hub2-&gt;Hub3-&gt;Hub4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal">u</span><span class="mord mathnormal">b</span><span class="mord">1</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal">u</span><span class="mord mathnormal">b</span><span class="mord">2</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal">u</span><span class="mord mathnormal">b</span><span class="mord">3</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal">u</span><span class="mord mathnormal">b</span><span class="mord">4</span></span></span></span>就会被禁止，因此更长的循环路径也同样会被禁止。</p>
<h1 id="Switching_And_Layer_2_switchers"><a class="header-anchor" href="#Switching_And_Layer_2_switchers">#</a>Switching And Layer 2 switchers</h1>
<p><code>桥接（bridging）</code>的概念可以帮助理解现代以太网的基础：<code>交换（switching）</code>。一个以太网交换机（Ethernet switch）有时也被称为二层交换机（Layer-2 switch）。交换机如同集线器一样，有多个接口，每个接口都与一个计算机相连。交换机和集线器的不同在于，集线器如模拟设备一样，是将电脑传输的信号传递出去，而交换机是数字设备，传递的是电脑的数据包。可以将集线器想象成一个共享媒介，而把交换器想象成一个由网桥连接的网络，其中每个部分都只有一台电脑。</p>
<p>交换机可以想象成如下图的结构，可以看到交换机的左侧是三个网桥，每个网桥连接两个设备：</p>
<p><img src="/ch_17_repeaters,_bridges,_and_switches/2020-01-03-10-22-38.png" alt=""></p>
<p>但上图只是一个概念图，实际中的交换机中并没有网桥，而是每个端口都于一个<code>智能接口（Intelligent Interface）</code>相连，然后有个中央光纤将所有的接口连接在一起，而且这光纤支持两两配对的接口间的同时传输（如之前提到的网桥连接的两部分间的设备可同时传输一样）。</p>
<p>每个智能接口都有处理器和内存，因此可以判断需要传递的路线以及在目标端口繁忙时缓存数据，如电脑 1 和电脑 2 同时要向电脑 3 传输数据，则电脑 1 或电脑 2 中的一台会先将要传输的数据缓存起来。实际的交换机结构如下：</p>
<p><img src="/ch_17_repeaters,_bridges,_and_switches/2020-01-03-10-27-51.png" alt=""></p>
<p>交换机相对于集线器最大的优点在于并行。集线器在同一时间只能支持一个传输，而交换机可以同时进行多个独立的传输（这里的独立指不会有多个来自于不同地址的数据要发送给同一端口）。因此如果一个交换机有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>个端口，最多可以有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">N/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord">/2</span></span></span></span>个传输同时进行。</p>
<h1 id="VLAN_Switchers"><a class="header-anchor" href="#VLAN_Switchers">#</a>VLAN Switchers</h1>
<p>当一个交换机被扩展了虚拟功能，即称为虚拟局域网交换机（Virtual Local Area Network Switch,VLAN Switcher）。虚拟局域网交换机的功能就是让单一的交换机模拟成是多个独立的交换机，即管理者可以将一台交换机的其中某几个端口定义是在一个模拟局域网中，而另几个端口是在另外一个模拟局域网中，这样的话其中一个模拟局域网中的设备发送广播数据，另一个模拟局域网中的端口并不会接受到信息。</p>
<p>这种通过 VLAN 切分广播域的做法在公司环境下很关键，如一层楼只有一个交换机，但广播数据的发送并不希望整层楼都能收到。</p>
<h1 id="Multiple_Switchers_And_Shared_VLANs"><a class="header-anchor" href="#Multiple_Switchers_And_Shared_VLANs">#</a>Multiple Switchers And Shared VLANs</h1>
<p>交换机通常被部署在离计算机较近的地方，如每层楼都有一个交换机。在公司环境下有种情况是同一个部门可能处于不同的楼层，那么同一个部门的网络在不同的交换机下。在有多个交换机的情况下，上节中提到的 VLAN 会遇到问题。当只有一个交换机时，根据端口号分好 VLAN 后，数据的传输指定端口号就能判断出数据应该处于哪个 VLAN 中。但如果有两台交换机，两台交换机的同一端口，如端口 1，可能是在不同的 VLAN 下，因此光指定端口号是无法知道其到底在哪个 VLAN。</p>
<p>为了在多个交换机中使用 VLAN 技术，IEEE 扩展了以太网协议，记录在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>802.1</mn><mi>Q</mi></mrow><annotation encoding="application/x-tex">802.1Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord">802.1</span><span class="mord mathnormal">Q</span></span></span></span>中。该协议下，在以太网的数据包的头字段中，增加 16bit 长的数据表示 VLAN Tag，表示需要传递给 VLAN。在 802.1Q 协议下的以太网数据包如下图所示：</p>
<p><img src="/ch_17_repeaters,_bridges,_and_switches/2020-01-03-11-13-59.png" alt=""></p>
<p>即使是使用了多交换机的 VLAN，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>802.1</mn><mi>Q</mi></mrow><annotation encoding="application/x-tex">802.1Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord">802.1</span><span class="mord mathnormal">Q</span></span></span></span>协议下的以太网数据包仅在交换机之间传输，而在交换机与电脑间传输的包仍然是普通以太网数据包，因为只有交换机才能解析<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>802.1</mn><mi>Q</mi></mrow><annotation encoding="application/x-tex">802.1Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord">802.1</span><span class="mord mathnormal">Q</span></span></span></span>数据。使用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>802.1</mn><mi>Q</mi></mrow><annotation encoding="application/x-tex">802.1Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord">802.1</span><span class="mord mathnormal">Q</span></span></span></span>实现 VLAN 的交换机如下图所示</p>
<p><img src="/ch_17_repeaters,_bridges,_and_switches/2020-01-03-11-15-56.png" alt=""></p>
<p>以上图为例，如果图中的 A，B，D，E 共处于 VLAN 17 中，当 A 广播数据后，B 会直接收到数据，然后交换机 1 会将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>17</mn></mrow><annotation encoding="application/x-tex">17</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">17</span></span></span></span>作为 VLAN Tag 插入到数据包头中，然后传递给交换机 2，交换机 2 在收到数据后，取出其中的 VLAN tag，并将包传递给 D 和 E。</p>
<h1 id="The_importance_Of_Bridging"><a class="header-anchor" href="#The_importance_Of_Bridging">#</a>The importance Of Bridging</h1>
<p>虽然现在很少会有厂商生产单独的网桥，但是桥接的概念已经被整合入网络设备中。如无线网络的路由器就整合了提供桥接功能的以太网的交换器，通常将其中交换机的端口称为<code>本地端口（Local Port）</code>，将连接网络调制解调器的端口称为<code>因特网端口（Internet Port）</code>。当两个本地的电脑传输数据时，无线路由器并不会将数据发送给网络服务商，而是直接将数据在本地进行传输（类似于桥接的分组功能）。</p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《Computer Networks and Internets》 笔记汇总</title>
    <url>/computer_networks_and_internets/</url>
    <content><![CDATA[<h1 id="Introduction_And_Internet_Applications"><a class="header-anchor" href="#Introduction_And_Internet_Applications">#</a>Introduction And Internet Applications</h1>
<p><a href="/ch_01_introduction_and_overview">Ch 01 Introduction And Overview</a></p>
<h1 id="Data_Communication_Basics"><a class="header-anchor" href="#Data_Communication_Basics">#</a>Data Communication Basics</h1>
<p><a href="/ch_05_overview_of_data_communications">Ch 05 Overview Of Data Communications</a></p>
<p><a href="/ch_06_information_sources_and_signals">Ch 06 Information Sources And Signals</a></p>
<p><a href="/ch_07_transmission_media">Ch 07 Transmission Media</a></p>
<p><a href="/ch_08_reliability_and_channel_coding">Ch 08 Reliability And Channel Coding</a></p>
<p><a href="/ch_10_modulation_and_modems">Ch 10 Modulation And Modems</a></p>
<p><a href="/ch_11_multiplexing_and_demultiplexing">Ch 11 Multiplexing And Demultiplexing (Channelization)</a></p>
<h1 id="Packet_Switching_And_Network_Technologies"><a class="header-anchor" href="#Packet_Switching_And_Network_Technologies">#</a>Packet Switching And Network Technologies</h1>
<p><a href="/ch_13_local_area_networks_packets,_frames,_and_topologies">Ch 13 Local Area Networks Packets, Frames, And Topologies</a></p>
<p><a href="/ch_14_the_ieee_mac_sublayer">Ch 14 The IEEE MAC Sublayer</a></p>
<p><a href="/ch_16_wireless_networking_technologies">Ch 16 Wireless Networking Technologies</a></p>
<p><a href="/ch_17_repeaters,_bridges,_and_switches">Ch 17 Repeaters, Bridges, And Switches</a></p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>耦合与内聚</title>
    <url>/coupling/</url>
    <content><![CDATA[<h1 id="耦合与内聚"><a class="header-anchor" href="#耦合与内聚">#</a>耦合与内聚</h1>
<p>当一个类与另一个类存在关系时，称这两个类存在<code>依赖(Dependency )</code>或`耦合(Coupling)``。如果两个类相互依赖，则修改其中的一个就可能会影响到另一个的执行逻辑。</p>
<p>当一个类的内部组件（如方法、属性等）彼此紧密关联，并共同完成某个功能时，称这个类具有<code>内聚(Cohesion)</code>。如果一个类内部的组件高度聚焦在明确的任务上，那么这个类更易于维护和理解。</p>
<p>在最理想的情况下，代码应该是低耦合高内聚的：</p>
<ul>
<li>耦合性表示的是对象间的交互（引用关系）。低耦合的表现是尽可能少的双向引用，循环引用。</li>
<li>内聚则是同类型代码是否在一起，高内聚的表现为模块化。</li>
</ul>
<p><img src="/coupling/image-20230611124256681.png" alt="耦合和内聚"></p>
<ul>
<li>Code Complete 中关于耦合的讨论：<a href="/ch_05_design_in_construction/#%E4%BF%9D%E6%8C%81%E6%9D%BE%E8%80%A6%E5%90%88">保持松耦合</a></li>
</ul>
]]></content>
      <tags>
        <tag>编码规范</tag>
      </tags>
  </entry>
  <entry>
    <title>.Net Tools 创建指南</title>
    <url>/create_.net_tools/</url>
    <content><![CDATA[<h1 id="创建一个_Net_Tool"><a class="header-anchor" href="#创建一个_Net_Tool">#</a>创建一个 .Net Tool</h1>
<div class="note primary simple"><p>示例可见 <a href="https://github.com/xuejiaW/.Net-Samples/tree/main/CowSay">CowSay</a></p>
</div>
<div class="note info simple"><p>.Net Tool 需要使用 .net 6.0 及以上的版本</p>
</div>
<h2 id="创建_Net_Tool_项目"><a class="header-anchor" href="#创建_Net_Tool_项目">#</a>创建 .Net Tool 项目</h2>
<p>使用 <code>dotnet new</code> 命令创建一个新的 .Net Tool：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">dotnet new console <span class="literal">-n</span> &lt;ToolName&gt; <span class="operator">-f</span> &lt;Framework&gt;</span><br></pre></td></tr></table></figure>
<p>如下例创建了一个名为 <code>Cowsay</code> 的 .Net Tool，使用的是 .Net 8.0 的版本：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">dotnet new console <span class="literal">-n</span> CowSay <span class="operator">-f</span> net8.<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>当执行上述命令后，会在当前目录下创建一个名为 <code>CowSay</code> 的文件夹，其中包含了一个名为 <code>Program.cs</code> 的文件，该文件中包含了一个 <code>Main</code> 方法，该方法是 .Net Tool 的入口方法。</p>
<p>以及包含有一个 <code>CowSay.csproj</code> 的文件，该文件是 .Net Tool 的项目文件。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Project</span> <span class="attr">Sdk</span>=<span class="string">&quot;Microsoft.NET.Sdk&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">OutputType</span>&gt;</span>Exe<span class="tag">&lt;/<span class="name">OutputType</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TargetFramework</span>&gt;</span>net8.0<span class="tag">&lt;/<span class="name">TargetFramework</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImplicitUsings</span>&gt;</span>enable<span class="tag">&lt;/<span class="name">ImplicitUsings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Nullable</span>&gt;</span>enable<span class="tag">&lt;/<span class="name">Nullable</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">Project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以看到其中约定的 <code>TargetFramework</code> 是 <code>8.0</code>。</p>
<h2 id="修改代码"><a class="header-anchor" href="#修改代码">#</a>修改代码</h2>
<p>将 <code>Program.cs</code> 中的代码修改为如下内容：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">CowSay</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (args.Length == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span>? versionString = Assembly.GetEntryAssembly()?</span><br><span class="line">               .GetCustomAttribute&lt;AssemblyInformationalVersionAttribute&gt;()?</span><br><span class="line">               .InformationalVersion;</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;Cow Say v<span class="subst">&#123;versionString&#125;</span>&quot;</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;-------------&quot;</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;\nUsage:&quot;</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;  Cow Say &lt;message&gt;&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ShowCow(<span class="built_in">string</span>.Join(<span class="string">&#x27; &#x27;</span>, args));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ShowCow</span>(<span class="params"><span class="built_in">string</span> message</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> bot = <span class="string">$&quot;\n        <span class="subst">&#123;message&#125;</span>&quot;</span>;</span><br><span class="line">        bot += <span class="string">@&quot;</span></span><br><span class="line"><span class="string">    __________________</span></span><br><span class="line"><span class="string">                         \</span></span><br><span class="line"><span class="string">                          \</span></span><br><span class="line"><span class="string">                             (oo)\_______</span></span><br><span class="line"><span class="string">                             (__)        )\/\</span></span><br><span class="line"><span class="string">                                 ||------||</span></span><br><span class="line"><span class="string">                                 ||      ||</span></span><br><span class="line"><span class="string">                            &quot;</span>;</span><br><span class="line">        Console.WriteLine(bot);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>Main</code> 方法中的代码是用来处理命令行参数的，如果没有参数，会打印一系列提示信息。如果有参数，则会将参数组合成一个 <code>string</code> 并作为输出的小牛的 ASCII 图案中的一部分内容。</p>
<h2 id="运行_Tool"><a class="header-anchor" href="#运行_Tool">#</a>运行 Tool</h2>
<p>此时在 <code>CowSay</code> 文件夹下执行 <code>dotnet run</code> 命令，会输出如下内容，因为此时并没有带上任何参数，所以会输出一系列提示信息：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">❯ dotnet run</span><br><span class="line">Cow Say v1.<span class="number">0.0</span>+d0f6e0d23ad19769312547a08ad5db8cf35fa97d</span><br><span class="line"><span class="literal">-------------</span></span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">  Cow Say &lt;message&gt;</span><br></pre></td></tr></table></figure>
<p>如果运行 <code>dotnet run Hello World</code> 命令，则会输出如下内容。因为此时带上了参数，所以程序会将参数赋予给小牛并输出：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">❯ dotnet run Hello World</span><br><span class="line"></span><br><span class="line">        Hello World</span><br><span class="line">    __________________</span><br><span class="line">                         \</span><br><span class="line">                          \</span><br><span class="line">                             (oo)\_______</span><br><span class="line">                             (__)        )\/\</span><br><span class="line">                                 ||<span class="literal">------</span>||</span><br><span class="line">                                 ||      ||</span><br></pre></td></tr></table></figure>
<h2 id="打包_Tool"><a class="header-anchor" href="#打包_Tool">#</a>打包 Tool</h2>
<p>在运行打包前，先修改 <code>Cowsay.csproj</code> 文件，在 <code>&lt;PropertyGroup&gt;</code> 标签中添加如下内容：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">PackAsTool</span>&gt;</span>true<span class="tag">&lt;/<span class="name">PackAsTool</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ToolCommandName</span>&gt;</span>cowsay<span class="tag">&lt;/<span class="name">ToolCommandName</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">PackageOutputPath</span>&gt;</span>./nupkg<span class="tag">&lt;/<span class="name">PackageOutputPath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Version</span>&gt;</span> 1.0.1 <span class="tag">&lt;/<span class="name">Version</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><code>&lt;PackAsTool&gt;</code> 标签是用来指定是否将项目打包为一个 .Net Tool</li>
<li><code>&lt;ToolCommandName&gt;</code> 标签是用来指定打包后的 .Net Tool 的名称，该名称会用于后续在 CLI 中调用</li>
<li><code>&lt;PackageOutputPath&gt;</code> 标签是用来指定打包后的 .Net Tool 的输出路径。</li>
<li><code>&lt;Version&gt;</code> 标签标识打包后的 .Net Tool 的版本</li>
</ul>
<p>此时在 <code>CowSay</code> 文件夹下执行 <code>pack</code> 命令进行打包：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">dotnet pack</span><br></pre></td></tr></table></figure>
<p>此时在 <code>CowSay</code> 文件夹下创建一个名为 <code>nupkg</code> 的文件夹，其中包含的就是可安装的 tool 文件：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">├───nupkg</span><br><span class="line">│       CowSay.<span class="number">1.0</span>.<span class="number">1</span>.nupkg</span><br></pre></td></tr></table></figure>
<h2 id="安装_Global_Tool"><a class="header-anchor" href="#安装_Global_Tool">#</a>安装 Global Tool</h2>
<p>当 <a href="/create_.net_tools/#%E6%89%93%E5%8C%85-tool">打包 Tool</a> 生成了一个可安装的 .Net Tool 后，就可以使用 <code>dotnet tool install</code> 命令来安装该 Tool：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">dotnet tool install <span class="literal">--global</span> <span class="literal">--add-source</span> &lt;sourcePath&gt; &lt;toolName&gt; <span class="literal">--version</span> &lt;version&gt;</span><br></pre></td></tr></table></figure>
<div class="note primary simple"><p>理论上 <code>--version</code> 不是必须的，但是在某些 .net 版本下，如 <code>.net 8.0.203</code> 中，不加上这个参数会出现错误，详见：<a href="https://github.com/dotnet/sdk/issues/40039">Issue</a></p>
</div>
<p>如下在安装后，即可直接运行 <code>coway</code> 命令：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">❯ dotnet tool install <span class="literal">--global</span> <span class="literal">--add-source</span> .\nupkg CowSay <span class="literal">--version</span> <span class="number">1.0</span>.<span class="number">1</span></span><br><span class="line">You can invoke the tool <span class="keyword">using</span> the following <span class="keyword">command</span>: cowsay</span><br><span class="line">Tool <span class="string">&#x27;cowsay&#x27;</span> (version <span class="string">&#x27;1.0.1&#x27;</span>) was successfully installed.</span><br><span class="line">❯ cowsay hello world</span><br><span class="line"></span><br><span class="line">        hello world</span><br><span class="line">    __________________</span><br><span class="line">                         \</span><br><span class="line">                          \</span><br><span class="line">                             (oo)\_______</span><br><span class="line">                             (__)        )\/\</span><br><span class="line">                                 ||<span class="literal">------</span>||</span><br><span class="line">                                 ||      ||</span><br></pre></td></tr></table></figure>
<p>后续如果想要删除该 tool，则可以运行 <code>uninstall</code> 命令：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">dotnet tool uninstall <span class="literal">-g</span> &lt;toolName&gt;</span><br></pre></td></tr></table></figure>
<h3 id="安装路径控制"><a class="header-anchor" href="#安装路径控制">#</a>安装路径控制</h3>
<p>在 Windows 下默认 Tool 安装的路径是：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">C:\users\<span class="variable">$env:username</span>\.dotnet\tools</span><br><span class="line">// C:\Users\<span class="variable">$env:username</span>\.dotnet\tools\cowsay.exe</span><br></pre></td></tr></table></figure>
<p>在安装时，可以加上 <code>--tool-path</code> 参数来指定安装路径：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">dotnet tool install <span class="literal">--tool-path</span> &lt;path&gt; <span class="literal">--add-source</span> &lt;sourcePath&gt; &lt;toolName&gt; <span class="literal">--version</span> &lt;version&gt;</span><br></pre></td></tr></table></figure>
<p>对于指定路径的 tool，当卸载时也需要加上 <code>--tool-path</code> 参数来指定卸载路径：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">dotnet tool uninstall <span class="literal">--tool-path</span> &lt;path&gt; &lt;toolName&gt;</span><br></pre></td></tr></table></figure>
<h2 id="更新_Tool"><a class="header-anchor" href="#更新_Tool">#</a>更新 Tool</h2>
<p>如果修改了 Tool 并重新进行了 <a href="/create_.net_tools/#%E6%89%93%E5%8C%85_Tool">打包 Tool</a> 操作，可以使用 <code>update</code> 进行 tool 的更新：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">dotnet tool update <span class="literal">--global</span> <span class="literal">--add-source</span> &lt;sourcePath&gt; &lt;toolName&gt;</span><br></pre></td></tr></table></figure>
<p>如我们将 <code>CowSay</code> 的版本更新为 <code>1.0.2</code> 后，并再次允许 <code>dotnet pack</code>，此时在 <code>.nuget</code> 目录下会生成一个新的 <code>nupkg</code> 文件夹，其中包含了新的 <code>CowSay</code> 的版本：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">├── nupkg</span><br><span class="line">│   ├── CowSay.1.0.1.nupkg</span><br><span class="line">│   └── CowSay.1.0.2.nupkg</span><br></pre></td></tr></table></figure>
<p>此时可运行 <code>dotnet tool update</code> 进行更新：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">dotnet tool update <span class="literal">--global</span> <span class="literal">--add-source</span> .\nupkg CowSay <span class="literal">--version</span> <span class="number">1.0</span>.<span class="number">2</span></span><br></pre></td></tr></table></figure>
<h1 id="Reference"><a class="header-anchor" href="#Reference">#</a>Reference</h1>
<p><a href="https://learn.microsoft.com/en-us/dotnet/core/tools/global-tools-how-to-create">Tutorial: Create a .NET tool - .NET CLI | Microsoft Learn</a></p>
<p><a href="https://www.youtube.com/watch?v=JNDgcBDZPkU&amp;ab_channel=NickChapsas">(4) How to create your own .NET CLI tools to make your life easier - YouTube</a></p>
]]></content>
      <tags>
        <tag>DotNet</tag>
      </tags>
  </entry>
  <entry>
    <title>.Net 工程创建 NUnit 单元测试指南</title>
    <url>/create_nunit_testing/</url>
    <content><![CDATA[<div class="note primary simple"><p>完整工程见 <a href="https://github.com/xuejiaW/.Net-Samples/tree/main/UnitTestingUsingNUnit">UnitTestingUsingNUnit</a></p>
</div>
<h1 id="创建被测试工程"><a class="header-anchor" href="#创建被测试工程">#</a>创建被测试工程</h1>
<p>为了创建单元测试工程，首先需要有一个需要被测试的工程。创建一个名为 <code>UnitTestingUsingNUnit</code> 的文件夹，进入文件夹后运行 new sln 创建一个解决方案：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">❯ dotnet new sln</span><br><span class="line">The template <span class="string">&quot;Solution File&quot;</span> was created successfully.</span><br></pre></td></tr></table></figure>
<p>然后创建一个 <code>PrimeService</code> 文件夹，进入其中并运行 new classlib 创建一个类库：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">❯ dotnet new classlib <span class="literal">-n</span> PrimeService</span><br><span class="line">The template <span class="string">&quot;Class Library&quot;</span> was created successfully.</span><br><span class="line"></span><br><span class="line">Processing post<span class="literal">-creation</span> actions...</span><br><span class="line">Restoring D:\Github\.Net<span class="literal">-Samples</span>\UnitTestingUsingNUnit\PrimeService\PrimeService.csproj:</span><br><span class="line">  Determining projects to restore...</span><br><span class="line">  Restored D:\Github\.Net<span class="literal">-Samples</span>\UnitTestingUsingNUnit\PrimeService\PrimeService.csproj (<span class="keyword">in</span> <span class="number">44</span> ms).</span><br><span class="line">Restore succeeded.</span><br></pre></td></tr></table></figure>
<p>默认创建的类库，会包含 <em>Class1.cs</em> 文件，我们可以将其重命名为 <code>PrimeService.cs</code> 的文件，此时的工程结构如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">├── PrimeService</span><br><span class="line">│   ├── PrimeService.cs</span><br><span class="line">│   ├── PrimeService.csproj</span><br><span class="line">└── UnitTestingUsingNUnit.sln</span><br></pre></td></tr></table></figure>
<p>使用 sln add 命令将类库加入解决方案中：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">dotnet sln add PrimeService/PrimeService.csproj</span><br></pre></td></tr></table></figure>
<p>在 <code>PrimeService.cs</code> 中增加一个 <code>IsPrime</code> 方法，用于判断一个数是否为质数，但此时我们不实现这个函数，并抛出一个 <code>NotImplementedException</code> 异常，保证后续的测试肯定失败：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">PrimeService</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PrimeService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">IsPrime</span>(<span class="params"><span class="built_in">int</span> candidate</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException(<span class="string">&quot;Please create a test first.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，我们已经创建了一个需要被测试的工程。后续，我们将创建一个测试工程，用于测试这个工程中的 <code>IsPrime</code> 方法。</p>
<h1 id="创建_NUnit_Testing"><a class="header-anchor" href="#创建_NUnit_Testing">#</a>创建 NUnit Testing</h1>
<p>为了给这个工程增加 NUnit 测试，我们可以在该目录下运行 <code>dotnet new nunit</code> 命令新建一个 NUnit 测试工程：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">dotnet new nunit <span class="literal">-n</span> PrimeService.Tests</span><br></pre></td></tr></table></figure>
<p>运行该命令后，会在命令运行目录下生成测试工程的文件夹，如本例中为 <code>PrimeService.Tests</code> 文件夹，文件夹包含有对应的 <code>.csproj</code> 文件和一个 <code>UnitTest1.cs</code> 文件，我们将其重命名为 <code>PrimeServiceIsPrimeShould.cs</code>，此时的工程结构为：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── PrimeService</span><br><span class="line">│   ├── PrimeService.cs</span><br><span class="line">│   ├── PrimeService.csproj</span><br><span class="line">├── PrimeService.Tests</span><br><span class="line">│   ├── PrimeService.Tests.csproj</span><br><span class="line">│   ├── PrimeServiceIsPrimeShould.cs</span><br><span class="line">└── UnitTestingUsingNUnit.sln</span><br></pre></td></tr></table></figure>
<p>此时再运行 <code>dotnet sln add</code> 命令，将新生成的测试工程的 <code>.csproj</code> 文件添加到主工程的解决方案中：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">❯ dotnet sln add .\PrimeService.Tests\PrimeService.Tests.csproj</span><br><span class="line">Project `PrimeService.Tests\PrimeService.Tests.csproj` added to the solution.</span><br></pre></td></tr></table></figure>
<p>因为 <em>测试工程</em> 需要引用 <em>被测试工程</em> 的代码，因此我们需要使用 add reference 命令为 <em>测试工程</em> 添加 <em>被测试工程</em> 的引用：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">dotnet add .\PrimeService.Tests\PrimeService.Tests.csproj reference .\PrimeService\PrimeService.csproj</span><br></pre></td></tr></table></figure>
<p>测试可以使用 <code>dotnet test</code> 命令运行测试，效果如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">❯ dotnet test</span><br><span class="line">  Determining projects to restore...</span><br><span class="line">  Restored D:\Github\.Net<span class="literal">-Samples</span>\UnitTestingUsingNUnit\PrimeService\PrimeService.csproj (<span class="keyword">in</span> <span class="number">41</span> ms).</span><br><span class="line">  Restored D:\Github\.Net<span class="literal">-Samples</span>\UnitTestingUsingNUnit\PrimeService.Tests\PrimeService.Tests.csproj (<span class="keyword">in</span> <span class="number">140</span> ms).</span><br><span class="line">  PrimeService -&gt; D:\Github\.Net<span class="literal">-Samples</span>\UnitTestingUsingNUnit\PrimeService\bin\Debug\net8.<span class="number">0</span>\PrimeService.dll</span><br><span class="line">  PrimeService.Tests -&gt; D:\Github\.Net<span class="literal">-Samples</span>\UnitTestingUsingNUnit\PrimeService.Tests\bin\Debug\net8.<span class="number">0</span>\PrimeService.Tests.dll</span><br><span class="line">Test run <span class="keyword">for</span> D:\Github\.Net<span class="literal">-Samples</span>\UnitTestingUsingNUnit\PrimeService.Tests\bin\Debug\net8.<span class="number">0</span>\PrimeService.Tests.dll (.NETCoreApp,Version=v8.<span class="number">0</span>)</span><br><span class="line">Microsoft (<span class="built_in">R</span>) Test Execution Command Line Tool Version <span class="number">17.9</span>.<span class="number">0</span> (x64)</span><br><span class="line">Copyright (c) Microsoft Corporation.  All rights reserved.</span><br><span class="line"></span><br><span class="line">Starting test execution, please wait...</span><br><span class="line">A total of <span class="number">1</span> test files matched the specified pattern.</span><br><span class="line"></span><br><span class="line">Passed!  - Failed:     <span class="number">0</span>, Passed:     <span class="number">1</span>, Skipped:     <span class="number">0</span>, Total:     <span class="number">1</span>, Duration: <span class="number">39</span> ms - PrimeService.Tests.dll (net8.<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h1 id="编写单元测试"><a class="header-anchor" href="#编写单元测试">#</a>编写单元测试</h1>
<p>在 <code>PrimeServiceIsPrimeShould.cs</code> 文件中，我们可以编写测试代码，测试 <code>PrimeService</code> 中的 <code>IsPrime</code> 方法：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">PrimeService.Tests</span>;</span><br><span class="line"></span><br><span class="line">[<span class="meta">TestFixture</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PrimeServiceIsPrimeShould</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> PrimeService? m_PrimService = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">SetUp</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetUp</span>()</span> &#123; m_PrimService = <span class="keyword">new</span> PrimeService(); &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Test</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">IsPrime_InputIs1_ReturnFalse</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> result = m_PrimService!.IsPrime(<span class="number">1</span>);</span><br><span class="line">        Assert.That(result, Is.False, <span class="string">&quot;1 should not be prime&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时运行 <code>dotnet test</code> 命令，会发现测试失败，输出如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">❯ dotnet test</span><br><span class="line">  Determining projects to restore...</span><br><span class="line">  All projects are up<span class="literal">-to-date</span> <span class="keyword">for</span> restore.</span><br><span class="line">  PrimeService -&gt; D:\Github\.Net<span class="literal">-Samples</span>\UnitTestingUsingNUnit\PrimeService\bin\Debug\net8.<span class="number">0</span>\PrimeService.dll</span><br><span class="line">  PrimeService.Tests -&gt; D:\Github\.Net<span class="literal">-Samples</span>\UnitTestingUsingNUnit\PrimeService.Tests\bin\Debug\net8.<span class="number">0</span>\PrimeService.Tests.dll</span><br><span class="line">Test run <span class="keyword">for</span> D:\Github\.Net<span class="literal">-Samples</span>\UnitTestingUsingNUnit\PrimeService.Tests\bin\Debug\net8.<span class="number">0</span>\PrimeService.Tests.dll (.NETCoreApp,Version=v8.<span class="number">0</span>)</span><br><span class="line">Microsoft (<span class="built_in">R</span>) Test Execution Command Line Tool Version <span class="number">17.9</span>.<span class="number">0</span> (x64)</span><br><span class="line">Copyright (c) Microsoft Corporation.  All rights reserved.</span><br><span class="line"></span><br><span class="line">Starting test execution, please wait...</span><br><span class="line">A total of <span class="number">1</span> test files matched the specified pattern.</span><br><span class="line">  Failed IsPrime_InputIs1_ReturnFalse [<span class="number">12</span> <span class="type">ms</span>]</span><br><span class="line">  Error Message:</span><br><span class="line">   System.NotImplementedException : Please create a test first.</span><br><span class="line">  Stack Trace:</span><br><span class="line">     at PrimeService.PrimeService.IsPrime(Int32 candidate) <span class="keyword">in</span> D:\Github\.Net<span class="literal">-Samples</span>\UnitTestingUsingNUnit\PrimeService\PrimeService.cs:line <span class="number">5</span></span><br><span class="line">   at PrimeService.Tests.PrimeServiceIsPrimeShould.IsPrime_InputIs1_ReturnFalse() <span class="keyword">in</span> D:\Github\.Net<span class="literal">-Samples</span>\UnitTestingUsingNUnit\PrimeService.Tests\PrimeServiceIsPrimeShould.cs:line <span class="number">14</span></span><br><span class="line">   at System.RuntimeMethodHandle.InvokeMethod(Object target, Void** arguments, Signature sig, Boolean isConstructor)</span><br><span class="line">   at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Failed!  - Failed:     <span class="number">1</span>, Passed:     <span class="number">0</span>, Skipped:     <span class="number">0</span>, Total:     <span class="number">1</span>, Duration: <span class="number">12</span> ms - PrimeService.Tests.dll (net8.<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>此时如果修改 <code>PrimeService</code> 中的 <code>IsPrime</code> 方法，使在 <code>indicate</code> 小于 2 时直接返回 <code>false</code>：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">IsPrime</span>(<span class="params"><span class="built_in">int</span> candidate</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (candidate &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException(<span class="string">&quot;Please create a test first.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时再次运行 <code>dotnet test</code> 命令，会发现测试通过：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">❯ dotnet test</span><br><span class="line">  Determining projects to restore...</span><br><span class="line">  All projects are up<span class="literal">-to-date</span> <span class="keyword">for</span> restore.</span><br><span class="line">  PrimeService -&gt; D:\Github\.Net<span class="literal">-Samples</span>\UnitTestingUsingNUnit\PrimeService\bin\Debug\net8.<span class="number">0</span>\PrimeService.dll</span><br><span class="line">  PrimeService.Tests -&gt; D:\Github\.Net<span class="literal">-Samples</span>\UnitTestingUsingNUnit\PrimeService.Tests\bin\Debug\net8.<span class="number">0</span>\PrimeService.Tests.dll</span><br><span class="line">Test run <span class="keyword">for</span> D:\Github\.Net<span class="literal">-Samples</span>\UnitTestingUsingNUnit\PrimeService.Tests\bin\Debug\net8.<span class="number">0</span>\PrimeService.Tests.dll (.NETCoreApp,Version=v8.<span class="number">0</span>)</span><br><span class="line">Microsoft (<span class="built_in">R</span>) Test Execution Command Line Tool Version <span class="number">17.9</span>.<span class="number">0</span> (x64)</span><br><span class="line">Copyright (c) Microsoft Corporation.  All rights reserved.</span><br><span class="line"></span><br><span class="line">Starting test execution, please wait...</span><br><span class="line">A total of <span class="number">1</span> test files matched the specified pattern.</span><br><span class="line"></span><br><span class="line">Passed!  - Failed:     <span class="number">0</span>, Passed:     <span class="number">1</span>, Skipped:     <span class="number">0</span>, Total:     <span class="number">1</span>, Duration: <span class="number">3</span> ms - PrimeService.Tests.dll (net8.<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h2 id="针对_internal_对象的测试"><a class="header-anchor" href="#针对_internal_对象的测试">#</a>针对 internal 对象的测试</h2>
<p>在对主工程进行测试时，常会遇到的问题时，需要对主工程中 <code>internal</code> 的对象进行测试，而测试工程默认无法访问主工程的 <code>internal</code> 对象。</p>
<p>为了解决这个问题，可以在主工程中创建出一个 <code>AssemblyInfo.cs</code> 文件，并在其中添加如下内容，即通过 <code>InternalsVisibleTo</code> 让主工程的 <code>internal</code> 对象可以对特定的 Assembly 暴露：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Runtime.CompilerServices;</span><br><span class="line"></span><br><span class="line">[<span class="meta">assembly: InternalsVisibleTo(<span class="string">&quot;PrimeService.Tests&quot;</span>)</span>]</span><br></pre></td></tr></table></figure>
<div class="note primary simple"><p>上述代码并不要求必须定义在 <code>AssemblyInfo.cs</code> 文件中，在任意的 <code>.cs</code> 脚本中都可以。</p>
</div>
<p>假设 <code>PrimeService</code> 类中有一个 <code>IsPrimeImplementation</code> 函数，其定义如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">internal</span> <span class="built_in">bool</span> <span class="title">IsPrimeImpl</span>(<span class="params"><span class="built_in">int</span> candidate</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">2</span>; i &lt; candidate; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (candidate % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在加入了 <code>AssemblyInfo</code> 后，就可以在测试工程中对 <code>IsPrimeImpl</code> 进行测试：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Test</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">IsPrimeImpl_Is4_ReturnFalse</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> result = m_PrimService!.IsPrimeImpl(<span class="number">4</span>);</span><br><span class="line">    Assert.That(result, Is.False, <span class="string">&quot;4 should not be prime&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Reference"><a class="header-anchor" href="#Reference">#</a>Reference</h1>
<p><a href="https://learn.microsoft.com/en-us/dotnet/core/testing/unit-testing-with-nunit">Unit testing C# with NUnit and .NET Core - .NET | Microsoft Learn</a></p>
<p><a href="https://learn.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.internalsvisibletoattribute?view=net-8.0">InternalsVisibleToAttribute</a></p>
]]></content>
      <tags>
        <tag>DotNet</tag>
        <tag>UnitTesting/NUnit</tag>
      </tags>
  </entry>
  <entry>
    <title>Custom SRP</title>
    <url>/custom_srp/</url>
    <content><![CDATA[<p>Unity Catlike 中 <a href="%5Bunity_custom_srp_tutorials_(catlikecoding.com)%5D(https://catlikecoding.com/unity/tutorials/custom-srp/)">Custom SRP</a> 的教程学习笔记汇总，该笔记并非完全的对原教程的翻译，在学习过程中的发现的额外资料以及对原教程中未详细说明的部分都会进行相应的补充。</p>
<ul>
<li><a href="/custom_render_pipeline">Custom Render Pipeline</a>：使用自定义的渲染管线在 Editor 和 Game 界面中绘制一系列 <code>Unlit/Color</code> 的物体以及 Skybox。</li>
<li><a href="/draw_calls">Draw Calls</a>：渲染自定义的 <code>Unlit</code> 的材质渲染一系列小球，讨论了不同的节省 Draw Calls 的技术，以及讨论了不同的实现透明度的办法</li>
<li>Directional Lights：制作一系列支持方向光的 Lit Shader</li>
</ul>
<h1 id="Reference"><a class="header-anchor" href="#Reference">#</a>Reference</h1>
<p><a href="https://catlikecoding.com/unity/tutorials/custom-srp/">Unity Custom SRP Tutorials (catlikecoding.com)</a></p>
]]></content>
      <tags>
        <tag>Unity</tag>
        <tag>Catlike</tag>
      </tags>
  </entry>
  <entry>
    <title>《Unix 编程艺术》 第十一章 接口</title>
    <url>/di_11_zhang_jie_kou%EF%BC%9Aunix_huan_jing_xia_de_yong_hu_jie_kou_she_ji_mo_shi/</url>
    <content><![CDATA[<p>在 Unix 接口设计的传统中，会反复涉足两个主题：</p>
<ol>
<li>与其他程序通信方式的前瞻性设计</li>
<li><a href="/di_1_zhang_zhe_xue/#%E9%80%9A%E4%BF%97%E5%8E%9F%E5%88%99%EF%BC%9A%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1%E9%81%BF%E5%85%8D%E6%A0%87%E6%96%B0%E7%AB%8B%E5%BC%82">通俗原则：接口设计避免标新立异</a>，也可称为最小立异原则</li>
</ol>
<h1 id="11_3_接口设计评估"><a class="header-anchor" href="#11_3_接口设计评估">#</a>11.3 接口设计评估</h1>
<div class="note info simple"><p>这里的接口，指的并非是代码的 <code>interface</code> 而是 UI</p>
</div>
<p>Unix 使用五种度量标准对接口风格进行分类：</p>
<ul>
<li>简洁：一个事务处理需要的动作时间及复杂度有较低的上限，可以用点击键量，鼠标手势量和需要多少秒注意力来衡量</li>
<li>表现力：接口具有表现力是指接口可以触发相当广泛的行为。最具表现力的接口可以启动程序设计者没有预见的行为组合，并仍然给予用户有用和一致的结果。</li>
<li>易用：接口的易用性同要求用户记忆的东西成反比</li>
<li>透明：接口透明度时用户在使用接口时，几乎没有什么问题、数据或程序的相关状态需要记忆</li>
<li>脚本化能力：指接口能够容易地为其它程序所使用，可脚本化的程序通常被其它程序作为组件使用，从而减少了定制代码的昂贵需求并使得重复任务的自动化相对容易。</li>
</ul>
<h1 id="11_4_CLI_和可视接口之间的权衡"><a class="header-anchor" href="#11_4_CLI_和可视接口之间的权衡">#</a>11.4 CLI 和可视接口之间的权衡</h1>
<blockquote>
<p>商业世界通常一窝蜂地支持初学者模式，因为</p>
<ul>
<li>购买决定基于冲动</li>
<li>仅仅有个傻愣愣的 GUI，用户支持工作得以降到最少。<br>
我发现许多非 Unix 系统常常令人沮丧，因为，比如，它们不提供对成百上千的文件进行某种处理的方法;想写一个脚本，又不支持。实质的问题是他们已经假定所有的用户总是入门级的，然后非难 Unix，因为 Unix 并不迎合这种模型<br>
—— Mike Lesk</li>
</ul>
</blockquote>
<h1 id="11_5_透明、表现力和可配置"><a class="header-anchor" href="#11_5_透明、表现力和可配置">#</a>11.5 透明、表现力和可配置</h1>
<p>Unix 程序员默认地使得接口富有表现力和透明，并且更愿意牺牲易用性换取这些品质。</p>
<ul>
<li>这种态度常常被描述成，接口是“程序员写给程序员的”。但这过度简化了事情的某一重要方面。</li>
<li>当 Unix 程序员倾向可配置能力和表现力而不是易用性时，并不是想当然地认为他的月标受众仅仅由其他程序员构成，他们深入骨髓的本能反应是，如果不了解终端用户的意图，最好不要迁就或者放马后炮。</li>
</ul>
<p>Unix 开发者对于不完全地支持是难以容忍地。也许 Windows 开发者会说“我们不需要支持标准地所有特征：多数用户不会在意，而且对他们来说太复杂了”，而一个 Unix 开发者可能会说“我们并不知道是不是有人永远都不会需要这种功能或者选项，所以我们必须支持它。”</p>
<p>当 Unix 程序员和其他程序员一起工作时，这些态度会导致冲突，因为其他程序员可能会把这种设计认为是一种冒失的主观意愿，将用户置于对他们而言含混、无意义、其至是吓人的技术细节的负担之中。Mac 或 Windows 的程序员害怕只是因为少数人的高级需求而吓跑大多数用户。</p>
<p>相反，Unix 程序员更愿意认为对表现力的忽视是一种逃避，或者甚至是一种对未来用户的背叛，这些未来用户对于他们自己的需求实际上会比现在的实现者还要清楚。具有讽刺意味的是，尽管 Unix 的这种态度常常被视作是程序员的一种傲慢，但它实质上是谦逊的另一种形式一-往往伴随着好多年的战争创伤而获得。</p>
<h1 id="11_6_Unix_接口设计模式"><a class="header-anchor" href="#11_6_Unix_接口设计模式">#</a>11.6 Unix 接口设计模式</h1>
<h2 id="11_6_1_过滤器模式"><a class="header-anchor" href="#11_6_1_过滤器模式">#</a>11.6.1 过滤器模式</h2>
<p>过滤器程序接受标准输入的数据，转换成某种格式后，再将结果发送到标准输出端。</p>
<p>在定义过滤器时，最好在心中牢记一些附带的原则：</p>
<ol>
<li>
<p>牢记 Postel 原则:宽进严出。也就是说，尽可能自由宽松地接受输入格式，并输出结构良好的严谨输出格式。</p>
<ul>
<li>前者的做法减少了过滤器在面对非预期输入时出错的可能性，以及在某种情形下(或是在某一工具链中间)崩溃的可能性。</li>
<li>后者提高了过滤器终有一天能够作为其它程序有用输入的可能性。</li>
</ul>
</li>
<li>
<p>在过滤时，不需要的信息也决不丢弃：这也提升了过滤器将来能够成为其它程序有用输入的可能。丢弃的信息，在管线后面就再也不能使用了</p>
</li>
<li>
<p>在过滤时，绝不增加无用数据：避免增加不必要的信息，避免以可能让管线下游程序难以解析的格式输出。</p>
<ul>
<li>任何这样的附加物都应该是可选、并由开关控制的。如果程序需要输出日期的话，良好的实践是增加一个开关以强制转换成 ISO8601 标准的 YYYY-MM-DD 和 hh:mm:ss 一或者，更好是将标准格式作为默认的选项使用。</li>
</ul>
</li>
</ol>
<h2 id="11_6_2_Cantrip_模式"><a class="header-anchor" href="#11_6_2_Cantrip_模式">#</a>11.6.2 Cantrip 模式</h2>
<p>cantrip 接口设计模式是其中最简单的。没有输入，没有输出，只被调用一次，产生退出状态数值。一个 cantrip 程序的行为只能由启动条件来控制。没有任何程序会比这种方式更具备脚本能力。</p>
<p>Unix 设计者学会了当 cantrip 模式足以应付需要时，绝不编写更具交互性的程序。</p>
<p>简单的控制台清屏实用程序 clear ，可能是最纯正的 cantrip 模式;</p>
<h2 id="11_6_3_源模式"><a class="header-anchor" href="#11_6_3_源模式">#</a>11.6.3 源模式</h2>
<p>“源”是一种类似过滤器的程序，不需要输入;它的输出只能在启动条件中控制。可以作为例证的程序是 ls。</p>
<h2 id="11_6_7_Roguelike_模式"><a class="header-anchor" href="#11_6_7_Roguelike_模式">#</a>11.6.7 Roguelike 模式</h2>
<p>Roguelike 程序是设计来运行在系统控制台、X 终端模拟器或视频显示终端上的游戏，使用全屏幕、支持可视界面风格，但使用字符阵列显示，而非图形和鼠标界面。</p>
<p>Vi 和 Emacs 即为遵循这种模式的程序。</p>
<h1 id="11_9_沉默是金"><a class="header-anchor" href="#11_9_沉默是金">#</a>11.9 沉默是金</h1>
<p>长时间的操作要提供进度条。这是个好传统一一帮助用户有效地分时利用他的大脑暗示在等待完成的过程中可以离开去阅读邮件或是干点儿别的。</p>
<p>不要杂乱地让 GUI 界面弹出确认消息除非必要的警示，而且进一步，父窗口最小化时应隐藏这些信息，又如果焦点不在父窗口时，应避免这些信息。<strong>界面设计师的工作是方便用户，而不是在用户面前碍眼</strong>。</p>
<p>通常，老是告诉用户他们已经知道的事情是非常糟糕的风格(“程序<foo>正在启动··.”，或是“程序<foo>正在退出”就是两个经典违例)。</p>
<ul>
<li>接口设计作为整体应该遵从最小立异原则，但是信息内容应该符合最大惊奇原则。</li>
<li>这个原则对于确认提示有着更强的力量。不断询问的答案几乎都为“是”的请求确认会造成用户根本不假思索就点击“是”，这个习惯会带来非常不幸的结果。程序应该只在有足够理由怀疑答案可能是“不不不!”的时候请求确认。并非意外却要求确认是糟糕设计的显著标志。任何确认提示本质上也许就是接口实际上需要一个撤销命令的标志</li>
</ul>
<p>如果为了调试,需要喋喋不休的进展消息，添加默认情况下禁用的高详细度(verbosity)选项。在发布产品时，尽可能多地将需要显示的正常消息转移到启用高详细度选项开关下。</p>
]]></content>
      <tags>
        <tag>系统设计</tag>
        <tag>编码规范</tag>
      </tags>
  </entry>
  <entry>
    <title>《Unix 编程艺术》 第十章 配置</title>
    <url>/di_10_zhang_pei_zhi%EF%BC%9Amai_chu_zheng_que_de_di_yi_bu/</url>
    <content><![CDATA[<h1 id="10_1_什么应是可配置的"><a class="header-anchor" href="#10_1_什么应是可配置的">#</a>10.1 什么应是可配置的</h1>
<p>对于问题：什么应是可配置的？<br>
无畏的 Unix 回答是“一切”。Unix 程序员只要可能，就建立机制而把策略决定权交给用户。这种方式产生的程序往往功能强大，专家用户用起来会非常顺手。但它所产生的接口往往选项过多，并且配置文件像杂草一样疯长，从而彻底打击了新手和一般用户。</p>
<p>Unix 并不打算修改这种为同行和最老练用户设计的倾向。所以，也许把问题反过来，问问“什么不应该可配置”更加有用。Unix 实践的确在这方面提供了一些指导。</p>
<ol>
<li>对于能够可靠的进行自动检测的东西，就不要提供配置开关。
<ul>
<li>应当尽量用自动检测来减少配置开关的数量，或者在运行时不断尝试直到成功。如果觉得这个方法不够优雅或太昂贵，问问自己是不是掉进了过早优化的陷阱。</li>
<li>一个很好的经验法则是：提高适应能力，除非这样做会产生超过 0.7 秒的延迟。0.7 秒是一个魔数，因为，正如 Jef Raskin 设计 Canon Cat 计算机时的发现，人们几乎觉察不到少于 0.7 秒的启动延时;人们还没有来得及转移注意力，它就消失了。</li>
</ul>
</li>
<li>用户不应该看到优化开关。让程序经济运行是设计者的任务，不是用户的任务。
<ul>
<li>与提高界面复杂度成本相比，让用户从优化开关来获取的那点儿性能收益，换来界面复杂度的提升，往往得不偿失。</li>
</ul>
</li>
<li>能简单利用其它程序来完成的任务，就不要增加本程序的复杂度。</li>
</ol>
<p>无论何时想增加配置选项，请考虑以下这些较普遍的问题：</p>
<ul>
<li>能省掉这个功能吗?为什么在加厚手册之外还要加重用户负担?</li>
<li>能否用某种无伤大雅的方式改变程序的常规行为从而无需这个选项?</li>
<li>这个选项是否花哨没用?是否应该少考虑用户界面的可配置性而多考虑正确性?</li>
<li>这个选项附加的行为是否应该用一个独立的程序来代替?</li>
</ul>
<div class="note info simple"><p>为函数增加形参时，也可以自问上述问题</p>
</div>
<p>增加不必要的选项会产生诸多不良后果。其中最不易察觉但最严重的后果是对测试覆盖率的影响。</p>
<blockquote>
<p>除非做得非常仔细，否则增加一个开/关配置选项就会使测试量加倍。既然在实践中从来没有人完成双倍测试量，那么实际影响就是减少了特定配置获得的测试量。增加十个选项会产生 1024 倍测试量，所以不要多久就要讨论可靠性问题了。<br>
—— Steve Johnson</p>
</blockquote>
<h1 id="10_5_命令行选项"><a class="header-anchor" href="#10_5_命令行选项">#</a>10.5 命令行选项</h1>
<p>原始的 Unix 传统中，对于命令行选项偏爱小写字符而不是大写字符。</p>
<h1 id="10_7_论打破规则"><a class="header-anchor" href="#10_7_论打破规则">#</a>10.7 论打破规则</h1>
<p>约定都不是绝对的，但是违反这些约定会增加用户和未来开发者的磨合成本。</p>
<ul>
<li>如果必须打破规则，就放手去做一一但在做之前要确信自己完全知道为什么要这样做。</li>
<li>如果确实要打破规则，必须确保常规方法进行的尝试都非常明显地失败了，同时保证遵循 <a href="/di_1_zhang_zhe_xue/#%E8%A1%A5%E6%95%91%E5%8E%9F%E5%88%99%EF%BC%9A%E5%87%BA%E7%8E%B0%E5%BC%82%E5%B8%B8%E6%97%B6%EF%BC%8C%E9%A9%AC%E4%B8%8A%E9%80%80%E5%87%BA%E5%B9%B6%E7%BB%99%E5%87%BA%E8%B6%B3%E9%87%8F%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF">补救原则</a> 给出了正确的错误反馈</li>
</ul>
]]></content>
      <tags>
        <tag>系统设计</tag>
        <tag>编码规范</tag>
      </tags>
  </entry>
  <entry>
    <title>《Unix 编程艺术》 第十二章 优化</title>
    <url>/di_12_zhang_you_hua/</url>
    <content><![CDATA[<p>这将是很短的一章，因为关于性能优化，Unix 的经验告诉我们最主要的就是如何知道何时不去优化。其次，最有效的优化往往是优化之外的其它事情，如：清晰干净的设计。</p>
<h1 id="12_1_什么都别做，就站在那儿"><a class="header-anchor" href="#12_1_什么都别做，就站在那儿">#</a>12.1 什么都别做，就站在那儿</h1>
<p>程序员工具箱中最强大的优化技术就是不做优化。</p>
<p>有几个理由支持这项禅式的忠告。其中一个是摩尔定律的指数效应一一最聪明、最便宜、常常也是最迅速的性能提升方法，就是等上几个月，期望硬件性能更好。</p>
<ul>
<li>考虑到硬件和程序员时间成本比率，总是有更值得打发时间的事，别去优化一个工作中的系统</li>
</ul>
<p>这是有数学上的理由的。如果仅仅只是为了减少资源使用的一个常数部分而优化，那是很不值得的。更明智的做法是集中精力将时间复杂度或空间复杂度从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 降至 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 或者类似的，从一个更高次的指数降下来。线性性能增益往往很快就会被摩尔定律覆盖了。</p>
<h1 id="12_2_先估量，后优化"><a class="header-anchor" href="#12_2_先估量，后优化">#</a>12.2 先估量，后优化</h1>
<p>如果有真凭实据证明应用程序运行缓慢，这时 (仅当此时)才可以考虑优化代码但付诸实施前，要先估量。</p>
<p>最初的 Unix 程序员最先学到的经验之一就是要明确瓶颈所在，直觉实在是个糟糕的向导，即使特别熟悉可疑代码的人也不例外。</p>
<h1 id="12_3_非定域性之害"><a class="header-anchor" href="#12_3_非定域性之害">#</a>12.3 非定域性之害</h1>
<p>最有效的代码优化方法就是保持代码短小简单。</p>
<p>随着机器资源成本的直线下降，庞大数据结构的平均开销也随之而降一一但是因为相邻级别缓存的切换开销上升了，大型结构突破缓存容量对性能的影响也就增加了。 因此在这里，“小即是美”的建议比以往更有用，尤其是考虑到核心数据结构必须留在最快的缓存里。该建议也同样适用于代码：通常，指令加载要比执行花费的时间更多。</p>
<p>这彻底推翻了某些传统的建议。如循环分解，去掉相对昂贵的机器指令而增加代码的总行数，那是不值得的。在 3D 图形引擎中，优化旋转操作的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">sin(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">in</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span> 函数表在现代机器中占据 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>365</mn><mo>×</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">365 \times 4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">365</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span></span></span></span> 字节的空间在。处理器缓冲速度没有内存查询快时，这显然是个速度优化。但是现在，比起函数表产生的附加 Cache Miss 的可能开销，每次重新计算可能更快。</p>
<p>但在将来，也许随着缓存的增大又会反过来。更普遍的是，不妨悲观地认为，许多优化方法都是暂时的而且常常随着成本比例而变化。唯一的可行方案就是先衡量后再优化。</p>
<h1 id="12_4_吞吐量和延迟"><a class="header-anchor" href="#12_4_吞吐量和延迟">#</a>12.4 吞吐量和延迟</h1>
<h2 id="12_4_3_缓存操作结果"><a class="header-anchor" href="#12_4_3_缓存操作结果">#</a>12.4.3 缓存操作结果</h2>
<p>认为迫切需要缓存的时候，明智的做法是能够从更深层次来考虑，并问问为什么缓存是必须的。这比将缓存的所有边界条件都考虑到要容易得多。</p>
]]></content>
      <tags>
        <tag>系统设计</tag>
        <tag>编码规范</tag>
      </tags>
  </entry>
  <entry>
    <title>Custom SRP - Custom Render Pipeline</title>
    <url>/custom_render_pipeline/</url>
    <content><![CDATA[<div class="note info simple"><p>该教程部分完成的工程状态可见：<a href="https://github.com/xuejiaW/CustomSRP/releases/tag/CustomRenderPipeline">Custom Render Pipeline</a></p>
</div>
<h1 id="A_new_Render_Pipeline"><a class="header-anchor" href="#A_new_Render_Pipeline">#</a>A new Render Pipeline</h1>
<p>早期的 Unity 仅支持 <code> 内置渲染管线（Default Render Pipeline, DRP / Built-in Render Pipleline）</code>。自 Unity 2018 后，Unity 引入了 <code> 可编程渲染管线（Scriptable Render Piplelines，SRP）</code> ，但在 2018 中该功能是试验预览的状态，在 Unity 2019 中该功能才成为 正式功能。</p>
<p>基于 <code>SRP</code> ，Unity 官方在 2018 的版本中实现了两套管线， <code>Lightweight Render Pipeline</code> 和 <code>High Definition Render Pipeline</code> 。前者针对于移动端这样的轻量级平台，而后者针对如 PC，主机这样的高性能平台。在 Unity 2019 的版本中， <code>Lightweight Render Pipeline</code> 被拓展为 <code>Universal Render Pipeline</code> 。</p>
<div class="note info simple"><p><code>Lightweight Render Pipeline</code> 和 <code>Universal Render Pipeline</code> 实际上是同一套管线，<code>Lightweight Render Pipeline</code> 仅是 Unity 2018 中的早期实现版本的命名。</p>
</div>
<div class="note info simple"><p><code>Universal Render Pipeline</code> 计划最终取代目前的内置渲染管线，成为 Unity 渲染的默认渲染管线。</p>
</div>
<h2 id="Project_Setup"><a class="header-anchor" href="#Project_Setup">#</a>Project Setup</h2>
<div class="note primary simple"><p>该笔记使用的 Unity 版本为 2022.3.12f1</p>
</div>
<h3 id="Color_Space"><a class="header-anchor" href="#Color_Space">#</a>Color Space</h3>
<p>Unity 工程的默认色彩空间 Gamma，而为了保证后续光照等计算的准确性，首先需要将颜色空间切换为线性空间，可通过 <code>Edit -&gt; Project Settings -&gt; Player -&gt; Other Settings -&gt; Rendering -&gt; Color Space</code> 修改。</p>
<h3 id="Sample_Scene"><a class="header-anchor" href="#Sample_Scene">#</a>Sample Scene</h3>
<p>在场景中随意放置一些 Cube 和 Sphere，并附加不同的材质，结果如下图所示：</p>
<p><img src="/custom_render_pipeline/crp.png" alt=""></p>
<p>所使用的材质设置如下图所示：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="/custom_render_pipeline/crp1.png" alt="Red"></td>
<td><img src="/custom_render_pipeline/crp2.png" alt="Blue"></td>
<td><img src="/custom_render_pipeline/image-20220124092928056.png" alt="Green/Yellow/White"></td>
</tr>
</tbody>
</table>
<h2 id="Pipeline_Asset"><a class="header-anchor" href="#Pipeline_Asset">#</a>Pipeline Asset</h2>
<div class="note primary simple"><p>SRP 相关的脚本基本都在 <code>UnityEngine.Rendering</code> 命名空间下，且 SRP 已经在引擎内包含，因此此时并不需要额外导入其他的 Package。</p>
</div>
<p>当使用 <code>SRP</code> 时，Unity 引擎需要通过 <code>RenderPipe Asset(RP Asset)</code> 来获取渲染管线的实例，同时也会从 <code>RP Asset</code> 中读取关于渲染管线的设置。</p>
<p>为了创建 <code>RP Asset</code> ，首先需要创建对应的 <code>ScriptableObject</code> 。可以通过继承 <code>RenderPipelineAsset</code> 基类创建出可以构建 <code>RP Asset</code> 的 <code>ScriptableObject</code> 。如下所示：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Rendering;</span><br><span class="line"></span><br><span class="line">[<span class="meta">CreateAssetMenu(menuName = <span class="string">&quot;Rendering/Custom Render Pipeline&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomRenderPipelineAsset</span> : <span class="title">RenderPipelineAsset</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> RenderPipeline <span class="title">CreatePipeline</span>()</span> &#123; <span class="keyword">return</span> <span class="literal">null</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有派生自 <code>RenderPipelineAsset</code> 的类都必须实现 <code>CreatePipeline</code> 函数，Unity 使用该函数获取渲染管线的实例。</p>
<p>之后可以通过 <code>Assets -&gt; Create -&gt; Rendering -&gt; Custom Render Pipeline</code> 创造出 <code>RP Asset</code> ，结果如下所示：<br>
<img src="/custom_render_pipeline/crp3.png" alt=""></p>
<p>可以通过 <code>Project Settings -&gt; Graphics -&gt; Scriptable Render Pipeline Settings</code> 将自定义的 <code>RP Asset</code> 设置给 Unity，如下所示：<br>
<img src="/custom_render_pipeline/crp4.png" alt=""></p>
<p>当替换后了 <code>RP Asset</code> 后，主要有两个变化：</p>
<ol>
<li>
<p>原 <code>Graphics</code> 面板中的许多设置消失了。<br>
因为替换的 <code>RP Asset</code> 并没有提供相关的设置选项。</p>
</li>
<li>
<p>Scene / Game / Material 界面都不再渲染任何东西<br>
因为替换的 <code>RP Asset</code> 实际上返回的是空，即 Unity 此时没有任何的渲染管线可以用。</p>
</li>
</ol>
<h2 id="Render_Pipeline_Instance"><a class="header-anchor" href="#Render_Pipeline_Instance">#</a>Render Pipeline Instance</h2>
<p>为了创建出一个渲染管线，需要通过继承 <code>RenderPipeline</code> 构建自定义的渲染管线类，所有的派生自 <code>RenderPipeline</code> 的类都必须实现 <code>Render</code> 函数，Unity 在每一帧通过触发该函数进行渲染，如下所示：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Rendering;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomRenderPipeline</span> : <span class="title">RenderPipeline</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Render</span>(<span class="params">ScriptableRenderContext context, Camera[] cameras</span>)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Render</span>(<span class="params">ScriptableRenderContext context, List&lt;Camera&gt; cameras</span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note primary simple"><p>可以看到上述的实现中，对于 <code>Render</code> 函数有两个重载，其分别有 <code>Camera[]</code> 和 <code>List&lt;Camera&gt;</code> 的形参，在 Unity 2022 之前， 引擎仅支持形参为 <code>Camera[]</code> 的重载版本。而在 Unity 2022 之后，引擎又引入了形参为 <code>List&lt;Camera&gt;</code> 的重载版本。<br>
为了后续的遍历的便捷性，这里使用 <code>List&lt;Camera&gt;</code> 版本的重载，对于 <code>Camera[]</code> 版本的重载，保持空实现即可。</p>
<div class="note warning simple"><p>因为形参为 <code>Camera[]</code> 的函数原先被标记为了 <code>abstract</code>，因此必须被定义。</p>
</div></div>
<p>之前的 <code>CustomRenderPipelineAsset.CreatePipeline</code> 函数就可以返回该自定义渲染管线的示例，如下所示：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> RenderPipeline <span class="title">CreatePipeline</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CustomRenderPipeline();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时 Unity 已经可以使用 <code>CustomRenderPipeline</code> 进行绘制，但此时所有的界面与之前并没有任何的区别，因为定义的 <code>CustomRenderPipeline</code> 中并没有进行任何的实质渲染。</p>
<h1 id="Rendering"><a class="header-anchor" href="#Rendering">#</a>Rendering</h1>
<p>Unity 通过 <a href="/custom_render_pipeline/#Render_Pipeline_Instance">Render Pipeline Instance</a> 中的 <code>Render</code> 函数进行渲染，<code>Render</code> 函数有两个形参：</p>
<ol>
<li>
<p><code>ScriptableRenderContext</code> ：该形参表示 <code>SRP</code> 渲染的上下文。 RP 使用该形参与 Unity Native 的渲染部分进行通信</p>
</li>
<li>
<p><code>Camera[]</code> ，该形参表示所有激活的 Cameras</p>
<p>RP 使用该形参来控制每个摄像机的渲染与不同摄像机间的渲染顺序</p>
</li>
</ol>
<h2 id="Camera_Renderer"><a class="header-anchor" href="#Camera_Renderer">#</a>Camera Renderer</h2>
<p>通过 <code>ScriptableRenderContext</code> 和 <code>Camera</code> 就可以控制每个摄像机的渲染，如可以通过自定义的 <code>CameraRenderer</code> 类来负责特定摄像机的渲染：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CameraRenderer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> ScriptableRenderContext m_RenderContext = <span class="literal">default</span>;</span><br><span class="line">    <span class="keyword">private</span> Camera m_Camera = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Render</span>(<span class="params">ScriptableRenderContext renderContext, Camera camera</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_RenderContext = renderContext;</span><br><span class="line">        m_Camera = camera;</span><br><span class="line">                <span class="comment">// ....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在之前的 <code>CustomRenderPipeline</code> 中，让每一个相机都调用 <code>CameraRenderer.Render</code> 函数，如下所示：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomRenderPipeline</span> : <span class="title">RenderPipeline</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> CameraRenderer m_Renderer = <span class="keyword">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Render</span>(<span class="params">ScriptableRenderContext context, Camera[] cameras</span>)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Render</span>(<span class="params">ScriptableRenderContext context, List&lt;Camera&gt; cameras</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        cameras.ForEach(camera =&gt; m_Renderer.Render(context, camera));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Drawing_the_Skybox"><a class="header-anchor" href="#Drawing_the_Skybox">#</a>Drawing the Skybox</h2>
<p><code>CameraRenderer.Render</code> 的功能就是渲染所有该摄像机可以看到的物体。如以下的实现，可以让 <code>CameraRender</code> 渲染出天空盒：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Render</span>(<span class="params">ScriptableRenderContext renderContext, Camera camera</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    m_RenderContext = renderContext;</span><br><span class="line">    m_Camera = camera;</span><br><span class="line"></span><br><span class="line">    Setup();</span><br><span class="line">    DrawVisibleGeometry();</span><br><span class="line">    Submit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Setup</span>()</span> &#123; m_RenderContext.SetupCameraProperties(m_Camera); &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DrawVisibleGeometry</span>()</span> &#123; m_RenderContext.DrawSkybox(m_Camera); &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Submit</span>()</span> &#123; m_RenderContext.Submit(); &#125;</span><br></pre></td></tr></table></figure>
<p>在实现中，对 <code>ScriptableRenderContext</code> 调用了一系列函数来完成绘制目的：</p>
<ul>
<li><code>SetupCameraProperties</code> 用于在 Shader 中设置摄像机相关的变量，如 View 矩阵，Projection 矩阵</li>
<li><code>DrawSkybox</code> 将渲染天空盒的命令添加到 Context 的缓冲中</li>
<li><code>Submit</code> 将 Context 缓冲中的命令添加到执行队列中。</li>
</ul>
<div class="note warning simple"><p>仅当 Camera 的 ClearFlags 是 Skybox 时， <code>DrawSkybox</code> 才会真正的将绘制天空盒的命令添加到缓冲中。</p>
</div>
<p>结果如下所示：<br>
<img src="/custom_render_pipeline/gif_2021-5-8_19-55-17.gif" alt="Draw the Skybox"></p>
<h2 id="Command_Buffers"><a class="header-anchor" href="#Command_Buffers">#</a>Command Buffers</h2>
<p>之前的 <code>DrawSkybox</code> 命令向 Context 的缓冲中增加了一条渲染天空盒的命令。除此之外，可以通过 <code>CommandBuffer</code> 类和 <code>context.ExecuteCommandBuffer</code> 函数向 Context 中添加自定义的渲染命令。</p>
<p>通过如下命令创建 <code>CommandBuffer</code>， <code>CommandBuffer</code> 的 <code>name</code> 属性可以在 <code>FrameDebugger</code> 中查看：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">string</span> k_BufferName = <span class="string">&quot;Render Camera&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> CommandBuffer m_Buffer = <span class="keyword">new</span>() &#123;name = k_BufferName&#125;;</span><br></pre></td></tr></table></figure>
<div class="note info simple"><p>FrameDebugger 可以通过 <code>Window -&gt; Analysis -&gt; Frame Debugger</code> 打开。<br>
Profiler 可以通过 <code>Window -&gt; Analysis -&gt; Profiler</code> 打开。</p>
</div>
<p>而如果想要在 <code>Profiler</code> 中调试， 则可以使用 <code>commandBuffer.BeginSample</code> 和 <code>commandBuffer.EndSample</code> API 将开始采样和结束采样的命令添加至 Command Buffer 中，再通过 <code>ScriptableRenderContext.ExecuteCommandBuffer</code> 执行 Command Buffer。如下所示：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Setup</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    m_Buffer.BeginSample(k_BufferName);</span><br><span class="line">    ExecuteCommandBuffer();</span><br><span class="line"></span><br><span class="line">    m_RenderContext.SetupCameraProperties(m_Camera);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DrawVisibleGeometry</span>()</span> &#123; m_RenderContext.DrawSkybox(m_Camera); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Submit</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    m_Buffer.EndSample(k_BufferName);</span><br><span class="line">    ExecuteCommandBuffer();</span><br><span class="line"></span><br><span class="line">    m_RenderContext.Submit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ExecuteCommandBuffer</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    m_RenderContext.ExecuteCommandBuffer(m_Buffer);</span><br><span class="line">    m_Buffer.Clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note warning simple"><p><code>BeginSample</code> 和 <code>EndSample</code> 的命名需要与 Buffer 的名称相同，否则可能会出现 <code>Non matching Profiler.EndSample (BeginSample and EndSample count must match</code> 的错误。</p>
</div>
<div class="note warning simple"><p>像 <code>BeginSample</code> 和 <code>EndSample</code> 这样的 API 每次执行都会向 Command Buffer 中增加一条命令，因此在 <code>ExecuteCommandBuffer</code> 中执行后需要对 Command Buffer 进行 <code>Clear</code> 操作，否则 Command Buffer 中的命令会越来越多。</p>
</div>
<p>此时在 Frame Debugger 中既可以看到之前添加的 Buffer Name 信息：<br>
<img src="/custom_render_pipeline/image-20240220172114.png" alt="Buffer Name in frame debugger"></p>
<p>在 Profiler Window 中也能看到相应的信息：<br>
<img src="/custom_render_pipeline/image-20240220172503.png" alt="Buffer Name in Profiler"></p>
<h2 id="Clearing_the_Render_Target"><a class="header-anchor" href="#Clearing_the_Render_Target">#</a>Clearing the Render Target</h2>
<p>可通过在 Command Buffer 中添加 <code>ClearRenderTarget</code> 命令来清除渲染目标的内容，如下所示：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Setup</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    renderContext.SetupCameraProperties(camera);</span><br><span class="line">    buffer.ClearRenderTarget(<span class="literal">true</span>, <span class="literal">true</span>, Color.clear);  <span class="comment">// Clear render target</span></span><br><span class="line">    buffer.BeginSample(k_BufferName);</span><br><span class="line">    ExecuteCommandBuffer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时可以在 Frame Debugger 中看到 <code>Clear</code> 的命令，如下所示：<br>
<img src="/custom_render_pipeline/image-20240220175057.png" alt="Clear Command"></p>
<div class="note warning simple"><p>对于增加 Clear Render Target 命令的顺序，必须严格按照上述例子，即先设置 Camera Properties，再进行 Clear，再进行 BeginSample。<br>
如果先进行了 Clear，再进行了 SetupCameraProperties，那么 Frame Debugger 中会显示 <code>Draw GL</code> 命令而非 <code>Clear</code> 命令，即 Unity 通过渲染一张铺满整个渲染目标的 Quad 来达成清除的目的，而这会消费较多的性能。如下代码就会导致渲染 Quad：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Setup</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">buffer.ClearRenderTarget(<span class="literal">true</span>, <span class="literal">true</span>, Color.clear);</span><br><span class="line">buffer.BeginSample(k_BufferName);</span><br><span class="line">ExecuteCommandBuffer();</span><br><span class="line">renderContext.SetupCameraProperties(camera);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时的 Frame Debugger 窗口将显示如下内容：<br>
<img src="/custom_render_pipeline/2024-02-20-17-33-31.png" alt="Draw GL"><br>
又因为 <code>CommandBuffer.ClearRenderTarget</code> 的实现会将 Clear 的操作放在一个以 Command Buffer 名称命名的 Sample 中，所以如下的代码将再 Frame Debugger 窗口中引发嵌套的 Sample，如下所示：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Setup</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">buffer.BeginSample(k_BufferName);</span><br><span class="line">buffer.ClearRenderTarget(<span class="literal">true</span>, <span class="literal">true</span>, Color.clear);</span><br><span class="line">ExecuteCommandBuffer();</span><br><span class="line">renderContext.SetupCameraProperties(camera);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时的 Frame Debugger 窗口将显示如下内容：<br>
<img src="/custom_render_pipeline/2024-02-20-17-36-55.png" alt="嵌套 Sample | 300"></p>
</div>
<h2 id="Culling"><a class="header-anchor" href="#Culling">#</a>Culling</h2>
<p>在正式的渲染前，为了保证仅渲染在摄像机的视锥体的内物体，需要让 Unity 进行 Culling 操作。为完成 Culling 操作，首先需要通过函数 <code>TryGetCullingParameters</code> 根据摄像机当前的状态获取到 <code>Culling</code> 相关的参数，再通过函数 <code>context.Cull</code> 将相关参数传递给渲染上下文，并得到 Culling 的结果，结果将以 <code>CullingResults</code> 表示，代码如下所示：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> CullingResults m_CullingResults = <span class="literal">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">bool</span> <span class="title">Cull</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!m_Camera.TryGetCullingParameters(<span class="keyword">out</span> ScriptableCullingParameters cullingParameters)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    m_CullingResults = m_RenderContext.Cull(<span class="keyword">ref</span> cullingParameters);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述 <code>Cull</code> 函数，返回 bool 值表示获取 Culling 参数是否成功。在某些情况下，无法通过 <code>TryGetCullingParameters</code> 函数获取到 Culling 的参数，如摄像机的 Viewport 为空，或者近远剪切平面的设置不合法。</p>
<p>对于 <code>Render</code> 函数，应当仅在 <code>Cull</code> 成功的情况下再进行渲染如下所示：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Render</span>(<span class="params">ScriptableRenderContext renderContext, Camera camera</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    m_RenderContext = renderContext;</span><br><span class="line">    m_Camera = camera;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!Cull()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note primary simple"><p>SRP 中许多函数都以 <code>ref</code> 传递数值，如 <code>context.Cull</code> 函数。但这通常是处于性能方面的考虑，避免数据的拷贝，而非是需要修改传入的参数。</p>
</div>
<h2 id="Drawing_Geometry"><a class="header-anchor" href="#Drawing_Geometry">#</a>Drawing Geometry</h2>
<p>现在可以通过 <code>context.DrawRenderers</code> 方法绘制具体的几何体，其中会用上之前获取到的 <code>CullingResults</code> 如下所示：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ShaderTagId s_UnlitShaderTagId = <span class="keyword">new</span>(<span class="string">&quot;SRPDefaultUnlit&quot;</span>);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DrawVisibleGeometry</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> sortingSettings = <span class="keyword">new</span> SortingSettings(m_Camera) &#123;criteria = SortingCriteria.CommonOpaque&#125;;</span><br><span class="line">    <span class="keyword">var</span> drawingSettings = <span class="keyword">new</span> DrawingSettings(s_UnlitShaderTagId, sortingSettings);</span><br><span class="line">    <span class="keyword">var</span> filteringSettings = <span class="keyword">new</span> FilteringSettings(RenderQueueRange.all);</span><br><span class="line"></span><br><span class="line">    m_RenderContext.DrawRenderers(m_CullingResults, <span class="keyword">ref</span> drawingSettings, <span class="keyword">ref</span> filteringSettings);</span><br><span class="line">    m_RenderContext.DrawSkybox(m_Camera);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><code>FilteringSetting</code> 决定了渲染指定 RenderQueue 范围内的物体，这里填的 <code>RenderQueueRange.all</code> 表示无论 RenderQueue 设置的为多少，都将被渲染。</li>
<li><code>DrawingSettings</code> 的第一个形参决定了需要执行的 Shader Pass， 这里传递的 <code>SRPDefaultUnlit</code> 为 Unity 内置的 Tag，因为目前场景中的许多游戏物体选用的是 <code>Unlit</code> 中的 Shader，所以使用该 Tag。</li>
</ul>
<div class="note info simple"><p>关于 <a href="https://docs.unity3d.com/Manual/SL-PassTags.html">Shader Tag</a> 的内容，查看文档 <a href="https://docs.unity3d.com/Manual/shader-predefined-pass-tags-built-in.html">Built-In Shader Tag</a> 与 <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@11.0/manual/urp-shaders/urp-shaderlab-pass-tags.html#urp-pass-tags-lightmode">SRP Shader Tag</a></p>
</div>
<p><code>DrawingSettings</code> 第二个形参是物体排序相关的设置 <code>SortingSettings</code>，该变量的构造函数依赖 <code>camera</code> 变量，因为其中依赖 <a href="https://docs.unity3d.com/ScriptReference/Camera-transparencySortMode.html"><code>camera.transparencySortMode</code></a> 决定以什么规则来计算排序的数值大小：</p>
<ol>
<li>Perspective：根据摄像机与物体中心的距离</li>
<li>Orthographic：根据沿着摄像机 View 方向的距离</li>
</ol>
<p><code>SortingSettings</code> 中的 <code>criteria</code> 制定了排序的标准，如这里的 <code>CommonOpaque</code> 表示使用通常渲染不透明物体时的排序规则，该规则会综合考虑 RenderQueue，材质，距离等相关信息。</p>
<p>此时在 Frame Debugger 中查看渲染的顺序与结果，如下所示，可以看到基本是先渲染一个特定的材质，然后再渲染下一个：<br>
<img src="/custom_render_pipeline/gif_2021-5-11_23-51-01.gif" alt="渲染顺序与结果"></p>
<p>如果查看 <code>CommonOpaque</code> 的定义可以看到，它考虑了尽可能的减少渲染上下文的切换，从前至后渲染等因素：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> SortingCriteria</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>   <span class="doctag">&lt;para&gt;</span>Typical sorting for opaque objects.<span class="doctag">&lt;/para&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    CommonOpaque = CanvasOrder | OptimizeStateChanges | QuantizedFrontToBack | RenderQueue | SortingLayer, <span class="comment">// 0x0000003B</span></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note warning simple"><p>物体具体的渲染顺序受 Unity 版本 / Unity 实现影响，这里的设置 <code>criteria</code> 更多的是一种“建议”，而具体的排序算法，在 Unity 引擎内部实现，是一个相对黑盒。</p>
</div>
<p>如果将 <code>SortingSettings</code> 中的 <code>criteria</code> 去除，即：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DrawVisibleGeometry</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> sortingSettings = <span class="keyword">new</span> SortingSettings(m_Camera);</span><br><span class="line">    <span class="keyword">var</span> drawingSettings = <span class="keyword">new</span> DrawingSettings(s_UnlitShaderTagId, sortingSettings);</span><br><span class="line">    <span class="keyword">var</span> filteringSettings = <span class="keyword">new</span> FilteringSettings(RenderQueueRange.all);</span><br><span class="line"></span><br><span class="line">    renderContext.DrawRenderers(cullingResults, <span class="keyword">ref</span> drawingSettings, <span class="keyword">ref</span> filteringSettings);</span><br><span class="line">    renderContext.DrawSkybox(camera);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>则渲染的结果如下所示，几乎是一个无规律的状态在渲染：<br>
<img src="/custom_render_pipeline/gif_2021-5-11_23-54-57.gif" alt="Random Rendering"></p>
<h2 id="Drawing_Opaque_and_Transparent_Geometry_Separately"><a class="header-anchor" href="#Drawing_Opaque_and_Transparent_Geometry_Separately">#</a>Drawing Opaque and Transparent Geometry Separately</h2>
<p>在之前的最终渲染结果中，天空盒将半透明物体的一部分遮挡掉了，如下所示：<br>
<img src="/custom_render_pipeline/crp6.png" alt="Wrong Effect of Transparent Object"></p>
<p>这是因为天空盒在半透明物体的之后进行渲染，而在 <code>Unlit/Transparent</code> 的 Shader 中，设置了 <code>ZWrite Off</code> ，即半透明物体不会写入深度缓冲，因此在绘制了半透明物体的部分，天空盒仍然能通过深度检测，即覆盖半透明物体。</p>
<p>解决这个问题的方式，就是调整渲染顺序为 <code>不透明物体 -&gt; 天空盒 -&gt; 半透明物体</code> 。实现方法如下所示：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DrawVisibleGeometry</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> sortingSettings = <span class="keyword">new</span> SortingSettings(m_Camera) &#123;criteria = SortingCriteria.CommonOpaque&#125;;</span><br><span class="line">    <span class="keyword">var</span> drawingSettings = <span class="keyword">new</span> DrawingSettings(s_UnlitShaderTagId, sortingSettings);</span><br><span class="line">    <span class="keyword">var</span> filteringSettings = <span class="keyword">new</span> FilteringSettings(RenderQueueRange.opaque);</span><br><span class="line">    m_RenderContext.DrawRenderers(m_CullingResults, <span class="keyword">ref</span> drawingSettings, <span class="keyword">ref</span> filteringSettings);</span><br><span class="line"></span><br><span class="line">    m_RenderContext.DrawSkybox(m_Camera);</span><br><span class="line"></span><br><span class="line">    sortingSettings.criteria = SortingCriteria.CommonTransparent;</span><br><span class="line">    drawingSettings.sortingSettings = sortingSettings;</span><br><span class="line">    filteringSettings.renderQueueRange = RenderQueueRange.transparent;</span><br><span class="line">    m_RenderContext.DrawRenderers(m_CullingResults, <span class="keyword">ref</span> drawingSettings, <span class="keyword">ref</span> filteringSettings);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>渲染结果如下：<br>
<img src="/custom_render_pipeline/crp7.png" alt="渲染结果"></p>
<h1 id="Editor_Rendering"><a class="header-anchor" href="#Editor_Rendering">#</a>Editor Rendering</h1>
<h2 id="Drawing_Legacy_Shaders"><a class="header-anchor" href="#Drawing_Legacy_Shaders">#</a>Drawing Legacy Shaders</h2>
<p>之前通过在初始化 <code>DrawingSettings</code> 时，设置的 Shader Tag 为 <code>SRPDefaultUnlit</code> 的 Shader，因此仅会渲染 Unlit Shader 的物体。而其余的物体，如使用了 <code>Standard</code> Shader 的物体，可以通过以下 Built-in 的 Shader Tag 找到并渲染：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ShaderTagId[] s_LegacyShaderTagIds =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">new</span>(<span class="string">&quot;Always&quot;</span>),</span><br><span class="line">    <span class="keyword">new</span>(<span class="string">&quot;ForwardBase&quot;</span>),</span><br><span class="line">    <span class="keyword">new</span>(<span class="string">&quot;PrepassBase&quot;</span>),</span><br><span class="line">    <span class="keyword">new</span>(<span class="string">&quot;Vertex&quot;</span>),</span><br><span class="line">    <span class="keyword">new</span>(<span class="string">&quot;VertexLMRGBM&quot;</span>),</span><br><span class="line">    <span class="keyword">new</span>(<span class="string">&quot;VertexLM&quot;</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>之后我们新建一个用以渲染这些 Built-in Shader 的物体的函数 <code>DrawUnSupportedShadersGeometry</code> ，如下所示：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Render</span>(<span class="params">ScriptableRenderContext renderContext, Camera camera</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    Setup();</span><br><span class="line">    DrawVisibleGeometry();</span><br><span class="line">    DrawUnSupportedShadersGeometry();</span><br><span class="line">    Submit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DrawUnSupportedShadersGeometry</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> drawingSettings = <span class="keyword">new</span> DrawingSettings &#123;sortingSettings = <span class="keyword">new</span> SortingSettings(m_Camera)&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i != s_LegacyShaderTagIds.Length; ++i)</span><br><span class="line">        drawingSettings.SetShaderPassName(i, s_LegacyShaderTagIds[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> filteringSettings = FilteringSettings.defaultValue;</span><br><span class="line"></span><br><span class="line">    m_RenderContext.DrawRenderers(m_CullingResults, <span class="keyword">ref</span> drawingSettings, <span class="keyword">ref</span> filteringSettings);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的 <code>legacyShaderTagIds</code> 中指定了常用的 Built-in 的 Shader Tag，即会尝试渲染 Built-in Shader 的物体。结果如下所示，可以看到使用了 <code>Standard</code> Shader 的物体被渲染了出来：<br>
<img src="/custom_render_pipeline/2024-02-24-18-30-08.png" alt="Rendering Effect of Built-in Shader"></p>
<div class="note info simple"><p>在早期的 Unity 版本中，此时 <code>Standard</code> Shader 的物体会被渲染成黑色，这是因为早期 <code>SRP</code> 无法设置 <code>Standard</code> Shader 中的一些参数。</p>
</div>
<h2 id="Error_Material"><a class="header-anchor" href="#Error_Material">#</a>Error Material</h2>
<p>虽然在 Unity 2022 中，一些 Built-in Shader 的物体可以被渲染出来，但这仍然不健壮，且应当有明确的错误提示开发者应当将 Built-in Shader 替换为 SRP Shader，为达到这个目的，可以使用 Unity 内置的表示 Shader 错误的特殊 Shader 来渲染这些物体，只需要修改 <code>DrawingSettings</code> 中的 <code>overrideMaterial</code> 即可，如下所示：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Material s_ErrorMaterial = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DrawUnSupportedShadersGeometry</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (s_ErrorMaterial == <span class="literal">null</span>)</span><br><span class="line">        s_ErrorMaterial = <span class="keyword">new</span> Material(Shader.Find(<span class="string">&quot;Hidden/InternalErrorShader&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> drawingSettings = <span class="keyword">new</span> DrawingSettings();</span><br><span class="line">    drawingSettings.sortingSettings = <span class="keyword">new</span> SortingSettings(m_Camera);</span><br><span class="line">    drawingSettings.overrideMaterial = s_ErrorMaterial;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i != s_LegacyShaderTagIds.Length; ++i)</span><br><span class="line">        drawingSettings.SetShaderPassName(i, s_LegacyShaderTagIds[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> filteringSettings = FilteringSettings.defaultValue;</span><br><span class="line"></span><br><span class="line">    m_RenderContext.DrawRenderers(m_CullingResults, <span class="keyword">ref</span> drawingSettings, <span class="keyword">ref</span> filteringSettings);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时结果如下：<br>
<img src="/custom_render_pipeline/crp9.png" alt="渲染结果"></p>
<h2 id="Partial_Class"><a class="header-anchor" href="#Partial_Class">#</a>Partial Class</h2>
<p>可以使用 Scripting Symbols 让不支持的 Shader 部分仅在 Editor 和 Development Build 才被显示，即将相关代码定义放到如下的代码块中：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> UNITY_EDITOR || DEVELOPMENT_BUILD</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>同时为了更好的管理代码，可以将 Editor 部分放到 <code>CameraRenderer.Editor</code> 中，如下所示：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In CameraRenderer.Editor.cs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">CameraRenderer</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> UNITY_EDITOR || DEVELOPMENT_BUILD</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ShaderTagId[] legacyShaderTagIds =</span><br><span class="line">    &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Material s_ErrorMaterial = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">partial</span> <span class="keyword">void</span> <span class="title">DrawUnSupportedShadersGeometry</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in CameraRenderer.cs</span></span><br><span class="line"><span class="function"><span class="keyword">partial</span> <span class="keyword">void</span> <span class="title">DrawUnSupportedShadersGeometry</span>()</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里使用了 Partial Classes 拆分 <code>CameraRenderer</code> 类，方便代码管理。并将 <code>DrawUnSupportedShaderGeometry</code> 函数定义为 Partial Methods，保证在非 Editor 和 Development Build 时，即使 <code>DrawUnSupportedShaderGeometry</code> 未被定义实现，代码仍然能正常编译。</p>
<h2 id="Drawing_Gizmos"><a class="header-anchor" href="#Drawing_Gizmos">#</a>Drawing Gizmos</h2>
<p>目前在 Scene 场景中并没有绘制 <code>Gizmo</code> ，如场景中并没有摄像机的显示，也没有摄像机的视锥体的展示。</p>
<p>可以通过 <code>Handles.ShouldRenderGizmos</code> 判断当前帧是否需要渲染 <code>Gizmos</code> ，如需要的话可通过函数 <code>context.DrawGizmos</code> 进行绘制。</p>
<div class="note info simple"><p>Editor Scene 下的 Gizmos Toggle 会影响 <code>Handles.ShouldRenderGizmos</code> 的返回值。<br>
<img src="/custom_render_pipeline/2024-02-25-14-21-17.png" alt="Gizmos Toggle"></p>
</div>
<div class="note info simple"><p>Unity 的 <a href="https://docs.unity3d.com/ScriptReference/Handles.html">Handles</a> 存在许多关于 Gizmos 的帮助函数</p>
</div>
<p><code>Gizmos</code> 的绘制应当在整个流程的最后，最终绘制 <code>Gizmos</code> 的代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In CameraRenderer</span></span><br><span class="line"><span class="function"><span class="keyword">partial</span> <span class="keyword">void</span> <span class="title">DrawGizmos</span>()</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Render</span>(<span class="params">ScriptableRenderContext renderContext, Camera camera</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    Setup();</span><br><span class="line">    DrawVisibleGeometry();</span><br><span class="line">    DrawUnSupportedShadersGeometry();</span><br><span class="line">    DrawGizmos();</span><br><span class="line">    Submit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In CameraRenderer.Editor</span></span><br><span class="line"><span class="function"><span class="keyword">partial</span> <span class="keyword">void</span> <span class="title">DrawGizmos</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!Handles.ShouldRenderGizmos()) <span class="keyword">return</span>;</span><br><span class="line">    m_RenderContext.DrawGizmos(m_Camera,GizmoSubset.PreImageEffects);</span><br><span class="line">    m_RenderContext.DrawGizmos(m_Camera,GizmoSubset.PostImageEffects);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>context.DrawGizmos</code> 需要两个参数，第一个是表示当前 View 的 Camera， 第二个表示哪种 <code>Gizmos</code> 需要被绘制， <code>GizmoSubset.PreImageEffects</code> 表示受后处理影响的 <code>Gizmos</code> ， <code>GizmoSubset.PostImageEffects</code> 表示不受后处理影响的部分。这里选择渲染所有种类的 <code>Gizmos</code> 。渲染的结果如下：<br>
<img src="/custom_render_pipeline/crp10.png" alt="渲染结果"></p>
<h2 id="Drawing_Unity_UI"><a class="header-anchor" href="#Drawing_Unity_UI">#</a>Drawing Unity UI</h2>
<p>在场景中添加了一个 UGUI 的 Button 后，可以看到按钮在 Game 界面中被正常的渲染了出来，如下所示：<br>
<img src="/custom_render_pipeline/crp11.png" alt="Button in Game View"></p>
<p>但通过 Frame Debugger 可以发现此时 UI 的渲染并没有经过自定义的 SRP 如下所示：<br>
<img src="/custom_render_pipeline/crp12.png" alt="Frame Debugger for UI"></p>
<p>而当将 <code>Canvas</code> 中的 <code>Render Mode</code> 修改为 <code>Screen Space - Camera</code> 或 <code>World Space</code> 后，UI 的渲染被放到了渲染半透明物体的部分中，如下所示，且此时因为在半透明的队列中先渲染了 UI，所以 UI 几乎被其他物体遮挡住了：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="/custom_render_pipeline/crp13.png" alt=""></td>
<td><img src="/custom_render_pipeline/crp14.png" alt=""></td>
</tr>
</tbody>
</table>
<p>但无论 <code>Render Mode</code> 是什么格式，在 Scene 界面中，UI 都没有被正常的渲染出来，能看到的只有 UI 的 <code>Gizmo</code> ，如下：<br>
<img src="/custom_render_pipeline/crp15.png" alt=""></p>
<p>这是因为 UI 在 Scene 界面下，都是以 <code>World Space</code> 模式被渲染出来，而且用了不同的几何信息，且 UI 在 Scene 下的几何信息默认并没有被添加到 SRP 中。</p>
<p>对于在 Scene 中显示的 UI 的几何信息，需要通过函数 <code>ScriptabEmitWorldGeometryForSceneView</code> 添加到 SRP 中。且需要在调用 <code>Cull</code> 函数前被添加，保证这些几何信息同样会被进行正常裁剪。</p>
<p>整体代码如下所示：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In CameraRenderer</span></span><br><span class="line"><span class="function"><span class="keyword">partial</span> <span class="keyword">void</span> <span class="title">PrepareForSceneWindow</span>()</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Render</span>(<span class="params">ScriptableRenderContext renderContext, Camera camera</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    PrepareForSceneWindow();</span><br><span class="line">    <span class="keyword">if</span> (!Cull()) <span class="comment">// Get Culling parameters failed</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In CameraRenderer.Editor</span></span><br><span class="line"><span class="function"><span class="keyword">partial</span> <span class="keyword">void</span> <span class="title">PrepareForSceneWindow</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (camera.cameraType == CameraType.SceneView)</span><br><span class="line">    &#123;</span><br><span class="line">      ScriptableRenderContext.EmitWorldGeometryForSceneView(camera);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ScriptableRenderContext.EmitWorldGeometryForSceneView</code> 函数的描述如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span>   <span class="doctag">&lt;para&gt;</span>Emits UI geometry into the Scene view for rendering.<span class="doctag">&lt;/para&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;cullingCamera&quot;&gt;</span>Camera to emit the geometry for.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">[<span class="meta">FreeFunction(<span class="string">&quot;UI::GetCanvasManager().EmitWorldGeometryForSceneView&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">MethodImpl(MethodImplOptions.InternalCall)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">EmitWorldGeometryForSceneView</span>(<span class="params">Camera cullingCamera</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>此时在 Scene 界面下就可以看到 UI 被正确的渲染出来。</p>
<h1 id="Multiply_Cameras"><a class="header-anchor" href="#Multiply_Cameras">#</a>Multiply Cameras</h1>
<h2 id="Two_Cameras"><a class="header-anchor" href="#Two_Cameras">#</a>Two Cameras</h2>
<p>在场景中可以将 <code>Main Camera</code> 进行拷贝，并将新的 Camera 命名为 <code>Second Camera</code> ，并将 <code>Second Camera</code> 的 <code>Depth</code> 参数设置为 0，即此时会先渲染 <code>Main Camera</code> ，然后再渲染 <code>Second Camera</code> ：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="/custom_render_pipeline/crp16.png" alt="Hierarchy"></td>
<td><img src="/custom_render_pipeline/crp17.png" alt="Main Camera"></td>
<td><img src="/custom_render_pipeline/crp18.png" alt="Second Camera"></td>
</tr>
</tbody>
</table>
<p>此时在 Frame Debugger 中可以看到两个摄像机的渲染被合并在了一起，如下所示：<br>
<img src="/custom_render_pipeline/crp19.png" alt="Red For Main, Yellow For Second"></p>
<p>这是因为此时两个 Camera 对应的 <code>CameraRenderer</code> 中的 <code>Command Buffer</code> 命名相同，因此 Frame Debugger 将两者的信息合并在了一起。</p>
<p>可以通过分别对两个 Command Buffer 进行命令来分开两者的渲染信息，如下所示：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In CameraRenderer</span></span><br><span class="line"><span class="function"><span class="keyword">partial</span> <span class="keyword">void</span> <span class="title">PrepareBuffer</span>()</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Render</span>(<span class="params">ScriptableRenderContext renderContext, Camera camera</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    PrepareBuffer();</span><br><span class="line">    PrepareForSceneWindow();</span><br><span class="line">    <span class="keyword">if</span> (!Cull()) <span class="comment">// Get Culling parameters failed</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In CameraRenderer.Editor</span></span><br><span class="line"><span class="function"><span class="keyword">partial</span> <span class="keyword">void</span> <span class="title">PrepareBuffer</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    buffer.name = camera.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note info simple"><p><code>camera.name</code> 会造成内存分配，但因为 <code>PrepareBuffer</code> 是定义在 <code>CameraRender.Editor</code> 中，因此仅在 Editor 模式下运行，不会造成运行时的性能浪费。</p>
</div>
<p>此时 Frame Debugger 界面如下：<br>
<img src="/custom_render_pipeline/crp20.png" alt="Main And Second Camera|500  "></p>
<h2 id="Layers"><a class="header-anchor" href="#Layers">#</a>Layers</h2>
<p>可以调整物体的 <code>Layer</code> 以及摄像机的 <code>Culling Mask</code> 来控制摄像机仅渲染特定的游戏物体。</p>
<p>如将所有使用了 <code>Standard</code> 的游戏物体的 <code>Layer</code> 调整为 <code>Ignore Raycast</code> ，并将两个摄像机的 <code>Culling Mask</code> 设置为如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="/custom_render_pipeline/crp21.png" alt="Main Camera"></td>
<td><img src="/custom_render_pipeline/crp22.png" alt="Second Camera"></td>
</tr>
</tbody>
</table>
<p>此时的渲染结果如下，因为 Second Camera 仅渲染 <code>Ignore Raycast</code> Layer 的物体，又 Second Camera 会覆盖 Main Camera 的内容：<br>
<img src="/custom_render_pipeline/image-20240225150054.png" alt="Second Camera"></p>
<h2 id="Clear_Flags"><a class="header-anchor" href="#Clear_Flags">#</a>Clear Flags</h2>
<p>可以通过修改两个摄像机的 Clear Flags 来合并两个摄像机的渲染内容。并根据摄像机的 Clear Flags 调整 ClearRenderTarget 的逻辑，如下所示：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Setup</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    CameraClearFlags flags = camera.clearFlags;</span><br><span class="line">    buffer.ClearRenderTarget(flags &lt;= CameraClearFlags.Depth, flags == CameraClearFlags.Color,</span><br><span class="line">                flags == CameraClearFlags.Color ? camera.backgroundColor.linear : Color.clear);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>CameraClearFlags</code> 是 Unity 定义的一个枚举值，有四个参数，参数数值从 1 到 4，分别为 <code>Skybox</code> , <code>Color</code> , <code>Depth</code> , <code>Nothing</code> 。</p>
<p>上述代码中，除了 <code>Nothing</code> 的情况，都会将 Depth Buffer 清除，而仅在为 <code>Color</code> 的时候会对 Color Buffer 进行清除。在清除时，仅当为 <code>Color</code> 时使用 <code>camera.backgroundColor</code> 其余时候都用 <code>Color.clear</code> 。</p>
<div class="note info simple"><p>使用 <code>camera.backgroundColor.linear</code> 是因为项目建立时，将颜色空间设置为了 <code>Linear</code> 。</p>
</div>
<div class="note info simple"><p>理论上，在 <code>CameraClearFlags</code> 为 <code>Skybox</code> 时也应当清除 <code>Color Buffer</code> ，但因为 <code>Skybox</code> 时擦除了 Depth Buffer，又会在渲染的最后绘制 Skybox，所以上一帧的颜色内容即使不清除，也会被这一帧渲染的 Skybox 覆盖，因此不会造成显示的错误。</p>
</div>
<p><code>Main Camera</code> 作为第一个渲染的摄像机，为了保证渲染的正确性，必须使用 <code>Skybox</code> 或 <code>Color</code> 作为 Clear Flags。 <code>Second Camera</code> 为了不 Clear 掉 <code>Main Camera</code> 渲染的内容，则必须使用 <code>Depth</code> 或 <code>Nothing</code> 保证 <code>Main Camear</code> 渲染的 Color Buffer 被保持。</p>
<p>当 <code>Second Camera</code> 选择 <code>Depth</code> 时， <code>Main Camera</code> 渲染的 Depth Buffer 会被 Clear，此时 <code>Second Camera</code> 渲染的内容就都会叠加到 <code>Main Camera</code> 的内容上。</p>
<p>当 <code>Second Camera</code> 选择 <code>Nothing</code> 时， <code>Main Camera</code> 渲染的 Depth Buffer 会被保留，此时 <code>Second Camera</code> 渲染的内容就仍要与 <code>Main Camera</code> 渲染的内容进行深度检测。</p>
<p>当 <code>Main Camera</code> Clear Flags 为 <code>Skybox</code> ， <code>Second Camera</code> 的 Clear Flags 分别为 <code>Skybox</code> , <code>Color</code> , <code>Depth</code> , <code>Nothing</code> 的结果如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="/custom_render_pipeline/image-20240225150227.png" alt="Skybox"></td>
<td><img src="/custom_render_pipeline/image-20240225150301.png" alt="Color"></td>
</tr>
<tr>
<td><img src="/custom_render_pipeline/image-20240225150324.png" alt="Depth Only"></td>
<td><img src="/custom_render_pipeline/image-20240225150353.png" alt="Don't Clear"></td>
</tr>
</tbody>
</table>
<p>还可以通过调整摄像机的 <code>Viewport</code> 决定摄像机渲染结果的输出范围，如下为 <code>Second Camera</code> 的 Clear Flag 为 <code>Color</code> 且 Viewport 为 <code>(0.75, 0.75, 0.25, 0.25)</code> 时的结果：<br>
<img src="/custom_render_pipeline/crp23.png" alt=""></p>
<div class="note info simple"><p>Unity 使用 <code>Hidden/InternalClear</code> shader 来进行 Clear 操作。该 Shader 中会通过 Stencil Buffer 来实现 Camera Viewport 的效果。</p>
</div>
<div class="note info simple"><p>当有多个摄像机时，每帧每个摄像机都需要进行 <code>Culling</code>, <code>Setup</code> , <code>Sorting</code> 等操作。因此增加摄像机数量会增大对性能的消耗。</p>
</div>
<h1 id="Reference"><a class="header-anchor" href="#Reference">#</a>Reference</h1>
<p><a href="https://catlikecoding.com/unity/tutorials/custom-srp/custom-render-pipeline/">Custom Render Pipeline (catlikecoding.com)</a></p>
]]></content>
      <tags>
        <tag>Unity</tag>
        <tag>SRP</tag>
      </tags>
  </entry>
  <entry>
    <title>《Unix 编程艺术》 第十三章 复杂度</title>
    <url>/di_13_zhang_fu_za_du%EF%BC%9Ajin_ke_neng_jian_dan%EF%BC%8Cdan_bie_jian_dan_guo_le_tou/</url>
    <content><![CDATA[<p>在<a href="/di_1_zhang_zhe_xue">第 1 章 哲学</a> 末，将 Unix 的哲学概括为“KeepItSimple,Stupid!”。贯穿整个“设计”部分的不变主题就是尽可能保持简单设计的重要性。但什么是“尽可能的简单”?又如何断定?</p>
<p>本章并不是简单地尝试给出这些问题的答案，因为根本没有答案一一而是希望读者能够在概念上有所收益，从而挖掘出自己的答案。</p>
<h1 id="13_1_谈谈复杂度"><a class="header-anchor" href="#13_1_谈谈复杂度">#</a>13.1 谈谈复杂度</h1>
<h2 id="13_1_1_复杂度的三个来源"><a class="header-anchor" href="#13_1_1_复杂度的三个来源">#</a>13.1.1 复杂度的三个来源</h2>
<p>Unix 程序员追求简单的激情，源自注重实效的事实: 复杂度就是成本。复杂的软件更难于开发，难于测试，难于调试，难于维护一一最重要的，难以学习和使用。而复杂所带来的成本，开发时便汹涌而来，部署后更变本加厉。复杂是 bug 滋生的温床，在整个的软件生存期，世界都将不得安宁。</p>
<p>复杂度的三个来源：</p>
<ul>
<li>实现复杂度：程序员为了能够试图理解一个程序，从而建立其思维模型并调试该程序的困难程度</li>
<li>接口复杂度：即界面复杂度。对用户而言，复杂度与记忆负担紧密关联。</li>
<li>代码量：代码的缺陷密度，每百行代码出错率，往往是一个与实现语言种类无关的常量。更多行的代码意味着更多的 bug，而调试常常是开发中最昂贵、最耗时的部分。</li>
</ul>
<p>所有种种压力将程序员拖进复杂度的泥沼中，其中两个最臭名昭著的就是功能蠕变和过早优化。</p>
<ul>
<li>代码量、接口复杂度和实现复杂度可能同时上升。这就是功能蠕变的通常结果，所以程序员对其特别恐惧。</li>
<li>过早的优化并不增加接口复杂度，但是对于实现复杂度和代码库规模有着负面的影响(常常特别糟糕)。</li>
</ul>
<p>三种复杂度陷阱：</p>
<ul>
<li>设计时首先考虑容易实现或代码规模，可能就会简单地将许多底层任务都抛给用户。——&gt; Manularity 陷阱</li>
<li>迫于保持代码库适度规模的压力不得不使用极端晦涩复杂的实现技法，这往往会导致系统实现复杂度的层层叠加，成为无法调试的一团乱麻。——&gt; Blivet 陷阱</li>
<li>如果项目设计者对实现复杂度特别敏感，而拒绝使用统一但复杂的方式来解决一整类问题，相反地更愿意对问题个体编写重复、专用代码，其结果就是代码库尺寸暴涨，而维护问题远较使用统一方法严重。——&gt; Adhocity 陷阱</li>
</ul>
<h2 id="13_1_3_本质的、选择的和偶然地复杂度"><a class="header-anchor" href="#13_1_3_本质的、选择的和偶然地复杂度">#</a>13.1.3 本质的、选择的和偶然地复杂度</h2>
<p>在理想世界，Unix 程序员只愿意手工打造小巧完美的软件宝石，每个都那么小巧、那么优雅、那么完美。然而现实中很不幸的是，太多复杂问题需要复杂的解决方案。仅十行的程序，再优雅也无法控制喷气客机。</p>
<ul>
<li>本质复杂度：喷气客机的复杂是必然的。过去有个相当尖锐的观点，不能为简单性而牺牲掉功能，因为飞机必须要能飞。</li>
<li>偶然复杂度：没有找到实现规定功能集合的最简方法，偶然复杂度可以由良好的设计或重新设计来去除</li>
<li>选择复杂度：同某个期望的功能相关联，只能由改变工程的目标来去除</li>
</ul>
<h2 id="13_1_4_映射复杂度"><a class="header-anchor" href="#13_1_4_映射复杂度">#</a>13.1.4 映射复杂度</h2>
<p>复杂度的不同来源必须以不同方法应对：</p>
<ul>
<li>代码库规模可以采用更好的工具来解决</li>
<li>实现复杂度可以选择更好的算法来处理</li>
<li>接口复杂度必须着眼于更好的交互设计，一种考虑了人类工程学和用户心理学在内的技能。这种技能，比编码能力更为少见。</li>
</ul>
<p>处理各种复杂度，必然更仰赖于见识而非方法</p>
<ul>
<li>通过发现更简单的方法可以去除偶然复杂度。</li>
<li>依赖上下文环境判断哪些功能值得去做，可以去除选择复杂度。</li>
<li>去除本质复杂度，就只能通过对现实真谛的洞察和顿悟，从根本上重新定义所要解决的问题。</li>
</ul>
<h2 id="13_1_5_当简洁不能胜任"><a class="header-anchor" href="#13_1_5_当简洁不能胜任">#</a>13.1.5 当简洁不能胜任</h2>
<p>在 Unix 传统中存在一个强烈的偏好，宁可去掉功能，也不可接受可能复杂性</p>
<p>同其他美学形式一样，我们需要注意何时设计上的简约已经的不再是有价值的自律形式，而开始成为一件伪装的苦行者外衣———一种实际上把美德作为借口来敷衍工作的纵容方式。</p>
<h1 id="13_4_软件的适度规模"><a class="header-anchor" href="#13_4_软件的适度规模">#</a>13.4 软件的适度规模</h1>
<p>软件很容易负载太多任务、太多需求设想而最终失败，也很容易把程序编制得过于复杂、臃肿和庞大。… 纠正这种趋势的方法就是吝啬原则：只有实证了其他方法行不通时才写庞大程序，即 <a href="/di_1_zhang_zhe_xue/#%E5%90%9D%E5%95%AC%E5%8E%9F%E5%88%99%EF%BC%9A%E9%99%A4%E9%9D%9E%E7%A1%AE%E6%97%A0%E5%AE%83%E6%B3%95%EF%BC%8C%E4%B8%8D%E8%A6%81%E7%BC%96%E5%86%99%E5%BA%9E%E5%A4%A7%E7%9A%84%E7%A8%8B%E5%BA%8F">吝啬原则：除非确无它法，不要编写庞大的程序</a></p>
]]></content>
      <tags>
        <tag>系统设计</tag>
        <tag>编码规范</tag>
      </tags>
  </entry>
  <entry>
    <title>《Unix 编程艺术》 第十四章 语言</title>
    <url>/di_14_zhang_yu_yan%EF%BC%9Ac_hai_shi_fei_c/</url>
    <content><![CDATA[<h1 id="14_1_Unix_下语言的丰饶"><a class="header-anchor" href="#14_1_Unix_下语言的丰饶">#</a>14.1 Unix 下语言的丰饶</h1>
<p>Unix 上运行的语言种类完全可能超过计算史上其它所有操作系统的总和，至少有两个充分的理由造成了这种巨大的多样性：</p>
<ol>
<li>Unix 广泛用于研究和教学平台。</li>
<li>Unix 传统鼓励专门领域语言的设计，和现在一般称为“脚本语言”的东西——为了把其它应用程序和工具胶合起来而专门设计的语言。</li>
</ol>
<p>“脚本语言”是个有点整脚的术语。很多通常这么称呼的主要语言 (PerlTcl、Python 等)都已经超越了最初意义的脚本用途，已经成为威力相当强大的独立通用编程语言。</p>
<p>把所有这些语言都纳入“脚本语言”的部分原因在于，这些语言都具有非常一致的发展历程。在运行期完成解释使得动态存储管理的自动化相对容易，而这几平要求采用引用（存储地址不透明且无法进行运算）而不是传值或显式指针。使用引用可使下一步更容易实现运行期的多态性和 OO。</p>
<h1 id="14_2_为什么不是_C"><a class="header-anchor" href="#14_2_为什么不是_C">#</a>14.2 为什么不是 C</h1>
<p>C 和 C++以增加实现时间和调试时间为代价来优化效率。尽管以 C 或 C++编写对时间要求极高的系统程序或应用程序内核似乎还有意义，然而自从这些语言在 1980 年代崛起，世界已经发生了很大变化。在 2003 年，用几平同样的价钱能够买到的处理器快了 1000 倍，内存大了 1000 倍,，磁盘容量也大了 10000 倍。</p>
<p>急剧下降的成本从根本上改变了编程的经济含义。大多数情况下，和 C 一样节约机器资源已经不再有任何意义。相反地，经济方面的最优选择已经变成尽可能减少调试时间、尽可能延长人类对代码的长期可维护性。</p>
<p>C 和 C++的中心问题在于它们要求程序员自己完成内存管理—声明变量、显式管理链表、设置缓冲大小、检测或防止缓冲溢出，以及分配和回收动态存储。…尽管缺乏确凿坚实的数据，但很多经验丰富的程序员都相信，内存管理产生的 bug 时真实代码持续产生错误的最大单体来源。</p>
<h1 id="14_3_解释型语言和混合策略"><a class="header-anchor" href="#14_3_解释型语言和混合策略">#</a>14.3 解释型语言和混合策略</h1>
<p>避免手工管理内存的语言通过在运行期可执行体中嵌入一个内存管理器来完成内存管理。</p>
<p>通常情况下，这些语言的运行环境分成程序部分（运行脚本本身）和解释器部分解释器管理动态存储。在 Unix（以及其它现代操作系统）中解释器内核由多个程序部分共享，减少了各个程序的实际开销。</p>
<h1 id="14_4_语言评估"><a class="header-anchor" href="#14_4_语言评估">#</a>14.4 语言评估</h1>
<p>混合语言是一种知识密集型（而不是编码密集型）的编程。要让它能够工作，我们不仅应该具备相当数量的多种语言应用知识，并且还必须具备能够判断这些语言在什么地方最适合、以及怎样把它们组合在一起的潜经验。</p>
<h2 id="14_4_1_C"><a class="header-anchor" href="#14_4_1_C">#</a>14.4.1 C</h2>
<p>尽管存在内存管理问题，但 C 语言还有一些仍然可以在其中称王称霸的生态环境要求速度最快并且具有实时需求的程序，或者与 OS 内核紧密联系的程序非常适合用 C 编写。</p>
<p>即使更高级的语言能够满足编程的要求，我们仍然要学习 C，其中一个充分理由就是 C 能帮助我们学会在硬件体系层次上考虑问题。</p>
<h2 id="14_4_2_C"><a class="header-anchor" href="#14_4_2_C">#</a>14.4.2 C++</h2>
<p>当 C++在 1980 年代中期首次公布于世时，面向对象 （OO）语言正被大肆吹捧为解决软件复杂度问题的“银弹”。</p>
<p>C++面向对象的特性对于其前辈 C 而言是个压倒性的优点其拥期望 C++能够迅速废掉更古老的 C 语言。</p>
<p>这种情况当然并没有发生。部分可归因于 C++本身的问题:对向后兼容 C 的要求迫使 C++在设计中做出了许多妥协。而且这个要求阻碍了 C++完全自动化动态内存管理从而无法解决 C 语言最严重的问题。后来，薄弱、不成熟的标准化努力，并不能限制各个不同编译器实现者之间的功能特征竞赛，C++变得过分精微复杂了。</p>
<p>对 C 的向上兼容；面向对象的平台；STL 和泛型等最前沿的技术工具——C++ 试图满足所有人的所有要求，但代价是 C++ 比任何一个程序员所能处理的复杂度都要高。C++ 的主要设让者已经承认他不指望任何一个程序员能够完全掌握 C++。</p>
<p>Unix 黑客对此并没有很好的反应：一段匿名但非常著名的评论这样描述“C++:狗被钉上软肢而变成的章鱼”。</p>
<p>C++ 最根本的问题还是在于它根本上只是另外一种传统语言。在标准模板库发明后，C++的内存管理控制有所改善，比 C 好得多，但仍然十分脆弱：除非代码仅使用对象，否则控制仍旧无用。对许多类型的应用而言，C++的 OO 特性并不重要，没有带来多少优势，陡增复杂度而已。</p>
<p>总结：C++的最佳之处是编译效率以及面向对象和泛型编程的结合。最糟之处是它非常怪异复杂，往往鼓励过分复杂的设计。</p>
<h2 id="14_4_3_Shell"><a class="header-anchor" href="#14_4_3_Shell">#</a>14.4.3 Shell</h2>
<p>简单 shell 程序的编写极其容易和自然。Unix 使用解释型语言的快速原型设计传统就始于 shell。</p>
<p>然而，随着程序规模越来越大，这些程序往往变得非常专用。部分 shell 语法（特别是其引用和声明语法规则）变得十分混乱。为了 shell 作为交互式命令行解释器的实用性而在设计中对语言部分做了折中，这些缺点就是这么来的。</p>
<p>现在 shell 只是为最简单的包装器(那些语言使用在包装器上是大材小用)和系统启动时的初始化脚本而保留。复杂的 shell 脚本经常产生可移植性问题，主要原因并不在于 shell 本身而在于 shell 使用了某些它假定存在的程序。</p>
<p>总结：shell 的最佳之处在于书写小型脚本非常自然快捷。最糟之处在于大型 shell 脚本必须依靠大量辅助命令，而这些辅助命今不一定在所有日标机器上都表现一致甚至不一定存在。要在大型 shell 脚本中分析依赖关系并不容易。</p>
<h2 id="14_4_6_Python"><a class="header-anchor" href="#14_4_6_Python">#</a>14.4.6 Python</h2>
<p>Python 的语法介于 C 语言和 Modula 系列语言之间，但有个非常罕见的特征，即代码块结构实际上用缩进来控制。</p>
<p>Python 语言的设计是非常于净优雅，具有非常出色的模块化特性。它提供了设计者用面向对象风格编码的可能，但并不把这个选择强加于设计者(可以用更加经典的类 C 方式编码）。</p>
<p>Python 在纯执行速度方面无法同 C 或 C++竞争(尽管在现今快速处理器上应用混合语言策略使这点已经相对不那么重要)。实际上，人们通常认为 Python 是主要脚本语言中效率最低、速度最慢的语言，这是它为运行期类型多态付出的代价。</p>
<p>然而当心，别因为这些原因而拒绝 Python，Python 能够提供的性能实际上已经满足人多数应用程序，即使那些似乎需要更好性能的程序通常也受到网络等待或磁盘等待等外部延时的限制，从而完全抵消了 Python 解释型开销产生的影响。</p>
<p>总结：Python 的最佳之处在于它鼓励清晰、易读的代码，易学易用，又能够扩展到大型项目。最糟之处在于，不仅相对于编译语言，而且相对于其它脚本语言，它也是效率低下、速度缓慢的。</p>
<h2 id="14_4_7_Java"><a class="header-anchor" href="#14_4_7_Java">#</a>14.4.7 Java</h2>
<p>Java 编程语言的设计目标是“write once, run anywhere（一次编写，到处运行）”并且支持网页中嵌入交互程序(即 applets)，可在任一个浏览器中运行。由于其所有者 Sun Microsystems 的一系列技术和战略失误，Java 没有实现这两个最初的设计目标。但它在系统编程和应用编程方面仍然十分强大，足以挑战 C 和 C++。</p>
<p>尽管远比 C++ 小巧简单，但 Java 设计非常聪明地抓住了自动管理内存的巨大优势也抓住了支持 OO 设计这一虽小却并非不重要的优点。Java 保留了大量的类 C 语法，大多数程序员对此感觉非常舒服。它也包括支持动态载入的 C 调用并支持在 C 中把 Java 作为嵌入语言调用。Sun 公司在网上提供良好 Java 文档的工作完成得非常出色，这一点作用也不可小觑。</p>
]]></content>
      <tags>
        <tag>设计模式</tag>
        <tag>编码规范</tag>
      </tags>
  </entry>
  <entry>
    <title>《Unix 编程艺术》 第十五章 工具</title>
    <url>/di_15_zhang_gong_ju%EF%BC%9Akai_fa_de_zhan_shu/</url>
    <content><![CDATA[<h1 id="15_4_make：自动化编译"><a class="header-anchor" href="#15_4_make：自动化编译">#</a>15.4 make：自动化编译</h1>
<h2 id="15_4_3_通用生成目标"><a class="header-anchor" href="#15_4_3_通用生成目标">#</a>15.4.3 通用生成目标</h2>
<p>关于通用生成目标应该表示什么，以及它们该如何命名已经有了一组良好的约定。遵从这些会让自己的 makefile 更容易理解和使用：</p>
<ul>
<li>
<p>all： 生成工程中所有可以执行者。通常全部产品并没有明确的定义;往往指工程中高阶的目标文件(并且，并非偶然地，常常有文档说明会包括哪些)。它通常应该是 makcfile 的第一个生成目标，因此它往往是开发者不带参数键入 make 就执行的那一个</p>
</li>
<li>
<p>test： 运行程序的自动测试套件，典型地，包括一组单元测试(Unit Test)来查找递归 bug，或是其它在开发过程中偏离预期行为的误差。“test”目标也可以由软件的最终用户来确保安装程序能够正常工作。</p>
</li>
</ul>
<ul>
<li>clean：删除 make a11 时产生的所有文件(例如二进制可执行文件和目标文件)。make clean 应该将软件的编译过程重置到良好的初始状态。</li>
</ul>
<h1 id="15_5_版本控制系统"><a class="header-anchor" href="#15_5_版本控制系统">#</a>15.5 版本控制系统</h1>
<h2 id="15_5_1_为什么需要版本控制"><a class="header-anchor" href="#15_5_1_为什么需要版本控制">#</a>15.5.1 为什么需要版本控制</h2>
<p>如果改变了代码却发现并不可行，如何恢复到一个已知的良好版本?如果回归是困难的或不可靠的，改变代码就太过冒险(有可能会崩掉整个项目，或者为自己凭空增加许多小时的痛苦工作)</p>
<p>几乎同样重要的是变化追踪。知道代码已经发生了改变，但知道为什么吗？稍后再看它们却很容易就忘记了改变的原因。如果项目存在合作者，又如何知道在自己不注意时合作者改变了什么，另外，每个修改该由谁负责?</p>
<blockquote>
<p>常常令人惊奇地发现，即使没有合作者，问问自己从上一个已知的良好版本后改变了什么也非常有用。这也常常会揭露不必要的改变，例如被遗忘的调试码，我现在在检入 (check in)变化前，一般就会做这项工作。<br>
—— Henry Spencer</p>
</blockquote>
<h1 id="15_6_运行期调试"><a class="header-anchor" href="#15_6_运行期调试">#</a>15.6 运行期调试</h1>
<p>只要拥有超过一星期编程经验的人都会知道，让程序符合正确的语法是调试中相对容易的部分。困难的是在这之后，需要了解为什么语法正确的程序并不如期望的那样运行。</p>
<h1 id="15_7_性能分析"><a class="header-anchor" href="#15_7_性能分析">#</a>15.7 性能分析</h1>
<p>作为通用法则程序 90%的执行时间都耗费在 10%的代码上。性能分析软件（Profilers）可以帮助确定那 10%抑制程序速度的区域。这可以让程序跑得更快。</p>
<p>但在 Unix 传统中，profiler 有个更为重要的功能。它能够让人不去优化其余 90%的代码。这很棒，并不仅仅由于这样节省了工作。其实不去优化余下 90% 代码真正有价值的效应是降低了整体复杂度，减少了 bug。</p>
<p>做好设计，首先考虑什么是正确的，然后再调整效率。</p>
<h1 id="15_8_使用_Emacs_整合工具"><a class="header-anchor" href="#15_8_使用_Emacs_整合工具">#</a>15.8 使用 Emacs 整合工具</h1>
<h2 id="15_8_4_Emacs_和_Profiling"><a class="header-anchor" href="#15_8_4_Emacs_和_Profiling">#</a>15.8.4 Emacs 和 Profiling</h2>
<p>别蛮干—这会浪费时间和生产力。如果发现在低层次的机械开发部分花费了太多时间的话，先站住。应该运用 Unix 折学。使用工具自动化或半自动化地完成任务。</p>
<p>然后，作为对所有继承的回报，将自己的解决方案作为开源软件放置在互联网上帮助把程序员同行们从蛮千中解放出来。</p>
]]></content>
      <tags>
        <tag>设计模式</tag>
        <tag>编码规范</tag>
      </tags>
  </entry>
  <entry>
    <title>《Unix 编程艺术》 第十七章 可移植性</title>
    <url>/di_17_zhang_ke_yi_zhi_xing%EF%BC%9Aruan_jian_ke_yi_zhi_xing_yu_zun_xun_biao_zhun/</url>
    <content><![CDATA[<p>移植性一直是 Unix 的主要优势。Unix 程序员往往设想硬件是易变的，只有 Unix API 本是稳定的。</p>
<p>Unix 程序员往往尽量避免软件依赖于某种特殊易逝的技术， 而严谨地遵循开放标准。这<br>
种考虑可移植性的编码习惯在 Unix 传统中根深蒂固，甚至应用于那些一次性小型单用途<br>
的代码中。</p>
<p>可移植性最直接的效益是工具和应用程序无需每隔几年就重写，因为 Unix 软件比起原生的硬件平台来得长久，这是再正常不过的。</p>
<p>间接的益处并不明显但可能更为重要。可移植性的戒律往往在架构、接口和实现上施加了一种简单化的影响。这既提高了项目成功的几率也降低了生命期的维护成本。</p>
<h1 id="17_2_Unix_标准"><a class="header-anchor" href="#17_2_Unix_标准">#</a>17.2 Unix 标准</h1>
<h2 id="17_2_3_开源世界的_Unix_标准"><a class="header-anchor" href="#17_2_3_开源世界的_Unix_标准">#</a>17.2.3 开源世界的 Unix 标准</h2>
<p>大量的 Unix 发布者—随着 Linux 发布市场的统一，越来越清楚真正的问题是时间变化率。API 是稳定的，但是系统管理文件的预期位置、实用程序以及用户邮箱名和日志文件的前缀路径等常常发生变化。</p>
<h1 id="17_3_IETF_和_RFC_标准化过程"><a class="header-anchor" href="#17_3_IETF_和_RFC_标准化过程">#</a>17.3 IETF 和 RFC 标准化过程</h1>
<p>在 IETF 传统中，标准必须来自于一个可用原型实现的经验——但是一旦成为标准，同标准不一致的代码就被认定是不合规范的，必须无情地抛弃。</p>
<p>不幸地是，这并不是标准通常发展的方式。计算机历史充满了许多这样的例子，技术标准是别有企图研究的最糟糕特征与黑暗密室政治结合的产物一一这样产生的规格说明在任何曾经的实现中都找不到踪影。更糟糕的是，许多规范不是严苛得无法实际实现，就是说明不够充分，解决的问题远不如产生的困惑多。这些规范随之被塞给软件商，它们如果发现什么地方不易实现，就忽略掉标准。</p>
<p>IETF 的哲学已经被概括为著名的“我们反对国王、总统和投票。我们信任大致的共识和可运行代码”。</p>
<h1 id="17_4_规格_DNA，代码_RNA"><a class="header-anchor" href="#17_4_规格_DNA，代码_RNA">#</a>17.4 规格 DNA，代码 RNA</h1>
<p>IETF 传统反复教导我们将代码作为标准的从属物来思考。正是标准让程序可以协作，将各项技术结合起来成为比部分之和更大的整体。</p>
<p>在最好的 Unix 实践中，程序的文档就近似于规范主体的“提议标准”，需要不断修正订正。</p>
<blockquote>
<p>以考虑周全的规格说明来驱动开发可能会引起“bug 还是功能”的小小争论;但没有正确实现规格说明的系统就是破损不全的，必须得到修正。<br>
一个在 Bellevue 以东一家小公司工作的朋友奇怪，Linux 应用程序开发者为什么可以随着应用程序发布版本同步地进行 OS 改动。在那个公司里，主要的系统级 API 频繁改动以容纳一些古怪念头，所以基本的 OS 功能必须常常随着每个应用程序一起发布。<br>
我向他描述了规格说明所具有的威力以及实现应当如何遵从规格，然后接着断言，如果一个应用程序按接口文档得到一个非预期的结果，那么不是违反了规格，就是发现了 bug。他认为这个观念非常令人吃惊。<br>
分辨这类 bug 再简单不过了，只要检查接口实现是否违反了规格。当然，如果有实现的源码会更简单。<br>
—— Keith Packard</p>
</blockquote>
<h1 id="17_5_可移植性编程"><a class="header-anchor" href="#17_5_可移植性编程">#</a>17.5 可移植性编程</h1>
<p>软件可移植性通常是准空间问题：代码可以从其诞生的环境移到别的硬件和软件平台吗？但是几十年的 Unix 经验告诉我们时间上的持久性同样重要，甚至更重要。软件的未来如果可以详细地预测，最好现在就来预测——然而，在可移植性编程中，我们应该尝试考虑选定最可能持续的软件环境特征作为构建软件的基础，同时要避免不久的将来就可能消亡的技术。</p>
<h1 id="17_7_可移植性、开放标准以及开放源码"><a class="header-anchor" href="#17_7_可移植性、开放标准以及开放源码">#</a>17.7 可移植性、开放标准以及开放源码</h1>
<p>IETF 自从大约 1997 年前后，愈发抵制连一个开源基准实现都没有的 REC 成为预备标准将来与某标准是否一致，似乎愈发有可能以“是否同已经得到标准作者们认可的开源实现相一致（或者完全使用该实现）”来判定。</p>
<blockquote>
<p>暗含的意思就是，成为标准的最好办法就是发布一个高质量的开源实现<br>
Henry Spencer</p>
</blockquote>
<p>最后,确保代码移植性最有效的一个环节就是不要依赖于专有技术。永远不会知道所依赖的闭源库 / 工具 / 代码生成器或网络协议何时会结束生命，接口何时会以某种非向后兼容的方式改变，从而崩溃掉已有的项目。而使用开源代码，即使前沿版本的改变方式足以崩溃已有的项目，也有前行之路：因为可以获取源码，如果需要，就可以向前移植项目到新的平台。</p>
]]></content>
      <tags>
        <tag>设计模式</tag>
        <tag>编码规范</tag>
      </tags>
  </entry>
  <entry>
    <title>《Unix 编程艺术》 第十六章 重用</title>
    <url>/di_16_zhang_zhong_yong%EF%BC%9Alun_bu_yao_zhong_xin_fa_ming_lun_zi/</url>
    <content><![CDATA[<p>不愿做不必要的工作是程序员的一大美德。</p>
<p>和其它耗在软件开发的花费比起来，时间无疑是最宝贵和最有价值的: 所以相应地，该耗费在解决新问题，而不是对那些已存在确切解决方案的问题老调重弹。这种态度对于开发投入来说，无论是在人员资本的“软”含义，还是在投资经济收益的“硬”含义都可以收到最好的回报。</p>
<blockquote>
<p>重新发明轮子之所以糟糕不仅因为浪费时间，还因为它浪费的时间往往是平方级。走捷径往往产生粗糙、未经思考的版本，长期而言这是假性节约，但通过这种方式来节省重新发明时间的诱惑几乎总是无法抵抗的。<br>
–Henry Spencer</p>
</blockquote>
<p>Unix 的经验是，养成良好的习惯，尝试通过最少的新发明，组合现有组件以形成原型，而非匆忙地编写独立的、只能使用一次的代码。</p>
<h1 id="16_1_猪小兵的故事"><a class="header-anchor" href="#16_1_猪小兵的故事">#</a>16.1 猪小兵的故事</h1>
<p><a href="/zhu_xiao_bing_de_gu_shi">猪小兵的故事</a></p>
<h1 id="16_2_透明性是重用的关键"><a class="header-anchor" href="#16_2_透明性是重用的关键">#</a>16.2 透明性是重用的关键</h1>
<p>猪小兵的多数麻烦（也意味着大规模质量问题）归根结底是透明性一一或者更确切地说，是缺乏透明性。</p>
<p>无法修正不通内情的东西。实际上，任何具有非平凡 API 的软件如果无法深入肌理，都无法被正确的使用。</p>
<p>只有文档，不仅在实践上不足，在原则上同样不够：文档并不能传达代码具现的所有细微差别之处。</p>
<p>有了源码，可以装备程序来进行衡测，可以通过编译来进行调试，这样在晦涩模糊的情况下就更容易探询程序的行为。而如果需要改变程序的行为，当然也可以做到。</p>
<p>需要源码还有另外一个重要的原因。Unix 程序员在几十年中学到了“只有变化才是永恒”，的经验，而源码是可以永续的。</p>
<p>源码是必需的，因为即使不想或不需要改动软件，可能还得在新的环境中重新编译以保证它能继续运行。</p>
<p>透明性的重要，以及代码遗留问题，是要求重用代码开源以供检验和修改的两个理由。</p>
<h1 id="16_3_从重用到开源"><a class="header-anchor" href="#16_3_从重用到开源">#</a>16.3 从重用到开源</h1>
<p>软件开发者希望他们使用的代码是透明的。更进一步，他们在换工作时不希望失去他们的工具包以及他们的专有经验。他们厌倦了成为受害者，腻烦了被生硬的工具和知识产权壁垒弄得灰心丧气，受够了不断地重新发明轮子。</p>
<p>这些就是开放源码的动力，从猪小兵痛苦的初步重用经历中产生的动力。这其中涉及了自我意识，设计最好的实践需要情感的投入，而不是冷漠无聊的过程。软件开发者同其它任何类型的工匠和技师一样;他们想要成为艺术家，这并不是什么私密。他们有艺术家的动力和需求，也有拥有听众的欲望。他们不仅仅希望重用代码，他们也希望自己的代码得到重用。这种势在必行的意念驱动，超越和颠覆了任何短期经济目标的达成，也不是闭源软件生产所能够满足的。</p>
<h1 id="16_4_生命中最美好的就是“开放”"><a class="header-anchor" href="#16_4_生命中最美好的就是“开放”">#</a>16.4 生命中最美好的就是“开放”</h1>
<p>来自 Unix 世界以外的人们（特别是非技术人员）往往倾向于认为开源（或“自由”）软件必然比商业软件差，是假冒伪劣的，不可靠的，带来的麻烦只会比所能免除的更多。</p>
<h3 id="为什么开源软件很可能产出质量特别高的软件"><a class="header-anchor" href="#为什么开源软件很可能产出质量特别高的软件">#</a>为什么开源软件很可能产出质量特别高的软件</h3>
<p>但这遗漏了重要一点：一般来说，编写开源软件的人都很在乎它，也需要它，自己使用而且通过发布这个软件在同行中赢得个人声誉。他们的时间也往往更少地耗费在会议、反馈设计更改或是各种官僚的开销中。他们也因此具有更强的动力和更好的立场来完成卓越的工作，远远超过那些薪水的奴隶。</p>
<p>开源用户社区（那些同行）不会羞于抓 bug，而且他们的标准很高。发布不够格软件的作者会承受许多的社会压力来修正或撤回代码，如果需要的话还能得到许多专家级的帮助。结果，成熟的开源软件包一般都是高质量的而且常常在功能上比任何专有等价物都要高级。这些开源软件或许看起来并不漂亮，想看懂文档或许也不容易，但其至关重要的部分通常都会工作得相当漂亮。</p>
<p>在同行评审效应之外，另外一个可以推测出质量上佳的理由是：在开源世界的开发者，从来不会受最终期限的压迫，不会一闭眼、一拍脑门就发布软件。因此开源实践同其余地方的一个区别就是，1.0 级别的版本实际上意味着软件可以使用了。事实上，0.90 或者更高的的版本号就相当可靠，表明代码已经是成品了，但是开发者还是不敢拿这个软件来赌自己的声誉。</p>
<h3 id="如何评价一个开源软件是否可靠"><a class="header-anchor" href="#如何评价一个开源软件是否可靠">#</a>如何评价一个开源软件是否可靠</h3>
<p>评估开源软件包的方法是阅读其文档和快速浏览它的部分代码。如果所见的代码编写恰当，文档完备，那么鼓励使用。如果能够证明软件包已经有些年头并且存在实质具体的用户反馈，就可以断定它是相当可靠的（无论如何还是测测为佳）。</p>
<p>在 README 文件以及项目新闻或源码发布历史文件中，所提到的除原作者之外的人数，是度量成熟度以及用户反馈量大小的好方法。很多人呈报修正和补丁本身就是良好的表征，既表明存在一个相当重要的用户群保持着对软件作者的敦促和警醒，也表明软件维护者是恪守职责的，能够对反馈作出响应并订正错误。当然，这也是一个暗示，如果早先的代码是充满 bug 的雷区，不用等到最近的爆炸，早就有受惊的人群踩得响噼里啪啦的了。</p>
<h1 id="16_6_使用开源软件的问题"><a class="header-anchor" href="#16_6_使用开源软件的问题">#</a>16.6 使用开源软件的问题</h1>
<p>文档通常是个更严重的问题，许多高质量的开源软件包的应用范围和它们在技术上的领先不相协调，就是因为它们的文档很糟糕。Unix 传统鼓励了太过专门的文档风格，这种风格 （尽管或许会在技术上涵盖软件包所有的功能特征）往往假设其阅读者也相当熟悉应用程序的定义域，并且阅读得非常仔细。</p>
]]></content>
      <tags>
        <tag>设计模式</tag>
        <tag>编码规范</tag>
      </tags>
  </entry>
  <entry>
    <title>《Unix 编程艺术》 第十八章 文档</title>
    <url>/di_18_zhang_wen_dang%EF%BC%9Axiang_wang_luo_shi_jie_chan_shi_dai_ma/</url>
    <content><![CDATA[<blockquote>
<p>我从没见过一个愿意阅读 17000 页文档的人，如果有，我会杀了他，这样人的基因必须抹去<br>
—— Joseph Costello</p>
</blockquote>
<h1 id="18_1_文档概念"><a class="header-anchor" href="#18_1_文档概念">#</a>18.1 文档概念</h1>
<p>所见即所得（WYSIWYG）的文档程序同以标记为中心的工具之间的差异。</p>
<ul>
<li>大多数的桌面出版程序和字处理器都属于前者:：具备图形用户界面、键入的文字可以真接插入到文档在屏幕上的表示之中，并尽可能地接近最终的打印版本。</li>
<li>在以标记为中心的系统中，相对应地，主文本通常就是包含明确可见控制标记的纯文本，跟期望的输出完全不同。标记的源文件可以由普通的文本编辑器修改，但必须传入某个格式器程序来渲染输出以供打印或显示。</li>
</ul>
<p>实话实说，WYSIWYG 的文档处理器并不真正所见即所得。大多数程序的界面，并没有真正消除屏幕显示和打印输出的差异，只是让你看不出来而已。这样做其实违反了最小立异原则：界面的可视部分鼓励将程序作为打字机使用，但实际上并不能这么用，而你的输入又时不时地产生无法预料或是非期望的结果。</p>
<p>再实事求是点，WYSIWYG 系统实际依赖的是标记码，只不过额外支付了巨大的努力以期将此隐藏在一般使用中。这又违反了透明原则：因为无法了解所有的标记，就难以标记位置错误的损坏文档。</p>
<h1 id="18_2_Unix_风格"><a class="header-anchor" href="#18_2_Unix_风格">#</a>18.2 Unix 风格</h1>
<h2 id="18_2_1_大文档偏爱"><a class="header-anchor" href="#18_2_1_大文档偏爱">#</a>18.2.1 大文档偏爱</h2>
<p>对不透明二进制文档格式的厌烦情绪——尤其是不透明的专有二进制格式——也在拒绝 WYSIWYG 工具的过程中起到了一定作用。</p>
<p>另一方面，PostScript（图像打印机的现行控制语言标准）刚可以使用，Unix 程序员就投入了极大的热情；这门语言整洁优美地符合 Unix 传统的域专用语言。现代的开源 Unix 系统都有优秀的 PostScript 和可移植文档格式（Portable Document Format，PDF）工具。</p>
<h2 id="18_2_2_文化风格"><a class="header-anchor" href="#18_2_2_文化风格">#</a>18.2.2 文化风格</h2>
<p>Unix 手册页传统上也包含一个叫做 BUGS 的部分。在其它地方，技术作者为了让软件产品看起来更漂亮，常常省略或一笔带过那些己知的 bug。</p>
<p>而在 Unix 文化中，同行彼此瓦相事无巨细地揭露软件的已知缺陷而用户也认为一个简单但详细的 BUGS 部分是高质量软件的表征。</p>
<p>隐瞒了 BUGS 部分或是改头换面为诸如 LIMITATIONS 或 ISSUES 或 APPLICATIONUSAGE 等轻描淡写词语、从而打破这个约定的商业 Unix 发布版本，无一例外地走上了不归之路。</p>
<h1 id="18_3_各种_Unix_文档格式"><a class="header-anchor" href="#18_3_各种_Unix_文档格式">#</a>18.3 各种 Unix 文档格式</h1>
<h2 id="18_3_2_Tex"><a class="header-anchor" href="#18_3_2_Tex">#</a>18.3.2 Tex</h2>
<p>TEX 是个威力强大的排版程序，如同 Emacs 编辑器一样，最初也来自 Unix 文化之外，但现在却在 Unix 文化中落地生根。它是由著名的计算机科学家 Donald Knuth 在 1970 年代晚期发明的，那时的他腻烦了印刷排版的一一特别是数学方面的一一排版质量。</p>
<p>人们通常也不需要手工编写大量原始的 TEX 宏：而是使用宏命令包以及各式各样的辅助程序。一个特别的宏命今包，LATEX，几乎无所不能，而且大多数人所谓在使用 TEX 创作时实际上几乎总是指用 LATEX 编写。</p>
<p>TEX 一个通常用户不可见的重要用法就是，其它文档处理工具宁愿生成 LATEX 来转换成 PostScrint，而不是尝试自己生成 PostScript。</p>
<h1 id="18_6_编写_Unix_文档的最佳实践"><a class="header-anchor" href="#18_6_编写_Unix_文档的最佳实践">#</a>18.6 编写 Unix 文档的最佳实践</h1>
<p>数量多不会被认为是质量高。尤其是，决不要因为害怕别人看不懂而省略功能细节，也决不要为了面子而不对存在的问题提出警示。不愿坦露问题才会损害信誉和用户，坦白的问题则不会。</p>
<p>如果项日规模比较大，应该发布三种不同的文档：手册页作为参考资料，教程手册和常见问题解答列表。</p>
<p>手册页应该为传统的 Unix 用户以传统风格的命令引用形式早现。考虑非技术用户入门手册应该多用全称，少用缩写。而 FAQ 应该随着软件支持群体对软件常用问题及如何回答的深入了解而不断改进。</p>
]]></content>
      <tags>
        <tag>设计模式</tag>
        <tag>编码规范</tag>
      </tags>
  </entry>
  <entry>
    <title>《Unix 编程艺术》 第十九章 开放源码</title>
    <url>/di_19_zhang_kai_fang_yuan_ma%EF%BC%9Azai_unix_xin_she_qu_zhong_bian_cheng/</url>
    <content><![CDATA[<p>当 Unix 实践最接近开放源码时，就欣欣向荣，反之则停滞不前。</p>
<h1 id="19_1_Unix_和开放源码"><a class="header-anchor" href="#19_1_Unix_和开放源码">#</a>19.1 Unix 和开放源码</h1>
<p>开源开发的规则很简单:</p>
<ol>
<li>源码公开。别隐藏秘密。公开代码以及产生代码的过程。鼓励第三方的同行复审确保其他人能够自由地修改和重新发布代码。尽可能地发展合作开发者。</li>
<li>尽早发布，经常发布。快速的发布节奏意味着反馈迅速而有效。每次递进发布间隔越小，回应真实世界反馈的修改过程就越容易。</li>
<li>给贡献以表扬。如果不能够给合作开发者以物质奖励，就给予精神表扬。即使可以给予物质的奖励，也不要忘记人们往往是为展示才华而不是为钱努力工作。</li>
</ol>
<blockquote>
<p>规则 2 的必然推论就是，单一发布不应该视为重大的事件，无需伴随太多的附带许诺和准备。将发布过程无情地精简非常重要，这样就不再为经常发布而感到痛苦。在发布准备期，其余工作都必须停止的安排是个可怕的错误(值得一提的是，如果使用 CVS 或者类似的版本控制，处于准备期的发布应该同主干开发线分开，这样就不至于阻塞主线开发过程。)总的来说，不要把发布当作什么特别的大事;而应该当作是例行公事。<br>
—— Henry Spencer</p>
</blockquote>
<p>牢记:频繁发布的原因是为了缩短和加速同用户和开发者间的反馈循环。因此，精工细作，等一切完美了才发布的想法是要不得的。不要许太多愿。一步一步地来，承认和公布现有的 bug，并有信心随着时间的推移，一定会达到完美。发布点多一点儿不是坏事，不必为版本号的增加而烦恼。</p>
<p>抛弃秘密开发的习惯，转而支持过程的透明化和同行复审是炼金术成为化学学科最关键的一步。同样你也开始发现，开源开发标志着软件开发终于长成为一门学科。</p>
<h1 id="19_2_与开源开发者协同工作的最佳实践"><a class="header-anchor" href="#19_2_与开源开发者协同工作的最佳实践">#</a>19.2 与开源开发者协同工作的最佳实践</h1>
<h2 id="19_2_1_良好的修补实践"><a class="header-anchor" href="#19_2_1_良好的修补实践">#</a>19.2.1 良好的修补实践</h2>
<p>代码的质量很难判断，所以开发者往往通过提交的质量来评估补丁，在提交者的风格和交流行为中寻找线索——该提交者是否设身处地为他们着想，是否知道评估和合并新的补丁究竟该怎样。</p>
<p>这是鉴定代码质量相当可靠的方法。在许多年处理来自数以百计陌生人补丁的过程中，我很少看到一个考虑周全、尊重我的时间的补丁会是技术上的赝品。反过来看，经验告诉我们，看起来马马虎虎或是打包很疏懒的补丁往往实际上就是赝品。</p>
<h3 id="19_2_1_3_不要包含可生成文件的补丁"><a class="header-anchor" href="#19_2_1_3_不要包含可生成文件的补丁">#</a>19.2.1.3 不要包含可生成文件的补丁</h3>
<p>在发送补丁之前需通览一遍，对于一旦维护者采用补丁、重新 make 后就能重新生成的文件，其补丁段应予删除。</p>
<h3 id="19_2_1_6_在补丁中包含文档"><a class="header-anchor" href="#19_2_1_6_在补丁中包含文档">#</a>19.2.1.6 在补丁中包含文档</h3>
<p>针对改动做好文档体现了一些好习惯。首先，已经为试图说服的维护者设身处地考虑过了。其次，表明对改动后的效果了如指掌，可以向其余不能查看代码的人解释清楚。第三，表示了对软件最终用户的关心。</p>
<p>良好的文档常常是区分“可靠的贡献”和“匆忙而邋的改动”最显著的特征。</p>
<h3 id="19_2_1_7_在补丁中包含解释"><a class="header-anchor" href="#19_2_1_7_在补丁中包含解释">#</a>19.2.1.7 在补丁中包含解释</h3>
<p>补丁应该包含一份说明，来解释为什么补丁是必须和有用的。这个说明并不直接给软件用户而是给接受补丁的维护者。</p>
<p>正确的态度非常有帮助，是对维护者时间的尊重，也是从容而谦逊的自信。表现出对所修补的代码充分理解，展示对维护者问题的认同，这些都是有益的。</p>
<p>一些经验丰富的开发者所发送的各种解释示例：</p>
<ul>
<li>“我已经发现代码中有两个问题，X 和 Y。我改掉了 X，但是我并没有试图去解决 Y 问题，因为我对牵涉到的代码还不理解。”</li>
<li>“修改了一个当输入过长时的 coredump。我在修改的时候，试图寻找另外的溢出错误。我发现有一个可能在 blarg.c 中，在第 666 行附近。你能确定在每个传输中发送端产生的字节不会多于 80?”</li>
<li>“你是否已经考虑使用 Foonly 算法来解决这个问题?在<a href="http://www.example.com/~jsmith/foonly.html">http://www.example.com/~jsmith/foonly.html</a>处有个好的实现。”</li>
<li>“补丁解决了当前的问题，但我意识到内存分配被不恰当地复杂化了。在我这里可以工作，但在发布前你应该进行重负荷测试。</li>
<li>“这可能太过于花哨，但无论如何我还是提交了。也许你会知道一个实现这种功能的更简洁的方法。”</li>
</ul>
<h2 id="19_2_3_良好的开发实践"><a class="header-anchor" href="#19_2_3_良好的开发实践">#</a>19.2.3 良好的开发实践</h2>
<h3 id="19_2_3_6_推荐的_C_C_移植性实践"><a class="header-anchor" href="#19_2_3_6_推荐的_C_C_移植性实践">#</a>19.2.3.6 推荐的 C/C++ 移植性实践</h3>
<p>在移植层之外的任何地方，注意这条建议:</p>
<blockquote>
<p>#ifdef 和#if 是最后一招，这通常是思路不当、产品过度差异化，无理由“优化”或是无用垃圾聚集的先兆。在代码中，它们就是诅咒。GNU 的/usr/include/ stdio.h 就是典型的悲剧。<br>
-Doug Mcllroy</p>
</blockquote>
<p>在移植层 <code>#ifdef</code> 和 <code>#if</code> 的使用是允许的(如果控制得当)。在此之外，应该尽量限制使用，只用于有条件地触发 <code>#include</code>。</p>
<p>严格地坚持编码规范，代码的一致和干净优先级最高，而编码规范自身的细节倒远在其次。</p>
<h2 id="19_2_4_良好的发行制作实践"><a class="header-anchor" href="#19_2_4_良好的发行制作实践">#</a>19.2.4 良好的发行制作实践</h2>
<h3 id="19_2_4_3_尊重和遵从标准文件命名实践"><a class="header-anchor" href="#19_2_4_3_尊重和遵从标准文件命名实践">#</a>19.2.4.3 尊重和遵从标准文件命名实践</h3>
<p>这里是些标准的顶级文件名及其含义。当然，并不是每个发行版本都需要所有文件。</p>
<ul>
<li>README：最先被阅读的路标文件。</li>
<li>INSTALL：配置、编译和安装指导</li>
<li>Authors：项目贡献者列表(GNU 惯例)</li>
<li>NEWS：最近的项目新闻</li>
<li>HISTORY：项目历史。</li>
<li>CHANGES：修订版本之间重大更改的日志。</li>
<li>COPYING：项目许可证条款(GNU 惯例)。</li>
<li>LICENSE：项目许可证条款。</li>
<li>FAQ：项目常见问题解答的纯文本文档。</li>
</ul>
<h2 id="19_2_5_良好的交流实践"><a class="header-anchor" href="#19_2_5_良好的交流实践">#</a>19.2.5 良好的交流实践</h2>
<h3 id="19_2_5_4_提供项目邮件列表"><a class="header-anchor" href="#19_2_5_4_提供项目邮件列表">#</a>19.2.5.4 提供项目邮件列表</h3>
<p>通告列表应严格控制。通信量最多一月几条：这个列表的整体目标是，向希望知道某些重要事情何时发生的人们提供信息，但并不需要知道日常繁冗的细节。如果这个列表在他们的邮箱中开始带来严重的混乱，许多人会立刻取消订阅。</p>
]]></content>
      <tags>
        <tag>设计模式</tag>
        <tag>编码规范</tag>
      </tags>
  </entry>
  <entry>
    <title>《Unix 编程艺术》 第一章 哲学</title>
    <url>/di_1_zhang_zhe_xue/</url>
    <content><![CDATA[<h1 id="1_4_Unix_之失"><a class="header-anchor" href="#1_4_Unix_之失">#</a>1.4 Unix 之失</h1>
<p>最终的用户永远比操作系统设计人员更清楚他们究竟需要什么。</p>
<p>用错误的方法解决正确的问题，总比用正确的方法解决错误的问题好</p>
<h1 id="1_5_Unit_之得"><a class="header-anchor" href="#1_5_Unit_之得">#</a>1.5 Unit 之得</h1>
<h2 id="1_5_2_跨平台可移植性和开放标准"><a class="header-anchor" href="#1_5_2_跨平台可移植性和开放标准">#</a>1.5.2 跨平台可移植性和开放标准</h2>
<p>IEEE 早期定义的”可移植操作系统标准（Portable Operating System Standard, POS）“ 被社区为了读起来更像 Unix 而加了后缀变为 ”POSIX“。因为只有称之为 Unix API 等价物才能算是可移植操作系统标准比较可信的模型。</p>
<h2 id="1_5_5_从头到家的灵活性"><a class="header-anchor" href="#1_5_5_从头到家的灵活性">#</a>1.5.5 从头到家的灵活性</h2>
<p>许多操作系统自诩比 Unix 来的更”现代“，”友好“，它们漂亮外表的背后，却是以貌似精巧实则脆弱狭隘难用的编程接口，把用户和开发者禁锢在单一的界面方针下。在这样的操作系统中，完成系统任务很容易，而完成设计者没有预料到的需求，用户要么是无计可施，要么是痛苦不堪。</p>
<p>Unix 传统是让各个程序接口小巧，简洁和正交。整个 Unix 系统，容易的事还是那么容易，困难的事，至少是可能做到的。</p>
<h2 id="1_5_6_Unix_Hack_之趣"><a class="header-anchor" href="#1_5_6_Unix_Hack_之趣">#</a>1.5.6 Unix Hack 之趣</h2>
<p>充满痛苦的开发环境只会浪费劳动力和创造力；这样的环境会在无形之中耗费大量时间，资金，机会。</p>
<p>乐趣是一个符号，意味着效能，效率和高产。</p>
<h1 id="1_6_Unix_哲学基础"><a class="header-anchor" href="#1_6_Unix_哲学基础">#</a>1.6 Unix 哲学基础</h1>
<p>Doug Mcllroy （Unix 管道发明人，Unix 传统奠基人之一） 说：</p>
<ol>
<li>让每个程序做好一件事。如果有新任务，就重新开始，不要往原程序中加入新功能而搞得复杂</li>
<li>假定每个程序的输出都会成为另一个程序的输入，哪怕那个程序还是未知的。输出中不要有无关的信息干扰。</li>
<li>对拙劣的代码别犹豫，扔掉重写</li>
<li>优先使用工具而不是拙劣的帮助来减轻编程任务的负担。工欲善其事，必先利其器。</li>
</ol>
<div class="note info simple"><p>同样可以将 Doug Mcllroy 描述中的“程序”替换为“模块” 去理解。</p>
</div>
<p>Rob Pike（最伟大的 C 语言大师之一），在 《Notes on C Programming》从另一个不同的角度表述 Unix 的哲学：</p>
<ol>
<li>你无法判定程序会在什么地方耗费运行时间。瓶颈经常出现在想象不到的地方，所以别胡乱找个地方改代码，除非你已经证实那就是瓶颈所在。</li>
<li>在你没对代码进行估量，特别是没找到最耗时的那部分之前，别去优化速度。</li>
<li>花哨的算法在 n 很小时通常很慢，而 n 通常很小。除非你确定 n 总是很大，否则不要用花哨的算法（即使 n 很大，也优先考虑原则 2）。</li>
<li>花哨的算法比简单算法更容易出 Bug，更难实现。尽量使用简单的算法配合简单的数据结构。</li>
<li>编程的核心是数据结构，而不是算法。</li>
</ol>
<p><strong>Ken Thompson（Unix 最初版本的设计者和实现者，对 Pike 原则 4 做了强调）：拿不准就穷举</strong></p>
<p>Unix 的原则，可以概括为如下几点：</p>
<ol>
<li>模块原则：使用简洁的接口拼合简单的部件</li>
<li>清晰原则：清晰胜于机巧</li>
<li>组合原则：设计时考虑拼接组合</li>
<li>分离原则：策略同机制分离，接口同引擎分离</li>
<li>吝啬原则：除非确无它法，不要编写庞大的程序</li>
<li>透明性原则：设计要可见，以便审查和调试</li>
<li>健壮原则：健壮源于透明和简洁</li>
<li>表示原则：把知识叠入数据以求逻辑质朴而健壮。</li>
<li>通俗原则：接口设计避免标新立异。</li>
<li>缄默原则：如果一个程序没什么好说的，就沉默。</li>
<li>补救原则：出现异常时，马上退出并给出足够错误信息。</li>
<li>经济原则：宁花机器一分，不花程序员一秒。</li>
<li>生成原则：避免手工 hack，尽量编写程序去生成程序。</li>
<li>优化原则：雕琢前先要有原型，跑之前先学会走。</li>
<li>多样原则：绝不相信所谓的“不二法门”的断言。</li>
<li>扩展原则：设计着眼未来，未来总比预想来的块。</li>
</ol>
<h2 id="模块原则：使用简洁的接口拼合简单的部件"><a class="header-anchor" href="#模块原则：使用简洁的接口拼合简单的部件">#</a>模块原则：使用简洁的接口拼合简单的部件</h2>
<p>Brian Kernighan（Unix 小组的 3 号人物）曾经说过：“计算机编程的本质就是控制复杂度”。</p>
<p>排错占用了大部分的开发时间，弄出一个拿得出手的可用系统，通常与其说出自才华横溢的设计成果，还不如说是跌跌撞撞的结果。</p>
<p>要编制复杂软件而又不至于一败涂地的唯一方式就是降低其整体复杂度——用清晰的接口把若干简单的模块组合出一个复杂软件。如此一来，多数问题只会局限在某个局部，那么就还有希望对局部改进而不至于牵动全身。</p>
<h2 id="清晰原则：清晰胜于机巧"><a class="header-anchor" href="#清晰原则：清晰胜于机巧">#</a>清晰原则：清晰胜于机巧</h2>
<p>在写程序时，要想到你不是写给执行代码的计算机看的，而是给人——将来阅读维护源码的人，包括你自己——看的。</p>
<p>为了取得程序一丁点的性能提升就大幅度增加技术的复杂性和晦涩性，这个买卖做不得——这不仅仅是因为复杂的代码冗余滋生 bug，也因为它会使日后的阅读和维护工作更加艰难。</p>
<h2 id="组合原则：设计时考虑拼接组合"><a class="header-anchor" href="#组合原则：设计时考虑拼接组合">#</a>组合原则：设计时考虑拼接组合</h2>
<p>如果程序彼此之间不能有通信，那么软件就难免会陷入复杂度的泥淖。</p>
<p>Unix 传统极力提倡采用简单、文本化、面向流、设备无关的格式。…Unix 程序员偏爱这种做法并不是因为他们仇恨图形用户界面，而是因为如果程序不采用简单的文本输入输出流，他们就极难衔接。</p>
<h2 id="分离原则：策略同机制分离"><a class="header-anchor" href="#分离原则：策略同机制分离">#</a>分离原则：策略同机制分离</h2>
<p>策略和机制是按照不同你的时间尺度变化的，策略的变化要远远快于机制。</p>
<div class="note info simple"><p>可以将机制视作规则，策略则是在规则下实现目的的方式。</p>
<p>比如系统定义了消息机制，定义了消息的发送、接受、处理、返回</p>
<p>应用可依赖机制通过不同的策略实现不同的功能。</p>
</div>
<h2 id="简洁原则：设计要简洁，复杂度能低则低"><a class="header-anchor" href="#简洁原则：设计要简洁，复杂度能低则低">#</a>简洁原则：设计要简洁，复杂度能低则低</h2>
<p>程序员们都很聪明，常常以能玩转复杂东西和耍弄抽象概念的能力为傲，这一点无可厚非……但他们的设计能力大大超出他们的实现和排错能力，结果便是代价高昂的废品。</p>
<p>过度的复杂性往往来自于项目的要求，而这些要求常常基于当月的推销热点，而不是基于顾客的需求和软件实际能够提供的功能。许多优秀的设计被市场推销所需要的大堆大堆“特性清单”扼杀——实际上这些特性几乎从没用过。然后恶性循环开始了：比别人花哨的方法就是把自己变得更花哨。很快，庞大臃肿变成了业界标准，每个人都在使用臃肿不堪、bug 极多的软件，连软件开发人员也不敢敝帚自珍。</p>
<p>要避免这些陷阱，唯一的方法就是鼓励另一种软件文化，以简洁为美。</p>
<h2 id="吝啬原则：除非确无它法，不要编写庞大的程序"><a class="header-anchor" href="#吝啬原则：除非确无它法，不要编写庞大的程序">#</a>吝啬原则：除非确无它法，不要编写庞大的程序</h2>
<p>程序大了，维护起来就困难。由于人们对花费了大量精力才做出来的东西难以割舍，结果导致在庞大的程序中把投资浪费注定要失败或者并非最佳的方案上。</p>
<h2 id="健壮原则：健壮源于透明与简洁"><a class="header-anchor" href="#健壮原则：健壮源于透明与简洁">#</a>健壮原则：健壮源于透明与简洁</h2>
<p>让程序健壮的方法，就是让程序的内部逻辑更易于理解。要做到这一点主要靠 <code>透明化</code> 和 <code>简洁性</code>。</p>
<p>软件的透明性就是指一眼能看出是怎么回事。人们不需要绞尽脑汁就能够推断出所有可能的情况，那么这个程序透明的。</p>
<p>模块性是组织程序达到更简洁目的的一个方法。</p>
<h2 id="表示原则：把知识叠入数据以求逻辑质朴而健壮"><a class="header-anchor" href="#表示原则：把知识叠入数据以求逻辑质朴而健壮">#</a>表示原则：把知识叠入数据以求逻辑质朴而健壮</h2>
<p>数据要比编程逻辑更容易驾驭。如果要在复杂数据和复杂代码中选择一个，宁愿选择前者。在设计中，应该主动将代码的复杂度转移到数据之中去。</p>
<h2 id="通俗原则：接口设计避免标新立异"><a class="header-anchor" href="#通俗原则：接口设计避免标新立异">#</a>通俗原则：接口设计避免标新立异</h2>
<p>接口设计应该避免毫无来由的标新立异和自作聪明。</p>
<p>最小立异原则的另一面是避免表象相似而实际却略有不同。这会极端危险，因为表象相似往往导致人们产生错误的假定。所以最好让不同的事物有明显区别，而不要看起来几乎一模一样。 —— Henry Spencer</p>
<h2 id="缄默原则：如果一个程序没什么好说的，就保持沉默"><a class="header-anchor" href="#缄默原则：如果一个程序没什么好说的，就保持沉默">#</a>缄默原则：如果一个程序没什么好说的，就保持沉默</h2>
<p>行为良好的程序应该默默工作，决不唠唠叨叨，碍手碍脚。沉默是金。</p>
<p>设计良好的程序将用户的注意力视为有限的宝贵资源，只有在必要时才要求使用。</p>
<h2 id="补救原则：出现异常时，马上退出并给出足量错误信息"><a class="header-anchor" href="#补救原则：出现异常时，马上退出并给出足量错误信息">#</a>补救原则：出现异常时，马上退出并给出足量错误信息</h2>
<p>软件要尽可能从容地应付各种错误输入和自身的运行错误。但是，如果做不到这一点，就让程序尽可能以一种容易诊断错误的方式终止。</p>
<p>如果补救措施明明没有成功，却悄无声息地埋下崩溃的隐患，直到很久以后才显现出来，这就是最坏的一种情况。</p>
<p>“就算输入的数据很不规范，一个设计良好的程序也会尽量领会其中的意义，以尽量与别的程序协作；然后，要么响亮地倒塌，要么为工作链下一环的程序输出一个严谨干净正确的数据”—— Jonathan Postel（互联网主要架构者之一，第一个互联网 RFC 系列标准的编纂者）</p>
<h2 id="经济原则：宁花机器一分，不花程序员一秒"><a class="header-anchor" href="#经济原则：宁花机器一分，不花程序员一秒">#</a>经济原则：宁花机器一分，不花程序员一秒</h2>
<h2 id="生成原则：避免手工_hack，尽量编写程序去生成程序"><a class="header-anchor" href="#生成原则：避免手工_hack，尽量编写程序去生成程序">#</a>生成原则：避免手工 hack，尽量编写程序去生成程序</h2>
<h2 id="优化原则：雕琢前先得有原型，跑之前先学会走"><a class="header-anchor" href="#优化原则：雕琢前先得有原型，跑之前先学会走">#</a>优化原则：雕琢前先得有原型，跑之前先学会走</h2>
<p>”90% 的功能现在能实现，比 100% 的功能永远实现不了强“。</p>
<p>先给你的设计做个未优化，运行缓慢，很耗内存但正确的实现，然后进行系统的调整，寻找那些可能通过牺牲最小的局部简洁性而获得较大性能提升的地方。</p>
<p>借助原型化找出哪些功能不必实现，有助于对性能进行优化；那些不用写的代码显然无需优化。目前最强大的优化工具就是 delete 键。</p>
<div class="note icon-padding simple"><i class="note-icon fas fa-quote-left"></i><p>我最有成效的一天，就是扔掉了 1000 行代码 —— Ken Thompson（图灵奖获得者，GO 发明者）。</p>
</div>
<h2 id="多样原则：决不相信所谓_”不二法门“_的断言"><a class="header-anchor" href="#多样原则：决不相信所谓_”不二法门“_的断言">#</a>多样原则：决不相信所谓 ”不二法门“ 的断言</h2>
<p>设计一个僵化、封闭、不愿与外界沟通的软件，简直是一种病态的傲慢。</p>
<p>Unix 奉行的是广泛采用多种语言、开放的可拓展系统和用户定制机制。</p>
<h2 id="扩展原则：设计着眼未来，未来总比预想快"><a class="header-anchor" href="#扩展原则：设计着眼未来，未来总比预想快">#</a>扩展原则：设计着眼未来，未来总比预想快</h2>
<h1 id="1_7_Unix_哲学之一言以蔽之"><a class="header-anchor" href="#1_7_Unix_哲学之一言以蔽之">#</a>1.7 Unix 哲学之一言以蔽之</h1>
<p>KISS 原则： Keep It Simple, Stupid!</p>
<h1 id="1_9_态度也要紧"><a class="header-anchor" href="#1_9_态度也要紧">#</a>1.9 态度也要紧</h1>
<p>你必须相信，软件设计是一门艺术，值得你付出所有的智慧、创造力和激情。…………否则你就会在应该思考的时候急急忙忙跑去编程，你就会在该无情删繁就简的时候反而把问题复杂化——然后你还会反过来奇怪你的代码怎么会那么臃肿，那么难以调试。</p>
<p>要良好地运用 Unix 哲学，你应该珍惜你的时间决不浪费。一旦某人己经解决了某个问题，就直接拿来利用，不要让骄傲或偏见拽住你又去重做一遍。</p>
<p>永远不要蛮干：要多用巧劲，省下力气到需要的时候再用，好钢用在刀刃上。善用工具，尽可能将一切都自动化。</p>
]]></content>
      <tags>
        <tag>系统设计</tag>
        <tag>编码规范</tag>
      </tags>
  </entry>
  <entry>
    <title>《Unix 编程艺术》 第二十章 未来</title>
    <url>/di_20_zhang_wei_lai%EF%BC%9Awei_ji_yu_ji_yu/</url>
    <content><![CDATA[<h1 id="20_5_Unix_文化中的问题"><a class="header-anchor" href="#20_5_Unix_文化中的问题">#</a>20.5 Unix 文化中的问题</h1>
<p>在 2000 年，当花了三天时间参加了一个 Macintosh 开发者会议之后，我愈发清晰地意识到了更大的心理问题。沉浸在一个同 Unix 世界假设基础完全相反的编程环境中真是个给人启迪的经历。</p>
<p>Macintosh 程序员最为关心用户体验。他们是建筑设计师和装饰家。他们由外而内进行设计，首先就问“我们需要支持哪种交互?”，然后构建隐藏其后的程序逻辑来满足用户界面设计的需求。</p>
<p>这就会导致程序外观非常漂亮而内部结构脆弱摇摆。一个声名狼籍的例子，在 MacOs 9 以前的发布版本中，内存管理器有时对于那些退出但仍占用内存的程序，竟然要求用户手动回收内存。Unix 支持者本能地反感这类病态设计：他们不能理解 Macintosh 的人怎么能够忍受这些。</p>
<p>比起来，Unix 程序员先考虑基础设施。我们是水管工和砖瓦匠。我们的设计由里而外，构建强大的引擎以解决抽象定义问题（例如 “我们如何通过不可靠的链接和硬件而获得从 A 点到 B 点的可靠信息包流交换”)。然而引擎外，我们的包装难看，甚至接口常常相当丑陋。。Macintosh 人也本能地反感这种病态设计，他们也不能理解 Unix 的人怎么能够忍受这些。</p>
<p>两种设计哲学都有正确的一面，但是两个阵营却难以理解彼此的立场。Unix 开发者典型的反应就是把 Macintosh 软件当作是给无知人的绣花枕头而抛弃，然后继续构建能够吸引其它 Unix 开发者的软件。如果终端用户并不喜欢，那是终端用户的不对，他们了解多了之后，会回来的。</p>
<p>在 2003 年，在我们的态度中存在深深的矛盾——精英和大众之间的摩擦。我们希望影响和改变这世界 92%的人，对他们来说，计算机就意味着游戏、多媒体、漂亮的 GUI 界面… 我们正花费主要努力在诸如 GNOME 以及 KDE 等设计来给予 Unix 美妙外观的项目。但在内心深处，我们仍旧认为自己是精英，不能或不想去甄别或是倾听以王大婶为代表的普通用户需求。</p>
<p>对于非技术最终用户，我们构建的软件往往不是令人迷惑无法理解，就是样子难看故意屈尊似的，又或两者兼有。即使我们怀着尽可能高的热情尝试去做对用户友好的事，却可悲地前后矛盾。对于完成这份工作，我们从旧学派 Unix 继承的许多态度和反应都是不恰当的。即使我们想要倾听或帮助王大婶，我们也不知道如何去做一一我们设计了我们的服务类目、关心她并提供“解决方案”，但她却发现这同她存在的问题一样可怕。</p>
<p>我们在文化上面临的巨大挑战是，… 我们是否能够承认，不仅是在思想上，也是在日常实践的施行上，承认 Macintosh 支持者也抓住了要点。他们的要点也是基于普遍实际，而非 Mac 专用方式。… 交互设计也包含了大量坚实的真理，需要为每个 Unix 程序员所知道。</p>
]]></content>
      <tags>
        <tag>设计模式</tag>
        <tag>编码规范</tag>
      </tags>
  </entry>
  <entry>
    <title>《Unix 编程艺术》 第二章 历史</title>
    <url>/di_2_zhang_li_shi%E2%80%94%E2%80%94shuang_liu_ji/</url>
    <content><![CDATA[<h1 id="2_1_Unix_起源于历史，1969_1995"><a class="header-anchor" href="#2_1_Unix_起源于历史，1969_1995">#</a>2.1 Unix 起源于历史，1969-1995</h1>
<p>小型实验原型系统的后继产品往往备受令人讨厌的“第二版效应”折磨。由于迫切希望把所有首次开发时遗漏的功能都添加进去，往往导致设计十分庞大、过于复杂。其实，还有一个因不常遇到而鲜为人知的“第三版效应”：有时候，在第二系统不堪自身重负而崩溃之后，有可能返璞归真，走上正道。</p>
]]></content>
      <tags>
        <tag>系统设计</tag>
        <tag>编码规范</tag>
      </tags>
  </entry>
  <entry>
    <title>《Unix 编程艺术》 第三章 对比</title>
    <url>/di_3_zhang_dui_bi%EF%BC%9Aunix_zhe_xue_tong_qi_ta_zhe_xue_de_bi_jiao/</url>
    <content><![CDATA[<h1 id="3_1_操作系统的风格元素"><a class="header-anchor" href="#3_1_操作系统的风格元素">#</a>3.1 操作系统的风格元素</h1>
<h2 id="3_1_1_什么是操作系统的统一性理念"><a class="header-anchor" href="#3_1_1_什么是操作系统的统一性理念">#</a>3.1.1 什么是操作系统的统一性理念</h2>
<p>Unix 有几个统一性的理念或象征，并塑造了它的 API 及由此形成的开发风格。其中最重要的一点应当是“一切皆文件”模型及在此基础上建立的管道概念。</p>
<p>彻头彻尾的反 Unix 系统，就是没有任何统一性理念，胡乱堆砌起的一些唬人特性而已。</p>
<h2 id="3_1_2_多任务能力"><a class="header-anchor" href="#3_1_2_多任务能力">#</a>3.1.2 多任务能力</h2>
<p>Unix 系统拥有抢先式多任务（preemptive multitasking）能力。在 Unix 中，时间片由调度程序来分配，这个调度程序定期中断或抢断正在运行的进程而把控制权交给下一个进程。几乎所有的现代操作系统都支持抢占式调度。</p>
<p>彻头彻尾的反 Unix 系统，就是绝无多任务处理能力一一或者通过对进程管理增设诸多的规定、限制和特殊情况来削弱多任务能力的一个废物。</p>
<h2 id="3_1_3_协作进程"><a class="header-anchor" href="#3_1_3_协作进程">#</a>3.1.3 协作进程</h2>
<p>在 Unix 中，低价的进程生成和简便的 <code>进程间通讯（IPC,Inter-Process Communication）</code> 使众多小工具、管道和过滤器组成一个均衡系统成为可能。</p>
<p>如果操作系统的进程生成代价昂贵，且/或进程控制非常困难、不灵活，后果通常是：</p>
<ul>
<li>编写怪物般巨大的单个程序成为更自然的编程方式。</li>
<li>很多策略必须在这些庞大程序中表述。</li>
<li>当进程间不得不进行通讯时，要么只能采用笨拙、低效、不安全的机制（比如临时文件），要么就得依赖太多彼此的实现细节，要么彼此需了解对方的太多实现细节。</li>
<li>广泛使用多线程来完成某些任务，而这些任务 Unix 只需用互通的多进程就能处理。</li>
<li>必须学习和使用异步 IO。</li>
</ul>
<p>一个操作系统，如果没有灵活的 IPC 和使用 IPC 的强大传统，程序间就得通过共享结构复杂的数据实现通讯。由于一旦有新的程序加入通讯圈，圈子里所有程序的通讯问题都必须重新解决，所以解决方案的复杂度与协作程序数量的平方成正比。更糟糕的是，其中任何一个程序的数据结构发生变化，都说不定会给其它程序带来什么隐蔽的 bug。</p>
<p>彻头彻尾的反 Unix 系统，就是让进程的生成代价高昂，让进程的控制因难而死板，让 IPC 可有可无，对它不予支持或支持很少。</p>
<h2 id="3_1_4_内部边界"><a class="header-anchor" href="#3_1_4_内部边界">#</a>3.1.4 内部边界</h2>
<p>Unix 至少设立了三层内部边界来防范恶意用户或有缺陷的程序：</p>
<ol>
<li>第一层是内存管理：Unix 用硬件自身的 <code>内存管理单元(MMU)</code> 来保证各自的进程不会侵入到其它进程的内存地址空间。</li>
<li>第二层是为多用户设置的真正权限组——普通用户（非 Root 用户）的进程未经允许，就不能更改或者读取其他用户的文件。</li>
<li>第三层是把涉及关键安全性的功能限制在尽可能小的可信代码块上 。在 Unix 中，即使是 shell（系统命令解释器）也不是什么特权程序。</li>
</ol>
<h2 id="3_1_5_文件属性和记录结构"><a class="header-anchor" href="#3_1_5_文件属性和记录结构">#</a>3.1.5 文件属性和记录结构</h2>
<p>Unix 文件既没有记录结构也没有文件属性。</p>
<p>对文件属性的操作系统支持会诱导程序员使用不透明的文件格式，让他们依靠文件属性将文件格式对应的解读程序绑在一起。</p>
<h2 id="3_1_6_二进制文件格式"><a class="header-anchor" href="#3_1_6_二进制文件格式">#</a>3.1.6 二进制文件格式</h2>
<p>彻头彻尾的反 Unix 系统，让所有文件格式都采用不透明的二进制格式，后者要用重量级的工具才能读取和编辑。</p>
<h2 id="3_1_7_首选用户界面风格"><a class="header-anchor" href="#3_1_7_首选用户界面风格">#</a>3.1.7 首选用户界面风格</h2>
<p>如果操作系统的 CLI 功能很弱或根本不存在，其后果会是：</p>
<ul>
<li>程序设计不会考虑以未预料到的方式相互协作——因为无法这样设计。输出不能用作输入。</li>
<li>远程系统管理更难于实现，更难以使用，更强调网络。</li>
<li>即便简单的非交互程序也将招致 GUI 开销或复杂的脚本接口。</li>
<li>服务器、守护程序和后台进程几乎无法写出，至少很难以优雅的方式写出。</li>
</ul>
<p>彻头彻尾的反 Unix 系统，就是没有 CLI，没有脚本编程能力或者，存在 CLI 不能驱动的重要功能。</p>
<h2 id="3_1_8_目标受众"><a class="header-anchor" href="#3_1_8_目标受众">#</a>3.1.8 目标受众</h2>
<p>“客户端”可以理解为：轻量，只支持单个用户，能够在小型机器上运行，随需开关机器，没有抢先式多任务处理，为低延迟作了优化，大量资源都用在花哨的用户界面上。</p>
<p>“服务器”可以解释为：重量，能够连续运行，为吞吐量优化，完全抢占式多任务处理以处理多重会话。所有的操作系统最初都是服务器操作系统。</p>
<p>客户端操作系统更关注用户的视觉体验，而不是 7*24 小时的连续正常运行。</p>
<p>彻头彻尾的反 Unix 系统，就是一个自认为比你自己更懂你在干什么的操作系统，然后雪上加霜的是，它还做错了。</p>
<h2 id="3_1_9_开发的门坎"><a class="header-anchor" href="#3_1_9_开发的门坎">#</a>3.1.9 开发的门坎</h2>
<p>区分操作系统的另一个重要尺度就是纯用户转变为开发者的门坎高度。这里有两个重要的成本：一是开发工具的金钱成本，另一个是成为一个熟练开发者的时间成本。</p>
<h1 id="3_2_操作系统的比较"><a class="header-anchor" href="#3_2_操作系统的比较">#</a>3.2 操作系统的比较</h1>
<h2 id="3_2_2_MacOS"><a class="header-anchor" href="#3_2_2_MacOS">#</a>3.2.2 MacOS</h2>
<p>MacOS 有一个不同于 Unix 的坚定统一性理念：Mac 界面方针（the Mac InterfaceGuidelines）。</p>
<p>这些方针非常详细地说明了应用程序 GUI 的表现形式和行为模式。这些原则的一致性在很多重要方面影响了 Mac 用户的文化。</p>
<p>这些方针的主旨是：东西永远呆在你摆的地方。文档、目录和其它东西在桌面上都有固定的、系统不会弄乱的位置，重启后桌面依然保持原样。</p>
<h2 id="3_2_4_Windows_NT"><a class="header-anchor" href="#3_2_4_Windows_NT">#</a>3.2.4 Windows NT</h2>
<p>Windows NT(New Technology) 是微软为高端个人用户和服务器设计的操作系统；Windows XP 是 5.1.</p>
<p>NT 是逐步堆积而成的，缺乏对应于 Unix “一切皆文件” 或 MacOS 左面的统一性理念。</p>
<p>Unix 的系统配置和用户配置数据分散存放在众多的 dotfiles (名字以“.”开头的文件) 和系统数据文件中，而 NT 则集中存放在注册表中。以下后果贯穿于设计中：</p>
<ul>
<li>注册表使得整个系统完全不具备正交性。应用程序的单点故障就会损毁注册表，经常使得整个操作系统无法使用、必须重装。</li>
<li>注册表蠕变 (registry creep) 现象：随着注册表的膨胀，越来越大的存取开销拖慢了所有程序的运行。</li>
</ul>
<h2 id="3_2_8_Linux"><a class="header-anchor" href="#3_2_8_Linux">#</a>3.2.8 Linux</h2>
<p>Linux 并不含任何来自原始 Unix 源码树的代码，但却是一个按照 Unix 标准设计、行为像 Unix 的操作系统。</p>
<p>包容竞争者的目标加上贴近终端用户的动力，促使 Linux 开发者广泛吸收非 Unix 操作系统的设计理念，甚至到了使传统 Unix 显得十分孤立的地步。</p>
]]></content>
      <tags>
        <tag>系统设计</tag>
        <tag>编码规范</tag>
      </tags>
  </entry>
  <entry>
    <title>《Unix 编程艺术》第四章 模块化</title>
    <url>/di_4_zhang_mo_kuai_xing%EF%BC%9Abao_chi_qing_xi%EF%BC%8Cbao_chi_jian_jie/</url>
    <content><![CDATA[<blockquote>
<p>软件设计有两种方式：一种是设计得极为简洁，没有看得到的缺陷；另一种是设计得极为复杂，有缺陷也看不出来。第一种方式的难度要大得多。<br>
—— 《皇帝的旧衣》 C.A.R.Hoare</p>
</blockquote>
<p>模块化原则在这里展开来说就是：要编写复杂软件又不至于一败涂地的唯一方法，就是用定义清晰的接口把若干简单模块组合起来，如此一来，多数问题只会出现在局部，那么还有希望对局部进行改进或优化，而不至于牵动全身。</p>
<h1 id="4_1_封装和最佳模块大小"><a class="header-anchor" href="#4_1_封装和最佳模块大小">#</a>4.1 封装和最佳模块大小</h1>
<p>模块化代码的首要特质就是封装。封装良好的模块不会过多向外部披露自身的细节，不会直接调用其它模块的实现码，也不会胡乱共享全局数据。</p>
<p>模块之间通过应用程序编程接口（API），一组严密、定义良好的程序调用和数据结构来通信。这就是模块化原则的内容。</p>
<p>API 在模块间扮演双重角色。在实现层面，作为模块之间的滞塞点（choke point），阻止各自的内部细节被相邻模块知晓；在设计层面，正是 API（而不是模块间的实现代码）真正定义了整个体系。</p>
<ul>
<li>一种很好的方式来验证 API 是否设计良好：如果试着用纯人类语言描述设计（不许摘录任何源代码），能否把事情说清楚？</li>
</ul>
<p>模块分解得越彻底，每一块就越小，API 的定义也就越重要。全局复杂度和受 Bug 影响的程度也会相应降低。但模块过小时，几乎所有的复杂度都在接口，这就导致想要理解任何一部分代码前必须理解全部代码，因此阅读代码非常困难。200 到 400 之间逻辑行的代码是“最佳点”。</p>
<h1 id="4_2_紧凑性和正交性"><a class="header-anchor" href="#4_2_紧凑性和正交性">#</a>4.2 紧凑性和正交性</h1>
<h2 id="4_2_1_紧凑性"><a class="header-anchor" href="#4_2_1_紧凑性">#</a>4.2.1 紧凑性</h2>
<p>紧凑性就是一个设计是否能装进人脑中的特性。测试软件紧凑性的一个很实用的好方法是：有经验的用户通常需要操作手册吗？如果不需要，那么这个设计（或者至少这个设计的涵盖正常用途的子集）就是紧凑的。</p>
<p>紧凑的软件工具和顺手的自然工具一样具有同样的优点：让人乐于使用，不会在你的想法和工作之间格格不入，使你工作起来更有成效。不像那些蹩脚的工具，用着别扭，甚至还会把你弄伤。</p>
<ul>
<li>紧凑不等于“薄弱”：如果一个设计构建在易于理解且利于组合的抽象概念上，则这个系统能在具有非常强大、灵活的功能的同时保持紧凑。</li>
<li>紧凑也不等同于“容易学习”：对于某些紧凑设计而言，在掌握其精妙的内在基础概念模型之前，要理解这个设计相当困难；但一旦理解了这个概念模型，整个视角就会改变，紧凑的奥妙也就十分简单了。</li>
<li>紧凑也不意味着“小巧”。即使一个设计良好的系统，对有经验的用户来说没什么特异之处、“一眼”就能看懂，但仍然可能包含很多部分。</li>
</ul>
<div class="note info simple"><p>有时，为了其他优势，如纯性能和适应范围等，也有必要牺牲紧凑性。</p>
<p>把紧凑性作为有点来强调，并不是要求大家把紧凑性看作一个绝对要求。</p>
</div>
<h2 id="4_2_2_正交性"><a class="header-anchor" href="#4_2_2_正交性">#</a>4.2.2 正交性</h2>
<p>正交性是有助于使复杂设计也能紧凑的最重要特性之一。在纯粹的正交设计中，任何操作均无副作用：每一个动作只改变一件事，不会影响其它。</p>
<p>无论你控制的是什么系统，改变每个属性的方法有且只有一个。</p>
<p>“只做好一件事” 的忠告不仅仅是针对简单性的建议，同时也强调了正交性。</p>
<h2 id="4_2_3_SPOT_原则"><a class="header-anchor" href="#4_2_3_SPOT_原则">#</a>4.2.3 SPOT 原则</h2>
<p>《程序员修炼之道》(The Pragmatic Programmer) 针对一类特别重要的正交性明确提出了一条原则——<strong>“不要重复自身(Don’t Repeat Yourself&quot;)”</strong>。这个原则也可称为 <code>真理的单点性(Single Point of Truth)</code> 或者 SPOT 原则。</p>
<p>重复会导致前后矛盾、产生隐微问题的代码，原因是当你修改重复点时，往往只改变了一部分而非全部。</p>
<p>数据结构也存在类似的 SPOT 原则：<strong>“无垃圾，无混淆”(No junk, no confusion)</strong>。</p>
<ul>
<li>“无垃圾”是说数据结构（模型）应该最小化，比如，不要让数据结构太通用，甚至表示不可能存在的情况。</li>
<li>“无混淆”是指在真实世界中绝对明确清晰的状态在模型中也同样明确清晰。</li>
</ul>
<h2 id="4_2_4_紧凑性和强单一中心"><a class="header-anchor" href="#4_2_4_紧凑性和强单一中心">#</a>4.2.4 紧凑性和强单一中心</h2>
<p>要提高设计的紧凑性，有一个精妙但强大的方法，就是围绕“解决一个定义明确的问题”的强核心算法组织设计，避免臆断和捏造。</p>
<p>这是 Unix 传统中常常被忽视的一个优点。其实，Unix 许多非常有效的工具都是围绕某个单一强大算法直接转换的一个瘦包装器（thin wrapper）。如 <code>diff</code>，<code>grep</code> 和 <code>yacc</code> 三个程序都极少出 bug，大家认为它们绝对理所当然地应该正确运行，而且它们也非常紧凑，程序员用起来得心应手。这些良好性能只有一部分归功于长期服务和频繁使用所产生的改进，绝大部分还是因为建立在强大且被证明为正确的算法核心上，它们从一开始就无需多少改进。</p>
<p>与形式法相对的是 <code>试探法</code>——凭经验法则得出的解决方案，在概率上可能正确，但不一定总是正确。有时我们使用试探法是因为不可能找到绝对正确的解决方案。例如垃圾邮件过滤：一个算法上完美的垃圾邮件过滤器需要完全解决自然语言的理解问题。</p>
<div class="note info simple"><p>试探法的问题在于这种方案会增生出大量特例和边界情况。</p>
</div>
<h2 id="4_2_5_分离的价值"><a class="header-anchor" href="#4_2_5_分离的价值">#</a>4.2.5 分离的价值</h2>
<p>要达到这种简洁性，尽量不要去想一种语言或操作系统最多能做多少事情，而是尽量去想这种语言或操作系统最少能做的事情，不是带着假想行动，而是从零开始。</p>
<h1 id="4_3_软件是多层的"><a class="header-anchor" href="#4_3_软件是多层的">#</a>4.3 软件是多层的</h1>
<h2 id="4_3_1_自顶向下和自底向上"><a class="header-anchor" href="#4_3_1_自顶向下和自底向上">#</a>4.3.1 自顶向下和自底向上</h2>
<p>一个方向是自底向上，从具体到抽象 —— 从问题域中你确定要进行的具体操作开始，向上进行。例如，如果为一个磁盘驱动器设计固件，一些底层的原语可能包括“磁头移至物理块”、“读物理块”、“写物理块”、“开关驱动器 LED”等。</p>
<p>另一个方向是自顶向下，从抽象到具体——从描述逻辑开始，向下进行，直到各个具体操作。例如要为一个能处理不同介质的大容量存储控制器设计软件，可以从抽象的操作开始，如“移到逻辑块”、“读逻辑块”、“写逻辑块”、“开关状态指示”等。</p>
<p>编程新手往往被教导以 “正确的方法是自顶向下”：逐步求精，在拥有具体的工作码前，先在抽象层面上规定程序要做些什么，然后用实现代码逐步填充。但如果纯粹地自顶向下编程，常常产生在某些代码上的过度投资效应，这些代码因为接口没有通过实际检验而必须废弃或重做。</p>
<p>为了应对这种情况，出于自我保护，程序员尽量双管齐下，一方面以自顶向下的应用逻辑表达抽象规范，另一方面以函数或库来收集底层的域原语，这样，当高层设计变化时，这些域原语仍然可以重用。</p>
<h2 id="4_3_2_胶合层"><a class="header-anchor" href="#4_3_2_胶合层">#</a>4.3.2 胶合层</h2>
<p>当自顶向下和自底向上发生冲突时，其结果往往是一团糟。顶层的应用逻辑和底层的域原语集必须用 <strong>胶合逻辑层</strong> 来进行阻抗匹配（impedance match）。</p>
<p>Unix 程序员几十年的教训之一就是：胶合层是个挺讨厌的东西，必须尽可能薄，这一点极为重要。胶合层用来将东西粘在一起，但不应该用来隐藏各层的裂痕和不平整。</p>
<h2 id="4_3_3_被视为薄胶合层的_C_语言"><a class="header-anchor" href="#4_3_3_被视为薄胶合层的_C_语言">#</a>4.3.3 被视为薄胶合层的 C 语言</h2>
<p>完美之道，不在无可增加，而在无可删减</p>
<h1 id="4_4_程序库"><a class="header-anchor" href="#4_4_程序库">#</a>4.4 程序库</h1>
<p>Unix 编程风格强调模块性和定义良好的 API，它所产生的影响之一就是：强烈倾向于把程序分解成由胶合层连接的库集合。</p>
<p>这捎带引起了一个小问题。在 Unix 世界里，作为“程序库”发布的库必须携带练习程序（exerciser program）。</p>
<p>除了学习起来更容易外，库的练习程序常常可以作为优秀的测试框架。因此，有经验的 Unix 程序员并不仅仪把这些练习程序看作是为库使用者提供便利，也会认为代码应已经过很好的测试。</p>
<h1 id="4_5_Unix_和面向对象语言"><a class="header-anchor" href="#4_5_Unix_和面向对象语言">#</a>4.5 Unix 和面向对象语言</h1>
<p>过多的层次破坏了透明性：我们很难看清这些层次，无法在头脑中理清代码到底是怎样运行的。简洁、清晰和透明原则统统被破坏了，结果代码中充满了晦涩的 bug，始终存在维护问题。</p>
<h1 id="4_6_模块式编码"><a class="header-anchor" href="#4_6_模块式编码">#</a>4.6 模块式编码</h1>
<p>在编写代码时，问问自己以下这些问题，可能会有助于提高代码的模块性：</p>
<ul>
<li>
<p>有多少全局变量？全局变量对模块化是毒药，很容易使各模块轻率、混乱地互相泄漏信息。</p>
</li>
<li>
<p>单个模块的大小是否在 “最佳范围”内？如果回答是“不，很多都超过”的话，就可能产生长期的维护问题。</p>
</li>
<li>
<p>模块内的单个函数是不是太大了？与其说这是一个行数计算问题，还不如说是一个内部复杂性问题。如果不能用一句话来简单描述一个函数与其调用程序之间的约定，这个函数可能太大了。</p>
</li>
</ul>
<blockquote>
<p>就我个人而言，如果局部变量太多，我倾向于拆分子程序。另一个办法是看代码行是否存在（太多）缩进。我几乎从来不看代码长度。<br>
—— Ken Thompson</p>
</blockquote>
<ul>
<li>
<p>是否 每个 API 不受其它代码的影响？好的 API 应是意义清楚，不用看具体如何实现就能够理解的。对此有一个经典的测试方法：通过电话向另一个程序员描述。如果说不清楚，API 很可能就是太复杂，设计太糟糕了。</p>
</li>
<li>
<p>API 的入口点是不是超过七个？有没有哪个类有七个以上的方法？数据结构的成员是不是超过七个？</p>
</li>
<li>
<p>整个项目中每个模块的入口点数量如何分布？是不是不均匀？有很多入口点的模块真的需要这么多入口点吗？模块复杂性往往和入口点数量的平方成正比。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>系统设计</tag>
        <tag>编码规范</tag>
      </tags>
  </entry>
  <entry>
    <title>《Unix 编程艺术》 第五章 文本化</title>
    <url>/di_5_zhang_wen_ben_hua%EF%BC%9Ahao_xie_yi_chan_sheng_hao_shi_jian/</url>
    <content><![CDATA[<p>序列化（保存）操作有时也称为 <code>列集(marshaling)</code>，其反向操作（载入）称为 <code>散集(unmarshaling)</code>。</p>
<h1 id="文本化的重要性"><a class="header-anchor" href="#文本化的重要性">#</a>文本化的重要性</h1>
<p>文本流是非常有用的通用格式，因为人无需专门工具就可以很容易地读写和编辑文本流，这些格式是透明的（或可以设计成透明的）。</p>
]]></content>
      <tags>
        <tag>系统设计</tag>
        <tag>编码规范</tag>
      </tags>
  </entry>
  <entry>
    <title>《Unix 编程艺术》 第七章 多道程序设计</title>
    <url>/di_7_zhang_duo_dao_cheng_xu_she_ji%EF%BC%9Afen_li_jin_cheng_wei_du_li_de_gong_neng/</url>
    <content><![CDATA[<p>多道程序设计是设计中的荒蛮之地，几乎没有好的实践方针。许多程序员尽管精于判断如何将代码分解成子过程，然而最终还是编写出单个庞然大物般的单进程程序，而这些程序往往失败在自身的内部复杂度之上。</p>
<p>Unix 设计风格都运用“做单件事并做好” 的方法，强调用定义良好的进程间通信或共享文件来联通小型进程。</p>
<p>尽管将程序划分成协作进程带来了全局复杂度降低的好处，但代价是我们必须更多地关注在进程间传递信息和命令的协议设计(在所有种类的软件系统中，接口都是 bug聚集之地)。<br>
- 协议必须 <strong>看得出</strong> 很有表现力，即人们必须能够在头脑中尝试对通信程序的行为建模并验证其正确性。</p>
<h1 id="7_1_从性能调整中分离复杂度控制"><a class="header-anchor" href="#7_1_从性能调整中分离复杂度控制">#</a>7.1 从性能调整中分离复杂度控制</h1>
<p>在开发出可以把全局复杂度降至最低程度的干净体系之前，关注性能问题便是过早优化-万恶之源。</p>
<p>使用线程是为了调整性能，线程不是降低而是提高了全局复杂度。因此，除非万不得已，尽量避免使用线程。</p>
<ul>
<li>基于线程的程序不仅产生普通的竞争问题，而且产生了新一类 bug：时许依赖，要重现这些问题都极其困难，遑论修复。</li>
</ul>
<h1 id="7_2_Unix_IPC_方法的分类"><a class="header-anchor" href="#7_2_Unix_IPC_方法的分类">#</a>7.2 Unix IPC 方法的分类</h1>
<p>在使用更晚出现、更复杂的激发前，应当通过实证——用原型和基准检测结果——所有更早出现、更简单的技法都不管用。</p>
]]></content>
      <tags>
        <tag>系统设计</tag>
        <tag>编码规范</tag>
      </tags>
  </entry>
  <entry>
    <title>《Unix 编程艺术》 第六章 透明性</title>
    <url>/di_6_zhang_tou_ming_xing%EF%BC%9Alai_dian_er_guang/</url>
    <content><![CDATA[<div class="note icon-padding simple"><i class="note-icon fas fa-quote-left"></i><p>美在计算科学中的地位，要比在其它任何技术中的地位都重要，因为软件是太复杂了。美是抵御复杂的终极武器。 - David Gelernter</p>
</div>
<p>如果没有阴暗的角落和隐藏的深度，软件系统就是透明的。</p>
<p>透明性是一种 <strong>被动品质</strong>。如果实际上能预测到程序行为的全部或大部分情况，并能建立简单的心理模型，这个程序就是 <strong>透明</strong> 的。</p>
<p>如果软件系统所包含的功能是为了帮助人们对软件建立正确的 <code>做什么、怎样做</code> 的心理模型而设计，这个软件系统就是 <strong>可显</strong> 的。 对程序员而言，良好的变量和函数名有助于提高可显性。可显性是一种<strong>主动品质</strong>。</p>
<p>优雅的代码事半功倍：优雅的代码不仅正确，而且显然正确：优雅的代码不仅将算法传达给计算机，同时也把见解和信心传递给阅读代码的人。通过追求代码的优雅，我们能够编写更好的代码。学习编写透明的代码是学习如何编写优雅代码的第一关，很难的一关。</p>
<h1 id="6_1_研究实例"><a class="header-anchor" href="#6_1_研究实例">#</a>6.1 研究实例</h1>
<p>不要让调试工具仅仅成为一种事后追加或者用过就束之高阁的东西。它们是通往代码的窗口：不要只在墙上凿出粗糙的洞，要修整这些洞并装上窗。如果打算让代码一直可被维护，就始终必须让光照进去。</p>
<h1 id="6_2_为透明性和可显性而设计"><a class="header-anchor" href="#6_2_为透明性和可显性而设计">#</a>6.2 为透明性和可显性而设计</h1>
<p>要为透明性和可显性而设计，就必须运用各种计策来保持代码的简洁，也必须专注代码同其他人交流的方式。在“这个设计能行吗？”之后要提出的头几个问题就是“别人能读懂这个设计吗？这个设计优雅吗？”</p>
<p>优雅不是一种奢侈，在人类对软件的反映中，这些品质对于减少软件 bug 和提高软件长期维护性是最基本的。</p>
<h2 id="6_2_1_透明性之禅"><a class="header-anchor" href="#6_2_1_透明性之禅">#</a>6.2.1 透明性之禅</h2>
<p>要追求代码的透明，最有效的方法很简单，就是不要在具体操作的代码上叠放太多的抽象层。</p>
<p>软件设计者都是聪明人，可对其处理的应用域形成概念。他们把围绕这些概念编写的软件组织起来。然后，调试时，他们经常发现很难透过这些概念弄明白到底发生了什么。</p>
<h2 id="6_2_2_为透明性和可显性而编码"><a class="header-anchor" href="#6_2_2_为透明性和可显性而编码">#</a>6.2.2 为透明性和可显性而编码</h2>
<p>透明性和可显性同模块性一样，主要是设计的特性而不是代码的特性。以下这些问题需要好好关心：</p>
<ul>
<li>程序调用层次中最大的静态深度是多少？如果大于 4，就要当心</li>
<li>代码是否具有强大、明显的不变性质？（不变性质是指一个软件设计中各个操作都保持不变特性）</li>
<li>每个 API 中的各个函数调用是否正交？或者是否存在太多的 <code>magic flags</code> 和模式位，使得一个调用要完成多个任务？</li>
</ul>
<div class="note info simple"><p>完成避免模式标志会导致混乱的 API，里面包括太多几乎一模一样的函数，但是频繁使用模式标志更容易产生错误（很多易忘并且易混的模式标记）。</p>
</div>
<ul>
<li>程序的数据结构或分类和它们所代表的外部实体之间，是否存在清晰的一对一映射？</li>
<li>是否容易找到给定函数的代码部分？不仅单个函数、模块，还有整个代码，需要花多少精力才能读懂？</li>
<li>代码增加了特殊情况还是避免了特殊情况？每一个特殊情况可能对任何其它特殊情况产生影响：所有隐含的冲突都是 bug 滋生的温床。然而更重要的是，特殊情况使得代码更难理解。</li>
<li>代码中有多少个 magic number（意义含糊的常量）？</li>
</ul>
<h2 id="6_2_3_透明性和避免过度保护"><a class="header-anchor" href="#6_2_3_透明性和避免过度保护">#</a>6.2.3 透明性和避免过度保护</h2>
<p>隐藏细节和无法访问细节有着重要区别。</p>
<p>不能展示其行为的程序使故障检测困难得多。所以，经验丰富的 Unix 用户实际上把调试和探测开关的存在视为良好程序的标志，不存在则认为程序可能有问题。</p>
<h2 id="6_2_5_透明性、故障诊断和故障恢复"><a class="header-anchor" href="#6_2_5_透明性、故障诊断和故障恢复">#</a>6.2.5 透明性、故障诊断和故障恢复</h2>
<p>透明性还有一个与简化调试有关的好处，就是 bug 发作时，透明的系统更容易实施恢复措施。而且，经常是，首先更能抵抗 bug 的破坏。</p>
<p>简洁加上透明，降低了费用，缓解了每个人的压力，让人们从中解放出来，更多地投入到新问题，而不是总为旧错误擦屁股。</p>
<h1 id="6_3_为可维护性而设计"><a class="header-anchor" href="#6_3_为可维护性而设计">#</a>6.3 为可维护性而设计</h1>
<p>如果作者以外的其他人能够顺利地理解和修改软件，则这个软件就是可维护的。</p>
<p>Unix 程序员学到了一种品性，就是宁愿抛弃、重建代码也不愿修补那些蹩脚的代码。</p>
<p>一个非常重要地实践就是应用清晰原则：选择简单地算法。另一个重要的实践是要包含开发者手册。在发布源码的同时包含指导文档，简略地描述代码地关键数据结构和算法。</p>
]]></content>
      <tags>
        <tag>设计模式</tag>
        <tag>编码规范</tag>
      </tags>
  </entry>
  <entry>
    <title>《Unix 编程艺术》 第八章 微型语言</title>
    <url>/di_8_zhang_wei_xing_yu_yan%EF%BC%9Axun_zhao_ge_chang_de_le_fu/</url>
    <content><![CDATA[<p>Unix 有个长期传统，即包容小型的、为专门应用领域特质、大量减少程序行数的语言。</p>
]]></content>
      <tags>
        <tag>设计模式</tag>
        <tag>编码规范</tag>
      </tags>
  </entry>
  <entry>
    <title>《Unix 编程艺术》 第九章 生成</title>
    <url>/di_9_zhang_sheng_cheng%EF%BC%9Ati_sheng_gui_ge_shuo_ming_de_ceng_ci/</url>
    <content><![CDATA[<p>数据比程序逻辑更易驾驭。尽可能把设计的复杂度从程序代码转移到数据中是个好实践，选择便于人类维护和操作的数据表示法也是好实践。</p>
<h1 id="9_1_数据驱动编程"><a class="header-anchor" href="#9_1_数据驱动编程">#</a>9.1 数据驱动编程</h1>
<p>数据驱动编程有时会跟面向对象混淆起来，后者是另一种以数据组织为中心的风格。它们之间至少有两点不同。</p>
<ol>
<li>在数据驱动编程中，数据不仅仅是某个对象的状态实际上还定义了程序的控制流</li>
<li>OO 首先考虑的是封装，而数据驱动编程看重的是编写尽可能少的固定代码。</li>
</ol>
<h3 id="9_1_1_ascii"><a class="header-anchor" href="#9_1_1_ascii">#</a>9.1.1 ascii</h3>
<p><code>ascii</code> 是 Unix 系统中的一个命令行工具。当一个 ASCII 值或字符被传递到此工具时，它会输出该字符的八进制、十进制、和十六进制值，同时也会显示对应的字符。例如，如果你输入  <code>ascii A</code>，你将得到 ‘A’ 字符的 ASCII 编码信息。</p>
<p>在 Unix 中，采用了数据驱动编程开发这个程序。所有字符名的字符串都放在了一个表结构中，这个表结构比代码中的任何函数都大。代码仅仅查表并完成数值转换等底层任务。</p>
<p>这种结构使得增加新字符名、改变现有字符名或删除旧字符名都非常容易，只要简单编辑数据表就行，不需要改动代码。</p>
]]></content>
      <tags>
        <tag>系统设计</tag>
        <tag>编码规范</tag>
      </tags>
  </entry>
  <entry>
    <title>《Terminal, Console, Shell, Command Line 之间的关系》</title>
    <url>/difference_between_terminal,_console,_shell,_and_command_line/</url>
    <content><![CDATA[<p><code>Terminal</code>，<code>Console</code>，<code>Shell</code> 和 <code>Command Line</code> 这几个词汇经常同时被使用，也因此他们的含义很容易被混淆。本文将尝试解释这几个词汇的含义。</p>
<div class="note icon-padding simple"><i class="note-icon fas fa-clipboard-list"></i><p>用户输入的文本命令是 <code>Command Line</code>，<code>Shell</code> 负责将其转译成操作系统能够理解的指令，并获取操作系统的执行结果。<br>
<code>Terminal</code> 和 <code>Console</code> 负责提供用户可以输入 <code>Command Line</code> 的界面和展示命令的执行结果。</p>
</div>
<h1 id="Command_Line"><a class="header-anchor" href="#Command_Line">#</a>Command Line</h1>
<p><code>Command Line</code> 是用户通过文本与操作系统交互的方式，与之相对即是基于 <code>GUI</code> 的交互方式。</p>
<div class="note icon-padding simple"><i class="note-icon fas fa-list"></i><p><code>cd</code>，<code>ls</code>，<code>Get-Command</code> 这些文本都是 <code>Command Line</code>。</p>
</div>
<p>用户输入的 <code>Command Line</code> 将通过 <a href="/difference_between_terminal,_console,_shell,_and_command_line/#shell">Shell</a> 传递给操作系统，操作系统执行指令并返回结果。</p>
<h1 id="Shell"><a class="header-anchor" href="#Shell">#</a>Shell</h1>
<p><code>Shell</code> 是 <a href="/difference_between_terminal,_console,_shell,_and_command_line/#command_line">Command Line</a> 的转译软件，它负责将 <a href="/difference_between_terminal,_console,_shell,_and_command_line/#command_line">Command Line</a> 转译成操作系统能够理解的指令，并获取操作系统的执行结果。<code>Shell</code> 并无 GUI 界面，它只是一个接受文本数据（<a href="/difference_between_terminal,_console,_shell,_and_command_line/#command_line">Command Line</a>）并返回执行结果的软件。</p>
<ul>
<li>每一个 <code>Shell</code> 都有自己的语法，也因此，每一个 <code>Shell</code> 所能转译的 <a href="/difference_between_terminal,_console,_shell,_and_command_line/#command_line">Command Line</a> 是不同的。</li>
</ul>
<div class="note icon-padding simple"><i class="note-icon fas fa-list"></i><p><a href="https://en.wikipedia.org/wiki/bash_(unix_shell)">Bash</a>，<a href="https://github.com/fish-shell/fish-shell">FISH</a> 和 <a href="https://learn.microsoft.com/en-us/powershell/">PowerShell</a> 都是 Shell。</p>
</div>
<div class="note primary simple"><p>因为 <a href="https://learn.microsoft.com/en-us/powershell/">PowerShell</a> 软件本身也提供了 GUI 界面，因此 <a href="https://learn.microsoft.com/en-us/powershell/">PowerShell</a> 严格意义上是 <code>Shell</code> 和 <code>Console</code> 的结合体</p>
</div>
<p><code>Shell</code> 通过 <a href="/difference_between_terminal,_console,_shell,_and_command_line/#terminal_and_console">Terminal 或 Console</a> 展现其执行结果。</p>
<h1 id="Terminal_and_Console"><a class="header-anchor" href="#Terminal_and_Console">#</a>Terminal and Console</h1>
<p><code>Terminal</code> 和 <code>Console</code> 两个词汇含义非常相同：用户在键盘上输入 <a href="/difference_between_terminal,_console,_shell,_and_command_line/#command_line">Command Line</a>，<code>Terminal</code> 和 <code>Console</code> 都负责将执行结果展现给用户。在很多情况下，这两个词汇可以互换使用。</p>
<p>在早期，<code>Terminal</code> 和 <code>Console</code> 都表示的与计算机连接的物理设备，如键盘和显示器。</p>
<ul>
<li><code>Terminal</code>：连接到主机的物理设备，连接的目标类型并不做要求，可以是本地的主机，也可以是远端的主机。一个 <code>Terminal</code> 可以连接至多个不同的主机。</li>
<li><code>Console</code>：是 <code>Terminal</code> 的一种形式，特指连接到本地主机的物理设备。一个 <code>Console</code> 在同一时间，只能连接到一个主机。</li>
</ul>
<div class="note info simple"><p><code>Terminal</code> 的抽象等级相对于 <code>Console</code> 更高。<code>Console</code> 是 <code>Terminal</code> 的一种特例。</p>
</div>
<p>在现代，<code>Terminal</code> 和 <code>Console</code> 两个词汇更多的是指软件，而非物理设备，他们都是指用来与操作系统进行交互的，拥有 GUI 界面的软件，<a href="/difference_between_terminal,_console,_shell,_and_command_line/#shell">Shell</a> 需要运行在其中。 <code>Console</code> 仍然是 <code>Terminal</code> 的一种特例。</p>
<ul>
<li><code>Terminal</code>：接受用户的指令，并将指令的结果展现在 GUI 界面上。一个 <code>Terminal</code> 可以同时运行多个不同的 <a href="/difference_between_terminal,_console,_shell,_and_command_line/#shell">Shell</a>。</li>
<li><code>Console</code>：是 <code>Terminal</code> 的一种特例，接受的指令和显示的结果，通常都是纯文本的。一个 <code>Console</code> 同时只能运行一个 <a href="/difference_between_terminal,_console,_shell,_and_command_line/#shell">Shell</a>。</li>
</ul>
<div class="note primary simple"><p>许多 <a href="/difference_between_terminal,_console,_shell,_and_command_line/#Shell">Shell</a> 程序，如 PowerShell，都配有内置的<code>Console</code>。尽管这些 <code>Console</code> 主要设计用于各自的 Shell，但通常它们也允许运行其他的 <a href="/difference_between_terminal,_console,_shell,_and_command_line/#Shell">Shell</a>。例如，在 PowerShell 的 Console 中，用户可以启动 <code>cmd</code>，即 Windows Command Prompt。</p>
</div>
<div class="note primary simple"><p>在 IDE 中，<code>Console</code> 也会被用来描述程序输出信息的展示窗口，此时它就不再局限于为 <a href="/difference_between_terminal,_console,_shell,_and_command_line/#Shell">Shell</a> 服务。</p>
</div>
<div class="note icon-padding simple"><i class="note-icon fas fa-list"></i><p>Iterm2](<a href="https://iterm2.com/">https://iterm2.com/</a>) 和 [Windows Terminal 都是 <code>Terminal</code>。</p>
</div>
<h1 id="Reference"><a class="header-anchor" href="#Reference">#</a>Reference</h1>
<p><a href="https://www.tutorialspoint.com/difference-between-terminal-console-shell-and-command-line">Difference Between Terminal, Console, Shell, and Command Line (tutorialspoint.com)</a></p>
<p><a href="https://www.linkedin.com/advice/0/how-do-you-choose-between-terminal-console-your">Terminal vs Console: Choosing the Right Interface for OS Tasks (linkedin.com)</a></p>
]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Custom SRP - Draw Calls</title>
    <url>/draw_calls/</url>
    <content><![CDATA[<div class="note info simple"><p>该教程部分完成的工程状态可见：<a href="https://github.com/xuejiaW/CustomSRP/releases/tag/DrawCalls">Draw Calls</a></p>
</div>
<h1 id="Shaders"><a class="header-anchor" href="#Shaders">#</a>Shaders</h1>
<p>为了让 GPU 绘制物体，CPU 必须告诉 GPU 绘制什么以及如何绘制，绘制的内容通常是一系列网格，绘制方式则由 Shaders 来定义。</p>
<h2 id="Unlit_Shader"><a class="header-anchor" href="#Unlit_Shader">#</a>Unlit Shader</h2>
<p>首先要定义的最简单的 Shader 类型就是 <code>Unlit Shader</code>，这是一系列不考虑任何光照影响的 Shader。</p>
<p>创建一个 Shader 并将其删减到最少的结构，如下所示，其中 <code>Properties</code> 为会在 Inspector 面板中显示的属性， <code>SubShader</code> 中定义的 <code>Pass</code> 表示一种渲染的方式，一个 <code>SubShader</code> 中可以有多个 <code>Pass</code> ：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Shader &quot;Custom RP/Unlit&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties &#123; &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Pass &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用这个 Shader 创建一个材质，则该材质会默认的渲染白色，如下所示：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="/draw_calls/drawcall.png" alt=""></td>
<td><img src="/draw_calls/drawcall-1.png" alt=""></td>
<td><img src="/draw_calls/drawcall-2.png" alt=""></td>
</tr>
</tbody>
</table>
<h2 id="HLSL_Programs"><a class="header-anchor" href="#HLSL_Programs">#</a>HLSL Programs</h2>
<p>SRP 中通常用来书写 Shader 的语言是 <code>HLSL（High-Level Shading Language）</code> 。所有 HLSL 语言需要写在 <code>Pass</code> 中，且必须在 <code>HLSLPROGRAM</code> 和 <code>ENDHLSL</code> 中，如下所示：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Pass</span><br><span class="line">&#123;</span><br><span class="line">    HLSLPROGRAM</span><br><span class="line">    ENDHLSL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note info simple"><p>Unity 定义的 <code>.shader</code> 文件属于 <code>ShaderLab</code> 。<code>ShaderLab</code> 中可以使用不同的语言来写，如 <code>CG</code> 和 <code>HLSL</code> 。<br>
<code>HLSL</code> 可以同时被用在 DRP，URP，HDRP 和自定义 SRP 中。 <code>CG</code> 仅可以被用在 DRP 和自定义 SRP 中。<br>
因此为了保证与 Unity 的 RP 的统一性，在自定义 SRP 中建议使用 <code>HLSL</code> 。</p>
</div>
<p>在 Shader 中需要指定顶点着色器和片元着色器的函数名称，如下所示， <code>UnlitPassVertex</code> 和 <code>UnlitPassFragment</code> 分别为两者的名称：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Pass</span><br><span class="line">&#123;</span><br><span class="line">    HLSLPROGRAM</span><br><span class="line">	<span class="meta">#pragma vertex UnlitPassVertex</span></span><br><span class="line">    <span class="meta">#pragma fragment UnlitPassFragment</span></span><br><span class="line">    ENDHLSL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但此时 Shader 中并没有 <code>UnlitPassVertex</code> 和 <code>UnlitPassFragment</code> 的具体实现，因此会产生编译错误。</p>
<p>可以直接在 <code>HLSLPROGRAM</code> 和 <code>ENDHLSL</code> 间定义上述函数的实现，也可以选择将函数的实现放在 <code>.hlsl</code> 文件中，并 <code>include</code> 到 <code>.shader</code> 文件中，如下所示：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Pass</span><br><span class="line">&#123;</span><br><span class="line">    HLSLPROGRAM</span><br><span class="line">	<span class="meta">#pragma vertex UnlitPassVertex</span></span><br><span class="line">    <span class="meta">#pragma fragment UnlitPassFragment</span></span><br><span class="line">	<span class="meta">#include &quot;UnlitPass.hlsl&quot;</span></span><br><span class="line">    ENDHLSL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note info simple"><p>HLSL 和 C++ 的 <code>include</code> 逻辑类似，即直接将被 include 的文件的所有内容拷贝到 <code>include</code> 语句所在地。</p>
</div>
<h2 id="Include_Guard_Shader_Functions"><a class="header-anchor" href="#Include_Guard_Shader_Functions">#</a>Include Guard &amp;&amp; Shader Functions</h2>
<p><code>.hlsl</code> 文件不能通过 Unity 直接创建，但在文件浏览器中创建后，可以在 Unity 中直接查看，如下所示：<br>
<img src="/draw_calls/drawcall-3.png" alt=""></p>
<p>一个可通过编译的 <code>hlsl</code> 文件如下所示：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#ifndef CUSTOM_UNLIT_PASS_INCLUDED</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#define CUSTOM_UNLIT_PASS_INCLUDED</span></span><br><span class="line"></span><br><span class="line">    float4 UnlitPassVertex():SV_POSITION</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    float4 UnlitPassFragment():SV_TARGET</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure>
<p>其中 <code>#ifndef</code> 等宏编译是为了避免， <code>.hlsl</code> 文件被多次时 include 时产生重定义，并导致编译错误。</p>
<p><code>UnlitPassVertex</code> 和 <code>UnlitPassFragment</code> 为需要的顶点着色器和片段着色器函数。</p>
<p>在函数声明后的 <code>SV_POSITION</code> 和 <code>SV_TARGET</code> 为 <code>semantics</code> ，它告诉了编译器函数的返回值的具体含义。</p>
<p>其中 <code>SV_TARGET</code> 表示渲染对象的颜色， <code>SV_POSITION</code> 表示在其次裁剪空间的位置。</p>
<div class="note info simple"><p>如果没有定义 <code>semantics</code> ，则会导致编译失败。<br>
更多关于 HLSL 的内容，可见 <a href="https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl">High-Level Shading Language</a><br>
其中的 <code>semantics</code> 可见 <a href="https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-semantics?redirectedfrom=MSDN">Semantics</a><br>
Unity 官方也有相关的教程 <a href="https://docs.unity3d.com/Manual/SL-ShaderSemantics.html">Shader semantics</a></p>
</div>
<p>此时通过该 Shader 并不能渲染出任何物体，因为在顶点着色器中直接返回了 <code>0.0</code> 表示，即所有物体渲染的结果都会集中在屏幕正中间的一个像素上，所以不可见。</p>
<h2 id="Space_Transformation"><a class="header-anchor" href="#Space_Transformation">#</a>Space Transformation</h2>
<p>为了让物体可以正常的被渲染，需要将传入的顶点数据通过顶点着色器进行 <code>MVP</code> 矩阵的转换，如下所示:</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#include &quot;../Custom RP/ShaderLibrary/Common.hlsl&quot;</span></span><br><span class="line"></span><br><span class="line">float4 UnlitPassVertex(float3 positionOS: POSITION) : SV_POSITION</span><br><span class="line">&#123;</span><br><span class="line">    float3 positionWS = TransformObjectToWorld(positionOS.xyz);</span><br><span class="line">    <span class="keyword">return</span> TransformWorldToHClip(positionWS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note info simple"><p>传入的 <code>positionOS</code> 参数后的 <code>POSITION</code> 也是 semantics，表示传入的数据是表示位置的。</p>
</div>
<div class="note info simple"><p><code>POSITION</code> 和 <code>SV_POSITION</code> 的差异可见 Half-Pixel Offset</p>
</div>
<p>其中的 <code>TransformObjectToWorld</code> 和 <code>TransformWorldToHClip</code> 为自定义的坐标系转换的函数，如下所示：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In ShaderLibrary/Common.hlsl</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#include &quot;./UnityInput.hlsl&quot;</span></span><br><span class="line"></span><br><span class="line">float3 TransformObjectToWorld(float3 positionOS)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> mul(unity_ObjectToWorld,float4(positionOS,<span class="number">1.0</span>)).xyz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float4 TransformWorldToHClip(float3 positionWS)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> mul(unity_MatrixVP,float4(positionWS,<span class="number">1.0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个函数中用到了两个矩阵 <code>unity_ObjectToWorld</code> 和 <code>unity_MatrixVP</code> ，定义如下所示：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In ShaderLibrary/UnityInput.hlsl</span></span><br><span class="line">float4x4 unity_ObjectToWorld;</span><br><span class="line">float4x4 unity_MatrixVP;</span><br></pre></td></tr></table></figure>
<div class="note info simple"><p>在 HLSL 中直接定义的变量即为 <code>Uniform</code> 变量，上述两个变量的命名与 Unity 内置着色器的变量名相同，因此 Unity 可以找到这两个 <code>Uniform</code> 变量并为其赋值。</p>
</div>
<p><code>UnityInput.hlsl</code> 和 <code>Common.hlsl</code> 为新增的 <code>.hlsl</code> 文件，并放置在 <code>ShaderLibrary</code> 文件夹中，前者是为了封装 Unity 内置 Uniform 变量输入，后者是为了封装一些常用的函数。即此时文件结构为：<br>
<img src="/draw_calls/drawcall-4.png" alt="Project Structure"></p>
<p>此时的结果如下所示，即可以看到一个正确的小球，因为我们已经完成了对于顶点着色器的设置的，但小球仍然是黑色的，因为我们尚未对片段着色器做设置：<br>
<img src="/draw_calls/image-20240302183509.png" alt="Black Sphere | 300"></p>
<h2 id="Core_RP_Library"><a class="header-anchor" href="#Core_RP_Library">#</a>Core RP Library</h2>
<p>像上述的 <code>TransformObjectToWorld</code> 和 <code>TransformWorldToHClip</code> 是非常通用的函数，Unity 提供了 包 <code>Core RP Pipeline</code> 封装了这些函数的实现。可通过 Unity Package Manager 并选择 <code>Core RP Library</code> 进行安装：</p>
<div class="note primary simple"><p>当导入了 <code>Core RP Pipeline</code> 后，相关的源码可以在 <code>&lt;ProjectPath&gt;Library\\PackageCache\\com.unity.render-pipelines.core@&lt;version&gt;\\</code> 中查看</p>
</div>
<p>因此可以使用 <code>Core RP Pipeline</code> 的 <code>SpaceTransform.hlsl</code> 中 的内容替代自己实现的版本。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In Common.hlsl</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#include &quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/SpaceTransforms.hlsl&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// float3 TransformObjectToWorld(float3 positionOS)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     return mul(unity_ObjectToWorld,float4(positionOS,1.0)).xyz;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// float4 TransformWorldToHClip(float3 positionWS)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     return mul(unity_MatrixVP,float4(positionWS,1.0));</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<p>因为 <code>Core RP Pipeline</code> 中使用的变量与 Unity 中使用的 Shader 参数命名不相同，因此需要通过 <code>define</code> 将两者进行转换。如 <code>unity_ObjectToWorld</code> 变量，在 <code>SpaceTransform.hlsl</code> 中对应使用的变量为 <code>Unity_MATRIX_M</code> ，因此需要将 <code>unity_ObjectToWorld</code> 转换为 <code>Unity_MATRIX_M</code>，以保证 <code>SpaceTransform.hlsl</code> 可以正常工作，转换语句为：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> UNITY_MATRIX_M unity_ObjectToWorld</span></span><br></pre></td></tr></table></figure>
<p>与 <code>UNITY_MATRIX_M</code> 一样，<code>SpaceTransform.hlsl</code> 中还有许多变量需要相同的处理，如下的代码将所有这些代码与 Unity 内置的 Shader 参数命名对应在一起：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#define UNITY_MATRIX_M unity_ObjectToWorld</span></span><br><span class="line"><span class="meta">#define UNITY_MATRIX_I_M unity_WorldToObject</span></span><br><span class="line"><span class="meta">#define UNITY_MATRIX_V unity_MatrixV</span></span><br><span class="line"><span class="meta">#define UNITY_MATRIX_I_V unity_MatrixInvV</span></span><br><span class="line"><span class="meta">#define UNITY_MATRIX_VP unity_MatrixVP</span></span><br><span class="line"><span class="meta">#define UNITY_PREV_MATRIX_M unity_prev_MatrixM</span></span><br><span class="line"><span class="meta">#define UNITY_PREV_MATRIX_I_M unity_prev_MatrixIM</span></span><br><span class="line"><span class="meta">#define UNITY_MATRIX_P glstate_matrix_projection</span></span><br></pre></td></tr></table></figure>
<p>所有需要用到的参数，都需要在 <code>UnityInput.hlsl</code> 中定义，即最终的 <code>UnityInput.hlsl</code> 如下所示：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">float4x4 unity_ObjectToWorld;</span><br><span class="line">float4x4 unity_WorldToObject;</span><br><span class="line">real4 unity_WorldTransformParams;</span><br><span class="line"></span><br><span class="line">float4x4 unity_MatrixVP;</span><br><span class="line">float4x4 unity_MatrixV;</span><br><span class="line">float4x4 unity_MatrixInvV;</span><br><span class="line">float4x4 unity_prev_MatrixM;</span><br><span class="line">float4x4 unity_prev_MatrixIM;</span><br><span class="line">float4x4 glstate_matrix_projection;</span><br></pre></td></tr></table></figure>
<p>其中的 <code>real4</code> 是一个根据平台定义的参数，根据不同的平台，它可能被定义为 <code>half4</code> 或 <code>float4</code> 。 <code>real4</code> 的定义在 <code>Core RP Pipeline</code> 的 <code>Common.hlsl</code> 中。</p>
<div class="note primary simple"><p>在 <code>UnityInput.hlsl</code> 中定义的变量相当于是声明，这些变量都是在 Unity Default Shader 中可以找寻到的，Unity 会负责将这些变量的值传递给 Shader。<br>
<code>Common.hlsl</code> 中则是通过 define，将 Unity Default Shader 中的变量名与 <code>Core RP Pipeline</code> 中函数所依赖的变量名对应起来。<br>
以定义在 <code>Core RP Pipeline</code> 中的 <code>SpaceTransforms.hlsl</code> 的函数 <code>GetObjectToWorldMatrix</code> 为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">float4x4 GetObjectToWorldMatrix()</span><br><span class="line">&#123;</span><br><span class="line">return UNITY_MATRIX_M;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它依赖变量 <code>UNITY_MATRIX_M</code> ，而 <code>UNITY_MATRIX_M</code> 正是通过我们在 <code>Common.hlsl</code> 中定义的 <code>#define UNITY_MATRIX_M unity_ObjectToWorld</code> 而得到的。<br>
<code>unity_ObjectToWorld</code> 又进一步是因为我们在 <code>UnityInput.hlsl</code> 中声明了<code>float4x4 unity_ObjectToWorld</code>，才能正确获取到 <code>unity_ObjectToWorld</code> 的值。</p>
</div>
<p>因此，最终自定义的 <code>Common.hlsl</code> 如下所示：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#include &quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#include &quot;./UnityInput.hlsl&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#define UNITY_MATRIX_M unity_ObjectToWorld</span></span><br><span class="line"><span class="meta">#define UNITY_MATRIX_I_M unity_WorldToObject</span></span><br><span class="line"><span class="meta">#define UNITY_MATRIX_V unity_MatrixV</span></span><br><span class="line"><span class="meta">#define UNITY_MATRIX_I_V unity_MatrixInvV</span></span><br><span class="line"><span class="meta">#define UNITY_MATRIX_VP unity_MatrixVP</span></span><br><span class="line"><span class="meta">#define UNITY_PREV_MATRIX_M unity_prev_MatrixM</span></span><br><span class="line"><span class="meta">#define UNITY_PREV_MATRIX_I_M unity_prev_MatrixIM</span></span><br><span class="line"><span class="meta">#define UNITY_MATRIX_P glstate_matrix_projection</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#include &quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/SpaceTransforms.hlsl&quot;</span></span><br></pre></td></tr></table></figure>
<p>上述引入的相互依赖关系如下：</p>
<ol>
<li>先引入 <code>Core RP Pipeline</code> 的 <code>Common.hlsl</code> 文件，保证 <code>real4</code> 变量被定义。</li>
<li>引入自定义的 <code>UnityInput.hlsl</code> 文件，保证需要的变量被定义，且用 Unity 定义的着色器变量的名称。</li>
<li>使用一系列 <code>define</code> 语句，将 Unity 引擎中定义的变量与 <code>Core RP Pipeline</code> 中需要用的变量联系在一起。</li>
<li>引入 <code>Core RP Pipeline</code> 的 <code>SpaceTransforms.hlsl</code> ，其中的 <code>TransformObjectToWorld</code> 和 <code>TransformWorldToHClip</code> 即为需要的函数。</li>
</ol>
<p>此时可以看到和之前一样被绘制出来的黑色小球：<br>
<img src="/draw_calls/image-20240302190739.png" alt="Black Sphere "></p>
<h2 id="Color"><a class="header-anchor" href="#Color">#</a>Color</h2>
<p>在 <code>UnlitPass.hlsl</code> 中新增变量 <code>_BaseColor</code> 并将该颜色作为像素输出的颜色，如下所示：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">float4 m_BaseColor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">float4 UnlitPassFragment():SV_TARGET &#123;</span><br><span class="line">    <span class="keyword">return</span> m_BaseColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了让该变量可以在 Unity 的 Material 面板中展现出来，需要在 <code>.shader</code> 文件的 <code>Properties</code> 中加入，如下所示：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Properties</span><br><span class="line">&#123;</span><br><span class="line">    m_BaseColor(&quot;Color&quot;, Color) = (<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的 <code>m_BaseColor</code> 对应在 <code>UnlitPass.hlsl</code> 中定义的变量， <code>&quot;Color&quot;</code> 为最终在 Inspector 面板中显示的名称， <code>Color</code> 为变量的类型，<code>(1.0, 1.0, 1.0, 1.0)</code> 为变量的初始值。</p>
<p>即在 <code>Properties</code> 中定义的变量，格式为：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">&lt;Target Parameter&gt;(&quot;&lt;DisplayName&gt;&quot;, &lt;Type&gt;) = &lt;<span class="keyword">default</span> Value&gt;</span><br></pre></td></tr></table></figure>
<h1 id="Batch"><a class="header-anchor" href="#Batch">#</a>Batch</h1>
<p>使用上述着色器，生成四个颜色不同的材质，如下所示：<br>
<img src="/draw_calls/drawcall-6.png" alt="Blue"><br>
<img src="/draw_calls/drawcall-7.png" alt="Red"><br>
<img src="/draw_calls/drawcall-8.png" alt="Green"><br>
<img src="/draw_calls/2024-03-02-21-28-55.png" alt="Yellow"></p>
<p>在场景内添加 76 个小球，并用上述的材质随机给小球添加，效果如下所示：</p>
<p><img src="/draw_calls/drawcall-9.png" alt="76 Spheres with random material"></p>
<p>在 Frame Debugger 中可以看到此时一共需要用到 78 个 DrawCall ，其中 76 个绘制小球，一个绘制天空盒，一个用来 Clear。如下所示<br>
<img src="/draw_calls/drawcall-10.png" alt="Frame Debugger"></p>
<p>但如果 Game 窗口的 Statistic 界面中，只能看到 77 个 <code>Batches</code> ，这是因为 <code>Batches</code> 的计算无视了 Clear 。<br>
<img src="/draw_calls/drawcall-11.png" alt="Game Statistic"></p>
<h2 id="SRP_Batcher"><a class="header-anchor" href="#SRP_Batcher">#</a>SRP Batcher</h2>
<p><code>Batching</code> 是将多个 Draw Call 结合在一起的过程。在 SRP 中最简单使用 <code>Batching</code> 的方法就是激活 <code>SRP Batcher</code> 功能，但这功能仅能在兼容的 Shader 中开启，上述自定义的 <code>Unlit</code> Shader 还不支持此功能，如下所示：<br>
<img src="/draw_calls/drawcall-12.png" alt=""></p>
<p><code>SRP Batcher</code> 本质上并没有减少 Draw Call 的数量，它只是将一些材质的 Uniform 数据缓存在 GPU 上，让 CPU 不需要每帧都去设置。这样同时减少了 CPU 处理数据的时间以及 CPU 向 GPU 传输的数据量。</p>
<p>所有可以被 <code>SRP Batcher</code> 缓存在 GPU 的 Uniform 数据都必须定义在一块地址不变的内存中，在 <code>SRP</code> 中可以通过将数据包裹在 <code>cbuffer</code>(Shader Constants Buffer) 定义的数据块中。</p>
<p>针对我们之前定义的 <code>UnlitPass.hlsl</code> Shader 就需要将 <code>m_BaseColor</code> 变量用 <code>cbuffer</code> 包裹，如下所示：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In UnlitPass.hlsl</span></span><br><span class="line">cbuffer UnityPerMaterial</span><br><span class="line">&#123;</span><br><span class="line">    float4 _BaseColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note warning simple"><p><code>SRP Batcher</code> 要求自定义的数据类型必须要放在名为 <code>UnityPerMaterial</code> 的数据块中，所有 Unity 内置的数据类型要放在名为 <code>UnityPerDraw</code> 的数据库中 [^2]。</p>
</div>
<p>但 <code>cbuffer</code> 并不是在所有的平台下都支持，如 OpenGL ES 2.0 就不支持，所以为了保证兼容性，可以可以使用如下的方式进行替代：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In UnlitPass.hlsl</span></span><br><span class="line"></span><br><span class="line">CBUFFER_START(UnityPerMaterial)</span><br><span class="line">    float4 m_BaseColor;</span><br><span class="line">CBUFFER_END</span><br></pre></td></tr></table></figure>
<p>同理，还需要将一些坐标转换的数据也放到 <code>cbuffer</code> 中，如下所示，其中的 <code>unity_LODFADE</code> 虽然没用到，但同样必须包裹在 <code>Cbuffer</code> 中：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In UnityInput.hlsl</span></span><br><span class="line"></span><br><span class="line">CBUFFER_START(UnityPerDraw)</span><br><span class="line">    float4x4 unity_ObjectToWorld;</span><br><span class="line">    float4x4 unity_WorldToObject;</span><br><span class="line">    float4 unity_LODFADE;</span><br><span class="line">    real4 unity_WorldTransformParams;</span><br><span class="line">CBUFFER_END</span><br></pre></td></tr></table></figure>
<p>当定义完后，Shader 就变为兼容 <code>SRP Batcher</code> ，如下所示：<br>
<img src="/draw_calls/drawcall-13.png" alt="|300 "></p>
<p>此时在自定义的渲染管线中，开启 <code>SRP Batcher</code> 即可，可以在自定义渲染管线构造时直接启用，如下所示：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In CustomRendererPipeline.cs</span></span><br><span class="line"></span><br><span class="line">public CustomRenderPipeline()</span><br><span class="line">&#123;</span><br><span class="line">    GraphicsSettings.useScriptableRenderPipelineBatching = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时在 Game 界面的 Statistic 窗口查看，可以看到仍然显示 77 个 Batches，而 <code>Saved by batching</code> 则变成了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>76</mn></mrow><annotation encoding="application/x-tex">-76</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">76</span></span></span></span> 个，如下所示：<br>
<img src="/draw_calls/drawcall-14.png" alt="Frame Debugger"></p>
<p>之所以 <code>Saved by batching</code> 出现负数是因为 Unity 的 Statistic 窗口对于 SRP 存在 Bug，因此更好的选择是通过 Frame Debugger 查看，如下所示可以看到仅有一个 Batch：<br>
<img src="/draw_calls/drawcall-15.png" alt="Only Batch In Frame Debugger"></p>
<div class="note primary simple"><p>上图中 Draw Calls 仍然是 76，因为 <code>SRP Batcher</code> 并未合并 DrawCall，只是在 GPU 缓存了数据，减少了数据的传输和准备时间。</p>
</div>
<p>SRP Batcher 的实现原理中，真正关心的是材质的 GPU 的内存的分布是否相同。因此不同的材质只要使用相同的着色器时，他们的 <code>UnityPerMaterial</code> 的内存分布都是相同的，因此可以被合并。</p>
<p>如在上述的例子中，虽然使用了四种不同的材质来绘制小球，但最终所有的都被合并到一个 Batch 中，这是因为这四个材质实际上都是使用同一个 Shader。</p>
<div class="note warning simple"><p>Unity 实际上判断的是着色器是否相同。因此如果两个不同的着色器定义了相同的 <code>UnityPerMaterial</code> 内存，仍然是没法被合并的。</p>
</div>
<h2 id="Many_Colors"><a class="header-anchor" href="#Many_Colors">#</a>Many Colors</h2>
<p>在开发过程中，如果有更多的小球需要有更多不同的颜色，为每种颜色都创建一个材质是不现实的。因此需要在运行时去修改已有的材质。</p>
<p>如下定义了脚本 <code>PerObjectMaterialProperties</code>，该脚本通过 <code>m_BaseColor</code> 去修改 <code>MaterialPropertyBlock</code>达到修改材质颜色的目标 ：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line">[<span class="meta">DisallowMultipleComponent</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PerObjectMaterialProperties</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> s_BaseColorId = Shader.PropertyToID(<span class="string">&quot;m_BaseColor&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MaterialPropertyBlock s_Block;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> Color m_BaseColor = Color.white;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span> &#123; OnValidate(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnValidate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        s_Block ??= <span class="keyword">new</span> MaterialPropertyBlock();</span><br><span class="line">        s_Block.SetColor(s_BaseColorId, m_BaseColor);</span><br><span class="line">        GetComponent&lt;Renderer&gt;().SetPropertyBlock(s_Block);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note primary simple"><p>关于 <code>MaterialPropertyBlock.SetXXX</code> 和 <code>Material.SetXXX</code> 的区别见 Material Property Blocks 。概括而言 <code>MaterialPropertyBlock</code> 保证了材质不会被拷贝，虽然每个物体都设置了自己的 Material Property，但它们仍然使用的是一个材质。</p>
</div>
<div class="note primary simple"><p>因为小球的颜色实际上上是由 <code>PerObjectMaterialProperties</code> 通过 Material Property 决定的，所有此时所有小球使用同一个材质仍然可以拥有不同的颜色。</p>
</div>
<p>此时的效果为：<br>
<img src="/draw_calls/2024-03-03-14-15-09.png" alt="Many Colors"></p>
<p><code>SRP Batch</code> 并无法处理运行时的 <code>Per-Object</code> 的 Material Property，因此此时查看 Frame Debugger，会发现所有的小球都是单独的 DrawCall 进行绘制的：</p>
<p><img src="/draw_calls/2024-03-03-11-19-33.png" alt="DrawCall for every Sphere"></p>
<p>针对这种 <code>Per-Object</code> 的 Material Property 修改情况，可以使用 <a href="/draw_calls/#gpu_instancing">GPU Instancing</a> 进行处理。</p>
<h2 id="GPU_Instancing"><a class="header-anchor" href="#GPU_Instancing">#</a>GPU Instancing</h2>
<p>对于同一个材质，但是因为使用了 <code>MaterialPropertyBlock</code> 而打断 Batch 的情况，可以使用 <code>GPU Instancing</code> 将它们合并为一个 DrawCall 进行渲染。 CPU 会将这些物体各自对于材质的修改组合成一个数组（ <code>Instanced Data</code>）并一次性送给 GPU，GPU 在渲染它们时使用 index 进行区分。</p>
<p>OpenGL 中 GPU Instancing 的实现可见 Instancing</p>
<p>目前实现的 Shader 是不支持 GPU Instancing 的。为了让其支持 Instancing，首先需要加上 <code>multi_compile_instancing</code> 的关键字，如下所示：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Unlit.shader</span></span><br><span class="line">Pass</span><br><span class="line">&#123;</span><br><span class="line">    HLSLPROGRAM</span><br><span class="line">    <span class="meta">#pragma multi_compile_instancing</span></span><br><span class="line">    <span class="meta">#pragma vertex UnlitPassVertex</span></span><br><span class="line">    <span class="meta">#pragma fragment UnlitPassFragment</span></span><br><span class="line">    <span class="meta">#include &quot;UnlitPass.hlsl&quot;</span></span><br><span class="line">    ENDHLSL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时可以看到使用了该 Shader 的材质面板中出现了 <code>Enable GPU Instancing</code> 关键字，如下所示，带上该关键字后，Unity 在编译时会为 Shader 生成两份代码，一份支持 Instancing，一份不支持：<br>
<img src="/draw_calls/drawcall-17.png" alt=""></p>
<p>但勾选了选项后会发现使用了同一材质的物体并没有被合并为一个 Shader 进行渲染，这是因为 Unity 在编译时需要知道哪些数据需要被组合为 <code>Instanced Data</code>的，因此 Shader 具体的实现也需要对应的更改。</p>
<p>为了构建 <code>Instanced Data</code>，首先需要引入 <code>Core RP Library</code> 中的 <code>UnityInstancing.hlsl</code> ，该 Shader 封装了一系列 Instancing 相关的函数，如通过 Instancing 的 Index 去访问 Instanced Data。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Common.hlsl</span><br><span class="line">#include &quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/UnityInstancing.hlsl&quot;</span><br><span class="line">#include &quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/SpaceTransforms.hlsl&quot;</span><br></pre></td></tr></table></figure>
<p>Unity 中整个支持 Instancing 的 Shader 的逻辑大致为，Instancing Index 在顶点着色器中被输入，经过转换传递给片段着色器，最终在片段着色器中根据 Index 获取到对应的数值。<code>UnlitPass.hlsl</code> 中的主体代码将修改为如下形式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// In UnlitPass.hlsl</span><br><span class="line">UNITY_INSTANCING_BUFFER_START(UnityPerMaterial)</span><br><span class="line">    UNITY_DEFINE_INSTANCED_PROP(float4, m_BaseColor)</span><br><span class="line">UNITY_INSTANCING_BUFFER_END(UnityPerMaterial)</span><br><span class="line"></span><br><span class="line">struct Attributes &#123;</span><br><span class="line">    float3 positionOS: POSITION;</span><br><span class="line">    UNITY_VERTEX_INPUT_INSTANCE_ID</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Varyings &#123;</span><br><span class="line">    float4 positionCS : SV_POSITION;</span><br><span class="line">    UNITY_VERTEX_INPUT_INSTANCE_ID</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Varyings UnlitPassVertex(Attributes input) &#123;</span><br><span class="line">    Varyings output;</span><br><span class="line">    UNITY_SETUP_INSTANCE_ID(input)</span><br><span class="line">    UNITY_TRANSFER_INSTANCE_ID(input, output);</span><br><span class="line">    float3 positionWS = TransformObjectToWorld(input.positionOS.xyz);</span><br><span class="line">    output.positionCS = TransformWorldToHClip(positionWS);</span><br><span class="line">    return output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float4 UnlitPassFragment(Varyings input) : SV_TARGET &#123;</span><br><span class="line">    UNITY_SETUP_INSTANCE_ID(input)</span><br><span class="line">    return UNITY_ACCESS_INSTANCED_PROP(UnityPerMaterial, m_BaseColor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相较于之前 <code>UnlitPass.hlsl</code> 的代码，这里的改动主要在于：</p>
<ol>
<li>使用 <code>Attributes</code> 和 <code>Varying</code> 结构体封装顶点着色器和片段着色器的输入，且每个结构体中，都用 <code>UNITY_VERTEX_INPUT_INSTANCE_ID</code> 标记其中的相关数据是与 Instancing Index ID 绑定的。</li>
<li>使用 <code>UNITY_INSTANCING_BUFFER_START</code> 和 <code>UNITY_INSTANCING_BUFFER_END</code> 包裹需要 Instanced 的数据</li>
<li>使用 <code>UNITY_SETUP_INSTANCE_ID</code> 获取输入数据所对应的 instancing index id，使用 <code>UNITY_TRANSFER_INSTANCE_ID</code> 将输入的 instancing index id 拷贝给输出。</li>
<li>使用 <code>UNITY_ACCESS_INSTANCED_PROP</code> 访问 Instanced Data</li>
</ol>
<div class="note primary simple"><p>通常 <code>UnityPerMaterial</code> 的数据需要被标记为 Instanced Data 。 <code>UnityPerDraw</code> 的数据，如 <code>unity_ObjectToWorld</code> 是不需要被标记为 Instanced Data。</p>
</div>
<div class="note primary simple"><p>Instanced Data 同样兼容 SRP Batcher，两者并不是相互冲突的设置，即一个材质可以同时支持 SRP Batcher 和 GPU Instancing。</p>
</div>
<p>当 Shader 修改完成后，选择小球使用的 Material，并在其中选择 <code>Enable GPU Instancing</code>：<br>
<img src="/draw_calls/2024-03-03-14-19-51.png" alt="Enable GPU Instancing"></p>
<p>此时通过 Frame Debugger 可以看到之前所有的 DrawCall 都被一个 Instanced Draw 合并：<br>
<img src="/draw_calls/2024-03-03-14-20-54.png" alt="One Instanced Draw"></p>
<h2 id="Drawing_Many_Instanced_Meshes"><a class="header-anchor" href="#Drawing_Many_Instanced_Meshes">#</a>Drawing Many Instanced Meshes</h2>
<p>上一节中，已经可以让场景内多个使用相同材质，但被 <code>MaterialPropertyBlock</code> 修改的物体通过 GPU Instancing 一次性被渲染。</p>
<p>但如果要一次性生成大量的物体，如 1000 个小球，每个都需要有不同的颜色。此时继续通过 <code>PerObjectMaterialProperties</code> 进行修改的话，那就需要创建许多的 <code>MonoBehaviour</code> 实例，而这对于性能是不友善的。</p>
<p>针对这种需求，更普遍的做法是在代码中通过 <code>Graphics.DrawMeshInstanced</code> 进行绘制，如下所示：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DrawMassiveMeshBall</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> s_BaseColorId = Shader.PropertyToID(<span class="string">&quot;m_BaseColor&quot;</span>);</span><br><span class="line"></span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> Mesh m_Mesh = <span class="literal">default</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> Material m_Material = <span class="literal">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Matrix4x4[] m_Matrices = <span class="keyword">new</span> Matrix4x4[<span class="number">1023</span>];</span><br><span class="line">    <span class="keyword">private</span> Vector4[] m_BaseColors = <span class="keyword">new</span> Vector4[<span class="number">1023</span>];</span><br><span class="line">    <span class="keyword">private</span> MaterialPropertyBlock m_Block;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i != m_Matrices.Length; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            m_Matrices[i] = Matrix4x4.TRS(Random.insideUnitSphere * <span class="number">10f</span>, Quaternion.identity, Vector3.one);</span><br><span class="line">            m_BaseColors[i] = <span class="keyword">new</span> Vector4(Random.<span class="keyword">value</span>, Random.<span class="keyword">value</span>, Random.<span class="keyword">value</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_Block == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_Block = <span class="keyword">new</span> MaterialPropertyBlock();</span><br><span class="line">            m_Block.SetVectorArray(s_BaseColorId, m_BaseColors);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Graphics.DrawMeshInstanced(m_Mesh, <span class="number">0</span>, m_Material, m_Matrices, <span class="number">1023</span>, m_Block);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Graphics.DrawMeshInstanced</code> 所接纳的形参分别是绘制用的 Mesh，Mesh 中的 SubMeshIndex（这里为 0），绘制用的材质，表示绘制 Mesh 位姿的 Matrices 绘制的数量，以及所用的 Material Property Block。注意这里通过 <code>MaterialPropertyBlock.SetVectorArray</code> 将绘制小球所需要的 Colors 一次性设置给了 Material Property Block。</p>
<p>此时可以看到的效果为：<br>
<img src="/draw_calls/drawcall-19.png" alt="Massive Spheres"></p>
<p>此时可以从 Frame Debugger 中看到绘制了 1023 个小球仅用了 3 个 DrawCall：</p>
<p><img src="/draw_calls/drawcall-20.png" alt="Three Draw Call"></p>
<h2 id="Dynamic_Batching"><a class="header-anchor" href="#Dynamic_Batching">#</a>Dynamic Batching</h2>
<p>还有一种方法减少 DrawCall 的方法称为 <code>Dynamic Batching</code>，该方法将多个拥有相同材质小的 Mesh 动态结合为一个大的 Mesh，达到可以一次性渲染的目的。</p>
<p><code>Dynamic Batching</code> 与 <code>GPU Instancing</code> 是互斥的，因此当需要用 <code>Dynamic Batching</code> 时，需要在 <code>DrawSetting</code> 中将 <code>GPU Instancing</code> 关闭，如下所示：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CameraRenderer.cs</span></span><br><span class="line">DrawingSettings drawingSettings = <span class="keyword">new</span> DrawingSettings(unlitShaderTagId, sortingSettings)</span><br><span class="line">&#123;</span><br><span class="line">    enableDynamicBatching = <span class="literal">true</span>,</span><br><span class="line">    enableInstancing = <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>且 <code>SRP Batcher</code> 比 Dynamic Batching 也有更高的优先级，所以也需要将其关闭：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CustomRenderPipeline.cs</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CustomRenderPipeline</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    GraphicsSettings.useScriptableRenderPipelineBatching = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于可以被<code>Dynamic Batching</code> 的小 Mesh，Unity 也有<a href="https://docs.unity3d.com/Manual/DrawCallBatching.html">一系列的限制</a>，如：</p>
<ol>
<li>顶点数必须在 300 以下，顶点数据（一个顶点可能有多个顶点数据）的数量必须在 900 以下</li>
<li>不能有镜像的大小，如一个物体的尺寸是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，另一个物体的尺寸是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>，这两物体不会被 Batch 在一起。</li>
<li>不能拥有一样的材质</li>
<li>带有不同烘焙贴图参数的物体不能被 Batch 在一起</li>
<li>不能被 <code>Multi-Pass</code> 的 Shader 打断</li>
</ol>
<div class="note warning simple"><p><code>Dynamic Batching</code> 还可能造成的一些Bug，如当物体有不同的 Scale 时，较大物体的法线不能保证为 Unit Vector。</p>
</div>
<p>因为 Unity 中的默认的 Sphere 物体，顶点数是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>515</mn></mrow><annotation encoding="application/x-tex">515</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">515</span></span></span></span> 个，不满足上述条件 1，因此无法被 <code>Dynamic Batching</code> 在一起。而默认的 Cube 物体，顶点数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>24</mn></mrow><annotation encoding="application/x-tex">24</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">24</span></span></span></span> 个，满足条件，因此可使用 Cube 作为测试 <code>Dynamic Batching</code> 的物体。</p>
<p>如下为 76 Cube，使用了四种不同的材质，渲染的效果如下所示：<br>
<img src="/draw_calls/drawcall-21.png" alt="76 Cubes"></p>
<p>此时查看 Frame Debugger，可以看到 76 个 Cubes 使用了 7 个 DrawCall 完成了渲染：</p>
<p><img src="/draw_calls/drawcall-22.png" alt="7 DrawCall"></p>
<div class="note primary simple"><p>通常情况下， <code>GPU Instancing</code> 是比 <code>Dynamic Batching</code> 更好的解决方法，因为少了很多限制，也不会产生 Bug。</p>
</div>
<div class="note primary simple"><p>当多个小 Mesh 使用了同一材质，但是用了 <code>MaterialPropertyBlock</code> 修改时， <code>Dynamic Batching</code> 也不生效。</p>
</div>
<h2 id="Configuring_Batching"><a class="header-anchor" href="#Configuring_Batching">#</a>Configuring Batching</h2>
<p>上述介绍了三种减少 DrawCall 的方法， <code>SRP Batcher</code> ， <code>GPU Instancing</code> ，<code>Dynamic Batching</code> 。而 <code>Dynamic Batching</code> 与前两者互斥，在之前的代码中，是直接通过 Hard Code 来切换不同的特性，而理想上需要动态的根据所选择的减少 DrawCall 的方式去调整代码。</p>
<p>解决思路为创建 <code>CustomRenderPipeline</code> 时指定需要使用的特性，然后将选择一路传递给具体的 Renderer，Renderer 以此去调整参数，如下所示：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CustomRenderPipelineAsset.cs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomRenderPipelineAsset</span> : <span class="title">RenderPipelineAsset</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> <span class="built_in">bool</span> m_UseDynamicBatching = <span class="literal">true</span>;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> <span class="built_in">bool</span> m_UseGPUInstancing = <span class="literal">true</span>;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> <span class="built_in">bool</span> m_UseSRPBatcher = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> RenderPipeline <span class="title">CreatePipeline</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CustomRenderPipeline(m_UseDynamicBatching, m_UseGPUInstancing, m_UseSRPBatcher);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CustomRendererPipeline.cs</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">bool</span> m_UseDynamicBatching;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">bool</span> m_UseGPUInstancing;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CustomRenderPipeline</span>(<span class="params"><span class="built_in">bool</span> useDynamicBatching, <span class="built_in">bool</span> useGPUInstancing, <span class="built_in">bool</span> useSRPBatcher</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    m_UseDynamicBatching = useDynamicBatching;</span><br><span class="line">    m_UseGPUInstancing = useGPUInstancing;</span><br><span class="line">    GraphicsSettings.useScriptableRenderPipelineBatching = useSRPBatcher;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Render</span>(<span class="params">ScriptableRenderContext context, List&lt;Camera&gt; cameras</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    cameras.ForEach(camera =&gt; m_Renderer.Render(context, camera, m_UseDynamicBatching, m_UseGPUInstancing));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CameraRenderer.cs</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Render</span>(<span class="params">ScriptableRenderContext renderContext, Camera camera,<span class="built_in">bool</span> useDynamicBatching, <span class="built_in">bool</span> useGPUInstancing</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    DrawVisibleGeometry(useDynamicBatching, useGPUInstancing);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DrawVisibleGeometry</span>(<span class="params"><span class="built_in">bool</span> useDynamicBatching, <span class="built_in">bool</span> useGPUInstancing</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    DrawingSettings drawingSettings = <span class="keyword">new</span> DrawingSettings(unlitShaderTagId, sortingSettings)</span><br><span class="line">    &#123;</span><br><span class="line">        enableDynamicBatching = useDynamicBatching,</span><br><span class="line">        enableInstancing = useGPUInstancing</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Transparency"><a class="header-anchor" href="#Transparency">#</a>Transparency</h1>
<p>在材质中的 <code>Render Queue</code> 部分，可以看到有 <code>Transparent</code> 选项，如下所示，但这里的 <code>Transparent</code> 仅是修改物体的渲染顺序，而并不会改变物体的渲染特性。即此时将 <code>Base Color</code> 调整为半透明的，最终渲染的结果仍然是完全不透明的。<br>
<img src="/draw_calls/drawcall-23.png" alt="Render Queue"></p>
<h2 id="Blend_Modes"><a class="header-anchor" href="#Blend_Modes">#</a>Blend Modes</h2>
<p>为了真正实现半透明效果，需要开启 <code>Alpha Blending</code> ，在 Unity 中通过 <code>Blend [&lt;SrcBlend&gt;] [&lt;DstBlend&gt;]</code> 语句切换 Alpha Blending。当 <code>&lt;SrcBlend&gt;</code> 为 1， <code>&lt;DstBlend&gt;</code> 为 0 时 Alpha Blending 关闭，其余情况为打开。</p>
<p>为了让 <code>Unlit</code> Shader 支持半透明，可将其修改为：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Unlit.shader</span></span><br><span class="line">Properties</span><br><span class="line">&#123;</span><br><span class="line">    m_BaseColor(&quot;Color&quot;, Color) = (<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>)</span><br><span class="line">    [Enum(UnityEngine.Rendering.BlendMode)] m_SrcBlend(&quot;Src Blend&quot;, Float) = <span class="number">1</span></span><br><span class="line">    [Enum(UnityEngine.Rendering.BlendMode)] m_DstBlend(&quot;Dst Blend&quot;, Float) = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubShader</span><br><span class="line">&#123;</span><br><span class="line">    Pass</span><br><span class="line">    &#123;</span><br><span class="line">        Blend [m_SrcBlend] [m_DstBlend]</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时新建一个 <code>CustomUnlitTransparentYellow</code> 材质，并按如下设置：<br>
<img src="/draw_calls/drawcall-24.png" alt="CustomUnlitTransparentYellow"></p>
<p>并用该材质替代原来使用 <code>CustomUnlitYellow</code> 材质的小球，此时的效果如下：</p>
<p><img src="/draw_calls/drawcall-25.png" alt="Transparent Yellow Effect"></p>
<h2 id="Not_Writing_Depth"><a class="header-anchor" href="#Not_Writing_Depth">#</a>Not Writing Depth</h2>
<p>通常而言 <code>Transparent</code> 的物体渲染顺序为从远到近，也因此深度检测对 <code>Transparent</code> 在很多情况下是不产生效果的（从远到近渲染，新绘制的东西通常都会过深度测试）。因此可以选择在渲染 <code>Transparent</code> 时将深度缓冲的写入关闭，为了支持关闭深度检测，需要将 Shader 修改如下：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Unlit.shader</span></span><br><span class="line">Properties</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    [Enum(Off,<span class="number">0</span>,On,<span class="number">1</span>)] m_ZWrite (&quot;Z Write&quot;, Float) = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubShader</span><br><span class="line">&#123;</span><br><span class="line">    Pass</span><br><span class="line">    &#123;</span><br><span class="line">        ZWrite [_ZWrite]</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时的材质应当修改如下：<br>
<img src="/draw_calls/2024-03-03-16-18-24.png" alt="Turn off ZWrite"></p>
<h2 id="Texturing"><a class="header-anchor" href="#Texturing">#</a>Texturing</h2>
<p>为了让小球半透明，还可以使用带有半透明信息的贴图，在这里可以自定义一个 Shader <code>UnlitTransparentTexture.shader</code>，在 <code>Unlit.shader</code> 的基础上为了让材质支持纹理采样，首先需要在 Shader 的 <code>Properties</code> 中增加：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// UnlitTransparentTexture.shader</span></span><br><span class="line">Shader &quot;Custom RP/UnlitTexture&quot;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">Properties</span><br><span class="line">&#123;</span><br><span class="line">    m_BaseMap(&quot;Texture&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>2D</code> 表示为一张二维的纹理， <code>White</code> 表示默认值为 Unity 定义的白色纹理，最后的 <code>&#123;&#125;</code> 为早期 Unity 版本中对纹理的设置选项，目前已经废弃，但仍需要定义，避免一些奇怪的错误。</p>
<p>对纹理也需要定义特定的 Uniform 变量，变量的类型为 <code>TEXTURE2D</code> ，且需要额外增加一个 <code>SAMPLER</code> 类型的变量，作为控制纹理 Filter 和 Wrap 模式的采样器，我们将这些数据定义在新建的 <code>UnlitTransparentTexturePass.hlsl</code> 中，该文件以 <code>UnlitPass.hlsl</code> 作为基础，如下所示：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// UnlitTransparentTexturePass.hlsl</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">TEXTURE2D(m_BaseMap);</span><br><span class="line">SAMPLER(sampler_m_BaseMap);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>确保要将 <code>UnlitTransparentTexture.shader</code> 中 include 的 <code>hlsl</code> 修改为 <code>UnlitTransparentTexturePass.hlsl</code>。</p>
<div class="note warning simple"><p><code>SAMPLER</code> 变量的命名应该与 <code>TEXTURE2D</code> 相同，只不过前面添加 <code>sampler_</code> 字段。</p>
</div>
<p>此时创建的 Material，可以看到多了 <code>Texture</code> 的数据，除了纹理贴图的设置外，还有 <code>Tiling</code> 和 <code>Offset</code> 选项的设置，前者表示纹理 UV 的大小，后者表示 UV 的起始点。整体如下所示：<br>
<img src="/draw_calls/2024-03-03-16-38-30.png" alt="Material With Texture "></p>
<p><code>Tiling</code> 和 <code>Offset</code> 为 Unity 为每个纹理定义的 <code>Special Texture properties</code>，需要在着色器中定义对应的 <code>float4</code> 变量才行。该变量的命名规则为 <code>&lt;TextureName&gt;_ST</code> ，如上述纹理命名为 <code>m_BaseMap</code> ，则需要定义 <code>m_BaseMap_ST</code> ，且该变量可以作为 instanced data。因此定义如下所示：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// UnlitTransparentTexturePass.hlsl</span></span><br><span class="line"></span><br><span class="line">TEXTURE2D(m_BaseMap);</span><br><span class="line">SAMPLER(sampler_m_BaseMap);</span><br><span class="line"></span><br><span class="line">UNITY_INSTANCING_BUFFER_START(UnityPerMaterial)</span><br><span class="line">    UNITY_DEFINE_INSTANCED_PROP(float4, m_BaseColor)</span><br><span class="line">    UNITY_DEFINE_INSTANCED_PROP(float4, m_BaseMap_ST)</span><br><span class="line">UNITY_INSTANCING_BUFFER_END(UnityPerMaterial)</span><br></pre></td></tr></table></figure>
<p>之后就是在顶点着色器的输入中加入 UV 信息，并在经过 <code>Tiling</code> 和 <code>Offset</code> 的调整后传入片段着色器中，片段着色器中根据调整后的 UV 通过 <code>SAMPLE_TEXTURE2D</code> 函数采样纹理。整个改动如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// UnlitTransparentTexturePass.hlsl</span><br><span class="line">struct Attributes &#123;</span><br><span class="line">    float3 positionOS: POSITION;</span><br><span class="line">    float2 baseUV : TEXCOORD0;</span><br><span class="line">    UNITY_VERTEX_INPUT_INSTANCE_ID</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Varyings &#123;</span><br><span class="line">    float4 positionCS : SV_POSITION;</span><br><span class="line">    float2 baseUV : VAR_BASE_UV;</span><br><span class="line">    UNITY_VERTEX_INPUT_INSTANCE_ID</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Varyings UnlitPassVertex(Attributes input) &#123;</span><br><span class="line">    Varyings output;</span><br><span class="line">    UNITY_SETUP_INSTANCE_ID(input)</span><br><span class="line">    UNITY_TRANSFER_INSTANCE_ID(input, output);</span><br><span class="line">    float3 positionWS = TransformObjectToWorld(input.positionOS.xyz);</span><br><span class="line">    output.positionCS = TransformWorldToHClip(positionWS);</span><br><span class="line"></span><br><span class="line">    float4 baseST = UNITY_ACCESS_INSTANCED_PROP(unityPerMaterial, m_BaseMap_ST);</span><br><span class="line">    output.baseUV = input.baseUV * baseST.xy + baseST.zw;</span><br><span class="line"></span><br><span class="line">    return output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float4 UnlitPassFragment(Varyings input) : SV_TARGET &#123;</span><br><span class="line">    UNITY_SETUP_INSTANCE_ID(input)</span><br><span class="line"></span><br><span class="line">    float4 baseMap = SAMPLE_TEXTURE2D(m_BaseMap, sampler_m_BaseMap, input.baseUV);</span><br><span class="line">    float4 color = UNITY_ACCESS_INSTANCED_PROP(UnityPerMaterial, m_BaseColor);</span><br><span class="line">    return baseMap * color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时将原先场景中使用 <code>CustomUnlitRed</code> 材质的小球修改为使用 <code>CustomUnlitTextureRed</code> 材质，材质如下所示：<br>
<img src="/draw_calls/2024-03-03-16-56-17.png" alt="CustomUnlitTextureRed | 400"></p>
<p>此时的场景效果如下：<br>
<img src="/draw_calls/drawcall-27.png" alt="Red Transparent Texture"></p>
<p>在这个场景下，如果需要将 Batch 数降低到最低，应该首先开启 <code>CustomRP</code> 的 <code>Use SRP Batcher</code>，并让半透明的黄色小球的材质，也换为使用 <code>UnlitTransparentTexture.shader</code> 只不过材质为空，如下所示：<br>
<img src="/draw_calls/2024-03-03-17-10-17.png" alt="Yellow Texture"></p>
<p>此时查看 Frame Debugger，可以发现所有的小球，使用了两个 Batch 就绘制完成了：<br>
<img src="/draw_calls/2024-03-03-17-12-36.png" alt="Two Batch"></p>
<p>因为所有不透明的小球都是使用的一个 Shader <code>Unlit.shader</code>，而所有半透明的小球（无论使用了贴图与否）都使用了 <code>UnlitTransparentTexture.shader</code>。</p>
<h2 id="Alpha_Clipping"><a class="header-anchor" href="#Alpha_Clipping">#</a>Alpha Clipping</h2>
<p><code>Alpha Clipping</code> 是将一些不满足要求的像素直接丢弃掉避免渲染的方法，在 Unity 中也被称为 <code>Cutoff</code> 。</p>
<p>我们在 <code>UnlitTransparentTexture.shader</code> 和 <code>UnlitTransparentTexturePass.hlsl</code> 的基础上定义 <code>UnlitTransparentTextureCutoff.shader</code> 和 <code>UnlitTransparentTextureCutoffPass.hlsl</code> 以支持 <code>Cutoff</code> 特性。</p>
<p>为使用 <code>Alpha Clipping</code> ，首先需要定义它丢弃的阈值，即 <code>cutoff threshold</code> ，该变量也可以放在 <code>Unity Per Material</code> 中作为 Instanced Data。在片段着色器中通过 <code>clip</code> 函数剔除不需要的像素，该函数接受一个 float 类型的形参，当形参值小于 0 时，该像素会被丢弃。整个流程如下所示：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// UnlitTransparentTextureCutoff.shader</span></span><br><span class="line">Properties</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    m_Cutoff(&quot;Alpha Cutoff&quot;, Range(<span class="number">0.0</span>, <span class="number">1.0</span>)) = <span class="number">0.5</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UnlitTransparentTextureCutoffPass.hlsl</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">UNITY_INSTANCING_BUFFER_START(UnityPerMaterial)</span><br><span class="line">    UNITY_DEFINE_INSTANCED_PROP(float4, m_BaseColor)</span><br><span class="line">    UNITY_DEFINE_INSTANCED_PROP(float4, m_BaseMap_ST)</span><br><span class="line">    UNITY_DEFINE_INSTANCED_PROP(<span class="type">float</span>, m_Cutoff)</span><br><span class="line">UNITY_INSTANCING_BUFFER_END(UnityPerMaterial)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">float4 UnlitPassFragment(Varyings input) : SV_TARGET &#123;</span><br><span class="line">    UNITY_SETUP_INSTANCE_ID(input)</span><br><span class="line"></span><br><span class="line">    float4 baseMap = SAMPLE_TEXTURE2D(m_BaseMap, sampler_m_BaseMap, input.baseUV);</span><br><span class="line">    float4 color = UNITY_ACCESS_INSTANCED_PROP(UnityPerMaterial, m_BaseColor);</span><br><span class="line">    float4 base = baseMap * color;</span><br><span class="line">    clip(base.a - UNITY_ACCESS_INSTANCED_PROP(UnityPerMaterial, m_Cutoff));</span><br><span class="line">    <span class="keyword">return</span> baseMap * color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>此时效果如下所示：<br>
<img src="/draw_calls/gif_2021-6-10_9-00-17.gif" alt="Cutoff"></p>
<p>上示例子中，同时使用了 <code>Alpha Blending</code> 和 <code>Alpha Cutoff</code> 两个技术，但通常而言，这两个技术并不会一起使用。 <code>Alpha Blending</code> 使用时通常不会写入深度信息，而 <code>Alpha Cutoff</code> 使用时通常会写入深度信息。</p>
<p>当关闭了 <code>Alpha Blending</code> 并只使用 <code>Alpha Cutoff</code> 时，效果如下所示：<br>
<img src="/draw_calls/gif_2021-6-10_9-04-22.gif" alt="Only Cutoff"></p>
<p>在现代 GPU 中， <code>Alpha Clipping</code> 可能会打断 <code>Early-Z</code> 造成性能的下降，因此最好仅在需要的时候开启 <code>Alpha Clipping</code> 功能。</p>
<h2 id="Shader_Features"><a class="header-anchor" href="#Shader_Features">#</a>Shader Features</h2>
<p>现在实现的 <code>UnlitTransparentTextureCutoff.shader</code> 中，无论何种情况都会启用 Cutoff，而在某些情况下，我们会希望 Cutoff 被关闭。</p>
<p>Unity 的 Shader Features 功能可以根据 Shader 中 <code>Toggle</code> 的值增加或移除特定的宏，并根据宏调整 Shader 的编译。整体流程如下所示：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// UnlitTransparentTextureCutoff.shader</span></span><br><span class="line">Properties</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    m_Cutoff(&quot;Alpha Cutoff&quot;, Range(<span class="number">0.0</span>, <span class="number">1.0</span>)) = <span class="number">0.5</span></span><br><span class="line">    [Toggle(_CLIPPING)] m_Clipping(&quot;Alpha Clipping&quot;,<span class="type">float</span> ) =<span class="number">0</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">SubShader</span><br><span class="line">&#123;</span><br><span class="line">    Pass</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        HLSLPROGRAM</span><br><span class="line">        <span class="meta">#pragma shader_feature _CLIPPING</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        ENDHLSL</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UnlitTransparentTextureCutoffPass.hlsl</span></span><br><span class="line">float4 UnlitPassFragment(Varyings input):SV_TARGET</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="meta">#if defined(_CLIPPING)</span></span><br><span class="line">        clip(base.a - UNITY_ACCESS_INSTANCED_PROP(UnityPerMaterial, m_Cutoff));</span><br><span class="line">    <span class="meta">#endif</span></span><br><span class="line">    <span class="keyword">return</span> base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>#pragma shader_feature</code> 会让 Unity 根据在 <code>Toggle</code> 中定义的宏，即 <code>_CLIPPING</code> ，编译出两份不同的代码，一份是定义了 <code>_CLIPPING</code> ，一份是不定义的。</p>
<p>即对于使用了 <code>shader_feature</code> 且进行了不同配置的 Shader 而言，其在运行时实际上是不同的两份 Shader，也因此 <a href="/draw_calls/#srp_batcher">SRP Batcher</a> 并不生效。</p>
<h2 id="Cutoff_Per_Object"><a class="header-anchor" href="#Cutoff_Per_Object">#</a>Cutoff Per Object</h2>
<p>在之前的 <code>PerObjectMaterialProperties</code> 脚本中可以加入 <code>Cutoff</code> 的设置，如下所示：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PerObjectMaterialProperties.cs</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> s_CutoffId = Shader.PropertyToID(<span class="string">&quot;m_Cutoff&quot;</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">SerializeField</span>] <span class="keyword">private</span> <span class="built_in">float</span> m_Cutoff = <span class="number">0.5f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnValidate</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    s_Block.SetFloat(s_CutoffId, m_Cutoff);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：<br>
<img src="/draw_calls/2024-03-03-21-26-45.png" alt="Different Cutoff"></p>
<h2 id="Ball_of_Alpha_Clipped_Spheres"><a class="header-anchor" href="#Ball_of_Alpha_Clipped_Spheres">#</a>Ball of Alpha-Clipped Spheres</h2>
<p>同理在使用 Instanced Drawing 时，也可以随机设置小球的透明度，并以此触发 <code>Alpha Clipping</code> 效果，如下所示：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// InstancedDrawingMeshBall.cs</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i != matrices.Length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        matrices[i] = Matrix4x4.TRS(Random.insideUnitSphere * <span class="number">10f</span>,</span><br><span class="line">        Quaternion.Euler(Random.<span class="keyword">value</span> * <span class="number">360f</span>, Random.<span class="keyword">value</span> * <span class="number">360f</span>, Random.<span class="keyword">value</span> * <span class="number">360f</span>),</span><br><span class="line">        Vector3.one * Random.Range(<span class="number">0.5f</span>, <span class="number">0.1f</span>));</span><br><span class="line">        baseColors[i] = <span class="keyword">new</span> Vector4(Random.<span class="keyword">value</span>, Random.<span class="keyword">value</span>, Random.<span class="keyword">value</span>, Random.Range(<span class="number">0.5f</span>, <span class="number">1f</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：<br>
<img src="/draw_calls/drawcall-28.png" alt=""></p>
<h1 id="Reference"><a class="header-anchor" href="#Reference">#</a>Reference</h1>
<p><a href="https://catlikecoding.com/unity/tutorials/custom-srp/draw-calls/">Draw Calls (catlikecoding.com)</a></p>
<p><a href="https://docs.unity3d.com/Manual/shader-shaderlab-code-blocks.html">ShaderLab: adding shader programs</a></p>
<p><a href="https://docs.unity3d.com/Manual/SL-DataTypesAndPrecision.html">Shader data types and precision</a></p>
<p><a href="https://docs.unity3d.com/Manual/SL-UnityShaderVariables.html">Built-in shader variables</a></p>
]]></content>
      <tags>
        <tag>Unity</tag>
        <tag>SRP</tag>
      </tags>
  </entry>
  <entry>
    <title>C# Formattable String</title>
    <url>/formattable_string/</url>
    <content><![CDATA[<p><code>FormattableString</code>  是 C# 6.0 中引入的新类型之一，可以避免在非必要情况下执行了格式化字符串带来的性能开销。</p>
<p>使用如下示例如下，可以看出 <code>FormattableString</code> 将需要格式化的字符串创建和真正的格式化操作进行了拆分：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line"><span class="built_in">int</span> age = <span class="number">30</span>;</span><br><span class="line"><span class="built_in">decimal</span> weight = <span class="number">60.5</span>m;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 FormattableString</span></span><br><span class="line">FormattableString message = <span class="string">$&quot;<span class="subst">&#123;name&#125;</span> 年龄 <span class="subst">&#123;age&#125;</span>，体重 <span class="subst">&#123;weight&#125;</span> 公斤。&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 FormattableString 转换为 string 类型</span></span><br><span class="line"><span class="built_in">string</span> formattedMessage = message.ToString();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">Console.WriteLine(formattedMessage);</span><br></pre></td></tr></table></figure>
<h1 id="Performance"><a class="header-anchor" href="#Performance">#</a>Performance</h1>
<p>对于一些函数，需要在运行时判断是否需要输出 string，可以使用 <code>FormattableString</code> 保证格式化仅在真正需要使用 <code>string</code> 时才执行。这可以带来性能提升。</p>
<p>如下性能测试函数：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Test, Performance, Category(<span class="string">&quot;String&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">String_NotReallyOutput</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> unit = SampleUnit.Microsecond;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> outputStr = <span class="keyword">new</span> MeasurementSettings(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="string">&quot;Output using string&quot;</span>, unit);</span><br><span class="line">    <span class="keyword">var</span> outputFormattedStr = <span class="keyword">new</span> MeasurementSettings(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="string">&quot;Output using formatted string&quot;</span>, unit);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FakeOutput</span>(<span class="params"><span class="built_in">string</span> str</span>)</span> &#123; <span class="keyword">if</span> (<span class="literal">false</span>) Debug.Log(str); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FormattedFakeOutput</span>(<span class="params">FormattableString fStr</span>)</span> &#123; <span class="keyword">if</span> (<span class="literal">false</span>) Debug.Log(fStr.ToString()); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> age = <span class="number">23</span>, times = <span class="number">25</span>;</span><br><span class="line">    Measure.Method(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        FakeOutput(<span class="string">$&quot;Hello World with age <span class="subst">&#123;age&#125;</span> with times <span class="subst">&#123;times&#125;</span> &quot;</span>);</span><br><span class="line">    &#125;, outputStr).Run();</span><br><span class="line"></span><br><span class="line">    Measure.Method(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        FormattedFakeOutput(<span class="string">$&quot;Hello World with age <span class="subst">&#123;age&#125;</span> with times <span class="subst">&#123;times&#125;</span> &quot;</span>);</span><br><span class="line">    &#125;, outputFormattedStr).Run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>FormattableString</code> 的版本因为避免了格式化操作的进行，带来了约 5 倍的收益：<br>
<img src="/formattable_string/image-20230417094543917.png" alt=""></p>
<p>即使真正需要执行 String 格式化时，使用 <code>FormattableString</code> 也不会带来性能劣化，如下性能测试代码：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Test, Performance, Category(<span class="string">&quot;String&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">String_ReallyOutput</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> unit = SampleUnit.Microsecond;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> outputStr = <span class="keyword">new</span> MeasurementSettings(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="string">&quot;Output using string&quot;</span>, unit);</span><br><span class="line">    <span class="keyword">var</span> outputFormattedStr = <span class="keyword">new</span> MeasurementSettings(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="string">&quot;Output using formatted string&quot;</span>, unit);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FakeOutput</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">true</span>) Debug.Log(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FormattedFakeOutput</span>(<span class="params">FormattableString fStr</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">true</span>) Debug.Log(fStr.ToString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> age = <span class="number">23</span>, times = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line">    Measure.Method(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        FakeOutput(<span class="string">$&quot;Hello World with age <span class="subst">&#123;age&#125;</span> with times <span class="subst">&#123;times&#125;</span> &quot;</span>);</span><br><span class="line">    &#125;, outputStr).Run();</span><br><span class="line"></span><br><span class="line">    Measure.Method(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        FormattedFakeOutput(<span class="string">$&quot;Hello World with age <span class="subst">&#123;age&#125;</span> with times <span class="subst">&#123;times&#125;</span> &quot;</span>);</span><br><span class="line">    &#125;, outputFormattedStr).Run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>性能测试结果为：<br>
<img src="/formattable_string/image-20230417094729230.png" alt=""></p>
<p>但是如果在不需要进行格式化时，强制使用 <code>FormattableString</code> 则会带来性能劣化。</p>
<p>如下代码，可以看到针对字符串实际上并没有需要拼接的数据，但对于 <code>Formattted</code> 版本的函数，为了保证形参为 <code>FormattableString</code> 仍然加上了 <code>$</code> 符：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Test, Performance, Category(<span class="string">&quot;String&quot;</span>), TestCase(true), TestCase(false)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">String_UseZeroArgument</span>(<span class="params"><span class="built_in">bool</span> reallyOutput</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    MeasurementSettings outputStr = <span class="keyword">new</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="string">&quot;Output using string&quot;</span>, s_Unit);</span><br><span class="line">    MeasurementSettings outputFormattedStr = <span class="keyword">new</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="string">&quot;Output using formatted string&quot;</span>, s_Unit);</span><br><span class="line"></span><br><span class="line">    Measure.Method(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (reallyOutput)</span><br><span class="line">            ReallyOutput(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            FakeOutput(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;, outputStr).Run();</span><br><span class="line"></span><br><span class="line">    Measure.Method(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (reallyOutput)</span><br><span class="line">            ReallyFormattedOutput(<span class="string">$&quot;Hello World&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            FakeFormattedOutput(<span class="string">$&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;, outputFormattedStr).Run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，<code>FormattableString</code> 版本的函数在实际不需要输出时带来了约 10 倍的性能恶化：<br>
<img src="/formattable_string/image-20230417102028637.png" alt=""></p>
<h1 id="Override"><a class="header-anchor" href="#Override">#</a>Override</h1>
<p>尽可能的避免 <code>string</code> 和 <code>FormattableString</code> 的函数重载，因为编译器会优先选择 <code>string</code> 形参的版本，且在一些操作时可能会隐式的将 <code>FormattableString</code> 转换为 <code>string</code>，进而导致与预期违背的行为产生。</p>
<p>如下示例代码：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DO NOT</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sample</span>(<span class="params"><span class="built_in">string</span> <span class="keyword">value</span></span>)</span> =&gt; <span class="keyword">throw</span> <span class="literal">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sample</span>(<span class="params">FormattableString <span class="keyword">value</span></span>)</span> =&gt; <span class="keyword">throw</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">Sample(<span class="string">$&quot;Hello <span class="subst">&#123;name&#125;</span>&quot;</span>);</span><br><span class="line"><span class="comment">// ⚠ Call Sample(string)</span></span><br><span class="line"></span><br><span class="line">Sample((FormattableString)<span class="string">$&quot;Hello <span class="subst">&#123;name&#125;</span>&quot;</span>);</span><br><span class="line"><span class="comment">// Call Sample(FormattableString) because of the explicit cast</span></span><br><span class="line"></span><br><span class="line">Sample((FormattableString)<span class="string">$&quot;Hello <span class="subst">&#123;name&#125;</span>&quot;</span> + <span class="string">&quot;!&quot;</span>);</span><br><span class="line"><span class="comment">// Call Sample(string) because the operator FormattableString + string returns a string</span></span><br></pre></td></tr></table></figure>
<h1 id="Reference"><a class="header-anchor" href="#Reference">#</a>Reference</h1>
<p><a href="https://www.meziantou.net/interpolated-strings-advanced-usages.htm#interpolated-strings-a9996a-2">Interpolated strings: advanced usages - Meziantou’s blog</a></p>
]]></content>
      <tags>
        <tag>String</tag>
        <tag>C#</tag>
        <tag>Performance</tag>
      </tags>
  </entry>
  <entry>
    <title>《蛤蟆先生去看心理医生》 摘抄</title>
    <url>/ha_ma_xian_sheng_qu_kan_xin_li_yi_sheng/</url>
    <content><![CDATA[<h1 id="第三章_初见咨询师"><a class="header-anchor" href="#第三章_初见咨询师">#</a>第三章 初见咨询师</h1>
<p>心理咨询向来是一个自发的过程，咨询师和来访者双方都得出于自愿。所以这就意味着，只有当你是为自己而不是为取悦朋友们才想咨询的时候，我们才能真正合作。</p>
<h1 id="第四章_抑郁的原因"><a class="header-anchor" href="#第四章_抑郁的原因">#</a>第四章 抑郁的原因</h1>
<p>当说一个人处在‘儿童自我状态’时，是指他的行为和感受都像一个孩子。这不同于‘幼稚’，而是‘像孩子一样’。”</p>
<h1 id="第五章_成长的寓言"><a class="header-anchor" href="#第五章_成长的寓言">#</a>第五章 成长的寓言</h1>
<p>‘儿童自我状态’，是由童年残留的遗迹搭建而成，包含小时候体验过的所有情感。<br>
一个人刚出生时，它只具备几种最基本的情感。幼年时，这些基本情感逐渐发展演变成更微妙、更复杂的行为模式，<br>
这些行为模式成为一个人的核心，融为他自身的一部分，定义了他一生的行为。正因为这样，某些特定的情形和场景会激发一个人的基本行为模式，让人自动做出反应，所以人会和小时候一样去行动和感受。具体的情形和场景因人而异。</p>
<p>某些基本情感是与生俱来的，就好像红黄蓝三原色，对所有婴儿来说都是类似的。然而当人作为个体开始发展的时候，每个人的情绪和反应都变得越来越个人化，就好像几种原色混合在一起就变出各式各样微妙的色调和色差来。</p>
<p>儿童的基本情感：快乐，深情，愤怒，悲伤，恐惧。所有这些情感加在一起，就构成了所谓‘自然型儿童’，而这是整个‘儿童自我状态’的重要组成部分。</p>
<p>大多数的父母会尽最大的努力来养育孩子，很少有父母要故意伤害自己的孩子。可是，父母也是人，会不可避免地把他们的观念和行为传递给后代，正如他们一定会把自己的基因传给下一代一样。所以孩子们要学会的是，如何应对和防御因此而产生的后果。</p>
<p>每一个婴儿都必须学习如何调整他的基本行为，来应对自己所处的初始状况。这些调整，就像原子核一样，以后我们所有的行为都围绕着这个核心形成和发展。当然，人生后面阶段的许多其他事件也会对我们造成影响，但这些最早期的经历塑造了人格的雏形，所以我们无法否认也无法忘记它们。</p>
<div class="note icon-padding simple"><i class="note-icon fas fa-quote-left"></i><p>模型是一种强大的工具，但也有缺点。它们会让我们陷入特定的思维方式中，导致我们错失一些改善世界的机会<br>
———— <a href="/tan_lan_de_duo_ba_an">《贪婪的多巴胺》 摘抄</a></p>
</div>
<p>理解你的童年就是理解你自己的关键线索</p>
<h1 id="第六章_探索童年"><a class="header-anchor" href="#第六章_探索童年">#</a>第六章 探索童年</h1>
<p>如果你要更好地理解自己，就需要跟自己的情绪做联结，并理解这些情绪。如果你否认它们，不论是用无视还是压抑的方式，结果都像是做了截肢，就如身体的重要部位被切掉了一样，你在某种程度上成了一个残缺的人。</p>
<p>有的人发现在任何时候都很难承认自己感到愤怒。他总觉得如果别人知道他生气了，他就会受到惩罚。结果就是他吞下了怒火，却化成了内疚。</p>
<p>对于使用浮夸和愚蠢行为的人：<br>
除了顺从我父母的意愿之外，我还总是想要取悦他们。我不确定自己有没有成功过，但我记得很清楚，我想让他们对我满意，为我骄傲。”他又停下思索了一会儿，接着说：“也许这就是我变得爱炫耀的原因。他们对我的所作所为从没有满意过或被打动过，所以我就放任自己用浮夸和愚蠢的行为来博得他们的关注。</p>
<p>童年体验到的最强烈的情绪，不可避免地变成我们成年后经常有的感受。有诗人曾说‘孩子是成年人的父亲’，或许就是这个意思。</p>
<p>可对大多数人而言，成长的本质就是要减少并最终打破这样的依赖关系，这样才能成为一个独立自主的人。很少有人能完全达成这点，有些人能部分达成，而很多人则会依赖一辈子</p>
<h1 id="第七章_愤怒的表现"><a class="header-anchor" href="#第七章_愤怒的表现">#</a>第七章 愤怒的表现</h1>
<p>怄气的人是总绷着脸、阴沉沉的样子，而且安静得很反常。‘适应型儿童’的所有行为里，怄气是最能说明怎样用时间来稀释愤怒的例子。通常这是孩子在权威之下无法随心所欲才做出的反应。成年人或许会因为输掉一场权力斗争而生闷气，也是同样道理。说白了，怄气是输家在对强大的赢家做出反应。</p>
<p>当成年人怄气、撒泼、郁闷或是厌烦的时候，我们会想他们究竟是行为不当，还是在无意识或无法控制地重演童年的行为模式。</p>
<p>怄气会导致两个后果，都是负面的。第一个就是会被人嘲笑。看到一个成年人撒泼怄气是件蛮好笑的事情，但也让人尴尬。而更严重的后果是，这类行为告诉别人，这人是个失败者。</p>
<h1 id="第九章_秘密协议"><a class="header-anchor" href="#第九章_秘密协议">#</a>第九章 秘密协议</h1>
<p>“PLOM 代表了四个英文单词，意思就是‘可怜弱小的我呀’。这个游戏你每局都赢了，也可以说是输了，这取决于你自己的看法。”</p>
<ul>
<li>你可能对自己不诚实。为什么你总是遇到类似的事情？这些事情最后都让你显得很蠢，让对方占了上风，让你感觉又变回小时候那个可怜弱小的自己，到底是纯属倒霉，还是因为你用某种方式和对方共谋了这件倒霉事儿</li>
<li>我用‘共谋’是想说，你偷偷地或无意识地配合对方，来给自己制造不快，这就是在玩心理游戏，而且在游戏里输的人才算是赢家。</li>
</ul>
<p>越是能帮助你深入自我的概念，也越容易引发激烈的阻抗。因为这些概念最容易打破我们的心理平衡，它们最有可能带你走向深层的蜕变，而这个过程往往是痛苦的，</p>
<p>“处于‘父母自我状态’时，我们表现得正如自己的父母。记住，他们是我们最早接触的人，因此对我们的影响是不可估量的。‘父母状态’包含了自出生起，我们从父母那里学到的所有价值观和道德观，还包含了对生活的评判标准，让我们借此判断是非对错。这些价值观来自父母，所以父母是最能左右我们行为的人。他们的言行塑造了我们童年的生活，也不可避免地对我们之后的人生产生影响。”</p>
<ul>
<li>我们绝不是父母的翻版。虽然父母对我们影响极大，但每个人自身的独特性确保了我们不是父亲或母亲的复制品，而是独立的个体</li>
</ul>
<p>没有一种批判比自我批判更强烈，也没有一个法官比我们自己更严苛。能帮你的人是你自己，也只有你自己。有许多问题需要你向自己发问。比如你能停止自我批判吗？你能对自己好一些吗？也许最重要的问题是，你能开始爱自己吗？”</p>
<h1 id="第十一章_蛤蟆先生的选择"><a class="header-anchor" href="#第十一章_蛤蟆先生的选择">#</a>第十一章 蛤蟆先生的选择</h1>
<p>自我状态的的三位一体，分别是：父母、成人、儿童状态，这个三位一体代表了人格的结构。</p>
<p>‘成人自我状态’ 指我们用理性而不是情绪化的方式来行事。它让我们能应对此时此地正在发生的现实状况。</p>
<ul>
<li>在这个状态下，我们能计划、考虑、决定、行动，我们能理性而合理地行事。处于这个状态时，我们所有的知识和技能都能为自己所用，而不再被脑子里父母过去的声音所驱使，也不会被童年的情绪所围困。相反，我们能思考当下的状况，基于事实来决定要怎么做。</li>
</ul>
<p>只有在‘成人自我状态’里，才能学到关于自我的新知识。</p>
<ul>
<li>在‘儿童状态’时，你会体验到童年的感受，好的坏的都有。你会再现过去的情形，再次体验过去的情绪，可你学不到任何新的东西</li>
<li>在‘父母状态’时，基本上你不是在挑剔就是在教育别人。不管是哪种，你都在用言行重复从父母那里学来的观念和价值观，你会想证明给别人看，让别人接受你的观念和价值观。这种确信无疑的状态，就没法给新知识和新理念留出一席之地。旧的思想主宰着你，这就是为什么单靠争论不能改变一个人的想法，只会让人更固执己见。</li>
</ul>
<p>成人状态难，是因为这个过程需要艰辛的努力和刻意的思考。在另外两种状态时，像父母或儿童一样行事，几乎不需要去思考，因为我们知道要做什么、说什么，就好像在演戏一样。就好像出演一个我们最喜欢、最了解的角色，台词和动作都烂熟于心。比方说，有个角色叫‘生气鬼’。‘生气鬼’很懂该怎么表达愤怒。</p>
<p>没有人能‘让’我们产生什么感受，除非他们用蛮力胁迫你。说到底，是我们‘选择’了自己的感受。我们‘选择’了愤怒，我们‘选择’了悲伤。” 人们做这些选择时都是无意识的，更像是一种条件反射。</p>
<p>如果你为自己负责，就会认识到你对自己是有自主权的。因此你就知道自己有力量来改变处境，更重要的是，有力量改变你自己。</p>
<ul>
<li>而针对过去的父母，能做的只有原谅。</li>
</ul>
<h1 id="第十三章_人生坐标与心理游戏"><a class="header-anchor" href="#第十三章_人生坐标与心理游戏">#</a>第十三章 人生坐标与心理游戏</h1>
<p>将自己的经历告诉别人，而不会因此被嘲笑或排斥，是多么大的慰藉。</p>
<p>当人在成人状体时，会渐渐获得了一种能力，让他在回忆时不再谴责自己。他能找到事件之间的联系，能客观地去看，而不再感到内疚。慢慢地，他开始理解为什么有些事情会以那样的方式发生，以及它会带来怎样的影响。换句话说，人会在反思自己的所作所为，并从中学习领悟。</p>
<p>人可能在无意识中一手策划了各种情境，好让自己的剧本时不时上演。甚至，这意味着在他的潜意识里，关于他人生的“故事情节”早已布局好，有一股未知的力量正将他推向某个特定的结局。</p>
<p>但还有另一种活法，无须跟着预先设定的剧本走，甚至可以没有剧本，或者说，可以即兴发挥。这会让人感到害怕，没了剧本，你怎么知道该做什么或说什么呢？<em>剧本至少能让你不用思考，不用为自己做决定。</em> 可反过来，每一个全新的时刻都意味着独一无二的机会和挑战，又让人无比激动。</p>
<p>从出生到大约四五岁的时候，发生的一切都对你影响重大，还影响了你后来的成长，牵涉到你怎样看待自己和别人。这种影响是普遍存在的。就这样，你形成了对这个世界特有的看法，对你而言，这就是你看待事情的唯一方式。从那时起，你就生活在自己的世界里，用同一个视角看待一切事物。</p>
<ul>
<li>每个人的早年经历本质上是不同的，所以每个人看到的都是一个不同的世界。有时候，人们看到的世界如此不同，连信念和预设都不尽相同，最严重的时候，这些人在之后的人生里只能经过流血冲突才能达成和解</li>
</ul>
<p>在人大约四到五岁左右，会试图回答两个问题：</p>
<ol>
<li>我是怎么看自己的？我好吗？</li>
<li>‘我是怎么看别人的？他们好吗？’</li>
</ol>
<p>有四种回答：</p>
<ol>
<li>我好；你也好。</li>
<li>我好；你不好。</li>
<li>我不好；你好。</li>
<li>我不好；你也不好。</li>
</ol>
<p>就回答就成为了‘人生坐标’。一旦我们在童年决定用哪种态度和观点，我们就会在随后的人生里始终坚持自己的选择。这些态度和观点，变成我们存在的底层架构。从那以后，我们便建构出一个世界，不断确认和支持这些信念和预期。换一个词来说，我们把自己的人生变成了一个‘自证预言’。”</p>
<ul>
<li>‘自证预言’的意思是，我们会控制事件的发生，从而确保预言会成真。我们会确保自己的世界和预期的一样。”</li>
</ul>
<p>人生坐标理念不是用来给人贴标签，攻击羞辱别人的。它们只是用来理解行为的方法，尤其是理解我们自己的行为。”</p>
<h1 id="第十四章_赢了游戏_输了自己"><a class="header-anchor" href="#第十四章_赢了游戏_输了自己">#</a>第十四章 赢了游戏 输了自己</h1>
<h2 id="我不好，你好"><a class="header-anchor" href="#我不好，你好">#</a>我不好，你好</h2>
<p><code>我不好；你好</code> 代表了一个人的行为态度，这类人认为自己很差劲，别人都比他好。这些低自尊的人通常觉得生活对他们不好，却更善待别人。概括地说，处在这个坐标的人认为自己是生活的受害者，所以他们就玩那些会把他们变成受害者的游戏</p>
<ul>
<li>这些人会竭尽所能地选择记住那些悲伤和不快乐的事件，而忘记或忽略美好的时光。</li>
<li>他们认为自己的人生被不好的力量影响，无法掌控人生，这让他们焦虑，觉得自己不够好</li>
</ul>
<p>有些“我不好，你好”的人生活一团糟，或者有意无意惹上麻烦，就是想看看别人能宽容他们到什么程度，什么时候会排斥他们。接着他们就会说：‘我早说过你会这样对我，证明我是真的很差劲很愚蠢。</p>
<h2 id="我好，你不好"><a class="header-anchor" href="#我好，你不好">#</a>我好，你不好</h2>
<p>处于这个心理坐标的人常常会占据权力和权威的制高点，这样他们就能玩 <code>NIGYYSOB（Now i've got you, you son of bith）</code> 游戏。</p>
<p>这是人们经常在工作场合玩的游戏。首先，有个人犯了错，可以想象，这种情况很常见。然后上司发现了，把犯错的下属叫进来好一顿训斥，小题大做，对下属大声咆哮。所以你看，这种游戏能让愤怒的人找到看似正当的理由来发火，借此证实‘我好；你不好’的人生坐标。他们会证明别人根本上都是无能而不可信的，接下来，他们会把斥责和惩罚别人视为己任。他们会说：‘要不然，那帮人会觉得犯了错还能侥幸逃脱！’”</p>
<p>“很不幸，这种游戏似乎越来越常见，尤其是在机构组织里，权威人士很容易把自己想象成严厉的父母，把员工当成顽劣的孩子来惩罚。</p>
<p>在这个坐标游戏的人，永远都处于 <code>父母状态</code>，而且永远都是‘挑剔型父母状态’。这些人动不动就指责，焦虑得随时会发脾气，还想用不可能达到的标准来评判别人。当然了，有时候他们会摆出‘养育型父母’的姿态，说些诸如‘我比你更心痛’或‘我是为你好’之类的话，但大部分人都能听出这是虚情假意。</p>
<p>关于这类人的心理状态，还有一个有意思的现象，那就是他们从来不会抑郁。因为愤怒能够非常有效地抵抗抑郁。愤怒的人从不觉得内疚，因为他们总在怪罪别人。他们自卫的方式，是把自己内在的恐惧对外投射到别人身上，这样就能把对自己的怒火转向别人。</p>
<h1 id="第十五章_最后一次面谈"><a class="header-anchor" href="#第十五章_最后一次面谈">#</a>第十五章 最后一次面谈</h1>
<p>‘我好；你也好’的人生坐标并非静止的状态，而是动态的过程。你不能说‘好了，我终于到了’，好像登顶珠穆朗玛峰一样。你觉得自己是好的，也相信别人是好的，那就得靠行为和态度持续地对自己和别人展示出来。‘我好；你也好’其实是一种发自内心信念的行为</p>
<p>情商真正的意思是理解你内心的情感世界，并且还能掌控它，这和智商完全不是一回事。</p>
<p>高情商的人，概括而言，他们都有强大的自我意识，了解自己的情感。他们能管理情绪，能从悲伤和不幸中重新振作。但最重要的是，他们能控制冲动，也懂得延迟满足，从而避免轻率的决定和不妥的行为。</p>
<ul>
<li>情商和理解别人有关，一个高情商的人能辨识他人的感受，这种技能称为‘共情’。但也许情感智力中最大的技能是通过理解和回应对方的情感，与他人建立良好的关系。</li>
</ul>
<p>情感智力能让你在自我成长和完善的路上走得更远，因为它将带你从独立的个体走向共生的关系。</p>
<ul>
<li>独立性隐含了做自己的自豪感，还包括独特的才能、与众不同的部分。独立的人时刻守护新发现的自主权。</li>
<li>共生性则体现出成熟和自我接纳，还包括求同存异地接纳他人。共生性可以让你在社交和工作上与别人有效联结，协同合作 。</li>
</ul>
]]></content>
      <tags>
        <tag>心理学</tag>
      </tags>
  </entry>
  <entry>
    <title>《Good decision-making is good process》 摘抄</title>
    <url>/good_decision-making_is_good_process/</url>
    <content><![CDATA[<h1 id="用自己的术语定义问题"><a class="header-anchor" href="#用自己的术语定义问题">#</a>用自己的术语定义问题</h1>
<p>当遇到问题时，要克制住立即寻找解决方案的冲动。花时间理解问题并用自己的术语定义它，这个过程可以帮助你和定义原始问题的人弄清楚：</p>
<ol>
<li>你是否正在解决正确的问题</li>
<li>你是否最终的期望状态保持一致</li>
<li>你会不会在没有确认其他解决方案时就急于采取行动</li>
</ol>
<ul>
<li>
<p>在“识别问题”和“寻找解决方案” 之间建立明确的边界，如接下来的一小时，一天或一周是用来理解和定义问题的。问题问题越大，识别问题的时间就应该越长。</p>
</li>
<li>
<p>一旦你理解了问题所在，最好先休息下再进一步处理。人都有管窥效应，休息一下再投入解决问题，可以为大脑转移焦点，并为重新审视问题创造空间。</p>
</li>
</ul>
<p>!管窥所导致的忽视</p>
<h1 id="使用不同的视角来探索解决方案"><a class="header-anchor" href="#使用不同的视角来探索解决方案">#</a>使用不同的视角来探索解决方案</h1>
<p>人都会有认知偏差，会倾向于将明显的体验视作为“重要的”，同时无视那些隐性的体验。摆脱这种束缚的一种方法就是在寻求问题的解决方案时使用不同的视角。</p>
<h2 id="以时间旅行的视角去思考"><a class="header-anchor" href="#以时间旅行的视角去思考">#</a>以时间旅行的视角去思考</h2>
<p>问自己：在当下这个时间点，什么东西的出现能让这个问题解决。一年后，三年后，五年后，需要什么东西才能保持这个问题始终是解决的。</p>
<div class="note info simple"><p>可以通过止痛药在当下解决牙疼的问题，但可以通过止痛药让牙疼这个问题在五年中一直不出现吗？</p>
</div>
<h2 id="从终点处的视角倒推思考"><a class="header-anchor" href="#从终点处的视角倒推思考">#</a>从终点处的视角倒推思考</h2>
<p>假设你已经解决了问题，想象你通过了什么解决问题，需要依赖哪些东西。</p>
<p>在旅途的 3/4 处，1/2 处，1/4 处的检查点应该是什么，偏离轨道的信号又是什么？</p>
<h2 id="非二元的视角去思考"><a class="header-anchor" href="#非二元的视角去思考">#</a>非二元的视角去思考</h2>
<p>很多决策表面上看是二元的，但实际上并非如此：</p>
<ul>
<li>如果目前的选项都消失会怎么样？</li>
<li>如果目前的选项并不是 OR 而是 AND 会怎么样？</li>
</ul>
<h1 id="获取优质信息，评估和验证信息噪声"><a class="header-anchor" href="#获取优质信息，评估和验证信息噪声">#</a>获取优质信息，评估和验证信息噪声</h1>
<p>当定义问题和评估解决方案时，需要小心被传递了多手的信息。每一次的传播，信息的可靠性都会迅速恶化：错过信息的细节，选择性的编辑和重述。所以在找寻解决方案时，必须要验证关键事实和假设：</p>
<ul>
<li>找寻数据源</li>
<li>进行实验：实验经验是最重要的，即使是一次性的实验结果也好过没有实验结果</li>
<li>锻炼提问的能力：不要问别人的想法是什么，问别人是怎么思考的，然后找寻自己的答案</li>
</ul>
<h1 id="知道何时决定"><a class="header-anchor" href="#知道何时决定">#</a>知道何时决定</h1>
<div class="note info simple"><p>“做出正确决定”的行为价值被高估了，而“成为一个好学习者”的行为价值被低估了。</p>
</div>
<p>在做决定前，一个重要的能力是区分这个决定应该是 <code>早期确定决策（Early-Binding Decision）</code> 还是 <code>后期决定决策（Late-Binding Decision）</code>：</p>
<ul>
<li>早期决定决策：早期决定是需要是可逆的，他们可以基于部分（不完整）的信息快速做出。当决策的反转成本低时，早期绑定是有益的，因为它允许快速迭代和从实践中学习。</li>
<li>晚期决定策略：晚期决定通常很难逆转，因此需要在尽可能的收集和分析了所有相关信息后再做出决策。当决策复杂，风险高，逆转成本高时，晚期决定时有益的。</li>
</ul>
<p>一个常见的陷阱是过度希望自己是正确的，而忽略了学习率。过度寻求降低错误率，会导致过度分析以及更慢、更差的长期执行。对于早期决定决策，应当尽早承诺，欢迎负面发现，并快速迭代。</p>
<div class="note info simple"><p>一个好的决定并不一定意味着一个好的结果，从好的或坏的结果中优化学习率也很重要。</p>
</div>
<p>对于很难逆转的晚期决定，应当将需要回答的问题和输入信息尽量拆分，然后进行低成本的实验来获取更多信息。在做出最终决定前，尽可能的保持思想开放。当做出最终决定的时刻来临时，停下来反思一下：“我做的对吗，我是否获取到了足够的信息。” 如果此时有情绪被触发，那就是一个暂停信号，给自己一个重新评估的缓冲时间。</p>
<h1 id="Reference"><a class="header-anchor" href="#Reference">#</a>Reference</h1>
<p><a href="https://ilya.grigorik.com/good-decision-making-is-good-process-used-intentionally/">Good decision-making is good process (grigorik.com)</a></p>
]]></content>
      <tags>
        <tag>方法论</tag>
        <tag>How-To</tag>
      </tags>
  </entry>
  <entry>
    <title>《Head First 设计模式》 - 设计原则总结</title>
    <url>/head_first_design_pattern_design_principles/</url>
    <content><![CDATA[<ol>
<li>将变化的部分封装起来（Encapsulate what varies)</li>
<li>组合优于继承（Favor composition over inheritance）</li>
<li>面向接口编程而非实现（Program to interfaces, not implementations.）</li>
<li>减少需要交互的类之间的耦合（Strive for loosely coupled designs between objects that interact）</li>
<li>对拓展开放，对修改关闭（Classes should be open for extension but closed for modification.）</li>
<li>依赖于抽象而非具体的类（ Depend on abstraction. Do not depend on concrete classes）</li>
<li>暴露最少的信息给其他类（最少知识原则）（Talk only to your immediate friends）</li>
<li>高层有对底层的管理，而底层不需要关心高层何时会调用自己（好莱坞原则）（Don’t call us ,we’ll call you）</li>
<li>一个类应该有且只有一个被改变的理由（A class should have only one reason to change）</li>
</ol>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>《Head First 设计模式》 笔记汇总</title>
    <url>/head_first_design_patterns/</url>
    <content><![CDATA[<p><a href="/ch_01_the_strategy_pattern">Ch 01 the Strategy Pattern</a></p>
<p><a href="/ch_02_the_observer_pattern">Ch 02 the Observer Pattern</a></p>
<p><a href="/ch_03_the_decorator_pattern">Ch 03 the Decorator Pattern</a></p>
<p><a href="/ch_04_the_factory_pattern">Ch 04 the Factory Pattern</a></p>
<p><a href="/ch_05_the_singleton_pattern">Ch 05 the Singleton Pattern</a></p>
<p><a href="/ch_06_the_command_pattern">Ch 06 the Command Pattern</a></p>
<p><a href="/ch_07_the_adapter_and_facade_patterns">Ch 07 the Adapter and Facade Patterns</a></p>
<p><a href="/ch_08_the_template_method_pattern">Ch 08 the Template Method Pattern</a></p>
<p><a href="/ch_09_the_iterator_and_composite_pattern">Ch 09 the Iterator and Composite Pattern</a></p>
<p><a href="/ch_10_the_state_pattern">Ch 10 the State Pattern</a></p>
<p><a href="/ch_11_the_proxy_pattern">Ch 11 the Proxy Pattern</a></p>
<p><a href="/ch_12_the_compound_patterns">Ch 12 the Compound Patterns</a></p>
<p><a href="/head_first_design_pattern_design_principles">Head First Design Pattern Design Principles</a></p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity Input System Step-By-Step 最简教程</title>
    <url>/input_system_minimum_tutorial/</url>
    <content><![CDATA[<h1 id="Overview"><a class="header-anchor" href="#Overview">#</a>Overview</h1>
<div class="note info simple"><p>本教程极大程度的参考了 Unity Learn 上的官方教程[^1]，但并不是其翻译版本，而是根据我的学习过程进行相应增删改。<br>
完整工程见：<a href="https://github.com/xuejiaW/InputSystemSample">xuejiaW/InputSystemSample: A minimum unity project to illustrate how to use Unity new input system. (github.com)</a></p>
</div>
<p>Unity 有内建的 <code>Input Manager</code> 机制，这一套机制存在了非常久的时间。针对于传统的键盘，鼠标等输入，内置的 <code>Input Manager</code> 可以健壮的处理，但 <code>Input Manager</code> 的可拓展性不高。也因此随着输入设备种类的增多（如各类 XR 设备），<code>Input Manager</code> 无法优雅的解决这些输入。</p>
<p><code>Input System</code> 是 Unity 为了解决 <code>Input Manager</code> 的上述问题，提供的高可拓展性，高自由配置的新输入解决方案。</p>
<div class="note primary simple"><p>对于新工程，Unity 官方都推荐使用 <code>Input System</code> 作为输入的解决方案，但 <code>Input Manager</code> 并不会短期内被废弃，因为历史包袱过重[^2]。</p>
</div>
<div class="note info simple"><p>Input System 依赖 Unity 2019.1 及以上版本，本文档基于 Unity 2022.3.15f1 + Input System 1.7 编写</p>
</div>
<h1 id="Get_Started"><a class="header-anchor" href="#Get_Started">#</a>Get Started</h1>
<h2 id="安装_Input_System"><a class="header-anchor" href="#安装_Input_System">#</a>安装 Input System</h2>
<p>首先通过 Unity Package Manager 安装 Input System：<br>
<img src="/input_system_minimum_tutorial/2023-11-16-15-56-36.png" alt=""></p>
<p>在安装 Package 后，会自动弹出如下窗口，该窗口表示 <code>Input System</code> 启用后需要重启 Editor Backend 才能正常使用，点击 <code>Yes</code> 启用 Input System，此时 Unity Editor 会自动重启：<br>
<img src="/input_system_minimum_tutorial/2023-11-16-15-54-50.png" alt="启用 Input System"></p>
<p>当 Unity 重启后，根据 Unity 版本的不同，可能内置的 <code>Input Manager</code> 会被关闭，如果要重新启用，可以在 <code>Edit</code> -&gt; <code>Project Settings</code> -&gt; <code>Player</code> -&gt; <code>Other Settings</code> -&gt; <code>Active Input Handling</code> 中选择 <code>Both</code>：<br>
<img src="/input_system_minimum_tutorial/2023-11-16-15-59-49.png" alt="Player Settings 中切换输出方式"></p>
<p>至此 Input System 已经被正确安装。</p>
<p>为方便后续的调试，Demo 工程中预先引入了 URP 和一个最简的测试场景，此时的工程的见：A<br>
<a href="https://github.com/xuejiaW/InputSystemSample/tree/7d041a5604c71096b0147cd0ae672557eee517c8">xuejiaW/InputSystemSample at 7d041a5604c71096b0147cd0ae672557eee517c8 (github.com)</a></p>
<h2 id="创建_Input_System_Assets"><a class="header-anchor" href="#创建_Input_System_Assets">#</a>创建 Input System Assets</h2>
<p>为了使用 Input System，推荐先创建 Settings Asset，你需要在 <code>Project Settings</code> -&gt; <code>Input System Package</code> 中创建相关资源：</p>
<p><img src="/input_system_minimum_tutorial/2023-11-16-16-01-18.png" alt="Create Input System"></p>
<div class="note primary simple"><p>该 Settings Asset 作为 Input System 全局的配置，但其并不是必须项。如果未创建该文件 Unity 会使用默认的 Input System 配置。</p>
</div>
<p>当点击创建后，会在工程的根目录创建出一个 <code>InputSystem.inputsettings</code> 文件，该文件即是 Input System 的总配置文件。同时原 <code>Input System Package</code> 页面也会包含有一系列的针对于 <code>Input System</code> 的配置项：<br>
<img src="/input_system_minimum_tutorial/2023-11-16-16-13-41.png" alt="Input System Settings"></p>
<p>选择创建出来的 <code>InputSystem.inputsettings</code> 文件，在 Inspector 中会出现直接跳转到 <code>Input System Settings</code> 的按钮，点击该按钮，同样会跳转到上述 <code>Input System Settings</code> 的配置页面：<br>
<img src="/input_system_minimum_tutorial/2023-11-16-16-17-06.png" alt="Asset Inspector | 400"></p>
<div class="note primary simple"><p>你可以随意修改 <code>InputSystem.inputsettings</code> 的位置，并不要求该文件必须在工程根目录下。</p>
</div>
<p>此时的工程状态见：<br>
<a href="https://github.com/xuejiaW/InputSystemSample/tree/62aff15fcf5c3479e5a3073af7646a6c2775e043">xuejiaW/InputSystemSample at 62aff15fcf5c3479e5a3073af7646a6c2775e043 (github.com)</a></p>
<h2 id="查看_Input_Debugger_窗口"><a class="header-anchor" href="#查看_Input_Debugger_窗口">#</a>查看 Input Debugger 窗口</h2>
<p>你可以在 <code>Window -&gt; Analysis -&gt; Input Debugger</code> 中打开 Input Debugger 窗口，该窗口中可以显示当前连接的输入设备：<br>
<img src="2023-11-16-16-20-42.png" alt="Input Debugger 窗口"></p>
<h1 id="使用_Input_System"><a class="header-anchor" href="#使用_Input_System">#</a>使用 Input System</h1>
<h2 id="创建_Input_Action_Asset"><a class="header-anchor" href="#创建_Input_Action_Asset">#</a>创建 Input Action Asset</h2>
<p>如场景中有如下小球：<br>
<img src="/input_system_minimum_tutorial/2023-11-16-16-25-08.png" alt="Sphere"></p>
<p>为了让其移动，可以为它添加一个 <code>Player Input</code> 组件，在 <code>Player Input</code> 组件上，选择 <code>Create Action</code> 创建出一个 Input Action 资源：<br>
<img src="/input_system_minimum_tutorial/2023-11-17-15-09-59.png" alt=""></p>
<p>当点击后，会需要你选择保存的路径，选择后，会在该路径下创建出一个 <code>Input Action</code> 资源（ <code>Input System.inputactions</code>），并自动打开该资源的配置窗口，窗口如下所示：<br>
<img src="/input_system_minimum_tutorial/2023-11-16-16-28-43.png" alt="Input Action Window"></p>
<p>创建出来的 Input Action Asset 资源如下所示，当点击该资源上的 <code>Edit asset</code> 按钮或双击该资源，都将打开上述的窗口：<br>
<img src="/input_system_minimum_tutorial/2023-11-16-16-29-49.png" alt="Input Action Asset"></p>
<p>具体查看 Input Action Asset 中的 Move Action，可以看到其中通过定义了可以通过键盘的 <code>WASD</code> 和 <code>上下左右</code> 触发：<br>
<img src="/input_system_minimum_tutorial/2023-11-16-16-33-04.png" alt=""></p>
<p>此时按下 <code>WASD</code> 或 <code>上下左右</code>，会发现小球还 <strong>不能</strong> 移动，因为此时小球只是 <em>获取</em> 到了输入信息，但还是没有 <em>处理</em> 这些输入信息。</p>
<p>此时工程状态见：<br>
<a href="https://github.com/xuejiaW/InputSystemSample/tree/ed81be6f2efcf89c72f287240c9b56ea80a24094">xuejiaW/InputSystemSample at ed81be6f2efcf89c72f287240c9b56ea80a24094 (github.com)</a></p>
<h2 id="使用代码控制小球"><a class="header-anchor" href="#使用代码控制小球">#</a>使用代码控制小球</h2>
<p>为了处理 Input System 的输入信息，可以添加 <code>PlayerController</code> 脚本，其实现如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.InputSystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerController</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Rigidbody m_Rb;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> m_MovementX;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> m_MovementY;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> <span class="built_in">float</span> m_Speed = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span> &#123; m_Rb = GetComponent&lt;Rigidbody&gt;(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnMove</span>(<span class="params">InputValue <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> inputVector = <span class="keyword">value</span>.Get&lt;Vector2&gt;();</span><br><span class="line">        m_MovementX = inputVector.x;</span><br><span class="line">        m_MovementY = inputVector.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">FixedUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Vector3 movement = <span class="keyword">new</span>(m_MovementX, <span class="number">0.0f</span>, m_MovementY);</span><br><span class="line">        m_Rb.AddForce(movement * m_Speed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的 <code>OnMove</code> 对应 <a href="/input_system_minimum_tutorial/#%E5%88%9B%E5%BB%BA_Input_Action_Asset">创建 Input Action Asset</a> 后 Asset 中的 <code>Move</code> Action：<br>
<img src="/input_system_minimum_tutorial/image-20231117102349.png" alt=""></p>
<div class="note primary simple"><p>对于 Asset 中任意名称的 Action，都可以通过 <code>On&lt;ActionName&gt;</code> 监听到。<br>
如果 Action 叫做 <code>AAA</code>，则可以定义 <code>OnAAA</code> 函数监听。</p>
</div>
<p>将该脚本挂载在 <code>Player</code> 上，如下所示：<br>
<img src="/input_system_minimum_tutorial/2023-11-17-16-10-20.png" alt="挂载 PlayerController | 500"></p>
<p>此时小球就可以通过键盘的 <code>WASD</code> 和 <code>上下左右</code> 移动：<br>
<img src="/input_system_minimum_tutorial/gif-2023-11-17-16-11-05.gif" alt="控制小球"></p>
<p>此时的工程状态见：<br>
<a href="https://github.com/xuejiaW/InputSystemSample/tree/9cb75b9a8719cc8e695ac32ad786adcc007494d8">xuejiaW/InputSystemSample at 9cb75b9a8719cc8e695ac32ad786adcc007494d8 (github.com)</a></p>
<h1 id="自定义_Action_Asset"><a class="header-anchor" href="#自定义_Action_Asset">#</a>自定义 Action Asset</h1>
<p>在上 <a href="/input_system_minimum_tutorial/#%E5%88%9B%E5%BB%BA_Input_Action_Asset">创建 Input Action Asset</a> 步骤中，创建出来的 Input Actions 是 Unity 默认实现的，即适合于 <code>Player Input</code> 组件的 Actions 资源。</p>
<p><code>Player Input</code> 组件也是 Unity 内建的读取 Assets 资源的脚本</p>
<p>在这一节，会自定义 Actions 资源，并自定义使用该 Actions 资源的脚本。</p>
<h2 id="创建自定义_Action_Asset"><a class="header-anchor" href="#创建自定义_Action_Asset">#</a>创建自定义 Action Asset</h2>
<p>在 Project 面板中，空白处右键选择 <code>Create -&gt; Input Actions</code>，创建出一个新的 Input Actions 资源：<br>
<img src="/input_system_minimum_tutorial/gif-2023-11-17-15-35-29.gif" alt="New Input Actions Assets"></p>
<p>双击创建的资源（本例中为 <code>BallControls.inputactions</code> ） 后会打开空白的 Input Actions 窗口：<br>
<img src="/input_system_minimum_tutorial/2023-11-17-15-37-34.png" alt="Empty Input Assets"></p>
<p>此时点击画面左侧的 <code>+</code> 号可以创建出 Input Action Map，我们将新增的 Input Action Map 命名为 <code>BallPlayer</code>：<br>
<img src="/input_system_minimum_tutorial/gif-2023-11-17-15-44-11.gif" alt=""></p>
<p>在窗口中间，可以为这个 Input Action Map 创建一些 Input Action，如下过程，创建了 <code>Buttons</code> 这个 Input Action：<br>
<img src="/input_system_minimum_tutorial/gif-2023-11-17-15-49-12.gif" alt=""></p>
<p>在窗口的右侧，可以为 Input Action 创建一系列 Input Binding，如下步骤分别绑定了 <code>GamePad</code> 的 <code>East Button</code> 和 <code>West Button</code> ：<br>
<img src="/input_system_minimum_tutorial/gif-2023-11-17-15-52-42.gif" alt=""></p>
<div class="note primary simple"><p><code>GamePad</code> 的 <code>East</code> 和 <code>West</code> Button，在 Xbox 控制器上分别对应 <code>X</code> 键和 <code>B</code> 键</p>
</div>
<p>你也可以继续为 <code>Buttons</code> Action 绑定 Keyboard 的 <code>F1</code> 和 <code>F2</code> 按键，步骤如上，当绑定完成后，整个 <code>Buttons</code> Action 如下所示：<br>
<img src="/input_system_minimum_tutorial/image-20231117155554.png" alt=""></p>
<p>进一步创建 <code>Move</code> Input Action ，与 <code>Buttons</code> 不同是，<code>Move</code> 需要将 Action Type 设置为 <code>Value</code>，且 Control Type 为 <code>Vector2</code>，这表示 Action 会返回 <code>Vector2</code> 数据，即用于平面移动的上下左右数据：<br>
<img src="/input_system_minimum_tutorial/gif-2023-11-17-15-59-17.gif" alt=""></p>
<p>如之前步骤一样，为该 <code>Move</code> Input Action 绑定 <code>Left Stick</code>，绑定后结果如下：<br>
<img src="/input_system_minimum_tutorial/2023-11-17-16-05-20.png" alt="左摇杆"></p>
<p>也可以将键盘上的按键通过 组合绑定（Composite Bindings） 至 <code>Move</code> Input Action，如下所示，其逻辑为使用四个按键分别表示 <code>Vector2</code> 四个方向（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>+</mo><mi>x</mi><mo separator="true">,</mo><mo>−</mo><mi>x</mi><mo separator="true">,</mo><mo>+</mo><mi>y</mi><mo separator="true">,</mo><mo>−</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">+x,-x,+y,-y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord">+</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">−</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">+</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>）：<br>
<img src="/input_system_minimum_tutorial/2023-11-17-16-17-41.png" alt="四按键组合绑定"></p>
<p>分别为上下左右四个方向设定四个按键 <code>K,J,H,L</code>，结果如下所示：<br>
<img src="/input_system_minimum_tutorial/2023-11-17-16-26-24.png" alt="绑定后的四个按键"></p>
<p>至此，自定义的 Action Asset 创建完成，其中定义了使用 <code>GamePad</code> 和 <code>Keyboard</code> 两种输入设备，分别控制 <code>Buttons</code> 和 <code>Move</code> 两个 Action。将新建的 <code>BallControls.inputactions</code> 替换掉 <code>Player Input</code> 组件中的 Actions，即可使用新的 Action Asset：<br>
<img src="/input_system_minimum_tutorial/2023-11-17-16-43-31.png" alt="使用新 Asset"></p>
<p>此时运行游戏，可以发现通过手柄的左摇杆和 <code>HJKL</code> 都可以控制小球的移动，而 <code>WASD</code> 则不行了。</p>
<p>这是因为 <code>PlayerController</code> 脚本监听的 <code>Motion</code> 事件在 <code>BallControls.inputactions</code> 中也存在，因此我们定义的左摇杆和 <code>HJKL</code> 四个按键都能响应，即使不修改 <code>PlayerController</code> 也可以正常运行。而原 <code>PlayerInput.inputactions</code> 中的 <code>WASD</code> 我们并没有绑定，所以无法相应。</p>
<p>此时的工程状态见：<br>
<a href="https://github.com/xuejiaW/InputSystemSample/tree/8d994e47fbf7c766c87aa62ce517e7e5bdda031b">xuejiaW/InputSystemSample at 8d994e47fbf7c766c87aa62ce517e7e5bdda031b (github.com)</a></p>
<h2 id="创建自定义_Player_Input"><a class="header-anchor" href="#创建自定义_Player_Input">#</a>创建自定义 Player Input</h2>
<h3 id="手动解析_Actions_Asset"><a class="header-anchor" href="#手动解析_Actions_Asset">#</a>手动解析 Actions Asset</h3>
<p>自定义一个 <code>BallController</code> 脚本，用于解析刚刚创建的 <code>BallControls.inputactions</code>，其实现如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BallController</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> <span class="built_in">float</span> m_Speed = <span class="number">10</span>;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> InputActionAsset m_Asset = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Rigidbody m_Rb;</span><br><span class="line">    <span class="keyword">private</span> Vector2 m_Move;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> InputActionMap m_ActionMap = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> InputAction m_ButtonsAction = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> InputAction m_MoveAction = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_ActionMap = m_Asset.FindActionMap(<span class="string">&quot;BallPlayer&quot;</span>);</span><br><span class="line">        m_ButtonsAction = m_ActionMap.FindAction(<span class="string">&quot;Button&quot;</span>);</span><br><span class="line">        m_MoveAction = m_ActionMap.FindAction(<span class="string">&quot;Move&quot;</span>);</span><br><span class="line">        m_MoveAction.canceled += _ =&gt; OnMove(Vector2.zero);</span><br><span class="line"></span><br><span class="line">        m_ButtonsAction.performed += _ =&gt; OnButton();</span><br><span class="line">        m_MoveAction.performed += ctx =&gt; OnMove(ctx.ReadValue&lt;Vector2&gt;());</span><br><span class="line"></span><br><span class="line">        m_Rb = GetComponent&lt;Rigidbody&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span> &#123; m_ActionMap.Enable(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnButton</span>()</span> &#123; Debug.Log(<span class="string">&quot;On Buttons clicked triggered&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnMove</span>(<span class="params">Vector2 coordinates</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">$&quot;On move clicked triggered <span class="subst">&#123;coordinates.ToString(<span class="string">&quot;f4&quot;</span>)&#125;</span>&quot;</span>);</span><br><span class="line">        m_Move = coordinates;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">FixedUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Vector3 movement = <span class="keyword">new</span>(m_Move.x, <span class="number">0.0f</span>, m_Move.y);</span><br><span class="line">        m_Rb.AddForce(movement * m_Speed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDisable</span>()</span> &#123; m_ActionMap.Disable(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，该脚本直接引用了之前的 <code>InputActionAsset</code> ，并使用了 InputActionAsset.FindActionMap](<a href="https://docs.unity3d.com/Packages/com.unity.inputsystem@1.7/api/UnityEngine.InputSystem.InputActionAsset.html#UnityEngine_InputSystem_InputActionAsset_FindActionMap_System_String_System_Boolean_">https://docs.unity3d.com/Packages/com.unity.inputsystem@1.7/api/UnityEngine.InputSystem.InputActionAsset.html#UnityEngine_InputSystem_InputActionAsset_FindActionMap_System_String_System_Boolean_</a>) 找寻之前创建的 <code>BallPlayer</code> [Input Action Map，并在 <code>OnEnable</code> 和 <code>OnDisable</code> 时启用和禁用该 Input Action Map。</p>
<p>另外脚本中通过 InputActionMap.FindAction](<a href="https://docs.unity3d.com/Packages/com.unity.inputsystem@1.7/api/UnityEngine.InputSystem.InputActionMap.html#UnityEngine_InputSystem_InputActionMap_FindAction_System_String_System_Boolean_">https://docs.unity3d.com/Packages/com.unity.inputsystem@1.7/api/UnityEngine.InputSystem.InputActionMap.html#UnityEngine_InputSystem_InputActionMap_FindAction_System_String_System_Boolean_</a>) 找寻之前创建的 <code>Buttons</code> 和 <code>Move</code> Action，并监听了 [Input Action 的 <code>performed</code> 事件，触发对应的回调函数 <code>OnButton</code> 和 <code>OnMove</code>。</p>
<p>至此 <code>BallController</code> 脚本已经完全实现了之前 <code>Player Input</code> + <code>PlayerController</code> 的功能，因此在 <code>Player</code> 游戏物体上仅需要 <code>BallController</code> 脚本即可，注意要将之前创建的 <code>BallControls.inputactions</code> 挂载至脚本中：<br>
<img src="/input_system_minimum_tutorial/2023-11-17-17-30-55.png" alt=""></p>
<p>此时小球可以如同之前一样的通过手柄和键盘控制移动。</p>
<p>此时工程状态见：<br>
<a href="https://github.com/xuejiaW/InputSystemSample/tree/f070c14f0671d7c1c702b270f3751aed8c003692">xuejiaW/InputSystemSample at f070c14f0671d7c1c702b270f3751aed8c003692 (github.com)</a></p>
<h3 id="基于_Actions_Asset_自动生成对应类"><a class="header-anchor" href="#基于_Actions_Asset_自动生成对应类">#</a>基于 Actions Asset 自动生成对应类</h3>
<p>在 <a href="/input_system_minimum_tutorial/#%E6%89%8B%E5%8A%A8%E8%A7%A3%E6%9E%90_Actions_Asset">手动解析 Actions Asset</a> 中需要手动管理 <code>Actions Asset</code> 并从中读取 Input Action Map 和 Input Action。</p>
<p>上述的读取过程，会随着 <code>Action Assets</code> 中的数据变更而出现潜在的失效（如命名错误），因此 Unity 提供了从 <code>Action Assets</code> 中自动创建相应脚本的能力，可以简化上述步骤。</p>
<p>可以选择 <code>Action Assets</code> 便选择，并勾选其中的 <code>Generate C# Class</code> ，选择需要创建的类名称，文件和命名空间，并点击 <code>Apply</code> 正式创建脚本：<br>
<img src="/input_system_minimum_tutorial/image-20231119134430.png" alt="Create "></p>
<p>此时会创建出对应的脚本：<br>
<img src="/input_system_minimum_tutorial/image-20231119134523.png" alt="Automated Create Script"></p>
<p>修改之前的 <code>BallController</code> 脚本，以适配自动生成的 <code>BallControls</code>，如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BallController_AutoScripts</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> <span class="built_in">float</span> m_Speed = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BallControls m_Controls;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Rigidbody m_Rb;</span><br><span class="line">    <span class="keyword">private</span> Vector2 m_Move;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_Controls = <span class="keyword">new</span> BallControls();</span><br><span class="line">        m_Rb = GetComponent&lt;Rigidbody&gt;();</span><br><span class="line"></span><br><span class="line">        m_Controls.BallPlayer.Button.performed += _ =&gt; OnButton();</span><br><span class="line">        m_Controls.BallPlayer.Move.performed += ctx =&gt; OnMove(ctx.ReadValue&lt;Vector2&gt;());</span><br><span class="line">        m_Controls.BallPlayer.Move.canceled += _ =&gt; OnMove(Vector2.zero);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span> &#123; m_Controls.BallPlayer.Enable(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnButton</span>()</span> &#123; Debug.Log(<span class="string">&quot;On Buttons clicked triggered&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnMove</span>(<span class="params">Vector2 coordinates</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">$&quot;On move clicked triggered <span class="subst">&#123;coordinates.ToString(<span class="string">&quot;f4&quot;</span>)&#125;</span>&quot;</span>);</span><br><span class="line">        m_Move = coordinates;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">FixedUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Vector3 movement = <span class="keyword">new</span>(m_Move.x, <span class="number">0.0f</span>, m_Move.y);</span><br><span class="line">        m_Rb.AddForce(movement * m_Speed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDisable</span>()</span> &#123; m_Controls.BallPlayer.Disable(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时不再需要手动获取 Input Action Map 和 Input Action，只需要使用 <code>&lt;ActionControls&gt;.&lt;ActionMapName&gt;.&lt;Action&gt;</code> 的风格直接访问即可。</p>
<p>此时将之前挂载在 <code>Player</code> 上的的 <code>BallController</code> 脚本换为 <code>BallController_AutoScripts</code> 脚本，并运行，可以看到效果与之前的效果无差别。</p>
<p>此时工程状态见：<br>
<a href="https://github.com/xuejiaW/InputSystemSample/tree/a92af1df6ccfb22f2747548d2abf1a08c43a3407">xuejiaW/InputSystemSample at a92af1df6ccfb22f2747548d2abf1a08c43a3407 (github.com)</a></p>
<h1 id="Reference"><a class="header-anchor" href="#Reference">#</a>Reference</h1>
]]></content>
      <tags>
        <tag>Unity</tag>
        <tag>Tutorial</tag>
      </tags>
  </entry>
  <entry>
    <title>《Learn OpenGL》 学习笔记汇总</title>
    <url>/learn_opengl/</url>
    <content><![CDATA[<p>以下内容都是我学习 <a href="https://learnopengl.com/Introduction">Learn OpenGL</a> 系列教程时的笔记，它很详尽，一定程度上你可以将其视作是 <a href="https://learnopengl.com/Introduction">Learn OpenGL</a> 的翻译，但我在其中也加入了一些自己的理解和注释，同时也会对原始内容进行一些增删和调整，以便更好地适应我学习时的背景。</p>
<h1 id="Getting_Started"><a class="header-anchor" href="#Getting_Started">#</a>Getting Started</h1>
<p><a href="/ch_00_creating_a_window">Ch 00 Creating a Window</a></p>
<p><a href="/ch_01_hello_window">Ch 01 Hello Window</a></p>
<p><a href="/ch_02_hello_triangle">Ch 02 Hello Triangle</a></p>
<p>Ch 03 Shaders</p>
<p>Ch 04 Textures</p>
<p>Ch 05 Transformations</p>
<p>CH 06 Coordinate System</p>
<p>Ch 07 Camera</p>
<p>Ch 08 Framework</p>
<p>Ch 09 Model Loading</p>
<h1 id="Lighting"><a class="header-anchor" href="#Lighting">#</a>Lighting</h1>
<p>Ch 10 Color</p>
<p>Ch 11 Basic Lighting</p>
<p>Ch 12 Materials</p>
<p>Ch 13 Lighting Maps</p>
<p>Ch 14 Light Casters, Multiple Lights</p>
<h1 id="Advanced_OpenGl"><a class="header-anchor" href="#Advanced_OpenGl">#</a>Advanced OpenGl</h1>
<p>Ch 15 Depth Testing<br>
Ch 16 Stencil Testing<br>
Ch 17 Blending<br>
Ch 18 Face Culling<br>
Ch 19 Framebuffers<br>
Ch 20 Cubemaps<br>
Ch 21 Advanced Data, GLSL<br>
Ch 22 Geometry Shader<br>
Ch 23 Instancing<br>
Ch 24 Anti Aliasing</p>
<h1 id="Advanced_Lighting"><a class="header-anchor" href="#Advanced_Lighting">#</a>Advanced Lighting</h1>
<p>Ch 25 Blinn-Phong<br>
Ch 26 Gamma Correction<br>
Ch 27 Shadow Mapping<br>
Ch 28 Point Shadows<br>
Ch 29 Normal Mapping<br>
Ch 30 Parallax Mapping<br>
Ch 31 HDR<br>
Ch 32 Bloom<br>
Ch 33 Deferred Shading<br>
Ch 34 SSAO</p>
<h1 id="Reference"><a class="header-anchor" href="#Reference">#</a>Reference</h1>
<p><a href="https://learnopengl.com/Introduction">Learn OpenGL</a></p>
]]></content>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>《Linus on Kernel Management Style》 翻译</title>
    <url>/linus_on_kernel_management_style/</url>
    <content><![CDATA[<p>这是一篇关于描述期望的 Linux Kernel 管理风格的简短文章，它在某种程度上与 CodeStyle 文档类似，是避免一遍又一遍的回答相同（或相似）的问题。</p>
<div class="note info simple"><p>本文档并非通过解决问题来实现避免回答问题，而是让提问者痛苦地，显然地意识到我们也没有任何思路解决问题。</p>
</div>
<p>管理是非常个人化的，而且比简单的代码风格更难量化。所以这篇文章可能，也可能没有，与你的现实有很多共鸣。这篇文档出自于乐趣，但这并不意味着这篇文档中没有干货，一切都取决于你自己的看法。</p>
<p>顺便说一句，当谈论“Kernel 管理者”时，都假设这些管理者是技术领导人，而不是在一些公司中的传统管理者。 如果你需要签署采购订单或者你有任何关于采购订单的工作，如果你的团队有关于预算的工作内容，那么你肯定不是 Kernel 管理者。 这些建议可能适用于你，也可能不适用于你。</p>
<p>首先，我建议你买一本《高效人士的七个习惯》 ，但不要阅读它。烧了它，这是一个伟大的象征性姿态。</p>
<h1 id="第一章_决定"><a class="header-anchor" href="#第一章_决定">#</a>第一章 决定</h1>
<p>每个人都认为管理者应该做出决策，而且做出决策是重要的。 越是重大和痛苦的决策，就越应该由管理者做出。这看似非常深刻和明显，但事实并非如此。</p>
<p>这个游戏的名称应该叫做“避免做决策”。特别是，如果有人告诉你“我们现在必须在 A 和 B 中做选择” ，那你作为管理者就有麻烦了。你的组员应该比你更了解细节，如果他们要你来做出技术决定，你就完蛋了，你显然没有足够的能力为他们做出决定。</p>
<div class="note info simple"><p>如果你管理的人，不比你了解更多的细节，你也完蛋了。因为你做错了工作，你应该来展现你的才华，而让他们来管理你。</p>
</div>
<p>所以这个游戏的名称叫做“避免做决策”，至少是避免做重大而痛苦的决策。做一些小而无关紧要的决策没关系，这也会让帮助你知道现在在做什么。所以作为内核的管理者，你应该做的是把大而痛苦的决策，拆分成没人关心的小决策。</p>
<p>有一点可以帮助人意识到大决策和小决策之间的差异：小决策是可以事后修正的决策。只要始终保证你的决策如果错了（你 <strong>一定会</strong> 错的），你有办法通过回滚来消除损失。这样你就做出了两个决策（第一个错误的决策，和后续回滚的正确决策。）</p>
<p>这时候人们就会意识到你展现的领导力（狗屁）。</p>
<p>因此，避免做出重大决定的关键就是避免去做无法挽回的事情。 不要陷入一个你无法逃脱的窘境。 走投无路的老鼠可能会让人觉得很危险，但一个走投无路的管理者只会显得很可怜。</p>
<p>事实上，无论如何，都不会有人蠢到让 Kernel 管理者去承担巨大的财务责任，因此管理者通常很容易走回头路。因为管理者没机会浪费大量的、他无法偿还的金钱，所以他唯一可做的决策就是技术决策，而技术决策很容易回滚：只需要告诉所有人你是一个无能的白痴，然后说声抱歉，然后取消所有你去年让人做的无意义的工作。这样，突然间，你去年做的决策就不再是一个 “大” 决策，因为他很容易被撤销。</p>
<p>事实证明，对有些人而言，这个方法很困难，主要有两个原因：</p>
<ol>
<li>承认自己是个白痴比看起来更难。我们都喜欢保持形象，所以在公开场合承认自己的错误确实很难。</li>
<li>告诉一个一线工程师，他去年做的工作毫无意义，这非常残忍。虽然你可以通过删除代码来撤销工作，但你不可挽回的失去了那位工程师的信任。请记住，“不可挽回” 是我们始终要避免的事，所以你做的决策最终还是会变为一个 <strong>大</strong> 的决策。</li>
</ol>
<p>令人高兴的是，上述两个原因都可以通过以下方法得到有效缓解：</p>
<ol>
<li>预先承认你并没有任何的思路，并预先告诉别人你的决策纯粹是初步的，并且可能是错误的。</li>
<li>你应该始终保留更改决策的权利，并让人们意识到这一点。</li>
</ol>
<p>在你还没有真正做一件事时，就承认自己的愚蠢要容易的多。然后，当这个决策真的被证明是愚蠢的时候，人们只会耸耸肩，然后说“哎呀，他又做蠢事了”。</p>
<p>这种预先承认自己无能的做法，也能让那些实际做这项工作的人三思而后行，让他们去思考这件事是否值得做。毕竟，如果他们自己都不确定这件事是否是个好主意，你不应该通过承诺他们的工作将会产出成果等行为来鼓励他们。让他们在付出努力前，三思而后行。</p>
<p>记住：你管理的人，作为一线的工程师，比你了解更多的细节，而且他们通常也对自己要做的事值得与否有他们自己的回答。所以你作为管理者，你能做的不是灌输信心，而是要对他们正在进行的事进行批判性思考。</p>
<p>另外，避免做出决策的另一种方法就是看起来很可怜的向他们说：“我们不能两者都做吗？”。相信我，这个策略有效。如果你不清楚哪个方案更好，他们会最终找出答案。</p>
<p>但答案也可能是，尝试这两个不同决策两个队伍，都对他们的情况感到沮丧。这听起来无疑是个失败，但这也是一个信号：两个项目都存在一些问题，参与其中的工程师无法决定两个策略哪个更好的原因是：这两个决策都是错的。</p>
<h1 id="第二章_人"><a class="header-anchor" href="#第二章_人">#</a>第二章 人</h1>
<p>大多数人都是白痴，作为一个管理者意味着你需要处理这个事实。而且可能更重要一点是，你的组员需要处理你这个白痴。</p>
<p>事实证明，纠正技术错误很容易，但消除人格缺陷造成的影响很难。你必须与你组员和你的人格缺陷共存。</p>
<p>为了让自己做好成为 Kernel 管理者的准备，你最好记住，不要烧毁任何的桥梁，不要轰炸任何无辜的村民，也不要疏远 Kernel 的开发者。疏远人相当容易，但要消除这个疏远则很困难。因此 “疏远” 是一个不可逆的决策，而这就是我们在第一章中所说的要回避的决策。</p>
<p>这里有一些简单的准则：</p>
<ol>
<li>不要说别人是傻逼（最起码不要当众说）</li>
<li>在你忘了规则 1 的时候，记得道歉</li>
</ol>
<p>准则 1 很容易做到，因为你有一百万种方式暗示一个人是傻逼（而不是直接说出）。有时你都没意识到你这么做了，通常当这发生时，说明你隐含着一种炙热的信念“我是对的”。</p>
<p>你越确信你是对的（你相信你有能力叫任何人傻逼，而且你相信你通常是正确的），你事后就越难道歉。为了解决这个问题，你实际上只有两个选择：</p>
<ol>
<li>非常善于道歉</li>
<li>平等的散播“爱”，以至于没有人会真正的感受到自己受到了不公平的攻击。你可以让这个攻击足够有创意，以至于他们甚至会觉得有点好笑。</li>
</ol>
<p>“始终保持礼貌” 并不是一个合理的选项，因为没有人会相信一个如此明显的隐藏自己真实性格的人。</p>
<h1 id="第三章_人（二）"><a class="header-anchor" href="#第三章_人（二）">#</a>第三章 人（二）</h1>
<p>事实证明大多数人都是白痴，可悲的是，由这个事实可以推论你也是个白痴。虽然我们可以依靠“我比普通人更优秀”这个想法来安然度日（面对现实吧，没有人会相信自己是平均水平，或平均水平以下），但我们也要承认，我们不是世界上最聪明的人，总有人不像你一样白痴。</p>
<p>一些人对聪明人反应很糟糕，而另一些人则利用聪明人。</p>
<p>需要保证，你，作为一个 Kernel 管理者，属于上述第二类人。拍那些聪明人的马屁，因为他们会让你的工作更轻松。特别的是，他们会为你做出决策，这也就是第一章中我们所说的“避免做决策”意义所在。</p>
<p>所以，当你发现有人比你聪明时，就顺其自然吧。此时，你的管理职责很大程度上就变成了“听起来是个好主意，大胆的去做吧”，或者 “听起来不错，但 XXX 怎么样？”特别是第二个版本，你既可以让他学习 XXX 的知识，又可以通过指出聪明人没有想到的事情来显得自己做了 <em>管理</em> 。无论怎样，你都是胜者。</p>
<p>你还需要意识到，一个领域的优秀并不意味着能复刻进另一个领域。所以你可能鼓励一个人在特定的方向努力，但需要面对的现实是，这个人可能擅长他现在做的事，然后在其他所有方面都很差。好消息是，人们总会倾向于回到自己擅长的领域，所以你在鼓励某人在一个特定方面努力的行为通常是可逆的，只要你别鼓励的太用力。</p>
<h1 id="第四章_责备"><a class="header-anchor" href="#第四章_责备">#</a>第四章 责备</h1>
<p>事情总会出错，而且人们总是希望有个人能接受指责。没错，你就是那个人。</p>
<p>接受指责实际上并不难，尤其是当人们有点意识到这不全是你的错时。这让我们想到了承担指责的最佳方式：为另外一个人承担指责。你会为做了好事而感到开心，他会因为没有收到指责而感到开心，而那个因为你的无能和失去了他全部的 36G 色情收藏的家伙（指用户）也会勉强承认你至少没有逃避。</p>
<p>然后，私底下告诉那个搞砸事情的开发者（如果你能联系到他的话），他把这件事搞砸了。这样他不仅可以在未来避免再犯同样的错误，而且他也会知道他欠你一个人情。而且更重要的是，他才是那个能解决问题的人，让我们面对现实吧，真正解决问题的肯定不是你。</p>
<p>承担责任是你成为管理者的首要原因。人们信任你，并且让你体现荣耀的一部分原因就是你是那个能说“我搞砸了”的人。如果你遵循了之前的规则，那么目前为止，你应该很擅长说这句话。</p>
<h1 id="第五章_要避免的事"><a class="header-anchor" href="#第五章_要避免的事">#</a>第五章 要避免的事</h1>
<p>有一件比被人叫白痴更让人讨厌的事，那就是被道貌岸然的叫白痴。第一个你还可以道歉，第二个你就得不到道歉的机会了。即使你之后改善了，他们也不会再听你。</p>
<p>我们都以为自己比别人更优秀，这意味着当别人摆架子时，确实会惹恼我们。你可以在道德和智力上优于你周围的每个人，但不要试图让它变得太明显，除非你真的 <em>打算</em> 激怒某个人。</p>
<div class="note info simple"><p>提示：你可以在与你工作没有直接关系的互联网组织里发泄对某人不满。你可以通过带着冷笑，写一些侮辱性的帖子，时不时的发发脾气，来净化自己的心灵。记住，不要在离家太近的地方拉屎。</p>
</div>
<p>同样，不要对事情太客气或态度太微妙。人很容易变得过于礼貌进而掩盖问题，正如人们所说，“在互联网上，没有人能听出你的微妙”。 使用一个大锤子来敲击要点，否则你没法指望人们真正理解你的观点。</p>
<p>一些幽默可以帮助加强你的观点并传达给别人。对一件事太过分到荒谬的描述可以帮助对方理解，同时不会让听者感到痛苦，因为他们只会认为你觉得你的例子很愚蠢。因此，它可以帮助我们克服对批评的心理障碍。</p>
<h1 id="第六章_为什么是我？"><a class="header-anchor" href="#第六章_为什么是我？">#</a>第六章 为什么是我？</h1>
<p>既然管理者的主要责任似乎变为了为别人的错误承担责任，并且让人明显的看出你的无能，那么一个问题就呼之欲出了：为什么一开始你要做管理者？</p>
<p>首先，虽然你可能会，也可能不会，听到十几岁的女孩子尖叫着敲你更衣室的门，但你同样会因为 “负责” 而获得巨大的个人成就感。请不要介意这样一个事实：你真正的领导力是保持跟上其他人，而且尽可能快的追赶他们。其他每个人仍然会认为你才是那个真正应该负责的人。</p>
<p>如果你能了解这个工作，那管理将是一个伟大的工作。</p>
<h1 id="Reference"><a class="header-anchor" href="#Reference">#</a>Reference</h1>
<p><a href="https://lwn.net/Articles/105375/">Linus on kernel management style [LWN.net]</a></p>
]]></content>
      <tags>
        <tag>管理</tag>
      </tags>
  </entry>
  <entry>
    <title>《LLM 对程序员的冲击和影响》摘抄</title>
    <url>/llm_dui_cheng_xu_yuan_de_chong_ji_he_ying_xiang/</url>
    <content><![CDATA[<h1 id="LLM_的局限"><a class="header-anchor" href="#LLM_的局限">#</a>LLM 的局限</h1>
<p>如果说 <strong>ChatGPT 实现了数字时代知识的平权，codex 类的代码语言大模型实现了基础编码能力的知识平权</strong>，进而带来软件研发的局部效率提升。 可以说，LLM 降低了软件开发的门槛，可以让更多对软件开发感兴趣的人更加轻松地参与到软件开发工作中，同时，LLM 提高了编程的效率和质量，使我们可以在更短的时间内完成更多的工作，因而能留出更多的时间让我们思考。</p>
<p>我们面对的是软件工程的问题，<strong>编程不等于软件工程，编程只是软件工程的一部分。软件工程的四大内在特性（复杂度、不一致性、可变性、不可见性）并没有因为 LLM 的出现而发生本质上的变化，这才是软件工程面临的主要矛盾</strong>。这四点再叠加上大型软件的规模效应，其中包含软件系统本身的规模和软件研发团队的规模，问题就更严重了，即会显著提升软件研发过程中的沟通成本、决策成本、认知成本和试错成本，而这些才是软件工程问题的本质，这些本质问题自始至终都没有变过，LLM 对此也基本无能为力。</p>
<h2 id="复杂性"><a class="header-anchor" href="#复杂性">#</a>复杂性</h2>
<p>LLM 让局部编码变简单，或者说更高效了，但是需求分析和软件设计并没有因为 LLM 而变得简单。</p>
<p>只有我们的需求足够的清楚，那么生成的代码才会准确。如何准确全面描述需求成为了关键。面向自然语言编程，首先你要有能力把话讲清楚。但是问题是：你能讲清楚吗？我们通过一些实践发现，<strong>要把需求描述到让它能正确写出来代码，需要的工作量似乎已经接近甚至超过编码了</strong>。为什么会这样，有两个方面的原因：</p>
<ol>
<li>
<p>因为大多数的代码实现是 imperative 的，而需求描述是 declarative 的，这两者对人的要求完全不一样。我们程序员群体接受的教育是编程，而不是需求描述，也就是说程序员本来更擅长写代码，而不是描述需求。</p>
</li>
<li>
<p>在当前的开发模式下，程序员直接用代码默认帮需求（产品经理）做了很多代偿。很多在需求中没有明确提及的内容被程序员用代码直接实现了（代偿）。而现在要倒过来先把需求的细节完全理清楚这个可能不是程序员当前的工作习惯。而且代码的信息熵其实要大于自然语言，程序员更善于用代码而非自然语言来描述事务。</p>
<ul>
<li>在当前的开发模式下，程序员直接用代码默认帮需求（产品经理）做了很多代偿。很多在需求中没有明确提及的内容被程序员用代码直接实现了（代偿）。而现在要倒过来先把需求的细节完全理清楚这个可能不是程序员当前的工作习惯。而且代码的信息熵其实要大于自然语言，程序员更善于用代码而非自然语言来描述事务。</li>
<li>一个软件的需求，不仅仅是功能性的，还有很多非功能的需求，这些都是需要描述清楚的。另外代码实现的时候，还要考虑为可测试而设计，为可扩展而设计，为可运维而设计，为可观测而设计等等。原本这些很多是开发代偿了，现在要从需求生成代码，你必须要提前讲清楚。</li>
</ul>
</li>
</ol>
<div class="note info simple"><p>软件从业者高估了编程的复杂度，但是却低估了功能和设计的深刻度。</p>
</div>
<h2 id="一致性"><a class="header-anchor" href="#一致性">#</a>一致性</h2>
<p>由于软件研发的本质依然是“<strong>知识手工业者的大规模协作</strong>”，所以我们非常需要一致性。如果系统是一致的，则意味着相似的事情以相似的方式完成，错并不可怕，怕的是错的千变万化。LLM 的出现并没有提升软件研发的一致性，甚至<strong>由于 LLM 本身的概率属性，使用 LLM 实现代码生成的不一致性问题反而是被放大了</strong></p>
<h2 id="可变性"><a class="header-anchor" href="#可变性">#</a>可变性</h2>
<p>软件会随着需求不断演进和变化，所以架构设计和模块抽象只能面向当下，它天然是短视的，或者说是有局限性的，这种局限性即使是最优秀的架构师也是不可逾越的。</p>
<p>当需求发生变动后，一般是会在原有代码基础上改动，而不是直接从头全量生成全部代码，这个时候，LLM 本质上做的是局部编程的辅助（pair programming）。局部编程辅助过程中，经常需要对代码做局部修改，而这个往往并不容易。代码的信息熵大于自然语言，用信息熵更低的自然语言去描述代码，尤其是准确描述大段代码中的若干个位置往往是困难的。</p>
<p>如果需要进一步描述如何修改就会更困难，因为大概率需要用到很多代码上下文的相关描述，所以对于 prompt 的表述要求以及长度要求都很高。要在原有代码基础上修改，就需要利用已有的代码上下文，而不是从 0 开始。要实现这一点，一个最朴素的做法就是把整个项目的代码都贴到 prompt 里，但这样并不现实。因为 GPT-3.5 限制最多只能 4096 个 tokens，GPT-4 最多 8192 个，除非项目非常小，否则根本放不下。这个问题可能需要用 LangChain 来解决了。</p>
<p>而且 LLM 本质上不是基于修改意见（prompt）进行改写，而是基于修改意见（prompt）重新写了一份，而且 LLM 的原理决定了其会“一本正经的胡说八道”的本质，会<strong>混合捏造</strong>一些不存在的东西，可以说人工智能的混合捏造是人工智能在无知情况下的“自信”反应，而这个点在代码生成上是灾难性的，比如会将不同类型的 SQL 语句混在一起使用，会分不清 Go 语言的 <code>os.Kill</code> 和 Python 语言的 <code>os.kill()</code>。输出的代码需要人重复的阅读和理解，使得认知成本变高了。</p>
<h2 id="不可见性"><a class="header-anchor" href="#不可见性">#</a>不可见性</h2>
<p>软件的客观存在不具有空间的形体特征，不同的关注点，会有不同的图。综合叠加这些图是困难的，而且<strong>强行可视化的效果会造成图的异常复杂，反而失去了可视化的价值</strong>。设计无法可视化就限制了有效的沟通和交流。</p>
<p>在实际中，很多需求和设计并不以文档的形式存在，往往会存在于程序员和架构师的脑子里，或者在讨论的过程中。就算有文档，文档和代码大概率不同步。就算文档同步，文档（需求和设计）背后经常有大量的方案对比和推敲，甚至有很多要在原有债务基础上的设计妥协，这些决策过程一般都不会明确地被记录下来。这些没有被文档化下来的知识，我们称其为<code>暗知识</code>。虽然我们说只要有足够的数据，大模型就可以学到需求和设计知识。但这些“暗知识”本身就很难被捕捉到，“足够的数据”这一前提在需求分析和软件设计可能难以满足。</p>
<p>在实际软件开发中，需求可能一次不能表达得很清楚，需要一边开发一边逐步写清楚需求。尤其是敏捷开发更是如此。所以一些通用的，不需要特定领域知识的问题，LLM 的表现会比较好，但是那些专用的，需要特定领域知识（私域知识）的问题，LLM 就可能不是很擅长。</p>
<div class="note info simple"><p>你能想到的多过你能说出来的，你能说出来的多过你能写下来的。所以这就天然限制了 LLM 能力的上限。</p>
</div>
<h1 id="工程师与_LLM_的共生"><a class="header-anchor" href="#工程师与_LLM_的共生">#</a>工程师与 LLM 的共生</h1>
<p>在软件开发过程中，当伪代码级别的设计完成后，最后一公里的编码实现会被 LLM 替代，因为基于记忆的简单重复编码不是人的优势，而是机器的优势。</p>
<p>这部分工作现在属于码农，也就是我们俗称的 CRUD 仔和 API Boy，所以很多不涉及设计的码农可能会被大模型替代。未来工程师需要关注业务理解、需求拆分、架构设计、设计取舍，并在此基础上通过 prompt 学会与 AI 合作，从而<strong>实现“工程师 + LLM”形成 1+1 &gt;2 的效果。这就是共生</strong>。需要注意的是，这种<strong>共生必须始终保持人的主观能动性</strong>，机器必须是 Copilot，也就是智能副驾驶，主驾驶位置必须是人，这样的人 - 机关系才能长期健康发展。这也就是为什么说微软现任 CEO 萨提亚强调 Copilot（智能副驾驶）是比 Autopilot（自动驾驶）还先进的根本原因。</p>
<p>软件项目参与的人越来越多，分工越来越细，人和人之间需要的沟通量，也指数增长。很快你会发现，沟通花费的时间，渐渐地就比分工省下来的时间还要多。说白了，过了一个临界点，人越多不是越帮忙，而是人越多越添乱。一个人 12 个月能完成的事，不见得上 12 个人 1 个月就能完成，甚至 12 个月也未必能完成。</p>
<ul>
<li>《人月神话》里建议了一种组织方式，叫“外科手术式的队伍”。就像一台外科手术一样，有一个主刀大夫，软件项目也应该有一个首席程序员，其他人都是给他提供支持的。这样，就既能获得由少数头脑产生的产品完整性，又能得到多位协助人员的总体生产率，还彻底地减少了沟通的工作量。<strong>LLM 的出现，让基础编程工作一定程度上实现了自动化，这样非常有利于控制研发团队规模，保持小团队的效率优势</strong>。</li>
</ul>
<h1 id="未来可能基于_Prompt_编程"><a class="header-anchor" href="#未来可能基于_Prompt_编程">#</a>未来可能基于 Prompt 编程</h1>
<p>让我们做个大胆的设想，如果当软件需求发生变化的时候，我们不再是去改代码，而是直接修改需求对应的 prompt，然后基于 prompt 直接生成完整的代码，这个将是软件开发范式的改变。在这种范式下，我们需要确保代码不能有人为修改，必须都是由 prompt 直接生成，此时我们还需要对 prompt 做版本管理，或许会出现类似今天 git 的 prompt 版本管理的新物种。</p>
<p>此时，从本质上来看 <strong>prompt 即是代码，而原本的代码不再是代码了</strong>，这就真正实现了基于自然语言（prompt）的编程，此时的编程范式将从 prompt to code 转变为 prompt as code。</p>
<p>但这个假设还是在以以往的逻辑在做分析，这个基础可能本来就是错误，全新的时代或许需要全新的思维模式。</p>
]]></content>
      <tags>
        <tag>摘抄</tag>
        <tag>AI</tag>
        <tag>LLM</tag>
        <tag>程序员</tag>
      </tags>
  </entry>
  <entry>
    <title>Normal Matrix 矩阵推导</title>
    <url>/normal_matrix/</url>
    <content><![CDATA[<p>Normal Matrix 是用来将法线从 Model Space 转换到 World Spaces 的。</p>
<p>相对于将顶点位置从 Model Space 转换到 View Space，法线的转换有两点需要额外考虑：</p>
<ol>
<li>法线是不需要考虑平移的</li>
<li>如果物体存在非等比例的缩放，而对法线直接进行这样的非等比例的缩放后，发现将不再垂直于平面，如下图所示：<br>
<img src="/normal_matrix/image-20240324173719.png" alt="错误的法线变化效果"></li>
</ol>
<p>因此 Normal Matrix 相较于普通的 Mode Matrix，需要对上述的情况做处理。</p>
<h2 id="排除平移"><a class="header-anchor" href="#排除平移">#</a>排除平移</h2>
<p>法线是一个方向，不需要考虑平移，因此 Model Matrix 中的平移部分是不需要的，只需要取 Model Matrix 的左上 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>×</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">3\times3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span> 子矩阵即可。</p>
<p>即针对于法线，假设仍然使用 Model Matrix 来变换，那么表达式应该为：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">normalOutput = <span class="built_in">normalize</span>(<span class="type">mat3</span>(model) * normalInput);</span><br></pre></td></tr></table></figure>
<p>但这仅仅解决了平移的问题，对于非等比例缩放的问题，还需要进一步处理。</p>
<h2 id="处理非等比例缩放"><a class="header-anchor" href="#处理非等比例缩放">#</a>处理非等比例缩放</h2>
<h3 id="为何普通边可以使用_Model_矩阵"><a class="header-anchor" href="#为何普通边可以使用_Model_矩阵">#</a>为何普通边可以使用 Model 矩阵</h3>
<p>为了说明为何法线在使用 Model 矩阵转换后，遇到非等比例缩放下会出现问题，首先我们需要论证为何普通的边使用 Model 矩阵转换，在经过了非等比例缩放后，不会出现问题。</p>
<p>我们假设三角形的一条边上有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 两个点，那么这条边可以表达为：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>T</mi><mo>=</mo><msub><mi>P</mi><mn>2</mn></msub><mo>−</mo><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">T= P_2 - P_1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>此时对这条边进行 Model Matrix 的变换，可以得到：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msup><mi>T</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>M</mi><mo>⋅</mo><mi>T</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>M</mi><mo>⋅</mo><mrow><mo fence="true">(</mo><msub><mi>P</mi><mn>2</mn></msub><mo>−</mo><msub><mi>P</mi><mn>1</mn></msub><mo fence="true">)</mo></mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>M</mi><mo>⋅</mo><msub><mi>P</mi><mn>2</mn></msub><mo>−</mo><mi>M</mi><mo>⋅</mo><msub><mi>P</mi><mn>1</mn></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><msubsup><mi>P</mi><mn>2</mn><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo>−</mo><msubsup><mi>P</mi><mn>1</mn><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
T^{\prime} &amp; =M \cdot T \\
&amp; =M \cdot\left(P_2-P_1\right) \\
&amp; =M \cdot P_2-M \cdot P_1 \\
&amp; =P_2^{\prime}-P_1^{\prime}
\end{aligned}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:6em;vertical-align:-2.75em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.25em;"><span style="top:-5.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span><span style="top:-0.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.75em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.25em;"><span style="top:-5.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-0.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-2.453em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-2.453em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.75em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>由于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>P</mi><mn>1</mn><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup></mrow><annotation encoding="application/x-tex">P_1&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.2481em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-2.4519em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>P</mi><mn>2</mn><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup></mrow><annotation encoding="application/x-tex">P_2&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.2481em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-2.4519em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span></span></span></span> 是三角形在转换后的两个顶点，因此 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>P</mi><mn>2</mn><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo>−</mo><msubsup><mi>P</mi><mn>1</mn><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup></mrow><annotation encoding="application/x-tex">P_2&#x27;-P_1&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.2481em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-2.4519em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.2481em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-2.4519em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span></span></span></span> 仍然是转换后的三角形的边。</p>
<h3 id="为何法线不能使用_Model_矩阵"><a class="header-anchor" href="#为何法线不能使用_Model_矩阵">#</a>为何法线不能使用 Model 矩阵</h3>
<p>对于法线，我们可以同样用上述的方式计算，我们用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Q</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">Q_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Q</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">Q_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 两个点来表示三角形的法线，假设 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Q</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">Q_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是三角形上的一个点， <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Q</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">Q_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是三角形外的一个点，但两者的连线垂直于三角形的边：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>N</mi><mo>=</mo><msub><mi>Q</mi><mn>2</mn></msub><mo>−</mo><msub><mi>Q</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">N = Q_2 - Q_1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>在经过了 Model Matrix 的变换后，我们得到：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi>N</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><msubsup><mi>Q</mi><mn>2</mn><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo>−</mo><msubsup><mi>Q</mi><mn>1</mn><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup></mrow><annotation encoding="application/x-tex">N&#x27; = Q_2&#x27; - Q_1&#x27;
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8019em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0489em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0489em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>此时，我们只能保证 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>Q</mi><mn>1</mn><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup></mrow><annotation encoding="application/x-tex">Q_1&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.2481em;"></span><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-2.4519em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span></span></span></span> 是三角形上的一个点，但 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>Q</mi><mn>2</mn><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup></mrow><annotation encoding="application/x-tex">Q_2&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.2481em;"></span><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-2.4519em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>Q</mi><mn>1</mn><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup></mrow><annotation encoding="application/x-tex">Q_1&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.2481em;"></span><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-2.4519em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span></span></span></span> 之间的连线，即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>N</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">N&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> 并不能确定是垂直于三角形的边的。</p>
<p>如果要确保 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>N</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">N&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> 仍然垂直于三角形的边，那么必须满足 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>N</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>⋅</mo><msup><mi>T</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">N&#x27; \cdot T&#x27; = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>。我们前面已经知道了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>T</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">T&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> 是通过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> 经由 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 矩阵变换得到，而满足条件的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>N</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">N&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> 不一定可以通过矩阵 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 变换获得。我们这里假设满足条件的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>N</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">N&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> 可以通过矩阵 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> 变换得到，即：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msup><mi>N</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>⋅</mo><msup><mi>T</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo stretchy="false">(</mo><mi>G</mi><mi>N</mi><mo stretchy="false">)</mo><mo>⋅</mo><mo stretchy="false">(</mo><mi>M</mi><mi>T</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
N&#x27; \cdot T&#x27; &amp;= (GN) \cdot (MT) \\
   &amp;= 0
\end{aligned}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">GN</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">MT</span><span class="mclose">)</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>我们要求的就是矩阵 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> 该如何表达。</p>
<p>上述公式的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">GN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">GN</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">MT</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">MT</span></span></span></span> 都是向量，表达式求的是两个向量的点积。为了方便后续的计算，我们首先需要将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">GN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">GN</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">MT</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">MT</span></span></span></span> 间的计算转换为矩阵的乘法。假设 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> 都是行向量，那么 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">GN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">GN</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">MT</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">MT</span></span></span></span> 也是行向量，为了让 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">GN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">GN</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">MT</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">MT</span></span></span></span> 可以用矩阵乘法表示，需要首先将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">GN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">GN</span></span></span></span> 转换为列向量，这需要对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">GN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">GN</span></span></span></span> 进行转置，即：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><mi>G</mi><mi>N</mi><mo stretchy="false">)</mo><mo>⋅</mo><mo stretchy="false">(</mo><mi>M</mi><mi>T</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>G</mi><mi>N</mi><msup><mo stretchy="false">)</mo><mi>T</mi></msup><mo stretchy="false">(</mo><mi>M</mi><mi>T</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(G N) \cdot(M T)=(G N)^T(M T)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">GN</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">MT</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1413em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">GN</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">MT</span><span class="mclose">)</span></span></span></span></span></p>
<div class="note primary simple"><p>同理对于向量计算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>⋅</mo><mi>T</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">N \cdot T = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 也可以转换为矩阵运算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>N</mi><mi>T</mi></msup><mi>T</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">N^TT=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></p>
</div>
<p>上述式子可以进一步化简为：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><mi>G</mi><mi>N</mi><msup><mo stretchy="false">)</mo><mi>T</mi></msup><mo stretchy="false">(</mo><mi>M</mi><mi>T</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>N</mi><mi>T</mi></msup><msup><mi>G</mi><mi>T</mi></msup><mi>M</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">(G N)^T(M T)=N^T G^T M T
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1413em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">GN</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">MT</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8913em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.13889em;">MT</span></span></span></span></span></p>
<p>将上述的计算连起来，即我们需要求 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> 满足：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi>N</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>⋅</mo><msup><mi>T</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><msup><mi>N</mi><mi>T</mi></msup><msup><mi>G</mi><mi>T</mi></msup><mi>M</mi><mi>T</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">N&#x27; \cdot T&#x27; = N^T G^T M T= 0
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8019em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8019em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8913em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.13889em;">MT</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></span></p>
<p>假设 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>G</mi><mi>T</mi></msup><mi>M</mi><mo>=</mo><mi>I</mi></mrow><annotation encoding="application/x-tex">G^TM = I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span>，那 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>N</mi><mi>T</mi></msup><msup><mi>G</mi><mi>T</mi></msup><mi>M</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">N^T G^T M T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.13889em;">MT</span></span></span></span> 就变为了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>N</mi><mi>T</mi></msup><mi>T</mi></mrow><annotation encoding="application/x-tex">N^TT</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>N</mi><mi>T</mi></msup><mi>T</mi></mrow><annotation encoding="application/x-tex">N^TT</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> 显然是等于 0 的，即满足了我们的要求。</p>
<div class="note primary simple"><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>N</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">N^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span> 即为变化前的三角形的法线的矩阵表示，T 即为变换前的三角形的边，他们相乘显然为 0。</p>
</div>
<p>此时问题就变成了求 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span>，而 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> 满足 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>G</mi><mi>T</mi></msup><mi>M</mi><mo>=</mo><mi>I</mi></mrow><annotation encoding="application/x-tex">G^TM = I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span>：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msup><mi>G</mi><mi>T</mi></msup><mi>M</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>I</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msup><mi>G</mi><mi>T</mi></msup></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><msup><mi>M</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>G</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo stretchy="false">(</mo><msup><mi>M</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><msup><mo stretchy="false">)</mo><mi>T</mi></msup></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
   G^TM &amp;= I \\
   G^T &amp;= M^{-1} \\
   G &amp;= (M^{-1})^T
\end{aligned}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.654em;vertical-align:-2.077em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.577em;"><span style="top:-4.6857em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span><span style="top:-3.1343em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span><span style="top:-1.583em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">G</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.077em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.577em;"><span style="top:-4.6857em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span><span style="top:-3.1343em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span><span style="top:-1.583em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.077em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>至此我们求得了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span>，即对于法线，我们需要使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msup><mi>M</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><msup><mo stretchy="false">)</mo><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">(M^{-1})^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0913em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span> 来变换。</p>
<p>所以一个正确的法线变换的表达式为：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">normalOutput = <span class="built_in">normalize</span>(<span class="type">mat3</span>(<span class="built_in">transpose</span>(<span class="built_in">inverse</span>(model))) * normalInput);</span><br></pre></td></tr></table></figure>
<h1 id="Reference"><a class="header-anchor" href="#Reference">#</a>Reference</h1>
<p><a href="http://www.lighthouse3d.com/tutorials/glsl-12-tutorial/the-normal-matrix/">The Normal Matrix » Lighthouse3d.com</a></p>
]]></content>
      <tags>
        <tag>图形学</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>SOLID 原则</title>
    <url>/solid/</url>
    <content><![CDATA[<p><code>SOLID</code> 原则是面向对象编程中的五个重要设计原则，有助于增强软件的可维护性、可扩展性和可读性。</p>
<h1 id="S_Single_Responsibility_Principle_单一职责"><a class="header-anchor" href="#S_Single_Responsibility_Principle_单一职责">#</a>S- Single Responsibility Principle 单一职责</h1>
<p>单一原则要求一个类只能承担一个职责，并且只能有一个潜在的原因去更改这个类。</p>
<p><img src="/solid/image-20220703135544298.png" alt="单一职责"></p>
<div class="note warning simple"><p>不要刻意的追求单一原则，甚至于到了一个类只包含一个函数的程度。</p>
</div>
<h2 id="Example"><a class="header-anchor" href="#Example">#</a>Example</h2>
<p>如下是一个常见的 Unity <code>Monobehavior</code>：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UnrefactoredPlayer</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> <span class="built_in">string</span> inputAxisName;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> <span class="built_in">float</span> positionMultiplier;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> m_YPosition;</span><br><span class="line">    <span class="keyword">private</span> AudioSource m_BounceSfx;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span> &#123; m_BounceSfx = GetComponent&lt;AudioSource&gt;(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">float</span> delta = Input.GetAxis(inputAxisName) * Time.deltaTime;</span><br><span class="line">        m_YPosition = Mathf.Clamp(m_YPosition + delta, <span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">        transform.position = <span class="keyword">new</span> Vector3(transform.position.x, m_YPosition * positionMultiplier, transform.position.z);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerEnter</span>(<span class="params">Collider other</span>)</span> &#123; m_BounceSfx.Play(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个脚本中实际上耦合了音频，按键输入和对于玩家移动的控制，即：<br>
<img src="/solid/image-20230610105358001.png" alt="不符合单一原则的 Player"></p>
<p>为了符合单一职责的原则，可以将对于音频，按键输入和玩家控制的逻辑，分别拆分至 <code>PlayerAudio</code>，<code>PlayerInput</code> 和 <code>PlayerMovement</code> 三个类中， <code>Player</code> 去引用者三个类，如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">RequireComponent(typeof(PlayerAudio), typeof(PlayerInput), typeof(PlayerMovement))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Player</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> PlayerAudio playerAudio;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> PlayerInput playerInput;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> PlayerMovement playerMovement;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        playerAudio = GetComponent&lt;PlayerAudio&gt;();</span><br><span class="line">        playerInput = GetComponent&lt;PlayerInput&gt;();</span><br><span class="line">        playerMovement = GetComponent&lt;PlayerMovement&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerAudio</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerInput</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerMovement</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>关系图如下，此时如果要修改音频相关的逻辑，只需要修改 <code>PlayerAudio</code> 脚本，不会有影响到 Input 和 Movement 的风险：<br>
<img src="/solid/image-20230610134447341.png" alt="符合单一原则的 Player"></p>
<h1 id="O_Open_Closed_Principle_开闭原则"><a class="header-anchor" href="#O_Open_Closed_Principle_开闭原则">#</a>O-Open/Closed Principle 开闭原则</h1>
<p>实体应该对  <strong>扩展</strong>  开放，对  <strong>修改</strong>  关闭。允许扩展行为而无需修改源代码。</p>
<p><img src="/solid/image-20220703135627060.png" alt="开闭原则"></p>
<h2 id="Example-2"><a class="header-anchor" href="#Example-2">#</a>Example</h2>
<p>如存在 <code>AreaCalculator</code> 类，用以计算不同形状的面积：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AreaCalculator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">float</span> <span class="title">GetRectangleArea</span>(<span class="params">Rectangle rectangle</span>)</span> &#123; <span class="keyword">return</span> rectangle.width * rectangle.height; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">float</span> <span class="title">GetCircleArea</span>(<span class="params">Circle circle</span>)</span> &#123; <span class="keyword">return</span> circle.radius * circle.radius * Mathf.PI; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Rectangle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> width;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Circle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/solid/image-20230610135408696.png" alt="不符合开闭原则的 Area Calculator"></p>
<p>目前这个类的实现没有什么问题，但每增加一个形状，<code>AreaCalculator</code> 就需要修改一次。随着形状的种类的扩张， <code>AreaCaulculator</code> 会变得逐渐不可维护。</p>
<p>为了符合开闭原则，可以将所有形状抽象为 <code>Shape</code> 类，在派生类中定义每个形状计算面积的方式：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">float</span> <span class="title">CalculateArea</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Rectangle</span> : <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> width;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> height;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">float</span> <span class="title">CalculateArea</span>()</span> &#123; <span class="keyword">return</span> width * height; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Circle</span> : <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> radius;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">float</span> <span class="title">CalculateArea</span>()</span> &#123; <span class="keyword">return</span> radius * radius * Mathf.PI; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AreaCalculator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">float</span> <span class="title">GetArea</span>(<span class="params">Shape shape</span>)</span> &#123; <span class="keyword">return</span> shape.CalculateArea(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时 <code>AreaCalculator</code> 只需要关心调用 Shape 中的 <code>CalculateArea</code> 函数，而不需要关心具体的 Shape 类型。因此即使有了新的 Shape，也不会需要修改 <code>AreaCalculator</code> 类。此时类与类间的关系为：<br>
<img src="/solid/image-20230610161252390.png" alt="符合开闭原则的 AreaCalculator"></p>
<h1 id="L_Liskov_Substitution_Principle_里氏替换原则"><a class="header-anchor" href="#L_Liskov_Substitution_Principle_里氏替换原则">#</a>L - Liskov Substitution Principle 里氏替换原则</h1>
<p>程序中的对象应该可以被其子类实例替换掉，而不会影响程序的正确性。里氏替换原则指明了类的派生关系，要求派生类必须完全能承担基类的所有功能。</p>
<p><img src="/solid/image-20220703135721761.png" alt="里氏替换原则"></p>
<p>一些遵守里氏替换原则的技巧：</p>
<ul>
<li>如果在派生类中移除了某个函数的实现，则可能会破坏里氏替换原则。<code>NotImplementedException</code> 是一个绝对的信号，告知开发者里氏替换原则被破坏。如果子类中有空函数实现，则也标明了里氏替换原则的破坏。</li>
<li>保持基类尽可能的简单：在基类中的逻辑越多，则越可能破坏里氏替换原则。</li>
<li>更多的使用组合而非派生</li>
<li>在构造类的继承关系前，先思考类的 API。实现中的抽象关系，并不一定要来自于现实的抽象关系。并不是现实中所有的 <em>是</em> 关系，都需要设计为派生关系。如下例子中，<code>Train</code> 和 <code>Car</code> 可以派生自不同的基类，而非派生自 <code>Vehicle</code>。</li>
</ul>
<h2 id="Example-3"><a class="header-anchor" href="#Example-3">#</a>Example</h2>
<p>有一个 <code>Vehicle</code> 基类标识交通工具，并有 <code>Car</code> 和 <code>Trunk</code> 两个派生类：<br>
<img src="/solid/image-20230610162905254.png" alt="Vehicle 和派生类 "></p>
<p><code>Vehicle</code> 类如下</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Vehicle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> speed = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> Vector3 direction;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GoForward</span>()</span> &#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Reverse</span>()</span> &#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TurnRight</span>()</span> &#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TurnLeft</span>()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>交通工具，可能在马路上，也可能在铁路上行驶，如下图所示：<br>
<img src="/solid/image-20230610163001603.png" alt="铁路和马路"></p>
<p>可以通过类 <code>Navigator</code> 来控制交通工具的行驶：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Navigator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Move</span>(<span class="params">Vehicle vehicle</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        vehicle.GoForward();</span><br><span class="line">        vehicle.TurnLeft();</span><br><span class="line">        vehicle.GoForward();</span><br><span class="line">        vehicle.TurnRight();</span><br><span class="line">        vehicle.GoForward();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时如果将 <code>Train</code> 传递给 <code>Navigator</code> 就会发现，<code>Train</code> 在铁轨上是不能进行左右转弯的：<br>
<img src="/solid/image-20230610163250520.png" alt="Train 无法进行左右转弯"></p>
<p>此时即破坏了里氏替换原则，因为基类 <code>Vehicle</code> 要求交通工具要实现左右转弯，而 <code>Train</code> 并无法实现，即基类无法被派生类的替换。</p>
<p>为了修复这个问题，可以使用组合，将转向和移动拆分成两个接口，而不是集中在 <code>Vehicle</code> 基类中：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ITurnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TurnRight</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TurnLeft</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IMovable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GoForward</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Reverse</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建两个基类 <code>RoadVehicle</code> 和 <code>RailVehicle</code> 使用这两个接口，如下所示。此时每一个派生类都完美的实现了基类（<code>ITurnable</code> 和 <code>IMovable</code>）的功能，即满足了里氏替换原则：<br>
<img src="/solid/image-20230610165245750.png" alt="符合里氏替换原则的 Car / Train"></p>
<p>实现如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RoadVehicle</span> : <span class="title">IMovable</span>, <span class="title">ITurnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> speed = <span class="number">100f</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> turnSpeed = <span class="number">5f</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">GoForward</span>()</span> &#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Reverse</span>()</span> &#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">TurnLeft</span>()</span> &#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">TurnRight</span>()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RailVehicle</span> : <span class="title">IMovable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> speed = <span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">GoForward</span>()</span> &#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Reverse</span>()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Car</span> : <span class="title">RoadVehicle</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Train</span> : <span class="title">RailVehicle</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<h1 id="I_Interface_Segregation_Principle_接口隔离原则"><a class="header-anchor" href="#I_Interface_Segregation_Principle_接口隔离原则">#</a>I - Interface Segregation Principle 接口隔离原则</h1>
<p>使用多个特定细分的接口比单一的总接口要好，不能强迫用户去依赖他们用不到的接口。</p>
<p><img src="/solid/image-20220703135800770.png" alt=""></p>
<h2 id="Example-4"><a class="header-anchor" href="#Example-4">#</a>Example</h2>
<p>如在一个策略游戏中，有很多的单位。开发者可能会定义一个如下接口保证所有的对象都实现相似的功能：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IUnitStats</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> Health &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Defense &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Die</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TakeDamage</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RestoreHealth</span>()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> MoveSpeed &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> Acceleration &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GoForward</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Reverse</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TurnLeft</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TurnRight</span>()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Strength &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Dexterity &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Endurance &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个接口太过于复杂了，比如一个爆炸桶单位并不会移动，因此如果爆炸桶继承了该类，它必须要实现无意义的 <code>GoForward</code>，<code>TurnLeft</code> 等接口。</p>
<p>符合接口合理原则的方式，是将上述的接口进行拆分，如下所示。此时每一个派生类都能实现它真正需要的接口：<br>
<img src="/solid/image-20230610172229144.png" alt="符合接口隔离的接口定义"></p>
<p>定义的接口为：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IMovable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> MoveSpeed &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> Acceleration &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GoForward</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Reverse</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TurnLeft</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TurnRight</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IDamageable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> Health &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Defense &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Die</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TakeDamage</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RestoreHealth</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IUnitStats</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Strength &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Dexterity &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Endurance &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IExplodable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> Mass &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> ExplosiveForce &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> FuseDelay &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Explode</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ExplodingBarrel</span> : <span class="title">MonoBehaviour</span>, <span class="title">IDamageable</span>, <span class="title">IExplodable</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EnemyUnit</span> : <span class="title">MonoBehaviour</span>, <span class="title">IDamageable</span>, <span class="title">IMovable</span>, <span class="title">IUnitStats</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<h1 id="D_Dependency_Inversion_Principle_依赖倒置原则"><a class="header-anchor" href="#D_Dependency_Inversion_Principle_依赖倒置原则">#</a>D - Dependency Inversion Principle 依赖倒置原则</h1>
<p>程序要依赖于抽象接口，而不是具体实现。</p>
<ul>
<li>高层模块不应该依赖底层模块，二者都应该依赖于抽象</li>
<li>抽象不应该依赖具体实现，具体实现应该依赖抽象</li>
</ul>
<p><img src="/solid/image-20220703135905806.png" alt="依赖倒置原则"></p>
<div class="note info simple"><p>关于内聚耦合的定义和解释，见 <a href="/coupling/#%E9%AB%98%E5%86%85%E8%81%9A%E4%BD%8E%E8%80%A6%E5%90%88">高内聚低耦合</a></p>
</div>
<p>在编码时，自然的会产生 <code>High-Level</code> 的模块和 <code>Low-Level</code> 的模块。很自然的情况下，<code>High-Level</code> 模块会依赖 <code>Low-Level</code> 模块实现某些功能，但依赖导致原则则需要将整个依赖关系转为依赖抽象。</p>
<h2 id="Example-5"><a class="header-anchor" href="#Example-5">#</a>Example</h2>
<p>如需要实现<em>打开门</em> 这一功能，常见的会定义一个 <code>Switch</code> 类管理门的开启或关闭，并定义 <code>Door</code> 表示门。 <code>Switch</code> 是 <code>High-Level</code> 模块，<code>Door</code> 是 <code>Low-Level</code> 模块。</p>
<p>最常见的实现情况如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Switch</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Door door;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isActivated;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Toggle</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isActivated)</span><br><span class="line">        &#123;</span><br><span class="line">            isActivated = <span class="literal">false</span>;</span><br><span class="line">            door.Close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            isActivated = <span class="literal">true</span>;</span><br><span class="line">            door.Open();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Door</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Open</span>()</span> &#123; Debug.Log(<span class="string">&quot;The door is open.&quot;</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Close</span>()</span> &#123; Debug.Log(<span class="string">&quot;The door is closed.&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时依赖关系为：<br>
<img src="/solid/image-20230611125426387.png" alt="高等级的 Switch 依赖低等级的 Door "></p>
<p>这种实现可以正常运作，但 <code>Switch</code> 直接依赖了 <code>Door</code>，如果 <code>Switch</code> 要控制更多的物体，如灯泡，电风扇则需要再次修改。</p>
<p>解决方法是增加 <code>ISwitchable</code> 接口，<code>Switch</code> 依赖 <code>ISwitchable</code> 而不依赖 <code>Door</code>，如下：<br>
<img src="/solid/image-20230611144515909.png" alt="使用 ISwitchable 作为两个类的桥梁"></p>
<p>实现代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ISwitchable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isActive &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Activate</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Deactivate</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Switch</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> ISwitchable client;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Toggle</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (client.isActive)</span><br><span class="line">            client.Deactivate();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            client.Activate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Door</span> : <span class="title">MonoBehaviour</span>, <span class="title">ISwitchable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isActive &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Activate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        isActive = <span class="literal">true</span>;</span><br><span class="line">        Debug.Log(<span class="string">&quot;The door is open.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Deactivate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        isActive = <span class="literal">false</span>;</span><br><span class="line">        Debug.Log(<span class="string">&quot;The door is closed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时再需要定义新的可开关变量，只需要新增类而无需修改 <code>Switch</code> 脚本。这就是依赖倒置原则带来的好处：<br>
<img src="/solid/image-20230611151422409.png" alt=""></p>
<h1 id="Reference"><a class="header-anchor" href="#Reference">#</a>Reference</h1>
<p><a href="https://blog.unity.com/games/level-up-your-code-with-game-programming-patterns">Level up your code with game programming patterns | Unity Blog</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/130954951">图解你身边的 SOLID 原则 - 知乎 (zhihu.com)</a></p>
]]></content>
      <tags>
        <tag>设计模式</tag>
        <tag>编码规范</tag>
      </tags>
  </entry>
  <entry>
    <title>《System, Math and Explosions》 摘抄</title>
    <url>/system,_math_and_explosions/</url>
    <content><![CDATA[<p>系统从根本上就是复杂地，因为它不仅仅包含事物的集合，还包含事物的连接关系。而连接关系增长的非常块。</p>
<p>如下所示， 3 个点的集合只有 3 个连接，9 个点的集合有 36 个连接，最右侧的集合有 27 个点，链接已经增长到了 351 个，这种现象被称为<code>组合爆炸（Combinatorial Explosion）</code>：<br>
<img src="/system,_math_and_explosions/image-20230902151352.png" alt="系统连接的复杂度"></p>
<div class="note info simple"><p>直觉上，增长速度是指数级的，但是实际上是多项书的，但这不是这篇文章的重点。</p>
</div>
<h1 id="组合爆炸就是复杂性爆炸"><a class="header-anchor" href="#组合爆炸就是复杂性爆炸">#</a>组合爆炸就是复杂性爆炸</h1>
<p>当系统内组件的数量线性增长时，组件间的连接关系会呈指数增长，也因此系统的复杂度增长的会非常快。</p>
<h1 id="堆积如山的东西是不可预测的"><a class="header-anchor" href="#堆积如山的东西是不可预测的">#</a>堆积如山的东西是不可预测的</h1>
<p>系统之所以是系统，是因为它的组件能相互协同工作。随着系统的发展，理解一切是如何工作的，或者系统是否还仍然有效，变得越来越困难。这会让人感到难以理解、脆弱和不可预测。到那时，系统就正式变成了一坨 *</p>
<p>不可预测性尤其可怕。因为不可预测的结果可能是好的、坏的或可怕的。前一分钟可以是这三个的组合，下一分钟以上都不是。这就是混乱，混乱必然是不好的。</p>
<h1 id="避免复杂性的方法也会造成复杂性"><a class="header-anchor" href="#避免复杂性的方法也会造成复杂性">#</a>避免复杂性的方法也会造成复杂性</h1>
<p>人们已经磨练了很多工具来避免复杂性。但坏消息是治疗方法可能比疾病本身更糟糕。这并不是说这些工具本质上是不好的，而是它们具有经常被忽视的局限性。以下是一些局限性：</p>
<h2 id="拆分混淆了复杂性"><a class="header-anchor" href="#拆分混淆了复杂性">#</a>拆分混淆了复杂性</h2>
<p>尝试简化系统时，划分是首选方法。它是一个很好的工具，可以将一个大型的整体系统转变为一个由更小、更易于管理的子系统组成的系统。如下：</p>
<p><img src="/system,_math_and_explosions/image-20230902153548.png" alt="拆分为小组件"></p>
<p>可以将系统的划分，与公司的组织结构划分类比。组织结构是将庞大的系统（人员），分解为更小、更容易理解的子系统（部门）的典型定义。</p>
<p>组织结构图一个问题是它们会在人与人之间制造人为障碍，使他们更难一起工作。这些分区实际上并不存在于人们的日常工作中，但无论如何都是为了简化的目标而创建的。团队变得孤立，过度专注于自己的目标，而失去了对更大方向的可见性。</p>
<p>在一个系统中也是如此，如果要保证所有模块的连接与拆分前一致，将变得非常困难。因此在实际的拆分中，很可能会造就一个脱节的系统，其中的各个元素感觉不像是在一起工作的。</p>
<h2 id="减少连接降低复杂度"><a class="header-anchor" href="#减少连接降低复杂度">#</a>减少连接降低复杂度</h2>
<p>仅仅因为系统中的两个部分可以连接，并不意味着它们应该连接。明确减少各个部分之间的连接是降低复杂性的另一种明确方法。如下是一个仍然是 27 个点，但每个点只和自己同侧的点相连的图，可以看到连接数大大减少了：<br>
<img src="/system,_math_and_explosions/image-20230902154148.png" alt="降低连接数"></p>
<p>但整个解决方案不利的一面是，需要额外的认知负担来理解哪些部分相互连接以及如何连接，这个认知负担也会随着每个组件的每组选项的独特程度而增加。</p>
<p>另一个缺陷是，规则很可能会变得越来越复杂，一旦一个系统开始有 “做_<strong>_，除非__</strong>，除非____” 的规则出现，就要假设已经有人无法连接这个规则了。</p>
<h2 id="抽象创造了复杂性的层次"><a class="header-anchor" href="#抽象创造了复杂性的层次">#</a>抽象创造了复杂性的层次</h2>
<p>另一个降低复杂性的尝试是，仅让系统的一个子集可以被使用：一个简单的公共系统向所有人开放，它由一个隐藏着的一个更大、更复杂的私有系统驱动。</p>
<p>如下所示：</p>
<p><img src="/system,_math_and_explosions/image-20230902154624.png" alt="抽象"></p>
<p>这样的解决方案会减少认知负担，尤其是对于初学者而言。用户可以从强大的抽象系统中受益，但陷入麻烦的选择要少得多。</p>
<p>当然也有缺点。首先，公共和私有系统意味着需要处理更多的系统。其次，抽象可能会带来长期混乱的风险，因为人们开始发现他们没有获得所有的选择。这就引出了这样的问题：“还有哪些其他选项对我来说不可用？”、“为什么我不能使用它们？”并且，“为什么系统要按照与我不同的规则进行游戏？”</p>
<h1 id="降低复杂度的唯一真正办法"><a class="header-anchor" href="#降低复杂度的唯一真正办法">#</a>降低复杂度的唯一真正办法</h1>
<p>如果使用得当，上概述的工具可能会非常有效。但数学就是数学。线性地移除系统中的部分，连接会减少得更快。治疗复杂性的症状通常只是重新分配它。简而言之，避免复杂性陷阱的最佳方法就是完全避免复杂性。</p>
<h1 id="令人窒息的秩序_或_灾难性的混乱"><a class="header-anchor" href="#令人窒息的秩序_或_灾难性的混乱">#</a>令人窒息的秩序 或 灾难性的混乱</h1>
<p>很少有人承认混乱有吸引性，但为何它还是那么普遍呢？一个答案是：因为接受混乱很舒服。</p>
<p>避免混乱就是寻求冲突。 “是” 会助长复杂性爆炸，“不” 则让阻碍复杂度增长。 但 “不“ 会带来争议，这是痛苦的、排斥的、令人窒息的。“不” 不会让你成为聚会的焦点，而且通常需要令人难以置信的纪律才能维持。</p>
<p>尽管 “不” 可能会让人不舒服，但这最终是防止爆炸变成爆炸的最简单方法。</p>
<h1 id="Reference"><a class="header-anchor" href="#Reference">#</a>Reference</h1>
<p><a href="https://pjonori.blog/posts/systems-math-explosions/">Systems, math and explosions (in no particular order) (pjonori.blog)</a></p>
]]></content>
      <tags>
        <tag>系统设计</tag>
      </tags>
  </entry>
  <entry>
    <title>《Render Hell》 笔记汇总</title>
    <url>/render_hell/</url>
    <content><![CDATA[<ul>
<li><a href="/book_1_overview">Book 1 Overview</a></li>
<li><a href="/book_2_pipeline">Book 2 Pipeline</a></li>
<li><a href="/book_3_problems">Book 3 Problems</a></li>
<li><a href="/book_4_solutions">Book 4 Solutions</a></li>
</ul>
<h1 id="Reference"><a class="header-anchor" href="#Reference">#</a>Reference</h1>
<p><a href="http://simonschreibt.de/gat/renderhell/">Render Hell 2.0 | Simon schreibt.</a></p>
]]></content>
      <tags>
        <tag>GPU</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 System.CommandLine 为 .Net Tools 添加命令行参数支持</title>
    <url>/system.commandline_get_started/</url>
    <content><![CDATA[<p>本篇教程通过创建一个名为 <code>scl</code> <em>(Sample Command Line)</em> 的 .Net Tools 来说明如何使用 System.CommandLine 库为 .Net Tool 增加命令行参数解析支持。</p>
<div class="note primary simple"><p>完整的示例代码，可见 <a href="https://github.com/xuejiaW/.Net-Samples/tree/main/SampleCommandLine">SampleCommandLine</a></p>
</div>
<h1 id="使用_System_CommandLine_示例"><a class="header-anchor" href="#使用_System_CommandLine_示例">#</a>使用 System.CommandLine 示例</h1>
<h2 id="创建_Net_Tool"><a class="header-anchor" href="#创建_Net_Tool">#</a>创建 .Net Tool</h2>
<div class="note primary simple"><p>创建 .Net Tool 的完整说明可见 <a href="/create_.net_tools">.Net Tools 创建指南</a></p>
</div>
<p>通过以下命令创建一个 .Net Tool，并将其命令行指令定义为 <code>scl</code>：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">dotnet new console <span class="literal">-n</span> SampleCommandLine <span class="operator">-f</span> net8.<span class="number">0</span> <span class="comment"># Create SampleCommandLine tool</span></span><br></pre></td></tr></table></figure>
<p>修改 <code>SampleCommandLine.csproj</code> 文件，将命令行修改为 <code>scl</code>，并设定版本为 <code>0.0.1</code>，完整文件如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Project</span> <span class="attr">Sdk</span>=<span class="string">&quot;Microsoft.NET.Sdk&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">OutputType</span>&gt;</span>Exe<span class="tag">&lt;/<span class="name">OutputType</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TargetFramework</span>&gt;</span>net8.0<span class="tag">&lt;/<span class="name">TargetFramework</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImplicitUsings</span>&gt;</span>enable<span class="tag">&lt;/<span class="name">ImplicitUsings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Nullable</span>&gt;</span>enable<span class="tag">&lt;/<span class="name">Nullable</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">PackAsTool</span>&gt;</span>true<span class="tag">&lt;/<span class="name">PackAsTool</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ToolCommandName</span>&gt;</span>scl<span class="tag">&lt;/<span class="name">ToolCommandName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">PackageOutputPath</span>&gt;</span>./nupkg<span class="tag">&lt;/<span class="name">PackageOutputPath</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Version</span>&gt;</span> 0.0.1 <span class="tag">&lt;/<span class="name">Version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">Project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>dotnet pack</code> 打包后，再使用如下命令将 <code>scl</code> 安装为全局的命令：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">dotnet tool install <span class="literal">--global</span> <span class="literal">--add-source</span> .\nupkg SampleCommandLine <span class="literal">--version</span> <span class="number">0.0</span>.<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>运行效果如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">❯ scl</span><br><span class="line">Hello, World!</span><br></pre></td></tr></table></figure>
<h2 id="安装并使用_System_CommandLine_Package"><a class="header-anchor" href="#安装并使用_System_CommandLine_Package">#</a>安装并使用 System.CommandLine Package</h2>
<p>使用 add package 命令为项目增加 <code>System.CommandLine</code> 包：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">dotnet add package System.CommandLine <span class="literal">--prerelease</span></span><br></pre></td></tr></table></figure>
<p>修改 <code>Program.cs</code> 为如下内容：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.CommandLine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">SampleCommandLine</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> Task&lt;<span class="built_in">int</span>&gt; <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> fileOption = <span class="keyword">new</span> Option&lt;FileInfo?&gt;(name: <span class="string">&quot;--file&quot;</span>,</span><br><span class="line">                                               description: <span class="string">&quot;The file to read and display on the console&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> rootCommand = <span class="keyword">new</span> RootCommand(<span class="string">&quot;Sample app for System.CommandLine&quot;</span>);</span><br><span class="line">        rootCommand.AddOption(fileOption);</span><br><span class="line">        rootCommand.SetHandler(file =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (file != <span class="literal">null</span>) ReadFile(file);</span><br><span class="line">        &#125;, fileOption);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> rootCommand.InvokeAsync(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ReadFile</span>(<span class="params">FileInfo file</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        File.ReadLines(file.FullName).ToList().ForEach(Console.WriteLine);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码做了以下的行为：</p>
<ul>
<li>创建了一个名为 <code>--file</code> 的 Option，该 Option 接受一个 <a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.fileinfo">FileInfo</a> 类型的参数，用于指定一个文件。</li>
<li>创建了一个 Root Command，并将 <code>--file</code> Option 添加到 Root Command 中。</li>
<li>为 Root Command 设置了一个 Handler，当 Root Command 被触发时调用 <code>ReadFile</code> 方法。</li>
</ul>
<p>即此时我们定义 <code>scl</code> 命令，其接受一个 <code>--file</code> 参数，用于指定一个文件，当 <code>scl</code> 命令被触发时，将读取该文件的内容并输出到控制台。</p>
<h2 id="测试_Net_Tool"><a class="header-anchor" href="#测试_Net_Tool">#</a>测试 .Net Tool</h2>
<p>当上述代码完成后，可以重新打包并安装 <code>scl</code> 进行测试：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">dotnet pack</span><br><span class="line">dotnet tool update <span class="literal">--global</span> <span class="literal">--add-source</span> .\nupkg SampleCommandLine</span><br><span class="line">scl <span class="literal">--file</span> .\SampleCommandLine.csproj</span><br></pre></td></tr></table></figure>
<p>此时可以看到 <code>scl</code> 命令如预期的输出了目标文件的内容：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">❯ scl --file .\SampleCommandLine.csproj</span><br><span class="line">&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;</span><br><span class="line"></span><br><span class="line">  &lt;PropertyGroup&gt;</span><br><span class="line">    &lt;OutputType&gt;Exe&lt;/OutputType&gt;</span><br><span class="line">    &lt;TargetFramework&gt;net8.0&lt;/TargetFramework&gt;</span><br><span class="line">    &lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;</span><br><span class="line">    &lt;Nullable&gt;enable&lt;/Nullable&gt;</span><br><span class="line">    &lt;PackAsTool&gt;true&lt;/PackAsTool&gt;</span><br><span class="line">    &lt;ToolCommandName&gt;scl&lt;/ToolCommandName&gt;</span><br><span class="line">    &lt;PackageOutputPath&gt;./nupkg&lt;/PackageOutputPath&gt;</span><br><span class="line">    &lt;Version&gt; 0.0.1 &lt;/Version&gt;</span><br><span class="line">    &lt;AssemblyName&gt;scl&lt;/AssemblyName&gt;</span><br><span class="line">  &lt;/PropertyGroup&gt;</span><br><span class="line"></span><br><span class="line">  &lt;ItemGroup&gt;</span><br><span class="line">    &lt;PackageReference Include=&quot;System.CommandLine&quot; Version=&quot;2.0.0-beta4.22272.1&quot; /&gt;</span><br><span class="line">  &lt;/ItemGroup&gt;</span><br><span class="line"></span><br><span class="line">&lt;/Project&gt;</span><br></pre></td></tr></table></figure>
<p>另外此时运行 <code>System.CommandLine</code> 也会自动为生成的 .Net Tools 增加 <code>--version</code> 和 <code>--help</code> 支持：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">❯ scl <span class="literal">--help</span></span><br><span class="line">Description:</span><br><span class="line">  Sample app <span class="keyword">for</span> System.CommandLine</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">  SampleCommandLine [<span class="type">options</span>]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  <span class="literal">--file</span> &lt;file&gt;   The file to read and display on the console</span><br><span class="line">  <span class="literal">--version</span>       Show version information</span><br><span class="line">  -?, <span class="literal">-h</span>, <span class="literal">--help</span>  Show help and usage information</span><br><span class="line"></span><br><span class="line">❯ scl <span class="literal">--version</span></span><br><span class="line"> <span class="number">0.0</span>.<span class="number">1</span> +<span class="number">8780883</span>dafd03b279361438c8d2ae824e319fd48</span><br></pre></td></tr></table></figure>
<div class="note primary simple"><p>更多的测试方法，可见 测试 .Net Tools<br>
教程的后续部分，为了方便测试，会直接使用 <code>dotnet run</code> 进行测试。</p>
</div>
<h2 id="增加_Sub_Commands_和更多_Options"><a class="header-anchor" href="#增加_Sub_Commands_和更多_Options">#</a>增加 Sub Commands 和更多 Options</h2>
<p>我们将 <code>Program.cs</code> 的代码修改为内容：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> Task&lt;<span class="built_in">int</span>&gt; <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> fileOption = <span class="keyword">new</span> Option&lt;FileInfo?&gt;(name: <span class="string">&quot;--file&quot;</span>,</span><br><span class="line">                                               description: <span class="string">&quot;The file to read and display on the console&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> delayOption = <span class="keyword">new</span> Option&lt;<span class="built_in">int</span>&gt;(name: <span class="string">&quot;--delay&quot;</span>,</span><br><span class="line">                                          description:</span><br><span class="line">                                          <span class="string">&quot;Delay between lines, specified as milliseconds per character in a line.&quot;</span>,</span><br><span class="line">                                          getDefaultValue: () =&gt; <span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> fgColorOption = <span class="keyword">new</span> Option&lt;ConsoleColor&gt;(name: <span class="string">&quot;--fgcolor&quot;</span>,</span><br><span class="line">                                                     description: <span class="string">&quot;Foreground color of text displayed on the console.&quot;</span>,</span><br><span class="line">                                                     getDefaultValue: () =&gt; ConsoleColor.White);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> lightModeOption = <span class="keyword">new</span> Option&lt;<span class="built_in">bool</span>&gt;(name: <span class="string">&quot;--light-mode&quot;</span>,</span><br><span class="line">                                               description:</span><br><span class="line">                                               <span class="string">&quot;Background color of text displayed on the console: default is black, light mode is white.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> rootCommand = <span class="keyword">new</span> RootCommand(<span class="string">&quot;Sample app for System.CommandLine&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> readCommand = <span class="keyword">new</span> Command(<span class="string">&quot;read&quot;</span>, <span class="string">&quot;Reads a file and displays it on the console&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fileOption,</span><br><span class="line">            delayOption,</span><br><span class="line">            fgColorOption,</span><br><span class="line">            lightModeOption</span><br><span class="line">        &#125;;</span><br><span class="line">        rootCommand.AddCommand(readCommand);</span><br><span class="line"></span><br><span class="line">        readCommand.SetHandler(<span class="keyword">async</span> (file, delay, fgColor, lightMode) =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">await</span> ReadFile(file!, delay, fgColor, lightMode);</span><br><span class="line">        &#125;, fileOption, delayOption, fgColorOption, lightModeOption);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> rootCommand.InvokeAsync(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">ReadFile</span>(<span class="params">FileInfo file, <span class="built_in">int</span> delay, ConsoleColor fgColor, <span class="built_in">bool</span> lightMode</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.BackgroundColor = lightMode ? ConsoleColor.White : ConsoleColor.Black;</span><br><span class="line">        Console.ForegroundColor = fgColor;</span><br><span class="line">        List&lt;<span class="built_in">string</span>&gt; lines = File.ReadLines(file.FullName).ToList();</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">string</span> line <span class="keyword">in</span> lines)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(line);</span><br><span class="line">            <span class="keyword">await</span> Task.Delay(delay * line.Length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述的代码，主要进行了以下的修改：</p>
<ul>
<li>新定义了 <code>delayOption</code>、<code>fgColorOption</code> 和 <code>lightModeOption</code> 三个 Options，分别用于指定延迟、前景色和背景色。</li>
<li>将 <code>delayOption</code>、<code>fgColorOption</code> 和 <code>lightModeOption</code> 以及之前定义的 <code>fileOption</code> 一起用来定义传递给新创建的 <code>readCommand</code>。</li>
<li>将 <code>readCommand</code> 通过 <code>AddCommand</code> 将其作为 Root Command 的 Sub Command</li>
<li>修改函数 <code>ReadFile</code>，使其接受 <code>file</code>、<code>delay</code>、<code>fgColor</code> 和 <code>lightMode</code> 四个参数，并根据这四个参数的值来设置读取的文件、控制台的前景色、背景色和延迟。
<ul>
<li>将 <code>ReadFile</code> 方法改为异步方法，以便在读取文件时可以进行延迟。</li>
</ul>
</li>
<li>将 <code>ReadFile</code> 通过 <code>SetHandler</code> 方法与 <code>readCommand</code> 绑定，使得当 <code>readCommand</code> 被触发时调用 <code>ReadFile</code> 方法。</li>
</ul>
<p>此时的实现效果如下：<br>
<img src="/system.commandline_get_started/gif-4-9-2024-10-31-27-pm.gif" alt="Read Command"></p>
<p>此时的工程状态可见 <a href="https://github.com/xuejiaW/.Net-Samples/commit/2ef65d6e7dfba041cd9e9dc7e4b811d931f3ca4b">Patch</a>。</p>
<h2 id="增加更多的_Sub_Commands_及自定义验证"><a class="header-anchor" href="#增加更多的_Sub_Commands_及自定义验证">#</a>增加更多的 Sub Commands 及自定义验证</h2>
<p>为了后续的测试方便，我们可以将文件 <a href="https://github.com/dotnet/samples/raw/main/csharp/getting-started/console-teleprompter/sampleQuotes.txt">sampleQuotes.txt</a> 放置在工程中。</p>
<p>在这一节中，我们增加以下的功能：</p>
<ul>
<li>为 <code>fileOption</code> 增加一个验证，使得当传入的文件不存在时，输出自定义的错误信息。当该 Option 未调用时，以默认值 <code>sampleQuotes.txt</code> 作为文件。
<ul>
<li>设为 Global Option，使得其可以在所有的 Sub Commands 中使用。</li>
</ul>
</li>
<li>增加一个新的 Sub Command <code>quote</code>，并未该 Sub Command 设定两个 Sub Commands <code>add</code> 和 <code>remove</code>，分别用于添加和删除名言：
<ul>
<li><code>delete</code> 命令，命令定义一个 <code>searchTermsOption</code> ，该 Option 接受多个参数，当一行的内容包含任意参数时，删除该行。</li>
<li><code>add</code> 命令，为该命令定义两个 Arguments，分别作为名言的作者和内容。
<ul>
<li>为 <code>add</code> 命令设置一个 Alias <code>insert</code> -&gt; 学习如何设置 Alias</li>
</ul>
</li>
<li>同时将原先的 <code>read</code> Command 也作为 <code>quote</code> 的 Sub Command。</li>
</ul>
</li>
</ul>
<p>最终的 Command 关系如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">scl</span><br><span class="line">└── quote</span><br><span class="line">    ├── read</span><br><span class="line">    ├── add</span><br><span class="line">    ├── remove</span><br></pre></td></tr></table></figure>
<p>基于上述的功能，我们在这一节将学会：</p>
<ul>
<li>如何定义 Global Option</li>
<li>如何自定义验证</li>
<li>如何设定接纳多个 Arguments 的 Option</li>
<li>如何定义 Arguments</li>
<li>如何设置 Alias</li>
</ul>
<h3 id="验证_Option"><a class="header-anchor" href="#验证_Option">#</a>验证 Option</h3>
<p>可通过如下的代码，为 <code>fileOption</code> 增加验证，：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">var</span> fileOption = <span class="keyword">new</span> Option&lt;FileInfo?&gt;(description: <span class="string">&quot;The file to read and display on the console&quot;</span>,</span><br><span class="line">                                       name: <span class="string">&quot;--file&quot;</span>,</span><br><span class="line">                                       isDefault: <span class="literal">true</span>,</span><br><span class="line">                                       parseArgument: GetFileInfo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line">FileInfo? GetFileInfo(ArgumentResult result)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (result.Tokens.Count == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FileInfo(<span class="string">&quot;sampleQuotes.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> filePath = result.Tokens.Single().Value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (File.Exists(filePath)) <span class="keyword">return</span> <span class="keyword">new</span> FileInfo(filePath);</span><br><span class="line">    result.ErrorMessage = <span class="string">&quot;File does not exist.&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中设定 <code>isDefault</code> 为 <code>true</code>，使得即使没有调用 <code>--file</code> 时，设定的 <code>parseArgument</code> 也会被调用。将函数 <code>GetFileInfo</code> 作为 <code>parseArgument</code>，<code>fileOption</code> 的参数会被传递给该函数进行解析</p>
<ul>
<li>在函数中，我们检查了当文件路径不存在时返回错误信息 <code>File does not exist.</code></li>
<li>当 <code>Tokens</code> 的数量为 0 时，即没有设定 <code>--file</code> 时，返回默认的文件路径 <code>sampleQuotes.txt</code></li>
<li>否则正常返回文件路径</li>
</ul>
<h3 id="设置_Global_Option"><a class="header-anchor" href="#设置_Global_Option">#</a>设置 Global Option</h3>
<p>将 <code>fileOption</code> 作为 Global Option 赋值给 Root Command，此时原先的 <code>readCommand</code> 就可以将 <code>fileOption</code> 的添加删除：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">rootCommand.AddGlobalOption(fileOption);</span><br><span class="line"><span class="keyword">var</span> readCommand = <span class="keyword">new</span> Command(<span class="string">&quot;read&quot;</span>, <span class="string">&quot;Reads a file and displays it on the console&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    delayOption,</span><br><span class="line">    fgColorOption,</span><br><span class="line">    lightModeOption</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>定义 <code>quote</code> Command，并将 <code>readCommand</code> 作为其 Sub Command：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> quotesCommand = <span class="keyword">new</span> Command(<span class="string">&quot;quotes&quot;</span>, <span class="string">&quot;Work with a file that contains quotes.&quot;</span>);</span><br><span class="line">quotesCommand.AddCommand(readCommand);</span><br><span class="line">rootCommand.AddCommand(quotesCommand);</span><br></pre></td></tr></table></figure>
<h3 id="设定支持多个_Arguments_的_Option"><a class="header-anchor" href="#设定支持多个_Arguments_的_Option">#</a>设定支持多个 Arguments 的 Option</h3>
<p>增加一个 <code>searchTermsOption</code> 用于 <code>delete</code> 命令，该命令使用 <code>IsRequired</code> 表示该选项是必须的，可以使用 <code>AllowMultipleArgumentsPerToken</code> 表示该选项可以接受多个参数，为 <code>delete</code> 命令设定处理函数 <code>DeleteFromFile</code>，当一行的内容包含所有的参数时，删除该行：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> searchTermsOption = <span class="keyword">new</span> Option&lt;<span class="built_in">string</span>[]&gt;(name: <span class="string">&quot;--search-terms&quot;</span>,</span><br><span class="line">                                             description: <span class="string">&quot;Strings to search for when deleting entries.&quot;</span>)</span><br><span class="line">    &#123;IsRequired = <span class="literal">true</span>, AllowMultipleArgumentsPerToken = <span class="literal">true</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> deleteCommand = <span class="keyword">new</span> Command(<span class="string">&quot;delete&quot;</span>, <span class="string">&quot;Deletes lines from a file.&quot;</span>);</span><br><span class="line">deleteCommand.AddOption(searchTermsOption);</span><br><span class="line">deleteCommand.SetHandler((file, searchTerms) =&gt; DeleteFromFile(file!, searchTerms), fileOption, searchTermsOption);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteFromFile</span>(<span class="params">FileInfo file, <span class="built_in">string</span>[] searchTerms</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Deleting from file&quot;</span>);</span><br><span class="line">    File.WriteAllLines(file.FullName, File.ReadLines(file.FullName)</span><br><span class="line">                                          .Where(line =&gt; searchTerms.All(s =&gt; !line.Contains(s))).ToList());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">quotesCommand.AddCommand(deleteCommand);</span><br></pre></td></tr></table></figure>
<p>调用示例如下，如果行中同时包含有 <code>David</code> 或 <code>You can do</code>，则删除该行：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">scl quotes delete <span class="literal">--search-terms</span> David <span class="string">&quot;You can do&quot;</span></span><br></pre></td></tr></table></figure>
<p>此时通过 Git 查看文件内容，会发现该行已经被删除。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="literal">-1</span>. You can <span class="keyword">do</span> anything, but not everything.</span><br><span class="line"></span><br><span class="line"><span class="literal">--David</span> Allen</span><br></pre></td></tr></table></figure>
<h3 id="设定_Arguments"><a class="header-anchor" href="#设定_Arguments">#</a>设定 Arguments</h3>
<p>定义两个 Arguments 作为 <code>add</code> 命令的参数，分别用于指定名言的内容和作者：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> addCommand = <span class="keyword">new</span> Command(<span class="string">&quot;add&quot;</span>, <span class="string">&quot;Add an entry to the file.&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> quoteArgument = <span class="keyword">new</span> Argument&lt;<span class="built_in">string</span>&gt;(name: <span class="string">&quot;quote&quot;</span>, description: <span class="string">&quot;Text of quote.&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> bylineArgument = <span class="keyword">new</span> Argument&lt;<span class="built_in">string</span>&gt;(name: <span class="string">&quot;byline&quot;</span>, description: <span class="string">&quot;Byline of quote.&quot;</span>);</span><br><span class="line"></span><br><span class="line">addCommand.AddArgument(quoteArgument);</span><br><span class="line">addCommand.AddArgument(bylineArgument);</span><br><span class="line">addCommand.SetHandler(AddToFile, fileOption, quoteArgument, bylineArgument);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddToFile</span>(<span class="params">FileInfo file, <span class="built_in">string</span> quote, <span class="built_in">string</span> byline</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Adding to file&quot;</span>);</span><br><span class="line">    <span class="keyword">using</span> StreamWriter writer = file.AppendText();</span><br><span class="line">    writer.WriteLine(<span class="string">$&quot;<span class="subst">&#123;Environment.NewLine&#125;</span><span class="subst">&#123;Environment.NewLine&#125;</span><span class="subst">&#123;quote&#125;</span>&quot;</span>);</span><br><span class="line">    writer.WriteLine(<span class="string">$&quot;<span class="subst">&#123;Environment.NewLine&#125;</span>-<span class="subst">&#123;byline&#125;</span>&quot;</span>);</span><br><span class="line">    writer.Flush();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">quotesCommand.AddCommand(addCommand);</span><br></pre></td></tr></table></figure>
<p>此时可以通过如下命令将一条名言添加到文件中：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">scl quotes add <span class="string">&quot;Hello world!&quot;</span> <span class="string">&quot;Nancy Davolio&quot;</span></span><br></pre></td></tr></table></figure>
<p>此时使用 Git 查看文件内容，会发现 <code>Hello world!</code> 已经被添加到文件中。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">+Hello world!</span><br><span class="line">+</span><br><span class="line">+<span class="literal">-Nancy</span> Davolio</span><br></pre></td></tr></table></figure>
<h3 id="设置_Alias"><a class="header-anchor" href="#设置_Alias">#</a>设置 Alias</h3>
<p>为 <code>add</code> 命令设置一个 Alias <code>insert</code>：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">addCommand.AddAlias(<span class="string">&quot;insert&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>此时可以通过如下命令调用 <code>add</code> 命令：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">scl quotes insert <span class="string">&quot;Hello world!&quot;</span> <span class="string">&quot;Nancy Davolio&quot;</span></span><br></pre></td></tr></table></figure>
<h1 id="Reference"><a class="header-anchor" href="#Reference">#</a>Reference</h1>
<p><a href="https://learn.microsoft.com/en-us/dotnet/standard/commandline/get-started-tutorial">Tutorial: Get started with System.CommandLine - .NET | Microsoft Learn</a>：本篇教程绝大部分内容出自于此</p>
]]></content>
      <tags>
        <tag>DotNet</tag>
      </tags>
  </entry>
  <entry>
    <title>《贪婪的多巴胺》 摘抄</title>
    <url>/tan_lan_de_duo_ba_an/</url>
    <content><![CDATA[<p>《贪婪的多巴胺》 笔记摘抄。该书主要从生物学角度介绍了多巴胺对人行为及心理的影响。主要的包括：</p>
<ul>
<li>多巴胺与当下因子：当下因子让人关注当下，多巴胺让人关注未来</li>
<li>多巴胺与自律的关系：毒品美食的吸引力来自于欲望多巴胺，抵抗这些诱惑的能力不仅可以依赖意志力，也可以依赖控制多巴胺。</li>
<li>多巴胺与创造力的关系：丰富的多巴胺，让人更多的关注抽象的概念，并压抑了对此刻的关注，这可能会带来更多的创造力。但过多的多巴胺，则可能带来如精神分裂症这样的疾病</li>
<li>多巴胺与保守的关系：多巴胺能的人倾向于自由主义，当下分子能的人倾向于保守主义。</li>
</ul>
<h1 id="第一章_爱情"><a class="header-anchor" href="#第一章_爱情">#</a>第一章 爱情</h1>
<p>二十万分之一的脑细胞可以产生多巴胺，但这些细胞却能对行为产生巨大的影响。</p>
<p>在特定的情况下，激活让人“感觉良好”的多巴胺是人们无法抗拒的诱惑。一些科学家给多巴胺取名为“快乐分子”，大脑中产生多巴胺的途径被称为“奖赏回路“。但实际上多巴胺跟快乐一点儿关系都没有，它的影响力比“快乐”要大得多</p>
<p>多巴胺不是快乐的制造者，而是对意外的反应，即对可能性和预期的反应。我们每时每刻都在预测将要发生的事，从什么时候可以下班，到在自动取款机上看到卡里有多少余额。实际发生的事好于我们的预期，就表明我们对未来的预言存在误差：可能我们可以提前下班了，或者查看余额时发现比预期多了 100 元。正是这种让人快乐的误差触发多巴胺行动起来。这种快乐不是源于额外的时间或钱本身，而是预期之外的好消息带来的兴奋感。</p>
<p>多巴胺能的兴奋（即预期带来的兴奋）并不持久，因为最终未来都会变成现在。</p>
<p>多巴胺的角度来说，拥有是无趣的，只有获得才有趣。</p>
<p>为了享受我们拥有的东西，而不是仅仅可能得到的东西，我们的大脑必须从面向未来的多巴胺过渡到面向现在的某种化学物质，这是一系列神经递质，我们称之为“<strong>当下分子</strong>“。事实上，尽管多巴胺和当下分子的回路能一起工作，但在大多数情况下它们是相互对抗的。在当下分子回路被激活时，我们更喜欢体验周围的真实世界，多巴胺就会被抑制；而当多巴胺回路被激活时，我们则进入一个充满可能性的未来，当下分子会被抑制。</p>
<p>基于当下神经递质，如<strong>催产素、血管升压素和内啡肽</strong>的作用，它会为你提供长期的幸福感。这就像我们心中总是有最喜欢的餐厅、商店、城市一样，我们之所以喜爱这些地方，是因为熟悉的环境总是能给我们带来快乐，这里所说的环境指那个地方真实的物理环境。我们喜欢熟悉的事物，不是因为它能变成什么，而是因为它本来的样子。</p>
<p>多巴胺代表着痴迷与渴望，而与长期关系最相关的化学物质则是催产素和血管升压素。催产素在女性中更活跃，而血管升压素在男性中更活跃。</p>
<p>性就是爱情的快进。性始于欲望，是由睾酮这种激素驱动的一种多巴胺能的现象。接下来是性兴奋，这也是一种期待性的多巴胺能的体验。当身体接触开始时，大脑就将控制权转移到当下分子以便提供感官体验的愉悦，这个过程主要涉及内啡肽的释放。这一行为的顶峰，即性高潮，几乎完全是一种此时此地的体验，内啡肽和其他当下神经递质一起工作，将多巴胺彻底关闭。除了少数例外，大脑对性高潮的反应是相同的：多巴胺被关闭，当下分子通行。但是，正如有些人很难从激情之爱过渡到陪伴之爱，由多巴胺驱动的人在性生活中也很难把主导权让给当下分子。也就是说，有着强烈多巴胺驱动力的女性和男性有时会发现，他们难以停止自己的想法，去纯粹地体验性爱中亲昵的感觉——少一些思考，多一些感觉对他们来说非常困难。</p>
<h1 id="第二章_毒品"><a class="header-anchor" href="#第二章_毒品">#</a>第二章 毒品</h1>
<p>欲望始于大脑中一个在进化上早就存在的区域，位于头骨深处，被称为腹侧被盖区。这一区域富含多巴胺，是多巴胺两个主要的产生区域之一。像大多数脑细胞一样，生长在那里的细胞长着长长的尾巴，穿过大脑到达伏隔核。这些长尾巴的细胞被激活时，会将多巴胺释放到伏隔核中，让我们产生做某事的动力。这个回路叫作中脑边缘通路，但我们通常更直白地称之为 <strong>多巴胺欲望回路</strong>。</p>
<p><img src="/tan_lan_de_duo_ba_an/image-20230212202055360.png" alt="欲望回路"></p>
<p>买家之所以会懊悔，就是因为当下体验无法弥补多巴胺能激励的损失。这是欲望回路描绘的美好前景被打破的一个体现。它告诉你，如果你购买了那辆昂贵的车，你会欣喜若狂，你的生活肯定也会改变。但是，在你买入之后，你却没有特别强烈的感觉，而且这种感觉也不会很持久。想要和喜欢是由大脑中的两个不同的系统产生的，所以我们想要的东西往往是我们不喜欢的。</p>
<p>一种避免购买后懊悔的方法是购买一些能触发更多多巴胺能预期的东西，例如，一种工具（如一台能大大提高工作效率的新电脑），或者一件让你出门时看起来更迷人的新夹克。</p>
<p>毒品会“劫持”欲望回路。它们与食物或性等自然奖赏一样会刺激大脑激励系统，但它们刺激大脑的强度远甚于自然奖赏。成瘾性药物像导弹一样，以猛烈的“化学爆炸”冲击着欲望回路。任何自然行为都比不上它，食物、性，什么都比不上。</p>
<p>多巴胺系统的目标是预测未来，当一个意想不到的奖赏出现时，它就会发送一个信号说：“注意！现在要学习一些新东西了。”这样，沉浸在多巴胺中的脑回路就产生了可塑性，它们变成了新的样式。新的记忆被储藏，新的连接也形成了。“记住发生了什么，”多巴胺回路说，“这在将来可能有用。”最终结果是什么？下次奖赏出现时，你就不会感到惊讶了。当你发现一个网站播放着你最喜欢的音乐时，你会感到兴奋，但下一次访问这个网站时就不会了，它不再有任何奖赏预测误差。多巴胺并不是一种持久的快乐储存体。毒品破坏了大脑正常运作所需的微妙平衡。无论吸毒者处于何种情况，毒品都会刺激多巴胺的释放。于是，大脑变得混乱不堪，开始将吸毒与一切事物联系起来</p>
<p>当你期望的奖赏没有实现时，多巴胺系统就会关闭。用科学术语来讲，当多巴胺系统处于静止状态时，它会以每秒 3 到 5 次的速度被激发。但当它兴奋时，它的激发速率会激增到每秒 20 到 30 次。当预期的奖赏没有实现时，多巴胺的激发速率会下降到零，而这种感觉很糟糕。就是为什么多巴胺的停止会让你感到愤恨和失落，一个正在恢复的毒瘾患者每天保持克制和冷静时也是这种感受。克服上瘾需要付出巨大的力量、决心和支持。不要轻易招惹多巴胺，它的反击会让人招架不住</p>
<p>多巴胺的增加会让人热情参与自己原本认为不重要的事务。例如，有报道称一些吸大麻的人会站在水池前，看着水龙头不断地滴水，这一平平无奇的景象让他们看得十分着迷。欲望多巴胺压制了大脑中更理性的部分。我们知道自己做出的选择并不符合我们的最大利益，但我们无力抗拒。这就好比我们的自由意志已经屈服于一种强烈的及时行乐的冲动——也许是我们在节食时吃的一袋薯片，也许是一夜挥霍。</p>
<p>上瘾不是性格软弱或意志力不足的表现，它只是欲望回路因过度刺激而进入病理状态时会发生的情况。</p>
<p>帕金森病是一种多巴胺缺乏症，患有这种病的人负责控制肌肉运动的一条通路中多巴胺不足。这条通路，简单地说，就是我们将内心世界转化为行动，以及将意志施加给世界的途径。当这条通路中没有足够的多巴胺时，人就会僵硬和颤抖，并且移动缓慢。治疗方法是吃一些能促进多巴胺增长的药物。</p>
<p>什么样的大脑回路强大到足以对抗多巴胺呢？答案是多巴胺，多巴胺可以对抗多巴胺。与欲望回路相反的回路可以被称为“多巴胺控制回路”。</p>
<h1 id="第三章_掌控的力量"><a class="header-anchor" href="#第三章_掌控的力量">#</a>第三章 掌控的力量</h1>
<p>多巴胺通过不同的大脑回路也会产生不同的功能，经过中脑边缘回路的多巴胺会产生冲动，我们称该回路为 <strong>多巴胺欲望回路</strong> 。计算和规划（控制各种情况的手段）来自中脑皮层回路，我们称之为 <strong>多巴胺控制回路</strong></p>
<p>控制多巴胺利用欲望多巴胺提供的兴奋和动力，评估选项、挑选工具，并制定策略来获得想要的东西</p>
<p>多巴胺的功能来自进化和生存的需要。多巴胺鼓励我们最大限度地利用资源，因此，当我们把一件事情做得更好，使我们的未来成为一个更好、更安全的地方时，多巴胺就会奖励我们，给我们一点儿“躁起来”的感觉。多巴胺驱动了努力。这种努力的特征可能受到其他很多因素的影响，但如果没有多巴胺，努力从一开始就根本不会存在。</p>
<p>当别人对成功抱有很高的期望时，我们就会给他们让路。我们会服从他们的意志——在控制多巴胺的驱动下，他们的自我效能得到了完全的表达。我们的大脑之所以进化成这样，有一个充分的理由：参加一场你无法取胜的比赛可不明智。如果你发现对手对成功抱有很高的期望，那么你想要获胜就不那么容易了。<br>
为什么控制性神经递质多巴胺会触发顺从行为？这不是矛盾吗？一点儿也不矛盾。在控制回路中，多巴胺驱动的是控制环境，而不一定是环境中的人。多巴胺想要更多，但它不在乎它是如何得到的。无论道德还是不道德，控制还是顺从，对多巴胺而言都是一样的，只要它能使未来更好。</p>
<p>欲望多巴胺会促进毒瘾，让人追求快感，但收获的多巴胺刺激越来越少，同样，有些人的控制多巴胺如此之多，这使他们对成就上瘾，因而无法体验当下的满足。<br>
这是聚焦未来的多巴胺和聚焦现在的当下神经递质之间的失衡。他们想要逃避当下的情感和感官体验。对他们来说，生活关乎未来，关乎进步，关乎创新。尽管他们的努力带来了金钱甚至名声，但他们总是不开心。不管做了多少，他们都觉得不够。</p>
<p>额叶负责控制多巴胺的活动，它是发育得最晚的脑区，直到一个人结束青春期进入成年期之后，它才与大脑的其他部分完成连接。控制回路的工作之一是限制欲望回路，因此冲动控制与 ADHD 相关。当控制多巴胺很弱时，人们会去追求他们想要的东西而不考虑长期的后果。多巴胺的生成不受良心的约束。相反，在欲望的滋养下，它是狡猾的源泉。它被激发时，会抑制内疚感这种当下的情绪。它能够激励人们做出不懈的努力，但在追求的过程中不能避免使用欺骗甚至暴力手段 。</p>
<p>由激情驱使的攻击是对挑衅的猛烈回击，但这并不是由多巴胺控制回路刻意安排的动作。恰恰相反，当激情驱使着我们攻击挑衅者时，当下分子回路会抑制多巴胺。</p>
<p>当下分子回路相抗衡的多巴胺可以关闭情绪的音量。在复杂的情况下，拥有“冷静头脑”的人，也就是多巴胺能更强的人，能够抑制这种反应，做出更深思熟虑的选择，这些选择通常会带来更好的结果。传统观点将他的脱险归因于“肾上腺素爆发”，事实则恰恰相反。他不是靠肾上腺素爆发，而是靠多巴胺爆发。在他拯救船只的紧张时刻，多巴胺开始掌控局面，肾上腺素（当它在大脑中时被称为去甲肾上腺素）被抑制。</p>
<p>但当我们需要抵制有害的欲望时，意志力是我们首先使用的工具。事实证明，这可能不是个好选择。意志力可以帮助酒鬼拒绝一次喝酒，但如果他要在几个月或几年的时间里一次次地拒绝的话，他很可能坚持不住。意志力就像一块肌肉，用过之后会疲劳，可能用不了多久，它就放弃了 。于是就有了通过多巴胺对抗多巴胺的疗法，包括：</p>
<ul>
<li>动机增强疗法：用欲望多巴胺对抗欲望多巴胺</li>
<li>认知行为疗法：用控制多巴胺对抗欲望多巴胺</li>
<li>十二步促进疗法：用当下分子对抗欲望多巴胺<br>
当下的内疚感是一种强大的动力（你母亲或许也经常利用这一点）。情感的支持和内疚的威胁相结合，帮助许多瘾君子长期保持不复饮</li>
</ul>
<h1 id="第四章_天才与疯子"><a class="header-anchor" href="#第四章_天才与疯子">#</a>第四章 天才与疯子</h1>
<p>有可能影响你未来的事情是突出的，能触发欲望多巴胺的事情也是突出的。突出的信息提醒你：“该醒醒了！”“当心点儿！”“兴奋起来！”“这很重要！ 如果大脑在突出性方面的功能失灵，即在没有发生对你真正重要的事情时，它也爆发了，那么会发生什么呢？想象你在看新闻，主持人正在谈论政府的一项间谍计划，突然你的突出性回路无缘无故地启动，你可能就会相信新闻上的这个故事和你有关。突出性过强或者在错误的时间出现，都会产生错觉，让触发事件从默默无闻上升到至关重要。</p>
<p>患有精神分裂症的人通过服用阻断多巴胺受体的药物来控制多巴胺的活动。阻断多巴胺通常不会使精神分裂症的所有症状消失，但可以消除妄想和幻觉。不幸的是，抗精神病药物会阻断整个大脑的多巴胺，而阻断额叶的控制回路会使某些方面变得更糟，例如难以集中注意力和难以用抽象概念推理。</p>
<p>精神分裂症的患者大脑处于短路状态，把原本熟悉而被忽视的普通事物变得更显著。这种状态也叫作“低潜在抑制“。“潜在抑制”中“潜在”的含义略有不同。不是说一件事从一开始就被隐藏起来，而是说我们把它隐藏起来，因为它对我们不重要。</p>
<p>我们会抑制自己关注不重要事物的能力，这样就不必把注意力浪费在它们上面。我们在街上走的时候，如果被干净透亮的窗户分散了注意力，可能就注意不到十字路口处“禁止通行”的标志。</p>
<p>有时我们的环境充满了新事物，使得潜在抑制能力无法挑选出最重要的东西。这种经历可能令人兴奋，也可能令人恐惧。如你身处异国他乡，没有什么可抑制的，它就能带来极大的愉悦，但也会让人混乱、迷失方向，这就是文化冲击。</p>
<p>模型是我们为了更好地理解世界而建立起的对世界的假想图示。在某些方面，模型就像潜在抑制。模型只包含模型建造者认为必不可少的环境元素，不包含其他细节。这使得这个世界更容易理解，后续我们还可以通过各种方式来操纵它以获得最大利益。模型不仅简化了我们对世界的理解，而且还让我们做抽象归纳，利用获取的特定经验来制定广泛、通用的规则，从而预测和处理从未遇到的情况。<br>
当我们需要在许多不同的选项中进行选择时，模型会很有帮助。它们让我们想象不同的场景，以便选出最佳的一个。</p>
<p>糟糕的现实模型可能是由许多因素造成的：没有足够的信息，难以进行抽象思考，或者执着于错误的假设。这些糟糕的假设可能会导致焦虑和抑郁等精神疾病。例如，如果一个孩子在父母的挑剔下长大，她可能会产生自己是一个无能的人的想法，这种想法将塑造她一生所创造的世界模型 。</p>
<p>模型是一种强大的工具，但也有缺点。它们会让我们陷入特定的思维方式中，导致我们错失一些改善世界的机会</p>
<p>美术和自然科学之间的共同点，比大多数人认为的要更多，因为两者都是由多巴胺驱动的。诗人写一首描写爱而不得的诗句和物理学家写出电子激发公式没有什么不同，都需要创作者具有超越感官世界，进入一个更深层、更深刻的抽象思想世界的能力。</p>
<p>高水平的多巴胺会抑制当下分子的功能，所以聪明的人在人际关系上往往很差。我们需要当下的同理心来理解别人的想法，这是社交互动的基本技能。极其聪明、成功和极富创造性的人，也就是那些典型的多巴胺丰富的人通常会表达一种奇怪的情绪：他们对人类充满激情，但对个人却没有耐心。</p>
<h1 id="第五章_自由与保守"><a class="header-anchor" href="#第五章_自由与保守">#</a>第五章 自由与保守</h1>
<p>多巴胺能的人倾向于支持自由主义政策。自由主义者经常把自己称为“进步的”，这个词意味着不断的提升。 硅谷的企业家以及为他们工作的人，往往极富多巴胺能。他们意志坚强、敢于冒险、追求刺激，与《美国政治科学杂志》修正版文章中的自由主义者的特征相符。 一项针对初创企业创始人的调查显示，83% 的人持进步主义的观点，认为教育可以解决社会上的所有或大部分问题。而在公众中，只有 44% 的人相信这是真的。《纽约时报》的一篇评论指出，只有 2% 的英语系教授是共和党人，而 18% 的社会学家则认为自己是马克思主义者。</p>
<div class="note info simple"><p>多巴胺能的人倾向于自由主义，当下分子能的人倾向于保守主义。</p>
</div>
<p>大多数专家都认为智商测试并不能衡量一般智力。它更着重于衡量根据不完整数据进行归纳和使用抽象规则找出新信息的能力。智商测试衡量了一个人根据过去的经验建立假想模型，然后利用这些模型预测未来会发生什么的能力。控制多巴胺在这些过程中起着很大的作用。</p>
<p>理性决定是不可靠的，总是随着新证据的出现而随时可能被修改。非理性则更持久，欲望多巴胺和当下分子通路都可以被用来引导人们做出非理性的决定。最有效的工具是恐惧、欲望和同情。 不论是哪种政治倾向的人，他们在感受到威胁时都会变得更加保守。一瓶洗手液能唤醒人对于病毒的恐惧。研究进化对人类行为影响的心理学家格伦·D. 威尔逊（Glenn D. Wilson）教授开玩笑说，在选举季节，厕所里张贴“员工必须洗手才能重返工作岗位”的标志就是在给共和党打广告。</p>
<p>保守主义者倾向于关注较小的群体，比如个人、家庭和国家，而自由主义者则更倾向于关注更大的群体：由所有人组成的全球社区。</p>
<p>把贫困移民拒之门外让人想起了爱因斯坦的那句话：“我对社会正义和社会责任充满热情，但我与其他人直接接触时却表现冷淡，这实在是一种奇怪的对比。”保守派似乎恰恰相反。他们想把非法移民排除在这个国家之外，以防止他们担心的事情发生，即他们的文化发生根本性转变。然而，伤害厌恶会促使他们愿意去照顾住在本国的人。</p>
<p>政治是一种多巴胺能的活动，因为政府是通过抽象的法律从远处管理人民的。由当下回路控制的暴力为法律树立威信。由于政府的本性就是多巴胺能的，自由主义者往往比专注于当下的保守主义者更热衷于此。相比之下，保守主义者更容易不信任政府，特别是距离较远的政府。保守派倾向于地方治理，权力在州或地方一级，而不是联邦一级。</p>
<h1 id="第六章_进步"><a class="header-anchor" href="#第六章_进步">#</a>第六章 进步</h1>
<p>多巴胺受体 D4 的一种编码基因。D4 基因的一个变体被称为 7R，拥有 7R 变体的人喜欢探求新奇事物。 他们喜欢追求新的体验，因为他们不大能容忍无聊。他们喜欢探索新的地方、想法、食物、毒品和性机会，他们是冒险家。全世界大约 1/5 的人有 7R 等位基因，但各地的差异很大。</p>
<p>经历了漫长征程的南美原住民中，长多巴胺等位基因的比例最高，达到 69%。在迁徙较短距离并定居北美的人中，只有 32% 的人拥有长等位基因。中美洲原住民的比例介于它们之间，为 42%。据估计，平均每迁移 1 000 英里，长等位基因的比例就会增加 4.3 个百分点。确定了 DRD4 基因的 7R 等位基因与种群迁移的距离有关以后，下一个问题就是为什么迁徙成员中的 7R 等位基因更多？答案是，也许 7R 等位基因并没有引发迁移，但一旦迁移开始，这一等位基因就会赋予携带者生存优势。7R 等位基因的一个优点是，它会让你不断探索新环境，以便寻找机会来使资源最大化。换句话说，它促进了对新事物的探索。不断前进的部落会一代又一代地经历陌生的环境。7R 的生殖优势将继续下去，7R 携带者将活得更长，生育更多的孩子。随着时间的推移，7R 等位基因在这些长途迁移者中会变得越来越普遍。</p>
<p>双相情感障碍中的双相又称两极（bipolar），是指两种极端的情绪。双相情感障碍患者会经历抑郁发作，即情绪异常低落，也会经历躁狂发作，即情绪过于高昂。后者与高水平的多巴胺有关，考虑到躁狂状态的症状，这一点儿也不奇怪。<br>
在舞蹈、表演、音乐和写作等创造性领域工作的人与没有从事创造性工作的人相比，患双相情感障碍的可能性高出 25%。在另一项研究中，格拉斯哥大学的科学家跟踪了 1 800 多名 8 岁到 20 岁出头的人。他们发现，8 岁时的智商分数越高，23 岁或之前患双相情感障碍的风险就越大。<br>
与普通大脑相比，聪明的大脑患多巴胺能精神疾病的风险更大。许多著名的有创造力的人都透露他们患有双相情感障碍。</p>
<p>多巴胺过度活动并不是双相情感障碍的唯一问题，但它起着重要的作用。它不是由高活性 DRD4 受体等位基因引起的。科学家认为这是由多巴胺转运体引起的。多巴胺转运体就像吸尘器，它可以限制多巴胺刺激周围细胞的时间。<br>
当一个能产生多巴胺的细胞被激活时，它会释放出它储存的多巴胺，后者与其他脑细胞的受体结合。之后，多巴胺转运体会将多巴胺吸回原来的细胞中，结束与受体的相互作用，以便后续再重复这一过程。这种转运体有时被称为“再摄取泵”，因为它将多巴胺重新泵入细胞。<br>
当转运体不能正常工作时会发生什么？我们可以通过研究滥用可卡因的人的行为来回答这个问题。可卡因会阻滞多巴胺转运体，就像把袜子塞进吸尘器吸嘴一样。这种阻滞作用使多巴胺能够一次又一次地与其受体相互作用。当这种情况发生时，人们会感受到更多的能量，也会有更多目标导向的活动和更强的性冲动。人的自尊和兴奋感得到提升，喜欢从一个话题跳到另一个话题。可卡因中毒与躁狂症十分相似，有时医生都难以区分。</p>
<p>高多巴胺能的科学家为高多巴胺能的统治者制造了末日武器。科学家无法阻止自己制造出更加致命的武器，独裁者也无法阻止自己对权力的贪欲。<br>
另一个容易想象到的世界末日场景是多巴胺驱使我们消耗越来越多的资源，直到我们毁灭地球<br>
着眼于未来的多巴胺让人不再生孩子，因为生活在发达国家的人在年老时不依赖孩子来抚养他们。</p>
<h1 id="第七章_和谐"><a class="header-anchor" href="#第七章_和谐">#</a>第七章 和谐</h1>
<p>现代世界驱使我们向着每时每刻全是多巴胺的状态发展。过多的多巴胺会导致精力旺盛的痛苦（如工作狂式的主管），而过多的当下神经递质则会导致快乐的懒惰（如躺在地下室抽大麻的人）。</p>
<p>从多巴胺的角度来看，精通是一件值得期待和追求的好事，但它不同于其他好事。它不仅仅是寻找食物和新的合作伙伴，或者击败竞争对手，它比这些更宏大、更普遍。它是我们成功提取奖励的过程：多巴胺达到了多巴胺的目标。实现了精通，多巴胺到达了它渴望的顶峰——挤压了所有可用资源的最后一滴。<br>
在尽其所能之后，多巴胺会暂停下来，允许当下分子在我们的快乐回路中发挥作用。在这一刻，多巴胺不再对抗满足感，它让它通行——即使只持续很短的一段时间。最好的享受就是沉浸在一份干得好的工作中。</p>
<p>关注现实，关注你此刻所做的事情，可以使进入你大脑的信息流最大化。它能最大限度地提高多巴胺制订新计划的能力，因为为了建立模型以准确地预测未来，多巴胺需要数据，以及来自感官的数据流。这时，多巴胺和当下分子就联手工作了。</p>
]]></content>
      <tags>
        <tag>心理</tag>
        <tag>自然科学</tag>
        <tag>科普</tag>
      </tags>
  </entry>
  <entry>
    <title>《Unix 编程艺术》笔记汇总</title>
    <url>/unix_bian_cheng_yi_shu/</url>
    <content><![CDATA[<h1 id="Part_1_Context"><a class="header-anchor" href="#Part_1_Context">#</a>Part 1 Context</h1>
<p><a href="/di_1_zhang_zhe_xue">第 1 章 哲学</a><br>
<a href="/di_2_zhang_li_shi%E2%80%94%E2%80%94shuang_liu_ji">第 2 章 历史——双流记</a><br>
<a href="/di_3_zhang_dui_bi%EF%BC%9Aunix_zhe_xue_tong_qi_ta_zhe_xue_de_bi_jiao">第 3 章 对比：Unix 哲学同其他哲学的比较</a></p>
<h1 id="Part_2_Design"><a class="header-anchor" href="#Part_2_Design">#</a>Part 2 Design</h1>
<p><a href="/di_4_zhang_mo_kuai_xing%EF%BC%9Abao_chi_qing_xi%EF%BC%8Cbao_chi_jian_jie">第 4 章 模块性：保持清晰，保持简洁</a><br>
<a href="/di_5_zhang_wen_ben_hua%EF%BC%9Ahao_xie_yi_chan_sheng_hao_shi_jian">第 5 章 文本化：好协议产生好实践</a><br>
<a href="/di_6_zhang_tou_ming_xing%EF%BC%9Alai_dian_er_guang">第 6 章 透明性：来点儿光</a><br>
<a href="/di_7_zhang_duo_dao_cheng_xu_she_ji%EF%BC%9Afen_li_jin_cheng_wei_du_li_de_gong_neng">第 7 章 多道程序设计：分离进程为独立的功能</a>A<br>
<a href="/di_8_zhang_wei_xing_yu_yan%EF%BC%9Axun_zhao_ge_chang_de_le_fu">第 8 章 微型语言：寻找歌唱的乐符</a><br>
<a href="/di_9_zhang_sheng_cheng%EF%BC%9Ati_sheng_gui_ge_shuo_ming_de_ceng_ci">第 9 章 生成：提升规格说明的层次</a><br>
<a href="/di_10_zhang_pei_zhi%EF%BC%9Amai_chu_zheng_que_de_di_yi_bu">第 10 章 配置：迈出正确的第一步</a><br>
<a href="/di_11_zhang_jie_kou%EF%BC%9Aunix_huan_jing_xia_de_yong_hu_jie_kou_she_ji_mo_shi">第 11 章 接口：Unix 环境下的用户接口设计模式</a><br>
<a href="/di_12_zhang_you_hua">第 12 章 优化</a><br>
<a href="/di_13_zhang_fu_za_du%EF%BC%9Ajin_ke_neng_jian_dan%EF%BC%8Cdan_bie_jian_dan_guo_le_tou">第 13 章 复杂度：尽可能简单，但别简单过了头</a></p>
<h1 id="Part_3_Implementation"><a class="header-anchor" href="#Part_3_Implementation">#</a>Part 3 Implementation</h1>
<p><a href="/di_14_zhang_yu_yan%EF%BC%9Ac_hai_shi_fei_c">第 14 章 语言：C 还是非 C</a><br>
<a href="/di_15_zhang_gong_ju%EF%BC%9Akai_fa_de_zhan_shu">第 15 章 工具：开发的战术</a><br>
<a href="/di_16_zhang_zhong_yong%EF%BC%9Alun_bu_yao_zhong_xin_fa_ming_lun_zi">第 16 章 重用：论不要重新发明轮子</a></p>
<h1 id="Part_3_Community"><a class="header-anchor" href="#Part_3_Community">#</a>Part 3 Community</h1>
<p><a href="/di_17_zhang_ke_yi_zhi_xing%EF%BC%9Aruan_jian_ke_yi_zhi_xing_yu_zun_xun_biao_zhun">第 17 章 可移植性：软件可移植性与遵循标准</a><br>
<a href="/di_18_zhang_wen_dang%EF%BC%9Axiang_wang_luo_shi_jie_chan_shi_dai_ma">第 18 章 文档：向网络世界阐释代码</a><br>
<a href="/di_19_zhang_kai_fang_yuan_ma%EF%BC%9Azai_unix_xin_she_qu_zhong_bian_cheng">第 19 章 开放源码：在 Unix 新社区中编程</a><br>
<a href="/di_20_zhang_wei_lai%EF%BC%9Awei_ji_yu_ji_yu">第 20 章 未来：危机与机遇</a></p>
]]></content>
      <tags>
        <tag>系统设计</tag>
        <tag>编码规范</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows Package Manager（winget）使用指南</title>
    <url>/windows_package_manager/</url>
    <content><![CDATA[<h1 id="介绍"><a class="header-anchor" href="#介绍">#</a>介绍</h1>
<p>Windows Package Manager （winget） 是微软推出的基于命令行的包管理器，类似于 Chocolatey。</p>
<div class="note info simple"><p>Package Manager 所管理的 Package，实际指应用（application / program）</p>
</div>
<p>理想情况下，开发人员使用 Package Manager 来指定开发所需的环境，Package 按照来说明安装和配置工具。Package Manager 可以减少准备环境所花费的时间，并且有助于确保在计算机上安装相同版本的包。</p>
<div class="note info simple"><p>下部分基于 winget 版本 1.6.2771。<br>
部分 Windows 安装时自带 winget 1.2 版本，在实际使用时会遇到各种问题。</p>
</div>
<h1 id="安装"><a class="header-anchor" href="#安装">#</a>安装</h1>
<p>可以通过在 Win Store 上安装 <code>App Installer</code> 来安装 winget。也可以通过命令行直接安装：</p>
<figure class="highlight pwsh"><table><tr><td class="code"><pre><span class="line"><span class="variable">$progressPreference</span> = <span class="string">&#x27;Continue&#x27;</span></span><br><span class="line"><span class="built_in">Write-Information</span> <span class="string">&quot;Downloading WinGet and its dependencies...&quot;</span></span><br><span class="line"><span class="built_in">Invoke-WebRequest</span> <span class="literal">-Uri</span> https://aka.ms/getwinget <span class="literal">-OutFile</span> Microsoft.DesktopAppInstaller_8wekyb3d8bbwe.msixbundle</span><br><span class="line"><span class="built_in">Invoke-WebRequest</span> <span class="literal">-Uri</span> https://aka.ms/Microsoft.VCLibs.x64.<span class="number">14.00</span>.Desktop.appx <span class="literal">-OutFile</span> Microsoft.VCLibs.x64.<span class="number">14.00</span>.Desktop.appx</span><br><span class="line"><span class="built_in">Invoke-WebRequest</span> <span class="literal">-Uri</span> https://github.com/microsoft/microsoft<span class="literal">-ui-xaml</span>/releases/download/v2.<span class="number">7.3</span>/Microsoft.UI.Xaml.<span class="number">2.7</span>.x64.appx <span class="literal">-OutFile</span> Microsoft.UI.Xaml.<span class="number">2.7</span>.x64.appx</span><br><span class="line"><span class="built_in">Add-AppxPackage</span> Microsoft.VCLibs.x64.<span class="number">14.00</span>.Desktop.appx</span><br><span class="line"><span class="built_in">Add-AppxPackage</span> Microsoft.UI.Xaml.<span class="number">2.7</span>.x64.appx</span><br><span class="line"><span class="built_in">Add-AppxPackage</span> Microsoft.DesktopAppInstaller_8wekyb3d8bbwe.msixbundle</span><br></pre></td></tr></table></figure>
<div class="note info simple"><p>在 Windows Sandbox 中不存在 Windows Store，因此只能使用命令行进行安装</p>
</div>
<h1 id="命令"><a class="header-anchor" href="#命令">#</a>命令</h1>
<h2 id="Search"><a class="header-anchor" href="#Search">#</a>Search</h2>
<p>使用 <code>search</code> 命令进行搜索：</p>
<figure class="highlight pwsh"><table><tr><td class="code"><pre><span class="line">winget search &lt;packageName&gt;</span><br><span class="line">winget search powershell</span><br></pre></td></tr></table></figure>
<p>示例和结果如下：<br>
<img src="/windows_package_manager/image-20231102213901.png" alt="winget search powershell"></p>
<div class="note info simple"><p>开源项目 <a href="https://github.com/winget-run/wingetdotrun">winget-run</a> （非微软维护），提供了在网页中搜索 winget 支持的 Package 的功能：</p>
</div>
<h2 id="Install"><a class="header-anchor" href="#Install">#</a>Install</h2>
<p>可以使用 <code>install</code> 安装应用，推荐使用 Search 结果中的 ID 来进行安装以避免冲突：</p>
<figure class="highlight pwsh"><table><tr><td class="code"><pre><span class="line">winget install &lt;Package ID&gt;</span><br><span class="line">// winget install Microsoft.PowerShell</span><br></pre></td></tr></table></figure>
<p>可以通过 <code>;</code> 风格多个安装命令，如：</p>
<figure class="highlight pwsh"><table><tr><td class="code"><pre><span class="line">winget install Microsoft.AzureStorageExplorer; winget install Microsoft.VisualStudioCode;  winget install Microsoft.AzureCLI</span><br></pre></td></tr></table></figure>
<p>可以使用 <code>-v</code> 约定安装的版本，未指定的情况下将安装最新版本。</p>
<p>可以使用 <code>-h</code> 或 <code>--slient</code> 保证以静默方式安装。</p>
<div class="note warning simple"><p>如果使用了静默安装，但安装要求管理员权限且当前命令行又不具有，则可能出现错误。<br>
因此建议在使用静默安装时，使用管理员权限打开命令行</p>
</div>
<h2 id="Uninstall"><a class="header-anchor" href="#Uninstall">#</a>Uninstall</h2>
<p>使用 <code>uninstall</code> 卸载应用：</p>
<figure class="highlight pwsh"><table><tr><td class="code"><pre><span class="line">winget uninstall &lt;Package ID&gt;</span><br><span class="line">// winget uninstall Microsoft.PowerShell</span><br></pre></td></tr></table></figure>
<p>可以使用 <code>-h</code> 或 <code>--slient</code> 保证以静默方式安装。</p>
<h2 id="Upgrade"><a class="header-anchor" href="#Upgrade">#</a>Upgrade</h2>
<p>可以使用 <code>upgrade</code> 命令列出系统内所以可以通过 <code>winget</code> 进行升级的应用：<br>
<img src="/windows_package_manager/image-20231102220234.png" alt="winget upgrade"></p>
<p>同样使用 <code>upgrade</code> 命令进行升级：</p>
<figure class="highlight pwsh"><table><tr><td class="code"><pre><span class="line">winget upgrade &lt;Package ID&gt;</span><br><span class="line">// winget upgrade microsoft.powertoys</span><br><span class="line"></span><br><span class="line">winget upgrade &lt;Package ID&gt; <span class="literal">-v</span> &lt;version&gt; // 升级到特定的版本</span><br><span class="line">// winget upgrade microsoft.powertoys <span class="literal">-v</span> <span class="number">0.41</span>.<span class="number">3</span></span><br><span class="line"></span><br><span class="line">winget upgrade <span class="literal">--all</span> // 升级所有应用</span><br></pre></td></tr></table></figure>
<h2 id="Export"><a class="header-anchor" href="#Export">#</a>Export</h2>
<p>可以使用 <code>export</code> 命令将本机安装的 Package 导出成 <code>json</code> 文件，加上 <code>--include-versions</code> 表示导出时需要包括版本。：</p>
<figure class="highlight pwsh"><table><tr><td class="code"><pre><span class="line">winget export <span class="literal">-o</span> &lt;OutputPath&gt; <span class="literal">--include-versions</span></span><br></pre></td></tr></table></figure>
<p>输出的 Json 如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;$schema&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://aka.ms/winget-packages.schema.2.0.json&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;CreationDate&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2023-11-05T11:37:19.847-00:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Sources&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Packages&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;PackageIdentifier&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Notion.Notion&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;Version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.2.4&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;PackageIdentifier&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Anki.Anki&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;Version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.1.66&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;SourceDetails&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;Argument&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://cdn.winget.microsoft.com/cache&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;Identifier&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Microsoft.Winget.Source_8wekyb3d8bbwe&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;winget&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;Type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Microsoft.PreIndexed.Package&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;WinGetVersion&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.6.2771&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="Import"><a class="header-anchor" href="#Import">#</a>Import</h2>
<p>可以使用 <code>import</code> 命令将通过 <a href="/windows_package_manager/#Export">Export</a> 导出的 Package 进行安装。</p>
<figure class="highlight pwsh"><table><tr><td class="code"><pre><span class="line">winget import <span class="literal">-i</span> &lt;JsonPath&gt; <span class="literal">--ignore-versions</span> <span class="literal">--ignore-unavailable</span></span><br></pre></td></tr></table></figure>
<p>在 <a href="/windows_package_manager/#Export">Export</a> 导出的文件中，很可能会出现版本已经不匹配或者其他无法安装的情况，因此建议加上 <code>--ignore-unavailable</code> 跳过无法安装的部分，避免阻塞整个流程。</p>
<h1 id="winget_Repository"><a class="header-anchor" href="#winget_Repository">#</a>winget Repository</h1>
<p>winget 默认应用的安装来源是 <a href="https://github.com/microsoft/winget-pkgs">Windows Package Manager Community Repository</a>。这是一个开源的项目，在项目的 <code>manifests</code> 文件夹下，按名称分类了每一个社区中提供的 Package。</p>
<p>以 PowerShell 为例子，在仓库中，<code>7.3.0</code> 版本对应的 Manifest 文件为 <a href="https://github.com/microsoft/winget-pkgs/blob/master/manifests/m/Microsoft/PowerShell/7.3.2.0/Microsoft.PowerShell.installer.yaml">https://github.com/microsoft/winget-pkgs/blob/master/manifests/m/Microsoft/PowerShell/7.3.2.0/Microsoft.PowerShell.installer.yaml</a>。</p>
<p>文件中最重要的就是 <code>Installer</code>，如其中这一段表示了 <code>x64</code> 结构的安装路径：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Installers:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">Architecture:</span> <span class="string">x64</span></span><br><span class="line">  <span class="attr">InstallerType:</span> <span class="string">wix</span></span><br><span class="line">  <span class="attr">InstallerUrl:</span> <span class="string">https://github.com/PowerShell/PowerShell/releases/download/v7.3.2/PowerShell-7.3.2-win-x64.msi</span></span><br><span class="line">  <span class="attr">InstallerSha256:</span> <span class="string">A4F7D081C5F74BC8D6C75F1DFEE382B7FD9335361181748FEE590ECDBC96CB26</span></span><br></pre></td></tr></table></figure>
<h2 id="在社区中发布_Package"><a class="header-anchor" href="#在社区中发布_Package">#</a>在社区中发布 Package</h2>
<p>Microsoft Learn：<a href="https://learn.microsoft.com/en-us/training/modules/explore-windows-package-manager-tool/6-contribute-to-repository">Contribute to the Windows Package Manager repository - Training | Microsoft Learn</a></p>
<p>Documentation： <a href="https://learn.microsoft.com/en-us/windows/package-manager/package/repository">Submit your manifest to the repository | Microsoft Learn</a></p>
<h1 id="Reference"><a class="header-anchor" href="#Reference">#</a>Reference</h1>
<p><a href="https://learn.microsoft.com/en-us/training/modules/explore-windows-package-manager-tool/">Explore the Windows Package Manager tool - Training | Microsoft Learn</a></p>
<p><a href="https://learn.microsoft.com/en-us/windows/package-manager/">Windows Package Manager | Microsoft Learn</a></p>
]]></content>
      <tags>
        <tag>Windows</tag>
        <tag>CLI</tag>
      </tags>
  </entry>
  <entry>
    <title>猪小兵的故事</title>
    <url>/zhu_xiao_bing_de_gu_shi/</url>
    <content><![CDATA[<p>程序员为什么会重新发明轮子？原因很多，从狭隘的技术原因到程序员心理状态，再到软件生产系统的经济学，方方面面都会导致如此行为，这种特有的顽疾正在蔓延。</p>
<p>猪小兵是个刚走出大学的程序员，拿到了第一份正式工作，让我们假设他或她已经知道了代码重用的价值并且满怀青春的准备大干一把。</p>
<p>小兵的第一个项目是随团队编制一个大型应用。为了实例说明的方便，让我们认为那是一个帮助终端用户能够智能构造查询和浏览庞大数据库的 GUI。项目经理已经组合了他们认为适合的工具和组件集，不仅包括开发语言，也包括许多程序库。</p>
<p>那些程序库对于项目来说至关重要。它们包装了许多服务–下到窗口构件和网络连接，上至诸如交互帮助的整个子系统–否则需要特别大量的额外编码，会严重影响工作预算和发布时间。</p>
<p>小兵有些担心发布时间。他或许缺乏经验，但他知道管理上有个趋势，说得好听点，进度上比较&quot;积极&quot;。</p>
<p>一切要比他想的费时和痛苦。在程序库表面光鲜的示例程序下，正在重用的组件似乎在一些边界情况下表现得无法预料或具有破坏性—而这些边界情况在他的代码中常常遇到。小兵经常奇怪写程序库的家伙究竟是怎么想的。但他没法知道，因为组件的文档不全–那些文档是技术文员写的，他们既不是程序员，想问题的方式也不像程序员。他也不能通过阅读源码来了解程序库究竟是干什么的，因为程序库是处于专有许可证下不透明的目标码。</p>
<p>小兵不得不为组件问题不断的编写复杂的迂回代码，使用程序库已经到了得不偿失的地步。迂回方法使得他的代码越变越糟。他碰到了程序库的软肋，库无法简单的像其规格说明那样完成某些至关重要的任务。有时他也确信肯定有某种方法可以让这个黑盒子跑起来，但却无法断定究竟是什么方法。</p>
<p>小兵发现，随着在程序库上花费的精力越多，他的调试时间就越成指数级的上升。代码处于崩溃和内存泄露的痛苦之中，追下来又往往发觉祸根就是那个程序库，或者是某些他无法查看和修改的代码。小兵知道再追也许会追回自己的代码，但是没有源代码，就算想追回到自己的代码也是不可能的。</p>
<p>项目进度在变缓，梦想成为架构师的小兵发现，自己简直成了砖瓦匠，正在试图用堆不起的砖盖房，而且压力一大就会塌掉。而经理并不想听到新手的借口，大声的抱怨组件质量太差，那些选择组件的经理和高级人员之间肯定会找他的麻烦。而且即使能够成功说服他们，改换组件也将是一个复杂的提议。</p>
<p>除非小兵非常，非常幸运，他不可能在项目的有生之年修正程序库的 bug。在清醒的时候，他也意识到库里面也有许多能工作的代码，他太注意那些 bug 和疏漏了。他很愿意能够坐下来同组件的开发者好好谈谈，他们又不是白痴，从他们的代码能看出来，他们一样是程序员，也工作在一个令人受挫的系统中。但是小兵甚至不知道他们是谁—而且即使能知道，他们就职的软件商也多半不会让他们同他讨论这个问题。</p>
<p>绝望中，小兵开始打造自己的砖块—用较稳定的库模拟不太稳定的库，并且开始从零编写自己的实现。用来置换的代码是他自己的，思维模式他一清二楚，并且能够反复阅读，更新认识，比起被替代的不透明组件和迂回方法所混合的代码，往往工作的相对更好也更容易调试。</p>
<p>小兵学到一个教训：越少用别人的代码，他的代码产量越高。这个经验满足了他的自尊。像其他所有年轻的程序员一样，在思想深处都觉得自己比别人聪明。他的经历也似乎在表面上证明了这一点。所以小兵开始构建属于自己的工具包，一个自己用起来更顺手的工具包。</p>
<p>不幸的是，小兵此时获得的自己动手的习惯性思维，是一个短期的局部优化，会引发长期的问题。他或许可以编写更多行的代码，但是如果不能重用，这些代码产生的实际价值很可能会相当大幅度的降低。代码多并不等于代码好，至少在编写低层次代码和大量重复投入时是如此。</p>
<p>在换工作时，小兵至少还得准备经历一个挫折。他很可能发现带不走他的工具包。如果他带着在公司编写的代码走出公司大门，其旧雇主就有理由认为他侵犯了知识产权。如果承认重用了旧代码，新雇主如果知道了，也大有可能很不爽。</p>
<p>即使小兵能够偷偷摸摸的在新工作中使用原先的代码，他也会发现自己的工具包用处不大。新雇主也许使用一套不同的专有工具，语言和程序库。极有可能的是，在每个新项目中，小兵都不得不学习一个稍微新一点的技术并重新发明一套轮子。</p>
<p>这样，程序员重用代码便是技术问题，知识产权壁垒，行政问题以及个人自我意识的综合。成千上万的小兵们年复一年的随着年龄的增长，变得越来越愤世嫉俗，也越来越习惯那种系统。对于多数软件行业的现状，这就是巨大的时间，资本和人力资源浪费。</p>
<p>小兵经历反映的职业文化可以折射出大部分的情况。软件公司有种&quot;非自己做不可&quot;的强烈情节。他们对于代码重用是矛盾复杂的，一方面为了赶进度逼迫程序员使用功能不足但很有市场的商业组件，同时又拒绝重用程序员自己经过良好测试的代码。这些软件公司费力生产的是大量专用重复的软件，其实编制软件的程序员知道结果会是垃圾，但除了自己的代码，别的哪也动不了。</p>
<p>代码好不容易写出来了就决不能扔，只有不断修修补补，即使所有的人都知道扔掉重写会更好些，这个教条，就是在这种文化里形成的最接近代码重用的对等物。这种文化产生的产品，即使其中涉及的每位人员都尽最大努力最好工作，随着时间的推移，写出的程序还是会变得越来越臃肿，bug 也越来越多。</p>
]]></content>
      <tags>
        <tag>系统设计</tag>
      </tags>
  </entry>
  <entry>
    <title>《You and Your Research》 摘抄</title>
    <url>/you_and_your_research/</url>
    <content><![CDATA[<p>这篇摘抄来源于对 <em>理查德·卫斯理·汉明（Richard Wesley Hamming）</em> 在 1986 年 3 月 7 日 的名为 <code>You and Your Research</code> 演讲的转录。</p>
<div class="note info simple"><p>Hamming，1968 年图灵机获得者，信息论中 <a href="https://en.wikipedia.org/wiki/Hamming_distance">Hamming Distance</a> 理论主要贡献者</p>
</div>
<p>该演讲主要聚焦在 Hamming 对 “为什么只有极少数的科学家做出了伟大的贡献，而绝大部分科学家却在时间的长流中被遗忘” 这一问题的观察和研究。</p>
<div class="note info simple"><p>以下内容是对演讲转录的摘抄，完整的演讲内容见 <a href="https://www.cs.virginia.edu/~robins/YouAndYourResearch.html">You and Your Research</a></p>
</div>
<div class="note info simple"><p>摘抄的内容并非逐字的对原文进行翻译，为保证阅读流畅，可能会更改/增删一些表达，但尽可能的保证表达的含义相同。</p>
</div>
<div class="note info simple"><p>以下摘抄中为 Hamming 的第一人称。</p>
</div>
<h1 id="The_Talk"><a class="header-anchor" href="#The_Talk">#</a>The Talk</h1>
<blockquote>
<p>I saw I was a stooge. I saw that although physically I was the same, they were different. And to put the thing bluntly, I was envious.<br>
…<br>
I continued examining the questions, Why? and What is the difference?‘’ I continued subsequently by reading biographies, autobiographies, asking people questions such as: ``How did you come to do this?‘’ I tried to find out what are the differences. And that’s what this talk is about.</p>
</blockquote>
<p>我在刚加入贝尔实验室时，面对费曼，香农，汉斯等科学家时，深感到自己与他们的差异，并对他们的能力和高效感到羡慕。为了探索出他们与自己不同的原因，我阅读了传记，自传以及对他们进行了采访。这些探索过程和结果便是这个演讲的内容。</p>
<blockquote>
<p>Now, why is this talk important? I think it is important because, as far as I know, each of you has one life to live. Even if you believe in reincarnation it doesn’t do you any good from one life to the next! Why shouldn’t you do significant things in this one life<br>
…<br>
I will talk mainly about science because that is what I have studied.<br>
…<br>
Outstanding work is characterized very much the same way in most fields, but I will confine myself to science.</p>
</blockquote>
<p>为什么这个话题很重要，因为人只会活一次，即便你相信来世，也没关系，为何不在今生就做一些伟大的事呢？</p>
<p>我将会主要通过科学领域的观察来回答这个话题，但这个话题同样适用于其他的领域。</p>
<blockquote>
<p>I have to get you to drop modesty and say to yourself, ``Yes, I would like to do first-class work.‘’ Our society frowns on people who set out to do really good work. You’re not supposed to; luck is supposed to descend on you and you do great things by chance.</p>
</blockquote>
<h2 id="关于运气"><a class="header-anchor" href="#关于运气">#</a>关于运气</h2>
<blockquote>
<p>In order to get at you individually, I must talk in the first person. I have to get you to drop modesty and say to yourself, ``Yes, I would like to do first-class work.‘’ Our society frowns on people who set out to do really good work. You’re not supposed to; luck is supposed to descend on you and you do great things by chance.</p>
</blockquote>
<p>你应该放弃谦逊，并对自己说 “是的，我想做一流的工作”。我们的社会风气并不赞赏那些努力去做伟大事业的人，它期望的是某人做出了伟大的工作，是因为这个人踩了狗屎运。</p>
<blockquote>
<p>I find that the major objection is that people think great science is done by luck. It’s all a matter of luck. Well, consider Einstein. Note how many different things he did that were good. Was it all luck?</p>
</blockquote>
<p>我发现科学研究最大的阻碍在于人们认为伟大的科学是靠运气完成的，认为所有科学研究都是运气问题。但你想下爱因斯坦，想下他做了多少伟大的工作，难道所有这些伟大工作都是因为爱因斯坦运气好吗？</p>
<blockquote>
<p>You see again and again, that it is more than one thing from a good person<br>
…<br>
I claim that luck will not cover everything. And I will cite Pasteur who said, ``Luck favors the prepared mind.‘’<br>
…<br>
The prepared mind sooner or later finds something important and does it. So yes, it is luck. The particular thing you do is luck, but that you do something is not.</p>
</blockquote>
<p>你会一次又一次看到，一个优秀的人并不是仅仅有一个成就。Pasteur 说 “好运偏爱有准备的人”，那些有准备的人或早或晚都会发现一个重要的事情并去完成它。</p>
<blockquote>
<p>I want to dispose of this matter of luck as being the sole criterion whether you do great work or not. I claim you have some, but not total, control over it.<br>
…<br>
Newton said, ``If others would think as hard as I did, then they would get similar results.‘’</p>
</blockquote>
<p>我反对的是将运气作为你是否能做伟大工作的唯一标准。针对于“运气”，你对它是存在一些控制权的，就像牛顿所言“如果其他人像我一样思考，他们就会得到和我相似结果。”</p>
<h2 id="关于勇气"><a class="header-anchor" href="#关于勇气">#</a>关于勇气</h2>
<blockquote>
<p>Bill Pfann, the fellow who did zone melting, came into my office one day. He had this idea dimly in his mind about what he wanted and he had some equations. … but ultimately he has collected all the prizes in the field. Once he got well started, his shyness, his awkwardness, his inarticulateness, fell away and he became much more productive in many other ways. Certainly he became much more articulate.</p>
</blockquote>
<blockquote>
<p>A fellow named Clogston…I didn’t think he had much…Well I would have fired the fellow…Clogston finally did the Clogston cable. After that there was a steady stream of good ideas. One success brought him confidence and courage.</p>
</blockquote>
<p>Bill Pfann 一开始在他们部门的认可微乎其微，但他最后获得了他领域的所有奖项。他开始获奖后，他的害羞，他的尴尬，他的口吃都消失了。他在许多领域都变得更加高效，他也变得更加善于表达。</p>
<p>我的一个叫做 Clogston 的同事，我觉得他并没有太多的才华，甚至于我曾想要开除他。但他最终做出了以他命名的电缆，一次的成功给他带来了自信和勇气。</p>
<blockquote>
<p>One of the characteristics of successful scientists is having courage. Once you get your courage up and believe that you can do important problems, then you can. If you think you can’t, almost surely you are not going to.<br>
That is the characteristic of great scientists; they have courage. They will go forward under incredible circumstances; they think and continue to think.</p>
</blockquote>
<p>成功科学家的一大品质就是拥有勇气，一旦你鼓起勇气并相信你能解决重要的问题，那你就能成功。而如果你认为自己做不到，那大概率你确实无法做到。</p>
<p>伟大科学家的勇气，让他们即使在几乎不可能的情况下，仍然能思考，仍然能继续思考。</p>
<h2 id="关于年龄"><a class="header-anchor" href="#关于年龄">#</a>关于年龄</h2>
<blockquote>
<p>Age is another factor which the physicists particularly worry about. They always are saying that you have got to do it when you are young or you will never do it. Einstein did things very early, and all the quantum mechanic fellows were disgustingly young when they did their best work. Most mathematicians, theoretical physicists, and astrophysicists do what we consider their best work when they are young. It is not that they don’t do good work in their old age but what we value most is often what they did early. On the other hand, in music, politics and literature, often what we consider their best work was done late. I don’t know how whatever field you are in fits this scale, but age has some effect.</p>
</blockquote>
<p>年龄是物理学家常常担心的问题。物理学家总是说，伟大的成就要么在你年轻时得到，要么就永远得不到。爱因斯坦在他非常年轻的时候取得了成就，所有的量子力学研究员也都在他们非常年轻的时候完成了我们认为最好的工作。大多数数学家，理论物理学家，天体物理学家也是这样，这并不是说他们在晚年没有做好工作，而是大家觉得最有价值的往往是他们年轻时的工作。但另一方面，音乐，政治，文学方面的人，我们认为他们最好的作品却往往在他们晚年时产出。总之年龄确实会有一些影响。</p>
<blockquote>
<p>But let me say why age seems to have the effect it does. In the first place if you do some good work you will find yourself on all kinds of committees and unable to do any more work.<br>
The third one, Brattain, practically with tears in his eyes, said, I know about this Nobel-Prize effect and I am not going to let it affect me; I am going to remain good old Walter Brattain.‘’ Well I said to myself, That is nice.‘’ But in a few weeks I saw it was affecting him. Now he could only work on great problems.<br>
When you are famous it is hard to work on small problems. This is what did Shannon in. After information theory, what do you do for an encore? The great scientists often make this error. They fail to continue to plant the little acorns from which the mighty oak trees grow. They try to get the big thing right off. And that isn’t the way things go. So that is another reason why you find that when you get early recognition it seems to sterilize you.</p>
</blockquote>
<p>但我要解释下为何在科学领域，看起来伟大工作都发生在年轻时。这是因为，一旦你做了一些好的工作，你就会发现自己身处各种委员会中，你也就不再能做任何伟大工作了。</p>
<p>Brattain 在诺贝尔奖项宣布的那天，说他不会让诺贝尔奖影响它，但几周后，我看到了诺贝尔奖给他带来的影响，现在他只能解决 <strong>大</strong> 问题了。</p>
<p>当你有名后，你很难解决 <strong>小</strong> 的问题。伟大的科学家经常犯这样的错误，他们不再种植可能会长成<strong>大橡树</strong>的 <strong>小橡子</strong>，，他们试图直接获取<strong>大橡树</strong>，但事情的发展并不是这样的。这也是为什么你会发现，当你获得了早期认可，你就被“绝育”了。</p>
<h2 id="关于工作条件"><a class="header-anchor" href="#关于工作条件">#</a>关于工作条件</h2>
<blockquote>
<p>I think that if you look carefully you will see that often the great scientists, by turning the problem around a bit, changed a defect to an asset. For example, many scientists when they found they couldn’t do a problem finally began to study why not. They then turned it around the other way and said, ``But of course, this is what it is’’ and got an important result. So ideal working conditions are very strange. The ones you want aren’t always the best ones for you.</p>
</blockquote>
<p>如果你仔细观察，你会发现伟大的科学家经常会将缺陷变为资产。比如，许多科学奖当发现他们无法解决一个问题时，他们会开始思考 <em>为什么</em>，并最终以此得到了一个重要的解决方式。所以理想的工作条件很奇怪。你想要的并不总是最适合你的。</p>
<h2 id="关于驱动力"><a class="header-anchor" href="#关于驱动力">#</a>关于驱动力</h2>
<blockquote>
<p>You observe that most great scientists have tremendous drive. I worked for ten years with John Tukey at Bell Labs. He had tremendous drive. One day about three or four years after I joined, I discovered that John Tukey was slightly younger than I was. John was a genius and I clearly was not. Well I went storming into Bode’s office and said, How can anybody my age know as much as John Tukey does?‘’ He leaned back in his chair, put his hands behind his head, grinned slightly, and said, You would be surprised Hamming, how much you would know if you worked as hard as he did that many years.‘’ I simply slunk out of the office!</p>
</blockquote>
<p>大多数伟大的科学家都有巨大的动力。我在贝尔实验室与 John Tukey 一起工作了十年，在我加入贝尔的大约三四年后的一天，我发现约翰·图基甚至比我还年轻一点。约翰是个天才，而我显然不是。有一天我冲进 Bode 的办公室说，“像我这个年纪的人，怎样才能像 John Tukey 一样知道那么多呢？” Bode 靠在椅子上，双手放在脑后，微微一笑，说：“Hamming，如果你像他一样努力工作并坚持多年的话，你就会对你自己的知识积累而感到惊讶。”</p>
<blockquote>
<p>What Bode was saying was this: ``Knowledge and productivity are like compound interest.‘’ Given two people of approximately the same ability and one person who works ten percent more than the other, the latter will more than twice outproduce the former. The more you know, the more you learn; the more you learn, the more you can do; the more you can do, the more the opportunity - it is very much like compound interest. I don’t want to give you a rate, but it is a very high rate. Given two people with exactly the same ability, the one person who manages day in and day out to get in one more hour of thinking will be tremendously more productive over a lifetime. I took Bode’s remark to heart; I spent a good deal more of my time for some years trying to work a bit harder and I found, in fact, I could get more work done. I don’t like to say it in front of my wife, but I did sort of neglect her sometimes; I needed to study. You have to neglect things if you intend to get what you want done. There’s no question about this.</p>
</blockquote>
<p>Bode 说的是：“知识和生产力就像复利。假设两个能力大致相同的人，一个人比另一个人多工作 10%，后者的产量将超过前者的两倍以上。”</p>
<p>你知道的越多，你学到的就越多，你学得越多，你能做的就越多，你能做的越多，机会就越多——这很像复利。</p>
<p>我把 Bode 的话记在心里：几年来，我花了很多时间试图更加努力地工作，事实上，我发现我可以完成更多的工作。我不喜欢在我妻子面前说出来，但有时我确实有点忽视她。我需要学习。如果你打算完成你想要做的事情，你必须忽略一些东西，这没有办法。</p>
<blockquote>
<p>drive, misapplied, doesn’t get you anywhere. I’ve often wondered why so many of my good friends at Bell Labs who worked as hard or harder than I did, didn’t have so much to show for it. The misapplication of effort is a very serious matter. Just hard work is not enough - it must be applied sensibly.</p>
</blockquote>
<p>但误用的驱动力，不会带你走向任何的成功。我经常想，为什么我在贝尔实验室的那么多好朋友，他们和我一样努力或比我更加的努力工作，却没有那么多东西可以展示。滥用努力是一个非常严重的问题。仅仅努力工作是不够的，你必须在正确的方向上努力。</p>
<h2 id="关于接受模棱两可"><a class="header-anchor" href="#关于接受模棱两可">#</a>关于接受模棱两可</h2>
<blockquote>
<p>There’s another trait on the side which I want to talk about; that trait is ambiguity. It took me a while to discover its importance.。 Most people like to believe something is or is not true. Great scientists tolerate ambiguity very well. They believe the theory enough to go ahead; they doubt it enough to notice the errors and faults so they can step forward and create the new replacement theory. If you believe too much you’ll never notice the flaws; if you doubt too much you won’t get started. It requires a lovely balance. But most great scientists are well aware of why their theories are true and they are also well aware of some slight misfits which don’t quite fit and they don’t forget it.</p>
</blockquote>
<p>另一个我花了很长时间才意识到的重要特质是接受模棱两可。大多数人喜欢相信一件事是真的或是假的，但伟大的科学家能忍受模棱两可。一方面他们足够的相信一个理论，这样他们才能继续研究这个理论。另一方面他们又对这个理论存在足够的怀疑，以至于他们能注意到理论的错误，并发展出新的替代性理论。如果你太相信，那么你永远不会注意到缺陷，但如果你怀疑的太多，你就不会出发。相信和怀疑之间需要一个可爱的平衡。</p>
<p>大多数伟大的科学家都很清楚为什么他们的理论是正确的，同时他们也很清楚理论中存在的一些无法说通的点，科学家们也不会忘记这些点。</p>
<blockquote>
<p>Darwin writes in his autobiography that he found it necessary to write down every piece of evidence which appeared to contradict his beliefs because otherwise they would disappear from his mind. When you find apparent flaws you’ve got to be sensitive and keep track of those things, and keep an eye out for how they can be explained or how the theory can be changed to fit them.</p>
</blockquote>
<p>达尔文在他的自传中写道，他发现有必要写下每一个看起来与他的理论不相符合的证据，否则它们就会从他的脑海中消失。当你发现明显的缺陷时，你必须保持敏感并跟踪这些事情，并思考如何解释它们或如何改变理论以适应它们，这些往往会造就伟大的贡献。</p>
<h2 id="关于潜意识"><a class="header-anchor" href="#关于潜意识">#</a>关于潜意识</h2>
<blockquote>
<p>Everybody who has studied creativity is driven finally to saying, ``creativity comes out of your subconscious.‘’ Somehow, suddenly, there it is. It just appears. Well, we know very little about the subconscious; but one thing you are pretty well aware of is that your dreams also come out of your subconscious. And you’re aware your dreams are, to a fair extent, a reworking of the experiences of the day. If you are deeply immersed and committed to a topic, day after day after day, your subconscious has nothing to do but work on your problem.</p>
</blockquote>
<p>每一个研究过创造力的人最终都会说，“创造力来自你的潜意识。不知何故，突然间，它就在那里。它只是出现”。虽然我对潜意识研究甚少，但我知道宛如日有所思夜有所梦一般，如果你日复一日地深深地沉浸在一个话题上，你的潜意识除了解决你的问题之外别无他法。因此，当你遇到一个真正重要的问题时，你不要让其他任何事情成为你关注的焦点——你专注在这个问题上，让你的潜意识保持饥饿，这样它就必须解决你的问题。这样的话，你就可以安然入睡，并在某一个早上免费得到答案。</p>
<h2 id="关于目标"><a class="header-anchor" href="#关于目标">#</a>关于目标</h2>
<blockquote>
<p>If you do not work on an important problem, it’s unlikely you’ll do important work. It’s perfectly obvious. Great scientists have thought through, in a careful way, a number of important problems in their field, and they keep an eye on wondering how to attack them…The average scientist, so far as I can make out, spends almost all his time working on problems which he believes will not be important and he also doesn’t believe that they will lead to important problems.</p>
</blockquote>
<p>如果你不为一个重要的问题工作，你基本不可能做出伟大的成就，这是显而易见的。</p>
<p>我看到的普通科学家，几乎把所有的时间都花在了他们认为不重要的问题上，他也不相信这些问题会引领他们走向别的重要的问题。</p>
<blockquote>
<p>But the average scientist does routine safe work almost all the time and so he (or she) doesn’t produce much. It’s that simple. If you want to do great work, you clearly must work on important problems, and you should have an idea.</p>
</blockquote>
<p>普通的科学家，几乎一直在做例行的舒适区内的工作，所以他们不会有巨大的产出，就这么简单。如果你想要做伟大工作，你显然必须在重要的问题上工作，而且你应该有一个想法知道什么是重要的问题。</p>
<blockquote>
<p>Most great scientists know many important problems. They have something between 10 and 20 important problems for which they are looking for an attack. And when they see a new idea come up, one hears them say ``Well that bears on this problem.‘’ They drop all the other things and get after it.</p>
</blockquote>
<p>大多数科学家知道许多重要的问题，他们会关注着大约 10 到 20 个重要的问题。当他们有一个新想法或看到一个新契机，他们脑海中会出现一个声音“嗯，这个与问题 A 有关”。然后他们就会抛下其他一切，全力投入这个问题。</p>
<blockquote>
<p>The great scientists, when an opportunity opens up, get after it and they pursue it. They drop all other things. They get rid of other things and they get after an idea because they had already thought the thing through. Their minds are prepared; they see the opportunity and they go after it…One of the chief tricks is to live a long time!</p>
</blockquote>
<p>当机会出现时，伟大的科学家们会抓住它并追求它。他们会放弃了其他所有的东西。他们之所以能抛弃其他的一切，而专注于抓住这个机遇，是因为他们已经有过了深刻的思考。他们的思维已经准备好了，只要他们一看到了他们一直等待的机会，他们就会续追逐它。</p>
<p>另外等待机遇的一个窍门就是活得长。</p>
<h2 id="关于开放"><a class="header-anchor" href="#关于开放">#</a>关于开放</h2>
<blockquote>
<p>I notice that if you have the door to your office closed, you get more work done today and tomorrow, and you are more productive than most. But 10 years later somehow you don’t know quite know what problems are worth working on; all the hard work you do is sort of tangential in importance. He who works with the door open gets all kinds of interruptions, but he also occasionally gets clues as to what the world is and what might be important.</p>
</blockquote>
<p>如果你工作时把门关上，你在今天和明天可以更好的完成工作，且你会比大多数人更高效。但 10 年后你或许并不知道什么问题才是真正需要被解决的，所有你认真完成的工作可能与重要性并不相关。</p>
<p>把门打开工作的人，或许会收到各种干扰，但他也会时不时的得到“当前世界什么事情最重要”的线索。</p>
<h2 id="关于抽象工作"><a class="header-anchor" href="#关于抽象工作">#</a>关于抽象工作</h2>
<blockquote>
<p>In the same way, when using the machine up in the attic in the early days, I was solving one problem after another after another; a fair number were successful and there were a few failures. I went home one Friday after finishing a problem, and curiously enough I wasn’t happy; I was depressed. I could see life being a long sequence of one problem after another after another. After quite a while of thinking I decided, ``No, I should be in the mass production of a variable product. I should be concerned with <em>all</em> of next year’s problems, not just the one in front of my face.‘’</p>
</blockquote>
<p>早年间我攻克一个又一个难题，成功的多，失败的少。在一个周五，当我解决完一个问题回家时，我并没有感到快乐，相反我感到沮丧。我感觉的人生就是一个问题接着一个问题，再接着一个问题。在一段时间的思考后，我决定“我应该关心明年所有的问题，而不仅仅是我面前的问题。”</p>
<blockquote>
<p>You should do your job in such a fashion that others can build on top of it, so they will indeed say, ``Yes, I’ve stood on so and so’s shoulders and I saw further.‘’ The essence of science is cumulative. By changing a problem slightly you can often do great work rather than merely good work. Instead of attacking isolated problems, I made the resolution that I would never again solve an isolated problem except as characteristic of a class.</p>
</blockquote>
<p>你应该以“别人可以在我工作的基础上建立其他工作”的方式做的你的工作。科学的本质是积累，所以我下定决心不再解决孤立的问题。</p>
<blockquote>
<p>Now if you are much of a mathematician you know that the effort to generalize often means that the solution is simple. Often by stopping and saying, ``This is the problem he wants but this is characteristic of so and so. Yes, I can attack the whole class with a far superior method than the particular one because I was earlier embedded in needless detail.‘’ The business of abstraction frequently makes things simple. Furthermore, I filed away the methods and prepared for the future problems.</p>
</blockquote>
<p>如果你是一个数学家，你就知道泛化的解决方案往往意味着解决方案是简单的。在数学的工作中，你可能常常会停下工作并意识到“这就是要解决的问题，但这有个特殊点 blablabla。我其实可以以一种更简单的方式完整的解决这类型的所有问题，但因为我过早的陷入了不必要的细节，所以我只做出了一个解决特定问题的复杂答案。”抽象的过程常常让事物变得简单，此外，抽象意味着将方法进行了归档，并为之后的问题做准备。</p>
<blockquote>
<p>you can make a great deal of difference in your final productivity because you can either do it in such a fashion that people can indeed build on what you’ve done, or you can do it in such a fashion that the next person has to essentially duplicate again what you’ve done. It isn’t just a matter of the job, it’s the way you write the report, the way you write the paper, the whole attitude. It’s just as easy to do a broad, general job as one very special case. And it’s much more satisfying and rewarding!</p>
</blockquote>
<p>你选择以“别人可以在我的基础上再接再厉”的方式去工作，也可以以“别人基本上需要再次复制我所做的”的方式去工作，这两者会产生巨大的生产力差异。这不仅仅是你工作的方式，也包含你写报告的方式，写论文的方式。做一个广泛的，通用的解决方案通常比做一个特化问题的解决方案更简单，也通常更令人满意和有帮助。</p>
<h2 id="关于推销自己"><a class="header-anchor" href="#关于推销自己">#</a>关于推销自己</h2>
<blockquote>
<p>it is not sufficient to do a job, you have to sell it. Selling to a scientist is an awkward thing to do. It’s very ugly; you shouldn’t have to do it. The world is supposed to be waiting, and when you do something great, they should rush out and welcome it. But the fact is everyone is busy with their own work. You must present it so well that they will set aside what they are doing, look at what you’ve done, read it, and come back and say, ``Yes, that was good.‘’</p>
</blockquote>
<p>只完成工作是不够的，你还需要推销它。“推销” 对科学家而言是一个尴尬的事，它很烦，你不应该需要做它。当你做出了一些伟大的事情事，这个世界应该立刻欢迎它。但事实上，每个人都因为自己的工作而忙碌，所以只有你推销了你的工作，其他人才会将他们的工作放在一边，并看看你做了什么，然后说“嗯，不错”。</p>
<blockquote>
<p>There are three things you have to do in selling. You have to learn to write clearly and well so that people will read it, you must learn to give reasonably formal talks, and you also must learn to give informal talks. We had a lot of so-called <em>back room scientists.</em> In a conference, they would keep quiet. Three weeks later after a decision was made they filed a report saying why you should do so and so. Well, it was too late. They would not stand up right in the middle of a hot conference, in the middle of activity, and say, We should do this for these reasons. You need to master that form of communication as well as prepared speeches.</p>
</blockquote>
<p>在推销自己时，必须要做好三件事：</p>
<ul>
<li>学会清晰的写作，这样人们才会愿意阅读</li>
<li>学会正式的演讲</li>
<li>学会非正式环境的谈话</li>
</ul>
<p>我们有很多所谓的“幕后科学家”。在会议上，他们会保持沉默。当会议结束的三周后，他们会提交一份报告，说明为什么要这样做。但这样就太晚了，没人会关注到他们。他们不会在激烈的会议中间站起来说 “出于这些原因，我们应该 blablabla”。你必须要需要掌握这种沟通形式以及准备好随时演讲。</p>
<blockquote>
<p>The technical person wants to give a highly limited technical talk. Most of the time the audience wants a broad general talk and wants much more survey and background than the speaker is willing to give. As a result, many talks are ineffective. The speaker names a topic and suddenly plunges into the details he’s solved. Few people in the audience may follow. You should paint a general picture to say why it’s important, and then slowly give a sketch of what was done. Then a larger number of people will say, Yes, Joe has done that,‘’ or Mary has done that; I really see where it is; yes, Mary really gave a good talk; I understand what Mary has done.‘’</p>
</blockquote>
<p>技术人员通常想要做一个非常聚焦，专精的技术演讲，而大多数时候，听众则想要一个广泛的一般性演讲，并且想要更多的调查数据和问题背景。所以，大多数的技术演讲是无效的，演讲者说出一个话题，然后突然进入了细节，听众很难跟上演讲者的思路。你应该给出一个大框架，说明为什么这个问题很重要，然后慢慢勾勒出所作的内容。这样大部分的听众会给出 “是的，Joy 做了一个重要的事”，“Mary 做了一个很好的演讲，我能明白 Mary 做了什么” 这样的评价。</p>
<h2 id="关于聚焦方向"><a class="header-anchor" href="#关于聚焦方向">#</a>关于聚焦方向</h2>
<blockquote>
<p>I committed 10% of my time trying to understand the bigger problems in the field, i.e. what was and what was not important. I found in the early days I had believed *this’*and yet had spent all week marching in <em>that</em> direction. It was kind of foolish. If I really believe the action is over there, why do I march in this direction? I either had to change my goal or change what I did. So I changed something I did and I marched in the direction I thought was important. It’s that easy.</p>
</blockquote>
<p>我把 10% 的时间用来理解领域中更 <strong>大</strong> 的问题，也就是什么是重要的，什么不重要。我发现在早期，我相信了 A 是重要的，但我却花了一周的时间在 B 问题上。这有点蠢。如果我真的相信我应该在 A 方向行动，为什么我还要朝着 B 方向前进？我要么改变我的目标，要么改变我所做的事情。所以我改变了我所做的事情，我朝着我认为重要的方向前进。就这么简单。</p>
<blockquote>
<p>Now you might tell me you haven’t got control over what you have to work on. Well, when you first begin, you may not. But once you’re moderately successful, there are more people asking for results than you can deliver and you have some power of choice, but not completely.</p>
</blockquote>
<p>你可能会告诉我，你没有权力控制你所要做的事情。好吧，当你刚开始工作时，你可能确实没有。但一旦你有了一定的成功，就会有更多的人需要你的结果，而你却无法满足所有人的需求，这时你就有了一些选择的权力，但不是完全的。</p>
<blockquote>
<p>I am telling you how you can get what you want in spite of top management. You have to sell your ideas there also.</p>
</blockquote>
<p>你可以在不受高层管理的影响下，得到你想要的东西，但你必须在管理层推销你的想法。</p>
<h2 id="关于动力"><a class="header-anchor" href="#关于动力">#</a>关于动力</h2>
<blockquote>
<p><em>Is the effort to be a great scientist worth it?‘’</em> To answer this, you must ask people. When you get beyond their modesty, most people will say, Yes, doing really first-class work, and knowing it, is as good as wine, women and song put together,‘’ or if it’s a woman she says, It is as good as wine, men and song put together.‘’ And if you look at the bosses, they tend to come back or ask for reports, trying to participate in those moments of discovery. They’re always in the way. So evidently those who have done it, want to do it again. But it is a limited survey. I have never dared to go out and ask those who didn’t do great work how they felt about the matter. It’s a biased sample, but I still think it is worth the struggle. I think it is very definitely worth the struggle to try and do first-class work because the truth is, the value is in the struggle more than it is in the result. The struggle to make something of yourself seems to be worthwhile in itself. The success and fame are sort of dividends, in my opinion.</p>
</blockquote>
<p>“成为一位伟大的科学家的努力是否值得？”为了回答这个问题，你需要去询问人们。当你让他们抛下顾虑时，大多数人会说，“是的，做真正一流的工作，并理解它，就像把美酒、女人和歌曲结合在一起那样好。” 或者如果你问的是一个女人，她会说：“这就像把美酒、男人和歌曲结合在一起一样美好。” 当你观察那些老板时，他们似乎总是会来参与进一流的工作或要求给出一流工作的报告，他们总是试图参与那些重要的发现时刻，虽然这一定程度上会会妨碍我们的工作。所以显然，那些曾经做过一流工作的人，都会想再次去做一流的工作。但这是一个有限的调查。我从未敢问那些没有做出伟大工作的人他们对此事的感受。虽然这是一个有偏差的样本，但我仍然认为努力去做一流的工作绝对是值得的，因为事实上，价值更多地在于挣扎本身，而不是结果。努力让自己变得更好似乎本身就是有价值的。在我看来，成功和名声只是一种额外收益。</p>
<blockquote>
<p>one of the reasons is drive and commitment. The people who do great work with less ability but who are committed to it, get more done that those who have great skill and dabble in it, who work during the day and go home and do other things and come back and work the next day. They don’t have the deep commitment that is apparently necessary for really first-class work. They turn out lots of good work, but we were talking, remember, about first-class work. There is a difference. Good people, very talented people, almost always turn out good work. We’re talking about the outstanding work, the type of work that gets the Nobel Prize and gets recognition.</p>
</blockquote>
<p>那些能力较弱但致力于实现伟大成就的人，比那些有着非凡技能、却只是粗略的使用技能的人完成更多工作。那些有着非凡技能的人白天工作，晚上回家做其他事情，然后第二天回来继续工作，他们没有显现出真正做一流工作所必需的深入投入。他们的成果很多，但请记住，我们谈论的是一流的工作。这两者之间存在差异。表现出色的人，非常有才华的人几乎总是能完成好的工作。但我们讨论的是杰出的工作，那种能获得诺贝尔奖并得到认可的工作。</p>
<h2 id="关于穿着"><a class="header-anchor" href="#关于穿着">#</a>关于穿着</h2>
<blockquote>
<p>I came from Los Alamos and in the early days I was using a machine in New York at 590 Madison Avenue where we merely rented time. I was still dressing in western clothes, big slash pockets, a bolo and all those things. I vaguely noticed that I was not getting as good service as other people. So I set out to measure. You came in and you waited for your turn; I felt I was not getting a fair deal. I said to myself, ``Why? No Vice President at IBM said, <em>Give Hamming a bad time</em> It is the secretaries at the bottom who are doing this. When a slot appears, they’ll rush to find someone to slip in, but they go out and find somebody else. Now, why? I haven’t mistreated them.‘’ Answer, I wasn’t dressing the way they felt somebody in that situation should. It came down to just that - I wasn’t dressing properly. I had to make the decision - was I going to assert my ego and dress the way I wanted to and have it steadily drain my effort from my professional life, or was I going to appear to conform better? I decided I would make an effort to appear to conform properly. The moment I did, I got much better service. And now, as an old colorful character, I get better service than other people.</p>
</blockquote>
<p>我来自 Los Alamos，早期我在纽约的 590 麦迪逊大街使用一台机器，那时我们只能租用设备一段时间使用。那时我仍然穿着西部服装，大口袋，蝴蝶结等。我隐约注意到我得到服务并不如其他人。所以我开始衡量，当排队等待轮到我的时候，我觉得我没有得到公平的待遇。我问自己，为什么？IBM 的副总裁肯定没有说过要给 Hamming 难堪之类的话。当有机器有一个空闲时段出现时，工作人员会急忙去找某人去使用，但他们总会选择其他人。为什么？我并没有虐待那些工作人员。最后我发现答案是，我没有穿工作人员认为的那个场合应该穿的衣服。归根结底就是这个原因——我穿着不得体。</p>
<p>因此我必须做一个决定——我是要坚持我自己的风格，让它不断地削弱我在专业上的付出，还是我要表现得更为顺从？我决定竭力表现得更为合宜。当我这么做时，我得到了更好的服务。现在，作为一个有趣的老人，我得到的服务比其他人更好。</p>
<blockquote>
<p>You should dress according to the expectations of the audience spoken to. If I am going to give an address at the MIT computer center, I dress with a bolo and an old corduroy jacket or something else. I know enough not to let my clothes, my appearance, my manners get in the way of what I care about. An enormous number of scientists feel they must assert their ego and do their thing their way. They have got to be able to do this, that, or the other thing, and they pay a steady price.</p>
</blockquote>
<p>你应该根据你面对的观众的期望来着装。如果我要在麻省理工学院计算机中心发表演讲，我会穿一条蝴蝶领带和一件旧灯芯绒夹克之类的衣服。我知道不能让我的衣着、外表和礼仪妨碍我关心的事情。有许多科学家认为他们必须坚持自己的风格，用自己的方式做事。但他们必须改变自己来符合观众的期望，否则，他们会持续付出代价。</p>
<blockquote>
<p>John Tukey almost always dressed very casually. He would go into an important office and it would take a long time before the other fellow realized that this is a first-class man and he had better listen. For a long time John has had to overcome this kind of hostility. It’s wasted effort! I didn’t say you should conform; I said The <em>appearance of conforming</em> gets you a long way.‘’ If you chose to assert your ego in any number of ways, I am going to do it my way,‘’ you pay a small steady price throughout the whole of your professional career. And this, over a whole lifetime, adds up to an enormous amount of needless trouble.</p>
</blockquote>
<p>John Tukey 几乎总是穿着非常休闲的衣服。当他会走进一个重要的办公室，过很长时间，对方才会意识到这是一个一流的人，他最好要认真倾听。很长一段时间以来，John 一直不得不克服这种敌意。这是浪费力气！我并没有说你应该完全顺从，我说的是“看起来顺从会带给你很大的便利。”如果你选择以许多不同的方式来坚持你的自我，“我要用我的方式去做”，那么在整个职业生涯中，你会持续付出一些小的代价。而这在一生中累计起来，会导致大量不必要的麻烦。</p>
<blockquote>
<p>And I think John Tukey paid a terrible price needlessly. He was a genius anyhow, but I think it would have been far better, and far simpler, had he been willing to conform a little bit instead of ego asserting. He is going to dress the way he wants all of the time. It applies not only to dress but to a thousand other things; people will continue to fight the system. Not that you shouldn’t occasionally!</p>
</blockquote>
<p>我认为 John Tukey 付出了可怕的，且不必要的代价。无论如何，他是个天才，但我认为，如果他愿意更对这个社会顺从一点而不是一味的自我主张，事情会好得多，也简单得多。他一直按照他想要的方式穿着，而且不仅仅是在着装领域，在其他上千件事情上 John 也这样。人们如果持续的与社会的要求做斗争，会付出不少的代价。当然了，在一些时刻，坚持自己也是应该的。</p>
<h2 id="关于制度"><a class="header-anchor" href="#关于制度">#</a>关于制度</h2>
<blockquote>
<p>Many a second-rate fellow gets caught up in some little twitting of the system, and carries it through to warfare. He expends his energy in a foolish project. Now you are going to tell me that somebody has to change the system. I agree; somebody’s has to. Which do you want to be? The person who changes the system or the person who does first-class science? Which person is it that you want to be? Be clear, when you fight the system and struggle with it, what you are doing, how far to go out of amusement, and how much to waste your effort fighting the system. My advice is to let somebody else do it and you get on with becoming a first-class scientist. Very few of you have the ability to both reform the system <em>and</em> become a first-class scientist.</p>
</blockquote>
<p>许多二流的人都会陷入对制度系统的一些缺陷的关注，并大张旗鼓的要改变它，于是他把精力消耗在了一个愚蠢的项目上。或许你会说 “必须有人改变系统”。我同意，有人必须这样做，但你想成为哪种人？一个改变制度的人还是做出一流科学成就的人？你必须清楚地知道，当你与系统作斗争并与之斗争时，你究竟在做什么，你是不是在趁机休息或娱乐，你在与系统作斗争时浪费了多少精力。我的建议是让别人去做，然后你就可以成为一流的科学家。很少有人有能力既改革体制又成为一流的科学家。</p>
<blockquote>
<p>On the other hand, we can’t always give in. There are times when a certain amount of rebellion is sensible. I have observed almost all scientists enjoy a certain amount of twitting the system for the sheer love of it. What it comes down to basically is that you cannot be original in one area without having originality in others. Originality is being different. You can’t be an original scientist without having some other original characteristics. But many a scientist has let his quirks in other places make him pay a far higher price than is necessary for the ego satisfaction he or she gets. I’m not against all ego assertion; I’m against some.</p>
</blockquote>
<p>另一方面，我们不能总是屈服于制度。有时，一定程度的反抗是明智的。我观察到，几乎所有科学家都出于对制度系统的纯粹热爱而喜欢对系统进行一定程度的改进。归根结底是，如果你在某个领域没有原创性，那么在其他领域就不可能有原创性。原创就是与众不同。如果你无法在一个制度系统中发现待改进的点，你很难成为一名原创性的科学家。但许多科学家的一些自我主张，让他在获取自我满足外，付出了过高的代价，他们过度的关注了制度是否满足他们的需求。我并不反对所有的自我主张，我反对一些代价高昂的自我主张。</p>
<blockquote>
<p>Another fault is anger. Often a scientist becomes angry, and this is no way to handle things. Amusement, yes, anger, no. Anger is misdirected. You should follow and cooperate rather than struggle against the system all the time.</p>
</blockquote>
<p>另一个错误是愤怒。科学家常常会生气，但错误会让你没有办法处理事务。幽默是好的，但愤怒不是。愤怒是误导性的，你应该跟随和配合制度，而不是一直与制度作斗争。</p>
<h2 id="关于自我认知"><a class="header-anchor" href="#关于自我认知">#</a>关于自我认知</h2>
<blockquote>
<p>I am an egotistical person; there is no doubt about it. I knew that most people who took a sabbatical to write a book, didn’t finish it on time. So before I left, I told all my friends that when I come back, that book was going to be done! Yes, I would have it done - I’d have been ashamed to come back without it! I used my ego to make myself behave the way I wanted to. I bragged about something so I’d have to perform. I found out many times, like a cornered rat in a real trap, I was surprisingly capable.</p>
</blockquote>
<p>我无疑是一个自负的人。我知道大多数人会决定在休假的时候写一本书，但常常完不成。所以我会在去休假前，告知我所有的朋友“当我休假结束，这本书就基本写完了”。这样我就能完成这本书，因为我一想到我回来时这书没写完，我就会觉得在朋友面前会太丢脸。我利用了我的自尊来完成我想要做的事，我会向别人吹嘘一些我必须要做的事。很多时候，这会让我像一个落入陷阱的老鼠一样，表现出令人吃惊的能力.</p>
<blockquote>
<p>Now self-delusion in humans is very, very common. There are enumerable ways of you changing a thing and kidding yourself and making it look some other way. When you ask, Why didn’t you do such and such,‘’ the person has a thousand alibis. If you look at the history of science, usually these days there are 10 people right there ready, and we pay off for the person who is there first. The other nine fellows say, Well, I had the idea but I didn’t do it and so on and so on.‘’ There are so many alibis. Why weren’t you first? Why didn’t you do it right? Don’t try an alibi. Don’t try and kid yourself. You can tell other people all the alibis you want. I don’t mind. But to yourself try to be honest.</p>
</blockquote>
<p>自我欺骗非常，非常的普遍。有许多的方式，你可以改变一件事然后欺骗自己，让它看起来有不一样的表现。当被问起 “你为什么不 blablabla” 时，人们有一千个理由。当你回顾科学发展的历史，你会发现在一个时间点，可能有 10 个科学家都已经有了做出伟大成就的准备，但只有一个人会首先迈出最终一步，然后剩下的九个人会说“我也有了这个想法，但我没去做他，因为 blablabla。” 人能给自己找的借口太多了，但为何你不是第一个人？为什么你没法把事情做对？不要尝试找借口，不要尝试欺骗自己，你可以告诉别人所有你想要的接口。这无所谓，但你不要骗自己就好。</p>
<h1 id="Discussion"><a class="header-anchor" href="#Discussion">#</a>Discussion</h1>
<h2 id="关于勇气-2"><a class="header-anchor" href="#关于勇气-2">#</a>关于勇气</h2>
<blockquote>
<p><em>Question:</em> The remarks about having courage, no one could argue with; but those of us who have gray hairs or who are well established don’t have to worry too much. But what I sense among the young people these days is a real concern over the risk taking in a highly competitive environment. Do you have any words of wisdom on this?</p>
</blockquote>
<blockquote>
<p><em>Hamming:</em> I’ll quote Ed David more. Ed David was concerned about the general loss of nerve in our society. It does seem to me that we’ve gone through various periods. Coming out of the war, coming out of Los Alamos where we built the bomb, coming out of building the radars and so on, there came into the mathematics department, and the research area, a group of people with a lot of guts. They’ve just seen things done; they’ve just won a war which was fantastic. We had reasons for having courage and therefore we did a great deal. I can’t arrange that situation to do it again. I cannot blame the present generation for not having it, but I agree with what you say; I just cannot attach blame to it. It doesn’t seem to me they have the desire for greatness; they lack the courage to do it. But we had, because we were in a favorable circumstance to have it; we just came through a tremendously successful war. In the war we were looking very, very bad for a long while; it was a very desperate struggle as you well know. And our success, I think, gave us courage and self confidence; that’s why you see, beginning in the late forties through the fifties, a tremendous productivity at the labs which was stimulated from the earlier times. Because many of us were earlier forced to learn other things - we were forced to learn the things we didn’t want to learn, we were forced to have an open door - and then we could exploit those things we learned. It is true, and I can’t do anything about it; I cannot blame the present generation either. It’s just a fact.</p>
</blockquote>
<p>问题：你关于勇气的部分的阐述毋庸置疑。但对于我们这些老人或者说一些已经成家立业的人而言，我们有了后盾，所以我们能鼓起勇气。但对于现在的年轻人，他们处在一个高度的竞争环境下，他们需要承担过高的风险以至于很难鼓起勇气。对于这个情况，你有什么建议或看法？</p>
<p>Hamming：在我看来，我们和现在的年轻人确实经历了不同的时期。我们是从战争时期中走出来的，我们在 Los Alamos 制造了炸弹，我们创造了雷达，在数学系和其他科学领域，有许多充满勇气的人。他们刚刚完成了所有的事，他们刚刚赢得了一场非常伟大的战争。因为战争，我们有必要有勇气，因此我们做了很多事情。但在这个时刻，我无法重新创造出战争那样的范围，我也不能责怪当代人没有这样的氛围，所以同意你的说法。在我看来，现在的年轻人并没有追求伟大的愿望，他们缺乏这样做的勇气。但我们有，是因为我们处于有利的环境中，我们刚刚经历了一场非常成功的战争。在战争中，我们有很长一段时间看起来非常非常糟糕。正如你所知，这是一场非常绝望的斗争。我认为，战争中的成功给了我们勇气和自信；这就是为什么你会看到，从四十年代末到五十年代，实验室在早期的刺激下取得了巨大的成果。因为我们中的许多人早些时候被迫学习其他东西 - 我们被迫学习我们不想学习的东西，我们被迫打开一扇门 - 然后我们可以利用我们学到的那些东西。这是事实，但我对此无能为力；我也不能责怪当代人。这只是事实。</p>
<h2 id="关于头脑风暴"><a class="header-anchor" href="#关于头脑风暴">#</a>关于头脑风暴</h2>
<blockquote>
<p><em>Question:</em> Is brainstorming a daily process?</p>
</blockquote>
<blockquote>
<p><em>Hamming:</em> Once that was a very popular thing, but it seems not to have paid off. For myself I find it desirable to talk to other people; but a session of brainstorming is seldom worthwhile. I do go in to strictly talk to somebody and say, Look, I think there has to be something here. Here’s what I think I see …‘’ and then begin talking back and forth. But you want to pick capable people. To use another analogy, you know the idea called the <em>critical mass.</em> If you have enough stuff you have critical mass. There is also the idea I used to call <em>sound absorbers</em> .When you get too many sound absorbers, you give out an idea and they merely say, Yes, yes, yes.‘’ What you want to do is get that critical mass in action; Yes, that reminds me of so and so,‘’ or, Have you thought about that or this?‘’ When you talk to other people, you want to get rid of those sound absorbers who are nice people but merely say, ``Oh yes,‘’ and to find those who will stimulate you right back.</p>
</blockquote>
<p>问题：你是否觉得头脑风暴应该成为一个日常过程？</p>
<p>Hamming: 头脑风暴曾经是一个非常流行的活动，但它似乎没有产生太多的收益。对我自己而言，我觉得与某些人交谈是值得的，但一个头脑风暴活动却很少会产生结果。我会找到特定的人，然后说 “我发现…我觉得…”，然后开始与他讨论。有一个概念叫 “临界质量”，当你有足够的知识后，你就有了与别人交流的 “临界质量” 了，这时候交流才是有价值的。我有个自己定义的概念叫 “吸音器”。当你交流的对象，大多是 “吸音器” 时，你能得到的回答就都是 “是的，是的，是的，嗯，嗯，嗯”。你要做的，就是保证参与的对象，都到了 “临界质量”，然后就能得到 “是的，这让我想起了 xxx”，“你有没有考虑过 xxxx”。当你决定和别人交谈时，你要摆脱那些只会说 “哦，好的” 的人，然后找到那些能刺激你的人。</p>
<blockquote>
<p>I picked my people carefully with whom I did or whom I didn’t brainstorm because the sound absorbers are a curse. They are just nice guys; they fill the whole space and they contribute nothing except they absorb ideas and the new ideas just die away instead of echoing on. Yes, I find it necessary to talk to people. I think people with closed doors fail to do this so they fail to get their ideas sharpened, such as ``Did you ever notice something over here?‘’ I never knew anything about it - I can go over and look. Somebody points the way. On my visit here, I have already found several books that I must read when I get home. I talk to people and ask questions when I think they can answer me and give me clues that I do not know about. I go out and look!</p>
</blockquote>
<p>我会精心挑选那些我共事的人，我也会精心挑选我 <strong>不</strong> 一起进行头脑风暴的人，因为 “吸音器” 是诅咒。 他们是好人，但他们会充满整个空间但不提供任何的东西，他们只会吸收所有的想法，所有新的想法会直接消亡而不是在大家脑海中回荡。是的，与人交流是有必要的，我认为那些关起门工作的人没有机会磨砺自己的想法，他们听不到类似于 “你有没有意识到 xxxx” 这样的回复。如果别人提出了我从未想到过的想法，我就会去关注和学习下这想法，一些人就曾给过我这样的想法。在我来这访问的时候，我已经听到了一些当我回家后必须要读的书。我会与那些我觉得会给出我未曾想过的思路线索的人交谈和向他们提问题。</p>
<h2 id="关于阅读_写作_做研究_的时间平衡"><a class="header-anchor" href="#关于阅读_写作_做研究_的时间平衡">#</a>关于阅读 / 写作 / 做研究 的时间平衡</h2>
<blockquote>
<p>What kind of tradeoffs did you make in allocating your time for reading and writing and actually doing research?</p>
</blockquote>
<blockquote>
<p><em>Hamming:</em> I believed, in my early days, that you should spend at least as much time in the polish and presentation as you did in the original research. Now at least 50% of the time must go for the presentation. It’s a big, big number.</p>
</blockquote>
<p>问题： 你觉得在读书，写作和做研究间，时间该如何分配。</p>
<p>Hamming：在我早期工作时，我认为你应该至少花费与研究一样多的时间去润色和演示你的成果。而对于现在的我而言，至少需要 50 % 的时间需要用来展示成果，这是一个很大的占比。</p>
<h2 id="关于阅读的方式"><a class="header-anchor" href="#关于阅读的方式">#</a>关于阅读的方式</h2>
<blockquote>
<p><em>Question:</em> How much effort should go into library work?</p>
</blockquote>
<blockquote>
<p><em>Hamming:</em> It depends upon the field. I will say this about it. There was a fellow at Bell Labs, a very, very, smart guy. He was always in the library; he read everything. If you wanted references, you went to him and he gave you all kinds of references. But in the middle of forming these theories, I formed a proposition: there would be no effect named after him in the long run. He is now retired from Bell Labs and is an Adjunct Professor. He was very valuable; I’m not questioning that. He wrote some very good Physical Review articles; but there’s no effect named after him because he read too much. If you read all the time what other people have done you will think the way they thought. If you want to think new thoughts that are different, then do what a lot of creative people do - get the problem reasonably clear and then refuse to look at any answers until you’ve thought the problem through carefully how you would do it, how you could slightly change the problem to be the correct one. So yes, you need to keep up. You need to keep up more to find out what the problems are than to read to find the solutions. The reading is necessary to know what is going on and what is possible. But reading to get the solutions does not seem to be the way to do great research. So I’ll give you two answers. You read; but it is not the amount, it is the way you read that counts.</p>
</blockquote>
<p>问题：我应该将多少事件花费在图书馆进行阅读？</p>
<p>Hamming：这个答案和你研究的领域相关。我知道在贝尔实验室有个人，他非常非常聪明。他几乎每天都在图书馆，他读了所有的书籍。如果你需要参考资料，你就去找他，他会给你所有的参考资料。但在一系列理论产生的时期，我觉得不会有任何的理论会以他的名字来命名。他现在已经退休了，成为了一名兼职教授。他非常有价值，我不是在质疑这一点。他写了一些非常好的物理评论文章，但没有一个理论或效应以他的名字命名，因为他读的太多了。如果你一直在阅读别人的成果，你会以他们的方式去思考。如果你想要有不同的思考，那么你需要做一些创造性的事情，你需要清楚的定义问题，然后拒绝看任何答案，直到你真的仔细的思考过这个问题：你会如何做，你会如何稍微改变看问题的角度来使问题变得可以解决正确。所以是的，你需要保持阅读，你需要保持阅读来发现问题而不是找到答案。阅读是必要的，你需要靠阅读知道这个世界发生了什么，什么是可能的。但是通过阅读来找到答案，似乎不是做出伟大研究的方式。所以我答案是，你需要阅读，但要关注的不是阅读的量，而是阅读的方式。</p>
<h2 id="关于研究方向"><a class="header-anchor" href="#关于研究方向">#</a>关于研究方向</h2>
<blockquote>
<p>Question: You mentioned the problem of the Nobel Prize and the subsequent notoriety of what was done to some of the careers. Isn’t that kind of a much more broad problem of fame? What can one do?</p>
</blockquote>
<blockquote>
<p>Hamming: Some things you could do are the following. Somewhere around every seven years make a significant, if not complete, shift in your field. Thus, I shifted from numerical analysis, to hardware, to software, and so on, periodically, because you tend to use up your ideas. When you go to a new field, you have to start over as a baby. You are no longer the big mukity muk and you can start back there and you can start planting those acorns which will become the giant oaks. Shannon, I believe, ruined himself. In fact when he left Bell Labs, I said, That’s the end of Shannon’s scientific career.‘’ I received a lot of flak from my friends who said that Shannon was just as smart as ever. I said, Yes, he’ll be just as smart, but that’s the end of his scientific career,‘’ and I truly believe it was.</p>
</blockquote>
<blockquote>
<p>You have to change. You get tired after a while; you use up your originality in one field. You need to get something nearby. I’m not saying that you shift from music to theoretical physics to English literature; I mean within your field you should shift areas so that you don’t go stale. You couldn’t get away with forcing a change every seven years, but if you could, I would require a condition for doing research, being that you will change your field of research every seven years with a reasonable definition of what it means, or at the end of 10 years, management has the right to compel you to change. I would insist on a change because I’m serious. What happens to the old fellows is that they get a technique going; they keep on using it. They were marching in that direction which was right then, but the world changes. There’s the new direction; but the old fellows are still marching in their former direction.</p>
</blockquote>
<blockquote>
<p>You need to get into a new field to get new viewpoints, and before you use up all the old ones. You can do something about this, but it takes effort and energy. It takes courage to say, Yes, I will give up my great reputation.‘’ For example, when error correcting codes were well launched, having these theories, I said, Hamming, you are going to quit reading papers in the field; you are going to ignore it completely; you are going to try and do something else other than coast on that.‘’ I deliberately refused to go on in that field. I wouldn’t even read papers to try to force myself to have a chance to do something else. I managed myself, which is what I’m preaching in this whole talk. Knowing many of my own faults, I manage myself. I have a lot of faults, so I’ve got a lot of problems, i.e. a lot of possibilities of management.</p>
</blockquote>
<p>问题：你提到了诺贝尔奖的问题，以及随后的名声对一些人事业的影响。这不是名声的一个更广泛的问题吗？一个人能做什么？</p>
<p>Hamming: 你可以做的一些事情是以下几点。大约每七年，在你的领域做一个重大的，如果不是完全的，转变。因此，我从数值分析转向硬件，再到软件，等等。你需要定期的转变，因为你会逐渐用完你的想法。当你进入一个新的领域时，你必须像一个婴儿一样重新开始。你不再是大人物，你可以从那里开始，你可以开始种植那些将成为巨大橡树的橡子。我相信香农毁了自己。事实上，当他离开贝尔实验室时，我说，“这是香农科学生涯的终结。”我的朋友们对此表示了很多的抱怨，他们说香农和以前一样聪明。我说，“是的，他还是一样聪明，但这是他科学生涯的终结”，我真的相信是这样的。</p>
<p>你必须改变。过了一段时间，你就会累了；你在一个领域里用完了你的独创性。你需要得到一些附近的东西。我不是说你应该从音乐转向理论物理学，再转向英国文学；我的意思是，在你的领域内，你应该转向其他领域，这样你就不会变得陈腐。你不需要强迫自己每七年改变一次，但如果你能，我会要求你在研究中改变你的领域，那些腐朽的人人们会发生什么事情呢？他们得到了一个技术，他们继续使用它，在当时那个时刻，这技术是在正确的方向上前进。但世界在变化，有了新的方向后，腐朽的人们仍然在他们以前的方向上前进。</p>
<p>你需要进入一个新的领域，以获得新的观点，而不是用完所有的旧观点。这需要努力和精力，你也需要勇气说，“是的，我会放弃我的伟大声誉。”例如，当纠错码被广泛应用时，我说，“Hamming，你要停止阅读这个领域的论文；你要完全忽略它；你要尝试做一些其他的事情，而不是在这个领域里继续。”我故意拒绝在这个领域继续前进。我甚至不会阅读论文，以便强迫自己有机会做其他的事情。我管理自己，这就是我在这次演讲中所宣扬的。了解我自己的许多缺点，然后管理自己。我有很多缺点，所以我有很多问题，也就有了很多管理的可能性。</p>
<h2 id="关于管理"><a class="header-anchor" href="#关于管理">#</a>关于管理</h2>
<blockquote>
<p>Question: Would you compare research and management?</p>
</blockquote>
<blockquote>
<p>Hamming: If you want to be a great researcher, you won’t make it being president of the company. If you want to be president of the company, that’s another thing. I’m not against being president of the company. I just don’t want to be. I think Ian Ross does a good job as President of Bell Labs. I’m not against it; but you have to be clear on what you want. Furthermore, when you’re young, you may have picked wanting to be a great scientist, but as you live longer, you may change your mind. For instance, I went to my boss, Bode, one day and said, Why did you ever become department head? Why didn’t you just be a good scientist?‘’ He said, Hamming, I had a vision of what mathematics should be in Bell Laboratories. And I saw if that vision was going to be realized, I had to make it happen; I had to be department head.‘’ When your vision of what you want to do is what you can do single-handedly, then you should pursue it. The day your vision, what you think needs to be done, is bigger than what you can do single-handedly, then you have to move toward management. And the bigger the vision is, the farther in management you have to go. If you have a vision of what the whole laboratory should be, or the whole Bell System, you have to get there to make it happen. You can’t make it happen from the bottom very easily. It depends upon what goals and what desires you have. And as they change in life, you have to be prepared to change. I chose to avoid management because I preferred to do what I could do single-handedly. But that’s the choice that I made, and it is biased. Each person is entitled to their choice. Keep an open mind. But when you do choose a path, for heaven’s sake be aware of what you have done and the choice you have made. Don’t try to do both sides.</p>
</blockquote>
<p>问题：你能比较一下研究和管理的关系吗？</p>
<p>Hamming：如果你想成为一个伟大的研究者，你不会成为公司的总裁。如果你的目标是成为公司的总裁，那就完全是另一回事。我不反对成为公司的总裁，只不过我自己不想成为。我认为 Ian Ross 在贝尔实验室是一个很好的 Boss。我并不是反对人们去做管理，去做总裁，但你必须清楚你想要什么。此外，当你年轻的时候，你可能选择成为一个伟大的科学家，但随着你的年龄增长，你可能会改变主意。例如，有一天我去找我的老板 Bode，我问他：“你为什么要成为部门主管？你为什么不只是成为一个优秀的科学家？” 他说：“Hamming，我对贝尔实验室的数学有一个愿景。如果这个愿景有可能能够实现，那我就必须让它实现，所以我必须成为部门主管。”</p>
<p>当你对你想做的事情有一个愿景，而你可以独自完成，那么你应该去追求它。当你的愿景，你认为需要做的事情，比你一个人能做的事情更大的时候，你就必须向管理方向发展。愿景越大，你就必须走得越远。如果你有一个关于整个实验室或整个贝尔系统的愿景，你必须到管理层去实现它，你从一线员工的角度去实现它是非常困难的。所以管理和研究取决于你的目标和愿望。随着生活的变化，你必须做好准备去改变你的选择。我选择避免管理，因为我更喜欢独自做我能做的。</p>
<h2 id="关于别人的期许"><a class="header-anchor" href="#关于别人的期许">#</a>关于别人的期许</h2>
<blockquote>
<p>Question: How important is one’s own expectation or how important is it to be in a group or surrounded by people who expect great work from you?</p>
</blockquote>
<blockquote>
<p>Hamming: At Bell Labs everyone expected good work from me - it was a big help. Everybody expects you to do a good job, so you do, if you’ve got pride. I think it’s very valuable to have first-class people around. I sought out the best people. The moment that physics table lost the best people, I left. The moment I saw that the same was true of the chemistry table, I left. I tried to go with people who had great ability so I could learn from them and who would expect great results out of me. By deliberately managing myself, I think I did much better than laissez faire.</p>
</blockquote>
<p>问题：一个人的期望有多重要？或者说，被一个期望你能做出伟大工作的团队包围有多重要？</p>
<p>Hamming：在贝尔实验室，每个人都期望我能做出好的工作，这对我很有帮助。如果每个人都期望你能做出好的工作，你又有自尊心，那么你就会做出好的工作。我认为身边有一流的人是非常有价值的，所以我不断地在寻找最优秀的人。当物理学组失去最优秀的的人时，我离开了物理学组。当我看到化学组也是如此时，我也离开了。我试图和有很强能力的人在一起，这样我就可以向他们学习，他们也会期望我能做出伟大的成果。通过有意识地管理自己，我认为我做得比放任自流要好得多。</p>
<h2 id="关于运气-2"><a class="header-anchor" href="#关于运气-2">#</a>关于运气</h2>
<blockquote>
<p>Question: You, at the outset of your talk, minimized or played down luck; but you seemed also to gloss over the circumstances that got you to Los Alamos, that got you to Chicago, that got you to Bell Laboratories.</p>
</blockquote>
<blockquote>
<p>Hamming: There was some luck. On the other hand I don’t know the alternate branches. Until you can say that the other branches would not have been equally or more successful, I can’t say. Is it luck the particular thing you do? For example, when I met Feynman at Los Alamos, I knew he was going to get a Nobel Prize. I didn’t know what for. But I knew darn well he was going to do great work. No matter what directions came up in the future, this man would do great work. And sure enough, he did do great work. It isn’t that you only do a little great work at this circumstance and that was luck, there are many opportunities sooner or later. There are a whole pail full of opportunities, of which, if you’re in this situation, you seize one and you’re great over there instead of over here. There is an element of luck, yes and no. Luck favors a prepared mind; luck favors a prepared person. It is not guaranteed; I don’t guarantee success as being absolutely certain. I’d say luck changes the odds, but there is some definite control on the part of the individual.</p>
</blockquote>
<p>问题: 在你的演讲开始时，你淡化了运气的作用，你似乎也忽略了让你到 Log Alamos 的环境，让你到达 Chicago，让你到达贝尔实验室的环境。</p>
<p>Hamming：确实这些事有一些运气。但从另一方面，我也不知道如果这些事没发生，我会怎么样。除非我能说 “没这些事，我就不会同样成功或更成功”，不然我也没法将去这些地方定义为是 “好运” 的。例如，当我在 Los Alamos 遇到费曼时，我知道他将获得诺贝尔奖。我不知道具体是什么原因，但我就是很清楚地知道他会做出伟大的工作。无论未来出现什么样的方向，这个人都会做出伟大的工作，果然，他做出了伟大的工作。并不是说你只能在特定情况下做出伟大的工作，如果是那样的话，那确实是运气主导了一切。实际上你总会有很多机会。你会有一大堆机会。如果你处在某个情况下，你抓住了一个机会，你就会在那里取得伟大的成就。所以运气是有的，但它决定不了一切。运气青睐有准备的头脑，运气青睐有准备的人。当然我无法保证这一点，我不能保证成功是绝对的。我只能说运气改变了胜算，但个人也有一定的控制权。</p>
<h1 id="Reference"><a class="header-anchor" href="#Reference">#</a>Reference</h1>
<p><a href="https://www.cs.virginia.edu/~robins/YouAndYourResearch.html">You and Your Research (virginia.edu)</a></p>
]]></content>
      <tags>
        <tag>摘抄</tag>
        <tag>How-To</tag>
      </tags>
  </entry>
  <entry>
    <title>Powershell 模块：ZLocation</title>
    <url>/zlocation/</url>
    <content><![CDATA[<p>ZLocation 是 PowerShell 中的一个 Module，其可以追踪你访问各个地址的历时，并通过 <code>z</code> 命令快速访问你最常使用的目录。</p>
<h1 id="安装方式"><a class="header-anchor" href="#安装方式">#</a>安装方式</h1>
<p>可使用如下的命令安装 ZLocation：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Install-Module</span> ZLocation <span class="literal">-Scope</span> CurrentUser</span><br></pre></td></tr></table></figure>
<p>并将如下代码添加到 PowerShell 配置文件的<strong>最后</strong>（原因可见 <a href="/zlocation/#%E6%95%B0%E6%8D%AE%E8%AE%B0%E5%BD%95">实现原理</a>）：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Import-Module</span> ZLocation</span><br></pre></td></tr></table></figure>
<h1 id="使用方式"><a class="header-anchor" href="#使用方式">#</a>使用方式</h1>
<p>ZLocation 有以下的使用方式：</p>
<ol>
<li>
<p>使用 <code>z</code> 命令，获取当前 ZLocation 所有记录的地址，如下所示：</p>
 <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">❯ z</span><br><span class="line">Weight Path</span><br><span class="line"><span class="literal">------</span> <span class="literal">----</span></span><br><span class="line">   <span class="number">14.00</span> C:\Users\wxjwa</span><br><span class="line">    <span class="number">6.00</span> C:\Users\wxjwa\Desktop</span><br><span class="line">   <span class="number">21.00</span> D:\</span><br><span class="line">   <span class="number">32.00</span> D:\Project1\unity</span><br><span class="line">    <span class="number">3.00</span> D:\Project2</span><br><span class="line">    <span class="number">7.00</span> D:\Project2\unity</span><br><span class="line">    <span class="number">3.00</span> D:\Project2\unity\SubProject1</span><br></pre></td></tr></table></figure>
<p>输出的左侧 <code>Weight</code> 为地址的权重，权重越高，表示该地址越常用。</p>
</li>
<li>
<p>通过 <code>z -l &lt;location&gt;</code> 命令，输出所有匹配 <code>&lt;location&gt;</code> 的所有路径中。</p>
 <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">❯ z <span class="literal">-l</span> unity</span><br><span class="line">Weight Path</span><br><span class="line"><span class="literal">------</span> <span class="literal">----</span></span><br><span class="line"> <span class="number">54.00</span> D:\Github\Unity</span><br><span class="line"> <span class="number">34.00</span> D:\Project1\unity</span><br><span class="line">  <span class="number">7.00</span> D:\Project2\unity</span><br></pre></td></tr></table></figure>
</li>
</ol>
<div class="note primary simple"><p><code>&lt;location&gt;</code> 模糊匹配的是路径最后的节点，如有地址 <code>D:\Project2\unity\SubProject1</code>，其并不会出现在 <code>z -l unity</code> 的输出中，因为 i 根节点 <code>SubProject1</code> 中并不包含有 <code>unity</code>。</p>
</div>
<ol start="3">
<li>
<p>通过 <code>z &lt;location&gt;</code> 命令，跳转到匹配 <code>&lt;location&gt;</code> 的所有路径中最常用（根据权重决定）的那个。<br>
<img src="/zlocation/gif-2023-11-26-21-28-41.gif" alt="z location"></p>
<p>可以看到跳转的路径，即为 <code>z -l &lt;location&gt;</code> 中权重最高的路径。</p>
</li>
<li>
<p>通过 <code>z &lt;location&gt; [TAB]</code> 在匹配的路径中进行选择。<br>
<img src="/zlocation/gif-2023-11-26-21-30-06.gif" alt="使用 Tab 切换"></p>
</li>
<li>
<p>通过 <code>z -</code> 命令返回使用 <code>z &lt;location&gt;</code> 跳转前的路径。</p>
</li>
<li>
<p>通过 <code>z &lt;subLocation 1&gt; &lt;subLocation 2&gt;</code> 进行跳转路径的选择控制。</p>
<p>因为 <code>z &lt;location&gt;</code> 只会跳转到匹配的路径中权重最高的那个，如记录了以下地址：</p>
 <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">35.00</span> D:\Project1\unity</span><br><span class="line"><span class="number">7.00</span> D:\Project2\unity</span><br></pre></td></tr></table></figure>
<p>如果使用 <code>z unity</code>，则会跳转到 <code>D:\Project1\unity</code></p>
<p>但有时，我们明确的知道是想要跳转到 <code>D:\Project2\unity</code>，此时就可以使用 <code>z 2 unity</code> 进行跳转。</p>
</li>
</ol>
<div class="note warning simple"><p>子路径必须按照顺序，如上例子中，如果使用 <code>z unity 2</code> 则是无法跳转的。</p>
</div>
<h1 id="工作原理"><a class="header-anchor" href="#工作原理">#</a>工作原理</h1>
<h2 id="数据记录"><a class="header-anchor" href="#数据记录">#</a>数据记录</h2>
<p>ZLocation 的实现原理，是修改 Powershell 的 <a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_prompts">Prompt</a> 函数以获取当前访问的目录地址。</p>
<p>并将访问的目录地址记录在一个文件（数据库）中，在后续使用 <code>z</code> 命令时，会从该文件中获取曾经访问的路径和次数，时间等信息，判断出匹配你当前输出的、常访问的目录，并进行跳转。</p>
<div class="note primary simple"><p>因为修改的是 Prompt，所以即使是使用 <code>cd</code> 进行路径跳转，也会记录在文件中。</p>
</div>
<h2 id="实现函数"><a class="header-anchor" href="#实现函数">#</a>实现函数</h2>
<p>可通过 Get-Command 获取到所有 Z-Location 实现的函数，如下所示：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">❯ <span class="built_in">Get-Command</span> <span class="literal">-Module</span> ZLocation</span><br><span class="line"></span><br><span class="line">CommandType     Name                Version    Source</span><br><span class="line"><span class="literal">-----------</span>     <span class="literal">----</span>                <span class="literal">-------</span>    <span class="literal">------</span></span><br><span class="line"><span class="function"><span class="keyword">Function</span>        <span class="title">Get-ZLocation</span>       <span class="title">1</span>.<span class="title">4</span>.<span class="title">3</span>      <span class="title">ZLocation</span></span></span><br><span class="line"><span class="function"><span class="keyword">Function</span>        <span class="title">Invoke-ZLocation</span>    <span class="title">1</span>.<span class="title">4</span>.<span class="title">3</span>      <span class="title">ZLocation</span></span></span><br><span class="line"><span class="function"><span class="keyword">Function</span>        <span class="title">Pop-ZLocation</span>       <span class="title">1</span>.<span class="title">4</span>.<span class="title">3</span>      <span class="title">ZLocation</span></span></span><br><span class="line"><span class="function"><span class="keyword">Function</span>        <span class="title">prompt</span>              <span class="title">1</span>.<span class="title">4</span>.<span class="title">3</span>      <span class="title">ZLocation</span></span></span><br><span class="line"><span class="function"><span class="keyword">Function</span>        <span class="title">Remove-ZLocation</span>    <span class="title">1</span>.<span class="title">4</span>.<span class="title">3</span>      <span class="title">ZLocation</span></span></span><br><span class="line"><span class="function"><span class="keyword">Function</span>        <span class="title">Set-ZLocation</span>       <span class="title">1</span>.<span class="title">4</span>.<span class="title">3</span>      <span class="title">ZLocation</span></span></span><br><span class="line"><span class="function"><span class="keyword">Function</span>        <span class="title">Update-ZLocation</span>    <span class="title">1</span>.<span class="title">4</span>.<span class="title">3</span>      <span class="title">ZLocation</span></span></span><br></pre></td></tr></table></figure>
<p>当调用 <code>z</code> 命令时，会调用 <code>Invoke-ZLocation</code> 函数，该函数内会进一步根据当前的输入参数或情况调用其他函数，如：</p>
<ul>
<li>无任何参数时，调用 <code>Get-ZLocation</code> 函数，获取匹配的目录</li>
<li>调用<code>z -l &lt;location&gt;</code> 时调用 <code>Get-ZLocation</code> 函数，获取所有匹配的目录</li>
<li>使用 <code>z -</code> 时调用 <code>Pop-ZLocation</code> 函数，返回上一个路径</li>
</ul>
<p>如在 <a href="/zlocation/#%E6%95%B0%E6%8D%AE%E8%AE%B0%E5%BD%95">数据记录</a> 中所述，ZLocation 会修改 <code>prompt</code> 函数，在访问某一个文件夹后，会调用 <code>Set-ZLocation</code> 函数，将访问的路径记录在文件中，多次访问时会调用 <code>Update-ZLocation</code> 函数，更新访问的次数和时间。当存储的文件过大时，会调用 <code>Remove-ZLocation</code> 函数，删除一些不常用的路径。</p>
<h1 id="Reference"><a class="header-anchor" href="#Reference">#</a>Reference</h1>
<p><a href="https://github.com/vors/ZLocation">ZLocation</a><br>
<a href="https://zhuanlan.zhihu.com/p/50548459">终端效率提升：自动路径切换</a></p>
]]></content>
      <tags>
        <tag>工具</tag>
        <tag>CLI</tag>
        <tag>效率提升</tag>
        <tag>PowerShell</tag>
      </tags>
  </entry>
  <entry>
    <title>《卓有成效的管理者》 摘抄</title>
    <url>/zhuo_you_cheng_xiao_de_guan_li_zhe/</url>
    <content><![CDATA[<h1 id="前言"><a class="header-anchor" href="#前言">#</a>前言</h1>
<p>本书的主题却是关于如何自我管理才能成为卓有成效的管理者的 ，实际上，让自身成效不高的管理者管好他们的同事与下属，那几乎是不可能的事。</p>
<h1 id="第一章_卓有成效是可以学会的"><a class="header-anchor" href="#第一章_卓有成效是可以学会的">#</a>第一章 卓有成效是可以学会的</h1>
<p>有才能的人往往最为无效，因为他们没有认识到才能本身并不是成果。他们也不知道，一个人的才能，只有通过有条理、有系统的工作，才有可能产生效益。</p>
<h2 id="为什么需要卓有成效的管理者"><a class="header-anchor" href="#为什么需要卓有成效的管理者">#</a>为什么需要卓有成效的管理者</h2>
<p>“有效性”只是“知识工作者”（knowledge worker）的一种特殊技能。</p>
<ul>
<li>对“体力工作”而言，我们所重视的只是“效率”。所谓效率，可以说是“把事情做对”（to do things right）的能力，而不是“做对的事情”（to get the right things done）的能力</li>
<li>唯有从事“对”的工作，才能使工作有效，而这一点，却是无法用衡量体力工作的方法来衡量的。</li>
</ul>
<p>我们无法对知识工作者进行严密和细致的督导，我们只能协助他们。知识工作者本人必须自己管理自己，自觉地完成任务，自觉地做出贡献，自觉地追求工作效益。</p>
<p>再伟大的智慧，如果不能应用在行动上，也将只是毫无意义的资料。因此，知识工作者必须做到一些体力工作者不需要做的事，他必须具有有效性。</p>
<h2 id="谁是管理者"><a class="header-anchor" href="#谁是管理者">#</a>谁是管理者</h2>
<div class="note info simple"><p>在一个现代的组织里，如果一位知识工作者能够凭借其职位和知识，对该组织负有贡献的责任，因而能对该组织的经营能力及达成的成果产生实质性的影响，那么他就是一位管理者。</p>
</div>
<p>美国报纸曾刊登一篇对于越南战场上一位青年步兵上尉的采访，最能清楚地说明这一点。记者问：“在战场混乱的情况下，你如何指挥你的下属？”那位青年步兵上尉回答说：“在那里，我是唯一的负责人。当我的下属在丛林中遭遇敌人却不知道该怎么行动时，我也因为距离太远无法告诉他们。我的任务，只是确保他们知道在这种情形下应该如何行动。至于实际上该怎么做，应由他们根据情况加以判断。责任虽然在我，但行动的决策却由战场上的每个人自己决定。”在游击战中，每一个人都是“管理者”。</p>
<p>在主管人员中，也有许多人并不是管理者。换言之，许多人只不过是别人的上司，甚至是许多人的上司，但他们的行为，并不能对组织的经营能力产生重大的影响。<br>
与此相反，一位知识工作者是不是一位管理者，我们不能以他有没有下属而定。</p>
<div class="note info simple"><p>在本书中，“管理者”一词，将泛指知识工作者、经理人员和专业人员。</p>
</div>
<h2 id="管理者必须面对的现实"><a class="header-anchor" href="#管理者必须面对的现实">#</a>管理者必须面对的现实</h2>
<ol>
<li>管理者的时间往往只属于别人，不属于自己。如果我们从工作的情形来替管理者下一个定义，我们简直可以说他是组织的囚徒。每一个人都可以随时来找他，而事实上每一个人也正是这么做的。</li>
<li>管理者往往被迫忙于“日常运作”，除非他们敢于采取行动来改变周围的一切。
<ul>
<li>如果管理者被迎面而来的一连串事务所左右，根据事情先后顺序来决定做什么、研究什么、重点对待哪项工作，那他不久就只能穷于应付了。也许他具有了不起的才干，足以应付得了，但实际上他却是在浪费自己的知识和能力，把原本可能达成的成效撇开了。管理者需要的是一套判断标准，使他能够针对真正重要的事项去工作。但是在日常事务中，常常找不到他所需的标准</li>
</ul>
</li>
<li>管理者本身处于一个“组织”之中。只有当别人能够利用管理者的贡献时，管理者才算有效
<ul>
<li>对管理者的有效性而言，最重要的人物，往往并不是管理者直接控制的下属，而是其他部门的人，即所谓“旁系人士”，或是管理者本人的上司。一位管理者如果不能与这些人主动接触，不能使这些人有效利用他的贡献，他本身就没有有效性可言。</li>
</ul>
</li>
<li>管理者身处一个组织的“内部”，受到组织的局限。
<ul>
<li>在组织的内部，根本不会有成果出现，一切成果都存在于组织之外。举例来说，企业机构的成果，是通过顾客产生的，企业付出的成本和努力，必须通过顾客购买其产品或服务，才能转变为收入和利润。也就是说，做决定的人在企业之外，不在企业之内。</li>
<li>这种外部环境是真正的现实，而这个现实却不能从组织内部有效控制，充其量也必须内外两方面共同作用才能产生成果。管理者能看得清清楚楚的只是组织的内部，组织内部才是他最密切接触的。内部的种种关系和联系、内部的种种问题和挑战以及种种错综的情况和意见，不停地由各个方向向他袭来。除非他能付出特殊的努力，使自己与外界保持直接的联系，否则他必将日益局限于组织内部。他在组织中的地位越高，他的注意力就越容易为内部的问题和挑战所困，而看不到外部的情况。</li>
<li>一个组织绝不能像生物一样，以自身的生存为目的，仅仅把能够延续后代视作成功。组织是社会的一种器官，只有能为外部环境做出自己的贡献，才能算有所成就。但是，当组织的规模日益扩大，并且看来日益成功时，其内部的种种事务也将变得更多，这些事务将占据管理者更多的兴趣、精力和能力，使其难以顾及自己的真正任务，无法为外界提供有效的服务。</li>
<li>通常只有组织内部的资料，才是可以量化的。真正的问题是，外部情况往往是质的性质，难以量化，它们还不能被称为事实。
<ul>
<li>福特公司的一款名为 Edsel 的汽车，也是一个类似的例子。在推出这种车型之前，福特公司搜集了一切能够得到的数据，证明这款新车必能畅销。没想到美国的汽车消费者发生了质的变化，从“收入决定购买”转变到“兴趣决定购买”了。而这种质的变化，却无法用统计数字来显示。等到后来这种质的变化可以用充分的数据来说明的时候，为时已晚，公司的新车已经推出，结果导致了失败。</li>
</ul>
</li>
<li>一位管理者，如果不能有意识地努力去觉察外部世界，则组织内部的事务必将蒙蔽他，使他看不见真正的现实。</li>
</ul>
</li>
</ol>
<h2 id="对有效性的认识"><a class="header-anchor" href="#对有效性的认识">#</a>对有效性的认识</h2>
<p>我们必须学会这么一种建立组织的方式：若某人在某一重要领域具有一技之长，就要让他充分发挥这一特长。</p>
<p>当然我说这些，并不表示一个人连各领域的一些基础知识都不需要掌握了。今天有许多年轻的受过高等教育的人士，不论是在企业机构、医院还是政府，他们的缺点之一，是往往以自己精通了某一狭窄领域的专门学问而自满，不屑于其他。一位会计当然不一定需要钻研人际关系，一位工程师当然也不一定需要钻研如何促销新产品；可是，他们至少应该知道那些是什么样的领域，为什么要设立那些领域，那些领域到底做些什么。</p>
<p>但是，这种精而后博的人与所谓通才不同。通才也和天才一样，可遇而不可求。我们应该努力的是，学会善用那些专精于某一领域的人。也就是说，我们必须提高有效性。我们既然不能增加资源的供应量，就应该设法增加资源的产出量。所谓有效性，就是使能力和知识资源能够产生更多、更好成果的一种手段。</p>
<h2 id="卓有成效可以学会吗"><a class="header-anchor" href="#卓有成效可以学会吗">#</a>卓有成效可以学会吗</h2>
<p>卓有成效的管理者有一个共同点，那就是他们在实践中都要经历一段训练，这一训练使他们工作起来能卓有成效。不管他们是在企业机构内、政府机构内、医院内，还是学校内，不管他们是干什么的，这些训练的内容都是一样的。</p>
<p>有效性是一种后天的习惯，是一种实践的综合。既然是一种习惯，便是可以学会的。</p>
<p>下列 5 项是要成为一个卓有成效的管理者，必须在思想上养成的习惯：</p>
<ol>
<li>有效的管理者知道应该将他们的时间用在什么地方。他们所能控制的时间非常有限，他们会通过系统地工作来善用这有限的时间。</li>
<li>有效的管理者重视对外界的贡献。他们并非为工作而工作，而是为成果而工作。他们不会一接到工作就一头钻进去，更不会一开头就探究工作的技术和手段，他们会首先自问：“别人期望我做出什么成果？”</li>
<li>有效的管理者善于利用长处，包括自己的长处、上司的长处、同事的长处和下属的长处。他们还善于抓住有利形势，做他们能做的事。他们不会把工作建立在自己的短处上，也绝不会去做自己做不了的事。</li>
<li>有效的管理者集中精力于少数重要的领域，在这少数重要的领域中，如果能有优秀的绩效就可以产生卓越的成果。他们会按照工作的轻重缓急设定优先次序，而且坚守优先次序。他们别无选择，只能要事第一。重要的事先做，不重要的事放一放，甚至不做，两种事都做，反倒会一事无成。</li>
<li>最后，有效的管理者必须善于做有效的决策。他们知道有效的决策事关处事的条理和秩序问题，也就是如何按正确的次序采取正确的步骤。他们知道一项有效的决策，总是在“不同意见讨论”的基础上做出的判断，它绝不会是“一致意见”的产物。他们知道快速的决策多为错误的决策，真正不可或缺的决策数量并不多，但一定是根本性的决策。他们需要的是正确的战略，而不是令人眼花缭乱的战术。</li>
</ol>
<h1 id="第二章_掌握自己的时间"><a class="header-anchor" href="#第二章_掌握自己的时间">#</a>第二章 掌握自己的时间</h1>
<p>管理者的工作计划，很少真正发生作用。计划通常只是纸上谈兵，或只是良好的意愿，很少能够真正实现。</p>
<p>有效的管理者并不是一开始就着手工作，他们往往会从时间安排上着手。他们并不以计划为起点，认识清楚自己的时间用在什么地方才是起点。然后他们管理自己的时间，减少非生产性工作所占用的时间。最后，再将“可自由运用的时间”，由零星而集中成大块连续性的时段。</p>
<p>有效的管理者知道，时间是一项限制因素。任何生产程序的产出量，都会受到最稀有资源的制约。而在我们称之为“工作成就”的生产程序里，最稀有的资源，就是时间。</p>
<p>人类像其他生物一样，生理上有自己的“生物钟”——任何人如果有乘飞机越洋飞行的经验，应该都能了解。但是心理学实验却证明，人的时间感觉是最不可靠的。所以，如果完全靠记忆，我们恐怕说不清楚自己的时间是怎样打发的。</p>
<ul>
<li>某公司的董事长，十分肯定地对我说他的时间大致分成三个部分：1/3 用于与公司高级管理人员研讨业务；1/3 用于接待重要客户；其余 1/3 则用于参加各种社会活动。但是，等实际记录了 6 个星期之后，跟他原来的估计比较，结果发现在上述三个方面，他几乎没花什么时间。原来，他所说的三类工作，只不过是他认为“应该”花时间的工作而已，因此他的记忆告诉他已将时间用在这三个方面了。6 个星期的实际记录，显示他的时间大部分都花在调度工作上了，例如处理他自己认识的顾客的订单，打电话给工厂催货。事实上，顾客的订单，本来可以顺利处理的，由于他的干预，反而弄得不能准时交货。</li>
</ul>
<h2 id="时间对管理者的压力"><a class="header-anchor" href="#时间对管理者的压力">#</a>时间对管理者的压力</h2>
<p>管理者经常受到种种压力，迫使他不得不花费一些时间在非生产性的和浪费时间的事务上。身为管理者，不管他是不是经理人，总有许多时间耗在毫无贡献的工作上。大量时间都不可避免地浪费了。而且管理者在组织中的地位越高，组织对他的时间要求往往越大。</p>
<p>每一位管理者的时间，都有很大部分是被浪费掉的。表面上看起来，每件事似乎都非办不可，实际上却毫无贡献或贡献太少。但是，即使是只想获得最低程度的有效性，管理者在绝大部分任务上也需要相当多的整块时间。如果每一次所花的时间少于这个极限，事情就做不好，所花的时间就是浪费，再做就得从头开始。</p>
<ul>
<li>举例来说，一份报告大概得花 6 ～ 8 小时才能完成初稿。如果说每次花 15 分钟，每天 2 次，一共花上 2 星期，虽然总时间也达到 7 小时，恐怕结果还是一张白卷，不过是在上面胡乱涂写了一些东西而已。但是如果能够关起门来，切断电话，连续做上五六个小时，一份相当不错的草稿就应该差不多了。</li>
</ul>
<p>每一位知识工作者，尤其是每一位管理者，要想有效就必须能将时间做整块的运用。如果将时间分割开来零星使用，纵然总时间相同，结果时间也肯定不够。</p>
<p>要想与他人做有效的沟通，总得花上足够的时间。一位经理人员如果以为他与下属讨论一项计划、一项方针或是一项工作表现，只需 15 分钟就够了，那他一定是自欺欺人。如果你真想影响别人，那至少需要一小时以上。如果你想和别人建立良好的人际关系，就需要更多的时间。</p>
<p>知识工作者只能自己制定工作方向，所以他必须了解别人期望他做出的贡献是什么，原因是什么，对必须使用其知识成果的人的工作情况，他也要有足够的了解。因此，知识工作者需要信息，需要讨论，还需要指导他人，这都是极为费时的。而且，他不但需要占用他上级的时间，也同样需要占用他周围同事的时间。</p>
<ul>
<li>知识工作者要想取得成果和绩效，就必须着眼于整个组织的成果和绩效。换句话说，他还得匀出时间来，将目光由自己的工作转到成果上；由他的专业转到外部世界，因为只有外部世界才有绩效可言。</li>
<li>在大型组织中，如果知识工作者的绩效表现不错，往往是因为该组织的高级主管能定期抽出时间来与他们进行交流，</li>
</ul>
<p>这样轻松交流，不管是在政府、企业、研究机构，还是在军事单位，都同样很有必要。如果没有这样的交流，知识工作者就容易丧失热情，成为得过且过的人，或者是只关注自己的专业领域，看不到整个组织的需要和机会。不过，进行这样的交流是很费时间的，特别是这种交流必须在不慌不忙、轻松自在的气氛下进行。只有这样，大家才会觉得“我们有足够的时间”，可以从容不迫地交流看法。这实际上意味着管理者要快速地做许多事，同时也意味着他必须腾出整块的时间来，而且中间不能有太多的中断和打扰。</p>
<ul>
<li>毫无疑问的是：一起工作的人数越多，工作者用于彼此协调关系的时间肯定越多，而真正用于工作的时间就越少了。因此大型组织只有在大量耗用其管理者的时间之后，才能变得强大有力。所以，组织规模越大，管理者实际可掌握的时间越少。身为管理者，因此更应该知道自己的时间应该用在什么地方，并且更应该妥善运用那剩下来可自由支配的少量时间了</li>
</ul>
<h2 id="如何诊断自己的时间"><a class="header-anchor" href="#如何诊断自己的时间">#</a>如何诊断自己的时间</h2>
<p>早在 20 世纪初期的科学管理时代，我们就已经知道了记录工作时间，</p>
<p>但是我们却一直将这套方法应用在时间因素并不太重要的工作上。在那些工作中，时间的利用和浪费，充其量只会对效率和成本稍有影响。而在某些越来越重要的工作领域，我们却没有应用这套方法，尤其是那些时间因素特别重要的知识工作，特别是管理者的工作。</p>
<p>所以，要提高管理者的有效性，第一步就是记录其时间耗用的实际情形。重要的是，必须在处理某一工作的“当时”立即加以记录，而不能事后凭记忆补记。有了时间耗用的记录样本，他们便能自行检讨了。半年之后，他们都会发现自己的时间耗用得很乱，浪费在种种无谓的小事上。经过练习，他们在时间的利用上必有进步。</p>
<p>第二个步骤就是要做有系统的时间管理。我们先要将非生产性的和浪费时间的活动找出来，尽可能将这类活动从时间表上排除出去。要做到这一步，可以试问自己以下几个问题。</p>
<ol>
<li>首先要找出什么事根本不必做，这些事做了也完全是浪费时间，于最终的成果无助。
<ul>
<li>许多大忙人，天天在做一些他们觉得难以割舍的事，比如应邀讲演、参加宴会、担任委员和列席指导之类，这些活动不知占去了他们多少时间。而这些工作，他们本身既不感兴趣，做得也根本不够精彩</li>
</ul>
</li>
<li>第二个该问的问题是：“时间记录上的哪些活动可以由别人代为参加而又不影响效果？”
<ul>
<li>几乎每一位主管人员都接到过上级有关做好授权的指示，而且他们本人也曾屡屡对其下属阐明授权的重要。但是这样的谆谆告诫是否产生了预期效果，实在令人怀疑。原因非常简单：没有完全明了授权的意义。</li>
<li>如果认为所谓授权，意思是说：“我的”工作应由别人来做，那就错了；因为你既然拿了薪水，就该做你自己的工作。又有人认为：充分授权之后，最闲散的经理人便应该是最好的经理人。这样的看法不但荒唐，而且也是不道德的。</li>
<li>管理者所做的工作，确实有许许多多可由别人去做，而且也应该由别人去做。“授权”这个名词，通常都被人误解，甚至是曲解了。这个名词的意义，应该是把可由别人做的事情交付给别人，这样才能做真正应由自己做的事。</li>
</ul>
</li>
<li>还有一项时间浪费的因素，是管理者自己可以控制并且可以消除的，这项因素是：管理者在浪费别人的时间。
<ul>
<li>去问问你的下属。有效的管理者懂得有系统及诚恳地问他的下属：“请你想想看，我常做哪些浪费你的时间而又不产生效果的事情？”问这样的问题，而且问得对方敢说真心话，才是有效管理者的特色。</li>
<li>某一大企业机构的财务经理，深感会议浪费了太多时间。通常不管讨论的是什么，他都通知财务部各单位主管全体前来开会，其结果是会议每次都拖得很长。出席会议的每一位主管，为了表示自己对问题的关切，都得提出自己的意见，而这些意见却大多与问题无关，会议时间自然拖长了。直到有一次这位财务经理诚恳地问了大家，才知道大家也都认为会议太浪费时间了。可是，他又想到：每一个人在组织中都至为重要，都应该了解情况，开会时如果少请几个人，他又担心会使未被邀请的人觉得他们被忽视。后来这位财务经理终于找到一个两全其美的办法了。开会前，他先分发一份开会通知：“兹订于星期三下午 3 时，于四楼会议室，邀请赵钱孙李四君开会讨论下年度资本预算问题。如哪位需了解这个问题或愿参与讨论，亦请届时出席。如果无法出席，我们将于会后立刻呈送记录，供各位参考并希望提供宝贵意见。”过去每次会议都要 12 人参加，花费整个下午，而现在只要 4 人出席，一小时就可以结束了，并且没有一个人有被忽视的感觉。</li>
<li>许多管理者都意识到了哪些事情会浪费他们的时间，然而他们却不敢面对这个问题。他们怕因小失大，造成错误。殊不知即使有了错误，也能很快弥补。能够大量削减不必要的和非生产性的工作，则工作就进行得快多了。事实上，一位管理者大刀阔斧地减少不必要的工作，绝不会有太大的风险。人常常会有高估自己地位的重要性的倾向，认为许多事非躬亲不可。纵然是最有效的管理者，仍然免不了有许多不必要的和非生产性的工作。</li>
</ul>
</li>
</ol>
<h2 id="消除浪费时间的活动"><a class="header-anchor" href="#消除浪费时间的活动">#</a>消除浪费时间的活动</h2>
<p>管理不善不仅会浪费大家的时间，更重要的是会浪费主管自己的时间。</p>
<p>（1）首先要做的是，找出由于缺乏制度或远见而产生时间浪费的因素。应注意的现象，是机构中一而再、再而三出现同样的“危机”。同样的危机如果出现了第二次，就绝不应该再让它出现第三次。</p>
<p>这类危机可以预先防止，或可以设计成一种例行工作，使每个人都能处理。所谓例行工作，是将本来要靠专家才能处理的事，设计成无须研究判断，人人均可处理的工作。例行的工作，可以说是专家们从过去的危机中，学会的一套有系统、有步骤的处理方式。</p>
<p>同一个危机如果重复出现，往往是疏忽和懒散造成的。</p>
<p>一个平静无波的工厂，必是管理上了轨道。如果一个工厂高潮迭现，在参观者看来大家忙得不可开交，就必是管理不善。管理好的工厂，总是单调无味，没有任何刺激动人的事件。那是因为凡是可能发生的危机都早已预见，且已将解决办法变成例行工作了。</p>
<p>（2）人员过多，也常造成时间的浪费。</p>
<p>判断人数是否过多，有一个靠得住的标准。如果一个高级管理人员，尤其是经理，不得不将他工作时间的 1/10 花在处理所谓“人际关系问题”上，花在处理纠纷和摩擦上，花在处理争执和合作等问题上，那么这个单位人数就过多了。</p>
<p>用一个人，应该是每天的工作都需要他。偶尔才有需要的专家，必要时才需向他请教的专家，就不该正式聘用。</p>
<p>（3）另一个常见的浪费时间的原因，是组织不健全。其表现就是会议太多。</p>
<p>所谓会议，顾名思义，是靠集会来商议，是组织缺陷的一种补救措施。我们开会时就不能工作，工作时就不能开会，谁也不能同时又开会又工作。一个结构设计臻于理想的组织，应该没有任何会议（在今天动态的世界中，这样的组织当然只是理想而已）。每个人应该都能了解他工作所必须了解的事，也应该都能随时获得他工作所必需的资源。我们之所以要开会，只是因为各有各的工作，要靠彼此合作才能完成某一特定任务。我们之所以要开会，只是因为某一情况所需的知识和经验，不能全部装在一个人的头脑里，需要集思广益。</p>
<p>一位管理者花费在会议上的时间如果过多，便是组织不健全的表现。要开会，就得有一定的计划，否则不但令人讨厌，而且是一种危险。会议应该是不得已的例外，不能视为常规。一个人人都随时开会的组织，必是一个谁都不能做事的组织。</p>
<p>原则上，一位管理者的时间，绝不能让开会占用太多。会议太多，表示职位结构不当，也表示单位设置不当。会议太多，表示本应由一个职位或一个单位做的工作，分散到几个职位或几个单位去了。同时表示职责混乱以及未能将信息传送给需要的人员。</p>
<p>（4）最后一项浪费时间的因素，是信息功能不健全。</p>
<ul>
<li>某一医院的院长，多年来一直为应付院内医生们的电话而苦恼。医生们打电话给他，要求他为病人安排一个床位。住院部都说是没有床位了，但这位院长几乎每次都可以找到空床位。原因是在病人出院时，住院部不能立刻接到通知。当然，有没有床位，各病房的护士长随时都很清楚，主办出院结账手续的出纳台也能随时知道。住院部的人，是在每天清早 5 点办理“床位调查”工作，而通常病人大多是在上午医生查房之后才办出院手续。其实像这样的问题，只要各病房护士长在填写出院通知单给出纳台时，多填一份副本送住院部就解决了。</li>
</ul>
<p>另一种同样常见的现象，是信息的表达方式不当，其后果有时更为严重。</p>
<ul>
<li>制造部门常遭遇的一项困扰，是生产数字无法直接供生产作业部门使用。例如产量，报表中往往只列出会计部门所需的“平均产量”。可是直接作业人员需要的却不是平均数字，而是范围和大小，包括产品的组合、产量的变动和每批生产的时间等。所以，他们需要这类资料时，不是每天都得花费几小时来推算，就是在本单位内设置一个自己的秘密统计组。当然这种资料在会计部门一定都有的，可是通常谁也不想去告诉会计部门，说自己需要的是怎样的信息。</li>
</ul>
<h2 id="统一安排可以自由支配的时间"><a class="header-anchor" href="#统一安排可以自由支配的时间">#</a>统一安排可以自由支配的时间</h2>
<p>一位管理者无论怎样无情地删掉了浪费的部分，其自由时间仍不会太多。一位管理者的职位越高，其不能自行支配的时间也一定越多。组织的规模越大，其用于维系组织运行，而非用于发挥组织功能及生产的时间也一定越多。</p>
<p>有效的管理者知道他必须集中他的自由时间。他知道他需要集中整块时间，时间分割成许多段，等于没有时间。时间如果能集中，即使只有一个工作日的 1/4，也足可办理几件大事。反之，零零碎碎的时间，纵然总数有 3/4 个工作日，也是毫无用处。</p>
<p>卡尔森教授在他的研究报告中，曾提到一位最有效的管理者。这位管理者每天上午上班前，总有 90 分钟时间留在家里，不接电话，专门从事研究工作。如果还要准时上班，那么早上在家里自然就得早早开始工作了。不过这种做法，总比每天下班后把重要事务带回家去，晚饭后再花 3 小时处理的方式好得多。现在喜欢把工作带回家来开夜车的人越来越多，这往往会造成一种不好的情况：人们以为可以晚上加班，因此反倒没有抓紧白天的工作时间。</p>
<p>许多人把次要的工作集中起来办理，因而匀出一段整块时间来。但这样的方法并无太大的作用。因为这样的方法，使人在心理或时间上，仍然放不下那些次要的事情，放不下那些很少贡献而又认为不能不做的事情。结果终究还会产生新的时间压力，来占用他的自由时间，牺牲他应该做的事。</p>
<p>一切卓有成效的管理者都懂得：对时间的控制与管理不能一劳永逸。他们要持续不断地做时间记录，定期对这些记录进行分析，还必须根据自己可以支配的时间的多少，给一些重要的活动定下必须完成的期限。</p>
<h1 id="第三章_我能贡献什么"><a class="header-anchor" href="#第三章_我能贡献什么">#</a>第三章 我能贡献什么</h1>
<p>重视贡献是有效性的关键。所谓有效性，表现在以下三个方面：</p>
<ol>
<li>自己的工作，包括工作内容、工作水准、工作标准及其影响</li>
<li>自己与他人的关系，包括对上司、同事和下属</li>
<li>各项管理手段的运用，例如会议或报告等。</li>
</ol>
<p>可是大多数管理者的视线都集中在下方。他们重视勤奋，但忽略成果。他们耿耿于怀的是：所服务的组织和上司是否亏待了他们，是否该为他们做些什么。他们最在意的是“应有”的权威，结果是做事没有成效。</p>
<p>一个人如果只知道埋头苦干，如果老是强调自己的职权，那不论其职位有多高，也只能算是别人的“下属”。反过来说，一个重视贡献的人，一个注意对成果负责的人，即使他位卑职小，也应该算是“高层管理人员”</p>
<h2 id="管理者的承诺"><a class="header-anchor" href="#管理者的承诺">#</a>管理者的承诺</h2>
<p>提出“我能做出什么贡献”的问题，是为了挖掘工作中尚未发挥的潜力，管理者如果不自问“我可以做出什么贡献”，他在工作中就不会有远大的目标，甚至可能把目标搞错而且特别容易对“贡献”一词只有狭义的理解。</p>
<p>一般机构对成效的要求往往表现在以下三个方面：</p>
<ul>
<li>直接成果</li>
<li>树立新的价值观及对这些价值观的重新确认</li>
<li>培养与开发明天所需要的人才</li>
</ul>
<p>因此，管理者若想做点贡献，就必须在这三方面下功夫。不过在这三者之中，哪个最重要，哪个其次，就要看管理者本人的情况以及他所处的地位及机构本身的需要了。</p>
<ul>
<li>直接成果应该是最重要的。组织的生存需要直接成果，犹如人需要营养食物一样。</li>
<li>除了直接成果，一个组织还必须有价值观的承诺与实现，这就像人体除了食物外还少不了维生素和矿物质。一个组织必须有自己的主张和想法，否则就难免解体、混乱和瘫痪</li>
<li>人都免不了一死，纵然他有再大的贡献，其贡献也因此有一定的限度。而一个组织，大体言之，正是克服这种限度的工具。组织如果不能持续存在，就是失败。所以，一个组织必须今天准备明天的接班人，其人力资源必须更新，必须经常提高水准。</li>
</ul>
<p>管理者的失败，原因有很多。常见的原因，应该是他本人在出任一项新职位时，不能或不愿为适应新职位的需要而改变自身。自以为过去做得成功了，因此满足于老一套的工作方法，结果必然遭到失败。</p>
<h2 id="如何使专业人员的工作卓有成效"><a class="header-anchor" href="#如何使专业人员的工作卓有成效">#</a>如何使专业人员的工作卓有成效</h2>
<p>知识工作者通常是一位专业人员。原则上，只有当他掌握了某种专门知识后，他的工作才能卓有成效。也就是说，他必须有所专长。但是，所谓专长，本身就是片面的、孤立的。一个专业人员的产出必须与其他人的产出结合在一起，才能产生成果。并不是说专业人员应变成“通才”，而是说专业人员必须使他本人有效，必须使他的专才有效。他必须考虑到他的产出供什么人使用，也必须了解用户应该知道些什么才能有效使用他的产出，从而产生成果。</p>
<p>知识分子有责任让别人了解自己。有些专业人员认为，普通人应该并且可以做出努力来理解他们，甚至认为他们只要能够和同行的少数专业人员沟通就够了，这真是傲慢的自大。一个人如果想成为管理者，换句话说，如果愿以贡献为目标，就必须使自己的“产品”——即他的知识能为别人所用。</p>
<p>卓有成效的管理者因为有想把工作干得更好的心理动力，所以总想了解别人需要什么、发现了什么以及能理解些什么。他们会向机构内部人员（包括他们的上司、下属，特别是其他部门的同事）提出这样的问题：“为便于你为机构做出贡献，你需要我做些什么贡献？需要我在什么时候，以哪种形式，用什么方式来提供这些贡献？”</p>
<p>所谓“通才”，应该也是一位专家，是一位能将其所专的一个小领域与其他广大知识领域联系的专家。有少数人也许可以精通几门知识，但这并不意味着他们便是通才，他们不过是精通几门知识的专家而已。仅通一门的专家固然可能偏执，精通几门的专家同样有可能偏执。</p>
<h2 id="正确的人际关系"><a class="header-anchor" href="#正确的人际关系">#</a>正确的人际关系</h2>
<p>在以工作或任务为主的环境下，如果我们不能有所成就，那就算我们能与人和谐相处，愉快交谈，又有什么意义呢？这种“和谐相处，愉快交谈”恰恰是恶劣态度的伪装。反过来说，如果能在工作上取得成绩，即使偶尔疾言厉色，也不至于影响人际关系的。</p>
<p>在个人的经验中，最具有良好人际关系的人士，我可以列举三个人：一位是第二次世界大战时美国的陆军参谋长马歇尔将军，一位是曾任通用汽车公司总裁达 30 余年的斯隆先生，还有一位是斯隆先生的高级主管之一杜瑞斯特。他们三人待人的方式虽各有不同，但都把人际关系建立在“贡献”的基础上。他们能与人密切合作，凡事都设身处地替别人着想。</p>
<p>有效的人际关系，有下列 4 项基本要求：</p>
<ul>
<li>互相沟通</li>
<li>团队合作</li>
<li>自我发展</li>
<li>培养他人。</li>
</ul>
<p>早在 20 年前，我们就已知道现代组织需要沟通，也缺乏沟通，可是今天的沟通工作仍然未见有多大改进。不过，至少我们已经开始了解沟通不易收效的原因了。原来是我们一直把沟通当成是上对下的事，是主管对下属的事。仅靠上对下的单向关系，沟通永远不可能成功。由下属自己设定的目标，往往会在主管的意料之外。换言之，主管和下属看问题的角度往往极不相同。下属越是能干，就越愿意自己承担责任，他们的所见所闻，所看到的客观现实、机会和需要，也就与他们的主管越不相同。此时下属的结论和主管的期望往往是明显对立的。</p>
<p>强调贡献有助于横向的沟通，因此能够促成团队合作。“谁需要我的产出，并使它产生效益？”这个问题能帮助我们看到与管理者责任范围无关的一些人（既不是他的上级或下级，也不是授权给他或他授权的人）的重要性。</p>
<h2 id="有效的会议"><a class="header-anchor" href="#有效的会议">#</a>有效的会议</h2>
<p>有效的管理者在会议开始时，会先说明会议的目的和要求达成的贡献。同时，他还要设法让会议紧紧围绕着主题。他绝不会使会议成为一次摆龙门阵的机会，任大家随便发言。当然，如果会议的目的是在激发大家的思想和创见，他也不会仅让某一个人滔滔不绝。他会刺激每一位与会人员的发言兴趣。但是在会议结束之前，他会回到开场所介绍的主题，使会议获得的结论与主题相符。</p>
<h1 id="第_4_章_如何发挥人的长处"><a class="header-anchor" href="#第_4_章_如何发挥人的长处">#</a>第 4 章 如何发挥人的长处</h1>
<p>用其同事之所长、用其上级之所长和用其本身之所长。利用好这些长处可以给你带来真正的机会。充分发挥人的长处，才是组织存在的唯一目的。要知道任何人都必定有很多缺点和短处，而缺点和短处几乎是不可能改变的，但是我们却可以设法使其不发生作用。管理者的任务，就是要充分运用每一个人的长处，共同完成任务。</p>
<h2 id="要用人所长"><a class="header-anchor" href="#要用人所长">#</a>要用人所长</h2>
<p>有效的管理者择人任事和升迁，都以一个人能做些什么为基础。所以，他的用人决策，不在于如何克服人的短处，而在于如何发挥人的长处。</p>
<p>美国南北战争时，林肯总统任命格兰特将军为北方军的总司令。当时有人告诉他格兰特嗜酒贪杯，难当大任。林肯却说：“如果我知道他喜欢什么酒，我倒应该送他几桶，让大家共享。”林肯总统并不是不知道酗酒可能误事，但他更知道在北军诸将领中，只有格兰特能够运筹帷幄，决胜千里。后来的事实证明了格兰特将军的受命，正是南北战争的转折点。这是一个有效的任命，因为林肯以“取得战役胜利的能力”为标准来选择将军，而不求其没有缺点，是个完人。</p>
<p>不管是谁，如果他在任用一个人时只想避免短处，那他所领导的组织最终必然是平平庸庸的。所谓“样样皆通”者，即只有长处没有短处的人（也可用其他词来描述这类人，如“完人”“个性成熟”“个性完美”或“通才”），实际上可能一无是处。才干越高的人，其缺点也往往越多</p>
<p>一位管理者如果仅能见人之短而不能识人之长，因而刻意避其所短，而非着眼于发挥其所长，则这位管理者本身就是一位弱者。他会觉得别人的才干可能构成对他本身的威胁。有效的管理者知道他们之所以用人，是用人来做事，而不是用人来投主管之所好。剧团经理知道，如果女明星常发脾气而有助于票房，也许他之所以受聘为经理，就是为了承受她的脾气。</p>
<p>有效的管理者从来不问：“他能跟我合得来吗？”他们问的是：“他贡献了什么？”他们从来不问：“他不能做什么？”他们问的是：“他能把什么做好？换言之，类似“完美的人”的说法是忽视了人的卓越性。因为卓越通常只能表现在某一个方面，最多也只能表现在个别的几个方面。</p>
<p>真正能在多方面都有杰出造诣的人，至今还没有出现。达·芬奇算是多才多艺了，但他最突出的成就只是在绘画上。歌德的诗如果没有流传下来，那即使他对光学和哲学有研究，也不见得能在百科全书上找到他的赫赫大名。几位世人皆知的伟人尚且如此，更何况我们这些凡人。</p>
<p>重视一个人的长处，也就是要对他的工作绩效提出要求。如果管理者不在用人之前先问自己“他能做些什么”，那可以肯定他的下属绝难有贡献，这就等于他已经事先对下属的不称职采取了宽容的态度。这样的管理者成事不足，败事有余。真正“苛求的上司”（实际上懂得用人的上司大部分都是“苛求”的上司），总是先发掘一个人最擅长做些什么，再来“苛求”他做些什么。</p>
<p>有效的管理者并不是不知道人有缺点。他了解他自己的任务在于如何使某人充分发挥其税务会计的才干，而不斤斤计较他不善于与人打交道。这层道理谁都清楚。可是，为什么做起来又是另一回事呢？为什么世间的管理者很多，而真能发挥他人长处者却不多。</p>
<p>原因很简单。主要是因为管理者往往以为他们首要的任务不在于因人设事，而在于因事用人。所以，通常是先有了某一个职位，再物色人选来出任该职位。这样的步骤，往往引人走入歧途，物色的对象，往往只是一位“最不至于出差错”的人选——也就是“仅合乎最低要求”的人选。其结果，自然难免都是平平庸庸的人选了。</p>
<ul>
<li>避免出现这一错误，最常见的解决办法是“因人设事”。然而这哪是什么解决办法，这也许比原有的错误还糟，除非是规模极小、事务极简的组织。要知道职位应该是根据客观需要而设定的，应由任务而定，而不应因人而定。</li>
<li>为什么“因人设事”不能解决问题，是因为组织中任何一个职位的变更，都会造成一连串的连锁反应。组织中的职位都是相互联系、相互依存的，牵一发而动全身。我们不能为了替某人安插一个职位，而使组织中的每一个人都受到牵连。</li>
<li>只有因事用人，才能为组织提供所需的各种人才，也只有这样，我们才能容忍各色人等的脾气和个性。能容忍这些差异，内部关系也才能保持以任务为重心，而非以人为重心。衡量成就的高低，应该按照贡献和绩效的客观标准。只有在职位的设计和划分不以人为中心时，这种衡量才有可能。不然的话，我们就会只注意“谁好谁坏”，而忽略了“什么好什么坏”</li>
<li>才能为组织提供所需的各种人才，也只有这样，我们才能容忍各色人等的脾气和个性。能容忍这些差异，内部关系也才能保持以任务为重心，而非以人为重心。人事的决策，要凭公平和公正，否则就会赶走了好人，或破坏好人的干劲。同时，组织也需要各方面的人才，否则将缺乏改变的能力，也将难于得到做出正确的决策所需的不同意见。</li>
</ul>
<p>能建立起第一流经营体制的管理者，通常不会与周围的同事及下属保持过分亲密的关系。不能根据个人的好恶来挑选人才，而应当看他们能干些什么，看他们的工作表现，绝不能看他们是否顺从自己。为了确保能够选用适当的人选，管理者应该与直接的同事或下属保持适当的距离。卓有成效的管理者究竟该怎样用人，才能既发挥他人的长处，又不致陷入因人设事的陷阱呢？大致来说，不外乎下面 4 个原则：</p>
<ol>
<li>卓有成效的管理者不会认为职位是上天或上帝创造的。职位是由人设计，是人都可能犯错</li>
</ol>
<ul>
<li>一个职位，如果先后由两人或三人担任都失败了，这就肯定是一个常人无法胜任的职位，这个职位就必须重新设计。</li>
<li>有效的管理者，第一项任务就是要将自己管辖下的职位都设置得合情合理。一旦发现某职位设计不当，他会立刻重新设计，而不会去设法寻找天才来担任</li>
</ul>
<ol start="2">
<li>职位的要求要严格，而涵盖要广。这是说，合理的职位，是对具有才干的人的挑战。同时因为职位的涵盖很广，所以人们可以把与任务有关的优势转化为切实的成果。</li>
</ol>
<ul>
<li>许多大型组织的政策却与此背道而驰。它们的职位设计过于具体，看起来似乎非要经过“特殊设计”和“特殊加工”的人选，才能达成职位的要求，以便在某一特定时刻做出特定绩效。</li>
<li>而且，职位的要求往往会随情况而变动，甚至变动得非常剧烈。于是，一位本来“绝对适合”的人选，可能忽然间完全不适合这一职位了。</li>
<li>只有把职位设计得涵盖较广且要求较严，才能使人在情况有所变化时能适应新的需要。</li>
<li>一位新人的能力不高，但他出任一项职位后，应该使他能有充分展现其长处的机会。一位知识工作者在初任某一职位时，其职位的标准，应能作为他日后发展的引导，应能成为他衡量自己、评估贡献的依据。</li>
<li>知识工作者职位的设计，还应该能够使人及早发现自己是否适合该职位，甚至是否适合此类工作。</li>
<li>凡是最能充分发挥其长处，而且最受到挑战的人，他的工作肯定最起劲，也肯定最能有所成就。而对工作不满的人，大都是异口同声地埋怨：“他们没有让我充分发挥所长！”</li>
<li>年轻的知识工作者的职位涵盖范围太窄，不足以向他的能力挑战，其结果不是他自请离职，便是很快变成“老油条”</li>
</ul>
<ol start="3">
<li>卓有成效的管理者在用人时，会先考虑某人能做些什么，而不是先考虑职位的要求是什么</li>
</ol>
<ul>
<li>今天大多数组织制定的考评办法，其实最初是由临床与变态心理学家出于自己的目的而设计的。医生的目的在于治病，医生重视的是病人的毛病，而不是病人的优点。</li>
<li>日本有一种“终身雇用”的制度。一个人进了一家公司，他就会逐年升迁，平均每 15 年薪水增加一倍。他不会随便辞职，公司也不能把他开除。除非年龄到了 45 岁，或者位置升到了顶点，才显出事业生涯的分歧：其中少数能力特别强的人，可以继续升到高级主管的位置。日本这套制度，与日本今天取得的巨大发展有什么关联呢？答案很简单：由于日本有这套制度，所以他们可以闭上眼睛，不看人的缺点。尤其是因为日本的管理者不能开除人，所以他们就只有从下属中去发掘能做事的人了。他们看人，只看人之所长。</li>
<li>有效的管理者，通常总有他自己的一套与众不同的考评方式。这套方式，第一步是列出对某人过去职务和现任职务所期望的贡献，再把某人的实际绩效记录与这项期望贡献相对照，然后检讨下面的 4 个问题：
<ol>
<li>哪方面的工作他确实做得很好？</li>
<li>因此，哪方面的工作他可能会做得更好？</li>
<li>为了充分发挥他的长处，他还应该再学习或获得哪些知识？</li>
<li>如果我有个儿子或女儿，我愿意让我的子女在他的指导下工作吗？如果愿意，理由是什么？如果不愿意，理由是什么？</li>
</ol>
</li>
</ul>
<ol start="4">
<li>卓有成效的管理者知道在用人之所长的同时，必须容忍人之所短。</li>
</ol>
<p>西方谚语说：“仆从眼中无英雄。”与英雄接近的人，总能发现英雄的缺点。当然，令人发笑的一方肯定是仆从。仆从眼中所见英雄的缺点，无害其为英雄，更无害于他们在历史舞台上呼风唤雨。</p>
<p>有效的管理者会问：“这个人在某方面是否确有长处？他的长处，是否确为某一任务所需？这个人如果担当这项任务，是否确能表现得与众不同？”如果答案为“是”，那就不必犹豫，而继续聘用此人。</p>
<p>有效的管理者对一位得力的人才，绝不会说：“我少不了他，少了他，我的事就办不成了。”通常我们说“少不了某人”，其原因不外三点：</p>
<ol>
<li>某人其实并不行，不过是管理者没有对他苛求而已，他本人也只能在这种保护下生存；</li>
<li>管理者本人的能力太差，实际上是误用了某人的才干来勉强支持一个自己很难站得住脚的上司；</li>
<li>本来就潜伏着某项严重问题，因为误用某人的才干而将该项问题掩盖住了。</li>
</ol>
<p>对一个没有突出表现的人，尤其是一个没有突出表现的主管，应该无情地调职，这是管理者的责任。任他留下来，必将影响全体人员，而且对于整个组织也是不公平的。对他的下属，则尤为不公平，因为主管无能，则不啻剥夺了下属发挥长处的机会。</p>
<p>马歇尔将军认为，将一位不称职人员调职，与其说是反映了对这个人的看法，倒不如说是对任命他的人有看法。他说：“某人不称职，只是不称‘此’职，并不是说他也肯定不能胜任别的职务。所以，选派某人出任这个职务，是我的错误，我应该负责再给他找到适合的工作。”</p>
<p>马歇尔将军也并非完全不顾一个人的弱点。在弱点可能影响这个人充分发挥长处时，他就要考虑这个人的弱点了。但他所考虑的，是如何运用工作和职业机会来帮助这个人克服这些弱点。</p>
<p>任何一项人事任命都是一个赌注。但是，只要能抓住某人的长处，这至少是合理的赌注。尽量发挥下属的长处，不但是管理者必须对机构承担的义务，更重要的是，这也是为人处世的道理：他应该协助下属得到应有的发展。组织必须为每一位成员服务，使每一位成员都能凭其才干达成成就，而不必顾念其所短。</p>
<h2 id="如何管理上司"><a class="header-anchor" href="#如何管理上司">#</a>如何管理上司</h2>
<p>卓有成效的管理者还要设法充分发挥上司的长处，这也是非常重要的。</p>
<p>如果上级主管的能力不够，下属通常是无法爬升上去的。上司如果没有升迁，下属只好永远屈居其下。如果有一天上司因成绩不佳调职了，继任者也往往都是来自别的部门，很少在本单位中选人提升。</p>
<p>运用上司的长处，也是下属工作卓有成效的关键。只有如此，身为下属者才能将精力集中在自身的贡献上，完成自己想做的工作，取得希望取得的成就。要使上司能发挥其所长，不能靠唯命是从，应该从正确的事情着手，并以上司能够接受的方式向其提出建议。</p>
<p>上司既然是人，所以肯定有其长处，也肯定有其短处。若能在上司的长处上下功夫，协助他做好能做的工作，便能使上司有效，下属也才能有效。反之，如果下属总强调上司的短处，那就像上司强调下属的短处一样，结果将一无所成。</p>
<p>人大致可以分为两种类型：“读者型”和“听者型”。</p>
<ul>
<li>我们面对“读者型”的人侃侃而谈，那是徒费口舌，因为他只能在读过之后才能“听”得进去。</li>
<li>同样，我们面对听者型的人递送一册厚厚的报告书，那是徒费笔墨，因为他只能“听”了之后才能掌握要点</li>
</ul>
<p>向上司提出建议时，应关注“建议”中的各相关方。与事情的轻重是非相比，陈述的先后顺序才是更应考虑的。如果说上司长于政治能力，而这项工作又有关政治，那么我们提出的报告就应以政治方面的问题居先，这样才能使上司易于掌握问题的重心，从而易于发挥其所长，使新政策得以成功。</p>
<h2 id="充分发挥自己的长处"><a class="header-anchor" href="#充分发挥自己的长处">#</a>充分发挥自己的长处</h2>
<p>有效的管理者对于本身的工作，也同样要从长处出发，使自己的长处得以充分发挥。</p>
<p>有效的管理者肯定关心自己所面临的局限性，但他们也应该了解自己能做的和该做的其实还有很多。尽管有人觉得委屈，不能做事，但有效的管理者却能勇往直前。由于他们能勇往直前，所以别人感到非常严重的限制，在他们面前都烟消云散了。</p>
<p>重要的是，有效的管理者会顺应自己的个性特点，不会勉强自己。他注意的是自己的绩效、自己的成果，从而发展出自己的工作方式来。他会问：“哪一类工作别人做起来要费九牛二虎之力，我做起来却是轻而易举？”</p>
<p>在讨论一个人的长处和短处时，他们想到的通常只是针对一门学问的知识，或一种艺术才能。但是，人的性情却往往是事情成败的关键。成年人一般都能了解自己的性情。我们要求有效，就要以了解自己能做些什么为基础，然后以最适合自己的方式做下去。</p>
<p>本章所讨论的如何用人之长，不仅有个态度问题，而且有一个敢不敢去实践的问题。用人之长，可以从实践中获得改进。我们只要注意认识我们的下属，观察我们的上司，多问“此人能做些什么”，而不必问“此人不能做些什么”，最后我们肯定能养成重视人之所长及善用人之所长的态度。久而久之，我们也能以同样的问题来问自己了。</p>
<p>领导人和一般人之间总有一段差距。领导人的绩效高了，一般人也竞相争高。有效的管理者一定明白这层道理：提高领导人的水平容易，但提高全体人员的水平很难。所以，他一定要找出有条件做出突出贡献，并能起带头作用的人才，赋予他们领导人的地位，把他们安置到能“制定标准”并能创造成绩的位置上。</p>
<h1 id="第五章_要事优先"><a class="header-anchor" href="#第五章_要事优先">#</a>第五章 要事优先</h1>
<p>卓有成效如果有什么秘诀的话，那就是善于集中精力。卓有成效的管理者总是把重要的事情放在前面先做（first things first），而且一次只做好一件事</p>
<p>管理者越是想做出重大的贡献，越是需要有更长的“整块时间”。管理者越是想将繁忙纷杂转化为成就，越是需要持续不断的努力，越是需要较长的连续性的时间。然而，即使只想“偷得浮生半日闲”来处理真正有生产性的工作，也要自律和具备非常大的决心对某些事说“不”。</p>
<p>世上确实有人能在同一时间内交替地做两件事，因此两项工作有先后错落的变化。但这只是表示他们能够对两件事，交替分配一段“最低的整块时间”而已。要说一个人能同时处理三件事，恐怕就绝无仅有了。</p>
<p>正因为管理者面对的事务太多太杂，才特别需要专心。一次只做好一件工作，恰恰就是加快工作速度的最佳方法。越能集中我们的时间、努力和资源，我们所能完成的工作也就越多。</p>
<p>有些人一事无成，而实际上他们却做得很吃力。第一，他们低估了完成一件任务所需的时间。他们总以为万事顺利，却总不免有出乎意料的情况发生。然而每个管理者都知道，没有任何事情会是一帆风顺。其实，所谓意料之外者，正应该在我们意料之中。而所谓意料之中，往往从来没有令人愉快的意外。所以，有效的管理者对时间需求的估计宁可有余，而不可不足。第二，一般的管理者（往往也是不大有效的管理者）总喜欢赶工——而赶工的结果，总不免使进度更加落后。有效的管理者不愿赛跑，他们按部就班，稳定前进。第三，一般的管理者喜欢同时着手几件要事，结果对每一件事，他们都无法获得足够的最少整块时间。只要任何一件事情受阻，全部事情也都会跟着受阻了。</p>
<h2 id="摆脱昨天"><a class="header-anchor" href="#摆脱昨天">#</a>摆脱昨天</h2>
<p>管理者专心一志，第一项原则是要摆脱已经不再有价值的过去。有效的管理者必须经常检讨他们和同事的工作计划，他们会问：“如果我们还没有进行这项工作，现在我们该不该开始这项工作？”如果不是非办不可，他们就会放弃这项工作，或者会将它搁置起来。至少他们不会再将资源投入不再产生价值的过去。而对于已经投入的最佳资源，尤其是非常匮乏的人力资源，他们会立即抽调出来，转而投入未来的新机会。</p>
<p>昨天的决策和行动，不论当时看起来如何勇敢、如何睿智，都有可能形成今天的困难和危机，甚至被证明是愚蠢的选择。但是我们至少可以把昨天遗留下来的、不能再产生成果的工作尽量减少。</p>
<p>人若遭遇了重大的失败，改正并不太难，他们能检讨自己。可是昨天的成功，却能留下无尽的影响，远超出成功的有效期。</p>
<ul>
<li>这些过去的成功和活动最需要无情的检讨，否则组织的血液都流失到这种自我之中了。而且这种“经营管理上的自我主义的资产”，往往占用了组织中最能干的人才，却还说那是“值得的”。</li>
<li>任何计划如果无法证明其确属有效及需要，便该立即放弃。否则，现代的政府会用其种种法令规章不断地窒息整个社会，到最后政府本身也将因自己的臃肿而窒息。</li>
</ul>
<p>奉劝各大公司的企业家在抱怨政府官僚习气的同时，也检讨自己的公司是否充满了形形色色的“控制机制”，其实却什么也控制不了。自己的公司是否在进行种种研究，其实只是用来掩饰自己缺乏果断？</p>
<p>有效的管理者打算做一项新的业务时，一定要先删除一项原有的业务。这对控制组织的“膨胀”是非常必要的。“膨胀”如不加以控制，组织就会变得涣散、难以管理。社会组织恰如生物有机体，必须保持“瘦且有肌肉”的状态。</p>
<p>要准备克服重大困难的手段，唯一靠得住的办法只有靠最有才干的人来主持。但是最有才干的人，通常总是太忙了。如果不把他原有的负荷减轻，怎能期望他再承担新的工作？</p>
<ul>
<li>有人会想到另聘新人来负责新工作，但这太冒险了。我们增添新人，大部分是增添在已有成规可循的工作上。而对于新工作，我们应责成确能证明有能力的人来负责。老实说，做一项新工作，本身就是一场赌博即便其他人已经多次做过的工作也是如此；倘若再另聘新人来做，就更是赌上加赌了。</li>
<li>任用新人，可用在“比高层略低”的职位上，用在已有成规或目标明确的职位上。</li>
</ul>
<p>任何一个组织，都不缺乏新的创意。所以，严格说来，我们的问题不是缺乏“创意”，所缺乏的只是创意的执行。人人都在为昨天的任务而忙碌。只要能定期审视当前的计划或活动，并抛弃那些不再有产出的事情，即使是最暮气沉沉的机构，也能获得生机。</p>
<h2 id="先后次序的考虑"><a class="header-anchor" href="#先后次序的考虑">#</a>先后次序的考虑</h2>
<p>我们要做的并不只是弄清楚哪些事情必须优先去做，那是很容易做到的，每个人都可以做得到。很多管理者不能做到集中精力于某项工作，其主要困难在于他们确定不了哪些事情可以缓一缓，就是说要能确定哪些事情可以暂时不去做，并且能把这一决定坚持到底。</p>
<p>由于被搁置实际上等于被取消，所以管理者都不敢轻易地延缓任何工作。他们明白，被延缓的工作虽不是他们最优先要做的事情，不过一旦被延缓，也是有风险的。自己缓办的结果，说不定是竞争同业赶在前头了。决定延缓一项工作，并不是一件愉快的事情。因为我们的“置后”，往往是别人的“优先”。列举一份第一优先的工作单，事事都办，但均浅尝辄止，显然容易得多。这样经常能使人人皆大欢喜，结果却是一事无成。</p>
<p>在决定哪些应该优先、哪些可以延缓这个问题上，最重要的并不是分析，而是拿出应有的勇气来。以下是几条可帮助确定优先次序的重要原则，每条都与勇气密切相关：</p>
<ul>
<li>重将来而不重过去</li>
<li>重视机会，不能只看到困难</li>
<li>选择自己的方向，而不盲从</li>
<li>目标要高，要有新意，不能只求安全和容易。</li>
</ul>
<h1 id="第六章_决策的要素"><a class="header-anchor" href="#第六章_决策的要素">#</a>第六章 决策的要素</h1>
<p>管理者在做出决策时通常并不需要花很多时间，但决策却是身为管理者特有的任务。所以，决策问题值得做特别的讨论。</p>
<p>管理者之所以为管理者，正是由于他拥有特殊的地位和知识，所以人们期望他能做出对整个组织、绩效和成果具有特殊影响的决策。因此，卓有成效的管理者，做的是有效的决策。</p>
<p>有效的管理者不做太多的决策。他们所做的，都是重大的决策。他们重视的，是分辨什么问题为例行性的，什么问题为战略性的，而不重视“解决问题”。</p>
<p>他们知道最棘手的决策，是正反两面折中的决策，他们能分辨正反两面的差异。他们知道在整个决策过程中，最费时的不是决策的本身，而是决策的推行。一项决策如果不能付诸行动，就称不上是真正的决策，最多只是一种良好的意愿。也就是说，有效的决策虽然是以高层次的理性认识为基础，但决策的推行却必须尽可能地接近工作层面，必须力求简单。</p>
<h2 id="有关决策的案例研究"><a class="header-anchor" href="#有关决策的案例研究">#</a>有关决策的案例研究</h2>
<p>他们解决问题，都着眼于最高层次的观念性的认识。他们先透彻地思考该决定的是什么，然后研究制定决策时应采用的原则。换句话说，他们的决策，不是为了适应当时的临时需要，而是战略性的考虑。所以，他们做了创新性的重大决策。</p>
<h2 id="决策的五个要素"><a class="header-anchor" href="#决策的五个要素">#</a>决策的五个要素</h2>
<p>决策的以下五点特征：</p>
<ol>
<li>要确实了解问题的性质，如果问题是经常性的，那就只能通过一项建立规则或原则的决策才能解决。</li>
<li>要确实找出解决问题时必须满足的界限，换言之，应找出问题的“边界条件”。</li>
<li>仔细思考解决问题的正确方案是什么以及这些方案必须满足哪些条件，然后再考虑必要的妥协、适应及让步事项，以期该决策能被接受。</li>
<li>决策方案要同时兼顾执行措施，让决策变成可以被贯彻的行动。</li>
<li>在执行的过程中重视反馈，以印证决策的正确性及有效性。</li>
</ol>
<h3 id="问题的经常性"><a class="header-anchor" href="#问题的经常性">#</a>问题的经常性</h3>
<p>有效的决策人常需花费不少时间来确定问题的属性。如果问题的属性判断错了，其决策必为错误的决策。我们常犯的错误，便是误将“经常问题”视为一连串的“偶发问题”。换言之，没有了解问题症结所在的基础，对问题缺乏经常性的认识与原则，其结果自然是失败与无效。</p>
<p>另一种常犯的错误，是误将真正的新问题视为旧病复发，因而仍旧应用旧原则。</p>
<p>第三种常见的错误，是对某些根本性问题的界定似是而非。</p>
<ul>
<li>自从第二次世界大战结束以来，美国军方常感到他们留不住高素质的医务人员。军方曾屡次研究这一问题，提出了不知多少建议。但是，所有的研究工作，都是以一项听来头头是道的假定为基础的——认为问题在于待遇不够，殊不知真正的原因在于军医的传统制度。美国的军医组织一向重视普通医师，然而今天的潮流已经是分科精细，重视专科医师了。照军方的系统，军医在人事晋升的阶梯上，只能转向行政方面，最后导致与医学研究相脱节。</li>
</ul>
<p>最后一种错误，是只看到问题的部分，而没有看清全貌。</p>
<ul>
<li>在所有肇事事件中，酒醉驾驶或极少数有“行车肇事倾向”的驾驶人员所引发的车祸，往往占车祸数的 3/4 左右；而这种车祸，确实不是驾驶学校所能负责，也不是公路不良所造成的。很久以来我们也知道，努力的重点，其实在于应针对那些非交通安全法规和训练所能控制的车祸。就是说，除了公路安全和驾驶训练，还得同时在技术方面设法，使得万一发生车祸，伤亡情况可以减轻。汽车制造业应该做的，是在技术方面不但使车辆在“正常驾驶”下能确保安全，而且在“不正常驾驶”下也能够提高车辆的安全性。但美国汽车制造业竟没有看到这一层。由上面这个例子，我们可以知道“一知半解”有时比“全然不知”更为可怕。凡属与交通安全有关的机构，包括汽车制造商、公路安全委员会、驾驶员协会以及保险公司等，都有一种误解，不敢承认车祸绝对不能避免，而以为凡有车祸即是因为忽略了安全。</li>
</ul>
<p>一位有效的决策者碰到问题，总是先假定该问题为“经常性质”。他总是先假定该问题是一种表面现象，另有根本性的问题存在。他要找出真正的问题，不会只满足于解决表面现象。</p>
<p>社会生活及政治生活中最显著的一项事实是：暂时性的事物往往具有永久性。这类的例子很多，比如英国的旅馆登记制、法国的房屋租赁管制以及美国政府中的许多“临时建筑”，都是在第一次世界大战时草草创设的。当时都以为最多三五个月就会取消，可是经过几十年，这些临时措施还是屹然不动。</p>
<ul>
<li>当然，这并不是说有效的管理者永远不会采用临时措施。不过，他会问自己：“如果这个临时办法被长期执行下去，我会愿意吗？”如果他的回答是否定的，他就会从更基本、更理性及更广泛的观念上去谋求解决之道。换言之，他会建立一项正确的原则。</li>
</ul>
<p>一位管理者如果天天要做决策，时时要做决策，那恰恰说明他是个疏懒和无效的人。</p>
<p>决策者也常常要留意是否有非常事件出现。他一定经常自问：“这一解释能说明某些事件吗？能说明所有同类的事件吗？”他一定经常想，这个问题的解答，可能引发什么结果？例如能否消除车祸？然后观察是否果然消除了车祸。最后，当出现了别的非常事件时，当出现了他的解答所不能解释的事件时，或者当发生的结果竟与预期不符时，他又回过头来重新检讨原来的问题。</p>
<h3 id="决策的边界"><a class="header-anchor" href="#决策的边界">#</a>决策的边界</h3>
<p>找出问题的“边界条件”，在于确实了解决策应遵循的规范。决策的目标是什么？换言之，最低限度应该达成什么目的？应该满足什么条件？用科学的术语来说，这就是所谓“边界条件”。一项有效的决策必须符合边界条件，必须足以达成目的。边界条件不够明确，则所做的决策不论看起来如何了不起，都肯定是一项无效的决策。探求边界条件的方法，是探求“解决某一问题应有什么最低需要”</p>
<p>有效的管理者明白，一项不符合边界条件的决策，肯定是无效和不适当的决策。不符合边界条件的决策，有时比一项符合“错误的边界条件”的决策更加误事。当然，不符合边界条件与符合错误的边界条件，两者都是错误的决策。不过，边界条件错了，还可能有修正的余地，决策仍可能成为有效的决策。如果根本与规范相反，那就难于补救了。</p>
<p>在各种不同的可能决策中要识别出哪项决策最危险（所谓最危险的决策，就是勉强可行的决策，即唯有在一切顺利的情况下，才可能达成的决策），也必须了解边界条件。几乎每一项这种决策都有其意义，但是当我们进一步探究其必须满足的规范时，便可能发现各项规范之间存在互相冲突的情况。这样的决策纵然不能说是不可能成功的，最多也只能说成功机会很小而已。若成功需寄望于奇迹，则问题不是奇迹出现的机会太小，而是我们不能依赖奇迹。</p>
<h3 id="正确的解决方案"><a class="header-anchor" href="#正确的解决方案">#</a>正确的解决方案</h3>
<p>决策是研究“正确”的决策是什么，而不是研究“能为人接受”的决策是什么。人总有采取折中办法的倾向，如果我们不知道符合规范及边界条件的“正确”决策是什么，就无法辨别正确的折中和错误的折中之间的区别，最终不免走到错误的折中的方向去。</p>
<p>所谓“折中”，实际上有两种。第一种“折中”，即俗语所谓“半片面包总比没有面包好”。第二种“折中”，则可用古代所罗门王审判两位妇人争夺婴儿的故事来说明：“与其要回半个死孩子，不如保全婴儿性命，将婴儿送与对方好。”第一种“折中”，仍能符合边界条件，因为面包本是为了充饥，半片面包仍然是面包。但是第二种“折中”，却完全不符合边界条件了：婴儿是一条生命，半个婴儿就没有生命可言，只是半个尸体了。</p>
<p>关于决策是否容易被他人接受的问题，如果老是要考虑决策如何才能被他人接受，又怕他人会反对，那就完全是浪费时间，不会有任何结果。世界上的事，你所担心的往往永不出现；而你从来没有担心的，却可能忽然间变成极大的阻碍。这就是说，如果你一开头就问：“什么是能让人接受的决策？”那你永远不会有结果。因为在你这样考虑时，通常总是不敢提出最重要的结论，所以你也得不到有效和正确的答案。</p>
<h3 id="决策的行动"><a class="header-anchor" href="#决策的行动">#</a>决策的行动</h3>
<p>决策的第四个要素，是化决策为行动。考虑边界条件，是决策过程中最难的一步；化决策为行动，则是最费时的一步。然而打从决策开始，我们就应该将行动的承诺纳入决策中，否则便是纸上谈兵。</p>
<p>事实上，一项决策如果没有列举详细具体的行动步骤，并指派为某人的工作和责任，那便不能算是一项决策，最多只是一种意愿。</p>
<p>过多的政策说明令人困扰，尤其是在企业机构里更是如此：决策中没有行动的承诺，没有指定何人负责执行。所以，组织的成员看到颁布的政策时，总不免是你看看我、我看看你，以为上级只不过是说说罢了。</p>
<p>若要化决策为行动，首先必须明确无误地回答下面几个问题：</p>
<ol>
<li>谁应该了解这项决策？</li>
<li>应该采取什么行动？</li>
<li>谁采取行动？</li>
<li>这些行动应如何进行，才能使执行的人能够执行？<br>
特别是第一个和最后一个问题，通常最容易被人忽略，以至于即使有了结果，也是灾难性的。</li>
</ol>
<p>为推行某一决策执行人员必须改变其行为习惯和态度时，化决策为行动更是最重要的考虑。在这种情况下，不但行动责任必须明确指定，执行人员必须确有能力，而且绩效的衡量及标准和有关激励的制度，也都需要配合改变。否则，工作人员就会困于情绪的冲突之中。</p>
<h2 id="决策的反馈"><a class="header-anchor" href="#决策的反馈">#</a>决策的反馈</h2>
<p>决策是人做的，人难免会犯错误。再了不起的决策，也不可能永远正确；即使是最有效的决策，总有一天也是会被淘汰的。</p>
<p>有了电脑，决策者和执行者之间的关系可能更加疏远。所以，如果管理者老坐在办公室，不到工作现场，他和实际情形必将越来越脱节。</p>
<h1 id="第七章_有效的决策"><a class="header-anchor" href="#第七章_有效的决策">#</a>第七章 有效的决策</h1>
<p>所谓选择，通常不是“对”与“错”间的选择，最多只是“大概是对的”与“也许是错的”之间的选择。而绝大多数的选择，都是任何一项方案均不一定优于其他方案时的选择。</p>
<p>有效的管理者都知道一项决策不是从搜集事实开始，而是先有自己的见解。这样做是正确的。因为凡在某一领域具有经验者，都应该有他的见解。假如说一个人在某一方面经验丰富，而竟然没有见解，那就说明此人没有敏锐的观察力，头脑迟钝。</p>
<p>人总是从自己的见解开始，所以要求决策者从搜集事实开始，是不符合实际的。其结果是，他像所有人一样，往往很容易不假思索地去寻找符合他自己心中结论的事实；他既然先有了结论，必能搜集到许多事实。干过统计工作的人都能体会到这一点，所以往往最不相信统计数字。统计工作人员也许知道提供数字者的立场，也许不知道提供数字者的立场，但是他知道数字的可疑。</p>
<p>因此唯一严谨的方法，唯一可以印证某一见解是否符合实际的方法，应该以明确承认“见解为先”作为基础——这是必要的做法。有了这样的认识，才能知道我们是以“尚待证实的假设”为起点——决策程序如此，科学研究也如此。我们都知道：假设是不必辩论的，却必须经得起验证。经得起验证的假设才值得我们重视，经不起验证者，就只有放弃了。</p>
<p>有效的决策人通常必先假定传统的衡量方法并非适当的衡量方法。否则，他就用不着做决策了，他只略做简单的调整就可以了。传统的衡量方法反映的是昨天的决策。我们之所以需要一项新决策，正表示过去的衡量方法已不适于今天了。</p>
<blockquote>
<p>自从朝鲜战争以来，美国军用物资的采购和库存政策一直不理想。军方也曾为这个问题绞尽脑汁，做过许多研究，但情况不但没有好转，反而每况愈下。直到麦克纳马拉出任国防部长，才向军需库存的传统衡量方法发起了挑战。在过去，军需物资的采购和库存，一直以物资项目的总项数和总金额为衡量的基础。麦克纳马拉一反此项传统，改用另一种衡量方法。他发现在所有军需物资中，有极少数的项目（也许只占总项数的 4%）是高价物资，它们的采购金额占采购总金额的 90%以上。同样地，他又发现有极少数的项目（大约也只占总项数的 4%）是重要物资，足以维持 90%的战备。在这两项物资（高价物资和战备物资）中，尚有部分重复者，所以合并起来，全部重要物资只不过占总项数的 5%或 6%而已。麦克纳马拉极力主张这类物资应予分别管理，严加管制。至于其余的 95%的物资，论金额不大，论重要性也不致对战备产生重大影响，他主张按照所谓“例外原则”来管理。麦克纳马拉这种一反过去传统的新衡量方法，立刻成为军需物资采购和库存的高度有效决策，也使整个后勤制度为之改观。<br>
汽车行业一向采用惯用的衡量方法，如“平均每行车公里交通事故件数”。如果他们能亲身查看，就会发现交通事故应该改以“人体伤残情况”来衡量。如果能这样做，他们就能知道这项“安全运动”的重点，该放在“一旦发生事故时如何使损伤减至最低”方面，也就是说，应该改良车辆的设计。</p>
</blockquote>
<p>说到判断，必须先有两项以上的方案，从其中选择一项。而且，如果说一项判断可以斩钉截铁地定其“对”与“错”，那也不称其为判断了。唯有在多项方案中，我们需凭借深入研究判断才能有所决定时，才称之为判断。因此，有效的管理者一定要求先有若干种不同的衡量方案，再自其中选取最适当的一种。</p>
<p>如果没有考虑每一个可能方案，就是偏颇。这也正说明了有效的决策者，为什么故意不遵循教科书原则。教科书上说，决策需寻求“意见的一致”，但是他们却有意“制造”互相冲突的不同意见。换句话说，管理者的决策不是从“众口一词”中得来的。好的决策，应以互相冲突的意见为基础，从不同的观点和不同的判断中选择。所以，除非有不同的见解，否则就不可能有决策。</p>
<h2 id="反对意见的运用"><a class="header-anchor" href="#反对意见的运用">#</a>反对意见的运用</h2>
<p>为什么该有反面意见，主要有三项理由：</p>
<ol>
<li>唯有反面意见，才能保护决策者不致沦为组织的俘虏。在一个组织中，所有人都必有求于决策者，每个人都各有所求，都希望主管的决策能对自己有利。唯一能突破这一陷阱，使决策者不致成为某方面的俘虏的办法，就在于引起争辩、掌握实据和经过深思熟虑的反面意见。</li>
<li>反面意见本身，正是决策所需的“另一方案”。决策时只有一种方案，别无其他选择，无论多么深思熟虑，那与赌博何异？如果在决策过程中原有若干方案可供选择，则决策者进可攻、退可守，有多方思考和比较的余地。反之，舍此以外别无他途，决策人在遇到该决策行不通的时候，就只有背水一战了。</li>
<li>反面意见可以激发想象力。不同意见，特别是那些经过缜密推断和反复思考的、论据充分的不同意见，便是激发想象力的最为有效的因素。</li>
</ol>
<p>有效的管理者会运用反面意见。只有这样，他才能避免为“似是而非”的看法所征服；他才能得到“替代方案”，以供他选择和决定；他也才能在万一决策行不通时不至于迷惘。同时，鼓励反面意见，可以启发他本人的想象力，启发与他共事者的想象力。</p>
<p>反面意见能把“言之有理”者转化为“正确”，再把“正确”转化为“良好的决策”。</p>
<p>有效的管理者知道世上有蠢才，也有恶作剧的人。但是，他绝不会将持不同意见者轻易地视为蠢才或捣蛋者，他总是假定任何人提出不同的意见，必是出于至诚。某人的意见纵然错了，也是由于此人所看到的现实不同，或他所关切的是另一个不同的问题。因此，有效的管理者会问：“如果此人的立场果真正当、果真合理、果真有见地的话，此人的看法又将如何呢？”有效的管理者关切的是“理解”。只有在有了确切的理解之后，他才研究谁是谁非。</p>
<p>身为管理者，不论他本身刻意求好之心如何迫切，也不论他如何自信看出了别人的错误，只要他打算做一项正确的决策，就会将了解“对方”作为他探求“另一方案”的方法。见解的冲突正是他的“工具”，运用这项“工具”，他才能保证自己看清问题的每一面。</p>
<p>做一项决策像动一次外科手术。任何新的决策都不免影响既有的制度，因此多少得冒风险。外科医师不到非动手术不可的时候绝不轻言开刀；同样地，不到非做决策的时候，也不宜轻易做出决策。什么时候需要决策？如果继续保守成规，情况就会恶化，那就必须做出新的决策。遇有新的机会来临，而且这个新的机会至关重要、稍纵即逝的时候，也必须立刻做出新的决策。</p>
<p>决策的反面是不做任何决策。有时候不做任何改变，事情也不会出问题。我们问：“保持现状，会有什么后果？”如果答案是：“不会有变化。”那我们又何必横生枝节？即使问题颇为恼人，但问题并不重要，也不致有什么严重后果，那我们也没有改变的必要。2000 年前罗马律法就曾说过：“行政长官不宜考虑鸡毛蒜皮之类的事情。”直到今天，我们的决策者还是需要好好学习这句话。</p>
<p>有效的管理者会做比较：做了新决策，可能有什么收获和风险；不做又可能有什么损失。至于如何比较，通常没有一定的公式。但是，实际上只要遵循下面两项原则就够了：</p>
<ul>
<li>如果利益远大于成本及风险，就该行动；</li>
<li>行动或不行动，切忌只做一半或折中。</li>
</ul>
<p>一切条件具备，现在就只等着决策了。规范已经清楚了，不同方案已经想到了，得失也衡量了。一切都已经一目了然，应该采取什么行动，也已经清清楚楚。该采取什么决策，已是明摆着的了。不幸的是，绝大多数决策是在此时流产的。决策者这才“恍然大悟”，原来决策那么难受，那么不受欢迎，那么不容易。到了这一步，不但需要判断，更需要勇气。到了这一步，有效的管理者绝不会说：“让我们再研究研究！”那只证明这位管理者缺乏胆识。没有胆识的人可能失败一千次，有胆识的人则只失败一次。面对“再研究研究”的呼声，卓有成效的管理者会问：“是不是再做一次研究就能讨论出新方案来？即使研究出新的方案，它是不是一定比现有的方案好？”如果答案是否定的，那么管理者就不需要再去做任何研究，他绝不会因为自己的优柔寡断再去浪费别人的时间。</p>
<p>组织雇用管理者并不是要他去做他自己喜欢做的事。管理者的责任是要把该做的事做好，具体地说，就是要进行有效的决策。</p>
]]></content>
      <tags>
        <tag>摘抄</tag>
        <tag>管理</tag>
      </tags>
  </entry>
  <entry>
    <title>《Learn OpenGL》 Ch 01 Hello Window</title>
    <url>/ch_01_hello_window/</url>
    <content><![CDATA[<div class="note primary simple"><p>本部分的实现代码，见 <a href="https://github.com/xuejiaW/LearnOpenGL/tree/main/_01_HelloWindow">01_CreateWindow</a></p>
</div>
<p>在 <a href="/ch_00_creating_a_window">Ch 00 Creating a Window</a> 的最后，我们通过一系列代码绘制出了一个纯色的面板，但并没有解释相关的代码。在这一章中，我们将从 0 逐步解释这些代码。</p>
<h1 id="引入相关库"><a class="header-anchor" href="#引入相关库">#</a>引入相关库</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br></pre></td></tr></table></figure>
<h1 id="初始化GLFW"><a class="header-anchor" href="#初始化GLFW">#</a>初始化GLFW</h1>
<p>在 <code>main</code> 函数的最开始，初始化 <code>GLFW</code> 库，后续将使用 <code>GLFW</code> 来创建窗口。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glfwInit</span>();</span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br></pre></td></tr></table></figure>
<p><code>glfwWindowHint</code>函数的第一个参数用来表示要设定的参数，所有参数都是以<code>GLFW_</code>开头，函数的第二个参数是需要设定的值。 <code>glfwWindowHint</code>接受的参数与参数值，可以在<a href="https://www.notion.so/Hellow-Window-8043f836bef641dcb87856decf739229">GLFW文档</a>中设置。</p>
<h1 id="创建GLFW窗口"><a class="header-anchor" href="#创建GLFW窗口">#</a>创建GLFW窗口</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">GLFWwindow *window = <span class="built_in">glfwCreateWindow</span>(SCR_WIDTH, SCR_HEIGHT, <span class="string">&quot;LearnOpenGL&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">glfwMakeContextCurrent</span>(window);</span><br></pre></td></tr></table></figure>
<p>通过<code>glfwCreateWindow</code>函数创建窗口，前两个参数设置窗口的宽和高，第三个参数设置窗口名，最后两个参数教程中未做解释。该函数会返回一个<code>GLFWWINDOW</code>类型的指针。</p>
<p><code>glfwMakeContextCurrent</code>将<code>glfwCreateWindow</code>返回的表示窗口的指针绑定给当前线程环境。</p>
<h1 id="初始化GLAD"><a class="header-anchor" href="#初始化GLAD">#</a>初始化GLAD</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>GLAD</code>用来管理OpenGL函数的地址，因此在调用任何的OpenGL函数前需要先对<code>GLAD</code>进行初始化。</p>
<p>需要给<code>gladLoadGLLoader</code>指定读取函数地址的函数，函数地址是系统相关的。在绑定了窗口后，可以通过<code>glfwGetProcAddress</code>函数获取到相应系统给出的函数地址。</p>
<p>因此需要先初始化<code>GLFW</code>，绑定<code>GLFW</code>窗口，再初始化<code>GLAD</code>，然后才能使用OpenGL相应的函数。</p>
<h1 id="渲染循环"><a class="header-anchor" href="#渲染循环">#</a>渲染循环</h1>
<p>此时在主函数中，就可以设置渲染循环，在其中只要 <code>glfwWindowShouldClose</code> 不返回 <code>true</code>，就意味着窗口不应该被关闭。当窗口不关闭时，就需要进行一系列的渲染操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">    <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">    <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>glClearColor</code>设置<code>ClearColor</code>的颜色。</p>
<p><code>glClear</code>设置需要清理的对象，这里仅清理颜色缓存。</p>
<p><code>glfwSwapBuffers</code>设置双缓冲。如果仅使用单缓存时可能会有图像闪烁的原因，因为图像并不是瞬间被画出，而是从左至右，从下至上逐像素画出。为避免这种情况的发生，可以用双缓存，当前缓存在显示时，后缓存进行读取，当后缓存读完，交换前后缓存，如此，图像可瞬间画出。</p>
<p><code>glfwPollEvents</code>用来检查是否有事件触发，包括键盘事件，鼠标事件，和窗口事件等。（即使不需要处理输入，也仍然要设定该函数）。</p>
<h1 id="按键处理"><a class="header-anchor" href="#按键处理">#</a>按键处理</h1>
<p>设置函数 <code>processInput</code> 处理按键信息：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)</span><br><span class="line">        <span class="built_in">glfwSetWindowShouldClose</span>(window, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>glfwGetKey</code>用来获取当前窗口按下的按键。 <code>glfwSetWindowShouldClose</code>设置当前窗口需要被关闭，调用该函数后，窗口会被关闭。</p>
<p><code>processInput</code>函数需要在函数主循环中被调用，保证一直检查输入状态。</p>
<p>在<a href="/ch_01_hello_window/#%E6%B8%B2%E6%9F%93%E5%BE%AA%E7%8E%AF">渲染循环</a> 的最开始调用 <code>processInput</code> 函数，保证在渲染前处理的按键信息：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window)) &#123;</span><br><span class="line">    <span class="built_in">processInput</span>(window);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="Viewport设置"><a class="header-anchor" href="#Viewport设置">#</a>Viewport设置</h1>
<p>当缩放窗口时，需要重新调用 <code>glViewport</code> 以保证渲染的范围与窗口的大小匹配。</p>
<p>为做到这一点，我们定义函数 <code>framebuffer_size_callback</code> 作为窗口大小改变时的回调函数，在回调中通过 <code>glViewport</code> 函数设置视口：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow *window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 <code>glfwSetFramebufferSizeCallback</code> 将函数 <code>framebuffer_size_callback</code> 设置为窗口大小改变时的回调函数。因为注册回调只需要一次，因此将其放在渲染循环前：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glfwSetFramebufferSizeCallback</span>(window, framebuffer_size_callback);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Main Loop</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="终止GLFW"><a class="header-anchor" href="#终止GLFW">#</a>终止GLFW</h1>
<p>在主函数的最后，调用 <code>glfwTerminate</code> 关闭窗口：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Reference"><a class="header-anchor" href="#Reference">#</a>Reference</h1>
<p><a href="https://learnopengl.com/Getting-started/Hello-Window">LearnOpenGL - Hello Window</a></p>
]]></content>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>《Learn OpenGL》 Ch 02 Hello Triangle</title>
    <url>/ch_02_hello_triangle/</url>
    <content><![CDATA[<div class="note primary simple"><p>本部分的实现代码，见 <a href="https://github.com/xuejiaW/LearnOpenGL/tree/main/_02_HelloTriangle">02_HelloTriangle</a></p>
</div>
<h1 id="渲染管线"><a class="header-anchor" href="#渲染管线">#</a>渲染管线</h1>
<p>将三维坐标系的内容转换为二维像素的过程是通过 OpenGL 的 渲染管线 控制的，渲染管线可以被进一步拆分为两个部分：第一个是将三维坐标系内容转换为二维坐标系内容，第二个是将二维坐标系内容转换为二维像素。</p>
<h1 id="顶点数据"><a class="header-anchor" href="#顶点数据">#</a>顶点数据</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">0.0f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>顶点的位置定义是放在 <code>标准化设备坐标系（Normalized Device Coordinates, NDC）</code> 下的，该坐标系是一个从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1.0</mn><mo>∼</mo><mn>1.0</mn></mrow><annotation encoding="application/x-tex">-1.0\sim 1.0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">1.0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1.0</span></span></span></span>的坐标系，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0,0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span>点处于屏幕的中心。而屏幕坐标系下，坐标系的数值是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>∼</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0\sim 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0,0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span>出现在屏幕的左上角。标准化设备坐标系如下图所示：</p>
<p><img src="/ch_02_hello_triangle/image-20211214233002415.png" alt=""></p>
<p>从标准化设备坐标系转换到屏幕坐标系是依赖 <code>glViewport</code> 函数。</p>
<div class="note warning simple"><p>在OpenGL的NDC坐标系下，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(-1,-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>点处在屏幕的左下角。而在 DX 和VulKan中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(-1,-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>在左上角</p>
</div>
<h1 id="顶点缓冲对象"><a class="header-anchor" href="#顶点缓冲对象">#</a>顶点缓冲对象</h1>
<p>为了存储顶点数据，需要再 GPU 上开辟出一块内存，在 OpenGL 中通过 <code>顶点缓冲对象（vertex buffer objects， VBO）</code>管理这块内存。通过 VBO，可以一次性的发送多个顶点数据，避免重复运行从 CPU 发送顶点数据到 GPU 这一复杂的操作。</p>
<p>生成顶点缓冲对象的步骤如下所示</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">GLuint vbo;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;vbo);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>glGenBuffers</code> 函数为新对象生成了一个 ID，并将新 ID 值赋值给传入的引用。</li>
<li><code>glBindBuffer</code> 函数将新缓冲绑定至目标类型，VBO 的类型为 <code>GL_ARRAY_BUFFER</code>。</li>
<li><code>glBufferData</code> 函数将数据填充到缓冲中，前三个参数都好理解，最后一个参数会决定 GPU 将如何管理这块内存，因为这里装填了顶点信息后，后期并不会有关于顶点的修改，所以这里设为了 <code>GL_STATIC_DRAW</code>。如果有大量修改，可以设为 <code>GL_DYNAMIC_DRAW</code> ，这样 GPU 就会将信息放到高速访问的内存中，保证之后修改时的效率。</li>
</ul>
<p>vertices 数据是定义在内存中的， glBufferData 操作是将内存中的 vertices 数据拷贝到显存中由 VBO 表示的地址中去。</p>
<p>虽然是拷贝，但在调用 glBufferData 后仍然不建议修改 vertices ，因为可能会造成 管线堵塞 （Pipeline stall）的问题</p>
<h1 id="索引缓冲对象"><a class="header-anchor" href="#索引缓冲对象">#</a>索引缓冲对象</h1>
<div class="note primary simple"><p>索引缓冲对象并不是必须的</p>
</div>
<p>通常来说，图形都是由三角形构成，如一个四边形就是由两个三角形构成的。这两个三角形可以通过设置六个点来进行绘制，但这样实际上浪费了内存，一个四边形最少需要四个点就可以确定。而当设置四个点时，需要告诉 OpenGL，这些点该如何组合构成两个三角形。这个步骤需要通过 <code>索引缓冲对象（Element Buffer Objects，EBO）</code>来完成。</p>
<p>索引缓冲对象的类型为 <code>GL_ELEMENT_ARRAY_BUFFER</code>，其余的绑定流程与 VBO 即为类似，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">GLuint ebo;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;ebo);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, ebo);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="built_in">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure>
<p>其中的 <code>indices</code> 为索引值，顶点数据和索引值可以如下设置：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> indices[] = &#123;  <span class="comment">// note that we start from 0!</span></span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>,   <span class="comment">// first triangle</span></span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>    <span class="comment">// second triangle</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>表示第 0，1，3 个顶点构成一个三角形，第 1，2，3 个顶点构成另一个三角形。</p>
<h1 id="链接顶点数据"><a class="header-anchor" href="#链接顶点数据">#</a>链接顶点数据</h1>
<p>如之前所述，顶点数据中可能会包含多种信息，如位置，颜色，法线。因此在通过 VBO 传递了顶点数据后，OpenGL 仍然不知道该如何正确的解析顶点数据，这里就需要用到函数 <code>glVertexAttribPointer</code> 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p><code>glVertexAtrribPointer</code> 函数中：</p>
<ul>
<li>第一个参数为需要配置的顶点数据，0 即表示顶点着色器中的 <code>Position 0</code>，1 则表示顶点着色器中的 <code>Position 1</code>。</li>
<li>第二个参数是顶点数据的大小，如果传递的是 <code>vec3</code> ，则参数应该为 3。</li>
<li>第三个是参数类型，这里是 GL_FLOAT</li>
<li>第四个是是否 需要标准化，即换到 0~1 的区间内</li>
<li>第五个是步长，即一组数据的总大小，比如有一组顶点数据同时存有位置和颜色，各 3 个数值，则这里应该是 6_sizeof(GLfloat)，我们这里仅有位置，所以是 3_sizeof(GLfloat)</li>
<li>最后一个是偏移量，如果同时需要设置位置和颜色，则前 3 为位置，后 3 为颜色，当设定颜色时偏移量应该是 <code>(GLvoid*)3*sizeof(GLfloat)</code></li>
</ul>
<p><code>glEnableVertexAttribArray</code> 则是应用之前的操作，其参数与 <code>glVertexAttribPointer</code> 的第一个参数相同。</p>
<div class="note primary simple"><p>链接顶点数据是针对于当前绑定的 vbo 而言的</p>
</div>
<h1 id="顶点数组对象"><a class="header-anchor" href="#顶点数组对象">#</a>顶点数组对象</h1>
<p><code>顶点数组对象（vertex array object，VAO）</code> 如同 VBO 类似，也是个物体，因此同样需要经过生成数组 ID，绑定数组等操作。VAO 的存在是为了管理顶点数据的链接操作，当绑定了一个 VAO 后，各种关于顶点属性的解释都会被存储在这个 VAO 中。</p>
<p>因此关于顶点数据的整个流程如下图所示，VAO 管理了一系列顶点数据的链接过程，而每个数据的链接又与当前绑定的 VBO 相关。同时，VAO 也可以管理 EBO （索引缓冲对象）。</p>
<p><img src="/ch_02_hello_triangle/image-20211214233259386.png" alt=""></p>
<p>VAO 创建代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> vao = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;vao);</span><br></pre></td></tr></table></figure>
<p>完整流程代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 绑定VAO</span></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(vao);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成并绑定 VBO</span></span><br><span class="line">GLuint vbo;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;vbo);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成并绑定 EBO</span></span><br><span class="line">GLuint ebo;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;ebo);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, ebo);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="built_in">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置顶点属性指针</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(<span class="number">0</span>));</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时 VAO 已经设置完成，解绑 VBO，EBO，VAO</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="number">0</span>); <span class="comment">// 必须在解绑VAO后才能解绑EBO</span></span><br></pre></td></tr></table></figure>
<div class="note warning simple"><p>在解绑 VAO 前不可解绑 EBO，因为 VAO 中包含了 EBO 的设置，如果在 VAO 解绑前解绑 EBO，相当于在 VAO 中删除了相关的设置。</p>
<p>但在解绑 VAO 前可以解绑 VBO，这是因为 VAO 中包含的并不是 VBO 本身，而是关于VBO中数据该如何解析的设置</p>
</div>
<h1 id="着色器"><a class="header-anchor" href="#着色器">#</a>着色器</h1>
<p>在之前的部分中，已经完成了将顶点数据传递给 GPU 的操作，但 GPU 并不知道如何处理这些数据，这就需要着色器来完成。着色器是运行在 GPU 上的小程序，用来处理图形的各个部分。</p>
<p>着色器最少需要两个，一个是顶点着色器，一个是片段着色器。</p>
<h2 id="顶点着色器"><a class="header-anchor" href="#顶点着色器">#</a>顶点着色器</h2>
<p>顶点着色器是处理顶点数据的着色器，最简单的顶点着色器如下所示：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(aPos.x, aPos.y, aPos.z, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>gl_Position</code> 为 OpenGL 预定义的变量，表示顶点在 <code>裁剪空间(Clipping Space)</code> 下的位置。</p>
<h2 id="片段着色器"><a class="header-anchor" href="#片段着色器">#</a>片段着色器</h2>
<p>最简单的片段着色器如下：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    FragColor = <span class="type">vec4</span>(<span class="number">1.0</span>f, <span class="number">0.5</span>f, <span class="number">0.2</span>f, <span class="number">1.0</span>f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>片段着色器必须返回一个 <code>vec4</code> 变量表示像素最终的颜色。</p>
<p>当定义好了着色器后，需要将其编译，并链接给程序，这样 GPU 才能正确的处理数据。</p>
<h2 id="着色器编译"><a class="header-anchor" href="#着色器编译">#</a>着色器编译</h2>
<p>编译着色器的流程如下，它还是传统的生成 ID，绑定 ID 的流程，数据操作的流程：</p>
<p>下面以生成 fragment shader 为例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> fragmentShader;</span><br><span class="line">fragmentShader = <span class="built_in">glCreateShader</span>(GL_FRAGMENT_SHADER);</span><br><span class="line"><span class="built_in">glShaderSource</span>(fragmentShader, <span class="number">1</span>, &amp;shaderSource, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">glCompileShader</span>(fragmentShader);</span><br></pre></td></tr></table></figure>
<p>其中函数 <code>glShaderSource</code> 用来绑定 shader 的源码，第一个形参为 ID，第二个形参为源码的数量，第三个参数类型必须是 <code>const GLchar*</code>，即需要将着色器文件读取成 C 风格字符串后传递给形参 <code>shaderSource</code>，第四个参数设为 NULL 表示源码长度不限定长度。</p>
<p>顶点着色器和片段着色器都应该用类似的流程进行编译。</p>
<p>编译结果可以通过以下代码进行检查：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">GLint success;</span><br><span class="line">GLchar infoLog[<span class="number">512</span>];</span><br><span class="line"><span class="built_in">glGetShaderiv</span>(fragmentShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line"><span class="keyword">if</span>(!success)</span><br><span class="line">	<span class="built_in">glGetShaderInfoLog</span>(id, <span class="number">512</span>, <span class="literal">nullptr</span>, infoLog);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Error in shader&quot;</span>&lt;&lt; infoLog &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<h2 id="着色器链接"><a class="header-anchor" href="#着色器链接">#</a>着色器链接</h2>
<p>当着色器都编译后，需要链接给程序，流程如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> shaderProgram;</span><br><span class="line">shaderProgram = <span class="built_in">glCreateProgram</span>();</span><br><span class="line"><span class="built_in">glAttachShader</span>(shaderProgram, vertexShader);</span><br><span class="line"><span class="built_in">glAttachShader</span>(shaderProgram, fragmentShader);</span><br><span class="line"><span class="built_in">glLinkProgram</span>(shaderProgram);</span><br></pre></td></tr></table></figure>
<p>在将着色器链接给程序后，就可以将两个着色器程序删除</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glDeleteShader</span>(vertexShader);</span><br><span class="line"><span class="built_in">glDeleteShader</span>(fragmentShader);</span><br></pre></td></tr></table></figure>
<p>链接的结果可以通过以下代码进行检查：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">GLint success;</span><br><span class="line">GLchar infoLog[<span class="number">512</span>];</span><br><span class="line"><span class="built_in">glGetProgramiv</span>(id, GL_LINK_STATUS, &amp;success);</span><br><span class="line"><span class="keyword">if</span>(!success)</span><br><span class="line">	<span class="built_in">glGetProgramInfoLog</span>(id, <span class="number">512</span>, <span class="literal">nullptr</span>, infoLog);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Error in shader&quot;</span> &lt;&lt; infoLog &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<h2 id="封装_Shader"><a class="header-anchor" href="#封装_Shader">#</a>封装 Shader</h2>
<p>关于 Shader 的读取，编译，链接等过程都可以封装进一个头文件<a href="https://github.com/xuejiaW/LearnOpenGL/blob/main/utilities/Shader.h">Shader.h</a>。当外部使用者使用头文件时，仅需要如下代码即可：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Shader <span class="title">shader</span><span class="params">(<span class="string">&quot;./vertex.vert&quot;</span>, <span class="string">&quot;./fragment.frag&quot;</span>)</span></span>;</span><br><span class="line">shader.<span class="built_in">use</span>();</span><br></pre></td></tr></table></figure>
<h1 id="绘制"><a class="header-anchor" href="#绘制">#</a>绘制</h1>
<p>之前已经准备好了所有绘制需要的内容，即 VAO 的创建和绑定（VAO 中又管理了 VBO 和 EBO）和着色器的编译与链接。之后直接进行绘制即可，绘制前需要绑定 VAO，确认当前绘制的顶点对象，还需要使用着色器程序，确认当前要使用的着色器</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">glUseProgram</span>(shaderProgram);</span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO);</span><br></pre></td></tr></table></figure>
<p>之后在渲染循环中，调用绘制命令即可。注意使用了 EBO 和不适用 EBO 时绘制的命令是不同的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// With EBO</span></span><br><span class="line"><span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Without EBO</span></span><br><span class="line"><span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p><code>glDrawElements</code> 函数中，第一个参数为绘制的图元类型，可选的还有 <code>GL_POINT</code>， <code>GL_LINE_STRIP</code> 等。第二个参数为需要绘制的顶点数量，第三参数为 EBO 的数据 <code>indices</code> 设置的类型，第四个参数是需要从 <code>indices</code> 的哪个索引开始读取。</p>
<p><code>glDrawArrays</code> 函数中，第一个参数同样为绘制的图元类型，第二个参数为 VBO 中的数据， <code>vertices</code> 中开始的索引值，第三个参数为需要绘制的顶点数量</p>
<p>当一切完成后，运行代码的结果为：</p>
<p><img src="/ch_02_hello_triangle/image-20211214233511740.png" alt=""></p>
]]></content>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
</search>
