<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Custom SRP - Custom Render Pipeline | 三叔胡言乱语的地方</title><meta name="author" content="三叔"><meta name="copyright" content="三叔"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="该部分讲述了使用自定义的渲染管线在 Editor 和 Game 界面中绘制一系列 &#96;Unlit&#x2F;Color&#96; 的物体以及 Skybox。">
<meta property="og:type" content="article">
<meta property="og:title" content="Custom SRP - Custom Render Pipeline">
<meta property="og:url" content="https://tuncle.blog/custom_render_pipeline/index.html">
<meta property="og:site_name" content="三叔胡言乱语的地方">
<meta property="og:description" content="该部分讲述了使用自定义的渲染管线在 Editor 和 Game 界面中绘制一系列 &#96;Unlit&#x2F;Color&#96; 的物体以及 Skybox。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tuncle.blog/img/avatar.jpg">
<meta property="article:published_time" content="2024-03-23T04:48:00.000Z">
<meta property="article:modified_time" content="2024-03-30T16:00:00.000Z">
<meta property="article:author" content="三叔">
<meta property="article:tag" content="Unity">
<meta property="article:tag" content="SRP">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tuncle.blog/img/avatar.jpg"><link rel="shortcut icon" href="/img/avatar.jpg"><link rel="canonical" href="https://tuncle.blog/custom_render_pipeline/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-2QHMY59T5S"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-2QHMY59T5S');
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":true,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":200,"languages":{"author":"作者: 三叔","link":"链接: ","source":"来源: 三叔胡言乱语的地方","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Custom SRP - Custom Render Pipeline',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-03-31 00:00:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="三叔胡言乱语的地方" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">94</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-list"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-paw"></i><span> 我的</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li><li><a class="site-page child" href="/reading/"><i class="fa-fw fas fa-book"></i><span> 阅读</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/atom.xml"><i class="fa-fw fas fa-rss"></i><span> RSS</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img fixed" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="三叔胡言乱语的地方"><span class="site-name">三叔胡言乱语的地方</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-list"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-paw"></i><span> 我的</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li><li><a class="site-page child" href="/reading/"><i class="fa-fw fas fa-book"></i><span> 阅读</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/atom.xml"><i class="fa-fw fas fa-rss"></i><span> RSS</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Custom SRP - Custom Render Pipeline</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-03-23T04:48:00.000Z" title="发表于 2024-03-23 12:48:00">2024-03-23</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>20分钟</span></span><span class="post-meta-separator">|</span><span class="leancloud_visitors" id="/custom_render_pipeline/" data-flag-title="Custom SRP - Custom Render Pipeline"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span class="leancloud-visitors-count"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><div class="note info simple"><p>该教程部分完成的工程状态可见：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/xuejiaW/CustomSRP/releases/tag/CustomRenderPipeline">Custom Render Pipeline</a></p>
</div>
<h1 id="A_new_Render_Pipeline"><a class="header-anchor" href="#A_new_Render_Pipeline">#</a>A new Render Pipeline</h1>
<p>早期的 Unity 仅支持 <code> 内置渲染管线（Default Render Pipeline, DRP / Built-in Render Pipleline）</code>。自 Unity 2018 后，Unity 引入了 <code> 可编程渲染管线（Scriptable Render Piplelines，SRP）</code> ，但在 2018 中该功能是试验预览的状态，在 Unity 2019 中该功能才成为 正式功能。</p>
<p>基于 <code>SRP</code> ，Unity 官方在 2018 的版本中实现了两套管线， <code>Lightweight Render Pipeline</code> 和 <code>High Definition Render Pipeline</code> 。前者针对于移动端这样的轻量级平台，而后者针对如 PC，主机这样的高性能平台。在 Unity 2019 的版本中， <code>Lightweight Render Pipeline</code> 被拓展为 <code>Universal Render Pipeline</code> 。</p>
<div class="note info simple"><p><code>Lightweight Render Pipeline</code> 和 <code>Universal Render Pipeline</code> 实际上是同一套管线，<code>Lightweight Render Pipeline</code> 仅是 Unity 2018 中的早期实现版本的命名。</p>
</div>
<div class="note info simple"><p><code>Universal Render Pipeline</code> 计划最终取代目前的内置渲染管线，成为 Unity 渲染的默认渲染管线。</p>
</div>
<h2 id="Project_Setup"><a class="header-anchor" href="#Project_Setup">#</a>Project Setup</h2>
<div class="note primary simple"><p>该笔记使用的 Unity 版本为 2022.3.12f1</p>
</div>
<h3 id="Color_Space"><a class="header-anchor" href="#Color_Space">#</a>Color Space</h3>
<p>Unity 工程的默认色彩空间 Gamma，而为了保证后续光照等计算的准确性，首先需要将颜色空间切换为线性空间，可通过 <code>Edit -&gt; Project Settings -&gt; Player -&gt; Other Settings -&gt; Rendering -&gt; Color Space</code> 修改。</p>
<h3 id="Sample_Scene"><a class="header-anchor" href="#Sample_Scene">#</a>Sample Scene</h3>
<p>在场景中随意放置一些 Cube 和 Sphere，并附加不同的材质，结果如下图所示：</p>
<p><img src="/custom_render_pipeline/crp.png" alt=""></p>
<p>所使用的材质设置如下图所示：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="/custom_render_pipeline/crp1.png" alt="Red"></td>
<td><img src="/custom_render_pipeline/crp2.png" alt="Blue"></td>
<td><img src="/custom_render_pipeline/image-20220124092928056.png" alt="Green/Yellow/White"></td>
</tr>
</tbody>
</table>
<h2 id="Pipeline_Asset"><a class="header-anchor" href="#Pipeline_Asset">#</a>Pipeline Asset</h2>
<div class="note primary simple"><p>SRP 相关的脚本基本都在 <code>UnityEngine.Rendering</code> 命名空间下，且 SRP 已经在引擎内包含，因此此时并不需要额外导入其他的 Package。</p>
</div>
<p>当使用 <code>SRP</code> 时，Unity 引擎需要通过 <code>RenderPipe Asset(RP Asset)</code> 来获取渲染管线的实例，同时也会从 <code>RP Asset</code> 中读取关于渲染管线的设置。</p>
<p>为了创建 <code>RP Asset</code> ，首先需要创建对应的 <code>ScriptableObject</code> 。可以通过继承 <code>RenderPipelineAsset</code> 基类创建出可以构建 <code>RP Asset</code> 的 <code>ScriptableObject</code> 。如下所示：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Rendering;</span><br><span class="line"></span><br><span class="line">[<span class="meta">CreateAssetMenu(menuName = <span class="string">&quot;Rendering/Custom Render Pipeline&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomRenderPipelineAsset</span> : <span class="title">RenderPipelineAsset</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> RenderPipeline <span class="title">CreatePipeline</span>()</span> &#123; <span class="keyword">return</span> <span class="literal">null</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有派生自 <code>RenderPipelineAsset</code> 的类都必须实现 <code>CreatePipeline</code> 函数，Unity 使用该函数获取渲染管线的实例。</p>
<p>之后可以通过 <code>Assets -&gt; Create -&gt; Rendering -&gt; Custom Render Pipeline</code> 创造出 <code>RP Asset</code> ，结果如下所示：<br>
<img src="/custom_render_pipeline/crp3.png" alt=""></p>
<p>可以通过 <code>Project Settings -&gt; Graphics -&gt; Scriptable Render Pipeline Settings</code> 将自定义的 <code>RP Asset</code> 设置给 Unity，如下所示：<br>
<img src="/custom_render_pipeline/crp4.png" alt=""></p>
<p>当替换后了 <code>RP Asset</code> 后，主要有两个变化：</p>
<ol>
<li>
<p>原 <code>Graphics</code> 面板中的许多设置消失了。<br>
因为替换的 <code>RP Asset</code> 并没有提供相关的设置选项。</p>
</li>
<li>
<p>Scene / Game / Material 界面都不再渲染任何东西<br>
因为替换的 <code>RP Asset</code> 实际上返回的是空，即 Unity 此时没有任何的渲染管线可以用。</p>
</li>
</ol>
<h2 id="Render_Pipeline_Instance"><a class="header-anchor" href="#Render_Pipeline_Instance">#</a>Render Pipeline Instance</h2>
<p>为了创建出一个渲染管线，需要通过继承 <code>RenderPipeline</code> 构建自定义的渲染管线类，所有的派生自 <code>RenderPipeline</code> 的类都必须实现 <code>Render</code> 函数，Unity 在每一帧通过触发该函数进行渲染，如下所示：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Rendering;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomRenderPipeline</span> : <span class="title">RenderPipeline</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Render</span>(<span class="params">ScriptableRenderContext context, Camera[] cameras</span>)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Render</span>(<span class="params">ScriptableRenderContext context, List&lt;Camera&gt; cameras</span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note primary simple"><p>可以看到上述的实现中，对于 <code>Render</code> 函数有两个重载，其分别有 <code>Camera[]</code> 和 <code>List&lt;Camera&gt;</code> 的形参，在 Unity 2022 之前， 引擎仅支持形参为 <code>Camera[]</code> 的重载版本。而在 Unity 2022 之后，引擎又引入了形参为 <code>List&lt;Camera&gt;</code> 的重载版本。<br>
为了后续的遍历的便捷性，这里使用 <code>List&lt;Camera&gt;</code> 版本的重载，对于 <code>Camera[]</code> 版本的重载，保持空实现即可。</p>
<div class="note warning simple"><p>因为形参为 <code>Camera[]</code> 的函数原先被标记为了 <code>abstract</code>，因此必须被定义。</p>
</div></div>
<p>之前的 <code>CustomRenderPipelineAsset.CreatePipeline</code> 函数就可以返回该自定义渲染管线的示例，如下所示：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> RenderPipeline <span class="title">CreatePipeline</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CustomRenderPipeline();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时 Unity 已经可以使用 <code>CustomRenderPipeline</code> 进行绘制，但此时所有的界面与之前并没有任何的区别，因为定义的 <code>CustomRenderPipeline</code> 中并没有进行任何的实质渲染。</p>
<h1 id="Rendering"><a class="header-anchor" href="#Rendering">#</a>Rendering</h1>
<p>Unity 通过 <a href="/custom_render_pipeline/#Render_Pipeline_Instance">Render Pipeline Instance</a> 中的 <code>Render</code> 函数进行渲染，<code>Render</code> 函数有两个形参：</p>
<ol>
<li>
<p><code>ScriptableRenderContext</code> ：该形参表示 <code>SRP</code> 渲染的上下文。 RP 使用该形参与 Unity Native 的渲染部分进行通信</p>
</li>
<li>
<p><code>Camera[]</code> ，该形参表示所有激活的 Cameras</p>
<p>RP 使用该形参来控制每个摄像机的渲染与不同摄像机间的渲染顺序</p>
</li>
</ol>
<h2 id="Camera_Renderer"><a class="header-anchor" href="#Camera_Renderer">#</a>Camera Renderer</h2>
<p>通过 <code>ScriptableRenderContext</code> 和 <code>Camera</code> 就可以控制每个摄像机的渲染，如可以通过自定义的 <code>CameraRenderer</code> 类来负责特定摄像机的渲染：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CameraRenderer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> ScriptableRenderContext m_RenderContext = <span class="literal">default</span>;</span><br><span class="line">    <span class="keyword">private</span> Camera m_Camera = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Render</span>(<span class="params">ScriptableRenderContext renderContext, Camera camera</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_RenderContext = renderContext;</span><br><span class="line">        m_Camera = camera;</span><br><span class="line">                <span class="comment">// ....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在之前的 <code>CustomRenderPipeline</code> 中，让每一个相机都调用 <code>CameraRenderer.Render</code> 函数，如下所示：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomRenderPipeline</span> : <span class="title">RenderPipeline</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> CameraRenderer m_Renderer = <span class="keyword">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Render</span>(<span class="params">ScriptableRenderContext context, Camera[] cameras</span>)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Render</span>(<span class="params">ScriptableRenderContext context, List&lt;Camera&gt; cameras</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        cameras.ForEach(camera =&gt; m_Renderer.Render(context, camera));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Drawing_the_Skybox"><a class="header-anchor" href="#Drawing_the_Skybox">#</a>Drawing the Skybox</h2>
<p><code>CameraRenderer.Render</code> 的功能就是渲染所有该摄像机可以看到的物体。如以下的实现，可以让 <code>CameraRender</code> 渲染出天空盒：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Render</span>(<span class="params">ScriptableRenderContext renderContext, Camera camera</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    m_RenderContext = renderContext;</span><br><span class="line">    m_Camera = camera;</span><br><span class="line"></span><br><span class="line">    Setup();</span><br><span class="line">    DrawVisibleGeometry();</span><br><span class="line">    Submit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Setup</span>()</span> &#123; m_RenderContext.SetupCameraProperties(m_Camera); &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DrawVisibleGeometry</span>()</span> &#123; m_RenderContext.DrawSkybox(m_Camera); &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Submit</span>()</span> &#123; m_RenderContext.Submit(); &#125;</span><br></pre></td></tr></table></figure>
<p>在实现中，对 <code>ScriptableRenderContext</code> 调用了一系列函数来完成绘制目的：</p>
<ul>
<li><code>SetupCameraProperties</code> 用于在 Shader 中设置摄像机相关的变量，如 View 矩阵，Projection 矩阵</li>
<li><code>DrawSkybox</code> 将渲染天空盒的命令添加到 Context 的缓冲中</li>
<li><code>Submit</code> 将 Context 缓冲中的命令添加到执行队列中。</li>
</ul>
<div class="note warning simple"><p>仅当 Camera 的 ClearFlags 是 Skybox 时， <code>DrawSkybox</code> 才会真正的将绘制天空盒的命令添加到缓冲中。</p>
</div>
<p>结果如下所示：<br>
<img src="/custom_render_pipeline/gif_2021-5-8_19-55-17.gif" alt="Draw the Skybox"></p>
<h2 id="Command_Buffers"><a class="header-anchor" href="#Command_Buffers">#</a>Command Buffers</h2>
<p>之前的 <code>DrawSkybox</code> 命令向 Context 的缓冲中增加了一条渲染天空盒的命令。除此之外，可以通过 <code>CommandBuffer</code> 类和 <code>context.ExecuteCommandBuffer</code> 函数向 Context 中添加自定义的渲染命令。</p>
<p>通过如下命令创建 <code>CommandBuffer</code>， <code>CommandBuffer</code> 的 <code>name</code> 属性可以在 <code>FrameDebugger</code> 中查看：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">string</span> k_BufferName = <span class="string">&quot;Render Camera&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> CommandBuffer m_Buffer = <span class="keyword">new</span>() &#123;name = k_BufferName&#125;;</span><br></pre></td></tr></table></figure>
<div class="note info simple"><p>FrameDebugger 可以通过 <code>Window -&gt; Analysis -&gt; Frame Debugger</code> 打开。<br>
Profiler 可以通过 <code>Window -&gt; Analysis -&gt; Profiler</code> 打开。</p>
</div>
<p>而如果想要在 <code>Profiler</code> 中调试， 则可以使用 <code>commandBuffer.BeginSample</code> 和 <code>commandBuffer.EndSample</code> API 将开始采样和结束采样的命令添加至 Command Buffer 中，再通过 <code>ScriptableRenderContext.ExecuteCommandBuffer</code> 执行 Command Buffer。如下所示：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Setup</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    m_Buffer.BeginSample(k_BufferName);</span><br><span class="line">    ExecuteCommandBuffer();</span><br><span class="line"></span><br><span class="line">    m_RenderContext.SetupCameraProperties(m_Camera);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DrawVisibleGeometry</span>()</span> &#123; m_RenderContext.DrawSkybox(m_Camera); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Submit</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    m_Buffer.EndSample(k_BufferName);</span><br><span class="line">    ExecuteCommandBuffer();</span><br><span class="line"></span><br><span class="line">    m_RenderContext.Submit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ExecuteCommandBuffer</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    m_RenderContext.ExecuteCommandBuffer(m_Buffer);</span><br><span class="line">    m_Buffer.Clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note warning simple"><p><code>BeginSample</code> 和 <code>EndSample</code> 的命名需要与 Buffer 的名称相同，否则可能会出现 <code>Non matching Profiler.EndSample (BeginSample and EndSample count must match</code> 的错误。</p>
</div>
<div class="note warning simple"><p>像 <code>BeginSample</code> 和 <code>EndSample</code> 这样的 API 每次执行都会向 Command Buffer 中增加一条命令，因此在 <code>ExecuteCommandBuffer</code> 中执行后需要对 Command Buffer 进行 <code>Clear</code> 操作，否则 Command Buffer 中的命令会越来越多。</p>
</div>
<p>此时在 Frame Debugger 中既可以看到之前添加的 Buffer Name 信息：<br>
<img src="/custom_render_pipeline/image-20240220172114.png" alt="Buffer Name in frame debugger"></p>
<p>在 Profiler Window 中也能看到相应的信息：<br>
<img src="/custom_render_pipeline/image-20240220172503.png" alt="Buffer Name in Profiler"></p>
<h2 id="Clearing_the_Render_Target"><a class="header-anchor" href="#Clearing_the_Render_Target">#</a>Clearing the Render Target</h2>
<p>可通过在 Command Buffer 中添加 <code>ClearRenderTarget</code> 命令来清除渲染目标的内容，如下所示：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Setup</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    renderContext.SetupCameraProperties(camera);</span><br><span class="line">    buffer.ClearRenderTarget(<span class="literal">true</span>, <span class="literal">true</span>, Color.clear);  <span class="comment">// Clear render target</span></span><br><span class="line">    buffer.BeginSample(k_BufferName);</span><br><span class="line">    ExecuteCommandBuffer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时可以在 Frame Debugger 中看到 <code>Clear</code> 的命令，如下所示：<br>
<img src="/custom_render_pipeline/image-20240220175057.png" alt="Clear Command"></p>
<div class="note warning simple"><p>对于增加 Clear Render Target 命令的顺序，必须严格按照上述例子，即先设置 Camera Properties，再进行 Clear，再进行 BeginSample。<br>
如果先进行了 Clear，再进行了 SetupCameraProperties，那么 Frame Debugger 中会显示 <code>Draw GL</code> 命令而非 <code>Clear</code> 命令，即 Unity 通过渲染一张铺满整个渲染目标的 Quad 来达成清除的目的，而这会消费较多的性能。如下代码就会导致渲染 Quad：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Setup</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">buffer.ClearRenderTarget(<span class="literal">true</span>, <span class="literal">true</span>, Color.clear);</span><br><span class="line">buffer.BeginSample(k_BufferName);</span><br><span class="line">ExecuteCommandBuffer();</span><br><span class="line">renderContext.SetupCameraProperties(camera);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时的 Frame Debugger 窗口将显示如下内容：<br>
<img src="/custom_render_pipeline/2024-02-20-17-33-31.png" alt="Draw GL"><br>
又因为 <code>CommandBuffer.ClearRenderTarget</code> 的实现会将 Clear 的操作放在一个以 Command Buffer 名称命名的 Sample 中，所以如下的代码将再 Frame Debugger 窗口中引发嵌套的 Sample，如下所示：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Setup</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">buffer.BeginSample(k_BufferName);</span><br><span class="line">buffer.ClearRenderTarget(<span class="literal">true</span>, <span class="literal">true</span>, Color.clear);</span><br><span class="line">ExecuteCommandBuffer();</span><br><span class="line">renderContext.SetupCameraProperties(camera);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时的 Frame Debugger 窗口将显示如下内容：<br>
<img src="/custom_render_pipeline/2024-02-20-17-36-55.png" alt="嵌套 Sample | 300"></p>
</div>
<h2 id="Culling"><a class="header-anchor" href="#Culling">#</a>Culling</h2>
<p>在正式的渲染前，为了保证仅渲染在摄像机的视锥体的内物体，需要让 Unity 进行 Culling 操作。为完成 Culling 操作，首先需要通过函数 <code>TryGetCullingParameters</code> 根据摄像机当前的状态获取到 <code>Culling</code> 相关的参数，再通过函数 <code>context.Cull</code> 将相关参数传递给渲染上下文，并得到 Culling 的结果，结果将以 <code>CullingResults</code> 表示，代码如下所示：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> CullingResults m_CullingResults = <span class="literal">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">bool</span> <span class="title">Cull</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!m_Camera.TryGetCullingParameters(<span class="keyword">out</span> ScriptableCullingParameters cullingParameters)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    m_CullingResults = m_RenderContext.Cull(<span class="keyword">ref</span> cullingParameters);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述 <code>Cull</code> 函数，返回 bool 值表示获取 Culling 参数是否成功。在某些情况下，无法通过 <code>TryGetCullingParameters</code> 函数获取到 Culling 的参数，如摄像机的 Viewport 为空，或者近远剪切平面的设置不合法。</p>
<p>对于 <code>Render</code> 函数，应当仅在 <code>Cull</code> 成功的情况下再进行渲染如下所示：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Render</span>(<span class="params">ScriptableRenderContext renderContext, Camera camera</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    m_RenderContext = renderContext;</span><br><span class="line">    m_Camera = camera;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!Cull()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note primary simple"><p>SRP 中许多函数都以 <code>ref</code> 传递数值，如 <code>context.Cull</code> 函数。但这通常是处于性能方面的考虑，避免数据的拷贝，而非是需要修改传入的参数。</p>
</div>
<h2 id="Drawing_Geometry"><a class="header-anchor" href="#Drawing_Geometry">#</a>Drawing Geometry</h2>
<p>现在可以通过 <code>context.DrawRenderers</code> 方法绘制具体的几何体，其中会用上之前获取到的 <code>CullingResults</code> 如下所示：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ShaderTagId s_UnlitShaderTagId = <span class="keyword">new</span>(<span class="string">&quot;SRPDefaultUnlit&quot;</span>);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DrawVisibleGeometry</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> sortingSettings = <span class="keyword">new</span> SortingSettings(m_Camera) &#123;criteria = SortingCriteria.CommonOpaque&#125;;</span><br><span class="line">    <span class="keyword">var</span> drawingSettings = <span class="keyword">new</span> DrawingSettings(s_UnlitShaderTagId, sortingSettings);</span><br><span class="line">    <span class="keyword">var</span> filteringSettings = <span class="keyword">new</span> FilteringSettings(RenderQueueRange.all);</span><br><span class="line"></span><br><span class="line">    m_RenderContext.DrawRenderers(m_CullingResults, <span class="keyword">ref</span> drawingSettings, <span class="keyword">ref</span> filteringSettings);</span><br><span class="line">    m_RenderContext.DrawSkybox(m_Camera);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><code>FilteringSetting</code> 决定了渲染指定 RenderQueue 范围内的物体，这里填的 <code>RenderQueueRange.all</code> 表示无论 RenderQueue 设置的为多少，都将被渲染。</li>
<li><code>DrawingSettings</code> 的第一个形参决定了需要执行的 Shader Pass， 这里传递的 <code>SRPDefaultUnlit</code> 为 Unity 内置的 Tag，因为目前场景中的许多游戏物体选用的是 <code>Unlit</code> 中的 Shader，所以使用该 Tag。</li>
</ul>
<div class="note info simple"><p>关于 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://docs.unity3d.com/Manual/SL-PassTags.html">Shader Tag</a> 的内容，查看文档 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://docs.unity3d.com/Manual/shader-predefined-pass-tags-built-in.html">Built-In Shader Tag</a> 与 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@11.0/manual/urp-shaders/urp-shaderlab-pass-tags.html#urp-pass-tags-lightmode">SRP Shader Tag</a></p>
</div>
<p><code>DrawingSettings</code> 第二个形参是物体排序相关的设置 <code>SortingSettings</code>，该变量的构造函数依赖 <code>camera</code> 变量，因为其中依赖 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://docs.unity3d.com/ScriptReference/Camera-transparencySortMode.html"><code>camera.transparencySortMode</code></a> 决定以什么规则来计算排序的数值大小：</p>
<ol>
<li>Perspective：根据摄像机与物体中心的距离</li>
<li>Orthographic：根据沿着摄像机 View 方向的距离</li>
</ol>
<p><code>SortingSettings</code> 中的 <code>criteria</code> 制定了排序的标准，如这里的 <code>CommonOpaque</code> 表示使用通常渲染不透明物体时的排序规则，该规则会综合考虑 RenderQueue，材质，距离等相关信息。</p>
<p>此时在 Frame Debugger 中查看渲染的顺序与结果，如下所示，可以看到基本是先渲染一个特定的材质，然后再渲染下一个：<br>
<img src="/custom_render_pipeline/gif_2021-5-11_23-51-01.gif" alt="渲染顺序与结果"></p>
<p>如果查看 <code>CommonOpaque</code> 的定义可以看到，它考虑了尽可能的减少渲染上下文的切换，从前至后渲染等因素：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> SortingCriteria</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>   <span class="doctag">&lt;para&gt;</span>Typical sorting for opaque objects.<span class="doctag">&lt;/para&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    CommonOpaque = CanvasOrder | OptimizeStateChanges | QuantizedFrontToBack | RenderQueue | SortingLayer, <span class="comment">// 0x0000003B</span></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note warning simple"><p>物体具体的渲染顺序受 Unity 版本 / Unity 实现影响，这里的设置 <code>criteria</code> 更多的是一种“建议”，而具体的排序算法，在 Unity 引擎内部实现，是一个相对黑盒。</p>
</div>
<p>如果将 <code>SortingSettings</code> 中的 <code>criteria</code> 去除，即：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DrawVisibleGeometry</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> sortingSettings = <span class="keyword">new</span> SortingSettings(m_Camera);</span><br><span class="line">    <span class="keyword">var</span> drawingSettings = <span class="keyword">new</span> DrawingSettings(s_UnlitShaderTagId, sortingSettings);</span><br><span class="line">    <span class="keyword">var</span> filteringSettings = <span class="keyword">new</span> FilteringSettings(RenderQueueRange.all);</span><br><span class="line"></span><br><span class="line">    renderContext.DrawRenderers(cullingResults, <span class="keyword">ref</span> drawingSettings, <span class="keyword">ref</span> filteringSettings);</span><br><span class="line">    renderContext.DrawSkybox(camera);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>则渲染的结果如下所示，几乎是一个无规律的状态在渲染：<br>
<img src="/custom_render_pipeline/gif_2021-5-11_23-54-57.gif" alt="Random Rendering"></p>
<h2 id="Drawing_Opaque_and_Transparent_Geometry_Separately"><a class="header-anchor" href="#Drawing_Opaque_and_Transparent_Geometry_Separately">#</a>Drawing Opaque and Transparent Geometry Separately</h2>
<p>在之前的最终渲染结果中，天空盒将半透明物体的一部分遮挡掉了，如下所示：<br>
<img src="/custom_render_pipeline/crp6.png" alt="Wrong Effect of Transparent Object"></p>
<p>这是因为天空盒在半透明物体的之后进行渲染，而在 <code>Unlit/Transparent</code> 的 Shader 中，设置了 <code>ZWrite Off</code> ，即半透明物体不会写入深度缓冲，因此在绘制了半透明物体的部分，天空盒仍然能通过深度检测，即覆盖半透明物体。</p>
<p>解决这个问题的方式，就是调整渲染顺序为 <code>不透明物体 -&gt; 天空盒 -&gt; 半透明物体</code> 。实现方法如下所示：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DrawVisibleGeometry</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> sortingSettings = <span class="keyword">new</span> SortingSettings(m_Camera) &#123;criteria = SortingCriteria.CommonOpaque&#125;;</span><br><span class="line">    <span class="keyword">var</span> drawingSettings = <span class="keyword">new</span> DrawingSettings(s_UnlitShaderTagId, sortingSettings);</span><br><span class="line">    <span class="keyword">var</span> filteringSettings = <span class="keyword">new</span> FilteringSettings(RenderQueueRange.opaque);</span><br><span class="line">    m_RenderContext.DrawRenderers(m_CullingResults, <span class="keyword">ref</span> drawingSettings, <span class="keyword">ref</span> filteringSettings);</span><br><span class="line"></span><br><span class="line">    m_RenderContext.DrawSkybox(m_Camera);</span><br><span class="line"></span><br><span class="line">    sortingSettings.criteria = SortingCriteria.CommonTransparent;</span><br><span class="line">    drawingSettings.sortingSettings = sortingSettings;</span><br><span class="line">    filteringSettings.renderQueueRange = RenderQueueRange.transparent;</span><br><span class="line">    m_RenderContext.DrawRenderers(m_CullingResults, <span class="keyword">ref</span> drawingSettings, <span class="keyword">ref</span> filteringSettings);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>渲染结果如下：<br>
<img src="/custom_render_pipeline/crp7.png" alt="渲染结果"></p>
<h1 id="Editor_Rendering"><a class="header-anchor" href="#Editor_Rendering">#</a>Editor Rendering</h1>
<h2 id="Drawing_Legacy_Shaders"><a class="header-anchor" href="#Drawing_Legacy_Shaders">#</a>Drawing Legacy Shaders</h2>
<p>之前通过在初始化 <code>DrawingSettings</code> 时，设置的 Shader Tag 为 <code>SRPDefaultUnlit</code> 的 Shader，因此仅会渲染 Unlit Shader 的物体。而其余的物体，如使用了 <code>Standard</code> Shader 的物体，可以通过以下 Built-in 的 Shader Tag 找到并渲染：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ShaderTagId[] s_LegacyShaderTagIds =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">new</span>(<span class="string">&quot;Always&quot;</span>),</span><br><span class="line">    <span class="keyword">new</span>(<span class="string">&quot;ForwardBase&quot;</span>),</span><br><span class="line">    <span class="keyword">new</span>(<span class="string">&quot;PrepassBase&quot;</span>),</span><br><span class="line">    <span class="keyword">new</span>(<span class="string">&quot;Vertex&quot;</span>),</span><br><span class="line">    <span class="keyword">new</span>(<span class="string">&quot;VertexLMRGBM&quot;</span>),</span><br><span class="line">    <span class="keyword">new</span>(<span class="string">&quot;VertexLM&quot;</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>之后我们新建一个用以渲染这些 Built-in Shader 的物体的函数 <code>DrawUnSupportedShadersGeometry</code> ，如下所示：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Render</span>(<span class="params">ScriptableRenderContext renderContext, Camera camera</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    Setup();</span><br><span class="line">    DrawVisibleGeometry();</span><br><span class="line">    DrawUnSupportedShadersGeometry();</span><br><span class="line">    Submit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DrawUnSupportedShadersGeometry</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> drawingSettings = <span class="keyword">new</span> DrawingSettings &#123;sortingSettings = <span class="keyword">new</span> SortingSettings(m_Camera)&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i != s_LegacyShaderTagIds.Length; ++i)</span><br><span class="line">        drawingSettings.SetShaderPassName(i, s_LegacyShaderTagIds[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> filteringSettings = FilteringSettings.defaultValue;</span><br><span class="line"></span><br><span class="line">    m_RenderContext.DrawRenderers(m_CullingResults, <span class="keyword">ref</span> drawingSettings, <span class="keyword">ref</span> filteringSettings);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的 <code>legacyShaderTagIds</code> 中指定了常用的 Built-in 的 Shader Tag，即会尝试渲染 Built-in Shader 的物体。结果如下所示，可以看到使用了 <code>Standard</code> Shader 的物体被渲染了出来：<br>
<img src="/custom_render_pipeline/2024-02-24-18-30-08.png" alt="Rendering Effect of Built-in Shader"></p>
<div class="note info simple"><p>在早期的 Unity 版本中，此时 <code>Standard</code> Shader 的物体会被渲染成黑色，这是因为早期 <code>SRP</code> 无法设置 <code>Standard</code> Shader 中的一些参数。</p>
</div>
<h2 id="Error_Material"><a class="header-anchor" href="#Error_Material">#</a>Error Material</h2>
<p>虽然在 Unity 2022 中，一些 Built-in Shader 的物体可以被渲染出来，但这仍然不健壮，且应当有明确的错误提示开发者应当将 Built-in Shader 替换为 SRP Shader，为达到这个目的，可以使用 Unity 内置的表示 Shader 错误的特殊 Shader 来渲染这些物体，只需要修改 <code>DrawingSettings</code> 中的 <code>overrideMaterial</code> 即可，如下所示：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Material s_ErrorMaterial = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DrawUnSupportedShadersGeometry</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (s_ErrorMaterial == <span class="literal">null</span>)</span><br><span class="line">        s_ErrorMaterial = <span class="keyword">new</span> Material(Shader.Find(<span class="string">&quot;Hidden/InternalErrorShader&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> drawingSettings = <span class="keyword">new</span> DrawingSettings();</span><br><span class="line">    drawingSettings.sortingSettings = <span class="keyword">new</span> SortingSettings(m_Camera);</span><br><span class="line">    drawingSettings.overrideMaterial = s_ErrorMaterial;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i != s_LegacyShaderTagIds.Length; ++i)</span><br><span class="line">        drawingSettings.SetShaderPassName(i, s_LegacyShaderTagIds[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> filteringSettings = FilteringSettings.defaultValue;</span><br><span class="line"></span><br><span class="line">    m_RenderContext.DrawRenderers(m_CullingResults, <span class="keyword">ref</span> drawingSettings, <span class="keyword">ref</span> filteringSettings);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时结果如下：<br>
<img src="/custom_render_pipeline/crp9.png" alt="渲染结果"></p>
<h2 id="Partial_Class"><a class="header-anchor" href="#Partial_Class">#</a>Partial Class</h2>
<p>可以使用 Scripting Symbols 让不支持的 Shader 部分仅在 Editor 和 Development Build 才被显示，即将相关代码定义放到如下的代码块中：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> UNITY_EDITOR || DEVELOPMENT_BUILD</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>同时为了更好的管理代码，可以将 Editor 部分放到 <code>CameraRenderer.Editor</code> 中，如下所示：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In CameraRenderer.Editor.cs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">CameraRenderer</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> UNITY_EDITOR || DEVELOPMENT_BUILD</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ShaderTagId[] legacyShaderTagIds =</span><br><span class="line">    &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Material s_ErrorMaterial = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">partial</span> <span class="keyword">void</span> <span class="title">DrawUnSupportedShadersGeometry</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in CameraRenderer.cs</span></span><br><span class="line"><span class="function"><span class="keyword">partial</span> <span class="keyword">void</span> <span class="title">DrawUnSupportedShadersGeometry</span>()</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里使用了 Partial Classes 拆分 <code>CameraRenderer</code> 类，方便代码管理。并将 <code>DrawUnSupportedShaderGeometry</code> 函数定义为 Partial Methods，保证在非 Editor 和 Development Build 时，即使 <code>DrawUnSupportedShaderGeometry</code> 未被定义实现，代码仍然能正常编译。</p>
<h2 id="Drawing_Gizmos"><a class="header-anchor" href="#Drawing_Gizmos">#</a>Drawing Gizmos</h2>
<p>目前在 Scene 场景中并没有绘制 <code>Gizmo</code> ，如场景中并没有摄像机的显示，也没有摄像机的视锥体的展示。</p>
<p>可以通过 <code>Handles.ShouldRenderGizmos</code> 判断当前帧是否需要渲染 <code>Gizmos</code> ，如需要的话可通过函数 <code>context.DrawGizmos</code> 进行绘制。</p>
<div class="note info simple"><p>Editor Scene 下的 Gizmos Toggle 会影响 <code>Handles.ShouldRenderGizmos</code> 的返回值。<br>
<img src="/custom_render_pipeline/2024-02-25-14-21-17.png" alt="Gizmos Toggle"></p>
</div>
<div class="note info simple"><p>Unity 的 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://docs.unity3d.com/ScriptReference/Handles.html">Handles</a> 存在许多关于 Gizmos 的帮助函数</p>
</div>
<p><code>Gizmos</code> 的绘制应当在整个流程的最后，最终绘制 <code>Gizmos</code> 的代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In CameraRenderer</span></span><br><span class="line"><span class="function"><span class="keyword">partial</span> <span class="keyword">void</span> <span class="title">DrawGizmos</span>()</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Render</span>(<span class="params">ScriptableRenderContext renderContext, Camera camera</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    Setup();</span><br><span class="line">    DrawVisibleGeometry();</span><br><span class="line">    DrawUnSupportedShadersGeometry();</span><br><span class="line">    DrawGizmos();</span><br><span class="line">    Submit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In CameraRenderer.Editor</span></span><br><span class="line"><span class="function"><span class="keyword">partial</span> <span class="keyword">void</span> <span class="title">DrawGizmos</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!Handles.ShouldRenderGizmos()) <span class="keyword">return</span>;</span><br><span class="line">    m_RenderContext.DrawGizmos(m_Camera,GizmoSubset.PreImageEffects);</span><br><span class="line">    m_RenderContext.DrawGizmos(m_Camera,GizmoSubset.PostImageEffects);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>context.DrawGizmos</code> 需要两个参数，第一个是表示当前 View 的 Camera， 第二个表示哪种 <code>Gizmos</code> 需要被绘制， <code>GizmoSubset.PreImageEffects</code> 表示受后处理影响的 <code>Gizmos</code> ， <code>GizmoSubset.PostImageEffects</code> 表示不受后处理影响的部分。这里选择渲染所有种类的 <code>Gizmos</code> 。渲染的结果如下：<br>
<img src="/custom_render_pipeline/crp10.png" alt="渲染结果"></p>
<h2 id="Drawing_Unity_UI"><a class="header-anchor" href="#Drawing_Unity_UI">#</a>Drawing Unity UI</h2>
<p>在场景中添加了一个 UGUI 的 Button 后，可以看到按钮在 Game 界面中被正常的渲染了出来，如下所示：<br>
<img src="/custom_render_pipeline/crp11.png" alt="Button in Game View"></p>
<p>但通过 Frame Debugger 可以发现此时 UI 的渲染并没有经过自定义的 SRP 如下所示：<br>
<img src="/custom_render_pipeline/crp12.png" alt="Frame Debugger for UI"></p>
<p>而当将 <code>Canvas</code> 中的 <code>Render Mode</code> 修改为 <code>Screen Space - Camera</code> 或 <code>World Space</code> 后，UI 的渲染被放到了渲染半透明物体的部分中，如下所示，且此时因为在半透明的队列中先渲染了 UI，所以 UI 几乎被其他物体遮挡住了：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="/custom_render_pipeline/crp13.png" alt=""></td>
<td><img src="/custom_render_pipeline/crp14.png" alt=""></td>
</tr>
</tbody>
</table>
<p>但无论 <code>Render Mode</code> 是什么格式，在 Scene 界面中，UI 都没有被正常的渲染出来，能看到的只有 UI 的 <code>Gizmo</code> ，如下：<br>
<img src="/custom_render_pipeline/crp15.png" alt=""></p>
<p>这是因为 UI 在 Scene 界面下，都是以 <code>World Space</code> 模式被渲染出来，而且用了不同的几何信息，且 UI 在 Scene 下的几何信息默认并没有被添加到 SRP 中。</p>
<p>对于在 Scene 中显示的 UI 的几何信息，需要通过函数 <code>ScriptabEmitWorldGeometryForSceneView</code> 添加到 SRP 中。且需要在调用 <code>Cull</code> 函数前被添加，保证这些几何信息同样会被进行正常裁剪。</p>
<p>整体代码如下所示：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In CameraRenderer</span></span><br><span class="line"><span class="function"><span class="keyword">partial</span> <span class="keyword">void</span> <span class="title">PrepareForSceneWindow</span>()</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Render</span>(<span class="params">ScriptableRenderContext renderContext, Camera camera</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    PrepareForSceneWindow();</span><br><span class="line">    <span class="keyword">if</span> (!Cull()) <span class="comment">// Get Culling parameters failed</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In CameraRenderer.Editor</span></span><br><span class="line"><span class="function"><span class="keyword">partial</span> <span class="keyword">void</span> <span class="title">PrepareForSceneWindow</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (camera.cameraType == CameraType.SceneView)</span><br><span class="line">    &#123;</span><br><span class="line">      ScriptableRenderContext.EmitWorldGeometryForSceneView(camera);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ScriptableRenderContext.EmitWorldGeometryForSceneView</code> 函数的描述如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span>   <span class="doctag">&lt;para&gt;</span>Emits UI geometry into the Scene view for rendering.<span class="doctag">&lt;/para&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;cullingCamera&quot;&gt;</span>Camera to emit the geometry for.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">[<span class="meta">FreeFunction(<span class="string">&quot;UI::GetCanvasManager().EmitWorldGeometryForSceneView&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">MethodImpl(MethodImplOptions.InternalCall)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">EmitWorldGeometryForSceneView</span>(<span class="params">Camera cullingCamera</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>此时在 Scene 界面下就可以看到 UI 被正确的渲染出来。</p>
<h1 id="Multiply_Cameras"><a class="header-anchor" href="#Multiply_Cameras">#</a>Multiply Cameras</h1>
<h2 id="Two_Cameras"><a class="header-anchor" href="#Two_Cameras">#</a>Two Cameras</h2>
<p>在场景中可以将 <code>Main Camera</code> 进行拷贝，并将新的 Camera 命名为 <code>Second Camera</code> ，并将 <code>Second Camera</code> 的 <code>Depth</code> 参数设置为 0，即此时会先渲染 <code>Main Camera</code> ，然后再渲染 <code>Second Camera</code> ：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="/custom_render_pipeline/crp16.png" alt="Hierarchy"></td>
<td><img src="/custom_render_pipeline/crp17.png" alt="Main Camera"></td>
<td><img src="/custom_render_pipeline/crp18.png" alt="Second Camera"></td>
</tr>
</tbody>
</table>
<p>此时在 Frame Debugger 中可以看到两个摄像机的渲染被合并在了一起，如下所示：<br>
<img src="/custom_render_pipeline/crp19.png" alt="Red For Main, Yellow For Second"></p>
<p>这是因为此时两个 Camera 对应的 <code>CameraRenderer</code> 中的 <code>Command Buffer</code> 命名相同，因此 Frame Debugger 将两者的信息合并在了一起。</p>
<p>可以通过分别对两个 Command Buffer 进行命令来分开两者的渲染信息，如下所示：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In CameraRenderer</span></span><br><span class="line"><span class="function"><span class="keyword">partial</span> <span class="keyword">void</span> <span class="title">PrepareBuffer</span>()</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Render</span>(<span class="params">ScriptableRenderContext renderContext, Camera camera</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    PrepareBuffer();</span><br><span class="line">    PrepareForSceneWindow();</span><br><span class="line">    <span class="keyword">if</span> (!Cull()) <span class="comment">// Get Culling parameters failed</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In CameraRenderer.Editor</span></span><br><span class="line"><span class="function"><span class="keyword">partial</span> <span class="keyword">void</span> <span class="title">PrepareBuffer</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    buffer.name = camera.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note info simple"><p><code>camera.name</code> 会造成内存分配，但因为 <code>PrepareBuffer</code> 是定义在 <code>CameraRender.Editor</code> 中，因此仅在 Editor 模式下运行，不会造成运行时的性能浪费。</p>
</div>
<p>此时 Frame Debugger 界面如下：<br>
<img src="/custom_render_pipeline/crp20.png" alt="Main And Second Camera|500  "></p>
<h2 id="Layers"><a class="header-anchor" href="#Layers">#</a>Layers</h2>
<p>可以调整物体的 <code>Layer</code> 以及摄像机的 <code>Culling Mask</code> 来控制摄像机仅渲染特定的游戏物体。</p>
<p>如将所有使用了 <code>Standard</code> 的游戏物体的 <code>Layer</code> 调整为 <code>Ignore Raycast</code> ，并将两个摄像机的 <code>Culling Mask</code> 设置为如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="/custom_render_pipeline/crp21.png" alt="Main Camera"></td>
<td><img src="/custom_render_pipeline/crp22.png" alt="Second Camera"></td>
</tr>
</tbody>
</table>
<p>此时的渲染结果如下，因为 Second Camera 仅渲染 <code>Ignore Raycast</code> Layer 的物体，又 Second Camera 会覆盖 Main Camera 的内容：<br>
<img src="/custom_render_pipeline/image-20240225150054.png" alt="Second Camera"></p>
<h2 id="Clear_Flags"><a class="header-anchor" href="#Clear_Flags">#</a>Clear Flags</h2>
<p>可以通过修改两个摄像机的 Clear Flags 来合并两个摄像机的渲染内容。并根据摄像机的 Clear Flags 调整 ClearRenderTarget 的逻辑，如下所示：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Setup</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    CameraClearFlags flags = camera.clearFlags;</span><br><span class="line">    buffer.ClearRenderTarget(flags &lt;= CameraClearFlags.Depth, flags == CameraClearFlags.Color,</span><br><span class="line">                flags == CameraClearFlags.Color ? camera.backgroundColor.linear : Color.clear);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>CameraClearFlags</code> 是 Unity 定义的一个枚举值，有四个参数，参数数值从 1 到 4，分别为 <code>Skybox</code> , <code>Color</code> , <code>Depth</code> , <code>Nothing</code> 。</p>
<p>上述代码中，除了 <code>Nothing</code> 的情况，都会将 Depth Buffer 清除，而仅在为 <code>Color</code> 的时候会对 Color Buffer 进行清除。在清除时，仅当为 <code>Color</code> 时使用 <code>camera.backgroundColor</code> 其余时候都用 <code>Color.clear</code> 。</p>
<div class="note info simple"><p>使用 <code>camera.backgroundColor.linear</code> 是因为项目建立时，将颜色空间设置为了 <code>Linear</code> 。</p>
</div>
<div class="note info simple"><p>理论上，在 <code>CameraClearFlags</code> 为 <code>Skybox</code> 时也应当清除 <code>Color Buffer</code> ，但因为 <code>Skybox</code> 时擦除了 Depth Buffer，又会在渲染的最后绘制 Skybox，所以上一帧的颜色内容即使不清除，也会被这一帧渲染的 Skybox 覆盖，因此不会造成显示的错误。</p>
</div>
<p><code>Main Camera</code> 作为第一个渲染的摄像机，为了保证渲染的正确性，必须使用 <code>Skybox</code> 或 <code>Color</code> 作为 Clear Flags。 <code>Second Camera</code> 为了不 Clear 掉 <code>Main Camera</code> 渲染的内容，则必须使用 <code>Depth</code> 或 <code>Nothing</code> 保证 <code>Main Camear</code> 渲染的 Color Buffer 被保持。</p>
<p>当 <code>Second Camera</code> 选择 <code>Depth</code> 时， <code>Main Camera</code> 渲染的 Depth Buffer 会被 Clear，此时 <code>Second Camera</code> 渲染的内容就都会叠加到 <code>Main Camera</code> 的内容上。</p>
<p>当 <code>Second Camera</code> 选择 <code>Nothing</code> 时， <code>Main Camera</code> 渲染的 Depth Buffer 会被保留，此时 <code>Second Camera</code> 渲染的内容就仍要与 <code>Main Camera</code> 渲染的内容进行深度检测。</p>
<p>当 <code>Main Camera</code> Clear Flags 为 <code>Skybox</code> ， <code>Second Camera</code> 的 Clear Flags 分别为 <code>Skybox</code> , <code>Color</code> , <code>Depth</code> , <code>Nothing</code> 的结果如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="/custom_render_pipeline/image-20240225150227.png" alt="Skybox"></td>
<td><img src="/custom_render_pipeline/image-20240225150301.png" alt="Color"></td>
</tr>
<tr>
<td><img src="/custom_render_pipeline/image-20240225150324.png" alt="Depth Only"></td>
<td><img src="/custom_render_pipeline/image-20240225150353.png" alt="Don't Clear"></td>
</tr>
</tbody>
</table>
<p>还可以通过调整摄像机的 <code>Viewport</code> 决定摄像机渲染结果的输出范围，如下为 <code>Second Camera</code> 的 Clear Flag 为 <code>Color</code> 且 Viewport 为 <code>(0.75, 0.75, 0.25, 0.25)</code> 时的结果：<br>
<img src="/custom_render_pipeline/crp23.png" alt=""></p>
<div class="note info simple"><p>Unity 使用 <code>Hidden/InternalClear</code> shader 来进行 Clear 操作。该 Shader 中会通过 Stencil Buffer 来实现 Camera Viewport 的效果。</p>
</div>
<div class="note info simple"><p>当有多个摄像机时，每帧每个摄像机都需要进行 <code>Culling</code>, <code>Setup</code> , <code>Sorting</code> 等操作。因此增加摄像机数量会增大对性能的消耗。</p>
</div>
<h1 id="Reference"><a class="header-anchor" href="#Reference">#</a>Reference</h1>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://catlikecoding.com/unity/tutorials/custom-srp/custom-render-pipeline/">Custom Render Pipeline (catlikecoding.com)</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="Tuncle">三叔</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://tuncle.blog/custom_render_pipeline/">https://tuncle.blog/custom_render_pipeline/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://tuncle.blog" target="_blank">三叔胡言乱语的地方</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Unity/">Unity</a><a class="post-meta__tags" href="/tags/SRP/">SRP</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="twitter, wechat, weibo"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/draw_calls/" title="Custom SRP - Draw Calls"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Custom SRP - Draw Calls</div></div></a></div><div class="next-post pull-right"><a href="/custom_srp/" title="Custom SRP"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Custom SRP</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#A_new_Render_Pipeline"><span class="toc-text">A new Render Pipeline</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Project_Setup"><span class="toc-text">Project Setup</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Color_Space"><span class="toc-text">Color Space</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sample_Scene"><span class="toc-text">Sample Scene</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pipeline_Asset"><span class="toc-text">Pipeline Asset</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Render_Pipeline_Instance"><span class="toc-text">Render Pipeline Instance</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Rendering"><span class="toc-text">Rendering</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Camera_Renderer"><span class="toc-text">Camera Renderer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Drawing_the_Skybox"><span class="toc-text">Drawing the Skybox</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Command_Buffers"><span class="toc-text">Command Buffers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Clearing_the_Render_Target"><span class="toc-text">Clearing the Render Target</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Culling"><span class="toc-text">Culling</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Drawing_Geometry"><span class="toc-text">Drawing Geometry</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Drawing_Opaque_and_Transparent_Geometry_Separately"><span class="toc-text">Drawing Opaque and Transparent Geometry Separately</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Editor_Rendering"><span class="toc-text">Editor Rendering</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Drawing_Legacy_Shaders"><span class="toc-text">Drawing Legacy Shaders</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Error_Material"><span class="toc-text">Error Material</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Partial_Class"><span class="toc-text">Partial Class</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Drawing_Gizmos"><span class="toc-text">Drawing Gizmos</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Drawing_Unity_UI"><span class="toc-text">Drawing Unity UI</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Multiply_Cameras"><span class="toc-text">Multiply Cameras</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Two_Cameras"><span class="toc-text">Two Cameras</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Layers"><span class="toc-text">Layers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Clear_Flags"><span class="toc-text">Clear Flags</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Reference"><span class="toc-text">Reference</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By 三叔</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Keep Writing</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'TGA1EB8Nf5aw6uJBpw45pBJQ-gzGzoHsz',
      appKey: 'z1vCYavVUbCGuMjNMcrsvShN',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: true
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: true,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', 'G-2QHMY59T5S', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>