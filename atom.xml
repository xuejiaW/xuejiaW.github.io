<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>三叔的数字花园</title>
  <icon>https://tuncle.blog/icon.png</icon>
  
  <link href="https://tuncle.blog/atom.xml" rel="self"/>
  
  <link href="https://tuncle.blog/"/>
  <updated>2025-06-25T16:00:00.000Z</updated>
  <id>https://tuncle.blog/</id>
  
  <author>
    <name>三叔</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>XR 合成层（Composition Layer）概念详解</title>
    <link href="https://tuncle.blog/composition_layer/"/>
    <id>https://tuncle.blog/composition_layer/</id>
    <published>2025-06-26T14:10:00.000Z</published>
    <updated>2025-06-25T16:00:00.000Z</updated>
    
    
    <summary type="html">XR系统中的合成层（Composition Layer）机制通过将不同类型的内容拆分为独立层（如Projection、Quad、Cylinder等层），由合成器（Compositor）合并后输出到屏幕。这种设计主要解决了传统XR渲染路径中两次非点对点采样导致的画质劣化问题，通过让UI等平面内容直接以合成层提交，减少了一次采样环节。典型案例显示，YVR2设备的Home界面由背景的Projection层和两个UI的Quad层共同构成。合成层还支持多应用内容整合，如MR场景中透视画面、曲面UI和系统弹框的协同显示</summary>
    
    
    
    
    <category term="XR" scheme="https://tuncle.blog/tags/XR/"/>
    
  </entry>
  
  <entry>
    <title>分辨率是什么？从信号与采样的角度分析分辨率</title>
    <link href="https://tuncle.blog/what_is_resolution/"/>
    <id>https://tuncle.blog/what_is_resolution/</id>
    <published>2025-06-20T03:13:00.000Z</published>
    <updated>2025-06-21T16:00:00.000Z</updated>
    
    
    <summary type="html">分辨率描述图像的像素数量，反映对连续信号的采样频率。分辨率越高，采样频率越高，越能还原高频细节。然而，分辨率并非越高越好，需与信号频率匹配。采样定理指出，采样频率需至少为信号最高频率的两倍才能准确还原。傅里叶变换揭示信号可分解为不同频率的正弦波，高频对应细节部分（如物体边缘）。因此，分辨率不足时，高频信号（如黑白突变）易出现锯齿。优化显示效果需平衡分辨率与信号频率，避免过度采样浪费资源</summary>
    
    
    
    
    <category term="图形学" scheme="https://tuncle.blog/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>《Vulkan Tutorial》 笔记 19：Frame in Flight</title>
    <link href="https://tuncle.blog/ch_19_frame_in_flight/"/>
    <id>https://tuncle.blog/ch_19_frame_in_flight/</id>
    <published>2025-05-08T14:00:00.000Z</published>
    <updated>2025-06-21T16:00:00.000Z</updated>
    
    
    <summary type="html">对渲染循环进行改进，通过创建多个 Command Buffer 和信号量来实现多帧渲染，允许 CPU 和 GPU 同时工作，避免 CPU 在 GPU 渲染时处于空闲状态。</summary>
    
    
    
    
    <category term="Vulkan" scheme="https://tuncle.blog/tags/Vulkan/"/>
    
  </entry>
  
  <entry>
    <title>《Vulkan Tutorial》 笔记 18：Rendering And Presentation</title>
    <link href="https://tuncle.blog/ch_18_rendering_and_presentation/"/>
    <id>https://tuncle.blog/ch_18_rendering_and_presentation/</id>
    <published>2025-05-08T13:00:00.000Z</published>
    <updated>2025-06-21T16:00:00.000Z</updated>
    
    
    <summary type="html">本章描述了最终渲染三角形和将其显示到屏幕上的过程，在其中需要创建信号量（Semaphore）和栅栏（Fence）实现 CPU 与 GPU 及队列间的同步，确保渲染流程各阶段正确有序地执行和呈现</summary>
    
    
    
    
    <category term="Vulkan" scheme="https://tuncle.blog/tags/Vulkan/"/>
    
  </entry>
  
  <entry>
    <title>《Vulkan Tutorial》 笔记 17：Command Buffers</title>
    <link href="https://tuncle.blog/ch_17_command_buffers/"/>
    <id>https://tuncle.blog/ch_17_command_buffers/</id>
    <published>2025-04-29T12:38:00.000Z</published>
    <updated>2025-05-04T16:00:00.000Z</updated>
    
    
    <summary type="html">Vulkan 中的命令（如绘制操作和内存传输）并不是通过函数调用直接执行的。开发者必须将所有想要执行的操作记录（Record）在 Command Buffer 对象中。在之前的章节中已经创建了绘制三角形所需要的绝大部分对象，本章定义 Command Buffer 来记录绘制三角形的命令了。</summary>
    
    
    
    
    <category term="Vulkan" scheme="https://tuncle.blog/tags/Vulkan/"/>
    
  </entry>
  
  <entry>
    <title>《Vulkan Tutorial》 笔记 16：FrameBuffers</title>
    <link href="https://tuncle.blog/ch_16_framebuffers/"/>
    <id>https://tuncle.blog/ch_16_framebuffers/</id>
    <published>2025-04-25T12:38:00.000Z</published>
    <updated>2025-05-04T16:00:00.000Z</updated>
    
    
    <summary type="html">创建 用于封装一组图像视图（如颜色、深度等附件），作为渲染目标 的 FrameBuffer 对象，其需要与之前创建的 RenderPass 兼容。</summary>
    
    
    
    
    <category term="Vulkan" scheme="https://tuncle.blog/tags/Vulkan/"/>
    
  </entry>
  
  <entry>
    <title>《Vulkan Tutorial》 笔记 15：Pipeline Conclusion</title>
    <link href="https://tuncle.blog/ch_15_conclusion/"/>
    <id>https://tuncle.blog/ch_15_conclusion/</id>
    <published>2025-04-23T12:38:00.000Z</published>
    <updated>2025-05-04T16:00:00.000Z</updated>
    
    
    <summary type="html">本章将介绍如何将之前的章节中创建的对象组合在一起，创建出一个完整的渲染管线。</summary>
    
    
    
    
    <category term="Vulkan" scheme="https://tuncle.blog/tags/Vulkan/"/>
    
  </entry>
  
  <entry>
    <title>《Vulkan Tutorial》 笔记 14：Render Passes</title>
    <link href="https://tuncle.blog/ch_14_render_passes/"/>
    <id>https://tuncle.blog/ch_14_render_passes/</id>
    <published>2025-04-20T12:38:00.000Z</published>
    <updated>2025-04-28T16:00:00.000Z</updated>
    
    
    <summary type="html">本章介绍了 Vulkan 中 Render Pass 的作用、关键结构体及其创建流程，讲解了如何描述和管理渲染过程中的附件与子通道，为后续渲染管线的搭建打下基础。</summary>
    
    
    
    
    <category term="Vulkan" scheme="https://tuncle.blog/tags/Vulkan/"/>
    
  </entry>
  
  <entry>
    <title>XR 立体渲染模式</title>
    <link href="https://tuncle.blog/stereo_rendering_mode/"/>
    <id>https://tuncle.blog/stereo_rendering_mode/</id>
    <published>2025-04-13T14:02:00.000Z</published>
    <updated>2025-06-14T16:00:00.000Z</updated>
    
    
    <summary type="html">在 XR 中物体通常需要以立体（in sterro）的方式被渲染，即一个内容需要被绘制到左眼和右眼的纹理中，这种渲染方式被称为 `立体渲染视图（Stereo-Rendering）`，本文将介绍几种立体渲染的方式，包括常见的 `Multi-Pass` 和 `Multi-View`，以及通常针对眼动设备的 `Quad-View` 方式。主要将说明这些方式在渲染时所用的纹理数量和 DrawCall 数量的差异。</summary>
    
    
    
    
    <category term="XR" scheme="https://tuncle.blog/tags/XR/"/>
    
    <category term="Unity" scheme="https://tuncle.blog/tags/Unity/"/>
    
    <category term="Rendering" scheme="https://tuncle.blog/tags/Rendering/"/>
    
  </entry>
  
  <entry>
    <title>《Vulkan Tutorial》 笔记 13：Fixed Functions</title>
    <link href="https://tuncle.blog/ch_13_fixed_functions/"/>
    <id>https://tuncle.blog/ch_13_fixed_functions/</id>
    <published>2025-04-13T12:38:00.000Z</published>
    <updated>2025-05-04T16:00:00.000Z</updated>
    
    
    <summary type="html">在这一节中，会设定创建 Pipeline 中除了 Shader Modules 剩下的固定函数的一些操作，如 Viewport Size / Color Blending 模式，这些在 Vulklan 中都需要在创建渲染管线时设定，而在如 OpenGL 这样较老的图形 API 中，则可以在运行时修改。</summary>
    
    
    
    
    <category term="Vulkan" scheme="https://tuncle.blog/tags/Vulkan/"/>
    
  </entry>
  
  <entry>
    <title>《Vulkan Tutorial》 笔记 12：Shader Module</title>
    <link href="https://tuncle.blog/ch_12_shader_modules/"/>
    <id>https://tuncle.blog/ch_12_shader_modules/</id>
    <published>2025-04-13T07:18:00.000Z</published>
    <updated>2025-04-12T16:00:00.000Z</updated>
    
    
    <summary type="html">VkShaderModule 类用以封装和管理已编译好的着色器代码，本节将说明如何创建 Shader Module，以及如何将其传递给渲染管线的特定阶段。</summary>
    
    
    
    
    <category term="Vulkan" scheme="https://tuncle.blog/tags/Vulkan/"/>
    
  </entry>
  
  <entry>
    <title>《Vulkan Tutorial》 笔记 11：图形管线介绍</title>
    <link href="https://tuncle.blog/ch_11_graphics_pipeline_introduction/"/>
    <id>https://tuncle.blog/ch_11_graphics_pipeline_introduction/</id>
    <published>2025-04-13T03:44:00.000Z</published>
    <updated>2025-04-12T16:00:00.000Z</updated>
    
    
    <summary type="html">Vulkan 中需要自己设定图形渲染管线，在一些旧的图形 API 如 OpenGL 中，时可以通过一些函数修改渲染管线的，如通过 `glBlendFunc` 修改管线中对于混合的操作。但在 Vulkan 中管线几乎是完全不变的，因此每当需要修改管线设置，就必须重新创建管线。</summary>
    
    
    
    
    <category term="Vulkan" scheme="https://tuncle.blog/tags/Vulkan/"/>
    
  </entry>
  
  <entry>
    <title>《Vulkan Tutorial》 笔记 10： Image Views</title>
    <link href="https://tuncle.blog/ch_10_image_views/"/>
    <id>https://tuncle.blog/ch_10_image_views/</id>
    <published>2025-04-13T03:30:00.000Z</published>
    <updated>2025-04-12T16:00:00.000Z</updated>
    
    
    <summary type="html">为了使用在 Swap Chain 最后获取的 VkImage，需要首先创建 VkImageView 对象。该对象作为外部对这个 Image 的 View，即该对象描述了该如何访问 Image，以及需要访问 Image 的哪一部分。如可以创建一个 Image View，描述该 Image 应该作为一个 2D 深度纹理，且不需要任何的 Mipmap Level。</summary>
    
    
    
    
    <category term="Vulkan" scheme="https://tuncle.blog/tags/Vulkan/"/>
    
  </entry>
  
  <entry>
    <title>《Vulkan Tutorial》 笔记 09： Swap Chain</title>
    <link href="https://tuncle.blog/ch_09_swap_chain/"/>
    <id>https://tuncle.blog/ch_09_swap_chain/</id>
    <published>2025-04-11T16:00:00.000Z</published>
    <updated>2025-04-13T16:00:00.000Z</updated>
    
    
    <summary type="html">在 Vulkan 中必须显式的创建 Swap Chain。SwapChain 是与 Surface 绑定的数据结构，其包含了多个 Image，应用渲染时会将渲染的结果放置到这些 Image 中，当调用 Present 时，SwapChain 会将这些 Image 通过其与 Surface 绑定，传递给 Surface，Surface 再将这些 Image 显示到平台的窗口或屏幕上。</summary>
    
    
    
    
    <category term="Vulkan" scheme="https://tuncle.blog/tags/Vulkan/"/>
    
  </entry>
  
  <entry>
    <title>《Vulkan Tutorial》 笔记 08： 窗口 Surface</title>
    <link href="https://tuncle.blog/ch_08_window_surface/"/>
    <id>https://tuncle.blog/ch_08_window_surface/</id>
    <published>2025-04-07T16:00:00.000Z</published>
    <updated>2025-04-11T16:00:00.000Z</updated>
    
    
    <summary type="html">因为 Vulkan 是一个平台不相关的 API，所以它无法直接与 Window 操作系统交互。为了建立 Vulkan 和 Window 操作系统之间的连接，就需要使用 `WSI（Window System Integration）` 拓展，其中最关键的就是 Surface。在本节中，会首先创建 Surface，并通过该 Surface 查询可以正确处理 Presentation 的队列族和队列。</summary>
    
    
    
    
    <category term="Vulkan" scheme="https://tuncle.blog/tags/Vulkan/"/>
    
  </entry>
  
  <entry>
    <title>《Vulkan Tutorial》 笔记 07： 逻辑设备和队列</title>
    <link href="https://tuncle.blog/ch_07_logical_device_and_queues/"/>
    <id>https://tuncle.blog/ch_07_logical_device_and_queues/</id>
    <published>2025-04-06T16:00:00.000Z</published>
    <updated>2025-04-11T16:00:00.000Z</updated>
    
    
    <summary type="html">在创建了 Physical Device（VkPhysicalDevice） 后需要建立一个 Logical Device （VkDevice）来与之交互。在创建 Logical Devices 时还需要指定需要从 Physical Devices 的 Queue Family 中创建多少 Queue。</summary>
    
    
    
    
    <category term="Vulkan" scheme="https://tuncle.blog/tags/Vulkan/"/>
    
  </entry>
  
  <entry>
    <title>《Vulkan Tutorial》 笔记 06：物理设备和 Queue Family</title>
    <link href="https://tuncle.blog/ch_06_physical_devices_and_queue_families/"/>
    <id>https://tuncle.blog/ch_06_physical_devices_and_queue_families/</id>
    <published>2025-04-06T02:31:00.000Z</published>
    <updated>2025-04-06T16:00:00.000Z</updated>
    
    
    <summary type="html">选择符合要求的物理设备和 Queue Family，物理设备是 Vulkan 的一个重要概念，它表示了一个支持 Vulkan 的 GPU 设备，Queue Family 则是物理设备的一个属性，表示了该设备支持的命令队列类型。</summary>
    
    
    
    
    <category term="Vulkan" scheme="https://tuncle.blog/tags/Vulkan/"/>
    
  </entry>
  
  <entry>
    <title>《Vulkan Tutorial》 笔记 05： Validation Layers</title>
    <link href="https://tuncle.blog/ch_05_validation_layers/"/>
    <id>https://tuncle.blog/ch_05_validation_layers/</id>
    <published>2025-03-31T13:11:00.000Z</published>
    <updated>2025-04-05T16:00:00.000Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;div class=&quot;note info simple&quot;&gt;&lt;p&gt;本部分重构前的代码可参考 &lt;a</summary>
        
      
    
    
    
    
    <category term="Vulkan" scheme="https://tuncle.blog/tags/Vulkan/"/>
    
  </entry>
  
  <entry>
    <title>《Vulkan Tutorial》 笔记 04：Instance</title>
    <link href="https://tuncle.blog/ch_04_instance/"/>
    <id>https://tuncle.blog/ch_04_instance/</id>
    <published>2025-03-31T08:42:00.000Z</published>
    <updated>2025-04-05T16:00:00.000Z</updated>
    
    
    <summary type="html">对于一个 Vulkan 应用而言，你首先需要通过创建一个 `instance` 来初始化 Vulkan 库， `instance` 是应用与 Vulkan 库的连接，在创建过程中会有相应的操作告知 Driver 你的应用的一些细节</summary>
    
    
    
    
    <category term="Vulkan" scheme="https://tuncle.blog/tags/Vulkan/"/>
    
  </entry>
  
  <entry>
    <title>《Vulkan Tutorial》 笔记 03：基本代码结构</title>
    <link href="https://tuncle.blog/ch_03_base_code/"/>
    <id>https://tuncle.blog/ch_03_base_code/</id>
    <published>2025-03-30T08:42:00.000Z</published>
    <updated>2025-03-29T16:00:00.000Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;div class=&quot;note info simple&quot;&gt;&lt;p&gt;本部分结果可参考 &lt;a</summary>
        
      
    
    
    
    
    <category term="Vulkan" scheme="https://tuncle.blog/tags/Vulkan/"/>
    
  </entry>
  
</feed>
