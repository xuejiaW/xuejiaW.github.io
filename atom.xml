<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>三叔的数字花园</title>
  <icon>https://tuncle.blog/icon.png</icon>
  
  <link href="https://tuncle.blog/atom.xml" rel="self"/>
  
  <link href="https://tuncle.blog/"/>
  <updated>2025-04-12T16:00:00.000Z</updated>
  <id>https://tuncle.blog/</id>
  
  <author>
    <name>三叔</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>XR 立体渲染模式</title>
    <link href="https://tuncle.blog/stereo_rendering_mode/"/>
    <id>https://tuncle.blog/stereo_rendering_mode/</id>
    <published>2025-04-13T14:02:00.000Z</published>
    <updated>2025-04-12T16:00:00.000Z</updated>
    
    
    <summary type="html">在 XR 中物体通常需要以立体（in sterro）的方式被渲染，即一个内容需要被绘制到左眼和右眼的纹理中，这种渲染方式被称为 `立体渲染视图（Stereo-Rendering）`，本文将介绍几种立体渲染的方式，包括常见的 `Multi-Pass` 和 `Multi-View`，以及通常针对眼动设备的 `Quad-View` 方式。主要将说明这些方式在渲染时所用的纹理数量和 DrawCall 数量的差异。</summary>
    
    
    
    
    <category term="Unity" scheme="https://tuncle.blog/tags/Unity/"/>
    
    <category term="XR" scheme="https://tuncle.blog/tags/XR/"/>
    
    <category term="Rendering" scheme="https://tuncle.blog/tags/Rendering/"/>
    
  </entry>
  
  <entry>
    <title>《Vulkan Tutorial》 笔记 13：Fixed Functions</title>
    <link href="https://tuncle.blog/ch_13_fixed_functions/"/>
    <id>https://tuncle.blog/ch_13_fixed_functions/</id>
    <published>2025-04-13T12:38:00.000Z</published>
    <updated>2025-04-12T16:00:00.000Z</updated>
    
    
    <summary type="html">在这一节中，会设定创建 Pipeline 中除了 Shader Modules 剩下的固定函数的一些操作，如 Viewport Size / Color Blending 模式，这些在 Vulklan 中都需要在创建渲染管线时设定，而在如 OpenGL 这样较老的图形 API 中，则可以在运行时修改。</summary>
    
    
    
    
    <category term="Vulkan" scheme="https://tuncle.blog/tags/Vulkan/"/>
    
  </entry>
  
  <entry>
    <title>《Vulkan Tutorial》 笔记 12：Shader Module</title>
    <link href="https://tuncle.blog/ch_12_shader_modules/"/>
    <id>https://tuncle.blog/ch_12_shader_modules/</id>
    <published>2025-04-13T07:18:00.000Z</published>
    <updated>2025-04-12T16:00:00.000Z</updated>
    
    
    <summary type="html">VkShaderModule 类用以封装和管理已编译好的着色器代码，本节将说明如何创建 Shader Module，以及如何将其传递给渲染管线的特定阶段。</summary>
    
    
    
    
    <category term="Vulkan" scheme="https://tuncle.blog/tags/Vulkan/"/>
    
  </entry>
  
  <entry>
    <title>《Vulkan Tutorial》 笔记 11：图形管线介绍</title>
    <link href="https://tuncle.blog/ch_11_graphics_pipeline_introduction/"/>
    <id>https://tuncle.blog/ch_11_graphics_pipeline_introduction/</id>
    <published>2025-04-13T03:44:00.000Z</published>
    <updated>2025-04-12T16:00:00.000Z</updated>
    
    
    <summary type="html">Vulkan 中需要自己设定图形渲染管线，在一些旧的图形 API 如 OpenGL 中，时可以通过一些函数修改渲染管线的，如通过 `glBlendFunc` 修改管线中对于混合的操作。但在 Vulkan 中管线几乎是完全不变的，因此每当需要修改管线设置，就必须重新创建管线。</summary>
    
    
    
    
    <category term="Vulkan" scheme="https://tuncle.blog/tags/Vulkan/"/>
    
  </entry>
  
  <entry>
    <title>《Vulkan Tutorial》 笔记 10： Image Views</title>
    <link href="https://tuncle.blog/ch_10_image_views/"/>
    <id>https://tuncle.blog/ch_10_image_views/</id>
    <published>2025-04-13T03:30:00.000Z</published>
    <updated>2025-04-12T16:00:00.000Z</updated>
    
    
    <summary type="html">为了使用在 Swap Chain 最后获取的 VkImage，需要首先创建 VkImageView 对象。该对象作为外部对这个 Image 的 View，即该对象描述了该如何访问 Image，以及需要访问 Image 的哪一部分。如可以创建一个 Image View，描述该 Image 应该作为一个 2D 深度纹理，且不需要任何的 Mipmap Level。</summary>
    
    
    
    
    <category term="Vulkan" scheme="https://tuncle.blog/tags/Vulkan/"/>
    
  </entry>
  
  <entry>
    <title>《Vulkan Tutorial》 笔记 09： Swap Chain</title>
    <link href="https://tuncle.blog/ch_09_swap_chain/"/>
    <id>https://tuncle.blog/ch_09_swap_chain/</id>
    <published>2025-04-11T16:00:00.000Z</published>
    <updated>2025-04-11T16:00:00.000Z</updated>
    
    
    <summary type="html">在 Vulkan 中必须显式的创建 Swap Chain。SwapChain 是与 Surface 绑定的数据结构，其包含了多个 Image，应用渲染时会将渲染的结果放置到这些 Image 中，当调用 Present 时，SwapChain 会将这些 Image 通过其与 Surface 绑定，传递给 Surface，Surface 再将这些 Image 显示到平台的窗口或屏幕上。</summary>
    
    
    
    
    <category term="Vulkan" scheme="https://tuncle.blog/tags/Vulkan/"/>
    
  </entry>
  
  <entry>
    <title>《Vulkan Tutorial》 笔记 08： 窗口 Surface</title>
    <link href="https://tuncle.blog/ch_08_window_surface/"/>
    <id>https://tuncle.blog/ch_08_window_surface/</id>
    <published>2025-04-07T16:00:00.000Z</published>
    <updated>2025-04-11T16:00:00.000Z</updated>
    
    
    <summary type="html">因为 Vulkan 是一个平台不相关的 API，所以它无法直接与 Window 操作系统交互。为了建立 Vulkan 和 Window 操作系统之间的连接，就需要使用 `WSI（Window System Integration）` 拓展，其中最关键的就是 Surface。</summary>
    
    
    
    
    <category term="Vulkan" scheme="https://tuncle.blog/tags/Vulkan/"/>
    
  </entry>
  
  <entry>
    <title>《Vulkan Tutorial》 笔记 07： 逻辑设备和队列</title>
    <link href="https://tuncle.blog/ch_07_logical_device_and_queues/"/>
    <id>https://tuncle.blog/ch_07_logical_device_and_queues/</id>
    <published>2025-04-06T16:00:00.000Z</published>
    <updated>2025-04-11T16:00:00.000Z</updated>
    
    
    <summary type="html">在创建了 Physical Device（VkPhysicalDevice） 后需要建立一个 Logical Device （VkDevice）来与之交互。在创建 Logical Devices 时还需要指定需要从 Physical Devices 的 Queue Family 中创建多少 Queue。</summary>
    
    
    
    
    <category term="Vulkan" scheme="https://tuncle.blog/tags/Vulkan/"/>
    
  </entry>
  
  <entry>
    <title>《Vulkan Tutorial》 笔记 06：物理设备和 Queue Family</title>
    <link href="https://tuncle.blog/ch_06_physical_devices_and_queue_families/"/>
    <id>https://tuncle.blog/ch_06_physical_devices_and_queue_families/</id>
    <published>2025-04-06T02:31:00.000Z</published>
    <updated>2025-04-06T16:00:00.000Z</updated>
    
    
    <summary type="html">选择符合要求的物理设备和 Queue Family，物理设备是 Vulkan 的一个重要概念，它表示了一个支持 Vulkan 的 GPU 设备，Queue Family 则是物理设备的一个属性，表示了该设备支持的命令队列类型。</summary>
    
    
    
    
    <category term="Vulkan" scheme="https://tuncle.blog/tags/Vulkan/"/>
    
  </entry>
  
  <entry>
    <title>《Vulkan Tutorial》 笔记 05： Validation Layers</title>
    <link href="https://tuncle.blog/ch_05_validation_layers/"/>
    <id>https://tuncle.blog/ch_05_validation_layers/</id>
    <published>2025-03-31T13:11:00.000Z</published>
    <updated>2025-04-05T16:00:00.000Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;div class=&quot;note info simple&quot;&gt;&lt;p&gt;本部分结果重构前的可参考 &lt;a</summary>
        
      
    
    
    
    
    <category term="Vulkan" scheme="https://tuncle.blog/tags/Vulkan/"/>
    
  </entry>
  
  <entry>
    <title>《Vulkan Tutorial》 笔记 04：Instance</title>
    <link href="https://tuncle.blog/ch_04_instance/"/>
    <id>https://tuncle.blog/ch_04_instance/</id>
    <published>2025-03-31T08:42:00.000Z</published>
    <updated>2025-04-05T16:00:00.000Z</updated>
    
    
    <summary type="html">对于一个 Vulkan 应用而言，你首先需要通过创建一个 `instance` 来初始化 Vulkan 库， `instance` 是应用与 Vulkan 库的连接，在创建过程中会有相应的操作告知 Driver 你的应用的一些细节</summary>
    
    
    
    
    <category term="Vulkan" scheme="https://tuncle.blog/tags/Vulkan/"/>
    
  </entry>
  
  <entry>
    <title>《Vulkan Tutorial》 笔记 03：基本代码结构</title>
    <link href="https://tuncle.blog/ch_03_base_code/"/>
    <id>https://tuncle.blog/ch_03_base_code/</id>
    <published>2025-03-30T08:42:00.000Z</published>
    <updated>2025-03-29T16:00:00.000Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;div class=&quot;note info simple&quot;&gt;&lt;p&gt;本部分结果可参考 &lt;a</summary>
        
      
    
    
    
    
    <category term="Vulkan" scheme="https://tuncle.blog/tags/Vulkan/"/>
    
  </entry>
  
  <entry>
    <title>《Vulkan Tutorial》 笔记 02：开发环境</title>
    <link href="https://tuncle.blog/ch_02_development_environment/"/>
    <id>https://tuncle.blog/ch_02_development_environment/</id>
    <published>2025-03-29T05:45:00.000Z</published>
    <updated>2025-03-29T16:00:00.000Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;div class=&quot;note info simple&quot;&gt;&lt;p&gt;本部分结果可参考 &lt;a</summary>
        
      
    
    
    
    
    <category term="Vulkan" scheme="https://tuncle.blog/tags/Vulkan/"/>
    
  </entry>
  
  <entry>
    <title>《Vulkan Tutorial》 笔记 01：概览</title>
    <link href="https://tuncle.blog/ch_01_overview/"/>
    <id>https://tuncle.blog/ch_01_overview/</id>
    <published>2025-03-29T05:42:00.000Z</published>
    <updated>2025-03-29T16:00:00.000Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;这一部分会先介绍 Vulkan 以及它解决的问题，然后会阐述绘制第一个三角形所需要的组成部分。&lt;/p&gt;
&lt;h1 id=&quot;Vulkan_的起源&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#Vulkan_的起源&quot;&gt;#&lt;/a&gt;Vulkan</summary>
        
      
    
    
    
    
    <category term="Vulkan" scheme="https://tuncle.blog/tags/Vulkan/"/>
    
  </entry>
  
  <entry>
    <title>《Vulkan Tutorial》 笔记 00：简介</title>
    <link href="https://tuncle.blog/ch_00_introduction/"/>
    <id>https://tuncle.blog/ch_00_introduction/</id>
    <published>2025-03-29T05:41:00.000Z</published>
    <updated>2025-03-28T16:00:00.000Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;Vulkan 是由 Khronos 提供了一套新图形 API，旨在为现代显卡提供更优秀的抽象能力，进而可以让开发者可以更好的描述自己需要应用执行的操作。与传统的 OpenGL 和 Direct3D 相比，Vulkan更少的依赖于驱动行为。&lt;/p&gt;
&lt;div</summary>
        
      
    
    
    
    
    <category term="Vulkan" scheme="https://tuncle.blog/tags/Vulkan/"/>
    
  </entry>
  
  <entry>
    <title>《Vulkan Tutorial》 学习笔记汇总</title>
    <link href="https://tuncle.blog/vulkan_tutorial/"/>
    <id>https://tuncle.blog/vulkan_tutorial/</id>
    <published>2025-03-29T05:40:00.000Z</published>
    <updated>2025-04-12T16:00:00.000Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;准备&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#准备&quot;&gt;#&lt;/a&gt;准备&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;/ch_00_introduction&quot;&gt;Ch 00 Introduction&lt;/a&gt;：简单的介绍 Vulkan API</summary>
        
      
    
    
    
    
    <category term="Vulkan" scheme="https://tuncle.blog/tags/Vulkan/"/>
    
  </entry>
  
  <entry>
    <title>Unity Coroutine 与 Yield 的关系</title>
    <link href="https://tuncle.blog/yield_and_coroutine/"/>
    <id>https://tuncle.blog/yield_and_coroutine/</id>
    <published>2025-01-23T16:00:00.000Z</published>
    <updated>2025-01-23T16:00:00.000Z</updated>
    
    
    <summary type="html">本文主要介绍 Unity 中的协程（Coroutine）和 Yield 的关系，分别会在 Unity 中进行协程原理的论证，以及通过 .Net Tool 自定义一个简易的协程系统说明协程原理。</summary>
    
    
    
    
    <category term="Unity" scheme="https://tuncle.blog/tags/Unity/"/>
    
    <category term="CSharp" scheme="https://tuncle.blog/tags/CSharp/"/>
    
  </entry>
  
  <entry>
    <title>C# Yield 关键字</title>
    <link href="https://tuncle.blog/yield/"/>
    <id>https://tuncle.blog/yield/</id>
    <published>2025-01-11T16:00:00.000Z</published>
    <updated>2025-01-23T16:00:00.000Z</updated>
    
    
    <summary type="html">介绍 C# 中 Yield 关键字的用法和工作原理，且通过一个示例说明如何通过 Yield 关键字节省性能。</summary>
    
    
    
    
    <category term="CSharp" scheme="https://tuncle.blog/tags/CSharp/"/>
    
  </entry>
  
  <entry>
    <title>《3D 数学基础》第四章 矩阵简介</title>
    <link href="https://tuncle.blog/ch_04_introduction_to_matrices/"/>
    <id>https://tuncle.blog/ch_04_introduction_to_matrices/</id>
    <published>2024-09-08T06:27:00.000Z</published>
    <updated>2024-09-07T16:00:00.000Z</updated>
    
    
    <summary type="html">本文主要介绍了矩阵的数学定义，矩阵的维度和表示方法，方阵，单位矩阵，矩阵转置，矩阵与标量相乘，两个矩阵相乘，矩阵与向量相乘，向量转置，矩阵的几何意义等内容。</summary>
    
    
    
    
    <category term="图形学" scheme="https://tuncle.blog/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="数学" scheme="https://tuncle.blog/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>绕任意轴旋转的旋转矩阵推导</title>
    <link href="https://tuncle.blog/rotate_about_arbitary_axis/"/>
    <id>https://tuncle.blog/rotate_about_arbitary_axis/</id>
    <published>2024-09-08T04:44:00.000Z</published>
    <updated>2024-09-07T16:00:00.000Z</updated>
    
    
    <summary type="html">介绍了绕任意轴旋转任意角度的的旋转矩阵的推导过程。</summary>
    
    
    
    
    <category term="图形学" scheme="https://tuncle.blog/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="数学" scheme="https://tuncle.blog/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
</feed>
