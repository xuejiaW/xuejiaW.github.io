<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>《C++ Primer》 第三章笔记 | 三叔胡言乱语的地方</title><meta name="author" content="三叔"><meta name="copyright" content="三叔"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="《C++ Primer》 第三章笔记。 第二章介绍的是C++中的内建类型，这一章则是会介绍C++标准库中的一些重要类型。">
<meta property="og:type" content="article">
<meta property="og:title" content="《C++ Primer》 第三章笔记">
<meta property="og:url" content="https://tuncle.blog/CPPPrimer-Chapter3-Notes/index.html">
<meta property="og:site_name" content="三叔胡言乱语的地方">
<meta property="og:description" content="《C++ Primer》 第三章笔记。 第二章介绍的是C++中的内建类型，这一章则是会介绍C++标准库中的一些重要类型。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tuncle.blog/img/avatar.jpg">
<meta property="article:published_time" content="2020-02-15T11:04:13.000Z">
<meta property="article:modified_time" content="2023-04-16T06:32:59.813Z">
<meta property="article:author" content="三叔">
<meta property="article:tag" content="读书笔记">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tuncle.blog/img/avatar.jpg"><link rel="shortcut icon" href="/img/avatar.jpg"><link rel="canonical" href="https://tuncle.blog/CPPPrimer-Chapter3-Notes/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":true,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":200,"languages":{"author":"作者: 三叔","link":"链接: ","source":"来源: 三叔胡言乱语的地方","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '《C++ Primer》 第三章笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-16 14:32:59'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">71</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img fixed" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="三叔胡言乱语的地方"><span class="site-name">三叔胡言乱语的地方</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">《C++ Primer》 第三章笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2020-02-15T11:04:13.000Z" title="发表于 2020-02-15 19:04:13">2020-02-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/">计算机语言</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>40分钟</span></span><span class="post-meta-separator">|</span><span class="leancloud_visitors" id="/CPPPrimer-Chapter3-Notes/" data-flag-title="《C++ Primer》 第三章笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span class="leancloud-visitors-count"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><p>《C++ Primer》 第三章笔记。</p>
<p>第二章介绍的是C++中的内建类型，这一章则是会介绍C++标准库中的一些重要类型。</p>
<p><img src="CPPPrimer-Chapter3-Notes/Ch3.png" alt="第三章内容"></p>
<span id="more"></span>
<h1 id="Chapter-3-String-Vectors-And-Arrays"><a href="#Chapter-3-String-Vectors-And-Arrays" class="headerlink" title="Chapter 3 String, Vectors, And Arrays"></a>Chapter 3 String, Vectors, And Arrays</h1><h2 id="Namespace-using-Declarations"><a href="#Namespace-using-Declarations" class="headerlink" title="Namespace using Declarations"></a>Namespace using Declarations</h2><p>可以使用<code>using &lt;namespace&gt;::&lt;name&gt;</code>的方式定义在命名空间中的一个函数或变量，注意一个<code>using</code>命令符只能对应一个名字，如下式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">voidTestNamespace</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">voidTestNamespace</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">voidTestNamespace</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter two number&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> v1, v2;</span><br><span class="line">    cin &gt;&gt; v1 &gt;&gt; v2;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The sum is &quot;</span> &lt;&lt; v1 &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; v2 &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; v1 + v2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Header-Should-not-include-using-Declarations"><a href="#Header-Should-not-include-using-Declarations" class="headerlink" title="Header Should not include using Declarations"></a>Header Should not include using Declarations</h3><p>如之前所述，预处理器实际上是把<code>#incldue</code>语句替换为头文件中的内容，所以如果在头文件中使用了using声明，那么所有引用了该头文件的文件都会使用该using声明。</p>
<p>这可能会造成意想不到的情况发生，所以应该尽量避免在头文件中使用using声明。</p>
<h2 id="Library-string-Type"><a href="#Library-string-Type" class="headerlink" title="Library string Type"></a>Library string Type</h2><p>使用C++标准库的string前，应该首先引入string，如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br></pre></td></tr></table></figure>
<h3 id="Defining-and-Initializing-strings"><a href="#Defining-and-Initializing-strings" class="headerlink" title="Defining and Initializing strings"></a>Defining and Initializing strings</h3><p>初始化String的方法如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>实例代码</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>string s1</td>
<td>默认的初始化，s1是空字符串</td>
</tr>
<tr>
<td>string s2</td>
<td>s2是s1的拷贝</td>
</tr>
<tr>
<td>string s2 = s1</td>
<td>与上式相同</td>
</tr>
<tr>
<td>string s3(“value”)</td>
<td>s3是字符串字面值的拷贝，不包括最后的空字符</td>
</tr>
<tr>
<td>string s3 = “value”</td>
<td>与上式相同</td>
</tr>
<tr>
<td>string s4(n,’c’)</td>
<td>用n个’c’来初始化s4</td>
</tr>
</tbody>
</table>
</div>
<p>如果用string字面值来初始化string类型，字面值最后的空字符是不会被拷贝进string的，如上表中，<code>&quot;value&quot;</code>是字面值，其长度为6，而通过<code>&quot;value&quot;</code>初始化的s3，长度为5，如下代码验证：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s3</span><span class="params">(<span class="string">&quot;value&quot;</span>)</span></span>;</span><br><span class="line">string s4 = <span class="string">&quot;value&quot;</span>;</span><br><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;value&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(str) / <span class="built_in">sizeof</span>(*str) &lt;&lt; endl; <span class="comment">//6</span></span><br><span class="line">cout &lt;&lt; s3.<span class="built_in">length</span>() &lt;&lt; endl;                <span class="comment">//5</span></span><br><span class="line">cout &lt;&lt; s4.<span class="built_in">length</span>() &lt;&lt; endl;                <span class="comment">//5</span></span><br></pre></td></tr></table></figure>
<h4 id="Direct-and-Copy-Forms-of-Initialization"><a href="#Direct-and-Copy-Forms-of-Initialization" class="headerlink" title="Direct and Copy Forms of Initialization"></a>Direct and Copy Forms of Initialization</h4><p>当使用<code>=</code>进行初始化的时候，实际上编译器执行的是<code>拷贝初始化(Copy Initialize)</code>，当不使用<code>=</code>时，是<code>直接初始化（Direct Initialization）</code>。</p>
<p>上表中，<code>string s2 = s1</code>和<code>string s3 = &quot;value&quot;</code>是拷贝初始化，其他的都是直接初始化</p>
<h3 id="Operations-on-strings"><a href="#Operations-on-strings" class="headerlink" title="Operations on strings"></a>Operations on strings</h3><h4 id="Reading-and-Writing-strings"><a href="#Reading-and-Writing-strings" class="headerlink" title="Reading and Writing strings"></a>Reading and Writing strings</h4><p>下表为可以对string进行的操作：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>操作代码</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>os &lt;&lt; s</td>
<td>输出结果到os,返回os</td>
</tr>
<tr>
<td>is &gt;&gt; s</td>
<td>is的结果到s，返回is。is的数值以whitespace分隔</td>
</tr>
<tr>
<td>getline(is,s)</td>
<td>读取is中的一行，返回is</td>
</tr>
<tr>
<td>s.empty()</td>
<td>s是否为空</td>
</tr>
<tr>
<td>s.size()</td>
<td>s中的字符数</td>
</tr>
<tr>
<td>s.length()</td>
<td>s中的字符数，与size是同义api，返回的结果相同</td>
</tr>
<tr>
<td>s[n]</td>
<td>去s中index为n的字符</td>
</tr>
<tr>
<td>s1 + s2</td>
<td>返回一个新string,值为s1和s2的结合</td>
</tr>
<tr>
<td>s1 = s2</td>
<td>将s1中的值替换为s2的值</td>
</tr>
<tr>
<td>s1 == s2</td>
<td>s1和s2是否相同</td>
</tr>
<tr>
<td>s1 != s2</td>
<td>s1和s2是否不同</td>
</tr>
<tr>
<td>&lt;,&lt;=,&gt;,&gt;=</td>
<td>s1和s2的大小，根据字典规则排序</td>
</tr>
</tbody>
</table>
</div>
<p>其中<code>is &gt;&gt; s</code>是以whitespace分隔的（空格，换行，tab），当读到whitespace时一个读取便结束（不包括whitespace），如下所示</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string s1, s2;</span><br><span class="line">cin &gt;&gt; s1 &gt;&gt; s2;                <span class="comment">//input is &quot;   Hello World!    &quot;</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;s1 is &quot;</span> &lt;&lt; s1 &lt;&lt; endl; <span class="comment">//Hello</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;s2 is &quot;</span> &lt;&lt; s2 &lt;&lt; endl; <span class="comment">//World!</span></span><br></pre></td></tr></table></figure>
<p>可以看到用cin的话，是无法读取输入中的空格的，如果需要读取空格，建议使用<code>getline</code>，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">string line;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">getline</span>(cin, line))</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;result is &quot;</span> &lt;&lt; line &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">$ ./a.exe</span></span><br><span class="line"><span class="comment">123  456   789</span></span><br><span class="line"><span class="comment">result is 123  456   789</span></span><br><span class="line"><span class="comment">    Hello World    </span></span><br><span class="line"><span class="comment">result is     Hello World </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><code>getline</code>以换行符进行分割，在Windows中输入回车即可，当getline读取到换行符后即会停止，读取的结果不包含换行符，即如果一行的开头便是换行符，则这次读取的结果为空字串。</p>
<p>又因为<code>getline</code>返回的也是stream类型，所以同样可以作为判断条件。</p>
<h4 id="The-string-size-type-Type"><a href="#The-string-size-type-Type" class="headerlink" title="The string::size_type Type"></a>The string::size_type Type</h4><p>string.size()方法返回字符串中的字符数，但是返回的结果并不是int或者unsigned，而是<code>string::size_type</code>。</p>
<p>string类和其他大部分的库类都定义了伴侣类型(companion type)，string::size_type就是其中一个。int之类的内建类型是硬件相关的，即不同的硬件会有不同的结果，而伴侣类型则是机器不相干的实现。</p>
<p>string::size_type内部的细节书中未提及，但是它是大到足够容纳任何长度字符串的unsigned类型。也因为是unsigned，所以要注意表达式中signed int到unsigned int的隐式转换，如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">-3</span>;</span><br><span class="line"><span class="keyword">if</span> (n &lt; s3.<span class="built_in">length</span>())</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;n is smaller&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s3 length is smaller&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">s3 length is smaller&quot;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>直觉上，n是负数，而s3的长度必然是正数，所以n一定小于s3的长度，但实际上因为n被转换为了unsigned int，所以是一个非常大的数（$2^32-3$）。因此最终的结果是s3的长度更小。</p>
<p>在C++11中，可以通过auto关键字来避免每次都手动的输入伴侣类型（通常比内建类型长，所以相对不太容易输入），如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> len = line.<span class="built_in">size</span>()</span><br></pre></td></tr></table></figure>
<h4 id="Adding-Literals-and-strings"><a href="#Adding-Literals-and-strings" class="headerlink" title="Adding Literals and strings"></a>Adding Literals and strings</h4><p>string标准库允许将字符字面值和字符串字面值转换为string字面值。</p>
<p>但如果需要用<code>+</code>操作符将字面值和string类型合并的时候，必须保证操作符的至少一端是string类型，如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string s1 = <span class="string">&quot;hello&quot;</span>, s2 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">string s3 = s1 + <span class="string">&#x27;,&#x27;</span> + s2 + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">cout &lt;&lt; s3;</span><br><span class="line"><span class="comment">// string s4 = &quot;Hello&quot; + &quot;world&quot;;  //error,both sides of + are literals</span></span><br><span class="line">string s4 = s1 + <span class="string">&quot;,&quot;</span> + s2; <span class="comment">//ok, s1 + &quot;,&quot; return string</span></span><br></pre></td></tr></table></figure>
<h3 id="Dealing-with-the-Characters-in-a-string"><a href="#Dealing-with-the-Characters-in-a-string" class="headerlink" title="Dealing with the Characters in a string"></a>Dealing with the Characters in a string</h3><p>在标准库的cctype头文件中定义了许多关于字符的函数。</p>
<blockquote>
<p>cctype实际上是从C标准库中继承来的，在c中命名为<code>ctype.h</code>。通常而言，在C中的标准库会被命名为<code>c&lt;Name&gt;.h</code>，如果这个库被移植到到C++，则会被命名为<code>cc&lt;Name&gt;</code>。<br>C和C++在很大程度上是通用的，在C++的移植版本中主要变换是将所有的函数和变量会被移到std命名空间下。如果直接使用C版本的标准库也是可以运行的，但是推荐还是使用C++版本，这样可以保证标准库命名空间的统一。</p>
</blockquote>
<p>cctype中常用的函数如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>代码实例</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>isalnum (c)</td>
<td>c是否是字母或者数字</td>
</tr>
<tr>
<td>isalpha (c)</td>
<td>c是否是字母</td>
</tr>
<tr>
<td>iscntrl (c)</td>
<td>c是否是控制字符</td>
</tr>
<tr>
<td>isdigit (c)</td>
<td>c是否是数字</td>
</tr>
<tr>
<td>isgraph (c)</td>
<td>c是否是可显示的（不包括空格）</td>
</tr>
<tr>
<td>islower (c)</td>
<td>c是否是小写的</td>
</tr>
<tr>
<td>isprint (c)</td>
<td>c是否是可显示的（包括空格）</td>
</tr>
<tr>
<td>isupper (c)</td>
<td>c是否是大写的</td>
</tr>
<tr>
<td>ispunct (c)</td>
<td>c是否是标点符号</td>
</tr>
<tr>
<td>isspace (c)</td>
<td>c是否是空白字符（空格，tab，vertical tab,返回，换行符等）</td>
</tr>
<tr>
<td>isxdigit (c)</td>
<td>c是否是十六进制字符</td>
</tr>
<tr>
<td>tolower(c)</td>
<td>将c从大写切换为小写</td>
</tr>
<tr>
<td>toupper(c)</td>
<td>将c从小写切换为大写</td>
</tr>
</tbody>
</table>
</div>
<h4 id="Processing-Every-Character-Use-Range-Based-for"><a href="#Processing-Every-Character-Use-Range-Based-for" class="headerlink" title="Processing Every Character? Use Range-Based for"></a>Processing Every Character? Use Range-Based for</h4><p>可以使用<code>Range for</code>来改变字符串中的每个字符，<code>Range for</code>结构如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (declaration : expression)</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure>
<p>如需要判断字符串中的每个字符是否是标点符号，可以通过如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;Hello World!!!&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">decltype</span>(s.<span class="built_in">size</span>()) punct_cnt = <span class="number">0</span>; <span class="comment">//type is size_t</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> c : s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ispunct</span>(c))</span><br><span class="line">        ++punct_cnt;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;There are &quot;</span> &lt;&lt; punct_cnt &lt;&lt; <span class="string">&quot; punctuation characters in &quot;</span> &lt;&lt; s &lt;&lt;endl;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">There are 3 punctuation characters in Hello World!!!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>在使用range for的时候，为了避免数值的拷贝，可以使用引用，并且在只访问数据的情况下，为了避免对值进行修改，可以使用const reference，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;c : s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ispunct</span>(c))</span><br><span class="line">        ++punct_cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Using-a-Range-for-to-Change-the-Characters-in-a-string"><a href="#Using-a-Range-for-to-Change-the-Characters-in-a-string" class="headerlink" title="Using a Range for to Change the Characters in a string"></a>Using a Range for to Change the Characters in a string</h4><p><code>Range for</code>实际上是返回值的拷贝，如上节的例子中在每次迭代的情况下，是将str中下个字符拷贝至c中。因此如果需要通过Range for修改string中的数值，就需要使用引用，如下是将字符串中的每个字符转换为大写的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c : s)</span><br><span class="line">&#123;</span><br><span class="line">    c = <span class="built_in">toupper</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;result is &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">HELLO WORLD!!!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="Using-a-Subsctipt-for-Iteration"><a href="#Using-a-Subsctipt-for-Iteration" class="headerlink" title="Using a Subsctipt for Iteration"></a>Using a Subsctipt for Iteration</h4><p>可以使用下标（<code>[&lt;index&gt;]</code>）取string中的每个字符。使用下标返回的并不是拷贝，而直接是string中的数值，所以可以直接进行修改，并不需要引用，如下是使用下标来将每个字符改为大写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;Hello World!!!&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">decltype</span>(s.<span class="built_in">size</span>()) i = <span class="number">0</span>; i != s.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    s[i] = <span class="built_in">toupper</span>(s[i]);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;result is &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">HELLO WORLD!!!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="Library-vector-Type"><a href="#Library-vector-Type" class="headerlink" title="Library vector Type"></a>Library vector Type</h2><p>Vector是对象的集合，所有的对象都必须有相同的类型。Vector并不是一个具体的类，而是一个类模板。</p>
<p>模板可以被视为是编译器生成函数或者类的指导，编译器使用模板生成函数和类的过程称为<code>实例化（Instantiation）</code>。当使用模板时，必须提供想要编译器创建的函数或类类型。在模板后跟上一对尖括号，在尖括号内部加上想要创建的类型，如<code>vector&lt;int&gt;</code>。</p>
<p>Vector中可以容纳绝大部分的类型，无论是内建类型还是自定义的类型，但是不能包含引用，严格严格来说引用并非是对象。Vector中的对象也可以是另一个Vector，在老版本中嵌套Vector的尖括号中必须带有空格，如<code>vector&lt;vector&lt;int&gt; &gt;</code>，但在C++11中不需要如此，直接写成<code>vector&lt;vector&lt;int&gt;&gt;</code>即可。</p>
<h3 id="Defining-and-Initializing-vectors"><a href="#Defining-and-Initializing-vectors" class="headerlink" title="Defining and Initializing vectors"></a>Defining and Initializing vectors</h3><h4 id="Value-Initialization-and-Default-Initialization"><a href="#Value-Initialization-and-Default-Initialization" class="headerlink" title="Value Initialization and Default Initialization"></a>Value Initialization and Default Initialization</h4><p>首先要说明值初始化（Value Initialization）和默认初始化（Default Initialization）的概念。</p>
<ol>
<li>在默认初始化情况下，如果变量声明在函数外，一个变量将获得其初始值。而在函数内，内建类型的值是未定义的。</li>
<li>在值初始化情况下，无论变量声明在函数内外，它都会获得其初始值。</li>
</ol>
<p>定义和初始化vector的方法如下所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>示例代码</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>vector<T> v1</td>
<td>vector中的元素类型为T，v1为空</td>
</tr>
<tr>
<td>vector<T> v2(v1)</td>
<td>v2中包含有v1中每个元素的拷贝</td>
</tr>
<tr>
<td>vector<T> v2 = v1</td>
<td>与上式一样</td>
</tr>
<tr>
<td>vector<T> v3(n,val)</td>
<td>v3中有n个元素，每个元素的值都是val</td>
</tr>
<tr>
<td>vector<T> v4(n)</td>
<td>v4中有n个元素，每个元素都是T的默认值</td>
</tr>
<tr>
<td>vector<T> v5{a, b, c}</td>
<td>如果a,b,c与T类型匹配，则v5包含a,b,c三个元素（不匹配的情况在下面有详细说明）。</td>
</tr>
<tr>
<td>vector<T> v5 = {a, b, c}</td>
<td>与上式相同</td>
</tr>
</tbody>
</table>
</div>
<p>vector的创建同样分类为拷贝初始化和直接初始化，定义和string中的初始化一样，如<code>vector&lt;T&gt; v2 = v1</code>和<code>vector&lt;T&gt; v5 = &#123;a, b, c&#125;</code>为拷贝初始化，其他的都为直接初始化。</p>
<p>在初始化中，如果使用的是括号(<code>()</code>)，则括号中的值为vector中元素的数量，所以括号内的值必须是自然数。如果使用的是大括号（<code>&#123;&#125;</code>），则会尝试将其中的值作为vector的元素，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intList_1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="comment">// vector&lt;string&gt; intList_1(&quot;abc&quot;);//error</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; intList_2&#123;<span class="number">10</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intList_3</span><span class="params">(<span class="number">10</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; intList_4&#123;<span class="number">10</span>, <span class="number">1</span>&#125;;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;vector_1 size is &quot;</span> &lt;&lt; intList_1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;vector_2 size is &quot;</span> &lt;&lt; intList_2.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;vector_3 size is &quot;</span> &lt;&lt; intList_3.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;vector_4 size is &quot;</span> &lt;&lt; intList_4.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">vector_1 size is 10</span></span><br><span class="line"><span class="comment">vector_2 size is 1</span></span><br><span class="line"><span class="comment">vector_3 size is 10</span></span><br><span class="line"><span class="comment">vector_4 size is 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>式子<code>vector&lt;T&gt; v4(n)</code>中，进行的是值初始化。类型T必须含有默认初始化值，否则vector的初始化会失败。</p>
</blockquote>
<p>但如果使用的是大括号，而且大括号内的值与vector中的元素类型不匹配，那么就无法将其作为vector中的元素，编译器会尝试将大括号替换为括号再次解析，如果仍然解析失败则会编译错误。如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; v5&#123;<span class="string">&quot;hi&quot;</span>&#125;;</span><br><span class="line"><span class="comment">// vector&lt;string&gt; v6(&quot;hi&quot;);//Error, value in parentheses must be digit</span></span><br><span class="line">vector&lt;string&gt; v7&#123;<span class="number">10</span>&#125;;</span><br><span class="line">vector&lt;string&gt; v8&#123;<span class="number">10</span>, <span class="string">&quot;hi&quot;</span>&#125;; <span class="comment">//try to analyse as parentheses</span></span><br><span class="line"><span class="comment">// vector&lt;string&gt; v9&#123;10, 20&#125;;//Error, analyse as parenthese still not work</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v5 size is &quot;</span> &lt;&lt; v5.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v7 size is &quot;</span> &lt;&lt; v7.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v8 size is &quot;</span> &lt;&lt; v8.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">v5 size is 1</span></span><br><span class="line"><span class="comment">v7 size is 10</span></span><br><span class="line"><span class="comment">v8 size is 10</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="Adding-Elements-to-a-vector"><a href="#Adding-Elements-to-a-vector" class="headerlink" title="Adding Elements to a vector"></a>Adding Elements to a vector</h3><p>使用<code>push_back</code>方法来增加vector中的元素。</p>
<p>在标准库中vector的实现下，vector的扩张是很高效的，所以通常来说不需要用括号的初始化方法来定义vector的大小，有的时候定义vector的大小反而会造成性能方面的影响。除了所有的元素都是相同值的情况，否则尽量避免使用括号的初始化方法。</p>
<h4 id="Programming-Implications-of-Adding-Elements-to-a-vector"><a href="#Programming-Implications-of-Adding-Elements-to-a-vector" class="headerlink" title="Programming Implications of Adding Elements to a vector"></a>Programming Implications of Adding Elements to a vector</h4><p>在vector的循环中要注意使vector大小发生变化的操作。</p>
<p>如果操作时关于改vector的大小的，则无法使用在string节提到的<code>range for</code>来遍历vector。</p>
<h3 id="Other-vector-Operations"><a href="#Other-vector-Operations" class="headerlink" title="Other vector Operations"></a>Other vector Operations</h3><p>对vector的操作如下表，绝大部分的含义与之前介绍的string的操作一样。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>代码示例</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>v.empty()</td>
<td>返回vector是否为空</td>
</tr>
<tr>
<td>v.size()</td>
<td>返回vector中元素的个数</td>
</tr>
<tr>
<td>v.push_back(t)</td>
<td>将一个元素加到vector最后，元素的值与t相同</td>
</tr>
<tr>
<td>v[n]</td>
<td>访问下标为n的元素</td>
</tr>
<tr>
<td>v1 = v2</td>
<td>将v1中的元素都替换为v2中元素的拷贝</td>
</tr>
<tr>
<td>v1 = {a,b,c}</td>
<td>将v1中的元素都替换为大括号内的元素</td>
</tr>
<tr>
<td>v1 == v2</td>
<td>v1与v2是否完全相同（元素个数，顺序，数值都相同）</td>
</tr>
<tr>
<td>v1 != v2</td>
<td>v1和v2是否不同</td>
</tr>
<tr>
<td>&lt;, &lt;=, &gt;, &gt;=</td>
<td>顺序排列，按字典顺序</td>
</tr>
</tbody>
</table>
</div>
<p>与string类似，size()操作返回的也是size_type，注意这里的size_type是属于实例化后的vector，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vector::size_type size = 1; //error</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::size_type size = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>与string类似，下标操作[]也必须注意元素的存在，如果通过下标访问了不存在的元素，称为缓存区溢出错误（Buffer overflow）。通常可以通过使用range for来避免下标操作，也进而避免了缓存区溢出错误。</p>
</blockquote>
<h2 id="Introducing-Iterators"><a href="#Introducing-Iterators" class="headerlink" title="Introducing Iterators"></a>Introducing Iterators</h2><p>除了Vector，标准库还定义了其他的容器（Container），所有的容器都包含迭代器操作（Iterator），但仅有部分的容器支持下标操作（<code>[]</code>）。</p>
<p>严格意义上，string并不是容器，但是string提供了非常多的容器操作。</p>
<p>迭代器有的像指针，同样提供了对象的非直接访问，而且同样也有合法和非法迭代器。一个合法的迭代器应该指向容器中一个元素或者指向容器最后的元素尾部的位置（position on past the last element）。</p>
<h3 id="Using-Iterators"><a href="#Using-Iterators" class="headerlink" title="Using Iterators"></a>Using Iterators</h3><p>通常来说，支持迭代器的类型都有两个成员迭代器，<code>begin</code>和<code>end</code>，<code>begin</code>指向容器中的第一个元素，<code>end</code>指向最后的元素尾部的位置，所以<code>end</code>指向的位置实际上并不是任何元素，<code>end</code>是一个用来标记容器尾部的指示器，通常将<code>end</code>迭代器值称为<code>off-the-end</code>迭代器。</p>
<p>如果一个容器是空的，则其<code>begin</code>和<code>end</code>指向的是同一个位置，都是<code>off-the-end</code>迭代器。</p>
<h4 id="Iterator-Operations"><a href="#Iterator-Operations" class="headerlink" title="Iterator Operations"></a>Iterator Operations</h4><p>迭代器只支持部分操作，如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>代码实例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>*iter</td>
<td>返回迭代器指向的元素的引用</td>
</tr>
<tr>
<td>iter-&gt;mem</td>
<td>访问迭代器指向元素中的成员mem，等同于(*item).mem</td>
</tr>
<tr>
<td>++iter</td>
<td>迭代器指向下一个元素的位置</td>
</tr>
<tr>
<td>—iter</td>
<td>迭代器指向上一个元素的位置</td>
</tr>
<tr>
<td>iter1 == iter2</td>
<td>判断两个迭代器是否相同，两个迭代器都指向同一元素或都指向<code>off-the-end</code>时相同</td>
</tr>
<tr>
<td>iter1 != iter2</td>
<td>判断两个迭代器是否不同</td>
</tr>
</tbody>
</table>
</div>
<p>因为end返回的并不是元素，所以不能被解引用或再使用<code>++</code>操作符。</p>
<p>因为并非所有的容器类都支持下标运算，且不一定支持关系比较，如<code>&lt;</code>和<code>&gt;</code>，所以C++程序会推荐使用迭代器并使用<code>!=</code>来进行循环操作，因为这样的实现可以适应任何的容器。</p>
<p>如下是两个等效的代码，一个对string使用下标，一个对string使用迭代器：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;Hello World!!!&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">decltype</span>(s.<span class="built_in">size</span>()) i = <span class="number">0</span>; i != s.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    s[i] = <span class="built_in">toupper</span>(s[i]);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;result is &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">s = <span class="string">&quot;Hello World!!!&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = s.<span class="built_in">begin</span>(); i != s.<span class="built_in">end</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    (*i) = <span class="built_in">toupper</span>(*i);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;result is &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">result is HELLO WORLD!!!</span></span><br><span class="line"><span class="comment">result is HELLO WORLD!!!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="Iterator-Types"><a href="#Iterator-Types" class="headerlink" title="Iterator Types"></a>Iterator Types</h4><p>像<code>size_type</code>一样，含有迭代器的类型也定义了相应的同伴类型，<code>iterator</code>和<code>const_iterator</code>，且类型是属于实例化后的类，如<code>vector&lt;int&gt;</code>。iterator和const_iterator的关系如同pointer和pointer to const，后者只能读取指向的元素，但不能修改，而且对于const对象来说，必须使用const_iterator，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v1&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">const</span> vector&lt;string&gt; v2&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator v1Iter = v1.<span class="built_in">begin</span>();</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::const_iterator v1Iter2 = v1.<span class="built_in">begin</span>();</span><br><span class="line"><span class="type">const</span> vector&lt;<span class="type">int</span>&gt;::iterator v1Iter3 = v1.<span class="built_in">begin</span>();</span><br><span class="line"><span class="comment">// (*v1Iter2) = 2;//error,can&#x27;t modify value through const_iterator</span></span><br><span class="line">++v1Iter2;</span><br><span class="line"><span class="comment">// ++v1Iter3; //can&#x27;t modify const iterator</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// vector&lt;string&gt;::iterator v2Iter = v2.begin(); //error, must beconst_iterator</span></span><br><span class="line">vector&lt;string&gt;::const_iterator v2Iter2 = v2.<span class="built_in">begin</span>();</span><br><span class="line"><span class="comment">// const vector&lt;string&gt;::iterator v2Iter3 = v2.begin(); //error,still mustbe const_iterator</span></span><br></pre></td></tr></table></figure>
<p>注意区分<code>const iterator</code>和<code>const_iterator</code>，前者类似于const pointer,指的是迭代器本身不能改变，即在初始化后无法指向其他元素，后者类似于pointer to const，指的是不能通过该迭代器修改指向的元素。</p>
<p>可以通过<code>cbegin</code>和<code>cend</code>来自动获取<code>const_iterator</code>，如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> cIter = v1.<span class="built_in">cbegin</span>();</span><br></pre></td></tr></table></figure>
<h4 id="Combining-Dereference-and-Member-Access"><a href="#Combining-Dereference-and-Member-Access" class="headerlink" title="Combining Dereference and Member Access"></a>Combining Dereference and Member Access</h4><p>可以使用<code>-&gt;</code>来取代<code>(*).</code>操作，如<code>it-&gt;empty()</code>等同于<code>(*it).empty()</code>。注意在使用后者时，必须加上括号。</p>
<p>如果去掉括号，<code>*it.empty()</code>指的是在<code>it</code>这个迭代器中寻找成员<code>empty</code>，无疑会造成编译错误。</p>
<h4 id="Some-vector-Operations-Invalidata-Iterators"><a href="#Some-vector-Operations-Invalidata-Iterators" class="headerlink" title="Some vector Operations Invalidata Iterators"></a>Some vector Operations Invalidata Iterators</h4><p>使用迭代器来执行循环操作时，也要注意循环操作造成容器大小变化时，很可能会造成循环的错误结果。</p>
<h3 id="Iterator-Arithmetic"><a href="#Iterator-Arithmetic" class="headerlink" title="Iterator Arithmetic"></a>Iterator Arithmetic</h3><p>vector和string支持一些额外的迭代器操作，如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>代码实例</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>iter + n</td>
<td>返回该迭代器后n个元素的位置</td>
</tr>
<tr>
<td>iter - n</td>
<td>返回该迭代器前n个元素的位置</td>
</tr>
<tr>
<td>iter += n</td>
<td>让迭代器指向后n个元素的位置</td>
</tr>
<tr>
<td>iter -= n</td>
<td>让迭代器指向前n个元素的位置</td>
</tr>
<tr>
<td>iter1 - iter2</td>
<td>获得两个迭代器之间的距离，即相距多少个元素</td>
</tr>
<tr>
<td>&lt;, &lt;=, &gt;, &gt;=</td>
<td>关系比较，比较迭代器指向元素的前后，越靠前越小</td>
</tr>
</tbody>
</table>
</div>
<h4 id="Arithmetic-Operations-on-Iterators"><a href="#Arithmetic-Operations-on-Iterators" class="headerlink" title="Arithmetic Operations on Iterators"></a>Arithmetic Operations on Iterators</h4><p><code>iter1 - iter2</code>操作返回的是一个名为<code>difference_type</code>的signed int类型,该类型同样属于实例化后的容器类型。</p>
<h4 id="Using-Iterator-Arithmetic"><a href="#Using-Iterator-Arithmetic" class="headerlink" title="Using Iterator Arithmetic"></a>Using Iterator Arithmetic</h4><p>使用迭代器进行二分查找例子:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">string text = <span class="string">&quot;abcdefghijk&quot;</span>;</span><br><span class="line"><span class="type">char</span> toSearch;</span><br><span class="line">cin &gt;&gt; toSearch;</span><br><span class="line"><span class="keyword">auto</span> beg = text.<span class="built_in">cbegin</span>(), end = text.<span class="built_in">cend</span>();</span><br><span class="line"><span class="keyword">auto</span> mid = beg + (end - beg) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (mid != end &amp;&amp; (*mid) != toSearch)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (toSearch &lt; (*mid))</span><br><span class="line">        end = mid;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        beg = mid + <span class="number">1</span>;</span><br><span class="line">    mid = beg + (end - beg) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; (end != mid ? <span class="string">&quot;Found&quot;</span> : <span class="string">&quot;Not Found&quot;</span>) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><h3 id="Defining-and-Initializaing-Build-in-Arrays"><a href="#Defining-and-Initializaing-Build-in-Arrays" class="headerlink" title="Defining and Initializaing Build-in Arrays"></a>Defining and Initializaing Build-in Arrays</h3><p>数组同样也是复合类型（compound type）。</p>
<p>数组的大小是数组类型的一部分，所以必须在编译阶段就确定，也因此设定数组大小的值必须是const的，且数组的定义不能使用auto，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> num = <span class="number">42</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> cnum = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="comment">// int arr2[]; //error,must indicate array size</span></span><br><span class="line"><span class="comment">// auto aarr[] = &#123;1, 2, 3&#125;; //error,can not use auto</span></span><br><span class="line"><span class="comment">// auto aarr[10]; //error,can not use auto</span></span><br><span class="line"><span class="comment">// int arr2[num]; //error,num is not const</span></span><br><span class="line"><span class="type">int</span> arr3[cnum];</span><br></pre></td></tr></table></figure>
<p>形如<code>arr3[cnum]</code>的式子，执行的是默认初始化，如果该式子出现在函数内，且其元素类型是内建类型，则值是未定义的。</p>
<p>因为引用并不是对象，所以也没有引用的数组。</p>
<h4 id="Explicitly-Initializing-Array-Elements"><a href="#Explicitly-Initializing-Array-Elements" class="headerlink" title="Explicitly Initializing Array Elements"></a>Explicitly Initializing Array Elements</h4><p>对数组可以使用列表初始化，在使用列表初始化的时候可以不指定数组的大小，此时数组的大小由列表内的元素数量决定。如果指定了数组大小，那么这个大小必须大于列表中元素的数量，在比列表元素数量大的情况下，数组中剩余的部分将进行值初始化。在不适用列表初始化的情况下，必须指定数组大小，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">unsigned</span> sz = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> ia1[sz] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> a2[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;          <span class="comment">//array size is 3</span></span><br><span class="line"><span class="type">int</span> a3[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;         <span class="comment">//array size is 5, value is 01,2,0,0</span></span><br><span class="line">string sa[sz] = &#123;<span class="string">&quot;hi&quot;</span>, <span class="string">&quot;byt&quot;</span>&#125;; <span class="comment">//size is 3,value is &quot;hi&quot;&quot;bye&quot; &quot;&quot;</span></span><br><span class="line"><span class="comment">// int a4[sz] = &#123;0, 1, 2, 3&#125;;     //error, list elements count is greater than array size</span></span><br></pre></td></tr></table></figure>
<h4 id="Character-Arrays-Are-Special"><a href="#Character-Arrays-Are-Special" class="headerlink" title="Character Arrays Are Special"></a>Character Arrays Are Special</h4><p>使用string字面值初始化char数组时要注意，string字面值最后是带有一个空白字符的，所以数组的大小应该是string字面值的大小+1。如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ca1[] = &#123;<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>&#125;;       <span class="comment">//size is 3</span></span><br><span class="line"><span class="type">char</span> ca2[] = &#123;<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;; <span class="comment">//size is 4</span></span><br><span class="line"><span class="type">char</span> ca3[] = <span class="string">&quot;abc&quot;</span>;                 <span class="comment">//size is 4</span></span><br><span class="line"><span class="comment">// const char a4[6] = &quot;Daniel&quot;;       //error,no space for \0</span></span><br></pre></td></tr></table></figure>
<h4 id="No-Copy-or-Assignment"><a href="#No-Copy-or-Assignment" class="headerlink" title="No Copy or Assignment"></a>No Copy or Assignment</h4><p>数组是没有拷贝初始化和赋值的，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="comment">// int aa[] = a;   //error</span></span><br><span class="line"><span class="comment">// int aa[] = a[]; //still error</span></span><br><span class="line"><span class="type">int</span> aa[<span class="number">3</span>];</span><br><span class="line"><span class="comment">// aa = a;         //error,can&#x27;t use assignment</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>某些编译器会允许数组的赋值，但仍然建议不要这样做，因为这不是C++标准的实现，在其他编译器中可能会引发问题。</p>
</blockquote>
<h4 id="Understanding-Complicated-Array-Declarations"><a href="#Understanding-Complicated-Array-Declarations" class="headerlink" title="Understanding Complicated Array Declarations"></a>Understanding Complicated Array Declarations</h4><p>指针的数组和数组的指针的声明会看起来有点复杂，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> array[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> *ptrs[<span class="number">10</span>]; <span class="comment">// ptrs is an array of size 10 where elementstype is int*</span></span><br><span class="line"><span class="comment">// int &amp;refs[10];//error,refs seems to be an array whereelemtns type is int&amp;, however reference is not object</span></span><br><span class="line"><span class="built_in">int</span>(*parray)[<span class="number">10</span>] = &amp;array;   <span class="comment">//parray is a pointer point toan int array of size 10</span></span><br><span class="line"><span class="built_in">int</span>(&amp;rarray)[<span class="number">10</span>] = array;    <span class="comment">//rarray is a reference bind toan int array of size 10</span></span><br><span class="line"><span class="type">int</span> *(*pparray)[<span class="number">10</span>] = &amp;ptrs; <span class="comment">//pparray is a pointer point toan int* array of size 10</span></span><br></pre></td></tr></table></figure>
<p>当没有括号将*与变量名称合在一起时，*表示元素的类型，如<code>int *ptrs[10]</code>表示<code>int*</code>的数组，当有括号时，表示变量本身的类型，如<code>int(*parray)[10] = &amp;array</code>，表示parray是一个指针，指向int[10]。</p>
<p>引用符号同理。</p>
<h3 id="Accessing-the-Elements-of-an-Array"><a href="#Accessing-the-Elements-of-an-Array" class="headerlink" title="Accessing the Elements of an Array"></a>Accessing the Elements of an Array</h3><p>当使用一个参数来作为数组的下标值时，这个参数的类型应该时<code>size_t</code>。<code>size_t</code>是一个机器相关的unsigned type。size_t定义在头文件cstddef中，该头文件是从C语言的头文件<code>stddef.h</code>改写而来。</p>
<p>同样可以使用下标和range for对数组进行操作，如下使用下标访问元素，使用range for遍历所有的元素，代码的功能是将输入的数组分类，判断有多少是在0-9范围中，有多少在10-19范围中等：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// unsigned scores[11];//warning,not defined value</span></span><br><span class="line"><span class="type">unsigned</span> scores[<span class="number">11</span>] = &#123;&#125;;</span><br><span class="line"><span class="type">unsigned</span> grade;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; grade)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (grade &lt;= <span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ++scores[grade / <span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> c : scores)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; c &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意必须对scores进行初始化。被初始化的第一条语句，执行的是默认初始化，而第二条语句<code>unsigned scores[11] = &#123;&#125;</code>使用的是值初始化。因此在函数内，后者可以保证所有的元素有确定的初始值（unsigned为0），而前者的值是未定义的。</p>
<p>如输入为<code>33 1 44 112 100 22 77 76 75 ^Z</code>，输出可能为<code>1  0  268501010  1  16713577  0  898214646  32766  8  0  1</code>，在这种情况下输出的结果是无法保证的。</p>
<p>而进行初始化的话，使用相同的输入，结果为<code>1  0  1  1  1  0  1  2  0  0  1</code>与预期结果相同。</p>
<p>在代码的最后通过range for遍历输出了scores中的元素，因为数组的大小是数组的一部分即必须在编译时确认，所以系统可以了解究竟有多少元素在数组中。</p>
<h3 id="Pointers-and-Arrays"><a href="#Pointers-and-Arrays" class="headerlink" title="Pointers and Arrays"></a>Pointers and Arrays</h3><p>在C++中，数组和指针是紧密关联的。在绝大部分表达式中，当使用数组时，编译器会将其转换为对第一个元素的指针，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">string nums[] = &#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>&#125;;</span><br><span class="line">cout &lt;&lt; (*nums) &lt;&lt; endl;</span><br><span class="line">string *p = nums;</span><br><span class="line">string *pp = &amp;nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span> (p == pp)</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;two pointers are the same&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;they are different&quot;</span> &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">one</span></span><br><span class="line"><span class="comment">two pointers are the same</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>在上例中，当使用<code>nums</code>实际上使用的是<code>&amp;nums[0]</code>，即对第一个元素的指针。</p>
<p>如使用auto也可以发现，编译器自动对数组进行了转换，如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pnums = nums; <span class="comment">// same as auto pnums = &amp;nums[0]</span></span><br><span class="line"><span class="comment">// pnums = &quot;zero&quot;;</span></span><br><span class="line">(*pnums) = <span class="string">&quot;zero&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;first element is &quot;</span> &lt;&lt; nums[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">first element is zero</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><code>pnums</code>的类型为<code>string*</code>，对pnums指向对象的操作即是对数组第一个元素的操作。</p>
<p>需要注意的是，当使用关键字<code>decltype</code>时，返回的仍然是数组类型，而不是对第一个元素的指针，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(nums) another = &#123;<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> n : another)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;value is &quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">value is abc</span></span><br><span class="line"><span class="comment">value is def</span></span><br><span class="line"><span class="comment">value is</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>如之前所述，数组的大小是数组类型的一部分，所以这里的another类型为string[3]，而列表初始化只给了两个元素，所以最有一个元素将默认为空string。</p>
<h4 id="Pointers-are-Iterators"><a href="#Pointers-are-Iterators" class="headerlink" title="Pointers are Iterators"></a>Pointers are Iterators</h4><p>对于数组中元素的指针，其支持的操作与之前提到的迭代器支持的操作一样，包括<code>++</code>,<code>--</code>，通过<code>*</code>解引用，<code>==,!=</code>，关系判断，<code>+= n</code>等。</p>
<p>如可以通过数组来进行循环遍历，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> *endPtr = &amp;arr[<span class="number">10</span>]; <span class="comment">//point to one past last elemment</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;value is: &quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> *i = arr; i != endPtr; i++)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; (*i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">value is: </span></span><br><span class="line"><span class="comment">0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>在代码中使用了<code>&amp;arr[10]</code>来获取相当于off-the-end迭代器的指针，因为其指向了最后一个元素后面的位置。在C++11标准中，可以使用函数<code>begin</code>和<code>end</code>来获取对应的迭代器的指针，如下所示，判断两种方法取得的值是否相同：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *oBeg = arr;</span><br><span class="line"><span class="type">int</span> *oEnd = &amp;arr[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> *beg = std::<span class="built_in">begin</span>(arr);</span><br><span class="line"><span class="type">int</span> *end = std::<span class="built_in">end</span>(arr);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Begin is &quot;</span> &lt;&lt; (oBeg == beg ? <span class="string">&quot;the same&quot;</span> : <span class="string">&quot;not thesame&quot;</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;End is &quot;</span> &lt;&lt; (oEnd == end ? <span class="string">&quot;the same&quot;</span> : <span class="string">&quot;not thesame&quot;</span>) &lt;&lt; endl;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Begin is the same</span></span><br><span class="line"><span class="comment">End is the same</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>下例是使用使用指针来判断两个数组是否相同的例子:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CompareTwoArray</span><span class="params">(<span class="type">int</span> *<span class="type">const</span> pb1, <span class="type">int</span> *<span class="type">const</span> pe1, <span class="type">int</span> *<span class="type">const</span> pb2, <span class="type">int</span> *<span class="type">const</span> pe2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((pe1 - pb1) != (pe2 - pb2))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//Different length</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = pb1, j = pb2; i &lt; pe1 &amp;&amp; j &lt; pe2; i++, j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((*i) != (*j))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Exercise3_36</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> arr1[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> arr2[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> arr3[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> arr4[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">CompareTwoArray</span>(<span class="built_in">begin</span>(arr1), <span class="built_in">end</span>(arr1), <span class="built_in">begin</span>(arr2), <span class="built_in">end</span>(arr2)) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">CompareTwoArray</span>(<span class="built_in">begin</span>(arr1), <span class="built_in">end</span>(arr1), <span class="built_in">begin</span>(arr3), <span class="built_in">end</span>(arr3)) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">CompareTwoArray</span>(<span class="built_in">begin</span>(arr1), <span class="built_in">end</span>(arr1), <span class="built_in">begin</span>(arr4), <span class="built_in">end</span>(arr4)) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1</span></span><br><span class="line"><span class="comment">    0</span></span><br><span class="line"><span class="comment">    0</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Pointer-Arithmetic"><a href="#Pointer-Arithmetic" class="headerlink" title="Pointer Arithmetic"></a>Pointer Arithmetic</h4><p>两个指针也是可以相减的，结果类型为<code>ptrdiff_t</code>，是一个硬件相关的类型，定义在<code>cstddef</code>头文件中。在不同的硬件上，它可能会被转换为不同的类型，如转换为long long等。</p>
<p>对不指向任何数组元素的指针进行访问，或比较两个不相关的指针是可以编译的，但其运行的结果是未定义的，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;value of end is &quot;</span> &lt;&lt; *end &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;value of end next is &quot;</span> &lt;&lt; *(++end) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>, sz = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;i, *e = &amp;sz;</span><br><span class="line">cout &lt;&lt; (p &lt; e ? <span class="string">&quot;p is smaller than e&quot;</span> : <span class="string">&quot;p is larger thane&quot;</span>) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>这些操作的结果都是未定义的，不同的硬件，不同的编译器甚至不同的运行时间都会造成不同的结果。</p>
<h4 id="Interaction-between-Dereference-and-Pointer-Arithmetic"><a href="#Interaction-between-Dereference-and-Pointer-Arithmetic" class="headerlink" title="Interaction between Dereference and Pointer Arithmetic"></a>Interaction between Dereference and Pointer Arithmetic</h4><p>在对指针进行解引用时，括号的使用会影响结果,如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ia[] = &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>&#125;;</span><br><span class="line">cout &lt;&lt; *(ia + <span class="number">4</span>) &lt;&lt; endl;<span class="comment">//Access the fifth element</span></span><br><span class="line">cout &lt;&lt; *ia + <span class="number">4</span> &lt;&lt; endl;<span class="comment">//Access the first element and add 4to the result</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="Subscripts-and-Pointers"><a href="#Subscripts-and-Pointers" class="headerlink" title="Subscripts and Pointers"></a>Subscripts and Pointers</h4><p>可以对任何指针使用下标，但是大多数情况下，只有对指向数组中元素的指针使用下标才有意义，剩下的都是未定义的结果，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ia[] = &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>&#125;;</span><br><span class="line"><span class="type">int</span> *iaP = &amp;ia[<span class="number">2</span>];</span><br><span class="line">cout &lt;&lt; *iaP &lt;&lt; endl;       <span class="comment">//Third element</span></span><br><span class="line">cout &lt;&lt; iaP[<span class="number">-2</span>] &lt;&lt; endl;    <span class="comment">//First element</span></span><br><span class="line">cout &lt;&lt; *(iaP - <span class="number">2</span>) &lt;&lt; endl; <span class="comment">//First element,same with lastexpression</span></span><br><span class="line">cout &lt;&lt; iaP[<span class="number">-3</span>] &lt;&lt; endl;    <span class="comment">//undefined result</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> *ap = &amp;a;</span><br><span class="line">cout &lt;&lt; ap[<span class="number">0</span>] &lt;&lt; endl;  <span class="comment">// a</span></span><br><span class="line">cout &lt;&lt; ap[<span class="number">-1</span>] &lt;&lt; endl; <span class="comment">//undefined result</span></span><br></pre></td></tr></table></figure>
<p>如上所示，通过解引用符号*对指针的访问，相当于使用<code>[0]</code>操作,因此如<code>iaP[-2]</code>和<code>*(iaP - 2)</code>是等效的。</p>
<h3 id="C-Style-Character-Strings"><a href="#C-Style-Character-Strings" class="headerlink" title="C-Style Character Strings"></a>C-Style Character Strings</h3><p>C++中的string字面值实际上是继承自C语言的。通过C++的string存储string字面值会将其转换为string类型，但如果要完全体现String字面值（C风格的String）本身的特性，可以使用char数组或者指针，如<code>char str[] = &quot;ABC&quot;;</code>，该数组的大小为4，因为还有在最后包含一个空字符。</p>
<p>在<code>cstring</code>头文件中，定义了对C-style的string操作的方法，如下表所示</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>代码实例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>strlen(p)</td>
<td>返回p的长度，不包含最后的空字符</td>
</tr>
<tr>
<td>strcmp(p1,p2)</td>
<td>判断两个字符串的大小，p1大于p2返回正数，小于p2返回负数，等于p2返回0</td>
</tr>
<tr>
<td>strcat(p1,p2)</td>
<td>将p2的内容添加到p1后，返回p1</td>
</tr>
<tr>
<td>strcpy(p1,p2)</td>
<td>将p2的内容拷贝到p1中，返回p1</td>
</tr>
</tbody>
</table>
</div>
<p>对C-Style字符串（使用char数组或指针）进行判断，必须使用<code>strcmp</code>，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">string s1 = <span class="string">&quot;A string example&quot;</span>;</span><br><span class="line">string s2 = <span class="string">&quot;A different string&quot;</span>;</span><br><span class="line">cout &lt;&lt; (s1 &gt; s2) &lt;&lt; endl;</span><br><span class="line"><span class="type">char</span> cs1[] = <span class="string">&quot;A string example&quot;</span>;</span><br><span class="line"><span class="type">char</span> cs2[] = <span class="string">&quot;A different string&quot;</span>;</span><br><span class="line">cout &lt;&lt; (cs1 &gt; cs2) &lt;&lt; endl;      <span class="comment">//wrong way,no meaning, iscomparing address of first element</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">strcmp</span>(cs1, cs2) &lt;&lt; endl; <span class="comment">//correct way</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Although cs1&gt;cs1 also yield correct result,but it&#x27;s nomeaning.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="Caller-is-Responsible-for-Size-of-a-Destination-String"><a href="#Caller-is-Responsible-for-Size-of-a-Destination-String" class="headerlink" title="Caller is Responsible for Size of a Destination String"></a>Caller is Responsible for Size of a Destination String</h4><p>使用C-Stype字符串相关操作时需要额外的小心，如<code>strcat</code>和<code>strcpy</code>操作，并不会检查第一个参数，即装填最终结果的数组的大小，如果数组大小不满足，则会产生错误结果。</p>
<p>另外<code>strlen</code>的长度通常是通过找寻C-Style字符串最后的空字符来实现的，如果参数是一个没有空字符的C-Style字符串，那么结果是未定义的，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ca[]&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">strlen</span>(ca) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">21</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>这里的21即是一个未定义的结果，在不同情况下结果会不同。在通常的编译器实现下，strlen会一直向后遍历内存，直到找到一块内存其中值未空白字符。</p>
<p>也正因为使用C-Style字符串需要额外的小心，一般现代C++程序推荐使用标准库中的string类型。</p>
<h3 id="Interfacing-to-Older-Code"><a href="#Interfacing-to-Older-Code" class="headerlink" title="Interfacing to Older Code"></a>Interfacing to Older Code</h3><p>在之前已经说明了，可以使用字符串字面值来直接初始化标准库中的string类型，更通常来说，可以使用任何最后是空白字符结尾的C-Style字符串直接转换为标准库中的string类型。如果C-Style字符串结尾不是空白字符，同样结果是未定义的。如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;ABCD&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;value is &quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;, size is &quot;</span> &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"><span class="type">char</span> cs[]&#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line">string sc = cs;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;value is &quot;</span> &lt;&lt; sc &lt;&lt; <span class="string">&quot;, size is &quot;</span> &lt;&lt; sc.<span class="built_in">size</span>() &lt;&lt;endl;</span><br><span class="line"><span class="type">char</span> cs2[]&#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>&#125;;</span><br><span class="line">string sc2 = cs2;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;value is &quot;</span> &lt;&lt; sc2 &lt;&lt; <span class="string">&quot;, size is &quot;</span> &lt;&lt; sc2.<span class="built_in">size</span>() &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">value is ABCD, size is 4</span></span><br><span class="line"><span class="comment">value is ABCD, size is 4</span></span><br><span class="line"><span class="comment">value is ABCD慅a, size is 7</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>相反，无法直接将string转换为C-Style字符串，但可以通过string的成员函数<code>c_str</code>将结果转换为<code>const char *</code>。</p>
<p>需要注意的是，c_str返回的是字符串第一个元素的指针，且最后是由空字符结尾，并且标准库的string值改变的话，对应返回的数据也会自动改变，如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;ABCD&quot;</span>;</span><br><span class="line"><span class="comment">// char *cs3 = s; //error,can&#x27;t direct convert</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *cs3 = s.<span class="built_in">c_str</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;value is &quot;</span> &lt;&lt; cs3 &lt;&lt; endl;</span><br><span class="line">s = <span class="string">&quot;DEFC&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;value is &quot;</span> &lt;&lt; cs3 &lt;&lt; endl;</span><br><span class="line">string css = cs3;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;value is &quot;</span> &lt;&lt; css &lt;&lt; <span class="string">&quot;, size is &quot;</span> &lt;&lt; css.<span class="built_in">size</span>() &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">value is ABCD</span></span><br><span class="line"><span class="comment">value is DEFC</span></span><br><span class="line"><span class="comment">value is DEFC, size is 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="Using-an-Array-to-Initialize-a-vector"><a href="#Using-an-Array-to-Initialize-a-vector" class="headerlink" title="Using an Array to Initialize a vector"></a>Using an Array to Initialize a vector</h4><p>如前所述，无法直接通过一个数组初始化另一个数组。同样的，无法通过一个vector直接初始化一个数组，但却可以通过指向数组元素的指针来初始化vector，如下所示</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> intArr[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intVec</span><span class="params">(begin(intArr), end(intArr))</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : intVec)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">intVec = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(intArr, intArr + <span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : intVec)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0 1 2 3 4 5 </span></span><br><span class="line"><span class="comment">0 1 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>代码的前半段是使用begin和end函数来获取第一个元素指针和off-the-end指针，这样就是完整拷贝了数组的元素到新vector中。</p>
<p>后半段是直接使用指针操作，需要注意的是传入的第二个参数是指向vector最后一个元素的内存尾部的地址。因此代码中第二个参数为<code>intArr+3</code>，但实际上Vectr中最后一个参数值是<code>*(intArr+2)</code>。</p>
<p>创建的vector和原数组是不同的内存，因此创建完后，修改原数组并不会对vector中的元素造成影响。</p>
<h2 id="Multidimensional-Arrays"><a href="#Multidimensional-Arrays" class="headerlink" title="Multidimensional Arrays"></a>Multidimensional Arrays</h2><p>C++并没有多维数组的概念，实际上多维数组的实现是通过数组的数组。如<code>ia[3][4]</code>可以看作是一个三行四列的数组。对于多维数组必须指定维度，不能初始值来推断。</p>
<h3 id="Initializing-the-Elements-of-a-Multidimensional-Array"><a href="#Initializing-the-Elements-of-a-Multidimensional-Array" class="headerlink" title="Initializing the Elements of a Multidimensional Array"></a>Initializing the Elements of a Multidimensional Array</h3><p>以下是初始化多维数组的几种方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ia[<span class="number">3</span>][<span class="number">4</span>];   <span class="comment">//without initialization;</span></span><br><span class="line"><span class="type">int</span> ib[<span class="number">3</span>][<span class="number">4</span>]&#123;&#125;; <span class="comment">//All elements will be 0</span></span><br><span class="line"><span class="type">int</span> ic[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;, &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> id[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;;</span><br><span class="line"><span class="type">int</span> ie[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0</span>&#125;, &#123;<span class="number">4</span>&#125;, &#123;<span class="number">8</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> ix[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">4</span>, <span class="number">8</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>其中<code>ic</code>和<code>id</code>的初始化结果是相同的，<code>ie</code>是初始化了每一行的第一个元素的值，<code>ix</code>的初始化了第一行的前三个元素，之后的元素都会被装填为0（进行了值初始化）。</p>
<h3 id="Subscripting-a-Multidimentional-Array"><a href="#Subscripting-a-Multidimentional-Array" class="headerlink" title="Subscripting a Multidimentional Array"></a>Subscripting a Multidimentional Array</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ia[<span class="number">3</span>][<span class="number">4</span>]= = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;, &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;&#125;;</span><br><span class="line"><span class="built_in">int</span> (&amp;row)[<span class="number">4</span>] = ia[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<p>其中<code>ia[0]</code>表示第一行，是一个长度为4的int数组。row是一个绑定至长度为4的int数组的引用。</p>
<p>可以使用下标来遍历数组，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ic[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;, &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; ic[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0 1 2 3 4 5 6 7 8 9 10 11</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="Using-a-Range-for-with-Multidimentsional-Arrays"><a href="#Using-a-Range-for-with-Multidimentsional-Arrays" class="headerlink" title="Using a Range for with Multidimentsional Arrays"></a>Using a Range for with Multidimentsional Arrays</h3><p>当使用C++ 11标准的<code>range for</code>遍历多维数组时，需要注意除了最内侧的数组外，外层的遍历都需要用引用，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ic[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;, &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;row : ic)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;col : row)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; col &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;row : ic)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> col : row)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; col &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for (auto row : ic)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     for (auto col : row)</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//         cout &lt;&lt; col &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0 1 2 3 4 5 6 7 8 9 10 11 </span></span><br><span class="line"><span class="comment">0 1 2 3 4 5 6 7 8 9 10 11</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，第一部分是两层循环都使用了引用，第二部分是之后外层循环使用了引用，第三部分是两层循环都没有使用引用。第一部分和第二部分都得到了理想的结果，而第三部分是无法通过编译的。</p>
<p>当外层循环的row不是引用时，编译器会自动将其转换为指针，即row的类型会变为<code>int *</code>，指向每一行数组的第一个元素，而对于指针没法使用range for，所以会出现编译错误。</p>
<h4 id="Pointers-and-Multidimensional-Arrays"><a href="#Pointers-and-Multidimensional-Arrays" class="headerlink" title="Pointers and Multidimensional Arrays"></a>Pointers and Multidimensional Arrays</h4><p>首先要注意数组与指针的关系，式子<code>int *ip[4]</code>表示ip是一个长度为4的数组，其中元素类型为int*。式子<code>int (*ip)[4]</code>表示ip是一个指针，指向长度为4的数组。</p>
<p>可以使用指针来遍历数组，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ic[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;, &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span>(*p)[<span class="number">4</span>] = ic; p != ic + <span class="number">3</span>; ++p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> *q = (*p); q != (*p) + <span class="number">4</span>; q++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; (*q) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0 1 2 3 4 5 6 7 8 9 10 11 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>注意外部循环中遍历p的类型是<code>int (*)[4]</code>，即指向大小为4的数组的指针，将ic赋值给p，是因为编译器会自动的将数组转换为指向第一个元素的指针，在外部循环中，第一个元素是数组。在内部循环中，初始值是(*p)，即是一个大小为4的数组，同样编译器会将其转换为第一个元素的指针，即int*。</p>
<p>如之前节所示，可以用begin和end简化代码，如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span>(*p)[<span class="number">4</span>] = <span class="built_in">begin</span>(ic); p != <span class="built_in">end</span>(ic); ++p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> *q = <span class="built_in">begin</span>(*p); q != <span class="built_in">end</span>(*p); q++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; (*q) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0 1 2 3 4 5 6 7 8 9 10 11 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="Type-Aliases-Simplify-Pointers-to-Multidimensional-Arrays"><a href="#Type-Aliases-Simplify-Pointers-to-Multidimensional-Arrays" class="headerlink" title="Type Aliases Simplify Pointers to Multidimensional Arrays"></a>Type Aliases Simplify Pointers to Multidimensional Arrays</h4><p>可以通过为int数组取一个别名来简化代码，如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// using int_array = int[4];</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> int_array[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ic[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;, &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">for</span> (int_array *p = ic; p != ic + <span class="number">3</span>; ++p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> *q = (*p); q != (*p) + <span class="number">4</span>; q++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; (*q) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0 1 2 3 4 5 6 7 8 9 10 11</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>示例中，将长度为4的int数组称为int_array。示例中使用using和typedef是等效的。</p>
<div class="note info simple"><p>引用：</p>
<ol>
<li><em>Cpp Primer</em> 5th Aug.2012</li>
</ol>
</div>
<hr>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="Tuncle">三叔</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://tuncle.blog/CPPPrimer-Chapter3-Notes/">https://tuncle.blog/CPPPrimer-Chapter3-Notes/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://tuncle.blog" target="_blank">三叔胡言乱语的地方</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="twitter, wechat, weibo"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/CPPPrimer-Chapter4-Notes/" title="《C++ Primer》 第四章笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">《C++ Primer》 第四章笔记</div></div></a></div><div class="next-post pull-right"><a href="/CPPPrimer-Chapter2-Notes/" title="《C++ Primer》 第二章笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">《C++ Primer》 第二章笔记</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-3-String-Vectors-And-Arrays"><span class="toc-number">1.</span> <span class="toc-text">Chapter 3 String, Vectors, And Arrays</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Namespace-using-Declarations"><span class="toc-number">1.1.</span> <span class="toc-text">Namespace using Declarations</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Header-Should-not-include-using-Declarations"><span class="toc-number">1.1.1.</span> <span class="toc-text">Header Should not include using Declarations</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Library-string-Type"><span class="toc-number">1.2.</span> <span class="toc-text">Library string Type</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Defining-and-Initializing-strings"><span class="toc-number">1.2.1.</span> <span class="toc-text">Defining and Initializing strings</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Direct-and-Copy-Forms-of-Initialization"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">Direct and Copy Forms of Initialization</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Operations-on-strings"><span class="toc-number">1.2.2.</span> <span class="toc-text">Operations on strings</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Reading-and-Writing-strings"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">Reading and Writing strings</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#The-string-size-type-Type"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">The string::size_type Type</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Adding-Literals-and-strings"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">Adding Literals and strings</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dealing-with-the-Characters-in-a-string"><span class="toc-number">1.2.3.</span> <span class="toc-text">Dealing with the Characters in a string</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Processing-Every-Character-Use-Range-Based-for"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">Processing Every Character? Use Range-Based for</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Using-a-Range-for-to-Change-the-Characters-in-a-string"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">Using a Range for to Change the Characters in a string</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Using-a-Subsctipt-for-Iteration"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">Using a Subsctipt for Iteration</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Library-vector-Type"><span class="toc-number">1.3.</span> <span class="toc-text">Library vector Type</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Defining-and-Initializing-vectors"><span class="toc-number">1.3.1.</span> <span class="toc-text">Defining and Initializing vectors</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Value-Initialization-and-Default-Initialization"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">Value Initialization and Default Initialization</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Adding-Elements-to-a-vector"><span class="toc-number">1.3.2.</span> <span class="toc-text">Adding Elements to a vector</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Programming-Implications-of-Adding-Elements-to-a-vector"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">Programming Implications of Adding Elements to a vector</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Other-vector-Operations"><span class="toc-number">1.3.3.</span> <span class="toc-text">Other vector Operations</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Introducing-Iterators"><span class="toc-number">1.4.</span> <span class="toc-text">Introducing Iterators</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Using-Iterators"><span class="toc-number">1.4.1.</span> <span class="toc-text">Using Iterators</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Iterator-Operations"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">Iterator Operations</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Iterator-Types"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">Iterator Types</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Combining-Dereference-and-Member-Access"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">Combining Dereference and Member Access</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Some-vector-Operations-Invalidata-Iterators"><span class="toc-number">1.4.1.4.</span> <span class="toc-text">Some vector Operations Invalidata Iterators</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Iterator-Arithmetic"><span class="toc-number">1.4.2.</span> <span class="toc-text">Iterator Arithmetic</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Arithmetic-Operations-on-Iterators"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">Arithmetic Operations on Iterators</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Using-Iterator-Arithmetic"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">Using Iterator Arithmetic</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Arrays"><span class="toc-number">1.5.</span> <span class="toc-text">Arrays</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Defining-and-Initializaing-Build-in-Arrays"><span class="toc-number">1.5.1.</span> <span class="toc-text">Defining and Initializaing Build-in Arrays</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Explicitly-Initializing-Array-Elements"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">Explicitly Initializing Array Elements</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Character-Arrays-Are-Special"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">Character Arrays Are Special</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#No-Copy-or-Assignment"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">No Copy or Assignment</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Understanding-Complicated-Array-Declarations"><span class="toc-number">1.5.1.4.</span> <span class="toc-text">Understanding Complicated Array Declarations</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Accessing-the-Elements-of-an-Array"><span class="toc-number">1.5.2.</span> <span class="toc-text">Accessing the Elements of an Array</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pointers-and-Arrays"><span class="toc-number">1.5.3.</span> <span class="toc-text">Pointers and Arrays</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Pointers-are-Iterators"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">Pointers are Iterators</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Pointer-Arithmetic"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">Pointer Arithmetic</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Interaction-between-Dereference-and-Pointer-Arithmetic"><span class="toc-number">1.5.3.3.</span> <span class="toc-text">Interaction between Dereference and Pointer Arithmetic</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Subscripts-and-Pointers"><span class="toc-number">1.5.3.4.</span> <span class="toc-text">Subscripts and Pointers</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-Style-Character-Strings"><span class="toc-number">1.5.4.</span> <span class="toc-text">C-Style Character Strings</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Caller-is-Responsible-for-Size-of-a-Destination-String"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">Caller is Responsible for Size of a Destination String</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Interfacing-to-Older-Code"><span class="toc-number">1.5.5.</span> <span class="toc-text">Interfacing to Older Code</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Using-an-Array-to-Initialize-a-vector"><span class="toc-number">1.5.5.1.</span> <span class="toc-text">Using an Array to Initialize a vector</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Multidimensional-Arrays"><span class="toc-number">1.6.</span> <span class="toc-text">Multidimensional Arrays</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Initializing-the-Elements-of-a-Multidimensional-Array"><span class="toc-number">1.6.1.</span> <span class="toc-text">Initializing the Elements of a Multidimensional Array</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Subscripting-a-Multidimentional-Array"><span class="toc-number">1.6.2.</span> <span class="toc-text">Subscripting a Multidimentional Array</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Using-a-Range-for-with-Multidimentsional-Arrays"><span class="toc-number">1.6.3.</span> <span class="toc-text">Using a Range for with Multidimentsional Arrays</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Pointers-and-Multidimensional-Arrays"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">Pointers and Multidimensional Arrays</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Type-Aliases-Simplify-Pointers-to-Multidimensional-Arrays"><span class="toc-number">1.6.3.2.</span> <span class="toc-text">Type Aliases Simplify Pointers to Multidimensional Arrays</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 By 三叔</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Keep Writing</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'TGA1EB8Nf5aw6uJBpw45pBJQ-gzGzoHsz',
      appKey: 'z1vCYavVUbCGuMjNMcrsvShN',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: true
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>